
qsys_webserver.elf:     file format elf32-littlenios2
qsys_webserver.elf
architecture: nios2, flags 0x00000112:
EXEC_P, HAS_SYMS, D_PAGED
start address 0x020001bc

Program Header:
    LOAD off    0x00001000 vaddr 0x00000000 paddr 0x00000000 align 2**12
         filesz 0x00000000 memsz 0x00000000 flags r-x
    LOAD off    0x00001020 vaddr 0x02000020 paddr 0x02000020 align 2**12
         filesz 0x000541f4 memsz 0x0063e19c flags rwx

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .entry        00000000  00000000  00000000  00001000  2**5
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .exceptions   0000019c  02000020  02000020  00001020  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .text         0004bf6c  020001bc  020001bc  000011bc  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  3 .rodata       00006080  0204c128  0204c128  0004d128  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  4 .rwdata       0000206c  020521a8  020521a8  000531a8  2**2
                  CONTENTS, ALLOC, LOAD, DATA, SMALL_DATA
  5 .bss          005ea255  02054214  02054214  00055214  2**2
                  ALLOC, SMALL_DATA
  6 .comment      00000023  00000000  00000000  00055214  2**0
                  CONTENTS, READONLY
  7 .debug_aranges 00001f88  00000000  00000000  00055238  2**3
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_info   0007b5b3  00000000  00000000  000571c0  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_abbrev 000189f2  00000000  00000000  000d2773  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_line   000201ca  00000000  00000000  000eb165  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_frame  00006f1c  00000000  00000000  0010b330  2**2
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    0000c25b  00000000  00000000  0011224c  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00021812  00000000  00000000  0011e4a7  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_alt_sim_info 00000050  00000000  00000000  0013fcbc  2**2
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_ranges 00000ef8  00000000  00000000  0013fd10  2**3
                  CONTENTS, READONLY, DEBUGGING
 16 .thread_model 00000006  00000000  00000000  0014bf37  2**0
                  CONTENTS, READONLY
 17 .cpu          00000005  00000000  00000000  0014bf3d  2**0
                  CONTENTS, READONLY
 18 .qsys         00000001  00000000  00000000  0014bf42  2**0
                  CONTENTS, READONLY
 19 .simulation_enabled 00000001  00000000  00000000  0014bf43  2**0
                  CONTENTS, READONLY
 20 .sysid_hash   00000004  00000000  00000000  0014bf44  2**0
                  CONTENTS, READONLY
 21 .sysid_base   00000004  00000000  00000000  0014bf48  2**0
                  CONTENTS, READONLY
 22 .sysid_time   00000004  00000000  00000000  0014bf4c  2**0
                  CONTENTS, READONLY
 23 .stderr_dev   00000009  00000000  00000000  0014bf50  2**0
                  CONTENTS, READONLY
 24 .stdin_dev    00000009  00000000  00000000  0014bf59  2**0
                  CONTENTS, READONLY
 25 .stdout_dev   00000009  00000000  00000000  0014bf62  2**0
                  CONTENTS, READONLY
 26 .sopc_system_name 00000007  00000000  00000000  0014bf6b  2**0
                  CONTENTS, READONLY
 27 .quartus_project_dir 00000024  00000000  00000000  0014bf72  2**0
                  CONTENTS, READONLY
 28 .sopcinfo     00082060  00000000  00000000  0014bf96  2**0
                  CONTENTS, READONLY
SYMBOL TABLE:
00000000 l    d  .entry	00000000 .entry
02000020 l    d  .exceptions	00000000 .exceptions
020001bc l    d  .text	00000000 .text
0204c128 l    d  .rodata	00000000 .rodata
020521a8 l    d  .rwdata	00000000 .rwdata
02054214 l    d  .bss	00000000 .bss
00000000 l    d  .comment	00000000 .comment
00000000 l    d  .debug_aranges	00000000 .debug_aranges
00000000 l    d  .debug_info	00000000 .debug_info
00000000 l    d  .debug_abbrev	00000000 .debug_abbrev
00000000 l    d  .debug_line	00000000 .debug_line
00000000 l    d  .debug_frame	00000000 .debug_frame
00000000 l    d  .debug_str	00000000 .debug_str
00000000 l    d  .debug_loc	00000000 .debug_loc
00000000 l    d  .debug_alt_sim_info	00000000 .debug_alt_sim_info
00000000 l    d  .debug_ranges	00000000 .debug_ranges
00000000 l    df *ABS*	00000000 F:/Qsys/qsys_webserver/qsys/software/qsys_webserver_bsp//obj/HAL/src/crt0.o
02000200 l       .text	00000000 alt_after_alt_main
00000000 l    df *ABS*	00000000 alt_exception_entry.o
02000094 l       .exceptions	00000000 alt_exception_unknown
00000000 l    df *ABS*	00000000 alt_irq_handler.c
00000000 l    df *ABS*	00000000 alt_error_handler.c
00000000 l    df *ABS*	00000000 http.c
0204c77c l     O .rodata	0000015f canned_http_response
0204c8dc l     O .rodata	000000eb canned_response2
020543f8 l     O .bss	0000cb10 conn.5350
00000000 l    df *ABS*	00000000 network_utilities.c
00000000 l    df *ABS*	00000000 srec_flash.c
00000000 l    df *ABS*	00000000 web_server.c
020042dc l     F .text	000000e0 WSCreateTasks
00000000 l    df *ABS*	00000000 atoi.c
00000000 l    df *ABS*	00000000 ctype_.c
0204d4dd l     O .rodata	00000180 _ctype_b
00000000 l    df *ABS*	00000000 fclose.c
00000000 l    df *ABS*	00000000 fflush.c
00000000 l    df *ABS*	00000000 fgetpos.c
00000000 l    df *ABS*	00000000 findfp.c
0200489c l     F .text	00000008 __fp_lock
020048a4 l     F .text	00000008 __fp_unlock
00000000 l    df *ABS*	00000000 fopen.c
00000000 l    df *ABS*	00000000 fprintf.c
00000000 l    df *ABS*	00000000 fread.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 fseek.c
00000000 l    df *ABS*	00000000 fstatr.c
00000000 l    df *ABS*	00000000 ftell.c
00000000 l    df *ABS*	00000000 fwalk.c
00000000 l    df *ABS*	00000000 fwrite.c
00000000 l    df *ABS*	00000000 getc.c
00000000 l    df *ABS*	00000000 impure.c
020521c0 l     O .rwdata	00000400 impure_data
00000000 l    df *ABS*	00000000 int_errno.c
00000000 l    df *ABS*	00000000 makebuf.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 memcpy.c
00000000 l    df *ABS*	00000000 memmove.c
00000000 l    df *ABS*	00000000 memset.c
00000000 l    df *ABS*	00000000 openr.c
00000000 l    df *ABS*	00000000 perror.c
00000000 l    df *ABS*	00000000 printf.c
00000000 l    df *ABS*	00000000 putc.c
00000000 l    df *ABS*	00000000 putchar.c
00000000 l    df *ABS*	00000000 puts.c
00000000 l    df *ABS*	00000000 refill.c
02006cc8 l     F .text	0000001c lflush
00000000 l    df *ABS*	00000000 rget.c
00000000 l    df *ABS*	00000000 sbrkr.c
00000000 l    df *ABS*	00000000 sprintf.c
00000000 l    df *ABS*	00000000 sscanf.c
02007058 l     F .text	00000008 eofread
00000000 l    df *ABS*	00000000 stdio.c
00000000 l    df *ABS*	00000000 strcasecmp.c
00000000 l    df *ABS*	00000000 strcat.c
00000000 l    df *ABS*	00000000 strchr.c
00000000 l    df *ABS*	00000000 strcmp.c
00000000 l    df *ABS*	00000000 strcpy.c
00000000 l    df *ABS*	00000000 strerror.c
00000000 l    df *ABS*	00000000 strlen.c
00000000 l    df *ABS*	00000000 strncmp.c
00000000 l    df *ABS*	00000000 strncpy.c
00000000 l    df *ABS*	00000000 strstr.c
02007ea4 l     F .text	00000124 critical_factorization
02007fc8 l     F .text	0000036c two_way_long_needle
00000000 l    df *ABS*	00000000 strtok.c
00000000 l    df *ABS*	00000000 strtok_r.c
00000000 l    df *ABS*	00000000 strtol.c
00000000 l    df *ABS*	00000000 u_strerr.c
00000000 l    df *ABS*	00000000 vfprintf.c
020089fc l     F .text	00000034 __sprint_r
0204de52 l     O .rodata	00000010 blanks.3515
0204de62 l     O .rodata	00000010 zeroes.3516
00000000 l    df *ABS*	00000000 vfscanf.c
0204de7a l     O .rodata	00000022 basefix.3427
00000000 l    df *ABS*	00000000 wbuf.c
00000000 l    df *ABS*	00000000 writer.c
00000000 l    df *ABS*	00000000 wsetup.c
00000000 l    df *ABS*	00000000 closer.c
00000000 l    df *ABS*	00000000 dtoa.c
0200c320 l     F .text	00000208 quorem
00000000 l    df *ABS*	00000000 flags.c
00000000 l    df *ABS*	00000000 fputc.c
00000000 l    df *ABS*	00000000 fputs.c
00000000 l    df *ABS*	00000000 fvwrite.c
00000000 l    df *ABS*	00000000 isattyr.c
00000000 l    df *ABS*	00000000 iswspace.c
00000000 l    df *ABS*	00000000 locale.c
0204debc l     O .rodata	00000030 lconv
00000000 l    df *ABS*	00000000 lseekr.c
00000000 l    df *ABS*	00000000 mbrtowc.c
00000000 l    df *ABS*	00000000 mbtowc_r.c
00000000 l    df *ABS*	00000000 memchr.c
00000000 l    df *ABS*	00000000 memcmp.c
00000000 l    df *ABS*	00000000 mprec.c
0204e004 l     O .rodata	0000000c p05.2435
00000000 l    df *ABS*	00000000 readr.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 s_isinfd.c
00000000 l    df *ABS*	00000000 s_isnand.c
00000000 l    df *ABS*	00000000 sccl.c
00000000 l    df *ABS*	00000000 sf_nan.c
00000000 l    df *ABS*	00000000 strtod.c
020529d4 l     O .rwdata	00000014 fpi.2015
0204e020 l     O .rodata	00000028 tinytens
020529e8 l     O .rwdata	00000014 fpinan.2051
00000000 l    df *ABS*	00000000 strtoll_r.c
00000000 l    df *ABS*	00000000 strtoul.c
00000000 l    df *ABS*	00000000 strtoull_r.c
00000000 l    df *ABS*	00000000 ungetc.c
00000000 l    df *ABS*	00000000 mallocr.c
00000000 l    df *ABS*	00000000 gdtoa-gethex.c
02011fd8 l     F .text	00000110 rshift
00000000 l    df *ABS*	00000000 gdtoa-hexnan.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
02013880 l     F .text	00000354 _fpadd_parts
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 lib2-divmod.c
0201467c l     F .text	00000074 udivmodsi4
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 libgcc2.c
00000000 l    df *ABS*	00000000 fp-bit.c
00000000 l    df *ABS*	00000000 alt_dcache_flush.c
00000000 l    df *ABS*	00000000 alt_flash_dev.c
00000000 l    df *ABS*	00000000 alt_fstat.c
020150e0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_isatty.c
020151dc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_lseek.c
020152cc l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_main.c
00000000 l    df *ABS*	00000000 alt_open.c
020154b8 l     F .text	00000050 alt_get_errno
02015508 l     F .text	000000cc alt_file_locked
00000000 l    df *ABS*	00000000 alt_release_fd.c
00000000 l    df *ABS*	00000000 alt_sbrk.c
020540f0 l     O .rwdata	00000004 heap_end
00000000 l    df *ABS*	00000000 alt_tick.c
00000000 l    df *ABS*	00000000 alt_env_lock.c
020540fc l     O .rwdata	00000004 lockid
0205425c l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 alt_malloc_lock.c
02054100 l     O .rwdata	00000004 lockid
02054264 l     O .bss	00000004 locks
00000000 l    df *ABS*	00000000 os_core.c
020172e0 l     F .text	00000044 OS_InitMisc
02017324 l     F .text	0000006c OS_InitRdyList
02017488 l     F .text	000000e0 OS_InitTCBList
02017204 l     F .text	000000dc OS_InitEventList
02017390 l     F .text	0000007c OS_InitTaskIdle
0201740c l     F .text	0000007c OS_InitTaskStat
020176f4 l     F .text	00000070 OS_SchedNew
00000000 l    df *ABS*	00000000 os_dbg.c
00000000 l    df *ABS*	00000000 os_flag.c
02019500 l     F .text	0000010c OS_FlagTaskRdy
0201925c l     F .text	000001c0 OS_FlagBlock
00000000 l    df *ABS*	00000000 os_mbox.c
00000000 l    df *ABS*	00000000 os_mem.c
00000000 l    df *ABS*	00000000 os_q.c
00000000 l    df *ABS*	00000000 os_sem.c
00000000 l    df *ABS*	00000000 os_task.c
00000000 l    df *ABS*	00000000 os_time.c
00000000 l    df *ABS*	00000000 alt_sys_init.c
0201e638 l     F .text	00000038 alt_dev_reg
020529fc l     O .rwdata	000000c8 epcs_flash_controller
02052ac4 l     O .rwdata	0000106c jtag_uart
02053b30 l     O .rwdata	00000030 sgdma_rx
02053b60 l     O .rwdata	00000030 sgdma_tx
02053b90 l     O .rwdata	00000030 altera_ro_zipfs
00000000 l    df *ABS*	00000000 altera_avalon_epcs_flash_controller.c
0201e910 l     F .text	00000038 alt_flash_device_register
0201e99c l     F .text	0000028c alt_epcs_flash_query
0201ec28 l     F .text	000000e8 alt_epcs_flash_memcmp
0201effc l     F .text	00000094 alt_epcs_test_address
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_fd.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_init.c
0201f540 l     F .text	000002ac altera_avalon_jtag_uart_irq
0201f7ec l     F .text	0000010c altera_avalon_jtag_uart_timeout
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_ioctl.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_read.c
00000000 l    df *ABS*	00000000 altera_avalon_jtag_uart_write.c
00000000 l    df *ABS*	00000000 altera_avalon_sgdma.c
0201ffe8 l     F .text	00000050 alt_get_errno
02020b8c l     F .text	000000b8 alt_avalon_sgdma_irq
00000000 l    df *ABS*	00000000 altera_avalon_timer_sc.c
02020ce8 l     F .text	00000074 alt_avalon_timer_sc_irq
00000000 l    df *ABS*	00000000 altera_ro_zipfs.c
02020de4 l     F .text	00000068 read_word
02020e4c l     F .text	00000054 read_word_inc
02020ea0 l     F .text	00000068 read_half_word
02020f08 l     F .text	00000054 read_half_word_inc
02020f5c l     F .text	00000120 check_file_header
020211b0 l     F .text	000000a4 check_directory_table
02021254 l     F .text	000000ac find_directory_entry
02021300 l     F .text	000001cc find_file_entry_by_name
020214cc l     F .text	0000019c find_file_entry
00000000 l    df *ABS*	00000000 epcs_commands.c
02021a74 l     F .text	00000038 epcs_test_wip
02021aac l     F .text	00000038 epcs_await_wip_released
00000000 l    df *ABS*	00000000 ins_tse_mac.c
00000000 l    df *ABS*	00000000 alt_iniche_close.c
00000000 l    df *ABS*	00000000 alt_iniche_dev.c
00000000 l    df *ABS*	00000000 alt_iniche_read.c
00000000 l    df *ABS*	00000000 alt_iniche_write.c
00000000 l    df *ABS*	00000000 ipnet.c
00000000 l    df *ABS*	00000000 ipstart.c
02060f30 l     O .bss	0000003c closers
020542d0 l     O .bss	00000004 nclosers
00000000 l    df *ABS*	00000000 igmp_cmn.c
00000000 l    df *ABS*	00000000 bsdsock.c
00000000 l    df *ABS*	00000000 cksum.c
02054190 l     O .rwdata	00000004 cksum_select
00000000 l    df *ABS*	00000000 in_utils.c
02060f6c l     O .bss	00000018 tistring
00000000 l    df *ABS*	00000000 netmain.c
00000000 l    df *ABS*	00000000 tk_crnos.c
00000000 l    df *ABS*	00000000 pktalloc.c
00000000 l    df *ABS*	00000000 q.c
00000000 l    df *ABS*	00000000 asm_cksum.o
020285c4 l       .text	00000000 done
02028454 l       .text	00000000 asm1
02028580 l       .text	00000000 loop0
0202847c l       .text	00000000 loop
0202859c l       .text	00000000 fold
00000000 l    df *ABS*	00000000 brdutils.c
02054304 l     O .bss	00000004 kbd_init.3831
02054300 l     O .bss	00000004 cpu_statusreg
00000000 l    df *ABS*	00000000 osportco.c
00000000 l    df *ABS*	00000000 targnios.c
00000000 l    df *ABS*	00000000 nptcp.c
02054338 l     O .bss	00000004 in_tcptick
00000000 l    df *ABS*	00000000 rawsock.c
00000000 l    df *ABS*	00000000 sockcall.c
0202c968 l     F .text	0000008c sockargs
0202bcc8 l     F .text	000001d4 t_getname
00000000 l    df *ABS*	00000000 socket.c
00000000 l    df *ABS*	00000000 socket2.c
00000000 l    df *ABS*	00000000 soselect.c
00000000 l    df *ABS*	00000000 tcp_in.c
00000000 l    df *ABS*	00000000 tcp_out.c
02034538 l     F .text	000000c8 bld_options
00000000 l    df *ABS*	00000000 tcp_subr.c
00000000 l    df *ABS*	00000000 tcp_timr.c
00000000 l    df *ABS*	00000000 tcp_usr.c
00000000 l    df *ABS*	00000000 tcpport.c
00000000 l    df *ABS*	00000000 udpsock.c
00000000 l    df *ABS*	00000000 alt_alarm_start.c
00000000 l    df *ABS*	00000000 alt_close.c
02036d8c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_dev.c
02036ea4 l     F .text	0000002c alt_dev_null_write
00000000 l    df *ABS*	00000000 alt_dev_llist_insert.c
02036ed0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_do_ctors.c
00000000 l    df *ABS*	00000000 alt_do_dtors.c
00000000 l    df *ABS*	00000000 alt_errno.c
00000000 l    df *ABS*	00000000 alt_find_dev.c
00000000 l    df *ABS*	00000000 alt_find_file.c
00000000 l    df *ABS*	00000000 alt_fs_reg.c
00000000 l    df *ABS*	00000000 alt_get_fd.c
00000000 l    df *ABS*	00000000 alt_iic.c
00000000 l    df *ABS*	00000000 alt_iic_isr_register.c
00000000 l    df *ABS*	00000000 alt_io_redirect.c
02037664 l     F .text	000000c0 alt_open_fd
00000000 l    df *ABS*	00000000 alt_irq_vars.c
00000000 l    df *ABS*	00000000 alt_read.c
0203779c l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_remap_cached.c
00000000 l    df *ABS*	00000000 alt_remap_uncached.c
00000000 l    df *ABS*	00000000 alt_uncached_malloc.c
00000000 l    df *ABS*	00000000 alt_write.c
020379a8 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 altera_nios2_qsys_irq.c
00000000 l    df *ABS*	00000000 os_cpu_a.o
00000040 l       *ABS*	00000000 OSCtxSw_SWITCH_PC
00000000 l    df *ABS*	00000000 os_cpu_c.c
00000014 l       *ABS*	00000000 OSTCBNext_OFFSET
00000032 l       *ABS*	00000000 OSTCBPrio_OFFSET
00000000 l       *ABS*	00000000 OSTCBStkPtr_OFFSET
00000000 l    df *ABS*	00000000 altera_avalon_spi.c
00000000 l    df *ABS*	00000000 altera_avalon_tse.c
02054367 l     O .bss	00000001 tse_system_count.4451
02054366 l     O .bss	00000001 is_init.4533
00000000 l    df *ABS*	00000000 altera_avalon_tse_system_info.c
00000000 l    df *ABS*	00000000 allports.c
0205436c l     O .bss	00000004 inside_pktdemux
00000000 l    df *ABS*	00000000 timeouts.c
0203d76c l     F .text	00000198 check_interval_timers
02054378 l     O .bss	00000004 numtimers
00000000 l    df *ABS*	00000000 tk_misc.c
00000000 l    df *ABS*	00000000 alt_iniche_fcntl.c
00000000 l    df *ABS*	00000000 et_arp.c
0205437c l     O .bss	00000004 arp_timer
02054384 l     O .bss	00000004 cachetime
00000000 l    df *ABS*	00000000 iface.c
00000000 l    df *ABS*	00000000 ip.c
020541fc l     O .rwdata	00000004 uid
00000000 l    df *ABS*	00000000 ip_reasm.c
00000000 l    df *ABS*	00000000 ipdemux.c
00000000 l    df *ABS*	00000000 ipmc.c
00000000 l    df *ABS*	00000000 ipport.c
00000000 l    df *ABS*	00000000 ipraw.c
00000000 l    df *ABS*	00000000 iproute.c
00000000 l    df *ABS*	00000000 udp.c
020543c4 l     O .bss	00000002 usocket
00000000 l    df *ABS*	00000000 igmp.c
00000000 l    df *ABS*	00000000 igmp2.c
00000000 l    df *ABS*	00000000 ipopt.c
00000000 l    df *ABS*	00000000 u_mctest.c
02054204 l     O .rwdata	00000004 iCounter.4589
00000000 l    df *ABS*	00000000 memdev.c
00000000 l    df *ABS*	00000000 parseip.c
02060f84 l     O .bss	0000001e nearBuf.4216
00000000 l    df *ABS*	00000000 tcpcksum.c
00000000 l    df *ABS*	00000000 udp_open.c
00000000 l    df *ABS*	00000000 in_pcb.c
00000000 l    df *ABS*	00000000 vfsfiles.c
00000000 l    df *ABS*	00000000 vfsport.c
00000000 l    df *ABS*	00000000 alt_fcntl.c
0204a6b0 l     F .text	00000050 alt_get_errno
00000000 l    df *ABS*	00000000 alt_usleep.c
00000000 l    df *ABS*	00000000 icmp.c
02054090 l     O .rwdata	00000018 dsts
00000000 l    df *ABS*	00000000 alt_busy_sleep.c
00000000 l    df *ABS*	00000000 atexit.c
00000000 l    df *ABS*	00000000 calloc.c
00000000 l    df *ABS*	00000000 exit.c
00000000 l    df *ABS*	00000000 malloc.c
00000000 l    df *ABS*	00000000 vprintf.c
00000000 l    df *ABS*	00000000 vsprintf.c
00000000 l    df *ABS*	00000000 __atexit.c
00000000 l    df *ABS*	00000000 __call_atexit.c
00000000 l    df *ABS*	00000000 alt_exit.c
00000000 l    df *ABS*	00000000 
02006c14 g     F .text	0000001c putchar
0263db08 g     O .bss	00000014 soq
02060fa4 g     O .bss	005b8d88 upload_buf
0200f468 g     F .text	00000074 _mprec_log10
0203944c g     F .text	000000d8 alt_tse_get_mac_info
0205414e g     O .rwdata	00000002 OSTaskNameSize
0201ef70 g     F .text	0000008c alt_epcs_flash_get_info
0200f558 g     F .text	00000084 __any_on
0200e1f4 g     F .text	00000064 _isatty_r
0204deec g     O .rodata	00000028 __mprec_tinytens
0203f638 g     F .text	00000740 ip_write_internal
020153ec g     F .text	000000cc alt_main
0200756c g     F .text	00000094 strcpy
02014e44 g     F .text	00000044 __ashldi3
02028044 g     F .text	000000b0 pk_free
02006c30 g     F .text	00000084 _puts_r
0263dcb4 g     O .bss	00000100 alt_irq
020019e0 g     F .text	00000194 http_send_file_chunk
02053f30 g     O .rwdata	00000009 rtp_priority
0200e36c g     F .text	0000006c _lseek_r
0204b828 g     F .text	0000033c icmp_timex
02029678 g     F .text	00000040 m_freem
0204a1b0 g     F .text	00000048 vgetc
02028734 g     F .text	0000001c clock_c
02054350 g     O .bss	00000004 tcp_optionbuf
0203f15c g     F .text	0000007c if_getbynum
0201a904 g     F .text	000000d0 OS_MemInit
0202779c g     F .text	0000006c TK_OSTaskQuery
02028434 g       .text	00000000 asm_cksum
0203d024 g     F .text	000000f0 marvell_cfg_rgmii
0201e5d4 g     F .text	00000064 OSTimeSet
0204a0b8 g     F .text	000000f8 vgetc_locked
02028fb4 g     F .text	00000020 post_task_setup
02042d0c g     F .text	00000378 ipr_stats
02035d90 g     F .text	00000118 tcp_attach
020540b0 g     O .rwdata	00000008 sweep_field
0202aa5c g     F .text	000000c4 tcp_tick
02026a40 g     F .text	0000007c print_ipad
02027698 g     F .text	00000104 tcp_wakeup
0200db44 g     F .text	00000098 __sflags
02014120 g     F .text	0000005c __eqdf2
02054214 g     O .bss	00000004 last_flash_sector_offset
020542d4 g     O .bss	00000004 igmp_timers_are_running
02032f28 g     F .text	0000012c tcp_pulloutofband
0203a634 g     F .text	00000210 alt_tse_phy_print_profile
02015f38 g     F .text	0000063c OSEventPendMulti
0200084c g     F .text	00000030 print
0263e1bc g       *ABS*	00000000 __alt_heap_start
02037ec8 g     F .text	00000020 OSTaskCreateHook
02008764 g     F .text	00000008 strtok_r
0203cdc4 g     F .text	00000098 marvell_phy_cfg
020430d4 g     F .text	000003e0 ip_rcv
02049e5c g     F .text	0000014c vfseek
0202f0e0 g     F .text	00000108 soqremque
02044dcc g     F .text	00000818 udpdemux
02023664 g     F .text	00000104 tse_mac_close
02006a24 g     F .text	0000003c printf
02054398 g     O .bss	00000004 rt_mib
02054126 g     O .rwdata	00000002 OSMboxEn
0204bdf0 g     F .text	00000024 vsprintf
0202015c g     F .text	00000110 alt_avalon_sgdma_do_sync_transfer
020165c8 g     F .text	0000007c OSIntEnter
02001234 g     F .text	0000011c http_handle_accept
02007230 g     F .text	0000005c __sseek
0200492c g     F .text	0000010c __sinit
02043fdc g     F .text	00000108 in_delmulti
0200bf84 g     F .text	0000013c __swbuf_r
020543b0 g     O .bss	00000004 so_evtmap_create
02054136 g     O .rwdata	00000002 OSQEn
02048538 g     F .text	00000088 in_pcballoc
020541b0 g     O .rwdata	00000002 socket_defaults
0200e290 g     F .text	0000009c _setlocale_r
0203df6c g     F .text	00000458 send_arp
020048b8 g     F .text	00000064 __sfmoreglue
02048f78 g     F .text	00000338 vfopen_locked
02011f00 g     F .text	0000001c ungetc
02015c00 g     F .text	000000d4 __malloc_unlock
02037f24 g     F .text	0000001c OSTaskStatHook
0203d5b8 g     F .text	00000054 prep_modules
02619d2c g     O .bss	0000002a board_funcs
02026020 g     F .text	0000013c bsd_i_sockoptlen
0205426c g     O .bss	00000001 OSLockNesting
0200fd74 g     F .text	00001458 _strtod_r
02007600 g     F .text	00000664 strerror
02039690 g     F .text	00000a74 getPHYSpeed
020494bc g     F .text	00000040 vfclose
0263dba8 g     O .bss	0000002c tcb
02054174 g     O .rwdata	00000002 OSDataSize
020378dc g     F .text	00000034 alt_remap_cached
0205426d g     O .bss	00000001 OSRunning
0203eea0 g     F .text	000002bc grat_arp
020036e8 g     F .text	000001b0 get_ip_addr
02047ce0 g     F .text	00000094 inet_pton
0203f2ac g     F .text	00000090 reg_type
02024e00 g     F .text	00000224 igmp_fasttimo
0204966c g     F .text	00000058 vunlink_flag_open_files
02020848 g     F .text	00000344 alt_avalon_sgdma_construct_descriptor_burst
0263dbd4 g     O .bss	000000e0 tcpstat
020425c0 g     F .text	0000034c ip_reasm_copy_queued_fragments_into_reassy_buffer
02029bcc g     F .text	0000009c dtom
0203443c g     F .text	000000fc tcp_setpersist
0202c050 g     F .text	00000184 t_getsockopt
02006704 g     F .text	00000128 memmove
0202a01c g     F .text	000005c4 ip_output
02037f68 g     F .text	0000001c OSInitHookBegin
0204bb64 g     F .text	00000050 icmp_du
02054194 g     O .rwdata	00000004 num_net_tasks
020543d8 g     O .bss	00000004 vfiles
0205416c g     O .rwdata	00000002 OSTmrSize
0200491c g     F .text	00000010 _cleanup
02041794 g     F .text	000002b8 ip_reasm_process_first_fragment
0200e634 g     F .text	000000a8 _Balloc
020086c0 g     F .text	000000a4 __strtok_r
0200358c g     F .text	00000108 get_board_mac_addr
02054270 g     O .bss	00000004 OSIdleCtr
0203c038 g     F .text	000001bc alt_tse_phy_set_adv_1000
020541e4 g     O .rwdata	00000001 max_mac_system
020466cc g     F .text	000005cc ip_setmoptions
02038704 g     F .text	000009fc alt_tse_system_add_sys
020141d8 g     F .text	00000064 __gtdf2
020477fc g     F .text	0000002c md_fseek
02037bb0 g       .text	00000000 OSStartTsk
00000000  w      *UND*	00000000 __errno
02017a14 g     F .text	000002d8 OS_TCBInit
02021ae4 g     F .text	000000f8 epcs_sector_erase
02041a4c g     F .text	00000088 ip_reassm
020540c8 g     O .rwdata	00000008 flash_field
0263dfb4 g     O .bss	00000010 udp_mib
00000000 g     F .entry	00000000 __reset
0202c7dc g     F .text	000000d0 t_shutdown
0202c2b4 g     F .text	00000138 t_recvfrom
02000fcc g     F .text	000000cc http_reset_connection
02054172 g     O .rwdata	00000002 OSTmrWheelTblSize
02046e60 g     F .text	00000708 u_mctest_run
020203b8 g     F .text	00000074 alt_avalon_sgdma_construct_stream_to_mem_desc_burst
02044148 g     F .text	00000088 prep_ifaces
020542f0 g     O .bss	00000001 to_netmain
02027cec g     F .text	000000cc pk_alloc
02054112 g     O .rwdata	00000002 OSEventSize
02054274 g     O .bss	00000001 OSPrioHighRdy
0200581c g     F .text	00000068 _fstat_r
02053df8 g     O .rwdata	00000120 tse_mac_device
02027414 g     F .text	00000044 tk_nettick
02037ee8 g     F .text	00000020 OSTaskDelHook
020039c4 g     F .text	00000290 ProgFlash
0205422c g     O .bss	00000004 errno
02006f1c g     F .text	00000014 __srget
020302e0 g     F .text	000000c0 in_pcbnotify
0200bef0 g     F .text	00000024 __svfscanf
02037b90 g       .text	00000000 OSStartHighRdy
0263d79c g     O .bss	00000014 lilfreeq
02000204 g     F .text	00000648 alt_uCOSIIErrorHandler
020441f8 g     F .text	00000028 evtmap_setup
0201ce04 g     F .text	000001f4 OSTaskCreateExt
020542f4 g     O .bss	00000004 tcp_sleep_timeout
0202fa94 g     F .text	000001b8 sbdrop
020543ac g     O .bss	00000004 net_system_exit
0263dfc4 g     O .bss	00000068 icmp_mib
0203c90c g     F .text	000004b8 alt_tse_phy_set_common_speed
02034edc g     F .text	00000078 tcp_getseq
020445e0 g     F .text	000000c0 ip_raw_alloc
02018d9c g     F .text	00000068 OSFlagPendGetFlagsRdy
02054152 g     O .rwdata	00000002 OSTaskStatStkSize
0263ddb4 g     O .bss	00000010 pmac_groups
0202d968 g     F .text	00000740 soreceive
020149dc g     F .text	0000002c __make_fp
02017e78 g     F .text	00000308 OSFlagAccept
0201afdc g     F .text	000000b8 OSQFlush
0201a9d4 g     F .text	00000140 OSQAccept
0205424c g     O .bss	00000004 alt_argv
0205c0a8 g       *ABS*	00000000 _gp
02043084 g     F .text	00000050 ip_reasm_send_icmp_timex
0204a818 g     F .text	00000114 usleep
020494fc g     F .text	00000048 vfflush
0263dab0 g     O .bss	00000040 resid_semaphore
02026900 g     F .text	00000140 hexdump
0204165c g     F .text	000000a0 ip_reasm_incr_mem_useage
0202900c g     F .text	00000034 calloc2
02025528 g     F .text	0000007c igmp_leavegroup
0201cc48 g     F .text	000001bc OSTaskCreate
0201c720 g     F .text	00000528 OSTaskChangePrio
02054268 g     O .bss	00000004 alt_heapsem
02034d24 g     F .text	000000f0 tcp_close
02017cec g     F .text	0000018c OSDebugInit
0201cff8 g     F .text	000003dc OSTaskDel
0204a5d8 g     F .text	0000005c vferror
02037950 g     F .text	00000058 alt_uncached_malloc
02038210 g     F .text	00000060 tse_mac_initTransInfo2
02045a44 g     F .text	000000bc udp_alloc
02053c78 g     O .rwdata	00000180 alt_fd_list
02639f8c g     O .bss	00000370 OSFlagTbl
0205433c g     O .bss	00000008 mbstat
02005be8 g     F .text	00000070 _getc_r
02005c58 g     F .text	00000088 getc
02006c0c g     F .text	00000008 _putchar_r
02016ff4 g     F .text	000000b0 OS_EventTaskRemove
02021d20 g     F .text	00000068 epcs_write_status_register
020462fc g     F .text	00000148 igmpv2_chk_set_timer
02027458 g     F .text	0000002c TK_OSTimeDly
02037078 g     F .text	00000090 alt_find_dev
0200660c g     F .text	000000f8 memcpy
0203847c g     F .text	00000054 tse_mac_setMIImode
020128b8 g     F .text	0000028c __hexnan
0203db7c g     F .text	00000088 task_stats
0202b494 g     F .text	0000004c DOMAIN_CHECK
0202a5e0 g     F .text	00000038 in_broadcast
0205413c g     O .rwdata	00000002 OSRdyTblSize
0203a104 g     F .text	00000048 alt_tse_phy_rd_mdio_addr
020543d4 g     O .bss	00000004 vfsystems
02045974 g     F .text	000000d0 udp_socket
02000cfc g     F .text	0000027c file_upload
020542c4 g     O .bss	00000004 MaxMtu
0202ffc0 g     F .text	0000013c sock_selscan
020048ac g     F .text	0000000c _cleanup_r
02014358 g     F .text	000000d4 __floatsidf
02041434 g     F .text	000000c4 ip_reasm_match_frag_with_ire
0202f23c g     F .text	00000054 socantrcvmore
02038270 g     F .text	000000e0 tse_mac_sTxWrite
020069e4 g     F .text	00000014 perror
0203721c g     F .text	00000084 alt_fs_reg
02037724 g     F .text	00000078 alt_io_redirect
020142a0 g     F .text	0000005c __ltdf2
02054318 g     O .bss	00000004 netq_intmask
02047c94 g     F .text	0000004c hextoa
0204c128 g       *ABS*	00000000 __DTOR_END__
0202c5d8 g     F .text	00000204 t_send
02036ddc g     F .text	000000c8 alt_close
02054344 g     O .bss	00000002 select_wait
02006cb4 g     F .text	00000014 puts
02026f7c g     F .text	00000044 std_out
02021668 g     F .text	00000090 alt_ro_zipfs_open
0263d290 g     O .bss	00000030 tse_iniche_dev_driver_data
0204a1f8 g     F .text	00000124 vfslookup_locked
0202d224 g     F .text	00000098 soaccept
02015cd4 g     F .text	00000120 OSEventNameGet
02054120 g     O .rwdata	00000002 OSFlagMax
0200e43c g     F .text	00000040 mbrtowc
0263db1c g     O .bss	0000003c tcpmib
0202c9f4 g     F .text	00000098 t_errno
02044220 g     F .text	000000e0 ip_raw_open
0201f104 g     F .text	00000104 alt_epcs_flash_write_block
0200bea4 g     F .text	0000004c _vfscanf_r
0200f3c4 g     F .text	000000a4 __ratio
02016644 g     F .text	000000f4 OSIntExit
02054200 g     O .rwdata	00000004 ipRoutes
0204961c g     F .text	00000050 vfeof
020351d8 g     F .text	0000005c tcp_canceltimers
0205415a g     O .rwdata	00000002 OSTCBSize
020204a8 g     F .text	00000088 alt_avalon_sgdma_construct_mem_to_stream_desc_burst
02054275 g     O .bss	00000001 OSPrioCur
0201fa54 g     F .text	000002c4 altera_avalon_jtag_uart_read
0204bd44 g     F .text	00000014 malloc
020543d0 g     O .bss	00000004 inpcb_cachemiss
020069f8 g     F .text	0000002c _printf_r
02047e50 g     F .text	000000c0 inet46_addr
020543cc g     O .bss	00000004 inpcb_cachehits
0201479c g     F .text	00000008 __udivsi3
02053c38 g     O .rwdata	0000000b tcp_outflags
0263d2c0 g     O .bss	00000130 tse
0201522c g     F .text	000000a0 isatty
02039100 g     F .text	00000164 alt_tse_sys_enable_mdio_sharing
02054140 g     O .rwdata	00000002 OSStkWidth
0200e258 g     F .text	00000038 iswspace
0204df3c g     O .rodata	000000c8 __mprec_tens
02048df4 g     F .text	00000070 vf_alloc_and_link_vop
02054134 g     O .rwdata	00000002 OSPtrSize
0205439c g     O .bss	00000004 ipr_curr_mem
02024a74 g     F .text	0000006c exit_hook
020393cc g     F .text	00000080 alt_tse_get_mac_info_index
020542d8 g     O .bss	00000004 igmp_cticks
0205432c g     O .bss	00000004 mheap_sem_ptr
020332dc g     F .text	0000004c ip4_tcpmss
0200e32c g     F .text	0000000c __locale_charset
02002914 g     F .text	000003c4 http_handle_receive
02054114 g     O .rwdata	00000002 OSEventTblSize
0263df38 g     O .bss	00000014 netlist
0202e0a8 g     F .text	00000098 soshutdown
02012ba4 g     F .text	00000084 __fixunsdfsi
02037b04 g       .text	00000000 OSCtxSw
0203d544 g     F .text	00000050 packet_check
0263db58 g     O .bss	00000014 mbufq
0202d1d4 g     F .text	00000050 soabort
02054238 g     O .bss	00000004 __malloc_top_pad
02001500 g     F .text	00000214 http_process_headers
02054278 g     O .bss	00000004 OSTCBList
02028334 g     F .text	00000100 qdel
0203d310 g     F .text	000001a0 station_state
02044738 g     F .text	00000174 rt_lookup
0205435c g     O .bss	00000004 alt_fd_list_lock
020118bc g     F .text	00000024 strtoul
020540e4 g     O .rwdata	00000004 __mb_cur_max
020255a4 g     F .text	00000314 igmp_validate
0200e338 g     F .text	0000000c _localeconv_r
020247d0 g     F .text	000002a4 ip_startup
020118e0 g     F .text	00000394 _strtoull_r
0202b78c g     F .text	0000024c t_accept
0202ecc4 g     F .text	00000094 soisdisconnecting
0200ea34 g     F .text	0000003c __i2b
0200dd10 g     F .text	000004e4 __sfvwrite_r
020205d4 g     F .text	00000058 alt_avalon_sgdma_stop
020241dc g     F .text	000003ac pktdemux
0263a2fc g     O .bss	00000c30 OSMemTbl
0205427c g     O .bss	00000001 OSTickStepState
0203a1a4 g     F .text	0000012c alt_tse_phy_wr_mdio_reg
020285f8 g     F .text	0000009c kbhit
0202be9c g     F .text	000001b4 t_setsockopt
02006f30 g     F .text	00000064 _sbrk_r
02053f18 g     O .rwdata	00000018 icmpdu_types
0203a844 g     F .text	0000069c alt_tse_mac_group_init
020496c4 g     F .text	00000200 vunlink
02022404 g     F .text	00000a84 tse_mac_init
02631e8c g     O .bss	00002000 SSDTaskStk
0205421c g     O .bss	00000004 line_count
02054138 g     O .rwdata	00000002 OSQMax
0202675c g     F .text	000000a8 ccksum
02048e64 g     F .text	000000c8 vf_alloc_buffer
020543c0 g     O .bss	00000004 cachedRoute
02054198 g     O .rwdata	00000004 lilbufs
0263af2c g     O .bss	00000800 OSTaskStatStk
02047828 g     F .text	00000024 md_ftell
02026804 g     F .text	00000054 cksum
0201a530 g     F .text	000000f8 OSMemNameGet
0202cd6c g     F .text	00000120 sofree
020542cc g     O .bss	00000004 ifNumber
02054118 g     O .rwdata	00000002 OSFlagEn
0200f5dc g     F .text	0000006c _read_r
0205415e g     O .rwdata	00000002 OSTimeTickHookEn
02014fb4 g     F .text	00000074 alt_dcache_flush
0201b504 g     F .text	00000168 OSQPost
0201960c g     F .text	000000a0 OS_FlagUnlink
020529c8 g     O .rwdata	0000000c __lc_ctype
020541d8 g     O .rwdata	00000004 alt_max_fd
020175bc g     F .text	0000006c OS_MemCopy
020541a0 g     O .rwdata	00000004 bigbufs
02035ea8 g     F .text	000000cc tcp_disconnect
02017628 g     F .text	000000cc OS_Sched
02014c2c g     F .text	00000104 __unpack_d
020044ec g     F .text	0000013c _fclose_r
0201a440 g     F .text	000000f0 OSMemGet
0201a134 g     F .text	00000118 OSMboxQuery
020022d4 g     F .text	00000268 http_find_file
0201d6d4 g     F .text	000001c4 OSTaskNameSet
02000aac g     F .text	00000250 http_parse_multipart_header
02004824 g     F .text	00000030 fflush
02054234 g     O .bss	00000004 __malloc_max_sbrked_mem
02054280 g     O .bss	00000004 OSCtxSwCtr
0263d714 g     O .bss	00000064 igmpstats
02037f40 g     F .text	00000028 OSTimeTickHook
0202615c g     F .text	00000104 bsd_getsockopt
02054122 g     O .rwdata	00000002 OSFlagNameSize
0263df9c g     O .bss	00000018 ire_stats
020360ec g     F .text	000001a0 udp_soinput
02028288 g     F .text	000000ac putq
020170a4 g     F .text	000000f8 OS_EventTaskRemoveMulti
020542ec g     O .bss	00000004 iniche_net_ready
02013bd4 g     F .text	00000054 __adddf3
02016eac g     F .text	00000148 OS_EventTaskWaitMulti
0204a590 g     F .text	00000048 isvfile
0202e238 g     F .text	00000430 sosetopt
020272ac g     F .text	000000e0 netmain
02033328 g     F .text	000000f8 tcp_mss
0201f090 g     F .text	00000074 alt_epcs_flash_erase_block
0200f138 g     F .text	00000148 __b2d
02047938 g     F .text	000002fc parse_ipad
02048dd4 g     F .text	00000020 get_vfopen_error
0205413a g     O .rwdata	00000002 OSQSize
020131f0 g     F .text	0000058c __umoddi3
0201531c g     F .text	000000d0 lseek
0203d60c g     F .text	00000160 inet_timer
0201c018 g     F .text	0000026c OSSemPend
020540b8 g     O .rwdata	00000008 lcd_field
0203a39c g     F .text	00000298 alt_tse_phy_add_profile_default
0203baa0 g     F .text	00000598 alt_tse_phy_get_cap
020540d4 g     O .rwdata	00000004 _global_impure_ptr
02026c3c g     F .text	00000158 print_eth
02021fe4 g     F .text	00000058 epcs_exit_4_bytes_mode
020492b0 g     F .text	00000050 vfopen
020377ec g     F .text	000000f0 alt_read
0200f648 g     F .text	000005fc _realloc_r
02054124 g     O .rwdata	00000002 OSLowestPrio
0263e1bc g       *ABS*	00000000 __bss_end
02037574 g     F .text	000000f0 alt_iic_isr_register
02020038 g     F .text	00000124 alt_avalon_sgdma_do_async_transfer
02029560 g     F .text	00000118 m_free
02037fbc g     F .text	00000020 OSTCBInitHook
02023624 g     F .text	00000040 tse_mac_stats
02027db8 g     F .text	0000028c pk_validate
0205416a g     O .rwdata	00000002 OSTmrCfgTicksPerSec
020158d0 g     F .text	00000104 alt_tick
02048b58 g     F .text	00000254 in_pcblookup
02019ec8 g     F .text	00000110 OSMboxPost
02639e8c g     O .bss	00000100 __hexdig
02012c28 g     F .text	000005c8 __udivdi3
020293d8 g     F .text	00000188 m_getnbuf
02028114 g     F .text	000000bc dump_buf_estats
0203b940 g     F .text	00000160 alt_tse_phy_check_link
02054394 g     O .bss	00000004 arpRepsOut
0205410c g     O .rwdata	00000002 OSEventEn
0204df14 g     O .rodata	00000028 __mprec_bigtens
0200e818 g     F .text	00000104 __s2b
02054166 g     O .rwdata	00000002 OSTmrCfgNameSize
02014560 g     F .text	0000011c __floatunsidf
0203d18c g     F .text	000000f4 netmain_init
0203cf40 g     F .text	000000e4 marvell_cfg_sgmii
0203b77c g     F .text	000001c4 alt_tse_phy_restart_an
0200eed8 g     F .text	00000058 __mcmp
02034760 g     F .text	0000040c tcp_respond
020364cc g     F .text	000002dc udp4_sockbind
020540d0 g     O .rwdata	00000004 __ctype_ptr
0205431c g     O .bss	00000004 old_mode
020252cc g     F .text	0000025c igmp_joingroup
0202a70c g     F .text	00000350 so_icmpdu
02004b44 g     F .text	00000018 __fp_lock_all
020543e4 g     O .bss	00000004 vfs_dir_stale
02037528 g     F .text	0000004c alt_ic_irq_enabled
0263ddc4 g     O .bss	00000010 pphy_profiles
0204290c g     F .text	0000011c ip_reasm_process_timer_tick
0204a634 g     F .text	00000058 vclearerr
02026688 g     F .text	000000d4 bsd_setsockopt
02029b78 g     F .text	00000054 mbuf_len
0201941c g     F .text	000000e4 OS_FlagInit
02015838 g     F .text	00000098 alt_alarm_stop
0204a364 g     F .text	000001d4 strippath
020274f4 g     F .text	000001a4 tcp_sleep
020089d0 g     F .text	00000024 strtol
02035f74 g     F .text	000000d4 tcp_usrclosed
00001c00 g       *ABS*	00000000 __alt_mem_descriptor_memory
02054308 g     O .bss	00000004 cticks_factor
02054148 g     O .rwdata	00000002 OSTaskIdleStkSize
02048614 g     F .text	00000210 in_pcbbind
02054360 g     O .bss	00000004 alt_irq_active
0201bbf8 g     F .text	000000b0 OSSemAccept
0201a744 g     F .text	000000d8 OSMemPut
0202180c g     F .text	0000013c alt_ro_zipfs_seek
0201a24c g     F .text	000001f4 OSMemCreate
02054284 g     O .bss	00000004 OSIdleCtrMax
020000ec g     F .exceptions	000000d0 alt_irq_handler
02053c50 g     O .rwdata	00000028 alt_dev_null
020541b2 g     O .rwdata	00000001 tcprexmtthresh
0205415c g     O .rwdata	00000002 OSTicksPerSec
0203f33c g     F .text	00000090 if_killsocks
0203fd78 g     F .text	00000218 ip_write
020434b4 g     F .text	000005dc ip_rcv_phase2
0202bc84 g     F .text	00000044 t_getsockname
0202b9d8 g     F .text	00000268 t_connect
020541ac g     O .rwdata	00000004 TCPTV_MSL
0263d7b0 g     O .bss	00000010 memestats
02001098 g     F .text	0000019c http_manage_connection
0203b664 g     F .text	00000118 alt_tse_phy_init
02028694 g     F .text	00000064 getch
02014858 g     F .text	000000c8 __unpack_f
02054010 g     O .rwdata	00000080 vfs_root_path
0202bc40 g     F .text	00000044 t_getpeername
020043bc g     F .text	00000098 board_control_task
0202062c g     F .text	00000064 alt_avalon_sgdma_check_descriptor_status
020416fc g     F .text	00000098 ip_reasm_decr_mem_useage
0202f3c4 g     F .text	00000088 soreserve
02003f00 g     F .text	000002d4 ParseSRECBuf
02037b04 g       .text	00000000 OSIntCtxSw
020028a4 g     F .text	00000070 http_prepare_response
02029040 g     F .text	000000ec npalloc
02004854 g     F .text	0000002c _fgetpos_r
0200e91c g     F .text	00000068 __hi0bits
020543bc g     O .bss	00000004 ipraw_eps
02027a58 g     F .text	00000294 pk_init
02047628 g     F .text	0000015c md_fread
0204bcf0 g     F .text	0000001c calloc
02022e88 g     F .text	000002f8 tse_mac_raw_send
0201442c g     F .text	000000d4 __fixdfsi
020009e4 g     F .text	000000c8 lcd_output
0263ddd4 g     O .bss	00000064 intimers
0202f49c g     F .text	00000048 sbrelease
0203041c g     F .text	000000f0 ifd_clr
0202fd48 g     F .text	0000008c sbdroprecord
02026d94 g     F .text	0000007c uslash
020379f8 g     F .text	000000ec alt_write
02000f78 g     F .text	00000054 ProgFlashStub
02054390 g     O .bss	00000004 arpRepsIn
0203d904 g     F .text	000001b8 in_timerset
020111cc g     F .text	0000001c strtod
02054288 g     O .bss	00000004 OSTCBFreeList
0201c284 g     F .text	00000174 OSSemPendAbort
02033420 g     F .text	0000101c tcp_output
02054368 g     O .bss	00000004 activehost
020541d0 g     O .rwdata	00000008 alt_dev_list
0202709c g     F .text	00000210 parse_args
02054320 g     O .bss	00000004 global_TCPwakeup_setIndx
0200dbdc g     F .text	00000044 _fputc_r
02023948 g     F .text	00000068 write
02020768 g     F .text	00000080 alt_avalon_sgdma_enable_desc_poll
0202912c g     F .text	000000c0 npfree
02006a60 g     F .text	000000bc _putc_r
0203e678 g     F .text	000002c4 arpReply
02026884 g     F .text	0000007c nextarg
02054160 g     O .rwdata	00000002 OSVersionNbr
02042038 g     F .text	00000530 ip_reasm_process_subsequent_fragments
0205420c g     O .rwdata	00000004 pton_error
020137d0 g     F .text	0000005c __gtsf2
0263d3f0 g     O .bss	00000014 rcvdq
020303a0 g     F .text	0000007c tcp_notify
02015130 g     F .text	000000ac fstat
02004ce8 g     F .text	00000024 fprintf
0202d2bc g     F .text	000000b8 soconnect
020446e0 g     F .text	00000058 ip_raw_maxalloc
02014e00 g     F .text	00000044 __lshrdi3
02619d56 g     O .bss	0000c000 http_rx_buffer
020142fc g     F .text	0000005c __ledf2
0203d114 g     F .text	00000078 DP83848C_link_status_read
02007348 g     F .text	00000098 strcat
02048ad8 g     F .text	00000080 in_setpeeraddr
02054108 g     O .rwdata	00000004 OSEndiannessTest
020286f8 g     F .text	0000003c clock_init
02049544 g     F .text	000000d8 vfgets
0203dcec g     F .text	0000018c et_send
0200ec50 g     F .text	0000012c __pow5mult
02054244 g     O .bss	00000004 __nlocale_changed
020147a4 g     F .text	00000008 __umodsi3
02047c34 g     F .text	00000060 inet_addr
020415c8 g     F .text	00000094 ip_reasm_check_mem_useage
0202e140 g     F .text	000000f8 sorflush
0204bd6c g     F .text	00000020 vprintf
0263d8c4 g     O .bss	000000fc global_tcb_ext
020403cc g     F .text	00000418 ip_fragment_lc
0263d404 g     O .bss	00000300 netstatic
02021ea4 g     F .text	00000068 epcs_read_electronic_signature
0202b560 g     F .text	0000015c t_bind
0202042c g     F .text	0000007c alt_avalon_sgdma_construct_mem_to_stream_desc
0205411a g     O .rwdata	00000002 OSFlagGrpSize
02048460 g     F .text	000000d8 udp_close
02020530 g     F .text	00000050 alt_avalon_sgdma_register_callback
02028d44 g     F .text	000001fc alt_iniche_init
0263e1bc g       *ABS*	00000000 end
0202895c g     F .text	00000084 UNLOCK_NET_RESOURCE
02022180 g     F .text	00000284 prep_tse_mac
0202c1d4 g     F .text	000000e0 t_recv
02014e88 g     F .text	0000012c __pack_f
020498c4 g     F .text	0000018c vfread
020240f8 g     F .text	000000e4 netclose
020044e0 g     F .text	0000000c _atoi_r
02038520 g     F .text	000001e4 alt_tse_phy_add_profile
020057f8 g     F .text	00000024 fseek
020541bc g     O .rwdata	00000004 tcp_keepintvl
0201f404 g     F .text	0000013c altera_avalon_jtag_uart_init
02017890 g     F .text	000000bc OS_TaskStat
02054178 g     O .rwdata	00000004 tse_mac_name
02053bf0 g     O .rwdata	00000018 tcp_protosw
0204c128 g       *ABS*	00000000 __CTOR_LIST__
020543e0 g     O .bss	00000004 vfopen_error
04000000 g       *ABS*	00000000 __alt_stack_pointer
02054354 g     O .bss	00000004 tcp_maxidle
020543c8 g     O .bss	00000004 firstudp
020207e8 g     F .text	00000060 alt_avalon_sgdma_disable_desc_poll
02020d5c g     F .text	00000088 alt_avalon_timer_sc_init
020147ac g     F .text	000000ac __clzsi2
0201fd18 g     F .text	000002d0 altera_avalon_jtag_uart_write
0202026c g     F .text	00000070 alt_avalon_sgdma_construct_mem_to_mem_desc
02004b34 g     F .text	00000004 __sfp_lock_acquire
0200e4c0 g     F .text	000000f8 memchr
02017568 g     F .text	00000054 OS_MemClr
02008a30 g     F .text	00001df8 ___vfprintf_internal_r
02037bd4 g     F .text	000002f4 OSTaskStkInit
02625d58 g     O .bss	00000030 flash_inf
02006f94 g     F .text	00000058 _sprintf_r
0202035c g     F .text	0000005c alt_avalon_sgdma_construct_stream_to_mem_desc
020050b4 g     F .text	000002d0 _free_r
02046444 g     F .text	00000140 igmpv2_chk4_rtr_alert_opt
02002cd8 g     F .text	00000060 http_handle_transmit
0202c8ac g     F .text	000000bc t_socketclose
02016c0c g     F .text	00000198 OS_EventTaskRdy
0204bf44 g     F .text	000001a0 __call_exitprocs
02006ed0 g     F .text	0000004c __srget_r
02001400 g     F .text	00000100 http_parse_type_boundary
02023180 g     F .text	000000b0 tse_sgdmaRx_isr
0205428c g     O .bss	00000001 OSCPUUsage
0263d704 g     O .bss	00000010 nets
02028898 g     F .text	000000c4 LOCK_NET_RESOURCE
02054240 g     O .bss	00000004 __mlocale_changed
020233e0 g     F .text	00000244 tse_mac_rcv
0202b4e0 g     F .text	00000080 t_socket
020540dc g     O .rwdata	00000004 __malloc_sbrk_base
020001bc g     F .text	00000048 _start
0203dca4 g     F .text	00000048 etainit
02054254 g     O .bss	00000004 _alt_tick_rate
0203d594 g     F .text	00000024 mcastlist
0201b094 g     F .text	000002fc OSQPend
02008334 g     F .text	00000374 strstr
0263d7c0 g     O .bss	000000f0 pktlog
02011308 g     F .text	00000330 _strtoll_r
02045f80 g     F .text	00000140 igmpv2_process_report
02030580 g     F .text	00000078 ifd_isset
02044c98 g     F .text	00000134 del_route
02020690 g     F .text	00000050 alt_avalon_sgdma_open
020089f4 g     F .text	00000008 _user_strerror
0201e00c g     F .text	00000148 OSTimeDly
02003694 g     F .text	00000054 get_mac_addr
0202cc9c g     F .text	000000d0 solisten
02002d38 g     F .text	00000354 WSTask
0200ed7c g     F .text	0000015c __lshift
02037fdc g     F .text	00000208 alt_avalon_spi_command
02054258 g     O .bss	00000004 _alt_nticks
0203a2d0 g     F .text	000000cc alt_tse_phy_rd_mdio_reg
020238d8 g     F .text	00000070 read
0201e6a4 g     F .text	0000026c alt_sys_init
02034e14 g     F .text	00000048 tcp_quench
02631d88 g     O .bss	00000104 frag
02026e10 g     F .text	0000016c ns_printf
02006908 g     F .text	0000006c _open_r
0203f1d8 g     F .text	000000d4 isbcast
020289e0 g     F .text	00000230 TK_NEWTASK
0204be14 g     F .text	00000130 __register_exitproc
0205428d g     O .bss	00000001 OSTaskCtr
020414f8 g     F .text	000000d0 ip_reasm_determine_type_of_frag
02054364 g     O .bss	00000001 phy_profile_count
02007cf0 g     F .text	000000fc strncmp
02039358 g     F .text	00000074 alt_tse_get_mac_group_index
0201e154 g     F .text	00000230 OSTimeDlyHMSM
02037910 g     F .text	00000040 alt_remap_uncached
02044300 g     F .text	000000bc ip_raw_close
0200ea70 g     F .text	000001e0 __multiply
02053f60 g     O .rwdata	000000b0 mdlist
0201f8f8 g     F .text	00000068 altera_avalon_jtag_uart_close
02024d20 g     F .text	000000e0 igmp_input
02040308 g     F .text	000000c4 ip_raw_write
02049a50 g     F .text	000003ac vfwrite_locked
02007dec g     F .text	000000b8 strncpy
02060f08 g     O .bss	00000028 __malloc_current_mallinfo
0205410e g     O .rwdata	00000002 OSEventMax
02047f10 g     F .text	00000068 inet_setport
0201377c g     F .text	00000054 __eqsf2
0200f280 g     F .text	00000144 __d2b
0201c3f8 g     F .text	00000110 OSSemPost
02007294 g     F .text	000000b4 strcasecmp
02032da8 g     F .text	00000180 tcp_dooptions
02021a18 g     F .text	0000005c epcs_read_status_register
0202ebc4 g     F .text	00000100 soisconnected
020167c0 g     F .text	000000d8 OSSchedUnlock
020441d0 g     F .text	00000028 netexit
020030bc g     F .text	000001d0 get_serial_number
020542e8 g     O .bss	00000004 nettick_wakes
0203a14c g     F .text	00000058 alt_tse_phy_wr_mdio_addr
02054348 g     O .bss	00000001 tcpprintfs
0203dabc g     F .text	0000009c in_timerkill
02045e38 g     F .text	00000148 igmpv2_input
0201f2a0 g     F .text	00000060 altera_avalon_jtag_uart_read_fd
02011638 g     F .text	00000284 _strtoul_r
02026858 g     F .text	0000002c do_trap
020372a0 g     F .text	000000fc alt_get_fd
02026260 g     F .text	000000ec bsd_ioctl
02054290 g     O .bss	00000004 OSMemFreeList
02016904 g     F .text	000000ac OSStatInit
02029e58 g     F .text	000001c4 tcp_rcv
02026bf8 g     F .text	00000044 panic
0204bbb4 g     F .text	00000128 alt_busy_sleep
020543e8 g     O .bss	00000004 vfs_open_files
02024640 g     F .text	00000190 ip2mac
02019198 g     F .text	000000c4 OSFlagQuery
02014d30 g     F .text	000000d0 __fpcmp_parts_d
020300fc g     F .text	000001e4 sock_select
02034600 g     F .text	00000058 tcp_init
02054324 g     O .bss	00000004 cticks
020542f1 g     O .bss	00000001 to_nettick
02054144 g     O .rwdata	00000002 OSTaskCreateExtEn
0200c2bc g     F .text	00000064 _close_r
020239b0 g     F .text	000005f0 Netinit
02028fd4 g     F .text	00000038 prep_armintcp
02043e90 g     F .text	0000014c in_addmulti
02034658 g     F .text	00000108 tcp_template
02633e8c g     O .bss	00002000 WSInitialTaskStk
0203c5e4 g     F .text	00000328 alt_tse_phy_get_common_speed
02029c68 g     F .text	00000070 remque
020086a8 g     F .text	00000018 strtok
0204bd8c g     F .text	00000014 _vprintf_r
0203065c g     F .text	0000040c tcp_reass
020480ac g     F .text	0000019c tcp_cksum
020367a8 g     F .text	0000037c udp4_socksend
02021f0c g     F .text	00000080 epcs_read_device_id
02049300 g     F .text	000001bc vfclose_locked
0203050c g     F .text	00000074 ifd_set
0200e5b8 g     F .text	0000007c memcmp
02016bf0 g     F .text	0000001c OS_Dummy
0201f360 g     F .text	00000050 altera_avalon_jtag_uart_close_fd
020542c8 g     O .bss	00000004 NDEBUG
0263e1bc g       *ABS*	00000000 __alt_stack_base
02054218 g     O .bss	00000004 last_flash_sector
0201f3b0 g     F .text	00000054 altera_avalon_jtag_uart_ioctl_fd
0202f44c g     F .text	00000050 sbreserve
02054365 g     O .bss	00000001 mac_group_count
020443bc g     F .text	00000224 ip_raw_input
02005b08 g     F .text	000000a0 _fwrite_r
0205419c g     O .rwdata	00000004 lilbufsiz
020305f8 g     F .text	00000064 ifd_get
0202f330 g     F .text	00000094 sbwakeup
02007060 g     F .text	0000007c sscanf
0200c148 g     F .text	00000174 __swsetup_r
0202203c g     F .text	00000144 altera_eth_tse_init
0263b72c g     O .bss	000001e0 OSQTbl
02033054 g     F .text	00000288 tcp_xmit_timer
02023230 g     F .text	000001b0 tse_sgdma_read_init
02013f6c g     F .text	000001b4 __divdf3
02004a38 g     F .text	000000fc __sfp
0200344c g     F .text	00000140 generate_mac_addr
0203f4b4 g     F .text	00000184 ip_bldhead
0200f4dc g     F .text	0000007c __copybits
0202f4e4 g     F .text	000000a0 sbappend
020525c0 g     O .rwdata	00000408 __malloc_av_
02004b40 g     F .text	00000004 __sinit_lock_release
02054294 g     O .bss	00000004 OSTCBHighRdy
02013c88 g     F .text	000002e4 __muldf3
00000000 g       *ABS*	00000000 __alt_mem_epcs_flash_controller
0203ff90 g     F .text	00000378 ip_write2
02007154 g     F .text	00000054 __sread
020541f8 g     O .rwdata	00000004 arp_ageout
02004f38 g     F .text	00000040 fread
02054298 g     O .bss	00000004 OSQFreeList
0203aee0 g     F .text	0000041c alt_tse_mac_get_phy
0203f3cc g     F .text	000000e8 ip_init
02037108 g     F .text	00000114 alt_find_file
020446a0 g     F .text	00000040 ip_raw_free
0203e578 g     F .text	00000100 make_arp_entry
02036f20 g     F .text	000000a0 alt_dev_llist_insert
02015aec g     F .text	00000114 __malloc_lock
02004cc0 g     F .text	00000028 _fprintf_r
02015788 g     F .text	000000b0 sbrk
02036088 g     F .text	00000064 udp_lookup
02020580 g     F .text	00000054 alt_avalon_sgdma_start
02003c54 g     F .text	000002ac ParseAndProgramLine
02015df4 g     F .text	00000144 OSEventNameSet
0200463c g     F .text	000001e8 _fflush_r
02039604 g     F .text	0000008c alt_tse_mac_set_duplex
02011f1c g     F .text	000000bc _calloc_r
0205429c g     O .bss	00000001 OSRdyGrp
020475e0 g     F .text	00000028 md_fopen
02053c08 g     O .rwdata	00000018 udp_protosw
020540e8 g     O .rwdata	00000008 alt_flash_dev_list
02048a58 g     F .text	00000080 in_setsockaddr
02004ca4 g     F .text	0000001c fopen
02054214 g       *ABS*	00000000 __bss_start
0202f584 g     F .text	000000d8 sbappendrecord
020041d4 g     F .text	00000078 WSInitialTask
0263df4c g     O .bss	00000050 ip_mib
0200682c g     F .text	000000dc memset
0202d374 g     F .text	00000098 sodisconnect
0200424c g     F .text	00000090 main
02054250 g     O .bss	00000004 alt_envp
02054230 g     O .bss	00000004 __malloc_max_total_mem
020299a8 g     F .text	000001d0 m_adj
0201f300 g     F .text	00000060 altera_avalon_jtag_uart_write_fd
02005994 g     F .text	00000014 ftell
0200c0c0 g     F .text	0000001c __swbuf
0204784c g     F .text	000000c8 md_fgetc
0204e188 g     O .rodata	00000100 OSUnMapTbl
02040e3c g     F .text	000002a8 ip_dump
02027834 g     F .text	00000224 tk_stats
0201382c g     F .text	00000054 __ltsf2
02004d0c g     F .text	0000022c _fread_r
02054184 g     O .rwdata	00000008 alt_iniche_dev_list
0205417c g     O .rwdata	00000008 alt_sgdma_list
0205413e g     O .rwdata	00000002 OSSemEn
0205430c g     O .bss	00000004 OS_TPS
0202ad4c g     F .text	00000748 rawip_usrreq
02018e04 g     F .text	00000394 OSFlagPost
0200728c g     F .text	00000008 __sclose
02047df4 g     F .text	0000005c print46_addr
04000000 g       *ABS*	00000000 __alt_heap_limit
02004628 g     F .text	00000014 fclose
02016da4 g     F .text	00000108 OS_EventTaskWait
02014500 g     F .text	00000060 __truncdfsf2
0200876c g     F .text	00000264 _strtol_r
02026abc g     F .text	0000013c print_uptime
0201794c g     F .text	000000c8 OS_TaskStatStkChk
0263e02c g     O .bss	00000190 _atexit0
0201d3d4 g     F .text	00000158 OSTaskDelReq
0200c528 g     F .text	0000161c _dtoa_r
02005e88 g     F .text	00000784 _malloc_r
02047914 g     F .text	00000024 md_unlink
020383f4 g     F .text	00000088 tse_mac_SwReset
020485c0 g     F .text	00000054 in_pcbdetach
020541dc g     O .rwdata	00000004 alt_errno
02054220 g     O .bss	00000004 current_flash_block
0200087c g     F .text	000000e4 sweep
02054208 g     O .rwdata	00000004 mdlist_size
02016898 g     F .text	0000006c OSStart
02011c74 g     F .text	000000f0 __submore
02046e30 g     F .text	00000030 u_mctest_init
02015a8c g     F .text	00000060 __env_unlock
020059a8 g     F .text	000000a8 _fwalk
02004880 g     F .text	0000001c fgetpos
0201d898 g     F .text	000001f4 OSTaskResume
0201a81c g     F .text	000000e8 OSMemQuery
02047f78 g     F .text	00000134 convert_ip
0203e3c4 g     F .text	000001b4 find_oldest_arp
02054150 g     O .rwdata	00000002 OSTaskStatEn
02054388 g     O .bss	00000004 arpReqsIn
02048f2c g     F .text	0000004c vf_free_buffer
0200e47c g     F .text	00000044 _mbtowc_r
0204a700 g     F .text	00000118 alt_fcntl
0205412a g     O .rwdata	00000002 OSMemMax
0201b66c g     F .text	00000170 OSQPostFront
020285c8 g     F .text	00000030 dtrap
020541a8 g     O .rwdata	00000004 kb_last
02006b1c g     F .text	000000f0 putc
020146f0 g     F .text	00000050 __divsi3
020392a4 g     F .text	00000048 alt_tse_mac_set_common_speed
0205429d g     O .bss	00000003 OSRdyTbl
02054104 g     O .rwdata	00000002 OSDebugEn
020216f8 g     F .text	00000114 alt_ro_zipfs_read
0204e064 g     O .rodata	00000014 __thenan_df
02024ae0 g     F .text	000000cc ip_exit
02004f78 g     F .text	0000013c _malloc_trim_r
02001350 g     F .text	000000b0 http_read_line
0204c128 g       *ABS*	00000000 __CTOR_END__
020219c0 g     F .text	00000058 alt_ro_zipfs_check_valid
0205411c g     O .rwdata	00000002 OSFlagNodeSize
02028750 g     F .text	000000ac cticks_hook
02054164 g     O .rwdata	00000002 OSTmrCfgMax
0203d4b0 g     F .text	00000094 sysuptime
0201ed10 g     F .text	00000260 alt_epcs_flash_write
020074c8 g     F .text	000000a4 strcmp
0200328c g     F .text	000001c0 generate_and_store_mac_addr
02042a28 g     F .text	000001b4 ip_reasm_delete_ire
0201ab14 g     F .text	000001f8 OSQCreate
020287fc g     F .text	0000005c irq_Mask
0201d52c g     F .text	000001a8 OSTaskNameGet
02054370 g     O .bss	00000004 nextppp
020542fc g     O .bss	00000004 irq_level
02023fa0 g     F .text	00000158 fixup_subnet_mask
0201b7dc g     F .text	0000020c OSQPostOpt
020169b0 g     F .text	00000220 OSTimeTick
02041304 g     F .text	00000130 ip_copypkt
0205414c g     O .rwdata	00000002 OSTaskMax
0204c128 g       *ABS*	00000000 __DTOR_LIST__
0201bca8 g     F .text	00000100 OSSemCreate
020542dc g     O .bss	00000004 igmp_all_hosts_group
02054170 g     O .rwdata	00000002 OSTmrWheelSize
02635e8c g     O .bss	00002000 LEDTaskStk
0202f290 g     F .text	00000038 sbselqueue
020542e4 g     O .bss	00000004 netmain_wakes
0203e93c g     F .text	0000026c arprcv
020521a8 g     O .rwdata	00000018 wstask
02027484 g     F .text	00000070 TK_OSTaskResume
020258b8 g     F .text	00000420 igmp_print_stats
0201417c g     F .text	0000005c __nedf2
02000960 g     F .text	00000084 http_cleanup_lcd_text
02029284 g     F .text	00000090 pffindtype
02021948 g     F .text	00000078 alt_ro_zipfs_fstat
02054146 g     O .rwdata	00000002 OSTaskDelEn
020541c0 g     O .rwdata	00000004 tcp_sendspace
02049fa8 g     F .text	00000110 vftell
0263d778 g     O .bss	00000012 eth_prt_buf
0201c508 g     F .text	00000118 OSSemQuery
0201ad0c g     F .text	000002d0 OSQDel
0201b390 g     F .text	00000174 OSQPendAbort
0201e670 g     F .text	00000034 alt_irq_init
02039264 g     F .text	00000040 alt_tse_mac_get_common_speed
0263daf0 g     O .bss	00000018 app_semaphore
02015728 g     F .text	00000060 alt_release_fd
02028ccc g     F .text	00000078 post_app_sem
02024c30 g     F .text	000000f0 igmp_init
02006fec g     F .text	0000006c sprintf
0204e078 g     O .rodata	00000100 __clz_tab
02047784 g     F .text	00000078 md_fwrite
0205423c g     O .bss	00000004 _PathLocale
02054310 g     O .bss	00000004 tcp_sleep_count
02029cd8 g     F .text	00000078 insque
020111e8 g     F .text	00000120 strtof
0204bcdc g     F .text	00000014 atexit
020543dc g     O .bss	00000004 vfsfiles
0200c0dc g     F .text	0000006c _write_r
0204bda0 g     F .text	00000050 _vsprintf_r
020455e4 g     F .text	000002a0 udp_send
02016738 g     F .text	00000088 OSSchedLock
02025024 g     F .text	000002a8 igmp_send
0200e344 g     F .text	0000001c setlocale
02018180 g     F .text	00000128 OSFlagCreate
02028858 g     F .text	00000040 irq_Unmask
0202b6bc g     F .text	000000d0 t_listen
0200fd6c g     F .text	00000008 nanf
020540d8 g     O .rwdata	00000004 _impure_ptr
02054248 g     O .bss	00000004 alt_argc
020356a4 g     F .text	000006ec tcp_usrreq
0203628c g     F .text	00000240 udp_usrreq
020291ec g     F .text	00000050 ncpalloc
0200e3d8 g     F .text	00000064 _mbrtowc_r
0203701c g     F .text	0000005c _do_dtors
02054116 g     O .rwdata	00000002 OSEventMultiEn
020541f0 g     O .rwdata	00000004 pingdelay
02005384 g     F .text	00000474 _fseek_r
0203defc g     F .text	00000070 arp_send_pending
0263d1b0 g     O .bss	000000e0 tse_mac_if
02045b6c g     F .text	000002cc igmpv1_input
02006ce4 g     F .text	000001ec __srefill_r
02028f40 g     F .text	00000074 pre_task_setup
02054330 g     O .bss	00000004 rcvdq_sem_ptr
02025f08 g     F .text	00000118 bsd_getsockname
02042bdc g     F .text	00000130 ip_reasm_mark_compact_rfq
02003898 g     F .text	0000012c FindLastFlashSectorOffset
020182a8 g     F .text	00000270 OSFlagDel
020542a0 g     O .bss	00000004 OSEventFreeList
02000020 g       .exceptions	00000000 alt_irq_entry
02019d54 g     F .text	00000174 OSMboxPendAbort
02054380 g     O .bss	00000004 arpcache
0204b514 g     F .text	00000314 icmp_destun
020440e4 g     F .text	00000064 lookup_mcast
0204a31c g     F .text	00000048 vfslookup
02043a90 g     F .text	00000400 ip_demux
0200f0d8 g     F .text	00000060 __ulp
0200fc44 g     F .text	00000038 __isinfd
02054314 g     O .bss	00000004 tcp_wakeup_count
0201879c g     F .text	00000600 OSFlagPend
02054162 g     O .rwdata	00000002 OSTmrEn
02004b5c g     F .text	00000018 __fp_unlock_all
02625d88 g     O .bss	0000c000 http_tx_buffer
02028c10 g     F .text	000000bc wait_app_sem
0200dc20 g     F .text	00000060 fputc
0205418c g     O .rwdata	00000004 ipmcfail_str
02054328 g     O .bss	00000004 memtrapsize
020296b8 g     F .text	000002f0 m_copy
020541c8 g     O .rwdata	00000008 alt_fs_list
0263db6c g     O .bss	00000014 mfreeq
02017764 g     F .text	0000007c OS_StrCopy
0202cc40 g     F .text	0000005c sobind
02002570 g     F .text	00000334 http_handle_post
02047568 g     F .text	00000078 init_memdev
02029d50 g     F .text	00000108 nptcp_init
0205412c g     O .rwdata	00000002 OSMemNameSize
0263d9c0 g     O .bss	000000f0 global_TCPwakeup_set
02037f84 g     F .text	0000001c OSInitHookEnd
0202ed58 g     F .text	000000c0 soisdisconnected
0203de78 g     F .text	00000084 arp_free_pending
02054158 g     O .rwdata	00000002 OSTCBPrioTblMax
0200e360 g     F .text	0000000c localeconv
0202ce8c g     F .text	00000348 soclose
02021bdc g     F .text	000000f4 epcs_read_buffer
0263d8b0 g     O .bss	00000014 bigfreeq
02054154 g     O .rwdata	00000002 OSTaskStatStkChkEn
020541ec g     O .rwdata	00000004 prompt
0201e948 g     F .text	00000054 alt_epcs_flash_init
0203c43c g     F .text	000001a8 alt_tse_phy_set_adv_10
020541b8 g     O .rwdata	00000004 tcp_keepidle
0202ab84 g     F .text	000001c8 rawip_soinput
02019744 g     F .text	000000fc OSMboxCreate
0203739c g     F .text	00000050 alt_ic_isr_register
02049dfc g     F .text	00000060 vfwrite
02054128 g     O .rwdata	00000002 OSMemEn
0202f038 g     F .text	000000a8 soqinsque
020543b4 g     O .bss	00000004 so_evtmap_delete
02005ba8 g     F .text	00000040 fwrite
020120e8 g     F .text	00000090 __hexdig_init
020070dc g     F .text	00000078 _sscanf_r
02054132 g     O .rwdata	00000002 OSMutexEn
020540a8 g     O .rwdata	00000008 mapping
020543a0 g     O .bss	00000004 h_ireq
02054214 g       *ABS*	00000000 _edata
020407e4 g     F .text	000005b0 ip_fragment
020237b0 g     F .text	00000128 iniche_devices_init
0263db80 g     O .bss	00000028 tcp_saveti
02026fc0 g     F .text	000000dc con_page
0263e1bc g       *ABS*	00000000 _end
0202e668 g     F .text	000004a8 sogetopt
02015028 g     F .text	00000068 alt_flash_open_dev
020542a4 g     O .bss	00000001 OSIntNesting
0203b2fc g     F .text	00000240 alt_tse_mac_associate_phy
02053bc0 g     O .rwdata	00000030 nettasks
0200253c g     F .text	00000034 http_send_redirect
020280f4 g     F .text	00000020 pk_get_max_intrsafe_buf_len
020410e4 g     F .text	00000220 iproute
0202a618 g     F .text	000000f4 np_stripoptions
020543b8 g     O .bss	00000001 so_evtmap
0200bf14 g     F .text	00000070 vfscanf
02054224 g     O .bss	00000004 board_control_mbox
0201f960 g     F .text	000000f4 altera_avalon_jtag_uart_ioctl
0200dc80 g     F .text	00000074 _fputs_r
0201e384 g     F .text	000001ec OSTimeDlyResume
020448ac g     F .text	000003ec add_route
02018648 g     F .text	00000154 OSFlagNameSet
02024588 g     F .text	000000b8 c_older
02019ab0 g     F .text	000002a4 OSMboxPend
02054228 g     O .bss	00000001 to_wstask
0202fa0c g     F .text	00000088 sbflush
02047608 g     F .text	00000020 md_fclose
02027808 g     F .text	0000002c tk_yield
0201da8c g     F .text	000001d4 OSTaskStkChk
02037488 g     F .text	000000a0 alt_ic_irq_disable
0202d40c g     F .text	0000055c sosend
02021f8c g     F .text	00000058 epcs_enter_4_bytes_mode
0205412e g     O .rwdata	00000002 OSMemSize
02040d94 g     F .text	000000a8 ip_mymach
020206e0 g     F .text	00000088 alt_avalon_sgdma_construct_descriptor
020071a8 g     F .text	00000088 __swrite
020542f8 g     O .bss	00000004 cticks_initialized
020541f4 g     O .rwdata	00000004 deflength
0202c3ec g     F .text	000001ec t_sendto
020540e0 g     O .rwdata	00000004 __malloc_trim_threshold
02006974 g     F .text	00000070 _perror_r
02037ae4 g     F .text	00000020 altera_nios2_qsys_irq_init
020542a8 g     O .bss	00000004 OSTCBCur
0202ca8c g     F .text	000001b4 socreate
0204bd0c g     F .text	00000038 exit
0263de38 g     O .bss	00000100 arp_table
020543f4 g     O .bss	00000004 icmpdu_hook
02054130 g     O .rwdata	00000002 OSMemTblSize
02005a50 g     F .text	000000b8 _fwalk_reent
0203db58 g     F .text	00000024 create_apptasks
020541b4 g     O .rwdata	00000004 tcp_ttl
0200ef30 g     F .text	000001a8 __mdiff
02015090 g     F .text	00000050 alt_flash_close_dev
0202923c g     F .text	00000048 ncpfree
02014740 g     F .text	0000005c __modsi3
020542c0 g     O .bss	00000004 MaxLnh
020384d0 g     F .text	00000050 tse_mac_setGMIImode
02047d74 g     F .text	00000080 inet_ntop
02045b00 g     F .text	0000002c udp_maxalloc
0203ce5c g     F .text	000000e4 marvell_cfg_gmii
020196ac g     F .text	00000098 OSMboxAccept
04000000 g       *ABS*	00000000 __alt_data_end
02000020 g     F .exceptions	00000000 alt_exception
02004b38 g     F .text	00000004 __sfp_lock_release
02016574 g     F .text	00000054 OSInit
02001b74 g     F .text	00000760 http_send_file_header
02000000 g       *ABS*	00000000 __alt_mem_sdram
0203b53c g     F .text	00000128 alt_tse_phy_cfg_pcs
0201de70 g     F .text	0000012c OSTaskQuery
0203d280 g     F .text	00000090 icmp_port_du
02054358 g     O .bss	00000004 tcp_iss
0201bb4c g     F .text	000000ac OS_QInit
0200fca8 g     F .text	000000c4 __sccl
020541a4 g     O .rwdata	00000004 bigbufsiz
020044d4 g     F .text	0000000c atoi
020177e0 g     F .text	00000054 OS_StrLen
02034e5c g     F .text	00000080 tcp_putseq
0201a628 g     F .text	0000011c OSMemNameSet
0204d3dc g     O .rodata	00000101 _ctype_
0202f65c g     F .text	000001d8 sbappendaddr
020543ec g     O .bss	00000004 vfs_total_rw_space
02046c98 g     F .text	00000114 ip_getmoptions
0205414a g     O .rwdata	00000002 OSTaskProfileEn
02045884 g     F .text	000000f0 udpswap
020542ac g     O .bss	00000004 OSTime
02054334 g     O .bss	00000004 nextslow
02034f54 g     F .text	00000284 tcp_slowtimo
02034b6c g     F .text	0000010c tcp_newtcpcb
0203eba8 g     F .text	000001a8 send_via_arp
02004454 g     F .text	00000080 LED_task
02042568 g     F .text	00000058 ip_reasm_find_ire
02014920 g     F .text	000000bc __fpcmp_parts_f
0263b90c g     O .bss	00000800 OSTaskIdleStk
02004b74 g     F .text	00000130 _fopen_r
0204c0e4 g     F .text	00000044 _exit
0204a538 g     F .text	00000058 isvfile_locked
0200fc7c g     F .text	0000002c __isnand
02019fd8 g     F .text	0000015c OSMboxPostOpt
020264bc g     F .text	000001cc bsd_select
02036c4c g     F .text	00000140 alt_alarm_start
02018518 g     F .text	00000130 OSFlagNameGet
02045b2c g     F .text	00000040 udp_free
020281d0 g     F .text	000000b8 getq
0204a68c g     F .text	00000024 prep_vfs
0201e570 g     F .text	00000064 OSTimeGet
020541e8 g     O .rwdata	00000004 name
0202fc4c g     F .text	000000fc sbdropend
02012b44 g     F .text	00000060 __muldi3
02005ce0 g     F .text	000001a8 __smakebuf_r
0203ed50 g     F .text	00000150 cb_arpent_tmo
02007c64 g     F .text	0000008c strlen
02046584 g     F .text	00000148 IPADDR_TO_NETP
02021cd0 g     F .text	00000050 epcs_write_enable
0202634c g     F .text	00000034 bsd_inet_ntoa
02037f08 g     F .text	0000001c OSTaskSwHook
020155d4 g     F .text	00000154 open
02048248 g     F .text	00000218 udp_open
0263c10c g     O .bss	00000b40 OSEventTbl
0202f1e8 g     F .text	00000054 socantsendmore
020543f0 g     O .bss	00000004 vfs_total_dyna_files
0201423c g     F .text	00000064 __gedf2
0263cc4c g     O .bss	00000510 OSTCBTbl
02012178 g     F .text	00000740 __gethex
0205438c g     O .bss	00000004 arpReqsOut
0201c620 g     F .text	00000100 OSSemSet
02054210 g     O .rwdata	00000004 http_root_path
02041ad4 g     F .text	00000564 ip_reasm_compute_overlap
02005884 g     F .text	00000110 _ftell_r
02038350 g     F .text	000000a4 tse_mac_aRxRead
020073e0 g     F .text	000000e8 strchr
0263d78a g     O .bss	00000012 ipreturn
020543a8 g     O .bss	00000004 port_prep
02053c43 g     O .rwdata	0000000d tcp_backoff
0202eb58 g     F .text	0000006c soisconnecting
0200dcf4 g     F .text	0000001c fputs
020541e0 g     O .rwdata	00000004 alt_priority_mask
020460c0 g     F .text	0000023c igmpv2_process_query
0202fdd4 g     F .text	000001ec t_select
0201bda8 g     F .text	00000270 OSSemDel
02036b24 g     F .text	00000128 udp4_sockaddr
020542b0 g     O .bss	00000004 OSFlagFreeList
02048824 g     F .text	000001dc in_pcbconnect
0205434c g     O .bss	00000004 dropline
020543a4 g     O .bss	00000004 ire_cticks
020373ec g     F .text	0000009c alt_ic_irq_enable
02054110 g     O .rwdata	00000002 OSEventNameSize
02019840 g     F .text	00000270 OSMboxDel
0200a828 g     F .text	00000024 __vfprintf_internal
0202738c g     F .text	00000088 tk_netmain
02048a00 g     F .text	00000058 in_pcbdisconnect
020542b4 g     O .bss	00000001 OSStatRdy
0263d15c g     O .bss	00000054 OSTCBPrioTbl
020159d4 g     F .text	000000b8 __env_lock
02054156 g     O .rwdata	00000002 OSTaskSwHookEn
02053f3c g     O .rwdata	00000024 mdio
02039524 g     F .text	000000e0 alt_tse_mac_set_speed
020202dc g     F .text	00000080 alt_avalon_sgdma_construct_mem_to_mem_desc_burst
02025cd8 g     F .text	00000118 bsd_accept
0200308c g     F .text	00000030 die_with_error
020541c4 g     O .rwdata	00000004 tcp_recvspace
02001714 g     F .text	000002cc http_process_request
02013c28 g     F .text	00000060 __subdf3
02036048 g     F .text	00000040 tcpinit
020542e0 g     O .bss	00000004 igmp_all_rtrs_group
0202ab20 g     F .text	00000064 rawip_lookup
0201f208 g     F .text	00000098 alt_epcs_flash_read
0203dc04 g     F .text	000000a0 fcntl
0200e984 g     F .text	000000b0 __lo0bits
0202f834 g     F .text	000001d8 sbcompress
0200a84c g     F .text	00001658 __svfscanf_r
02637e8c g     O .bss	00002000 BCTaskStk
020540f4 g     O .rwdata	00000008 alt_alarm_list
02011d64 g     F .text	0000019c _ungetc_r
02034c78 g     F .text	000000ac tcp_drop
0205411e g     O .rwdata	00000002 OSFlagWidth
02036fc0 g     F .text	0000005c _do_ctors
0203c1f4 g     F .text	00000248 alt_tse_phy_set_adv_100
02035234 g     F .text	00000470 tcp_timers
02024bac g     F .text	00000084 if_netnumber
02046dac g     F .text	00000084 ip_freemoptions
0202eb10 g     F .text	00000048 sohasoutofband
02030a68 g     F .text	00002340 tcp_input
02025df0 g     F .text	00000118 bsd_getpeername
02026380 g     F .text	0000013c bsd_recvfrom
02023768 g     F .text	00000048 close
02054260 g     O .bss	00000004 alt_envsem
020542b8 g     O .bss	00000004 OSIdleCtrRun
02016bd0 g     F .text	00000020 OSVersion
02054168 g     O .rwdata	00000002 OSTmrCfgWheelSize
0201df9c g     F .text	00000070 OS_TaskStkClr
02048dac g     F .text	00000028 set_vfopen_error
02014a08 g     F .text	00000224 __pack_d
02054142 g     O .rwdata	00000002 OSTaskCreateEn
020392ec g     F .text	0000006c alt_tse_get_system_index
02053c20 g     O .rwdata	00000018 rawip_protosw
0202f2c8 g     F .text	00000068 sbwait
0201719c g     F .text	00000068 OS_EventWaitListInit
02020c44 g     F .text	000000a4 alt_avalon_sgdma_init
02054374 g     O .bss	00000004 port_1s_callout
02037fa0 g     F .text	0000001c OSTaskIdleHook
0204bd58 g     F .text	00000014 free
02004b3c g     F .text	00000004 __sinit_lock_acquire
02021d88 g     F .text	0000011c epcs_write_buffer
020542bc g     O .bss	00000001 number_of_tse_mac
0200e704 g     F .text	00000114 __multadd
0200e6dc g     F .text	00000028 _Bfree
0201dc60 g     F .text	00000210 OSTaskSuspend
020540c0 g     O .rwdata	00000008 upload_field
020381e4 g     F .text	0000002c no_printf
0202ee18 g     F .text	00000220 sonewconn
0204a92c g     F .text	00000be8 icmprcv
02029314 g     F .text	000000c4 pffindproto
0202107c g     F .text	00000134 check_directory_header
02017834 g     F .text	0000005c OS_TaskIdle
0205416e g     O .rwdata	00000002 OSTmrTblSize
0201b9e8 g     F .text	00000164 OSQQuery



Disassembly of section .exceptions:

02000020 <alt_exception>:

#else /* ALT_EXCEPTION_STACK disabled */
        /* 
         * Reserve space on normal stack for registers about to be pushed.
         */
        addi  sp, sp, -76
 2000020:	deffed04 	addi	sp,sp,-76
         * documentation for details).
         *
         * Leave a gap in the stack frame at 4(sp) for the muldiv handler to
         * store zero into.
         */
        stw   ra,  0(sp)
 2000024:	dfc00015 	stw	ra,0(sp)
        stw   r1,   8(sp)
 2000028:	d8400215 	stw	at,8(sp)
        stw   r2,  12(sp)
 200002c:	d8800315 	stw	r2,12(sp)
        stw   r3,  16(sp)
 2000030:	d8c00415 	stw	r3,16(sp)
        stw   r4,  20(sp)
 2000034:	d9000515 	stw	r4,20(sp)
        stw   r5,  24(sp)
 2000038:	d9400615 	stw	r5,24(sp)
        stw   r6,  28(sp)
 200003c:	d9800715 	stw	r6,28(sp)
        stw   r7,  32(sp)
 2000040:	d9c00815 	stw	r7,32(sp)
        rdctl r5, estatus   /* Read early to avoid usage stall */
 2000044:	000b307a 	rdctl	r5,estatus
        stw   r8,  36(sp)
 2000048:	da000915 	stw	r8,36(sp)
        stw   r9,  40(sp)
 200004c:	da400a15 	stw	r9,40(sp)
        stw   r10, 44(sp)
 2000050:	da800b15 	stw	r10,44(sp)
        stw   r11, 48(sp)
 2000054:	dac00c15 	stw	r11,48(sp)
        stw   r12, 52(sp)
 2000058:	db000d15 	stw	r12,52(sp)
        stw   r13, 56(sp)
 200005c:	db400e15 	stw	r13,56(sp)
        stw   r14, 60(sp)
 2000060:	db800f15 	stw	r14,60(sp)
        stw   r15, 64(sp)
 2000064:	dbc01015 	stw	r15,64(sp)
        /*
         * ea-4 contains the address of the instruction being executed
         * when the exception occured. For interrupt exceptions, we will
         * will be re-issue the isntruction. Store it in 72(sp)
         */
        stw   r5,  68(sp)  /* estatus */
 2000068:	d9401115 	stw	r5,68(sp)
        addi  r15, ea, -4  /* instruction that caused exception */
 200006c:	ebffff04 	addi	r15,ea,-4
        stw   r15,  72(sp)
 2000070:	dbc01215 	stw	r15,72(sp)
#else
        /*
         * Test to see if the exception was a software exception or caused 
         * by an external interrupt, and vector accordingly.
         */
        rdctl r4, ipending
 2000074:	0009313a 	rdctl	r4,ipending
        andi  r2, r5, 1
 2000078:	2880004c 	andi	r2,r5,1
        beq   r2, zero, .Lnot_irq
 200007c:	10000326 	beq	r2,zero,200008c <alt_exception+0x6c>
        beq   r4, zero, .Lnot_irq
 2000080:	20000226 	beq	r4,zero,200008c <alt_exception+0x6c>
        /*
         * Now that all necessary registers have been preserved, call 
         * alt_irq_handler() to process the interrupts.
         */

        call alt_irq_handler
 2000084:	20000ec0 	call	20000ec <alt_irq_handler>

        .section .exceptions.irqreturn, "xa"

        br    .Lexception_exit
 2000088:	00000306 	br	2000098 <alt_exception_unknown+0x4>
         * upon completion, so we write ea (address of instruction *after*
         * the one where the exception occured) into 72(sp). The actual
         * instruction that caused the exception is written in r2, which these
         * handlers will utilize.
         */
        stw   ea,  72(sp)  /* Don't re-issue */
 200008c:	df401215 	stw	ea,72(sp)
        ldw   r2, -4(ea)   /* Instruction that caused exception */
 2000090:	e8bfff17 	ldw	r2,-4(ea)

02000094 <alt_exception_unknown>:
#ifdef NIOS2_HAS_DEBUG_STUB
       /*
        *  Either tell the user now (if there is a debugger attached) or go into
        *  the debug monitor which will loop until a debugger is attached.
        */
        break
 2000094:	003da03a 	break	0
        /* 
         * Restore the saved registers, so that all general purpose registers 
         * have been restored to their state at the time the interrupt occured.
         */

        ldw   r5,  68(sp)
 2000098:	d9401117 	ldw	r5,68(sp)
        ldw   ea,  72(sp)  /* This becomes the PC once eret is executed */
 200009c:	df401217 	ldw	ea,72(sp)
        ldw   ra,   0(sp)
 20000a0:	dfc00017 	ldw	ra,0(sp)

        wrctl estatus, r5
 20000a4:	2801707a 	wrctl	estatus,r5

        ldw   r1,   8(sp)
 20000a8:	d8400217 	ldw	at,8(sp)
        ldw   r2,  12(sp)
 20000ac:	d8800317 	ldw	r2,12(sp)
        ldw   r3,  16(sp)
 20000b0:	d8c00417 	ldw	r3,16(sp)
        ldw   r4,  20(sp)
 20000b4:	d9000517 	ldw	r4,20(sp)
        ldw   r5,  24(sp)
 20000b8:	d9400617 	ldw	r5,24(sp)
        ldw   r6,  28(sp)
 20000bc:	d9800717 	ldw	r6,28(sp)
        ldw   r7,  32(sp)
 20000c0:	d9c00817 	ldw	r7,32(sp)

#if defined(ALT_EXCEPTION_STACK) && defined(ALT_STACK_CHECK)
        ldw   et, %gprel(alt_exception_old_stack_limit)(gp)
#endif

        ldw   r8,  36(sp)
 20000c4:	da000917 	ldw	r8,36(sp)
        ldw   r9,  40(sp)
 20000c8:	da400a17 	ldw	r9,40(sp)
        ldw   r10, 44(sp)
 20000cc:	da800b17 	ldw	r10,44(sp)
        ldw   r11, 48(sp)
 20000d0:	dac00c17 	ldw	r11,48(sp)
        ldw   r12, 52(sp)
 20000d4:	db000d17 	ldw	r12,52(sp)
        ldw   r13, 56(sp)
 20000d8:	db400e17 	ldw	r13,56(sp)
        ldw   r14, 60(sp)
 20000dc:	db800f17 	ldw	r14,60(sp)
        ldw   r15, 64(sp)
 20000e0:	dbc01017 	ldw	r15,64(sp)
        stw   et, %gprel(alt_stack_limit_value)(gp)
        stw   zero, %gprel(alt_exception_old_stack_limit)(gp)
#endif /* ALT_STACK_CHECK */
        ldw   sp,  76(sp)
#else /* ALT_EXCEPTION_STACK disabled */
        addi  sp, sp, 76
 20000e4:	dec01304 	addi	sp,sp,76

        /*
         * Return to the interrupted instruction.
         */

        eret
 20000e8:	ef80083a 	eret

020000ec <alt_irq_handler>:
 * instruction is present if the macro ALT_CI_INTERRUPT_VECTOR defined.
 */

void alt_irq_handler (void) __attribute__ ((section (".exceptions")));
void alt_irq_handler (void)
{
 20000ec:	defff904 	addi	sp,sp,-28
 20000f0:	dfc00615 	stw	ra,24(sp)
 20000f4:	df000515 	stw	fp,20(sp)
 20000f8:	df000504 	addi	fp,sp,20
  
  /*
   * Notify the operating system that we are at interrupt level.
   */ 
  
  ALT_OS_INT_ENTER();
 20000fc:	20165c80 	call	20165c8 <OSIntEnter>
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 2000100:	0005313a 	rdctl	r2,ipending
 2000104:	e0bffe15 	stw	r2,-8(fp)

  return active;
 2000108:	e0bffe17 	ldw	r2,-8(fp)
   * Consider the case where the high priority interupt is asserted during
   * the interrupt entry sequence for a lower priority interrupt to see why
   * this is the case.
   */

  active = alt_irq_pending ();
 200010c:	e0bffb15 	stw	r2,-20(fp)

  do
  {
    i = 0;
 2000110:	e03ffd15 	stw	zero,-12(fp)
    mask = 1;
 2000114:	00800044 	movi	r2,1
 2000118:	e0bffc15 	stw	r2,-16(fp)
     * called to clear the interrupt condition.
     */

    do
    {
      if (active & mask)
 200011c:	e0fffb17 	ldw	r3,-20(fp)
 2000120:	e0bffc17 	ldw	r2,-16(fp)
 2000124:	1884703a 	and	r2,r3,r2
 2000128:	10001726 	beq	r2,zero,2000188 <alt_irq_handler+0x9c>
      { 
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
        alt_irq[i].handler(alt_irq[i].context); 
 200012c:	00c09934 	movhi	r3,612
 2000130:	18f72d04 	addi	r3,r3,-9036
 2000134:	e0bffd17 	ldw	r2,-12(fp)
 2000138:	100490fa 	slli	r2,r2,3
 200013c:	1885883a 	add	r2,r3,r2
 2000140:	10c00017 	ldw	r3,0(r2)
 2000144:	01009934 	movhi	r4,612
 2000148:	21372d04 	addi	r4,r4,-9036
 200014c:	e0bffd17 	ldw	r2,-12(fp)
 2000150:	100490fa 	slli	r2,r2,3
 2000154:	2085883a 	add	r2,r4,r2
 2000158:	10800104 	addi	r2,r2,4
 200015c:	10800017 	ldw	r2,0(r2)
 2000160:	1009883a 	mov	r4,r2
 2000164:	183ee83a 	callr	r3
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
 2000168:	0001883a 	nop
#ifndef NIOS2_EIC_PRESENT
static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_irq_pending (void)
{
  alt_u32 active;

  NIOS2_READ_IPENDING (active);
 200016c:	0005313a 	rdctl	r2,ipending
 2000170:	e0bfff15 	stw	r2,-4(fp)

  return active;
 2000174:	e0bfff17 	ldw	r2,-4(fp)
      mask <<= 1;
      i++;

    } while (1);

    active = alt_irq_pending ();
 2000178:	e0bffb15 	stw	r2,-20(fp)
    
  } while (active);
 200017c:	e0bffb17 	ldw	r2,-20(fp)
 2000180:	103fe31e 	bne	r2,zero,2000110 <alt_irq_handler+0x24>
 2000184:	00000706 	br	20001a4 <alt_irq_handler+0xb8>
#else
        alt_irq[i].handler(alt_irq[i].context, i); 
#endif
        break;
      }
      mask <<= 1;
 2000188:	e0bffc17 	ldw	r2,-16(fp)
 200018c:	1085883a 	add	r2,r2,r2
 2000190:	e0bffc15 	stw	r2,-16(fp)
      i++;
 2000194:	e0bffd17 	ldw	r2,-12(fp)
 2000198:	10800044 	addi	r2,r2,1
 200019c:	e0bffd15 	stw	r2,-12(fp)

    } while (1);
 20001a0:	003fde06 	br	200011c <alt_irq_handler+0x30>

  /*
   * Notify the operating system that interrupt processing is complete.
   */ 

  ALT_OS_INT_EXIT();
 20001a4:	20166440 	call	2016644 <OSIntExit>
}
 20001a8:	e037883a 	mov	sp,fp
 20001ac:	dfc00117 	ldw	ra,4(sp)
 20001b0:	df000017 	ldw	fp,0(sp)
 20001b4:	dec00204 	addi	sp,sp,8
 20001b8:	f800283a 	ret

Disassembly of section .text:

020001bc <_start>:

    /* Assume the data cache size is always a power of two. */
#if NIOS2_DCACHE_SIZE > 0x8000
    movhi r2, %hi(NIOS2_DCACHE_SIZE)
#else
    movui r2, NIOS2_DCACHE_SIZE
 20001bc:	00820014 	movui	r2,2048
#endif

0:
    initd 0(r2)
 20001c0:	10000033 	initd	0(r2)
#ifdef NIOS2_ECC_PRESENT
    addi r2, r2, -4
#else
    addi r2, r2, -NIOS2_DCACHE_LINE_SIZE
 20001c4:	10bff804 	addi	r2,r2,-32
#endif
    bgt r2, zero, 0b
 20001c8:	00bffd16 	blt	zero,r2,20001c0 <_start+0x4>

    /*
     * Now that the caches are initialized, set up the stack pointer and global pointer.
     * The values provided by the linker are assumed to be correctly aligned.
     */
    movhi sp, %hi(__alt_stack_pointer)
 20001cc:	06c10034 	movhi	sp,1024
    ori sp, sp, %lo(__alt_stack_pointer)
 20001d0:	dec00014 	ori	sp,sp,0
    movhi gp, %hi(_gp)
 20001d4:	06808174 	movhi	gp,517
    ori gp, gp, %lo(_gp)
 20001d8:	d6b02a14 	ori	gp,gp,49320
 */
#ifndef ALT_SIM_OPTIMIZE
    /* Log that the BSS is about to be cleared. */
    ALT_LOG_PUTS(alt_log_msg_bss)

    movhi r2, %hi(__bss_start)
 20001dc:	00808174 	movhi	r2,517
    ori r2, r2, %lo(__bss_start)
 20001e0:	10908514 	ori	r2,r2,16916

    movhi r3, %hi(__bss_end)
 20001e4:	00c098f4 	movhi	r3,611
    ori r3, r3, %lo(__bss_end)
 20001e8:	18f86f14 	ori	r3,r3,57788

    beq r2, r3, 1f
 20001ec:	10c00326 	beq	r2,r3,20001fc <_start+0x40>

0:
    stw zero, (r2)
 20001f0:	10000015 	stw	zero,0(r2)
    addi r2, r2, 4
 20001f4:	10800104 	addi	r2,r2,4
    bltu r2, r3, 0b
 20001f8:	10fffd36 	bltu	r2,r3,20001f0 <_start+0x34>

    /* Log that alt_main is about to be called. */
    ALT_LOG_PUTS(alt_log_msg_alt_main)

    /* Call the C entry point. It should never return. */
    call alt_main
 20001fc:	20153ec0 	call	20153ec <alt_main>

02000200 <alt_after_alt_main>:

    /* Wait in infinite loop in case alt_main does return. */
alt_after_alt_main:
    br alt_after_alt_main
 2000200:	003fff06 	br	2000200 <alt_after_alt_main>

02000204 <alt_uCOSIIErrorHandler>:
#include <errno.h>
#include "includes.h"
#include "alt_error_handler.h"
 
void alt_uCOSIIErrorHandler(INT8U error_code, void *expanded_diagnosis_ptr)
{
 2000204:	defffb04 	addi	sp,sp,-20
 2000208:	dfc00415 	stw	ra,16(sp)
 200020c:	df000315 	stw	fp,12(sp)
 2000210:	df000304 	addi	fp,sp,12
 2000214:	2005883a 	mov	r2,r4
 2000218:	e17fff15 	stw	r5,-4(fp)
 200021c:	e0bffe05 	stb	r2,-8(fp)
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
 2000220:	e0bffe03 	ldbu	r2,-8(fp)
 2000224:	10018326 	beq	r2,zero,2000834 <alt_uCOSIIErrorHandler+0x630>
   {
      return;
   }
   
   fault_level = SYSTEM;  
 2000228:	00800084 	movi	r2,2
 200022c:	e0bffd15 	stw	r2,-12(fp)
   OSSchedLock();  /* Disable Task Switching but still service other IRQs */
 2000230:	20167380 	call	2016738 <OSSchedLock>
      
   switch (error_code)
 2000234:	e0bffe03 	ldbu	r2,-8(fp)
 2000238:	10c00a20 	cmpeqi	r3,r2,40
 200023c:	1800261e 	bne	r3,zero,20002d8 <alt_uCOSIIErrorHandler+0xd4>
 2000240:	10c00a48 	cmpgei	r3,r2,41
 2000244:	1800121e 	bne	r3,zero,2000290 <alt_uCOSIIErrorHandler+0x8c>
 2000248:	10c00120 	cmpeqi	r3,r2,4
 200024c:	18006e1e 	bne	r3,zero,2000408 <alt_uCOSIIErrorHandler+0x204>
 2000250:	10c00148 	cmpgei	r3,r2,5
 2000254:	1800071e 	bne	r3,zero,2000274 <alt_uCOSIIErrorHandler+0x70>
 2000258:	10c000a0 	cmpeqi	r3,r2,2
 200025c:	18008e1e 	bne	r3,zero,2000498 <alt_uCOSIIErrorHandler+0x294>
 2000260:	10c000c8 	cmpgei	r3,r2,3
 2000264:	1800731e 	bne	r3,zero,2000434 <alt_uCOSIIErrorHandler+0x230>
 2000268:	10800060 	cmpeqi	r2,r2,1
 200026c:	1000591e 	bne	r2,zero,20003d4 <alt_uCOSIIErrorHandler+0x1d0>
 2000270:	0000de06 	br	20005ec <alt_uCOSIIErrorHandler+0x3e8>
 2000274:	10c00520 	cmpeqi	r3,r2,20
 2000278:	18004a1e 	bne	r3,zero,20003a4 <alt_uCOSIIErrorHandler+0x1a0>
 200027c:	10c007a0 	cmpeqi	r3,r2,30
 2000280:	1800b21e 	bne	r3,zero,200054c <alt_uCOSIIErrorHandler+0x348>
 2000284:	108002a0 	cmpeqi	r2,r2,10
 2000288:	1000771e 	bne	r2,zero,2000468 <alt_uCOSIIErrorHandler+0x264>
 200028c:	0000d706 	br	20005ec <alt_uCOSIIErrorHandler+0x3e8>
 2000290:	10c01020 	cmpeqi	r3,r2,64
 2000294:	1800a21e 	bne	r3,zero,2000520 <alt_uCOSIIErrorHandler+0x31c>
 2000298:	10c01048 	cmpgei	r3,r2,65
 200029c:	1800071e 	bne	r3,zero,20002bc <alt_uCOSIIErrorHandler+0xb8>
 20002a0:	10c00f60 	cmpeqi	r3,r2,61
 20002a4:	1800921e 	bne	r3,zero,20004f0 <alt_uCOSIIErrorHandler+0x2ec>
 20002a8:	10c00fa0 	cmpeqi	r3,r2,62
 20002ac:	1800851e 	bne	r3,zero,20004c4 <alt_uCOSIIErrorHandler+0x2c0>
 20002b0:	10800aa0 	cmpeqi	r2,r2,42
 20002b4:	1000131e 	bne	r2,zero,2000304 <alt_uCOSIIErrorHandler+0x100>
 20002b8:	0000cc06 	br	20005ec <alt_uCOSIIErrorHandler+0x3e8>
 20002bc:	10c01920 	cmpeqi	r3,r2,100
 20002c0:	1800ae1e 	bne	r3,zero,200057c <alt_uCOSIIErrorHandler+0x378>
 20002c4:	10c03fe0 	cmpeqi	r3,r2,255
 20002c8:	1800b91e 	bne	r3,zero,20005b0 <alt_uCOSIIErrorHandler+0x3ac>
 20002cc:	108010a0 	cmpeqi	r2,r2,66
 20002d0:	1000201e 	bne	r2,zero,2000354 <alt_uCOSIIErrorHandler+0x150>
 20002d4:	0000c506 	br	20005ec <alt_uCOSIIErrorHandler+0x3e8>
   {  
      case OS_PRIO_EXIST:
         fprintf(stderr, "Attempted to assign task priority aready in use.\n");
 20002d8:	00808174 	movhi	r2,517
 20002dc:	10903604 	addi	r2,r2,16600
 20002e0:	10800017 	ldw	r2,0(r2)
 20002e4:	10800317 	ldw	r2,12(r2)
 20002e8:	01008174 	movhi	r4,517
 20002ec:	21304a04 	addi	r4,r4,-16088
 20002f0:	01400044 	movi	r5,1
 20002f4:	01800c44 	movi	r6,49
 20002f8:	100f883a 	mov	r7,r2
 20002fc:	2005ba80 	call	2005ba8 <fwrite>
         break;
 2000300:	0000d506 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_PRIO_INVALID:
         fprintf(stderr, "Specified task priority higher than allowed max.\n");
 2000304:	00808174 	movhi	r2,517
 2000308:	10903604 	addi	r2,r2,16600
 200030c:	10800017 	ldw	r2,0(r2)
 2000310:	10800317 	ldw	r2,12(r2)
 2000314:	01008174 	movhi	r4,517
 2000318:	21305704 	addi	r4,r4,-16036
 200031c:	01400044 	movi	r5,1
 2000320:	01800c44 	movi	r6,49
 2000324:	100f883a 	mov	r7,r2
 2000328:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "Task can't be assigned a priority higher than %d\n",
 200032c:	00808174 	movhi	r2,517
 2000330:	10903604 	addi	r2,r2,16600
 2000334:	10800017 	ldw	r2,0(r2)
 2000338:	10800317 	ldw	r2,12(r2)
 200033c:	1009883a 	mov	r4,r2
 2000340:	01408174 	movhi	r5,517
 2000344:	29706404 	addi	r5,r5,-15984
 2000348:	01800504 	movi	r6,20
 200034c:	2004ce80 	call	2004ce8 <fprintf>
            OS_LOWEST_PRIO);
         break;
 2000350:	0000c106 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_NO_MORE_TCB:
         fprintf(stderr, "Task Control Blocks have been exhausted\n");
 2000354:	00808174 	movhi	r2,517
 2000358:	10903604 	addi	r2,r2,16600
 200035c:	10800017 	ldw	r2,0(r2)
 2000360:	10800317 	ldw	r2,12(r2)
 2000364:	01008174 	movhi	r4,517
 2000368:	21307104 	addi	r4,r4,-15932
 200036c:	01400044 	movi	r5,1
 2000370:	01800a04 	movi	r6,40
 2000374:	100f883a 	mov	r7,r2
 2000378:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "Current max number of tasks is %d\n",OS_MAX_TASKS);
 200037c:	00808174 	movhi	r2,517
 2000380:	10903604 	addi	r2,r2,16600
 2000384:	10800017 	ldw	r2,0(r2)
 2000388:	10800317 	ldw	r2,12(r2)
 200038c:	1009883a 	mov	r4,r2
 2000390:	01408174 	movhi	r5,517
 2000394:	29707c04 	addi	r5,r5,-15888
 2000398:	01800284 	movi	r6,10
 200039c:	2004ce80 	call	2004ce8 <fprintf>
         break;
 20003a0:	0000ad06 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_MBOX_FULL:
         fault_level = NONE;
 20003a4:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted Post to Mailbox already holding message\n");
 20003a8:	00808174 	movhi	r2,517
 20003ac:	10903604 	addi	r2,r2,16600
 20003b0:	10800017 	ldw	r2,0(r2)
 20003b4:	10800317 	ldw	r2,12(r2)
 20003b8:	01008174 	movhi	r4,517
 20003bc:	21308504 	addi	r4,r4,-15852
 20003c0:	01400044 	movi	r5,1
 20003c4:	01800c84 	movi	r6,50
 20003c8:	100f883a 	mov	r7,r2
 20003cc:	2005ba80 	call	2005ba8 <fwrite>
         break;
 20003d0:	0000a106 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_ERR_EVENT_TYPE:
         fault_level = TASK;
 20003d4:	00800044 	movi	r2,1
 20003d8:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, 
 20003dc:	00808174 	movhi	r2,517
 20003e0:	10903604 	addi	r2,r2,16600
 20003e4:	10800017 	ldw	r2,0(r2)
 20003e8:	10800317 	ldw	r2,12(r2)
 20003ec:	01008174 	movhi	r4,517
 20003f0:	21309204 	addi	r4,r4,-15800
 20003f4:	01400044 	movi	r5,1
 20003f8:	01801244 	movi	r6,73
 20003fc:	100f883a 	mov	r7,r2
 2000400:	2005ba80 	call	2005ba8 <fwrite>
"Attempted to access a resource with no match for the required data type.\n");
         break;
 2000404:	00009406 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_ERR_PEVENT_NULL:
         fprintf(stderr, "Attempting to access a resource pointing to NULL\n");
 2000408:	00808174 	movhi	r2,517
 200040c:	10903604 	addi	r2,r2,16600
 2000410:	10800017 	ldw	r2,0(r2)
 2000414:	10800317 	ldw	r2,12(r2)
 2000418:	01008174 	movhi	r4,517
 200041c:	2130a504 	addi	r4,r4,-15724
 2000420:	01400044 	movi	r5,1
 2000424:	01800c44 	movi	r6,49
 2000428:	100f883a 	mov	r7,r2
 200042c:	2005ba80 	call	2005ba8 <fwrite>
         break;
 2000430:	00008906 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_ERR_POST_NULL_PTR:
         fault_level = TASK;
 2000434:	00800044 	movi	r2,1
 2000438:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to Post a NULL to a resource. \n");
 200043c:	00808174 	movhi	r2,517
 2000440:	10903604 	addi	r2,r2,16600
 2000444:	10800017 	ldw	r2,0(r2)
 2000448:	10800317 	ldw	r2,12(r2)
 200044c:	01008174 	movhi	r4,517
 2000450:	2130b204 	addi	r4,r4,-15672
 2000454:	01400044 	movi	r5,1
 2000458:	01800a44 	movi	r6,41
 200045c:	100f883a 	mov	r7,r2
 2000460:	2005ba80 	call	2005ba8 <fwrite>
         break;
 2000464:	00007c06 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_TIMEOUT:
         fault_level = NONE;
 2000468:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Resource not received in specified time\n");
 200046c:	00808174 	movhi	r2,517
 2000470:	10903604 	addi	r2,r2,16600
 2000474:	10800017 	ldw	r2,0(r2)
 2000478:	10800317 	ldw	r2,12(r2)
 200047c:	01008174 	movhi	r4,517
 2000480:	2130bd04 	addi	r4,r4,-15628
 2000484:	01400044 	movi	r5,1
 2000488:	01800a04 	movi	r6,40
 200048c:	100f883a 	mov	r7,r2
 2000490:	2005ba80 	call	2005ba8 <fwrite>
         break;
 2000494:	00007006 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_ERR_PEND_ISR:
         fprintf(stderr, "Attempting to pend for a resource in an ISR\n");
 2000498:	00808174 	movhi	r2,517
 200049c:	10903604 	addi	r2,r2,16600
 20004a0:	10800017 	ldw	r2,0(r2)
 20004a4:	10800317 	ldw	r2,12(r2)
 20004a8:	01008174 	movhi	r4,517
 20004ac:	2130c804 	addi	r4,r4,-15584
 20004b0:	01400044 	movi	r5,1
 20004b4:	01800b04 	movi	r6,44
 20004b8:	100f883a 	mov	r7,r2
 20004bc:	2005ba80 	call	2005ba8 <fwrite>
         break;
 20004c0:	00006506 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_TASK_DEL_IDLE:
         fprintf(stderr, "Attempted to delete the IDLE task\n");
 20004c4:	00808174 	movhi	r2,517
 20004c8:	10903604 	addi	r2,r2,16600
 20004cc:	10800017 	ldw	r2,0(r2)
 20004d0:	10800317 	ldw	r2,12(r2)
 20004d4:	01008174 	movhi	r4,517
 20004d8:	2130d404 	addi	r4,r4,-15536
 20004dc:	01400044 	movi	r5,1
 20004e0:	01800884 	movi	r6,34
 20004e4:	100f883a 	mov	r7,r2
 20004e8:	2005ba80 	call	2005ba8 <fwrite>
         break;
 20004ec:	00005a06 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_TASK_DEL_ERR:
         fault_level = NONE;
 20004f0:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to delete a task that does not exist\n");
 20004f4:	00808174 	movhi	r2,517
 20004f8:	10903604 	addi	r2,r2,16600
 20004fc:	10800017 	ldw	r2,0(r2)
 2000500:	10800317 	ldw	r2,12(r2)
 2000504:	01008174 	movhi	r4,517
 2000508:	2130dd04 	addi	r4,r4,-15500
 200050c:	01400044 	movi	r5,1
 2000510:	01800bc4 	movi	r6,47
 2000514:	100f883a 	mov	r7,r2
 2000518:	2005ba80 	call	2005ba8 <fwrite>
         break;
 200051c:	00004e06 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_TASK_DEL_ISR:
         fprintf(stderr, "Attempted to delete a task from an ISR\n");
 2000520:	00808174 	movhi	r2,517
 2000524:	10903604 	addi	r2,r2,16600
 2000528:	10800017 	ldw	r2,0(r2)
 200052c:	10800317 	ldw	r2,12(r2)
 2000530:	01008174 	movhi	r4,517
 2000534:	2130e904 	addi	r4,r4,-15452
 2000538:	01400044 	movi	r5,1
 200053c:	018009c4 	movi	r6,39
 2000540:	100f883a 	mov	r7,r2
 2000544:	2005ba80 	call	2005ba8 <fwrite>
         break;
 2000548:	00004306 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_Q_FULL:
         fault_level = NONE;
 200054c:	e03ffd15 	stw	zero,-12(fp)
         fprintf(stderr, "Attempted to post to a full message queue\n");
 2000550:	00808174 	movhi	r2,517
 2000554:	10903604 	addi	r2,r2,16600
 2000558:	10800017 	ldw	r2,0(r2)
 200055c:	10800317 	ldw	r2,12(r2)
 2000560:	01008174 	movhi	r4,517
 2000564:	2130f304 	addi	r4,r4,-15412
 2000568:	01400044 	movi	r5,1
 200056c:	01800a84 	movi	r6,42
 2000570:	100f883a 	mov	r7,r2
 2000574:	2005ba80 	call	2005ba8 <fwrite>
         break;
 2000578:	00003706 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case OS_ERR_NOT_MUTEX_OWNER:
         fault_level = TASK;
 200057c:	00800044 	movi	r2,1
 2000580:	e0bffd15 	stw	r2,-12(fp)
         fprintf(stderr, "Attempted to post a mutex not owned by the task\n");
 2000584:	00808174 	movhi	r2,517
 2000588:	10903604 	addi	r2,r2,16600
 200058c:	10800017 	ldw	r2,0(r2)
 2000590:	10800317 	ldw	r2,12(r2)
 2000594:	01008174 	movhi	r4,517
 2000598:	2130fe04 	addi	r4,r4,-15368
 200059c:	01400044 	movi	r5,1
 20005a0:	01800c04 	movi	r6,48
 20005a4:	100f883a 	mov	r7,r2
 20005a8:	2005ba80 	call	2005ba8 <fwrite>
         break;
 20005ac:	00002a06 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      case EXPANDED_DIAGNOSIS_CODE:      
         fault_level = SYSTEM;
 20005b0:	00800084 	movi	r2,2
 20005b4:	e0bffd15 	stw	r2,-12(fp)
         printf(
 20005b8:	01008174 	movhi	r4,517
 20005bc:	21310b04 	addi	r4,r4,-15316
 20005c0:	2006a240 	call	2006a24 <printf>
"\n[MicroC/OS-II]: See STDERR for expanded diagnosis translation.");    
         fprintf(stderr, "\n[MicroC/OS-II]: Expanded Diagnosis: %s.", 
 20005c4:	00808174 	movhi	r2,517
 20005c8:	10903604 	addi	r2,r2,16600
 20005cc:	10800017 	ldw	r2,0(r2)
 20005d0:	10800317 	ldw	r2,12(r2)
 20005d4:	1009883a 	mov	r4,r2
 20005d8:	01408174 	movhi	r5,517
 20005dc:	29711b04 	addi	r5,r5,-15252
 20005e0:	e1bfff17 	ldw	r6,-4(fp)
 20005e4:	2004ce80 	call	2004ce8 <fprintf>
                 (char *)expanded_diagnosis_ptr);
         break;           
 20005e8:	00001b06 	br	2000658 <alt_uCOSIIErrorHandler+0x454>
      default:
         printf("\n[MicroC/OS-II]: (Not a MicroC/OS-II error) See STDERR.\n");    
 20005ec:	01008174 	movhi	r4,517
 20005f0:	21312604 	addi	r4,r4,-15208
 20005f4:	2006cb40 	call	2006cb4 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]:");
 20005f8:	00808174 	movhi	r2,517
 20005fc:	10903604 	addi	r2,r2,16600
 2000600:	10800017 	ldw	r2,0(r2)
 2000604:	10800317 	ldw	r2,12(r2)
 2000608:	01008174 	movhi	r4,517
 200060c:	21313404 	addi	r4,r4,-15152
 2000610:	01400044 	movi	r5,1
 2000614:	01800404 	movi	r6,16
 2000618:	100f883a 	mov	r7,r2
 200061c:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "\nError_code %d.\n", error_code);
 2000620:	00808174 	movhi	r2,517
 2000624:	10903604 	addi	r2,r2,16600
 2000628:	10800017 	ldw	r2,0(r2)
 200062c:	10c00317 	ldw	r3,12(r2)
 2000630:	e0bffe03 	ldbu	r2,-8(fp)
 2000634:	1809883a 	mov	r4,r3
 2000638:	01408174 	movhi	r5,517
 200063c:	29713904 	addi	r5,r5,-15132
 2000640:	100d883a 	mov	r6,r2
 2000644:	2004ce80 	call	2004ce8 <fprintf>
         perror("\n[MicroC/OS-II]: (Not a MicroC/OS-II error), ERRNO: ");
 2000648:	01008174 	movhi	r4,517
 200064c:	21313e04 	addi	r4,r4,-15112
 2000650:	20069e40 	call	20069e4 <perror>
         break;
 2000654:	0001883a 	nop

   }

   /* Process the error based on the fault level, 
    * reenable scheduler if appropriate. */  
   switch (fault_level) {
 2000658:	e0bffd17 	ldw	r2,-12(fp)
 200065c:	10c00060 	cmpeqi	r3,r2,1
 2000660:	1800041e 	bne	r3,zero,2000674 <alt_uCOSIIErrorHandler+0x470>
 2000664:	0080442e 	bgeu	zero,r2,2000778 <alt_uCOSIIErrorHandler+0x574>
 2000668:	108000a0 	cmpeqi	r2,r2,2
 200066c:	1000201e 	bne	r2,zero,20006f0 <alt_uCOSIIErrorHandler+0x4ec>
 2000670:	00006206 	br	20007fc <alt_uCOSIIErrorHandler+0x5f8>
      case TASK:
         /* Error can be isolated by killing the task */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is TASK).");
 2000674:	01008174 	movhi	r4,517
 2000678:	21314c04 	addi	r4,r4,-15056
 200067c:	2006a240 	call	2006a24 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is TASK");
 2000680:	00808174 	movhi	r2,517
 2000684:	10903604 	addi	r2,r2,16600
 2000688:	10800017 	ldw	r2,0(r2)
 200068c:	10800317 	ldw	r2,12(r2)
 2000690:	01008174 	movhi	r4,517
 2000694:	21315904 	addi	r4,r4,-15004
 2000698:	01400044 	movi	r5,1
 200069c:	01800904 	movi	r6,36
 20006a0:	100f883a 	mov	r7,r2
 20006a4:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Task is being deleted.\n");
 20006a8:	00808174 	movhi	r2,517
 20006ac:	10903604 	addi	r2,r2,16600
 20006b0:	10800017 	ldw	r2,0(r2)
 20006b4:	10800317 	ldw	r2,12(r2)
 20006b8:	01008174 	movhi	r4,517
 20006bc:	21316304 	addi	r4,r4,-14964
 20006c0:	01400044 	movi	r5,1
 20006c4:	01800a04 	movi	r6,40
 20006c8:	100f883a 	mov	r7,r2
 20006cc:	2005ba80 	call	2005ba8 <fwrite>
         OSSchedUnlock(); /* Reenable Task Switching */
 20006d0:	20167c00 	call	20167c0 <OSSchedUnlock>
         OSTaskDel(OS_PRIO_SELF);
 20006d4:	01003fc4 	movi	r4,255
 20006d8:	201cff80 	call	201cff8 <OSTaskDel>
         /* Reinvoke uCOSII error handler in case task deletion fails, in 
          * which case fault_level for this secondary error will be SYSTEM. */
         alt_uCOSIIErrorHandler(error_code, 0);         
 20006dc:	e0bffe03 	ldbu	r2,-8(fp)
 20006e0:	1009883a 	mov	r4,r2
 20006e4:	000b883a 	mov	r5,zero
 20006e8:	20002040 	call	2000204 <alt_uCOSIIErrorHandler>
         break;
 20006ec:	00005006 	br	2000830 <alt_uCOSIIErrorHandler+0x62c>
      case SYSTEM:
         /* Total System Failure, Restart Required */
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is SYSTEM).");    
 20006f0:	01008174 	movhi	r4,517
 20006f4:	21316e04 	addi	r4,r4,-14920
 20006f8:	2006a240 	call	2006a24 <printf>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is SYSTEM");
 20006fc:	00808174 	movhi	r2,517
 2000700:	10903604 	addi	r2,r2,16600
 2000704:	10800017 	ldw	r2,0(r2)
 2000708:	10800317 	ldw	r2,12(r2)
 200070c:	01008174 	movhi	r4,517
 2000710:	21317c04 	addi	r4,r4,-14864
 2000714:	01400044 	movi	r5,1
 2000718:	01800984 	movi	r6,38
 200071c:	100f883a 	mov	r7,r2
 2000720:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: FATAL Error, Restart required.");
 2000724:	00808174 	movhi	r2,517
 2000728:	10903604 	addi	r2,r2,16600
 200072c:	10800017 	ldw	r2,0(r2)
 2000730:	10800317 	ldw	r2,12(r2)
 2000734:	01008174 	movhi	r4,517
 2000738:	21318604 	addi	r4,r4,-14824
 200073c:	01400044 	movi	r5,1
 2000740:	01800bc4 	movi	r6,47
 2000744:	100f883a 	mov	r7,r2
 2000748:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Locking scheduler - endless loop.\n");
 200074c:	00808174 	movhi	r2,517
 2000750:	10903604 	addi	r2,r2,16600
 2000754:	10800017 	ldw	r2,0(r2)
 2000758:	10800317 	ldw	r2,12(r2)
 200075c:	01008174 	movhi	r4,517
 2000760:	21319204 	addi	r4,r4,-14776
 2000764:	01400044 	movi	r5,1
 2000768:	01800cc4 	movi	r6,51
 200076c:	100f883a 	mov	r7,r2
 2000770:	2005ba80 	call	2005ba8 <fwrite>
         while(1); /* Since scheduler is locked,loop halts all task activity.*/
 2000774:	003fff06 	br	2000774 <alt_uCOSIIErrorHandler+0x570>
         break;
      case NONE:
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is NONE");
 2000778:	00808174 	movhi	r2,517
 200077c:	10903604 	addi	r2,r2,16600
 2000780:	10800017 	ldw	r2,0(r2)
 2000784:	10800317 	ldw	r2,12(r2)
 2000788:	01008174 	movhi	r4,517
 200078c:	21319f04 	addi	r4,r4,-14724
 2000790:	01400044 	movi	r5,1
 2000794:	01800904 	movi	r6,36
 2000798:	100f883a 	mov	r7,r2
 200079c:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, "\n[MicroC/OS-II]: Informational error only, control"); 
 20007a0:	00808174 	movhi	r2,517
 20007a4:	10903604 	addi	r2,r2,16600
 20007a8:	10800017 	ldw	r2,0(r2)
 20007ac:	10800317 	ldw	r2,12(r2)
 20007b0:	01008174 	movhi	r4,517
 20007b4:	2131a904 	addi	r4,r4,-14684
 20007b8:	01400044 	movi	r5,1
 20007bc:	01800c84 	movi	r6,50
 20007c0:	100f883a 	mov	r7,r2
 20007c4:	2005ba80 	call	2005ba8 <fwrite>
         fprintf(stderr, 
 20007c8:	00808174 	movhi	r2,517
 20007cc:	10903604 	addi	r2,r2,16600
 20007d0:	10800017 	ldw	r2,0(r2)
 20007d4:	10800317 	ldw	r2,12(r2)
 20007d8:	01008174 	movhi	r4,517
 20007dc:	2131b604 	addi	r4,r4,-14632
 20007e0:	01400044 	movi	r5,1
 20007e4:	01800f84 	movi	r6,62
 20007e8:	100f883a 	mov	r7,r2
 20007ec:	2005ba80 	call	2005ba8 <fwrite>
            "returned to task to complete processing at application level.\n");
         OSSchedUnlock(); /* Reenable Task Switching */
 20007f0:	20167c00 	call	20167c0 <OSSchedUnlock>
         return;   
 20007f4:	0001883a 	nop
 20007f8:	00000f06 	br	2000838 <alt_uCOSIIErrorHandler+0x634>
         break;      
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
 20007fc:	01008174 	movhi	r4,517
 2000800:	2131c604 	addi	r4,r4,-14568
 2000804:	2006cb40 	call	2006cb4 <puts>
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
 2000808:	00808174 	movhi	r2,517
 200080c:	10903604 	addi	r2,r2,16600
 2000810:	10800017 	ldw	r2,0(r2)
 2000814:	10800317 	ldw	r2,12(r2)
 2000818:	01008174 	movhi	r4,517
 200081c:	2131d404 	addi	r4,r4,-14512
 2000820:	01400044 	movi	r5,1
 2000824:	01800ac4 	movi	r6,43
 2000828:	100f883a 	mov	r7,r2
 200082c:	2005ba80 	call	2005ba8 <fwrite>
   }
   while(1); /* Correct Program Flow never gets here. */
 2000830:	003fff06 	br	2000830 <alt_uCOSIIErrorHandler+0x62c>
{
   FAULT_LEVEL fault_level;
   
   if(error_code == OS_NO_ERR)
   {
      return;
 2000834:	0001883a 	nop
      default:
         printf("\n[MicroC/OS-II]: See STDERR (FAULT_LEVEL is Unknown).\n");
         fprintf(stderr, "\n[MicroC/OS-II]: FAULT_LEVEL is unknown!?!\n");
   }
   while(1); /* Correct Program Flow never gets here. */
}
 2000838:	e037883a 	mov	sp,fp
 200083c:	dfc00117 	ldw	ra,4(sp)
 2000840:	df000017 	ldw	fp,0(sp)
 2000844:	dec00204 	addi	sp,sp,8
 2000848:	f800283a 	ret

0200084c <print>:
 * 
 * This routine is called to demonstrate doing something server-side when an
 * HTTP "POST" command is received.
 */
void print()
{
 200084c:	defffe04 	addi	sp,sp,-8
 2000850:	dfc00115 	stw	ra,4(sp)
 2000854:	df000015 	stw	fp,0(sp)
 2000858:	d839883a 	mov	fp,sp
  printf("HTTP POST received.\n");
 200085c:	01008174 	movhi	r4,517
 2000860:	21327204 	addi	r4,r4,-13880
 2000864:	2006cb40 	call	2006cb4 <puts>
}
 2000868:	e037883a 	mov	sp,fp
 200086c:	dfc00117 	ldw	ra,4(sp)
 2000870:	df000017 	ldw	fp,0(sp)
 2000874:	dec00204 	addi	sp,sp,8
 2000878:	f800283a 	ret

0200087c <sweep>:
/* To sweep or not to sweep?  The sweep form will tell this function what to do.
 */


void sweep(http_conn* conn)
{
 200087c:	defffc04 	addi	sp,sp,-16
 2000880:	dfc00315 	stw	ra,12(sp)
 2000884:	df000215 	stw	fp,8(sp)
 2000888:	df000204 	addi	fp,sp,8
 200088c:	e13fff15 	stw	r4,-4(fp)
  char *delimiter_token;

  /* Set board_funcs to be off, by default. */
  
  board_funcs.LED_ON = 0;
 2000890:	008098b4 	movhi	r2,610
 2000894:	10a74b04 	addi	r2,r2,-25300
 2000898:	10000005 	stb	zero,0(r2)
  board_funcs.SSD_ON = 0;
 200089c:	008098b4 	movhi	r2,610
 20008a0:	10a74b04 	addi	r2,r2,-25300
 20008a4:	10000045 	stb	zero,1(r2)

  delimiter_token = strtok(conn->rx_rd_pos, "&");
 20008a8:	e0bfff17 	ldw	r2,-4(fp)
 20008ac:	10800d17 	ldw	r2,52(r2)
 20008b0:	1009883a 	mov	r4,r2
 20008b4:	01408174 	movhi	r5,517
 20008b8:	29727704 	addi	r5,r5,-13860
 20008bc:	20086a80 	call	20086a8 <strtok>
 20008c0:	e0bffe15 	stw	r2,-8(fp)
  
  while(delimiter_token != NULL)
 20008c4:	00001806 	br	2000928 <sweep+0xac>
  {
    if (strstr(delimiter_token, "LED"))
 20008c8:	e13ffe17 	ldw	r4,-8(fp)
 20008cc:	01408174 	movhi	r5,517
 20008d0:	29727804 	addi	r5,r5,-13856
 20008d4:	20083340 	call	2008334 <strstr>
 20008d8:	10000526 	beq	r2,zero,20008f0 <sweep+0x74>
    {
      board_funcs.LED_ON = 1;
 20008dc:	008098b4 	movhi	r2,610
 20008e0:	10a74b04 	addi	r2,r2,-25300
 20008e4:	00c00044 	movi	r3,1
 20008e8:	10c00005 	stb	r3,0(r2)
 20008ec:	00000906 	br	2000914 <sweep+0x98>
    }
    else if (strstr(delimiter_token, "seven"))
 20008f0:	e13ffe17 	ldw	r4,-8(fp)
 20008f4:	01408174 	movhi	r5,517
 20008f8:	29727904 	addi	r5,r5,-13852
 20008fc:	20083340 	call	2008334 <strstr>
 2000900:	10000426 	beq	r2,zero,2000914 <sweep+0x98>
    {
      board_funcs.SSD_ON = 1;
 2000904:	008098b4 	movhi	r2,610
 2000908:	10a74b04 	addi	r2,r2,-25300
 200090c:	00c00044 	movi	r3,1
 2000910:	10c00045 	stb	r3,1(r2)
    }

    delimiter_token = strtok( NULL, "&" );
 2000914:	0009883a 	mov	r4,zero
 2000918:	01408174 	movhi	r5,517
 200091c:	29727704 	addi	r5,r5,-13860
 2000920:	20086a80 	call	20086a8 <strtok>
 2000924:	e0bffe15 	stw	r2,-8(fp)
  board_funcs.LED_ON = 0;
  board_funcs.SSD_ON = 0;

  delimiter_token = strtok(conn->rx_rd_pos, "&");
  
  while(delimiter_token != NULL)
 2000928:	e0bffe17 	ldw	r2,-8(fp)
 200092c:	103fe61e 	bne	r2,zero,20008c8 <sweep+0x4c>
    }

    delimiter_token = strtok( NULL, "&" );
  }
  
  OSMboxPost(board_control_mbox, (void*)&board_funcs);
 2000930:	00808174 	movhi	r2,517
 2000934:	10908904 	addi	r2,r2,16932
 2000938:	10800017 	ldw	r2,0(r2)
 200093c:	1009883a 	mov	r4,r2
 2000940:	014098b4 	movhi	r5,610
 2000944:	29674b04 	addi	r5,r5,-25300
 2000948:	2019ec80 	call	2019ec8 <OSMboxPost>
 
}
 200094c:	e037883a 	mov	sp,fp
 2000950:	dfc00117 	ldw	ra,4(sp)
 2000954:	df000017 	ldw	fp,0(sp)
 2000958:	dec00204 	addi	sp,sp,8
 200095c:	f800283a 	ret

02000960 <http_cleanup_lcd_text>:

void http_cleanup_lcd_text()
{
 2000960:	defffe04 	addi	sp,sp,-8
 2000964:	df000115 	stw	fp,4(sp)
 2000968:	df000104 	addi	fp,sp,4

  /* Step through the board_funcs.LCD_TEXT array looking for chars to replace.
   * For now, just replace '+'s with space characters.
   */

  for (index = 0; index < 20; ++index)
 200096c:	e03fff15 	stw	zero,-4(fp)
 2000970:	00001506 	br	20009c8 <http_cleanup_lcd_text+0x68>
  {
    if (board_funcs.LCD_TEXT[index] == '+')
 2000974:	00c098b4 	movhi	r3,610
 2000978:	18e74b04 	addi	r3,r3,-25300
 200097c:	e0bfff17 	ldw	r2,-4(fp)
 2000980:	1885883a 	add	r2,r3,r2
 2000984:	10800084 	addi	r2,r2,2
 2000988:	10800003 	ldbu	r2,0(r2)
 200098c:	10803fcc 	andi	r2,r2,255
 2000990:	1080201c 	xori	r2,r2,128
 2000994:	10bfe004 	addi	r2,r2,-128
 2000998:	10800ad8 	cmpnei	r2,r2,43
 200099c:	1000071e 	bne	r2,zero,20009bc <http_cleanup_lcd_text+0x5c>
    {
      board_funcs.LCD_TEXT[index] = ' ';
 20009a0:	00c098b4 	movhi	r3,610
 20009a4:	18e74b04 	addi	r3,r3,-25300
 20009a8:	e0bfff17 	ldw	r2,-4(fp)
 20009ac:	1885883a 	add	r2,r3,r2
 20009b0:	10800084 	addi	r2,r2,2
 20009b4:	00c00804 	movi	r3,32
 20009b8:	10c00005 	stb	r3,0(r2)

  /* Step through the board_funcs.LCD_TEXT array looking for chars to replace.
   * For now, just replace '+'s with space characters.
   */

  for (index = 0; index < 20; ++index)
 20009bc:	e0bfff17 	ldw	r2,-4(fp)
 20009c0:	10800044 	addi	r2,r2,1
 20009c4:	e0bfff15 	stw	r2,-4(fp)
 20009c8:	e0bfff17 	ldw	r2,-4(fp)
 20009cc:	10800510 	cmplti	r2,r2,20
 20009d0:	103fe81e 	bne	r2,zero,2000974 <http_cleanup_lcd_text+0x14>
    if (board_funcs.LCD_TEXT[index] == '+')
    {
      board_funcs.LCD_TEXT[index] = ' ';
    }
  }
} 
 20009d4:	e037883a 	mov	sp,fp
 20009d8:	df000017 	ldw	fp,0(sp)
 20009dc:	dec00104 	addi	sp,sp,4
 20009e0:	f800283a 	ret

020009e4 <lcd_output>:

void lcd_output(http_conn* conn)
{
 20009e4:	defffb04 	addi	sp,sp,-20
 20009e8:	dfc00415 	stw	ra,16(sp)
 20009ec:	df000315 	stw	fp,12(sp)
 20009f0:	df000304 	addi	fp,sp,12
 20009f4:	e13fff15 	stw	r4,-4(fp)
  char* delimiter_token;
  char* temp_pos;

  delimiter_token = strtok(conn->rx_rd_pos, "&");
 20009f8:	e0bfff17 	ldw	r2,-4(fp)
 20009fc:	10800d17 	ldw	r2,52(r2)
 2000a00:	1009883a 	mov	r4,r2
 2000a04:	01408174 	movhi	r5,517
 2000a08:	29727704 	addi	r5,r5,-13860
 2000a0c:	20086a80 	call	20086a8 <strtok>
 2000a10:	e0bffd15 	stw	r2,-12(fp)

  while( delimiter_token != NULL )
 2000a14:	00001606 	br	2000a70 <lcd_output+0x8c>
  {
    if (strstr(delimiter_token, "lcd_text"))
 2000a18:	e13ffd17 	ldw	r4,-12(fp)
 2000a1c:	01408174 	movhi	r5,517
 2000a20:	29727b04 	addi	r5,r5,-13844
 2000a24:	20083340 	call	2008334 <strstr>
 2000a28:	10000c26 	beq	r2,zero,2000a5c <lcd_output+0x78>
    {
      temp_pos = strstr(delimiter_token, "=");
 2000a2c:	e13ffd17 	ldw	r4,-12(fp)
 2000a30:	01400f44 	movi	r5,61
 2000a34:	20073e00 	call	20073e0 <strchr>
 2000a38:	e0bffe15 	stw	r2,-8(fp)
      ++temp_pos;
 2000a3c:	e0bffe17 	ldw	r2,-8(fp)
 2000a40:	10800044 	addi	r2,r2,1
 2000a44:	e0bffe15 	stw	r2,-8(fp)
      /* LCD_TEXT is limited to 20 characters...limiting string to that size. */
      strncpy( board_funcs.LCD_TEXT, temp_pos, 20 );
 2000a48:	010098b4 	movhi	r4,610
 2000a4c:	21274b84 	addi	r4,r4,-25298
 2000a50:	e17ffe17 	ldw	r5,-8(fp)
 2000a54:	01800504 	movi	r6,20
 2000a58:	2007dec0 	call	2007dec <strncpy>
    }
    delimiter_token = strtok( NULL, "&" );
 2000a5c:	0009883a 	mov	r4,zero
 2000a60:	01408174 	movhi	r5,517
 2000a64:	29727704 	addi	r5,r5,-13860
 2000a68:	20086a80 	call	20086a8 <strtok>
 2000a6c:	e0bffd15 	stw	r2,-12(fp)
  char* delimiter_token;
  char* temp_pos;

  delimiter_token = strtok(conn->rx_rd_pos, "&");

  while( delimiter_token != NULL )
 2000a70:	e0bffd17 	ldw	r2,-12(fp)
 2000a74:	103fe81e 	bne	r2,zero,2000a18 <lcd_output+0x34>
    delimiter_token = strtok( NULL, "&" );
  }

  /* Clean up the HTTP-formatted text string.  For now this just replaces '+'s with spaces. */

  http_cleanup_lcd_text();
 2000a78:	20009600 	call	2000960 <http_cleanup_lcd_text>

  /* Post the updated LCD_TEXT to the board_control_mbox. */
  OSMboxPost(board_control_mbox, (void*)&board_funcs);
 2000a7c:	00808174 	movhi	r2,517
 2000a80:	10908904 	addi	r2,r2,16932
 2000a84:	10800017 	ldw	r2,0(r2)
 2000a88:	1009883a 	mov	r4,r2
 2000a8c:	014098b4 	movhi	r5,610
 2000a90:	29674b04 	addi	r5,r5,-25300
 2000a94:	2019ec80 	call	2019ec8 <OSMboxPost>

}
 2000a98:	e037883a 	mov	sp,fp
 2000a9c:	dfc00117 	ldw	ra,4(sp)
 2000aa0:	df000017 	ldw	fp,0(sp)
 2000aa4:	dec00204 	addi	sp,sp,8
 2000aa8:	f800283a 	ret

02000aac <http_parse_multipart_header>:

int http_parse_multipart_header( http_conn* conn )
{
 2000aac:	defffb04 	addi	sp,sp,-20
 2000ab0:	dfc00415 	stw	ra,16(sp)
 2000ab4:	df000315 	stw	fp,12(sp)
 2000ab8:	df000304 	addi	fp,sp,12
 2000abc:	e13fff15 	stw	r4,-4(fp)
  /* 
   * For now, make the assumption that no multipart headers are split
   * across packets.  This is a reasonable assumption, but not a surety.
   *
   */
  while( (temp_pos = strstr( conn->rx_rd_pos, conn->boundary )) )
 2000ac0:	00007e06 	br	2000cbc <http_parse_multipart_header+0x210>
  {
    if( strstr( conn->rx_rd_pos, "upload_image" ) )
 2000ac4:	e0bfff17 	ldw	r2,-4(fp)
 2000ac8:	10800d17 	ldw	r2,52(r2)
 2000acc:	1009883a 	mov	r4,r2
 2000ad0:	01408174 	movhi	r5,517
 2000ad4:	29727e04 	addi	r5,r5,-13832
 2000ad8:	20083340 	call	2008334 <strstr>
 2000adc:	10000626 	beq	r2,zero,2000af8 <http_parse_multipart_header+0x4c>
    {
      /* Terminate the received data by going back 5
       * from temp_pos and setting it to NULL.*/
      *(temp_pos-5) = '\0';
 2000ae0:	e0bffd17 	ldw	r2,-12(fp)
 2000ae4:	10bffec4 	addi	r2,r2,-5
 2000ae8:	10000005 	stb	zero,0(r2)
      conn->file_upload = 0;
 2000aec:	e0bfff17 	ldw	r2,-4(fp)
 2000af0:	10000a15 	stw	zero,40(r2)
      break;
 2000af4:	00007b06 	br	2000ce4 <http_parse_multipart_header+0x238>
    }
    /* Find the end of the content disposition line. */
    conn->rx_rd_pos = strstr( conn->rx_rd_pos, "Content-Disposition" );
 2000af8:	e0bfff17 	ldw	r2,-4(fp)
 2000afc:	10800d17 	ldw	r2,52(r2)
 2000b00:	1009883a 	mov	r4,r2
 2000b04:	01408174 	movhi	r5,517
 2000b08:	29728204 	addi	r5,r5,-13816
 2000b0c:	20083340 	call	2008334 <strstr>
 2000b10:	e0ffff17 	ldw	r3,-4(fp)
 2000b14:	18800d15 	stw	r2,52(r3)
    if( conn->rx_rd_pos == 0 ) return(-1);
 2000b18:	e0bfff17 	ldw	r2,-4(fp)
 2000b1c:	10800d17 	ldw	r2,52(r2)
 2000b20:	1000021e 	bne	r2,zero,2000b2c <http_parse_multipart_header+0x80>
 2000b24:	00bfffc4 	movi	r2,-1
 2000b28:	00006f06 	br	2000ce8 <http_parse_multipart_header+0x23c>
    cr_pos = strchr( conn->rx_rd_pos, '\r' );
 2000b2c:	e0bfff17 	ldw	r2,-4(fp)
 2000b30:	10800d17 	ldw	r2,52(r2)
 2000b34:	1009883a 	mov	r4,r2
 2000b38:	01400344 	movi	r5,13
 2000b3c:	20073e00 	call	20073e0 <strchr>
 2000b40:	e0bffe15 	stw	r2,-8(fp)
    if( cr_pos == 0 ) return(-1);
 2000b44:	e0bffe17 	ldw	r2,-8(fp)
 2000b48:	1000021e 	bne	r2,zero,2000b54 <http_parse_multipart_header+0xa8>
 2000b4c:	00bfffc4 	movi	r2,-1
 2000b50:	00006506 	br	2000ce8 <http_parse_multipart_header+0x23c>
    /* Insert a NULL byte over the second quotation mark. */
    *(cr_pos - 1) = '\0';
 2000b54:	e0bffe17 	ldw	r2,-8(fp)
 2000b58:	10bfffc4 	addi	r2,r2,-1
 2000b5c:	10000005 	stb	zero,0(r2)
    /* Move rx_rd_pos to end of the line, just beyond the newly
     * inserted NULL.
     */
    /* Look for "=" delimiter. */
    temp_pos = strchr( conn->rx_rd_pos, '=' );
 2000b60:	e0bfff17 	ldw	r2,-4(fp)
 2000b64:	10800d17 	ldw	r2,52(r2)
 2000b68:	1009883a 	mov	r4,r2
 2000b6c:	01400f44 	movi	r5,61
 2000b70:	20073e00 	call	20073e0 <strchr>
 2000b74:	e0bffd15 	stw	r2,-12(fp)
    if( temp_pos == 0 ) return(-1);
 2000b78:	e0bffd17 	ldw	r2,-12(fp)
 2000b7c:	1000021e 	bne	r2,zero,2000b88 <http_parse_multipart_header+0xdc>
 2000b80:	00bfffc4 	movi	r2,-1
 2000b84:	00005806 	br	2000ce8 <http_parse_multipart_header+0x23c>
    /* If second "=" delimiter exists, then parse for conn->filename. */
    if( (temp_pos = strchr( (temp_pos+1), '=' )) )
 2000b88:	e0bffd17 	ldw	r2,-12(fp)
 2000b8c:	10800044 	addi	r2,r2,1
 2000b90:	1009883a 	mov	r4,r2
 2000b94:	01400f44 	movi	r5,61
 2000b98:	20073e00 	call	20073e0 <strchr>
 2000b9c:	e0bffd15 	stw	r2,-12(fp)
 2000ba0:	e0bffd17 	ldw	r2,-12(fp)
 2000ba4:	10002826 	beq	r2,zero,2000c48 <http_parse_multipart_header+0x19c>
    {
			if( strlen(temp_pos+2) > 256 )
 2000ba8:	e0bffd17 	ldw	r2,-12(fp)
 2000bac:	10800084 	addi	r2,r2,2
 2000bb0:	1009883a 	mov	r4,r2
 2000bb4:	2007c640 	call	2007c64 <strlen>
 2000bb8:	10804070 	cmpltui	r2,r2,257
 2000bbc:	1000021e 	bne	r2,zero,2000bc8 <http_parse_multipart_header+0x11c>
			{
				return(-1);
 2000bc0:	00bfffc4 	movi	r2,-1
 2000bc4:	00004806 	br	2000ce8 <http_parse_multipart_header+0x23c>
			}
      strcpy( conn->filename, (temp_pos+2) );
 2000bc8:	e0bfff17 	ldw	r2,-4(fp)
 2000bcc:	10c01304 	addi	r3,r2,76
 2000bd0:	e0bffd17 	ldw	r2,-12(fp)
 2000bd4:	10800084 	addi	r2,r2,2
 2000bd8:	1809883a 	mov	r4,r3
 2000bdc:	100b883a 	mov	r5,r2
 2000be0:	200756c0 	call	200756c <strcpy>
      /* 
       * Place rx_rd_pos at the start of the next pertinent line. 
       * In this case, skip two lines ahead.
       */
      cr_pos = strchr( (cr_pos+1), '\r');
 2000be4:	e0bffe17 	ldw	r2,-8(fp)
 2000be8:	10800044 	addi	r2,r2,1
 2000bec:	1009883a 	mov	r4,r2
 2000bf0:	01400344 	movi	r5,13
 2000bf4:	20073e00 	call	20073e0 <strchr>
 2000bf8:	e0bffe15 	stw	r2,-8(fp)
      if( cr_pos == 0 ) return(-1);
 2000bfc:	e0bffe17 	ldw	r2,-8(fp)
 2000c00:	1000021e 	bne	r2,zero,2000c0c <http_parse_multipart_header+0x160>
 2000c04:	00bfffc4 	movi	r2,-1
 2000c08:	00003706 	br	2000ce8 <http_parse_multipart_header+0x23c>
      cr_pos = strchr( (cr_pos+1), '\r');
 2000c0c:	e0bffe17 	ldw	r2,-8(fp)
 2000c10:	10800044 	addi	r2,r2,1
 2000c14:	1009883a 	mov	r4,r2
 2000c18:	01400344 	movi	r5,13
 2000c1c:	20073e00 	call	20073e0 <strchr>
 2000c20:	e0bffe15 	stw	r2,-8(fp)
      if( cr_pos == 0 ) return(-1);
 2000c24:	e0bffe17 	ldw	r2,-8(fp)
 2000c28:	1000021e 	bne	r2,zero,2000c34 <http_parse_multipart_header+0x188>
 2000c2c:	00bfffc4 	movi	r2,-1
 2000c30:	00002d06 	br	2000ce8 <http_parse_multipart_header+0x23c>
      conn->rx_rd_pos = cr_pos+2;
 2000c34:	e0bffe17 	ldw	r2,-8(fp)
 2000c38:	10c00084 	addi	r3,r2,2
 2000c3c:	e0bfff17 	ldw	r2,-4(fp)
 2000c40:	10c00d15 	stw	r3,52(r2)
 2000c44:	00001d06 	br	2000cbc <http_parse_multipart_header+0x210>
      /* 
       * If no second delimiter, then skip ahead to start of 2nd. line.
       * That will be the start of the flash device name.
       *
       */
      temp_pos = strchr( (cr_pos+1), '\r' );
 2000c48:	e0bffe17 	ldw	r2,-8(fp)
 2000c4c:	10800044 	addi	r2,r2,1
 2000c50:	1009883a 	mov	r4,r2
 2000c54:	01400344 	movi	r5,13
 2000c58:	20073e00 	call	20073e0 <strchr>
 2000c5c:	e0bffd15 	stw	r2,-12(fp)
      conn->rx_rd_pos = temp_pos+2;
 2000c60:	e0bffd17 	ldw	r2,-12(fp)
 2000c64:	10c00084 	addi	r3,r2,2
 2000c68:	e0bfff17 	ldw	r2,-4(fp)
 2000c6c:	10c00d15 	stw	r3,52(r2)
      cr_pos = strchr( conn->rx_rd_pos, '\r' );
 2000c70:	e0bfff17 	ldw	r2,-4(fp)
 2000c74:	10800d17 	ldw	r2,52(r2)
 2000c78:	1009883a 	mov	r4,r2
 2000c7c:	01400344 	movi	r5,13
 2000c80:	20073e00 	call	20073e0 <strchr>
 2000c84:	e0bffe15 	stw	r2,-8(fp)
      *cr_pos = '\0';
 2000c88:	e0bffe17 	ldw	r2,-8(fp)
 2000c8c:	10000005 	stb	zero,0(r2)
      /* Ok, now copy the flash_device string. */
      strcpy( conn->flash_device, conn->rx_rd_pos );
 2000c90:	e0bfff17 	ldw	r2,-4(fp)
 2000c94:	10c05304 	addi	r3,r2,332
 2000c98:	e0bfff17 	ldw	r2,-4(fp)
 2000c9c:	10800d17 	ldw	r2,52(r2)
 2000ca0:	1809883a 	mov	r4,r3
 2000ca4:	100b883a 	mov	r5,r2
 2000ca8:	200756c0 	call	200756c <strcpy>
      /* Place rx_rd_pos at the start of the next line. */
      conn->rx_rd_pos = cr_pos+2;
 2000cac:	e0bffe17 	ldw	r2,-8(fp)
 2000cb0:	10c00084 	addi	r3,r2,2
 2000cb4:	e0bfff17 	ldw	r2,-4(fp)
 2000cb8:	10c00d15 	stw	r3,52(r2)
  /* 
   * For now, make the assumption that no multipart headers are split
   * across packets.  This is a reasonable assumption, but not a surety.
   *
   */
  while( (temp_pos = strstr( conn->rx_rd_pos, conn->boundary )) )
 2000cbc:	e0bfff17 	ldw	r2,-4(fp)
 2000cc0:	10c00d17 	ldw	r3,52(r2)
 2000cc4:	e0bfff17 	ldw	r2,-4(fp)
 2000cc8:	10806204 	addi	r2,r2,392
 2000ccc:	1809883a 	mov	r4,r3
 2000cd0:	100b883a 	mov	r5,r2
 2000cd4:	20083340 	call	2008334 <strstr>
 2000cd8:	e0bffd15 	stw	r2,-12(fp)
 2000cdc:	e0bffd17 	ldw	r2,-12(fp)
 2000ce0:	103f781e 	bne	r2,zero,2000ac4 <http_parse_multipart_header+0x18>
      strcpy( conn->flash_device, conn->rx_rd_pos );
      /* Place rx_rd_pos at the start of the next line. */
      conn->rx_rd_pos = cr_pos+2;
    }
  }
  return(0);
 2000ce4:	0005883a 	mov	r2,zero
}
 2000ce8:	e037883a 	mov	sp,fp
 2000cec:	dfc00117 	ldw	ra,4(sp)
 2000cf0:	df000017 	ldw	fp,0(sp)
 2000cf4:	dec00204 	addi	sp,sp,8
 2000cf8:	f800283a 	ret

02000cfc <file_upload>:

void file_upload(http_conn* conn)
{
 2000cfc:	defff904 	addi	sp,sp,-28
 2000d00:	dfc00615 	stw	ra,24(sp)
 2000d04:	df000515 	stw	fp,20(sp)
 2000d08:	df000504 	addi	fp,sp,20
 2000d0c:	e13fff15 	stw	r4,-4(fp)
  int buf_len;
  int data_used;
  struct upload_buf_struct *upload_buffer = &upload_buf;
 2000d10:	008081b4 	movhi	r2,518
 2000d14:	1083e904 	addi	r2,r2,4004
 2000d18:	e0bffb15 	stw	r2,-20(fp)
  struct flash_inf_struct *flash_info = &flash_inf;
 2000d1c:	008098b4 	movhi	r2,610
 2000d20:	10975604 	addi	r2,r2,23896
 2000d24:	e0bffc15 	stw	r2,-16(fp)
  /* Look for boundary, parse multipart form "mini" header information if found. */
  if( strstr( conn->rx_rd_pos, conn->boundary ) )
 2000d28:	e0bfff17 	ldw	r2,-4(fp)
 2000d2c:	10c00d17 	ldw	r3,52(r2)
 2000d30:	e0bfff17 	ldw	r2,-4(fp)
 2000d34:	10806204 	addi	r2,r2,392
 2000d38:	1809883a 	mov	r4,r3
 2000d3c:	100b883a 	mov	r5,r2
 2000d40:	20083340 	call	2008334 <strstr>
 2000d44:	10000926 	beq	r2,zero,2000d6c <file_upload+0x70>
  {
    if( http_parse_multipart_header( conn ) )
 2000d48:	e13fff17 	ldw	r4,-4(fp)
 2000d4c:	2000aac0 	call	2000aac <http_parse_multipart_header>
 2000d50:	10000626 	beq	r2,zero,2000d6c <file_upload+0x70>
    {
      printf( "multipart-form:  header parse failure...resetting connection!" );
 2000d54:	01008174 	movhi	r4,517
 2000d58:	21328704 	addi	r4,r4,-13796
 2000d5c:	2006a240 	call	2006a24 <printf>
      conn->state = RESET;
 2000d60:	e0bfff17 	ldw	r2,-4(fp)
 2000d64:	00c00104 	movi	r3,4
 2000d68:	10c00015 	stw	r3,0(r2)
    }
  }
  /* Exception for IE.  It sometimes sends _really_ small initial packets! */
  if( strchr( conn->rx_rd_pos, ':' ) )
 2000d6c:	e0bfff17 	ldw	r2,-4(fp)
 2000d70:	10800d17 	ldw	r2,52(r2)
 2000d74:	1009883a 	mov	r4,r2
 2000d78:	01400e84 	movi	r5,58
 2000d7c:	20073e00 	call	20073e0 <strchr>
 2000d80:	10000326 	beq	r2,zero,2000d90 <file_upload+0x94>
  {
    conn->state = READY;
 2000d84:	e0bfff17 	ldw	r2,-4(fp)
 2000d88:	10000015 	stw	zero,0(r2)
    return;
 2000d8c:	00007506 	br	2000f64 <file_upload+0x268>
  }
  /* Calculate the string size... */
  buf_len = strlen(conn->rx_rd_pos);
 2000d90:	e0bfff17 	ldw	r2,-4(fp)
 2000d94:	10800d17 	ldw	r2,52(r2)
 2000d98:	1009883a 	mov	r4,r2
 2000d9c:	2007c640 	call	2007c64 <strlen>
 2000da0:	e0bffd15 	stw	r2,-12(fp)
  conn->content_received = conn->content_received + buf_len;
 2000da4:	e0bfff17 	ldw	r2,-4(fp)
 2000da8:	10c00617 	ldw	r3,24(r2)
 2000dac:	e0bffd17 	ldw	r2,-12(fp)
 2000db0:	1887883a 	add	r3,r3,r2
 2000db4:	e0bfff17 	ldw	r2,-4(fp)
 2000db8:	10c00615 	stw	r3,24(r2)
  /* Copy all the received data into the upload buffer. */
  if ( memcpy( (void*) upload_buffer->wr_pos, 
 2000dbc:	e0bffb17 	ldw	r2,-20(fp)
 2000dc0:	11000017 	ldw	r4,0(r2)
               (void*) conn->rx_rd_pos, 
 2000dc4:	e0bfff17 	ldw	r2,-4(fp)
 2000dc8:	10c00d17 	ldw	r3,52(r2)
  }
  /* Calculate the string size... */
  buf_len = strlen(conn->rx_rd_pos);
  conn->content_received = conn->content_received + buf_len;
  /* Copy all the received data into the upload buffer. */
  if ( memcpy( (void*) upload_buffer->wr_pos, 
 2000dcc:	e0bffd17 	ldw	r2,-12(fp)
 2000dd0:	180b883a 	mov	r5,r3
 2000dd4:	100d883a 	mov	r6,r2
 2000dd8:	200660c0 	call	200660c <memcpy>
 2000ddc:	1000031e 	bne	r2,zero,2000dec <file_upload+0xf0>
               (void*) conn->rx_rd_pos, 
               buf_len ) == NULL )
  {
    printf( "ERROR:  memcpy to file upload buffer failed!" );
 2000de0:	01008174 	movhi	r4,517
 2000de4:	21329704 	addi	r4,r4,-13732
 2000de8:	2006a240 	call	2006a24 <printf>
  }
  /* Increment the wr_pos pointer to just after the received data. */
  upload_buffer->wr_pos = upload_buffer->wr_pos + buf_len;
 2000dec:	e0bffb17 	ldw	r2,-20(fp)
 2000df0:	10c00017 	ldw	r3,0(r2)
 2000df4:	e0bffd17 	ldw	r2,-12(fp)
 2000df8:	1887883a 	add	r3,r3,r2
 2000dfc:	e0bffb17 	ldw	r2,-20(fp)
 2000e00:	10c00015 	stw	r3,0(r2)
  conn->rx_rd_pos = conn->rx_rd_pos + buf_len;
 2000e04:	e0bfff17 	ldw	r2,-4(fp)
 2000e08:	10c00d17 	ldw	r3,52(r2)
 2000e0c:	e0bffd17 	ldw	r2,-12(fp)
 2000e10:	1887883a 	add	r3,r3,r2
 2000e14:	e0bfff17 	ldw	r2,-4(fp)
 2000e18:	10c00d15 	stw	r3,52(r2)
  /* Reset the buffers after copying the data into the big intermediate 
   * buffer.*/
  data_used = conn->rx_rd_pos - conn->rx_buffer;
 2000e1c:	e0bfff17 	ldw	r2,-4(fp)
 2000e20:	10800d17 	ldw	r2,52(r2)
 2000e24:	1007883a 	mov	r3,r2
 2000e28:	e0bfff17 	ldw	r2,-4(fp)
 2000e2c:	10801117 	ldw	r2,68(r2)
 2000e30:	1885c83a 	sub	r2,r3,r2
 2000e34:	e0bffe15 	stw	r2,-8(fp)
  memmove(conn->rx_buffer,conn->rx_rd_pos,conn->rx_wr_pos-conn->rx_rd_pos);
 2000e38:	e0bfff17 	ldw	r2,-4(fp)
 2000e3c:	11001117 	ldw	r4,68(r2)
 2000e40:	e0bfff17 	ldw	r2,-4(fp)
 2000e44:	10c00d17 	ldw	r3,52(r2)
 2000e48:	e0bfff17 	ldw	r2,-4(fp)
 2000e4c:	10800e17 	ldw	r2,56(r2)
 2000e50:	100b883a 	mov	r5,r2
 2000e54:	e0bfff17 	ldw	r2,-4(fp)
 2000e58:	10800d17 	ldw	r2,52(r2)
 2000e5c:	2885c83a 	sub	r2,r5,r2
 2000e60:	180b883a 	mov	r5,r3
 2000e64:	100d883a 	mov	r6,r2
 2000e68:	20067040 	call	2006704 <memmove>
  conn->rx_rd_pos = conn->rx_buffer;
 2000e6c:	e0bfff17 	ldw	r2,-4(fp)
 2000e70:	10c01117 	ldw	r3,68(r2)
 2000e74:	e0bfff17 	ldw	r2,-4(fp)
 2000e78:	10c00d15 	stw	r3,52(r2)
  conn->rx_wr_pos -= data_used;
 2000e7c:	e0bfff17 	ldw	r2,-4(fp)
 2000e80:	10c00e17 	ldw	r3,56(r2)
 2000e84:	e0bffe17 	ldw	r2,-8(fp)
 2000e88:	0085c83a 	sub	r2,zero,r2
 2000e8c:	1887883a 	add	r3,r3,r2
 2000e90:	e0bfff17 	ldw	r2,-4(fp)
 2000e94:	10c00e15 	stw	r3,56(r2)
  memset(conn->rx_wr_pos, 0, data_used);
 2000e98:	e0bfff17 	ldw	r2,-4(fp)
 2000e9c:	10c00e17 	ldw	r3,56(r2)
 2000ea0:	e0bffe17 	ldw	r2,-8(fp)
 2000ea4:	1809883a 	mov	r4,r3
 2000ea8:	000b883a 	mov	r5,zero
 2000eac:	100d883a 	mov	r6,r2
 2000eb0:	200682c0 	call	200682c <memset>
  if ( conn->file_upload == 0 )
 2000eb4:	e0bfff17 	ldw	r2,-4(fp)
 2000eb8:	10800a17 	ldw	r2,40(r2)
 2000ebc:	1000271e 	bne	r2,zero,2000f5c <file_upload+0x260>
  {
    printf( "Received a total of %d bytes.\n", conn->content_received );
 2000ec0:	e0bfff17 	ldw	r2,-4(fp)
 2000ec4:	10800617 	ldw	r2,24(r2)
 2000ec8:	01008174 	movhi	r4,517
 2000ecc:	2132a304 	addi	r4,r4,-13684
 2000ed0:	100b883a 	mov	r5,r2
 2000ed4:	2006a240 	call	2006a24 <printf>
    /* Insert a NULL character (temporarily). */
    *upload_buffer->wr_pos = '\0';
 2000ed8:	e0bffb17 	ldw	r2,-20(fp)
 2000edc:	10800017 	ldw	r2,0(r2)
 2000ee0:	10000005 	stb	zero,0(r2)
    /* Populate flash_info struct... print the buffer size. */
    flash_info->size = (int) strlen(upload_buffer->buffer);
 2000ee4:	e0bffb17 	ldw	r2,-20(fp)
 2000ee8:	10800204 	addi	r2,r2,8
 2000eec:	1009883a 	mov	r4,r2
 2000ef0:	2007c640 	call	2007c64 <strlen>
 2000ef4:	1007883a 	mov	r3,r2
 2000ef8:	e0bffc17 	ldw	r2,-16(fp)
 2000efc:	10c00115 	stw	r3,4(r2)
    printf( "Upload Buffer size = %d.\n", flash_info->size);
 2000f00:	e0bffc17 	ldw	r2,-16(fp)
 2000f04:	10800117 	ldw	r2,4(r2)
 2000f08:	01008174 	movhi	r4,517
 2000f0c:	2132ab04 	addi	r4,r4,-13652
 2000f10:	100b883a 	mov	r5,r2
 2000f14:	2006a240 	call	2006a24 <printf>
    strcpy( flash_info->device, conn->flash_device );
 2000f18:	e0bffc17 	ldw	r2,-16(fp)
 2000f1c:	10c00204 	addi	r3,r2,8
 2000f20:	e0bfff17 	ldw	r2,-4(fp)
 2000f24:	10805304 	addi	r2,r2,332
 2000f28:	1809883a 	mov	r4,r3
 2000f2c:	100b883a 	mov	r5,r2
 2000f30:	200756c0 	call	200756c <strcpy>
    flash_info->start = upload_buffer->rd_pos;
 2000f34:	e0bffb17 	ldw	r2,-20(fp)
 2000f38:	10c00117 	ldw	r3,4(r2)
 2000f3c:	e0bffc17 	ldw	r2,-16(fp)
 2000f40:	10c00015 	stw	r3,0(r2)
    /* Populate the flash_inf struct. */
    //printf( "Here's the Buffer:\n\n%s", upload_buffer->buffer);
    http_find_file(conn);
 2000f44:	e13fff17 	ldw	r4,-4(fp)
 2000f48:	20022d40 	call	20022d4 <http_find_file>
    conn->close = 1;
 2000f4c:	e0bfff17 	ldw	r2,-4(fp)
 2000f50:	00c00044 	movi	r3,1
 2000f54:	10c00415 	stw	r3,16(r2)
 2000f58:	00000206 	br	2000f64 <file_upload+0x268>
  }
  else
  {
    conn->state = READY;
 2000f5c:	e0bfff17 	ldw	r2,-4(fp)
 2000f60:	10000015 	stw	zero,0(r2)
  }
}
 2000f64:	e037883a 	mov	sp,fp
 2000f68:	dfc00117 	ldw	ra,4(sp)
 2000f6c:	df000017 	ldw	fp,0(sp)
 2000f70:	dec00204 	addi	sp,sp,8
 2000f74:	f800283a 	ret

02000f78 <ProgFlashStub>:
 *
 * A thin wrapper around the ProgSRECBuf() function in srec_flash.c.
 *
 */
void ProgFlashStub(http_conn* conn)
{
 2000f78:	defffc04 	addi	sp,sp,-16
 2000f7c:	dfc00315 	stw	ra,12(sp)
 2000f80:	df000215 	stw	fp,8(sp)
 2000f84:	df000204 	addi	fp,sp,8
 2000f88:	e13fff15 	stw	r4,-4(fp)
	struct flash_inf_struct *flash_info = &flash_inf;
 2000f8c:	008098b4 	movhi	r2,610
 2000f90:	10975604 	addi	r2,r2,23896
 2000f94:	e0bffe15 	stw	r2,-8(fp)
	/* Call ParseSRECBuf, with the flash_info argument. */
	ParseSRECBuf( flash_info );
 2000f98:	e13ffe17 	ldw	r4,-8(fp)
 2000f9c:	2003f000 	call	2003f00 <ParseSRECBuf>
	/* Go find and send the reset_system.html file. */
	http_find_file( conn );
 2000fa0:	e13fff17 	ldw	r4,-4(fp)
 2000fa4:	20022d40 	call	20022d4 <http_find_file>
	/* Close the connection. */
	conn->close = 1;
 2000fa8:	e0bfff17 	ldw	r2,-4(fp)
 2000fac:	00c00044 	movi	r3,1
 2000fb0:	10c00415 	stw	r3,16(r2)
  return;
 2000fb4:	0001883a 	nop
}
 2000fb8:	e037883a 	mov	sp,fp
 2000fbc:	dfc00117 	ldw	ra,4(sp)
 2000fc0:	df000017 	ldw	fp,0(sp)
 2000fc4:	dec00204 	addi	sp,sp,8
 2000fc8:	f800283a 	ret

02000fcc <http_reset_connection>:
 * 
 * This routine will clear our HTTP connection structure & prepare it to handle
 * a new HTTP connection.
 */
void http_reset_connection(http_conn* conn, int http_instance)
{
 2000fcc:	defffc04 	addi	sp,sp,-16
 2000fd0:	dfc00315 	stw	ra,12(sp)
 2000fd4:	df000215 	stw	fp,8(sp)
 2000fd8:	df000204 	addi	fp,sp,8
 2000fdc:	e13ffe15 	stw	r4,-8(fp)
 2000fe0:	e17fff15 	stw	r5,-4(fp)
  memset(conn, 0, sizeof(http_conn));
 2000fe4:	e13ffe17 	ldw	r4,-8(fp)
 2000fe8:	000b883a 	mov	r5,zero
 2000fec:	01887604 	movi	r6,8664
 2000ff0:	200682c0 	call	200682c <memset>

  conn->fd = -1;
 2000ff4:	e0bffe17 	ldw	r2,-8(fp)
 2000ff8:	00ffffc4 	movi	r3,-1
 2000ffc:	10c00315 	stw	r3,12(r2)
  conn->state = READY;
 2001000:	e0bffe17 	ldw	r2,-8(fp)
 2001004:	10000015 	stw	zero,0(r2)
  conn->keep_alive_count = HTTP_KEEP_ALIVE_COUNT;
 2001008:	e0bffe17 	ldw	r2,-8(fp)
 200100c:	00c00504 	movi	r3,20
 2001010:	10c00715 	stw	r3,28(r2)
  
  conn->rx_buffer = &http_rx_buffer[http_instance][0];
 2001014:	e0bfff17 	ldw	r2,-4(fp)
 2001018:	1006937a 	slli	r3,r2,13
 200101c:	008098b4 	movhi	r2,610
 2001020:	10a75584 	addi	r2,r2,-25258
 2001024:	1887883a 	add	r3,r3,r2
 2001028:	e0bffe17 	ldw	r2,-8(fp)
 200102c:	10c01115 	stw	r3,68(r2)
  conn->tx_buffer = &http_tx_buffer[http_instance][0];
 2001030:	e0bfff17 	ldw	r2,-4(fp)
 2001034:	1006937a 	slli	r3,r2,13
 2001038:	008098b4 	movhi	r2,610
 200103c:	10976204 	addi	r2,r2,23944
 2001040:	1887883a 	add	r3,r3,r2
 2001044:	e0bffe17 	ldw	r2,-8(fp)
 2001048:	10c01215 	stw	r3,72(r2)
  conn->rx_wr_pos = &http_rx_buffer[http_instance][0];
 200104c:	e0bfff17 	ldw	r2,-4(fp)
 2001050:	1006937a 	slli	r3,r2,13
 2001054:	008098b4 	movhi	r2,610
 2001058:	10a75584 	addi	r2,r2,-25258
 200105c:	1887883a 	add	r3,r3,r2
 2001060:	e0bffe17 	ldw	r2,-8(fp)
 2001064:	10c00e15 	stw	r3,56(r2)
  conn->rx_rd_pos = &http_rx_buffer[http_instance][0];
 2001068:	e0bfff17 	ldw	r2,-4(fp)
 200106c:	1006937a 	slli	r3,r2,13
 2001070:	008098b4 	movhi	r2,610
 2001074:	10a75584 	addi	r2,r2,-25258
 2001078:	1887883a 	add	r3,r3,r2
 200107c:	e0bffe17 	ldw	r2,-8(fp)
 2001080:	10c00d15 	stw	r3,52(r2)
}
 2001084:	e037883a 	mov	sp,fp
 2001088:	dfc00117 	ldw	ra,4(sp)
 200108c:	df000017 	ldw	fp,0(sp)
 2001090:	dec00204 	addi	sp,sp,8
 2001094:	f800283a 	ret

02001098 <http_manage_connection>:
 * structure. It is called from various points in the HTTP server code to
 * ensure that connections are reset properly on error, completion, and
 * to ensure that "zombie" connections are dealt with.
 */
void http_manage_connection(http_conn* conn, int http_instance)
{
 2001098:	defffb04 	addi	sp,sp,-20
 200109c:	dfc00415 	stw	ra,16(sp)
 20010a0:	df000315 	stw	fp,12(sp)
 20010a4:	df000304 	addi	fp,sp,12
 20010a8:	e13ffe15 	stw	r4,-8(fp)
 20010ac:	e17fff15 	stw	r5,-4(fp)
  alt_u32 current_time = 0;
 20010b0:	e03ffd15 	stw	zero,-12(fp)
  /*
   * Keep track of whether an open connection has timed out. This will be
   * determined by comparing the current time with that of the most recent
   * activity.
   */
  if(conn->state == READY || conn->state == PROCESS || conn->state == DATA)
 20010b4:	e0bffe17 	ldw	r2,-8(fp)
 20010b8:	10800017 	ldw	r2,0(r2)
 20010bc:	10000826 	beq	r2,zero,20010e0 <http_manage_connection+0x48>
 20010c0:	e0bffe17 	ldw	r2,-8(fp)
 20010c4:	10800017 	ldw	r2,0(r2)
 20010c8:	10800060 	cmpeqi	r2,r2,1
 20010cc:	1000041e 	bne	r2,zero,20010e0 <http_manage_connection+0x48>
 20010d0:	e0bffe17 	ldw	r2,-8(fp)
 20010d4:	10800017 	ldw	r2,0(r2)
 20010d8:	10800098 	cmpnei	r2,r2,2
 20010dc:	1000111e 	bne	r2,zero,2001124 <http_manage_connection+0x8c>
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 20010e0:	00808174 	movhi	r2,517
 20010e4:	10909604 	addi	r2,r2,16984
 20010e8:	10800017 	ldw	r2,0(r2)
  {
    current_time = alt_nticks();
 20010ec:	e0bffd15 	stw	r2,-12(fp)
    
    if( ((current_time - conn->activity_time) >= HTTP_KEEP_ALIVE_TIME) && conn->file_upload != 1 )
 20010f0:	e0bffe17 	ldw	r2,-8(fp)
 20010f4:	10800c17 	ldw	r2,48(r2)
 20010f8:	e0fffd17 	ldw	r3,-12(fp)
 20010fc:	1885c83a 	sub	r2,r3,r2
 2001100:	1084e230 	cmpltui	r2,r2,5000
 2001104:	1000071e 	bne	r2,zero,2001124 <http_manage_connection+0x8c>
 2001108:	e0bffe17 	ldw	r2,-8(fp)
 200110c:	10800a17 	ldw	r2,40(r2)
 2001110:	10800060 	cmpeqi	r2,r2,1
 2001114:	1000031e 	bne	r2,zero,2001124 <http_manage_connection+0x8c>
    {
      conn->state = RESET;
 2001118:	e0bffe17 	ldw	r2,-8(fp)
 200111c:	00c00104 	movi	r3,4
 2001120:	10c00015 	stw	r3,0(r2)
   * state machine as ready for additional connections... or not.
   *  - Only send so many files per connection. 
   *  - Stop when we reach a timeout.
   *  - If someone (like the client) asked to close the connection, do so.
   */
  if(conn->state == COMPLETE)
 2001124:	e0bffe17 	ldw	r2,-8(fp)
 2001128:	10800017 	ldw	r2,0(r2)
 200112c:	108000d8 	cmpnei	r2,r2,3
 2001130:	10001c1e 	bne	r2,zero,20011a4 <http_manage_connection+0x10c>
  {
    if(conn->file_handle != NULL)
 2001134:	e0bffe17 	ldw	r2,-8(fp)
 2001138:	10800b17 	ldw	r2,44(r2)
 200113c:	10000426 	beq	r2,zero,2001150 <http_manage_connection+0xb8>
    {
      fclose(conn->file_handle);
 2001140:	e0bffe17 	ldw	r2,-8(fp)
 2001144:	10800b17 	ldw	r2,44(r2)
 2001148:	1009883a 	mov	r4,r2
 200114c:	20046280 	call	2004628 <fclose>
    }
      
    conn->keep_alive_count--;
 2001150:	e0bffe17 	ldw	r2,-8(fp)
 2001154:	10800717 	ldw	r2,28(r2)
 2001158:	10ffffc4 	addi	r3,r2,-1
 200115c:	e0bffe17 	ldw	r2,-8(fp)
 2001160:	10c00715 	stw	r3,28(r2)
    conn->data_sent = 0;
 2001164:	e0bffe17 	ldw	r2,-8(fp)
 2001168:	10000915 	stw	zero,36(r2)
  
    if(conn->keep_alive_count == 0)
 200116c:	e0bffe17 	ldw	r2,-8(fp)
 2001170:	10800717 	ldw	r2,28(r2)
 2001174:	1000031e 	bne	r2,zero,2001184 <http_manage_connection+0xec>
    {
      conn->close = 1;
 2001178:	e0bffe17 	ldw	r2,-8(fp)
 200117c:	00c00044 	movi	r3,1
 2001180:	10c00415 	stw	r3,16(r2)
    }
    
    conn->state = conn->close ? CLOSE : READY;
 2001184:	e0bffe17 	ldw	r2,-8(fp)
 2001188:	10800417 	ldw	r2,16(r2)
 200118c:	10000226 	beq	r2,zero,2001198 <http_manage_connection+0x100>
 2001190:	00800144 	movi	r2,5
 2001194:	00000106 	br	200119c <http_manage_connection+0x104>
 2001198:	0005883a 	mov	r2,zero
 200119c:	e0fffe17 	ldw	r3,-8(fp)
 20011a0:	18800015 	stw	r2,0(r3)
   * Some error occured. http_reset_connection() will take care of most
   * things, but the RX buffer still needs to be cleared, and any open
   * files need to be closed. We do this in a separate state to maintain 
   * efficiency between successive (error-free) connections.
   */
  if(conn->state == RESET)
 20011a4:	e0bffe17 	ldw	r2,-8(fp)
 20011a8:	10800017 	ldw	r2,0(r2)
 20011ac:	10800118 	cmpnei	r2,r2,4
 20011b0:	1000101e 	bne	r2,zero,20011f4 <http_manage_connection+0x15c>
  {
    if(conn->file_handle != NULL)
 20011b4:	e0bffe17 	ldw	r2,-8(fp)
 20011b8:	10800b17 	ldw	r2,44(r2)
 20011bc:	10000426 	beq	r2,zero,20011d0 <http_manage_connection+0x138>
    {
      fclose(conn->file_handle);
 20011c0:	e0bffe17 	ldw	r2,-8(fp)
 20011c4:	10800b17 	ldw	r2,44(r2)
 20011c8:	1009883a 	mov	r4,r2
 20011cc:	20046280 	call	2004628 <fclose>
    }
      
    memset(conn->rx_buffer, 0, HTTP_RX_BUF_SIZE);
 20011d0:	e0bffe17 	ldw	r2,-8(fp)
 20011d4:	10801117 	ldw	r2,68(r2)
 20011d8:	1009883a 	mov	r4,r2
 20011dc:	000b883a 	mov	r5,zero
 20011e0:	01880004 	movi	r6,8192
 20011e4:	200682c0 	call	200682c <memset>
    conn->state = CLOSE;
 20011e8:	e0bffe17 	ldw	r2,-8(fp)
 20011ec:	00c00144 	movi	r3,5
 20011f0:	10c00015 	stw	r3,0(r2)
  }
  
  /* Close the TCP connection */
  if(conn->state == CLOSE)
 20011f4:	e0bffe17 	ldw	r2,-8(fp)
 20011f8:	10800017 	ldw	r2,0(r2)
 20011fc:	10800158 	cmpnei	r2,r2,5
 2001200:	1000071e 	bne	r2,zero,2001220 <http_manage_connection+0x188>
  {
    close(conn->fd);
 2001204:	e0bffe17 	ldw	r2,-8(fp)
 2001208:	10800317 	ldw	r2,12(r2)
 200120c:	1009883a 	mov	r4,r2
 2001210:	20237680 	call	2023768 <close>
    http_reset_connection(conn, http_instance);
 2001214:	e13ffe17 	ldw	r4,-8(fp)
 2001218:	e17fff17 	ldw	r5,-4(fp)
 200121c:	2000fcc0 	call	2000fcc <http_reset_connection>
  }
}
 2001220:	e037883a 	mov	sp,fp
 2001224:	dfc00117 	ldw	ra,4(sp)
 2001228:	df000017 	ldw	fp,0(sp)
 200122c:	dec00204 	addi	sp,sp,8
 2001230:	f800283a 	ret

02001234 <http_handle_accept>:
 * any open connection slots we will accept the connection (this creates a 
 * new socket for the data transfer), but if all available connections are in 
 * use we'll ignore the client's incoming connection request.
 */
int http_handle_accept(int listen_socket, http_conn* conn)
{
 2001234:	defff404 	addi	sp,sp,-48
 2001238:	dfc00b15 	stw	ra,44(sp)
 200123c:	df000a15 	stw	fp,40(sp)
 2001240:	df000a04 	addi	fp,sp,40
 2001244:	e13ffe15 	stw	r4,-8(fp)
 2001248:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0, i, socket, len;
 200124c:	e03ff715 	stw	zero,-36(fp)
  struct sockaddr_in  rem;

  len = sizeof(rem);
 2001250:	00800404 	movi	r2,16
 2001254:	e0bff915 	stw	r2,-28(fp)

  /* 
   * Loop through available connection slots to determine the first available
   * connection.
   */
  for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2001258:	e03ff615 	stw	zero,-40(fp)
 200125c:	00000a06 	br	2001288 <http_handle_accept+0x54>
  {
    if((conn+i)->fd == -1)
 2001260:	e0bff617 	ldw	r2,-40(fp)
 2001264:	10887624 	muli	r2,r2,8664
 2001268:	e0ffff17 	ldw	r3,-4(fp)
 200126c:	1885883a 	add	r2,r3,r2
 2001270:	10800317 	ldw	r2,12(r2)
 2001274:	10bfffd8 	cmpnei	r2,r2,-1
 2001278:	10000726 	beq	r2,zero,2001298 <http_handle_accept+0x64>

  /* 
   * Loop through available connection slots to determine the first available
   * connection.
   */
  for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 200127c:	e0bff617 	ldw	r2,-40(fp)
 2001280:	10800044 	addi	r2,r2,1
 2001284:	e0bff615 	stw	r2,-40(fp)
 2001288:	e0bff617 	ldw	r2,-40(fp)
 200128c:	10800190 	cmplti	r2,r2,6
 2001290:	103ff31e 	bne	r2,zero,2001260 <http_handle_accept+0x2c>
 2001294:	00000106 	br	200129c <http_handle_accept+0x68>
  {
    if((conn+i)->fd == -1)
    {
      break;
 2001298:	0001883a 	nop
  
  /* 
   * There are no more connection slots available. Ignore the connection
   * request for now.
   */
  if(i == HTTP_NUM_CONNECTIONS)
 200129c:	e0bff617 	ldw	r2,-40(fp)
 20012a0:	10800198 	cmpnei	r2,r2,6
 20012a4:	1000021e 	bne	r2,zero,20012b0 <http_handle_accept+0x7c>
    return -1;
 20012a8:	00bfffc4 	movi	r2,-1
 20012ac:	00002306 	br	200133c <http_handle_accept+0x108>
      
  if((socket = accept(listen_socket,(struct sockaddr*)&rem,&len)) < 0)
 20012b0:	e0fffa04 	addi	r3,fp,-24
 20012b4:	e0bff904 	addi	r2,fp,-28
 20012b8:	e13ffe17 	ldw	r4,-8(fp)
 20012bc:	180b883a 	mov	r5,r3
 20012c0:	100d883a 	mov	r6,r2
 20012c4:	2025cd80 	call	2025cd8 <bsd_accept>
 20012c8:	e0bff815 	stw	r2,-32(fp)
 20012cc:	e0bff817 	ldw	r2,-32(fp)
 20012d0:	10000b0e 	bge	r2,zero,2001300 <http_handle_accept+0xcc>
  {
    fprintf(stderr, "[http_handle_accept] accept failed (%d)\n", socket);
 20012d4:	00808174 	movhi	r2,517
 20012d8:	10903604 	addi	r2,r2,16600
 20012dc:	10800017 	ldw	r2,0(r2)
 20012e0:	10800317 	ldw	r2,12(r2)
 20012e4:	1009883a 	mov	r4,r2
 20012e8:	01408174 	movhi	r5,517
 20012ec:	2972c204 	addi	r5,r5,-13560
 20012f0:	e1bff817 	ldw	r6,-32(fp)
 20012f4:	2004ce80 	call	2004ce8 <fprintf>
    return socket;
 20012f8:	e0bff817 	ldw	r2,-32(fp)
 20012fc:	00000f06 	br	200133c <http_handle_accept+0x108>
  }

  (conn+i)->fd = socket;
 2001300:	e0bff617 	ldw	r2,-40(fp)
 2001304:	10887624 	muli	r2,r2,8664
 2001308:	e0ffff17 	ldw	r3,-4(fp)
 200130c:	1885883a 	add	r2,r3,r2
 2001310:	e0fff817 	ldw	r3,-32(fp)
 2001314:	10c00315 	stw	r3,12(r2)
  (conn+i)->activity_time = alt_nticks();
 2001318:	e0bff617 	ldw	r2,-40(fp)
 200131c:	10887624 	muli	r2,r2,8664
 2001320:	e0ffff17 	ldw	r3,-4(fp)
 2001324:	1885883a 	add	r2,r3,r2
 2001328:	00c08174 	movhi	r3,517
 200132c:	18d09604 	addi	r3,r3,16984
 2001330:	18c00017 	ldw	r3,0(r3)
 2001334:	10c00c15 	stw	r3,48(r2)

  return ret_code;
 2001338:	e0bff717 	ldw	r2,-36(fp)
}
 200133c:	e037883a 	mov	sp,fp
 2001340:	dfc00117 	ldw	ra,4(sp)
 2001344:	df000017 	ldw	fp,0(sp)
 2001348:	dec00204 	addi	sp,sp,8
 200134c:	f800283a 	ret

02001350 <http_read_line>:
 * 
 * This routine will scan the RX data buffer for a newline, allowing us to
 * parse an in-coming HTTP request line-by-line.
 */
int http_read_line(http_conn* conn)
{
 2001350:	defffb04 	addi	sp,sp,-20
 2001354:	dfc00415 	stw	ra,16(sp)
 2001358:	df000315 	stw	fp,12(sp)
 200135c:	df000304 	addi	fp,sp,12
 2001360:	e13fff15 	stw	r4,-4(fp)
  char* lf_addr;
  int ret_code = 0;
 2001364:	e03ffd15 	stw	zero,-12(fp)

  /* Find the Carriage return which marks the end of the header */
  lf_addr = strchr(conn->rx_rd_pos, '\n');
 2001368:	e0bfff17 	ldw	r2,-4(fp)
 200136c:	10800d17 	ldw	r2,52(r2)
 2001370:	1009883a 	mov	r4,r2
 2001374:	01400284 	movi	r5,10
 2001378:	20073e00 	call	20073e0 <strchr>
 200137c:	e0bffe15 	stw	r2,-8(fp)
  
  if (lf_addr == NULL)
 2001380:	e0bffe17 	ldw	r2,-8(fp)
 2001384:	1000031e 	bne	r2,zero,2001394 <http_read_line+0x44>
  {
    ret_code = -1;
 2001388:	00bfffc4 	movi	r2,-1
 200138c:	e0bffd15 	stw	r2,-12(fp)
 2001390:	00001506 	br	20013e8 <http_read_line+0x98>
  {
    /* 
     * Check that the line feed has a matching CR, if so zero that
     * else zero the LF so we can use the string searching functions.
     */
    if ((lf_addr > conn->rx_buffer) && (*(lf_addr-1) == '\r'))
 2001394:	e0bfff17 	ldw	r2,-4(fp)
 2001398:	10c01117 	ldw	r3,68(r2)
 200139c:	e0bffe17 	ldw	r2,-8(fp)
 20013a0:	18800b2e 	bgeu	r3,r2,20013d0 <http_read_line+0x80>
 20013a4:	e0bffe17 	ldw	r2,-8(fp)
 20013a8:	10bfffc4 	addi	r2,r2,-1
 20013ac:	10800003 	ldbu	r2,0(r2)
 20013b0:	10803fcc 	andi	r2,r2,255
 20013b4:	1080201c 	xori	r2,r2,128
 20013b8:	10bfe004 	addi	r2,r2,-128
 20013bc:	10800358 	cmpnei	r2,r2,13
 20013c0:	1000031e 	bne	r2,zero,20013d0 <http_read_line+0x80>
    {
      *(lf_addr-1) = 0;
 20013c4:	e0bffe17 	ldw	r2,-8(fp)
 20013c8:	10bfffc4 	addi	r2,r2,-1
 20013cc:	10000005 	stb	zero,0(r2)
    }

    *lf_addr = 0;
 20013d0:	e0bffe17 	ldw	r2,-8(fp)
 20013d4:	10000005 	stb	zero,0(r2)
    conn->rx_rd_pos = lf_addr+1;
 20013d8:	e0bffe17 	ldw	r2,-8(fp)
 20013dc:	10c00044 	addi	r3,r2,1
 20013e0:	e0bfff17 	ldw	r2,-4(fp)
 20013e4:	10c00d15 	stw	r3,52(r2)
  }

  return ret_code;
 20013e8:	e0bffd17 	ldw	r2,-12(fp)
}
 20013ec:	e037883a 	mov	sp,fp
 20013f0:	dfc00117 	ldw	ra,4(sp)
 20013f4:	df000017 	ldw	fp,0(sp)
 20013f8:	dec00204 	addi	sp,sp,8
 20013fc:	f800283a 	ret

02001400 <http_parse_type_boundary>:
 *   - Content-Type, Content-Disposition, boundary, etc.
 */
int http_parse_type_boundary( http_conn* conn,
                                char* start,
                                int len )
{
 2001400:	deffb904 	addi	sp,sp,-284
 2001404:	dfc04615 	stw	ra,280(sp)
 2001408:	df004515 	stw	fp,276(sp)
 200140c:	df004504 	addi	fp,sp,276
 2001410:	e13ffd15 	stw	r4,-12(fp)
 2001414:	e17ffe15 	stw	r5,-8(fp)
 2001418:	e1bfff15 	stw	r6,-4(fp)
  char* delimiter;
  char* boundary_start;
  char line[HTTP_MAX_LINE_SIZE];
  
  /* Copy the Content-Type/Boundary line. */
  if( len > HTTP_MAX_LINE_SIZE )
 200141c:	e0bfff17 	ldw	r2,-4(fp)
 2001420:	10804050 	cmplti	r2,r2,257
 2001424:	1000051e 	bne	r2,zero,200143c <http_parse_type_boundary+0x3c>
  {
    printf( "process headers:  overflow content-type/boundary parsing.\n" );
 2001428:	01008174 	movhi	r4,517
 200142c:	2132cd04 	addi	r4,r4,-13516
 2001430:	2006cb40 	call	2006cb4 <puts>
    return(-1);
 2001434:	00bfffc4 	movi	r2,-1
 2001438:	00002c06 	br	20014ec <http_parse_type_boundary+0xec>
  }
  strncpy( line, start, len );
 200143c:	e0bfff17 	ldw	r2,-4(fp)
 2001440:	e0ffbd04 	addi	r3,fp,-268
 2001444:	1809883a 	mov	r4,r3
 2001448:	e17ffe17 	ldw	r5,-8(fp)
 200144c:	100d883a 	mov	r6,r2
 2001450:	2007dec0 	call	2007dec <strncpy>
  /* Add a null byte to the end of it. */
  *(line + len) = '\0';
 2001454:	e0bfff17 	ldw	r2,-4(fp)
 2001458:	e0ffbd04 	addi	r3,fp,-268
 200145c:	1885883a 	add	r2,r3,r2
 2001460:	10000005 	stb	zero,0(r2)
  /* Get the Content-Type value. */
  if( (delimiter = strchr( line, ';' )) )
 2001464:	e0bfbd04 	addi	r2,fp,-268
 2001468:	1009883a 	mov	r4,r2
 200146c:	01400ec4 	movi	r5,59
 2001470:	20073e00 	call	20073e0 <strchr>
 2001474:	e0bfbb15 	stw	r2,-276(fp)
 2001478:	e0bfbb17 	ldw	r2,-276(fp)
 200147c:	10001426 	beq	r2,zero,20014d0 <http_parse_type_boundary+0xd0>
  {
    /* Need to parse both a boundary and Content-Type. */
    boundary_start = strchr( line, '=' ) + 2;
 2001480:	e0bfbd04 	addi	r2,fp,-268
 2001484:	1009883a 	mov	r4,r2
 2001488:	01400f44 	movi	r5,61
 200148c:	20073e00 	call	20073e0 <strchr>
 2001490:	10800084 	addi	r2,r2,2
 2001494:	e0bfbc15 	stw	r2,-272(fp)
    strcpy( conn->boundary, boundary_start);
 2001498:	e0bffd17 	ldw	r2,-12(fp)
 200149c:	10806204 	addi	r2,r2,392
 20014a0:	1009883a 	mov	r4,r2
 20014a4:	e17fbc17 	ldw	r5,-272(fp)
 20014a8:	200756c0 	call	200756c <strcpy>
    /* Insert a null space in place of the delimiter. */
    *delimiter = '\0';
 20014ac:	e0bfbb17 	ldw	r2,-276(fp)
 20014b0:	10000005 	stb	zero,0(r2)
    /* First part of the line is the Content-Type. */
    strcpy( conn->content_type, line);
 20014b4:	e0bffd17 	ldw	r2,-12(fp)
 20014b8:	10c05804 	addi	r3,r2,352
 20014bc:	e0bfbd04 	addi	r2,fp,-268
 20014c0:	1809883a 	mov	r4,r3
 20014c4:	100b883a 	mov	r5,r2
 20014c8:	200756c0 	call	200756c <strcpy>
 20014cc:	00000606 	br	20014e8 <http_parse_type_boundary+0xe8>
  }
  else
  {
    strcpy( conn->content_type, line );
 20014d0:	e0bffd17 	ldw	r2,-12(fp)
 20014d4:	10c05804 	addi	r3,r2,352
 20014d8:	e0bfbd04 	addi	r2,fp,-268
 20014dc:	1809883a 	mov	r4,r3
 20014e0:	100b883a 	mov	r5,r2
 20014e4:	200756c0 	call	200756c <strcpy>
  }
  return 0;
 20014e8:	0005883a 	mov	r2,zero
}
 20014ec:	e037883a 	mov	sp,fp
 20014f0:	dfc00117 	ldw	ra,4(sp)
 20014f4:	df000017 	ldw	fp,0(sp)
 20014f8:	dec00204 	addi	sp,sp,8
 20014fc:	f800283a 	ret

02001500 <http_process_headers>:
 * This routine should be modified in the future not to use strtok() as its
 * a bit invasive and is not thread-safe!
 * 
 */
int http_process_headers(http_conn* conn)
{
 2001500:	defff404 	addi	sp,sp,-48
 2001504:	dfc00b15 	stw	ra,44(sp)
 2001508:	df000a15 	stw	fp,40(sp)
 200150c:	df000a04 	addi	fp,sp,40
 2001510:	e13fff15 	stw	r4,-4(fp)
  char* option;
  char* cr_pos;
  char* ct_start;
  char* orig_read_pos = conn->rx_rd_pos;
 2001514:	e0bfff17 	ldw	r2,-4(fp)
 2001518:	10800d17 	ldw	r2,52(r2)
 200151c:	e0bff615 	stw	r2,-40(fp)
  /* 
   * A boundary was found.  This is a multi-part form
   * and header processing stops here!
   * 
   */
  if( (conn->boundary[0] == '-') && (conn->content_length > 0) )
 2001520:	e0bfff17 	ldw	r2,-4(fp)
 2001524:	10806203 	ldbu	r2,392(r2)
 2001528:	10803fcc 	andi	r2,r2,255
 200152c:	1080201c 	xori	r2,r2,128
 2001530:	10bfe004 	addi	r2,r2,-128
 2001534:	10800b58 	cmpnei	r2,r2,45
 2001538:	10000d1e 	bne	r2,zero,2001570 <http_process_headers+0x70>
 200153c:	e0bfff17 	ldw	r2,-4(fp)
 2001540:	10800517 	ldw	r2,20(r2)
 2001544:	00800a0e 	bge	zero,r2,2001570 <http_process_headers+0x70>

  {
    boundary_start = strstr( conn->rx_rd_pos, conn->boundary );
 2001548:	e0bfff17 	ldw	r2,-4(fp)
 200154c:	10c00d17 	ldw	r3,52(r2)
 2001550:	e0bfff17 	ldw	r2,-4(fp)
 2001554:	10806204 	addi	r2,r2,392
 2001558:	1809883a 	mov	r4,r3
 200155c:	100b883a 	mov	r5,r2
 2001560:	20083340 	call	2008334 <strstr>
 2001564:	e0bff715 	stw	r2,-36(fp)
    //conn->rx_rd_pos = boundary_start + strlen(conn->boundary);
    return -1;
 2001568:	00bfffc4 	movi	r2,-1
 200156c:	00006406 	br	2001700 <http_process_headers+0x200>
  }
  /* Skip the next section we'll chop with strtok(). Perl for Nios, anyone? */
  else if( (delimiter_token = strchr(conn->rx_rd_pos, ':')) )
 2001570:	e0bfff17 	ldw	r2,-4(fp)
 2001574:	10800d17 	ldw	r2,52(r2)
 2001578:	1009883a 	mov	r4,r2
 200157c:	01400e84 	movi	r5,58
 2001580:	20073e00 	call	20073e0 <strchr>
 2001584:	e0bff815 	stw	r2,-32(fp)
 2001588:	e0bff817 	ldw	r2,-32(fp)
 200158c:	10001726 	beq	r2,zero,20015ec <http_process_headers+0xec>
  {
    conn->rx_rd_pos = delimiter_token + 1;
 2001590:	e0bff817 	ldw	r2,-32(fp)
 2001594:	10c00044 	addi	r3,r2,1
 2001598:	e0bfff17 	ldw	r2,-4(fp)
 200159c:	10c00d15 	stw	r3,52(r2)
    conn->content_received = conn->rx_rd_pos - conn->rx_buffer;
 20015a0:	e0bfff17 	ldw	r2,-4(fp)
 20015a4:	10800d17 	ldw	r2,52(r2)
 20015a8:	1007883a 	mov	r3,r2
 20015ac:	e0bfff17 	ldw	r2,-4(fp)
 20015b0:	10801117 	ldw	r2,68(r2)
 20015b4:	1887c83a 	sub	r3,r3,r2
 20015b8:	e0bfff17 	ldw	r2,-4(fp)
 20015bc:	10c00615 	stw	r3,24(r2)
  else
  {
    return -1;
  }
  
  option = strtok(orig_read_pos, ":");
 20015c0:	e13ff617 	ldw	r4,-40(fp)
 20015c4:	01408174 	movhi	r5,517
 20015c8:	2972dc04 	addi	r5,r5,-13456
 20015cc:	20086a80 	call	20086a8 <strtok>
 20015d0:	e0bff915 	stw	r2,-28(fp)

  if(stricmp(option,"Connection") == 0)
 20015d4:	e13ff917 	ldw	r4,-28(fp)
 20015d8:	01408174 	movhi	r5,517
 20015dc:	2972dd04 	addi	r5,r5,-13452
 20015e0:	20072940 	call	2007294 <strcasecmp>
 20015e4:	10000326 	beq	r2,zero,20015f4 <http_process_headers+0xf4>
 20015e8:	00001706 	br	2001648 <http_process_headers+0x148>
    conn->rx_rd_pos = delimiter_token + 1;
    conn->content_received = conn->rx_rd_pos - conn->rx_buffer;
  }
  else
  {
    return -1;
 20015ec:	00bfffc4 	movi	r2,-1
 20015f0:	00004306 	br	2001700 <http_process_headers+0x200>
  
  option = strtok(orig_read_pos, ":");

  if(stricmp(option,"Connection") == 0)
  {
    temp_null = *(option + 17);
 20015f4:	e0bff917 	ldw	r2,-28(fp)
 20015f8:	10800443 	ldbu	r2,17(r2)
 20015fc:	e0bffa05 	stb	r2,-24(fp)
    *(option + 17) = 0;
 2001600:	e0bff917 	ldw	r2,-28(fp)
 2001604:	10800444 	addi	r2,r2,17
 2001608:	10000005 	stb	zero,0(r2)
    
    if(stricmp((option+12), "close") == 0)
 200160c:	e0bff917 	ldw	r2,-28(fp)
 2001610:	10800304 	addi	r2,r2,12
 2001614:	1009883a 	mov	r4,r2
 2001618:	01408174 	movhi	r5,517
 200161c:	2972e004 	addi	r5,r5,-13440
 2001620:	20072940 	call	2007294 <strcasecmp>
 2001624:	1000031e 	bne	r2,zero,2001634 <http_process_headers+0x134>
    {
      conn->close = 1;
 2001628:	e0bfff17 	ldw	r2,-4(fp)
 200162c:	00c00044 	movi	r3,1
 2001630:	10c00415 	stw	r3,16(r2)
    }
    *(option + 17) = temp_null;
 2001634:	e0bff917 	ldw	r2,-28(fp)
 2001638:	10800444 	addi	r2,r2,17
 200163c:	e0fffa03 	ldbu	r3,-24(fp)
 2001640:	10c00005 	stb	r3,0(r2)
 2001644:	00002d06 	br	20016fc <http_process_headers+0x1fc>
  }
  else if (stricmp(option, "Content-Length") == 0)
 2001648:	e13ff917 	ldw	r4,-28(fp)
 200164c:	01408174 	movhi	r5,517
 2001650:	2972e204 	addi	r5,r5,-13432
 2001654:	20072940 	call	2007294 <strcasecmp>
 2001658:	1000071e 	bne	r2,zero,2001678 <http_process_headers+0x178>
  {
    conn->content_length = atoi(option+16);
 200165c:	e0bff917 	ldw	r2,-28(fp)
 2001660:	10800404 	addi	r2,r2,16
 2001664:	1009883a 	mov	r4,r2
 2001668:	20044d40 	call	20044d4 <atoi>
 200166c:	e0ffff17 	ldw	r3,-4(fp)
 2001670:	18800515 	stw	r2,20(r3)
 2001674:	00002106 	br	20016fc <http_process_headers+0x1fc>
    //printf( "Content Length = %d.\n", conn->content_length );
  }
  /* When getting the Content-Type, get the whole line and throw it
   * to another function.  This will be done several times.
   */
  else if (stricmp(option, "Content-Type" ) == 0)
 2001678:	e13ff917 	ldw	r4,-28(fp)
 200167c:	01408174 	movhi	r5,517
 2001680:	2972e604 	addi	r5,r5,-13416
 2001684:	20072940 	call	2007294 <strcasecmp>
 2001688:	10001c1e 	bne	r2,zero,20016fc <http_process_headers+0x1fc>
  {
    /* Determine the end of line for "Content-Type" line. */
    cr_pos = strchr( conn->rx_rd_pos, '\r' );
 200168c:	e0bfff17 	ldw	r2,-4(fp)
 2001690:	10800d17 	ldw	r2,52(r2)
 2001694:	1009883a 	mov	r4,r2
 2001698:	01400344 	movi	r5,13
 200169c:	20073e00 	call	20073e0 <strchr>
 20016a0:	e0bffb15 	stw	r2,-20(fp)
    /* Find the length of the string. */
    opt_len = strlen(option);
 20016a4:	e13ff917 	ldw	r4,-28(fp)
 20016a8:	2007c640 	call	2007c64 <strlen>
 20016ac:	e0bffc15 	stw	r2,-16(fp)
    ct_len = cr_pos - (option + opt_len + 2);
 20016b0:	e0fffb17 	ldw	r3,-20(fp)
 20016b4:	e0bffc17 	ldw	r2,-16(fp)
 20016b8:	10800084 	addi	r2,r2,2
 20016bc:	e13ff917 	ldw	r4,-28(fp)
 20016c0:	2085883a 	add	r2,r4,r2
 20016c4:	1885c83a 	sub	r2,r3,r2
 20016c8:	e0bffd15 	stw	r2,-12(fp)
    /* Calculate the start of the string. */
    ct_start = cr_pos - ct_len;
 20016cc:	e0bffd17 	ldw	r2,-12(fp)
 20016d0:	0085c83a 	sub	r2,zero,r2
 20016d4:	e0fffb17 	ldw	r3,-20(fp)
 20016d8:	1885883a 	add	r2,r3,r2
 20016dc:	e0bffe15 	stw	r2,-8(fp)
    /* Pass the start of the string and the size of the string to 
     * a function.
     */
    if( (http_parse_type_boundary( conn, ct_start, ct_len ) < 0) )
 20016e0:	e13fff17 	ldw	r4,-4(fp)
 20016e4:	e17ffe17 	ldw	r5,-8(fp)
 20016e8:	e1bffd17 	ldw	r6,-12(fp)
 20016ec:	20014000 	call	2001400 <http_parse_type_boundary>
 20016f0:	1000020e 	bge	r2,zero,20016fc <http_process_headers+0x1fc>
    {
      /* Something failed...return a negative value. */
      return -1;
 20016f4:	00bfffc4 	movi	r2,-1
 20016f8:	00000106 	br	2001700 <http_process_headers+0x200>
    }
  }
  return 0;
 20016fc:	0005883a 	mov	r2,zero
}
 2001700:	e037883a 	mov	sp,fp
 2001704:	dfc00117 	ldw	ra,4(sp)
 2001708:	df000017 	ldw	fp,0(sp)
 200170c:	dec00204 	addi	sp,sp,8
 2001710:	f800283a 	ret

02001714 <http_process_request>:
 * This routine parses the beginnings of an HTTP request to extract the
 * command, version, and URI. Unsupported commands/versions/etc. will cause
 * us to error out drop the connection.
 */
int http_process_request(http_conn* conn)
{
 2001714:	defffa04 	addi	sp,sp,-24
 2001718:	dfc00515 	stw	ra,20(sp)
 200171c:	df000415 	stw	fp,16(sp)
 2001720:	df000404 	addi	fp,sp,16
 2001724:	e13fff15 	stw	r4,-4(fp)
  char* uri = 0;
 2001728:	e03ffc15 	stw	zero,-16(fp)
  char* version = 0;
 200172c:	e03ffd15 	stw	zero,-12(fp)
  char* temp = 0;
 2001730:	e03ffe15 	stw	zero,-8(fp)
  if( (temp = strstr(conn->rx_rd_pos, "GET")) )
 2001734:	e0bfff17 	ldw	r2,-4(fp)
 2001738:	10800d17 	ldw	r2,52(r2)
 200173c:	1009883a 	mov	r4,r2
 2001740:	01408174 	movhi	r5,517
 2001744:	2972ea04 	addi	r5,r5,-13400
 2001748:	20083340 	call	2008334 <strstr>
 200174c:	e0bffe15 	stw	r2,-8(fp)
 2001750:	e0bffe17 	ldw	r2,-8(fp)
 2001754:	10000726 	beq	r2,zero,2001774 <http_process_request+0x60>
  {
    conn->action = GET;
 2001758:	e0bfff17 	ldw	r2,-4(fp)
 200175c:	00c00044 	movi	r3,1
 2001760:	10c00115 	stw	r3,4(r2)
    conn->rx_rd_pos = temp;
 2001764:	e0bfff17 	ldw	r2,-4(fp)
 2001768:	e0fffe17 	ldw	r3,-8(fp)
 200176c:	10c00d15 	stw	r3,52(r2)
 2001770:	00001e06 	br	20017ec <http_process_request+0xd8>
  }
  else if( (temp = strstr(conn->rx_rd_pos, "POST")) )
 2001774:	e0bfff17 	ldw	r2,-4(fp)
 2001778:	10800d17 	ldw	r2,52(r2)
 200177c:	1009883a 	mov	r4,r2
 2001780:	01408174 	movhi	r5,517
 2001784:	2972eb04 	addi	r5,r5,-13396
 2001788:	20083340 	call	2008334 <strstr>
 200178c:	e0bffe15 	stw	r2,-8(fp)
 2001790:	e0bffe17 	ldw	r2,-8(fp)
 2001794:	10000726 	beq	r2,zero,20017b4 <http_process_request+0xa0>
  {
    conn->action = POST;
 2001798:	e0bfff17 	ldw	r2,-4(fp)
 200179c:	00c00084 	movi	r3,2
 20017a0:	10c00115 	stw	r3,4(r2)
    conn->rx_rd_pos = temp;
 20017a4:	e0bfff17 	ldw	r2,-4(fp)
 20017a8:	e0fffe17 	ldw	r3,-8(fp)
 20017ac:	10c00d15 	stw	r3,52(r2)
 20017b0:	00000e06 	br	20017ec <http_process_request+0xd8>
  }
  else
  {
    fprintf(stderr, "Unsupported (for now) request\n");
 20017b4:	00808174 	movhi	r2,517
 20017b8:	10903604 	addi	r2,r2,16600
 20017bc:	10800017 	ldw	r2,0(r2)
 20017c0:	10800317 	ldw	r2,12(r2)
 20017c4:	01008174 	movhi	r4,517
 20017c8:	2132ed04 	addi	r4,r4,-13388
 20017cc:	01400044 	movi	r5,1
 20017d0:	01800784 	movi	r6,30
 20017d4:	100f883a 	mov	r7,r2
 20017d8:	2005ba80 	call	2005ba8 <fwrite>
    conn->action = UNKNOWN;
 20017dc:	e0bfff17 	ldw	r2,-4(fp)
 20017e0:	10000115 	stw	zero,4(r2)
    return -1;
 20017e4:	00bfffc4 	movi	r2,-1
 20017e8:	00007806 	br	20019cc <http_process_request+0x2b8>
  }
  
  /* First space char separates action from URI */
  if( (conn->rx_rd_pos = strchr(conn->rx_rd_pos, ' ')) )
 20017ec:	e0bfff17 	ldw	r2,-4(fp)
 20017f0:	10800d17 	ldw	r2,52(r2)
 20017f4:	1009883a 	mov	r4,r2
 20017f8:	01400804 	movi	r5,32
 20017fc:	20073e00 	call	20073e0 <strchr>
 2001800:	e0ffff17 	ldw	r3,-4(fp)
 2001804:	18800d15 	stw	r2,52(r3)
 2001808:	e0bfff17 	ldw	r2,-4(fp)
 200180c:	10800d17 	ldw	r2,52(r2)
 2001810:	10001326 	beq	r2,zero,2001860 <http_process_request+0x14c>
  {
    conn->rx_rd_pos++;
 2001814:	e0bfff17 	ldw	r2,-4(fp)
 2001818:	10800d17 	ldw	r2,52(r2)
 200181c:	10c00044 	addi	r3,r2,1
 2001820:	e0bfff17 	ldw	r2,-4(fp)
 2001824:	10c00d15 	stw	r3,52(r2)
    uri = conn->rx_rd_pos;
 2001828:	e0bfff17 	ldw	r2,-4(fp)
 200182c:	10800d17 	ldw	r2,52(r2)
 2001830:	e0bffc15 	stw	r2,-16(fp)
  {
    return -1;
  }
    
  /* Second space char separates URI from HTTP version. */
  if( (conn->rx_rd_pos = strchr(conn->rx_rd_pos, ' ')) )
 2001834:	e0bfff17 	ldw	r2,-4(fp)
 2001838:	10800d17 	ldw	r2,52(r2)
 200183c:	1009883a 	mov	r4,r2
 2001840:	01400804 	movi	r5,32
 2001844:	20073e00 	call	20073e0 <strchr>
 2001848:	e0ffff17 	ldw	r3,-4(fp)
 200184c:	18800d15 	stw	r2,52(r3)
 2001850:	e0bfff17 	ldw	r2,-4(fp)
 2001854:	10800d17 	ldw	r2,52(r2)
 2001858:	1000031e 	bne	r2,zero,2001868 <http_process_request+0x154>
 200185c:	00001006 	br	20018a0 <http_process_request+0x18c>
    conn->rx_rd_pos++;
    uri = conn->rx_rd_pos;
  }
  else
  {
    return -1;
 2001860:	00bfffc4 	movi	r2,-1
 2001864:	00005906 	br	20019cc <http_process_request+0x2b8>
  }
    
  /* Second space char separates URI from HTTP version. */
  if( (conn->rx_rd_pos = strchr(conn->rx_rd_pos, ' ')) )
  {
    *conn->rx_rd_pos = 0;
 2001868:	e0bfff17 	ldw	r2,-4(fp)
 200186c:	10800d17 	ldw	r2,52(r2)
 2001870:	10000005 	stb	zero,0(r2)
    conn->rx_rd_pos++;
 2001874:	e0bfff17 	ldw	r2,-4(fp)
 2001878:	10800d17 	ldw	r2,52(r2)
 200187c:	10c00044 	addi	r3,r2,1
 2001880:	e0bfff17 	ldw	r2,-4(fp)
 2001884:	10c00d15 	stw	r3,52(r2)
    version = conn->rx_rd_pos;
 2001888:	e0bfff17 	ldw	r2,-4(fp)
 200188c:	10800d17 	ldw	r2,52(r2)
 2001890:	e0bffd15 	stw	r2,-12(fp)
  {
    return -1;
  }
  
  /* Is this an HTTP version we support? */
  if ((version == NULL) || (strncmp(version, "HTTP/", 5) != 0))
 2001894:	e0bffd17 	ldw	r2,-12(fp)
 2001898:	10000926 	beq	r2,zero,20018c0 <http_process_request+0x1ac>
 200189c:	00000206 	br	20018a8 <http_process_request+0x194>
    conn->rx_rd_pos++;
    version = conn->rx_rd_pos;
  }
  else
  {
    return -1;
 20018a0:	00bfffc4 	movi	r2,-1
 20018a4:	00004906 	br	20019cc <http_process_request+0x2b8>
  }
  
  /* Is this an HTTP version we support? */
  if ((version == NULL) || (strncmp(version, "HTTP/", 5) != 0))
 20018a8:	e13ffd17 	ldw	r4,-12(fp)
 20018ac:	01408174 	movhi	r5,517
 20018b0:	2972f504 	addi	r5,r5,-13356
 20018b4:	01800144 	movi	r6,5
 20018b8:	2007cf00 	call	2007cf0 <strncmp>
 20018bc:	10000226 	beq	r2,zero,20018c8 <http_process_request+0x1b4>
  {
    return -1;
 20018c0:	00bfffc4 	movi	r2,-1
 20018c4:	00004106 	br	20019cc <http_process_request+0x2b8>
  }

  if (!isdigit(version[5]) || version[6] != '.' || !isdigit(version[7]))
 20018c8:	00808174 	movhi	r2,517
 20018cc:	10903404 	addi	r2,r2,16592
 20018d0:	10c00017 	ldw	r3,0(r2)
 20018d4:	e0bffd17 	ldw	r2,-12(fp)
 20018d8:	10800144 	addi	r2,r2,5
 20018dc:	10800003 	ldbu	r2,0(r2)
 20018e0:	10803fcc 	andi	r2,r2,255
 20018e4:	1080201c 	xori	r2,r2,128
 20018e8:	10bfe004 	addi	r2,r2,-128
 20018ec:	1885883a 	add	r2,r3,r2
 20018f0:	10800003 	ldbu	r2,0(r2)
 20018f4:	10803fcc 	andi	r2,r2,255
 20018f8:	1080010c 	andi	r2,r2,4
 20018fc:	10001626 	beq	r2,zero,2001958 <http_process_request+0x244>
 2001900:	e0bffd17 	ldw	r2,-12(fp)
 2001904:	10800184 	addi	r2,r2,6
 2001908:	10800003 	ldbu	r2,0(r2)
 200190c:	10803fcc 	andi	r2,r2,255
 2001910:	1080201c 	xori	r2,r2,128
 2001914:	10bfe004 	addi	r2,r2,-128
 2001918:	10800b98 	cmpnei	r2,r2,46
 200191c:	10000e1e 	bne	r2,zero,2001958 <http_process_request+0x244>
 2001920:	00808174 	movhi	r2,517
 2001924:	10903404 	addi	r2,r2,16592
 2001928:	10c00017 	ldw	r3,0(r2)
 200192c:	e0bffd17 	ldw	r2,-12(fp)
 2001930:	108001c4 	addi	r2,r2,7
 2001934:	10800003 	ldbu	r2,0(r2)
 2001938:	10803fcc 	andi	r2,r2,255
 200193c:	1080201c 	xori	r2,r2,128
 2001940:	10bfe004 	addi	r2,r2,-128
 2001944:	1885883a 	add	r2,r3,r2
 2001948:	10800003 	ldbu	r2,0(r2)
 200194c:	10803fcc 	andi	r2,r2,255
 2001950:	1080010c 	andi	r2,r2,4
 2001954:	1000021e 	bne	r2,zero,2001960 <http_process_request+0x24c>
  {
    return -1;
 2001958:	00bfffc4 	movi	r2,-1
 200195c:	00001b06 	br	20019cc <http_process_request+0x2b8>
  }

  /* Before v1.1 we close the connection after responding to the request */
  if ( (((version[5] - '0')*10) + version[7] - '0') < 11)
 2001960:	e0bffd17 	ldw	r2,-12(fp)
 2001964:	10800144 	addi	r2,r2,5
 2001968:	10800003 	ldbu	r2,0(r2)
 200196c:	10803fcc 	andi	r2,r2,255
 2001970:	1080201c 	xori	r2,r2,128
 2001974:	10bfe004 	addi	r2,r2,-128
 2001978:	108002a4 	muli	r2,r2,10
 200197c:	10ff8804 	addi	r3,r2,-480
 2001980:	e0bffd17 	ldw	r2,-12(fp)
 2001984:	108001c4 	addi	r2,r2,7
 2001988:	10800003 	ldbu	r2,0(r2)
 200198c:	10803fcc 	andi	r2,r2,255
 2001990:	1080201c 	xori	r2,r2,128
 2001994:	10bfe004 	addi	r2,r2,-128
 2001998:	1885883a 	add	r2,r3,r2
 200199c:	10bff404 	addi	r2,r2,-48
 20019a0:	108002c8 	cmpgei	r2,r2,11
 20019a4:	1000031e 	bne	r2,zero,20019b4 <http_process_request+0x2a0>
  {
    conn->close = 1;
 20019a8:	e0bfff17 	ldw	r2,-4(fp)
 20019ac:	00c00044 	movi	r3,1
 20019b0:	10c00415 	stw	r3,16(r2)
  }

  strcpy(conn->uri, uri);
 20019b4:	e0bfff17 	ldw	r2,-4(fp)
 20019b8:	10807604 	addi	r2,r2,472
 20019bc:	1009883a 	mov	r4,r2
 20019c0:	e17ffc17 	ldw	r5,-16(fp)
 20019c4:	200756c0 	call	200756c <strcpy>
  return 0;
 20019c8:	0005883a 	mov	r2,zero
}
 20019cc:	e037883a 	mov	sp,fp
 20019d0:	dfc00117 	ldw	ra,4(sp)
 20019d4:	df000017 	ldw	fp,0(sp)
 20019d8:	dec00204 	addi	sp,sp,8
 20019dc:	f800283a 	ret

020019e0 <http_send_file_chunk>:
 * repeatedly until the file is completely sent, at which time the connection
 * state will go to "COMPLETE". Doing this rather than sending the entire
 * file allows us (in part) to multiplex between connections "simultaneously".
 */
int http_send_file_chunk(http_conn* conn)
{
 20019e0:	defff804 	addi	sp,sp,-32
 20019e4:	dfc00715 	stw	ra,28(sp)
 20019e8:	df000615 	stw	fp,24(sp)
 20019ec:	df000604 	addi	fp,sp,24
 20019f0:	e13fff15 	stw	r4,-4(fp)
  int chunk_sent = 0, ret_code = 0, file_chunk_size = 0, result = 0;
 20019f4:	e03ffa15 	stw	zero,-24(fp)
 20019f8:	e03ffd15 	stw	zero,-12(fp)
 20019fc:	e03ffb15 	stw	zero,-20(fp)
 2001a00:	e03ffe15 	stw	zero,-8(fp)
  char* tx_ptr;
  
  if(conn->data_sent < conn->file_length)
 2001a04:	e0bfff17 	ldw	r2,-4(fp)
 2001a08:	10c00917 	ldw	r3,36(r2)
 2001a0c:	e0bfff17 	ldw	r2,-4(fp)
 2001a10:	10800817 	ldw	r2,32(r2)
 2001a14:	1880490e 	bge	r3,r2,2001b3c <http_send_file_chunk+0x15c>
  {
    file_chunk_size = fread(conn->tx_buffer, 1, 
 2001a18:	e0bfff17 	ldw	r2,-4(fp)
 2001a1c:	11001217 	ldw	r4,72(r2)
      MIN(HTTP_TX_BUF_SIZE, (conn->file_length - conn->data_sent)), 
 2001a20:	e0bfff17 	ldw	r2,-4(fp)
 2001a24:	10c00817 	ldw	r3,32(r2)
 2001a28:	e0bfff17 	ldw	r2,-4(fp)
 2001a2c:	10800917 	ldw	r2,36(r2)
 2001a30:	1885c83a 	sub	r2,r3,r2
 2001a34:	10c80050 	cmplti	r3,r2,8193
 2001a38:	1800011e 	bne	r3,zero,2001a40 <http_send_file_chunk+0x60>
 2001a3c:	00880004 	movi	r2,8192
  int chunk_sent = 0, ret_code = 0, file_chunk_size = 0, result = 0;
  char* tx_ptr;
  
  if(conn->data_sent < conn->file_length)
  {
    file_chunk_size = fread(conn->tx_buffer, 1, 
 2001a40:	1007883a 	mov	r3,r2
      MIN(HTTP_TX_BUF_SIZE, (conn->file_length - conn->data_sent)), 
      conn->file_handle);
 2001a44:	e0bfff17 	ldw	r2,-4(fp)
  int chunk_sent = 0, ret_code = 0, file_chunk_size = 0, result = 0;
  char* tx_ptr;
  
  if(conn->data_sent < conn->file_length)
  {
    file_chunk_size = fread(conn->tx_buffer, 1, 
 2001a48:	10800b17 	ldw	r2,44(r2)
 2001a4c:	01400044 	movi	r5,1
 2001a50:	180d883a 	mov	r6,r3
 2001a54:	100f883a 	mov	r7,r2
 2001a58:	2004f380 	call	2004f38 <fread>
 2001a5c:	e0bffb15 	stw	r2,-20(fp)
      MIN(HTTP_TX_BUF_SIZE, (conn->file_length - conn->data_sent)), 
      conn->file_handle);
    
    tx_ptr = conn->tx_buffer;
 2001a60:	e0bfff17 	ldw	r2,-4(fp)
 2001a64:	10801217 	ldw	r2,72(r2)
 2001a68:	e0bffc15 	stw	r2,-16(fp)
    
    while(chunk_sent < file_chunk_size)
 2001a6c:	00003006 	br	2001b30 <http_send_file_chunk+0x150>
    {
      result = send(conn->fd, tx_ptr, file_chunk_size, 0);
 2001a70:	e0bfff17 	ldw	r2,-4(fp)
 2001a74:	10800317 	ldw	r2,12(r2)
 2001a78:	1009883a 	mov	r4,r2
 2001a7c:	e17ffc17 	ldw	r5,-16(fp)
 2001a80:	e1bffb17 	ldw	r6,-20(fp)
 2001a84:	000f883a 	mov	r7,zero
 2001a88:	202c5d80 	call	202c5d8 <t_send>
 2001a8c:	e0bffe15 	stw	r2,-8(fp)
      
      /* Error - get out of here! */
      if(result < 0)
 2001a90:	e0bffe17 	ldw	r2,-8(fp)
 2001a94:	10000e0e 	bge	r2,zero,2001ad0 <http_send_file_chunk+0xf0>
      {
        fprintf(stderr, "[http_send_file] file send returned %d\n", result);
 2001a98:	00808174 	movhi	r2,517
 2001a9c:	10903604 	addi	r2,r2,16600
 2001aa0:	10800017 	ldw	r2,0(r2)
 2001aa4:	10800317 	ldw	r2,12(r2)
 2001aa8:	1009883a 	mov	r4,r2
 2001aac:	01408174 	movhi	r5,517
 2001ab0:	2972f704 	addi	r5,r5,-13348
 2001ab4:	e1bffe17 	ldw	r6,-8(fp)
 2001ab8:	2004ce80 	call	2004ce8 <fprintf>
        ALT_DEBUG_ASSERT(1);
        conn->state = RESET;
 2001abc:	e0bfff17 	ldw	r2,-4(fp)
 2001ac0:	00c00104 	movi	r3,4
 2001ac4:	10c00015 	stw	r3,0(r2)
        return result;
 2001ac8:	e0bffe17 	ldw	r2,-8(fp)
 2001acc:	00002406 	br	2001b60 <http_send_file_chunk+0x180>
 2001ad0:	00808174 	movhi	r2,517
 2001ad4:	10909604 	addi	r2,r2,16984
 2001ad8:	10800017 	ldw	r2,0(r2)
      /*
       * No errors, but the number of bytes sent might be less than we wanted.
       */
      else
      {
        conn->activity_time = alt_nticks();
 2001adc:	1007883a 	mov	r3,r2
 2001ae0:	e0bfff17 	ldw	r2,-4(fp)
 2001ae4:	10c00c15 	stw	r3,48(r2)
        chunk_sent += result;
 2001ae8:	e0fffa17 	ldw	r3,-24(fp)
 2001aec:	e0bffe17 	ldw	r2,-8(fp)
 2001af0:	1885883a 	add	r2,r3,r2
 2001af4:	e0bffa15 	stw	r2,-24(fp)
        conn->data_sent += result;
 2001af8:	e0bfff17 	ldw	r2,-4(fp)
 2001afc:	10c00917 	ldw	r3,36(r2)
 2001b00:	e0bffe17 	ldw	r2,-8(fp)
 2001b04:	1887883a 	add	r3,r3,r2
 2001b08:	e0bfff17 	ldw	r2,-4(fp)
 2001b0c:	10c00915 	stw	r3,36(r2)
        tx_ptr += result;
 2001b10:	e0bffe17 	ldw	r2,-8(fp)
 2001b14:	e0fffc17 	ldw	r3,-16(fp)
 2001b18:	1885883a 	add	r2,r3,r2
 2001b1c:	e0bffc15 	stw	r2,-16(fp)
        file_chunk_size -= result;
 2001b20:	e0fffb17 	ldw	r3,-20(fp)
 2001b24:	e0bffe17 	ldw	r2,-8(fp)
 2001b28:	1885c83a 	sub	r2,r3,r2
 2001b2c:	e0bffb15 	stw	r2,-20(fp)
      MIN(HTTP_TX_BUF_SIZE, (conn->file_length - conn->data_sent)), 
      conn->file_handle);
    
    tx_ptr = conn->tx_buffer;
    
    while(chunk_sent < file_chunk_size)
 2001b30:	e0fffa17 	ldw	r3,-24(fp)
 2001b34:	e0bffb17 	ldw	r2,-20(fp)
 2001b38:	18bfcd16 	blt	r3,r2,2001a70 <http_send_file_chunk+0x90>
  
  /* 
   * We managed to send all of the file contents to the IP stack successfully.
   * At this point we can mark our connection info as complete.
   */
  if(conn->data_sent >= conn->file_length)
 2001b3c:	e0bfff17 	ldw	r2,-4(fp)
 2001b40:	10c00917 	ldw	r3,36(r2)
 2001b44:	e0bfff17 	ldw	r2,-4(fp)
 2001b48:	10800817 	ldw	r2,32(r2)
 2001b4c:	18800316 	blt	r3,r2,2001b5c <http_send_file_chunk+0x17c>
  {
    conn->state = COMPLETE;
 2001b50:	e0bfff17 	ldw	r2,-4(fp)
 2001b54:	00c000c4 	movi	r3,3
 2001b58:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 2001b5c:	e0bffd17 	ldw	r2,-12(fp)
}
 2001b60:	e037883a 	mov	sp,fp
 2001b64:	dfc00117 	ldw	ra,4(sp)
 2001b68:	df000017 	ldw	fp,0(sp)
 2001b6c:	dec00204 	addi	sp,sp,8
 2001b70:	f800283a 	ret

02001b74 <http_send_file_header>:
 *
 * Construct and send an HTTP header describing the now-opened file that is
 * about to be sent to the client.
 */
int http_send_file_header(http_conn* conn, const char* name, int code)
{
 2001b74:	defff504 	addi	sp,sp,-44
 2001b78:	dfc00a15 	stw	ra,40(sp)
 2001b7c:	df000915 	stw	fp,36(sp)
 2001b80:	df000904 	addi	fp,sp,36
 2001b84:	e13ffd15 	stw	r4,-12(fp)
 2001b88:	e17ffe15 	stw	r5,-8(fp)
 2001b8c:	e1bfff15 	stw	r6,-4(fp)
  int     result = 0, ret_code = 0;
 2001b90:	e03ff815 	stw	zero,-32(fp)
 2001b94:	e03ff915 	stw	zero,-28(fp)
  char* tx_wr_pos = conn->tx_buffer;
 2001b98:	e0bffd17 	ldw	r2,-12(fp)
 2001b9c:	10801217 	ldw	r2,72(r2)
 2001ba0:	e0bff715 	stw	r2,-36(fp)
  fpos_t  end, start;
  const char* ext = strchr(name, '.');
 2001ba4:	e13ffe17 	ldw	r4,-8(fp)
 2001ba8:	01400b84 	movi	r5,46
 2001bac:	20073e00 	call	20073e0 <strchr>
 2001bb0:	e0bffa15 	stw	r2,-24(fp)

  tx_wr_pos += sprintf(tx_wr_pos, HTTP_VERSION_STRING);
 2001bb4:	e0bff717 	ldw	r2,-36(fp)
 2001bb8:	00c01204 	movi	r3,72
 2001bbc:	10c00005 	stb	r3,0(r2)
 2001bc0:	00c01504 	movi	r3,84
 2001bc4:	10c00045 	stb	r3,1(r2)
 2001bc8:	00c01504 	movi	r3,84
 2001bcc:	10c00085 	stb	r3,2(r2)
 2001bd0:	00c01404 	movi	r3,80
 2001bd4:	10c000c5 	stb	r3,3(r2)
 2001bd8:	00c00bc4 	movi	r3,47
 2001bdc:	10c00105 	stb	r3,4(r2)
 2001be0:	00c00c44 	movi	r3,49
 2001be4:	10c00145 	stb	r3,5(r2)
 2001be8:	00c00b84 	movi	r3,46
 2001bec:	10c00185 	stb	r3,6(r2)
 2001bf0:	00c00c44 	movi	r3,49
 2001bf4:	10c001c5 	stb	r3,7(r2)
 2001bf8:	00c00804 	movi	r3,32
 2001bfc:	10c00205 	stb	r3,8(r2)
 2001c00:	10000245 	stb	zero,9(r2)
 2001c04:	e0bff717 	ldw	r2,-36(fp)
 2001c08:	10800244 	addi	r2,r2,9
 2001c0c:	e0bff715 	stw	r2,-36(fp)

  switch(code)
 2001c10:	e0bfff17 	ldw	r2,-4(fp)
 2001c14:	10c03220 	cmpeqi	r3,r2,200
 2001c18:	1800031e 	bne	r3,zero,2001c28 <http_send_file_header+0xb4>
 2001c1c:	10806520 	cmpeqi	r2,r2,404
 2001c20:	1000171e 	bne	r2,zero,2001c80 <http_send_file_header+0x10c>
 2001c24:	00002306 	br	2001cb4 <http_send_file_header+0x140>
  {
    /* HTTP Code: "200 OK\r\n" (we have opened the file successfully) */
    case HTTP_OK:
    {
      tx_wr_pos += sprintf(tx_wr_pos, HTTP_OK_STRING);
 2001c28:	e0bff717 	ldw	r2,-36(fp)
 2001c2c:	00c00c84 	movi	r3,50
 2001c30:	10c00005 	stb	r3,0(r2)
 2001c34:	00c00c04 	movi	r3,48
 2001c38:	10c00045 	stb	r3,1(r2)
 2001c3c:	00c00c04 	movi	r3,48
 2001c40:	10c00085 	stb	r3,2(r2)
 2001c44:	00c00804 	movi	r3,32
 2001c48:	10c000c5 	stb	r3,3(r2)
 2001c4c:	00c013c4 	movi	r3,79
 2001c50:	10c00105 	stb	r3,4(r2)
 2001c54:	00c012c4 	movi	r3,75
 2001c58:	10c00145 	stb	r3,5(r2)
 2001c5c:	00c00344 	movi	r3,13
 2001c60:	10c00185 	stb	r3,6(r2)
 2001c64:	00c00284 	movi	r3,10
 2001c68:	10c001c5 	stb	r3,7(r2)
 2001c6c:	10000205 	stb	zero,8(r2)
 2001c70:	e0bff717 	ldw	r2,-36(fp)
 2001c74:	10800204 	addi	r2,r2,8
 2001c78:	e0bff715 	stw	r2,-36(fp)
      break;
 2001c7c:	00001b06 	br	2001cec <http_send_file_header+0x178>
    }
    /* HTTP Code: "404 Not Found\r\n" (couldn't find requested file) */
    case HTTP_NOT_FOUND:
    {
      tx_wr_pos += sprintf(tx_wr_pos, HTTP_NOT_FOUND_STRING);
 2001c80:	e0fff717 	ldw	r3,-36(fp)
 2001c84:	00808174 	movhi	r2,517
 2001c88:	10b30104 	addi	r2,r2,-13308
 2001c8c:	1809883a 	mov	r4,r3
 2001c90:	1007883a 	mov	r3,r2
 2001c94:	00800404 	movi	r2,16
 2001c98:	180b883a 	mov	r5,r3
 2001c9c:	100d883a 	mov	r6,r2
 2001ca0:	200660c0 	call	200660c <memcpy>
 2001ca4:	e0bff717 	ldw	r2,-36(fp)
 2001ca8:	108003c4 	addi	r2,r2,15
 2001cac:	e0bff715 	stw	r2,-36(fp)
      break;
 2001cb0:	00000e06 	br	2001cec <http_send_file_header+0x178>
    }
    default:
    {
      fprintf(stderr, "[http_send_file_header] Invalid HTTP code: %d\n", code);
 2001cb4:	00808174 	movhi	r2,517
 2001cb8:	10903604 	addi	r2,r2,16600
 2001cbc:	10800017 	ldw	r2,0(r2)
 2001cc0:	10800317 	ldw	r2,12(r2)
 2001cc4:	1009883a 	mov	r4,r2
 2001cc8:	01408174 	movhi	r5,517
 2001ccc:	29730504 	addi	r5,r5,-13292
 2001cd0:	e1bfff17 	ldw	r6,-4(fp)
 2001cd4:	2004ce80 	call	2004ce8 <fprintf>
      conn->state = RESET;
 2001cd8:	e0bffd17 	ldw	r2,-12(fp)
 2001cdc:	00c00104 	movi	r3,4
 2001ce0:	10c00015 	stw	r3,0(r2)
      return -1;
 2001ce4:	00bfffc4 	movi	r2,-1
 2001ce8:	00017506 	br	20022c0 <http_send_file_header+0x74c>
      break;
    }
  }

  /* Handle the various content types */
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE);
 2001cec:	e0fff717 	ldw	r3,-36(fp)
 2001cf0:	00808174 	movhi	r2,517
 2001cf4:	10b31104 	addi	r2,r2,-13244
 2001cf8:	1809883a 	mov	r4,r3
 2001cfc:	1007883a 	mov	r3,r2
 2001d00:	008003c4 	movi	r2,15
 2001d04:	180b883a 	mov	r5,r3
 2001d08:	100d883a 	mov	r6,r2
 2001d0c:	200660c0 	call	200660c <memcpy>
 2001d10:	e0bff717 	ldw	r2,-36(fp)
 2001d14:	10800384 	addi	r2,r2,14
 2001d18:	e0bff715 	stw	r2,-36(fp)

  if (!strcasecmp(ext, ".html"))
 2001d1c:	e13ffa17 	ldw	r4,-24(fp)
 2001d20:	01408174 	movhi	r5,517
 2001d24:	29731504 	addi	r5,r5,-13228
 2001d28:	20072940 	call	2007294 <strcasecmp>
 2001d2c:	10001c1e 	bne	r2,zero,2001da0 <http_send_file_header+0x22c>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_HTML);
 2001d30:	e0bff717 	ldw	r2,-36(fp)
 2001d34:	00c01d04 	movi	r3,116
 2001d38:	10c00005 	stb	r3,0(r2)
 2001d3c:	00c01944 	movi	r3,101
 2001d40:	10c00045 	stb	r3,1(r2)
 2001d44:	00c01e04 	movi	r3,120
 2001d48:	10c00085 	stb	r3,2(r2)
 2001d4c:	00c01d04 	movi	r3,116
 2001d50:	10c000c5 	stb	r3,3(r2)
 2001d54:	00c00bc4 	movi	r3,47
 2001d58:	10c00105 	stb	r3,4(r2)
 2001d5c:	00c01a04 	movi	r3,104
 2001d60:	10c00145 	stb	r3,5(r2)
 2001d64:	00c01d04 	movi	r3,116
 2001d68:	10c00185 	stb	r3,6(r2)
 2001d6c:	00c01b44 	movi	r3,109
 2001d70:	10c001c5 	stb	r3,7(r2)
 2001d74:	00c01b04 	movi	r3,108
 2001d78:	10c00205 	stb	r3,8(r2)
 2001d7c:	00c00344 	movi	r3,13
 2001d80:	10c00245 	stb	r3,9(r2)
 2001d84:	00c00284 	movi	r3,10
 2001d88:	10c00285 	stb	r3,10(r2)
 2001d8c:	100002c5 	stb	zero,11(r2)
 2001d90:	e0bff717 	ldw	r2,-36(fp)
 2001d94:	108002c4 	addi	r2,r2,11
 2001d98:	e0bff715 	stw	r2,-36(fp)
 2001d9c:	0000c606 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".jpg"))
 2001da0:	e13ffa17 	ldw	r4,-24(fp)
 2001da4:	01408174 	movhi	r5,517
 2001da8:	29731704 	addi	r5,r5,-13220
 2001dac:	20072940 	call	2007294 <strcasecmp>
 2001db0:	10001c1e 	bne	r2,zero,2001e24 <http_send_file_header+0x2b0>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_JPG);
 2001db4:	e0bff717 	ldw	r2,-36(fp)
 2001db8:	00c01a44 	movi	r3,105
 2001dbc:	10c00005 	stb	r3,0(r2)
 2001dc0:	00c01b44 	movi	r3,109
 2001dc4:	10c00045 	stb	r3,1(r2)
 2001dc8:	00c01844 	movi	r3,97
 2001dcc:	10c00085 	stb	r3,2(r2)
 2001dd0:	00c019c4 	movi	r3,103
 2001dd4:	10c000c5 	stb	r3,3(r2)
 2001dd8:	00c01944 	movi	r3,101
 2001ddc:	10c00105 	stb	r3,4(r2)
 2001de0:	00c00bc4 	movi	r3,47
 2001de4:	10c00145 	stb	r3,5(r2)
 2001de8:	00c01a84 	movi	r3,106
 2001dec:	10c00185 	stb	r3,6(r2)
 2001df0:	00c01c04 	movi	r3,112
 2001df4:	10c001c5 	stb	r3,7(r2)
 2001df8:	00c019c4 	movi	r3,103
 2001dfc:	10c00205 	stb	r3,8(r2)
 2001e00:	00c00344 	movi	r3,13
 2001e04:	10c00245 	stb	r3,9(r2)
 2001e08:	00c00284 	movi	r3,10
 2001e0c:	10c00285 	stb	r3,10(r2)
 2001e10:	100002c5 	stb	zero,11(r2)
 2001e14:	e0bff717 	ldw	r2,-36(fp)
 2001e18:	108002c4 	addi	r2,r2,11
 2001e1c:	e0bff715 	stw	r2,-36(fp)
 2001e20:	0000a506 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".gif"))
 2001e24:	e13ffa17 	ldw	r4,-24(fp)
 2001e28:	01408174 	movhi	r5,517
 2001e2c:	29731904 	addi	r5,r5,-13212
 2001e30:	20072940 	call	2007294 <strcasecmp>
 2001e34:	10001c1e 	bne	r2,zero,2001ea8 <http_send_file_header+0x334>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_GIF);
 2001e38:	e0bff717 	ldw	r2,-36(fp)
 2001e3c:	00c01a44 	movi	r3,105
 2001e40:	10c00005 	stb	r3,0(r2)
 2001e44:	00c01b44 	movi	r3,109
 2001e48:	10c00045 	stb	r3,1(r2)
 2001e4c:	00c01844 	movi	r3,97
 2001e50:	10c00085 	stb	r3,2(r2)
 2001e54:	00c019c4 	movi	r3,103
 2001e58:	10c000c5 	stb	r3,3(r2)
 2001e5c:	00c01944 	movi	r3,101
 2001e60:	10c00105 	stb	r3,4(r2)
 2001e64:	00c00bc4 	movi	r3,47
 2001e68:	10c00145 	stb	r3,5(r2)
 2001e6c:	00c019c4 	movi	r3,103
 2001e70:	10c00185 	stb	r3,6(r2)
 2001e74:	00c01a44 	movi	r3,105
 2001e78:	10c001c5 	stb	r3,7(r2)
 2001e7c:	00c01984 	movi	r3,102
 2001e80:	10c00205 	stb	r3,8(r2)
 2001e84:	00c00344 	movi	r3,13
 2001e88:	10c00245 	stb	r3,9(r2)
 2001e8c:	00c00284 	movi	r3,10
 2001e90:	10c00285 	stb	r3,10(r2)
 2001e94:	100002c5 	stb	zero,11(r2)
 2001e98:	e0bff717 	ldw	r2,-36(fp)
 2001e9c:	108002c4 	addi	r2,r2,11
 2001ea0:	e0bff715 	stw	r2,-36(fp)
 2001ea4:	00008406 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".png"))
 2001ea8:	e13ffa17 	ldw	r4,-24(fp)
 2001eac:	01408174 	movhi	r5,517
 2001eb0:	29731b04 	addi	r5,r5,-13204
 2001eb4:	20072940 	call	2007294 <strcasecmp>
 2001eb8:	10001c1e 	bne	r2,zero,2001f2c <http_send_file_header+0x3b8>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_PNG);
 2001ebc:	e0bff717 	ldw	r2,-36(fp)
 2001ec0:	00c01a44 	movi	r3,105
 2001ec4:	10c00005 	stb	r3,0(r2)
 2001ec8:	00c01b44 	movi	r3,109
 2001ecc:	10c00045 	stb	r3,1(r2)
 2001ed0:	00c01844 	movi	r3,97
 2001ed4:	10c00085 	stb	r3,2(r2)
 2001ed8:	00c019c4 	movi	r3,103
 2001edc:	10c000c5 	stb	r3,3(r2)
 2001ee0:	00c01944 	movi	r3,101
 2001ee4:	10c00105 	stb	r3,4(r2)
 2001ee8:	00c00bc4 	movi	r3,47
 2001eec:	10c00145 	stb	r3,5(r2)
 2001ef0:	00c01c04 	movi	r3,112
 2001ef4:	10c00185 	stb	r3,6(r2)
 2001ef8:	00c01b84 	movi	r3,110
 2001efc:	10c001c5 	stb	r3,7(r2)
 2001f00:	00c019c4 	movi	r3,103
 2001f04:	10c00205 	stb	r3,8(r2)
 2001f08:	00c00344 	movi	r3,13
 2001f0c:	10c00245 	stb	r3,9(r2)
 2001f10:	00c00284 	movi	r3,10
 2001f14:	10c00285 	stb	r3,10(r2)
 2001f18:	100002c5 	stb	zero,11(r2)
 2001f1c:	e0bff717 	ldw	r2,-36(fp)
 2001f20:	108002c4 	addi	r2,r2,11
 2001f24:	e0bff715 	stw	r2,-36(fp)
 2001f28:	00006306 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".js"))
 2001f2c:	e13ffa17 	ldw	r4,-24(fp)
 2001f30:	01408174 	movhi	r5,517
 2001f34:	29731d04 	addi	r5,r5,-13196
 2001f38:	20072940 	call	2007294 <strcasecmp>
 2001f3c:	10000d1e 	bne	r2,zero,2001f74 <http_send_file_header+0x400>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_JS);
 2001f40:	e0fff717 	ldw	r3,-36(fp)
 2001f44:	00808174 	movhi	r2,517
 2001f48:	10b31e04 	addi	r2,r2,-13192
 2001f4c:	1809883a 	mov	r4,r3
 2001f50:	1007883a 	mov	r3,r2
 2001f54:	008006c4 	movi	r2,27
 2001f58:	180b883a 	mov	r5,r3
 2001f5c:	100d883a 	mov	r6,r2
 2001f60:	200660c0 	call	200660c <memcpy>
 2001f64:	e0bff717 	ldw	r2,-36(fp)
 2001f68:	10800684 	addi	r2,r2,26
 2001f6c:	e0bff715 	stw	r2,-36(fp)
 2001f70:	00005106 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".css"))
 2001f74:	e13ffa17 	ldw	r4,-24(fp)
 2001f78:	01408174 	movhi	r5,517
 2001f7c:	29732504 	addi	r5,r5,-13164
 2001f80:	20072940 	call	2007294 <strcasecmp>
 2001f84:	10001a1e 	bne	r2,zero,2001ff0 <http_send_file_header+0x47c>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_CSS);
 2001f88:	e0bff717 	ldw	r2,-36(fp)
 2001f8c:	00c01d04 	movi	r3,116
 2001f90:	10c00005 	stb	r3,0(r2)
 2001f94:	00c01944 	movi	r3,101
 2001f98:	10c00045 	stb	r3,1(r2)
 2001f9c:	00c01e04 	movi	r3,120
 2001fa0:	10c00085 	stb	r3,2(r2)
 2001fa4:	00c01d04 	movi	r3,116
 2001fa8:	10c000c5 	stb	r3,3(r2)
 2001fac:	00c00bc4 	movi	r3,47
 2001fb0:	10c00105 	stb	r3,4(r2)
 2001fb4:	00c018c4 	movi	r3,99
 2001fb8:	10c00145 	stb	r3,5(r2)
 2001fbc:	00c01cc4 	movi	r3,115
 2001fc0:	10c00185 	stb	r3,6(r2)
 2001fc4:	00c01cc4 	movi	r3,115
 2001fc8:	10c001c5 	stb	r3,7(r2)
 2001fcc:	00c00344 	movi	r3,13
 2001fd0:	10c00205 	stb	r3,8(r2)
 2001fd4:	00c00284 	movi	r3,10
 2001fd8:	10c00245 	stb	r3,9(r2)
 2001fdc:	10000285 	stb	zero,10(r2)
 2001fe0:	e0bff717 	ldw	r2,-36(fp)
 2001fe4:	10800284 	addi	r2,r2,10
 2001fe8:	e0bff715 	stw	r2,-36(fp)
 2001fec:	00003206 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".swf"))
 2001ff0:	e13ffa17 	ldw	r4,-24(fp)
 2001ff4:	01408174 	movhi	r5,517
 2001ff8:	29732704 	addi	r5,r5,-13156
 2001ffc:	20072940 	call	2007294 <strcasecmp>
 2002000:	10000d1e 	bne	r2,zero,2002038 <http_send_file_header+0x4c4>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_SWF);
 2002004:	e0fff717 	ldw	r3,-36(fp)
 2002008:	00808174 	movhi	r2,517
 200200c:	10b32904 	addi	r2,r2,-13148
 2002010:	1809883a 	mov	r4,r3
 2002014:	1007883a 	mov	r3,r2
 2002018:	00800804 	movi	r2,32
 200201c:	180b883a 	mov	r5,r3
 2002020:	100d883a 	mov	r6,r2
 2002024:	200660c0 	call	200660c <memcpy>
 2002028:	e0bff717 	ldw	r2,-36(fp)
 200202c:	108007c4 	addi	r2,r2,31
 2002030:	e0bff715 	stw	r2,-36(fp)
 2002034:	00002006 	br	20020b8 <http_send_file_header+0x544>
  }
  else if (!strcasecmp(ext, ".ico"))
 2002038:	e13ffa17 	ldw	r4,-24(fp)
 200203c:	01408174 	movhi	r5,517
 2002040:	29733104 	addi	r5,r5,-13116
 2002044:	20072940 	call	2007294 <strcasecmp>
 2002048:	10000d1e 	bne	r2,zero,2002080 <http_send_file_header+0x50c>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_TYPE_ICO);
 200204c:	e0fff717 	ldw	r3,-36(fp)
 2002050:	00808174 	movhi	r2,517
 2002054:	10b33304 	addi	r2,r2,-13108
 2002058:	1809883a 	mov	r4,r3
 200205c:	1007883a 	mov	r3,r2
 2002060:	008006c4 	movi	r2,27
 2002064:	180b883a 	mov	r5,r3
 2002068:	100d883a 	mov	r6,r2
 200206c:	200660c0 	call	200660c <memcpy>
 2002070:	e0bff717 	ldw	r2,-36(fp)
 2002074:	10800684 	addi	r2,r2,26
 2002078:	e0bff715 	stw	r2,-36(fp)
 200207c:	00000e06 	br	20020b8 <http_send_file_header+0x544>
  }
  else
  {
    fprintf(stderr, "[http_send_file] Unknown content type: \"%s\"\n", ext);
 2002080:	00808174 	movhi	r2,517
 2002084:	10903604 	addi	r2,r2,16600
 2002088:	10800017 	ldw	r2,0(r2)
 200208c:	10800317 	ldw	r2,12(r2)
 2002090:	1009883a 	mov	r4,r2
 2002094:	01408174 	movhi	r5,517
 2002098:	29733a04 	addi	r5,r5,-13080
 200209c:	e1bffa17 	ldw	r6,-24(fp)
 20020a0:	2004ce80 	call	2004ce8 <fprintf>
    conn->state = RESET;
 20020a4:	e0bffd17 	ldw	r2,-12(fp)
 20020a8:	00c00104 	movi	r3,4
 20020ac:	10c00015 	stw	r3,0(r2)
    ALT_DEBUG_ASSERT(1);
    return -1;
 20020b0:	00bfffc4 	movi	r2,-1
 20020b4:	00008206 	br	20022c0 <http_send_file_header+0x74c>
  }

  /* Get the file length and stash it into our connection info */
  fseek(conn->file_handle, 0, SEEK_END);
 20020b8:	e0bffd17 	ldw	r2,-12(fp)
 20020bc:	10800b17 	ldw	r2,44(r2)
 20020c0:	1009883a 	mov	r4,r2
 20020c4:	000b883a 	mov	r5,zero
 20020c8:	01800084 	movi	r6,2
 20020cc:	20057f80 	call	20057f8 <fseek>
  fgetpos(conn->file_handle, &end);
 20020d0:	e0bffd17 	ldw	r2,-12(fp)
 20020d4:	10c00b17 	ldw	r3,44(r2)
 20020d8:	e0bffb04 	addi	r2,fp,-20
 20020dc:	1809883a 	mov	r4,r3
 20020e0:	100b883a 	mov	r5,r2
 20020e4:	20048800 	call	2004880 <fgetpos>
  fseek(conn->file_handle, 0, SEEK_SET);
 20020e8:	e0bffd17 	ldw	r2,-12(fp)
 20020ec:	10800b17 	ldw	r2,44(r2)
 20020f0:	1009883a 	mov	r4,r2
 20020f4:	000b883a 	mov	r5,zero
 20020f8:	000d883a 	mov	r6,zero
 20020fc:	20057f80 	call	20057f8 <fseek>
  fgetpos(conn->file_handle, &start);
 2002100:	e0bffd17 	ldw	r2,-12(fp)
 2002104:	10c00b17 	ldw	r3,44(r2)
 2002108:	e0bffc04 	addi	r2,fp,-16
 200210c:	1809883a 	mov	r4,r3
 2002110:	100b883a 	mov	r5,r2
 2002114:	20048800 	call	2004880 <fgetpos>
  conn->file_length = end - start;
 2002118:	e0fffb17 	ldw	r3,-20(fp)
 200211c:	e0bffc17 	ldw	r2,-16(fp)
 2002120:	1887c83a 	sub	r3,r3,r2
 2002124:	e0bffd17 	ldw	r2,-12(fp)
 2002128:	10c00815 	stw	r3,32(r2)

  /* "Content-Length: <length bytes>\r\n" */
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_CONTENT_LENGTH);
 200212c:	e0fff717 	ldw	r3,-36(fp)
 2002130:	00808174 	movhi	r2,517
 2002134:	10b34604 	addi	r2,r2,-13032
 2002138:	1809883a 	mov	r4,r3
 200213c:	1007883a 	mov	r3,r2
 2002140:	00800444 	movi	r2,17
 2002144:	180b883a 	mov	r5,r3
 2002148:	100d883a 	mov	r6,r2
 200214c:	200660c0 	call	200660c <memcpy>
 2002150:	e0bff717 	ldw	r2,-36(fp)
 2002154:	10800404 	addi	r2,r2,16
 2002158:	e0bff715 	stw	r2,-36(fp)
  tx_wr_pos += sprintf(tx_wr_pos, "%d\r\n", conn->file_length);
 200215c:	e0bffd17 	ldw	r2,-12(fp)
 2002160:	10800817 	ldw	r2,32(r2)
 2002164:	e13ff717 	ldw	r4,-36(fp)
 2002168:	01408174 	movhi	r5,517
 200216c:	29734b04 	addi	r5,r5,-13012
 2002170:	100d883a 	mov	r6,r2
 2002174:	2006fec0 	call	2006fec <sprintf>
 2002178:	e0fff717 	ldw	r3,-36(fp)
 200217c:	1885883a 	add	r2,r3,r2
 2002180:	e0bff715 	stw	r2,-36(fp)
   * 
   * We send a specified number of files in a single keep-alive connection,
   * we'll also close the connection. It's best to be polite and tell the client,
   * though.
   */
  if(!conn->keep_alive_count)
 2002184:	e0bffd17 	ldw	r2,-12(fp)
 2002188:	10800717 	ldw	r2,28(r2)
 200218c:	1000031e 	bne	r2,zero,200219c <http_send_file_header+0x628>
  {
    conn->close = 1;
 2002190:	e0bffd17 	ldw	r2,-12(fp)
 2002194:	00c00044 	movi	r3,1
 2002198:	10c00415 	stw	r3,16(r2)
  }
  
  if(conn->close)
 200219c:	e0bffd17 	ldw	r2,-12(fp)
 20021a0:	10800417 	ldw	r2,16(r2)
 20021a4:	10000d26 	beq	r2,zero,20021dc <http_send_file_header+0x668>
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_CLOSE);
 20021a8:	e0fff717 	ldw	r3,-36(fp)
 20021ac:	00808174 	movhi	r2,517
 20021b0:	10b34d04 	addi	r2,r2,-13004
 20021b4:	1809883a 	mov	r4,r3
 20021b8:	1007883a 	mov	r3,r2
 20021bc:	00800504 	movi	r2,20
 20021c0:	180b883a 	mov	r5,r3
 20021c4:	100d883a 	mov	r6,r2
 20021c8:	200660c0 	call	200660c <memcpy>
 20021cc:	e0bff717 	ldw	r2,-36(fp)
 20021d0:	108004c4 	addi	r2,r2,19
 20021d4:	e0bff715 	stw	r2,-36(fp)
 20021d8:	00000c06 	br	200220c <http_send_file_header+0x698>
  }
  else
  {
    tx_wr_pos += sprintf(tx_wr_pos, HTTP_KEEP_ALIVE);
 20021dc:	e0fff717 	ldw	r3,-36(fp)
 20021e0:	00808174 	movhi	r2,517
 20021e4:	10b35204 	addi	r2,r2,-12984
 20021e8:	1809883a 	mov	r4,r3
 20021ec:	1007883a 	mov	r3,r2
 20021f0:	00800644 	movi	r2,25
 20021f4:	180b883a 	mov	r5,r3
 20021f8:	100d883a 	mov	r6,r2
 20021fc:	200660c0 	call	200660c <memcpy>
 2002200:	e0bff717 	ldw	r2,-36(fp)
 2002204:	10800604 	addi	r2,r2,24
 2002208:	e0bff715 	stw	r2,-36(fp)
  }

  /* "\r\n" (two \r\n's in a row means end of headers */
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_CR_LF);
 200220c:	e0bff717 	ldw	r2,-36(fp)
 2002210:	00c00344 	movi	r3,13
 2002214:	10c00005 	stb	r3,0(r2)
 2002218:	00c00284 	movi	r3,10
 200221c:	10c00045 	stb	r3,1(r2)
 2002220:	10000085 	stb	zero,2(r2)
 2002224:	e0bff717 	ldw	r2,-36(fp)
 2002228:	10800084 	addi	r2,r2,2
 200222c:	e0bff715 	stw	r2,-36(fp)

  /* Send the reply header */
  result = send(conn->fd, conn->tx_buffer, (tx_wr_pos - conn->tx_buffer), 
 2002230:	e0bffd17 	ldw	r2,-12(fp)
 2002234:	11000317 	ldw	r4,12(r2)
 2002238:	e0bffd17 	ldw	r2,-12(fp)
 200223c:	10c01217 	ldw	r3,72(r2)
 2002240:	e17ff717 	ldw	r5,-36(fp)
 2002244:	e0bffd17 	ldw	r2,-12(fp)
 2002248:	10801217 	ldw	r2,72(r2)
 200224c:	2885c83a 	sub	r2,r5,r2
 2002250:	180b883a 	mov	r5,r3
 2002254:	100d883a 	mov	r6,r2
 2002258:	000f883a 	mov	r7,zero
 200225c:	202c5d80 	call	202c5d8 <t_send>
 2002260:	e0bff815 	stw	r2,-32(fp)
                0);  
                
  if(result < 0)
 2002264:	e0bff817 	ldw	r2,-32(fp)
 2002268:	10000e0e 	bge	r2,zero,20022a4 <http_send_file_header+0x730>
  {
    fprintf(stderr, "[http_send_file] header send returned %d\n", result);
 200226c:	00808174 	movhi	r2,517
 2002270:	10903604 	addi	r2,r2,16600
 2002274:	10800017 	ldw	r2,0(r2)
 2002278:	10800317 	ldw	r2,12(r2)
 200227c:	1009883a 	mov	r4,r2
 2002280:	01408174 	movhi	r5,517
 2002284:	29735904 	addi	r5,r5,-12956
 2002288:	e1bff817 	ldw	r6,-32(fp)
 200228c:	2004ce80 	call	2004ce8 <fprintf>
    conn->state = RESET;
 2002290:	e0bffd17 	ldw	r2,-12(fp)
 2002294:	00c00104 	movi	r3,4
 2002298:	10c00015 	stw	r3,0(r2)
    return result;
 200229c:	e0bff817 	ldw	r2,-32(fp)
 20022a0:	00000706 	br	20022c0 <http_send_file_header+0x74c>
 20022a4:	00808174 	movhi	r2,517
 20022a8:	10909604 	addi	r2,r2,16984
 20022ac:	10800017 	ldw	r2,0(r2)
  }
  else
  {
    conn->activity_time = alt_nticks();
 20022b0:	1007883a 	mov	r3,r2
 20022b4:	e0bffd17 	ldw	r2,-12(fp)
 20022b8:	10c00c15 	stw	r3,48(r2)
  }
  
  return ret_code;
 20022bc:	e0bff917 	ldw	r2,-28(fp)
}
 20022c0:	e037883a 	mov	sp,fp
 20022c4:	dfc00117 	ldw	ra,4(sp)
 20022c8:	df000017 	ldw	fp,0(sp)
 20022cc:	dec00204 	addi	sp,sp,8
 20022d0:	f800283a 	ret

020022d4 <http_find_file>:
 *
 * Try to find the file requested. If nothing is requested you get /index.html
 * If we can't find it, send a "404 - Not found" message.
 */
int http_find_file(http_conn* conn)
{
 20022d4:	deffbc04 	addi	sp,sp,-272
 20022d8:	dfc04315 	stw	ra,268(sp)
 20022dc:	df004215 	stw	fp,264(sp)
 20022e0:	df004204 	addi	fp,sp,264
 20022e4:	e13fff15 	stw	r4,-4(fp)
  char  filename[256];
  int     ret_code = 0;
 20022e8:	e03fbe15 	stw	zero,-264(fp)

  strncpy( filename, ALTERA_RO_ZIPFS_NAME, strlen(ALTERA_RO_ZIPFS_NAME));
 20022ec:	e0bfbf04 	addi	r2,fp,-260
 20022f0:	00dd1bb4 	movhi	r3,29806
 20022f4:	18db4bc4 	addi	r3,r3,27951
 20022f8:	10c00015 	stw	r3,0(r2)
 20022fc:	00de9bf4 	movhi	r3,31343
 2002300:	18dc8bc4 	addi	r3,r3,29231
 2002304:	10c00115 	stw	r3,4(r2)
 2002308:	00dcd9b4 	movhi	r3,29542
 200230c:	18dc1a44 	addi	r3,r3,28777
 2002310:	10c00215 	stw	r3,8(r2)

  /* URI of "/" means get the default, usually index.html */
  if ( (conn->uri[0] == '/') && (conn->uri[1] == '\0') )
 2002314:	e0bfff17 	ldw	r2,-4(fp)
 2002318:	10807603 	ldbu	r2,472(r2)
 200231c:	10803fcc 	andi	r2,r2,255
 2002320:	1080201c 	xori	r2,r2,128
 2002324:	10bfe004 	addi	r2,r2,-128
 2002328:	10800bd8 	cmpnei	r2,r2,47
 200232c:	1000121e 	bne	r2,zero,2002378 <http_find_file+0xa4>
 2002330:	e0bfff17 	ldw	r2,-4(fp)
 2002334:	10807643 	ldbu	r2,473(r2)
 2002338:	10803fcc 	andi	r2,r2,255
 200233c:	1080201c 	xori	r2,r2,128
 2002340:	10bfe004 	addi	r2,r2,-128
 2002344:	10000c1e 	bne	r2,zero,2002378 <http_find_file+0xa4>
  {
    strcpy(filename+strlen(ALTERA_RO_ZIPFS_NAME), HTTP_DEFAULT_FILE);
 2002348:	e0bfbf04 	addi	r2,fp,-260
 200234c:	10800304 	addi	r2,r2,12
 2002350:	00d91bb4 	movhi	r3,25710
 2002354:	18da4bc4 	addi	r3,r3,26927
 2002358:	10c00015 	stw	r3,0(r2)
 200235c:	00da0bb4 	movhi	r3,26670
 2002360:	18de1944 	addi	r3,r3,30821
 2002364:	10c00115 	stw	r3,4(r2)
 2002368:	00c01b34 	movhi	r3,108
 200236c:	18db5d04 	addi	r3,r3,28020
 2002370:	10c00215 	stw	r3,8(r2)
 2002374:	00000706 	br	2002394 <http_find_file+0xc0>
  }
  else
  {
    strcpy( filename+strlen(ALTERA_RO_ZIPFS_NAME), conn->uri);
 2002378:	e0bfff17 	ldw	r2,-4(fp)
 200237c:	10807604 	addi	r2,r2,472
 2002380:	e0ffbf04 	addi	r3,fp,-260
 2002384:	18c00304 	addi	r3,r3,12
 2002388:	1809883a 	mov	r4,r3
 200238c:	100b883a 	mov	r5,r2
 2002390:	200756c0 	call	200756c <strcpy>
  }
  
  /* Try to open the file */
  printf("\nFetching file:  %s.\n", filename );
 2002394:	e0bfbf04 	addi	r2,fp,-260
 2002398:	01008174 	movhi	r4,517
 200239c:	21336404 	addi	r4,r4,-12912
 20023a0:	100b883a 	mov	r5,r2
 20023a4:	2006a240 	call	2006a24 <printf>
  conn->file_handle = fopen(filename, "r");
 20023a8:	e0bfbf04 	addi	r2,fp,-260
 20023ac:	1009883a 	mov	r4,r2
 20023b0:	01408174 	movhi	r5,517
 20023b4:	29736a04 	addi	r5,r5,-12888
 20023b8:	2004ca40 	call	2004ca4 <fopen>
 20023bc:	e0ffff17 	ldw	r3,-4(fp)
 20023c0:	18800b15 	stw	r2,44(r3)
  
  /* Can't find the requested file? Try for a 404-page. */
  if (conn->file_handle == NULL)
 20023c4:	e0bfff17 	ldw	r2,-4(fp)
 20023c8:	10800b17 	ldw	r2,44(r2)
 20023cc:	10004f1e 	bne	r2,zero,200250c <http_find_file+0x238>
  {
    strcpy(filename, ALTERA_RO_ZIPFS_NAME);
 20023d0:	e0bfbf04 	addi	r2,fp,-260
 20023d4:	00dd1bb4 	movhi	r3,29806
 20023d8:	18db4bc4 	addi	r3,r3,27951
 20023dc:	10c00015 	stw	r3,0(r2)
 20023e0:	00de9bf4 	movhi	r3,31343
 20023e4:	18dc8bc4 	addi	r3,r3,29231
 20023e8:	10c00115 	stw	r3,4(r2)
 20023ec:	00dcd9b4 	movhi	r3,29542
 20023f0:	18dc1a44 	addi	r3,r3,28777
 20023f4:	10c00215 	stw	r3,8(r2)
 20023f8:	10000305 	stb	zero,12(r2)
    strcpy(filename+strlen(ALTERA_RO_ZIPFS_NAME), HTTP_NOT_FOUND_FILE);
 20023fc:	e0bfbf04 	addi	r2,fp,-260
 2002400:	10800304 	addi	r2,r2,12
 2002404:	00dd1bf4 	movhi	r3,29807
 2002408:	18db8bc4 	addi	r3,r3,28207
 200240c:	10c00015 	stw	r3,0(r2)
 2002410:	00dd5bf4 	movhi	r3,30063
 2002414:	18d997c4 	addi	r3,r3,26207
 2002418:	10c00115 	stw	r3,4(r2)
 200241c:	00da0bb4 	movhi	r3,26670
 2002420:	18d91b84 	addi	r3,r3,25710
 2002424:	10c00215 	stw	r3,8(r2)
 2002428:	00c01b34 	movhi	r3,108
 200242c:	18db5d04 	addi	r3,r3,28020
 2002430:	10c00315 	stw	r3,12(r2)
    conn->file_handle = fopen(filename, "r");
 2002434:	e0bfbf04 	addi	r2,fp,-260
 2002438:	1009883a 	mov	r4,r2
 200243c:	01408174 	movhi	r5,517
 2002440:	29736a04 	addi	r5,r5,-12888
 2002444:	2004ca40 	call	2004ca4 <fopen>
 2002448:	e0ffff17 	ldw	r3,-4(fp)
 200244c:	18800b15 	stw	r2,44(r3)
    
    /* We located the specified "404: Not-Found" page */
    if (conn->file_handle != NULL)
 2002450:	e0bfff17 	ldw	r2,-4(fp)
 2002454:	10800b17 	ldw	r2,44(r2)
 2002458:	10000726 	beq	r2,zero,2002478 <http_find_file+0x1a4>
    {
      ALT_DEBUG_ASSERT(fd != NULL);
      ret_code = http_send_file_header(conn, filename, HTTP_NOT_FOUND);
 200245c:	e0bfbf04 	addi	r2,fp,-260
 2002460:	e13fff17 	ldw	r4,-4(fp)
 2002464:	100b883a 	mov	r5,r2
 2002468:	01806504 	movi	r6,404
 200246c:	2001b740 	call	2001b74 <http_send_file_header>
 2002470:	e0bfbe15 	stw	r2,-264(fp)
 2002474:	00002b06 	br	2002524 <http_find_file+0x250>
    }
    /* Can't find the 404 page: This likely means there is no file system */
    else
    {
      fprintf(stderr, "Can't open the 404 File Not Found error page.\n");
 2002478:	00808174 	movhi	r2,517
 200247c:	10903604 	addi	r2,r2,16600
 2002480:	10800017 	ldw	r2,0(r2)
 2002484:	10800317 	ldw	r2,12(r2)
 2002488:	01008174 	movhi	r4,517
 200248c:	21336b04 	addi	r4,r4,-12884
 2002490:	01400044 	movi	r5,1
 2002494:	01800b84 	movi	r6,46
 2002498:	100f883a 	mov	r7,r2
 200249c:	2005ba80 	call	2005ba8 <fwrite>
      fprintf(stderr, "Have you programmed the filing system into flash?\n");
 20024a0:	00808174 	movhi	r2,517
 20024a4:	10903604 	addi	r2,r2,16600
 20024a8:	10800017 	ldw	r2,0(r2)
 20024ac:	10800317 	ldw	r2,12(r2)
 20024b0:	01008174 	movhi	r4,517
 20024b4:	21337704 	addi	r4,r4,-12836
 20024b8:	01400044 	movi	r5,1
 20024bc:	01800c84 	movi	r6,50
 20024c0:	100f883a 	mov	r7,r2
 20024c4:	2005ba80 	call	2005ba8 <fwrite>
      send(conn->fd,(void*)canned_http_response,strlen(canned_http_response),0);
 20024c8:	e0bfff17 	ldw	r2,-4(fp)
 20024cc:	10800317 	ldw	r2,12(r2)
 20024d0:	1009883a 	mov	r4,r2
 20024d4:	01408174 	movhi	r5,517
 20024d8:	2971df04 	addi	r5,r5,-14468
 20024dc:	01805784 	movi	r6,350
 20024e0:	000f883a 	mov	r7,zero
 20024e4:	202c5d80 	call	202c5d8 <t_send>
      
      fclose(conn->file_handle);
 20024e8:	e0bfff17 	ldw	r2,-4(fp)
 20024ec:	10800b17 	ldw	r2,44(r2)
 20024f0:	1009883a 	mov	r4,r2
 20024f4:	20046280 	call	2004628 <fclose>
      conn->state = RESET;
 20024f8:	e0bfff17 	ldw	r2,-4(fp)
 20024fc:	00c00104 	movi	r3,4
 2002500:	10c00015 	stw	r3,0(r2)
      return -1;  
 2002504:	00bfffc4 	movi	r2,-1
 2002508:	00000706 	br	2002528 <http_find_file+0x254>
    }
  }
  /* We've found the requested file; send its header and move on. */  
  else
  {
    ret_code = http_send_file_header(conn, filename, HTTP_OK);
 200250c:	e0bfbf04 	addi	r2,fp,-260
 2002510:	e13fff17 	ldw	r4,-4(fp)
 2002514:	100b883a 	mov	r5,r2
 2002518:	01803204 	movi	r6,200
 200251c:	2001b740 	call	2001b74 <http_send_file_header>
 2002520:	e0bfbe15 	stw	r2,-264(fp)
  }

  return ret_code;
 2002524:	e0bfbe17 	ldw	r2,-264(fp)
}
 2002528:	e037883a 	mov	sp,fp
 200252c:	dfc00117 	ldw	ra,4(sp)
 2002530:	df000017 	ldw	fp,0(sp)
 2002534:	dec00204 	addi	sp,sp,8
 2002538:	f800283a 	ret

0200253c <http_send_redirect>:
 * This function sends re-directs to either program_flash.html or
 * reset_sytem.html.
 */

void http_send_redirect( alt_u8 redirect[256] )
{
 200253c:	defffd04 	addi	sp,sp,-12
 2002540:	dfc00215 	stw	ra,8(sp)
 2002544:	df000115 	stw	fp,4(sp)
 2002548:	df000104 	addi	fp,sp,4
 200254c:	e13fff15 	stw	r4,-4(fp)
  printf ("Don't do anything....for now.\n");
 2002550:	01008174 	movhi	r4,517
 2002554:	21338404 	addi	r4,r4,-12784
 2002558:	2006cb40 	call	2006cb4 <puts>
}
 200255c:	e037883a 	mov	sp,fp
 2002560:	dfc00117 	ldw	ra,4(sp)
 2002564:	df000017 	ldw	fp,0(sp)
 2002568:	dec00204 	addi	sp,sp,8
 200256c:	f800283a 	ret

02002570 <http_handle_post>:
 * http_handle_post()
 *
 * Process the post request and take the appropriate action.
 */
int http_handle_post(http_conn* conn)
{
 2002570:	defffa04 	addi	sp,sp,-24
 2002574:	dfc00515 	stw	ra,20(sp)
 2002578:	df000415 	stw	fp,16(sp)
 200257c:	df000404 	addi	fp,sp,16
 2002580:	e13fff15 	stw	r4,-4(fp)
  char* tx_wr_pos = conn->tx_buffer;
 2002584:	e0bfff17 	ldw	r2,-4(fp)
 2002588:	10801217 	ldw	r2,72(r2)
 200258c:	e0bffc15 	stw	r2,-16(fp)
  int ret_code = 0;
 2002590:	e03ffd15 	stw	zero,-12(fp)
  struct upload_buf_struct *upload_buffer = &upload_buf;
 2002594:	008081b4 	movhi	r2,518
 2002598:	1083e904 	addi	r2,r2,4004
 200259c:	e0bffe15 	stw	r2,-8(fp)
  
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_VERSION_STRING);
 20025a0:	e0bffc17 	ldw	r2,-16(fp)
 20025a4:	00c01204 	movi	r3,72
 20025a8:	10c00005 	stb	r3,0(r2)
 20025ac:	00c01504 	movi	r3,84
 20025b0:	10c00045 	stb	r3,1(r2)
 20025b4:	00c01504 	movi	r3,84
 20025b8:	10c00085 	stb	r3,2(r2)
 20025bc:	00c01404 	movi	r3,80
 20025c0:	10c000c5 	stb	r3,3(r2)
 20025c4:	00c00bc4 	movi	r3,47
 20025c8:	10c00105 	stb	r3,4(r2)
 20025cc:	00c00c44 	movi	r3,49
 20025d0:	10c00145 	stb	r3,5(r2)
 20025d4:	00c00b84 	movi	r3,46
 20025d8:	10c00185 	stb	r3,6(r2)
 20025dc:	00c00c44 	movi	r3,49
 20025e0:	10c001c5 	stb	r3,7(r2)
 20025e4:	00c00804 	movi	r3,32
 20025e8:	10c00205 	stb	r3,8(r2)
 20025ec:	10000245 	stb	zero,9(r2)
 20025f0:	e0bffc17 	ldw	r2,-16(fp)
 20025f4:	10800244 	addi	r2,r2,9
 20025f8:	e0bffc15 	stw	r2,-16(fp)
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_NO_CONTENT_STRING);
 20025fc:	e0fffc17 	ldw	r3,-16(fp)
 2002600:	00808174 	movhi	r2,517
 2002604:	10b38c04 	addi	r2,r2,-12752
 2002608:	1809883a 	mov	r4,r3
 200260c:	1007883a 	mov	r3,r2
 2002610:	00800444 	movi	r2,17
 2002614:	180b883a 	mov	r5,r3
 2002618:	100d883a 	mov	r6,r2
 200261c:	200660c0 	call	200660c <memcpy>
 2002620:	e0bffc17 	ldw	r2,-16(fp)
 2002624:	10800404 	addi	r2,r2,16
 2002628:	e0bffc15 	stw	r2,-16(fp)
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_CLOSE);
 200262c:	e0fffc17 	ldw	r3,-16(fp)
 2002630:	00808174 	movhi	r2,517
 2002634:	10b34d04 	addi	r2,r2,-13004
 2002638:	1809883a 	mov	r4,r3
 200263c:	1007883a 	mov	r3,r2
 2002640:	00800504 	movi	r2,20
 2002644:	180b883a 	mov	r5,r3
 2002648:	100d883a 	mov	r6,r2
 200264c:	200660c0 	call	200660c <memcpy>
 2002650:	e0bffc17 	ldw	r2,-16(fp)
 2002654:	108004c4 	addi	r2,r2,19
 2002658:	e0bffc15 	stw	r2,-16(fp)
  tx_wr_pos += sprintf(tx_wr_pos, HTTP_END_OF_HEADERS);
 200265c:	e0bffc17 	ldw	r2,-16(fp)
 2002660:	00c00344 	movi	r3,13
 2002664:	10c00005 	stb	r3,0(r2)
 2002668:	00c00284 	movi	r3,10
 200266c:	10c00045 	stb	r3,1(r2)
 2002670:	00c00344 	movi	r3,13
 2002674:	10c00085 	stb	r3,2(r2)
 2002678:	00c00284 	movi	r3,10
 200267c:	10c000c5 	stb	r3,3(r2)
 2002680:	10000105 	stb	zero,4(r2)
 2002684:	e0bffc17 	ldw	r2,-16(fp)
 2002688:	10800104 	addi	r2,r2,4
 200268c:	e0bffc15 	stw	r2,-16(fp)

  if (!strcmp(conn->uri, mapping.name))
 2002690:	e0bfff17 	ldw	r2,-4(fp)
 2002694:	10c07604 	addi	r3,r2,472
 2002698:	d0a00017 	ldw	r2,-32768(gp)
 200269c:	1809883a 	mov	r4,r3
 20026a0:	100b883a 	mov	r5,r2
 20026a4:	20074c80 	call	20074c8 <strcmp>
 20026a8:	1000141e 	bne	r2,zero,20026fc <http_handle_post+0x18c>
  {
    send(conn->fd, conn->tx_buffer, (tx_wr_pos - conn->tx_buffer), 0);
 20026ac:	e0bfff17 	ldw	r2,-4(fp)
 20026b0:	11000317 	ldw	r4,12(r2)
 20026b4:	e0bfff17 	ldw	r2,-4(fp)
 20026b8:	10c01217 	ldw	r3,72(r2)
 20026bc:	e17ffc17 	ldw	r5,-16(fp)
 20026c0:	e0bfff17 	ldw	r2,-4(fp)
 20026c4:	10801217 	ldw	r2,72(r2)
 20026c8:	2885c83a 	sub	r2,r5,r2
 20026cc:	180b883a 	mov	r5,r3
 20026d0:	100d883a 	mov	r6,r2
 20026d4:	000f883a 	mov	r7,zero
 20026d8:	202c5d80 	call	202c5d8 <t_send>
    conn->state = CLOSE;
 20026dc:	e0bfff17 	ldw	r2,-4(fp)
 20026e0:	00c00144 	movi	r3,5
 20026e4:	10c00015 	stw	r3,0(r2)
    mapping.func();
 20026e8:	00808174 	movhi	r2,517
 20026ec:	10902b04 	addi	r2,r2,16556
 20026f0:	10800017 	ldw	r2,0(r2)
 20026f4:	103ee83a 	callr	r2
 20026f8:	00006406 	br	200288c <http_handle_post+0x31c>
  }

  else if (!strcmp(conn->uri, sweep_field.name))
 20026fc:	e0bfff17 	ldw	r2,-4(fp)
 2002700:	10c07604 	addi	r3,r2,472
 2002704:	d0a00217 	ldw	r2,-32760(gp)
 2002708:	1809883a 	mov	r4,r3
 200270c:	100b883a 	mov	r5,r2
 2002710:	20074c80 	call	20074c8 <strcmp>
 2002714:	1000151e 	bne	r2,zero,200276c <http_handle_post+0x1fc>
  {
    send(conn->fd, conn->tx_buffer, (tx_wr_pos - conn->tx_buffer), 0);
 2002718:	e0bfff17 	ldw	r2,-4(fp)
 200271c:	11000317 	ldw	r4,12(r2)
 2002720:	e0bfff17 	ldw	r2,-4(fp)
 2002724:	10c01217 	ldw	r3,72(r2)
 2002728:	e17ffc17 	ldw	r5,-16(fp)
 200272c:	e0bfff17 	ldw	r2,-4(fp)
 2002730:	10801217 	ldw	r2,72(r2)
 2002734:	2885c83a 	sub	r2,r5,r2
 2002738:	180b883a 	mov	r5,r3
 200273c:	100d883a 	mov	r6,r2
 2002740:	000f883a 	mov	r7,zero
 2002744:	202c5d80 	call	202c5d8 <t_send>
    conn->state = CLOSE;
 2002748:	e0bfff17 	ldw	r2,-4(fp)
 200274c:	00c00144 	movi	r3,5
 2002750:	10c00015 	stw	r3,0(r2)
    sweep_field.func(conn);
 2002754:	00808174 	movhi	r2,517
 2002758:	10902d04 	addi	r2,r2,16564
 200275c:	10800017 	ldw	r2,0(r2)
 2002760:	e13fff17 	ldw	r4,-4(fp)
 2002764:	103ee83a 	callr	r2
 2002768:	00004806 	br	200288c <http_handle_post+0x31c>
  }
  
  else if (!strcmp(conn->uri, lcd_field.name))
 200276c:	e0bfff17 	ldw	r2,-4(fp)
 2002770:	10c07604 	addi	r3,r2,472
 2002774:	d0a00417 	ldw	r2,-32752(gp)
 2002778:	1809883a 	mov	r4,r3
 200277c:	100b883a 	mov	r5,r2
 2002780:	20074c80 	call	20074c8 <strcmp>
 2002784:	1000151e 	bne	r2,zero,20027dc <http_handle_post+0x26c>
  {
    send(conn->fd, conn->tx_buffer, (tx_wr_pos - conn->tx_buffer), 0);
 2002788:	e0bfff17 	ldw	r2,-4(fp)
 200278c:	11000317 	ldw	r4,12(r2)
 2002790:	e0bfff17 	ldw	r2,-4(fp)
 2002794:	10c01217 	ldw	r3,72(r2)
 2002798:	e17ffc17 	ldw	r5,-16(fp)
 200279c:	e0bfff17 	ldw	r2,-4(fp)
 20027a0:	10801217 	ldw	r2,72(r2)
 20027a4:	2885c83a 	sub	r2,r5,r2
 20027a8:	180b883a 	mov	r5,r3
 20027ac:	100d883a 	mov	r6,r2
 20027b0:	000f883a 	mov	r7,zero
 20027b4:	202c5d80 	call	202c5d8 <t_send>
    conn->state = CLOSE;
 20027b8:	e0bfff17 	ldw	r2,-4(fp)
 20027bc:	00c00144 	movi	r3,5
 20027c0:	10c00015 	stw	r3,0(r2)
    lcd_field.func(conn);
 20027c4:	00808174 	movhi	r2,517
 20027c8:	10902f04 	addi	r2,r2,16572
 20027cc:	10800017 	ldw	r2,0(r2)
 20027d0:	e13fff17 	ldw	r4,-4(fp)
 20027d4:	103ee83a 	callr	r2
 20027d8:	00002c06 	br	200288c <http_handle_post+0x31c>
  }

  else if (!strcmp(conn->uri, upload_field.name))
 20027dc:	e0bfff17 	ldw	r2,-4(fp)
 20027e0:	10c07604 	addi	r3,r2,472
 20027e4:	d0a00617 	ldw	r2,-32744(gp)
 20027e8:	1809883a 	mov	r4,r3
 20027ec:	100b883a 	mov	r5,r2
 20027f0:	20074c80 	call	20074c8 <strcmp>
 20027f4:	1000191e 	bne	r2,zero,200285c <http_handle_post+0x2ec>
  {
    conn->file_upload = 1;
 20027f8:	e0bfff17 	ldw	r2,-4(fp)
 20027fc:	00c00044 	movi	r3,1
 2002800:	10c00a15 	stw	r3,40(r2)
    upload_buffer->rd_pos = upload_buffer->wr_pos = upload_buffer->buffer;
 2002804:	e0bffe17 	ldw	r2,-8(fp)
 2002808:	10c00204 	addi	r3,r2,8
 200280c:	e0bffe17 	ldw	r2,-8(fp)
 2002810:	10c00015 	stw	r3,0(r2)
 2002814:	e0bffe17 	ldw	r2,-8(fp)
 2002818:	10c00017 	ldw	r3,0(r2)
 200281c:	e0bffe17 	ldw	r2,-8(fp)
 2002820:	10c00115 	stw	r3,4(r2)
    memset(upload_buffer->rd_pos, '\0', conn->content_length );
 2002824:	e0bffe17 	ldw	r2,-8(fp)
 2002828:	10c00117 	ldw	r3,4(r2)
 200282c:	e0bfff17 	ldw	r2,-4(fp)
 2002830:	10800517 	ldw	r2,20(r2)
 2002834:	1809883a 	mov	r4,r3
 2002838:	000b883a 	mov	r5,zero
 200283c:	100d883a 	mov	r6,r2
 2002840:	200682c0 	call	200682c <memset>
    upload_field.func(conn);
 2002844:	00808174 	movhi	r2,517
 2002848:	10903104 	addi	r2,r2,16580
 200284c:	10800017 	ldw	r2,0(r2)
 2002850:	e13fff17 	ldw	r4,-4(fp)
 2002854:	103ee83a 	callr	r2
 2002858:	00000c06 	br	200288c <http_handle_post+0x31c>
  }
  else if (!strcmp(conn->uri, flash_field.name))
 200285c:	e0bfff17 	ldw	r2,-4(fp)
 2002860:	10c07604 	addi	r3,r2,472
 2002864:	d0a00817 	ldw	r2,-32736(gp)
 2002868:	1809883a 	mov	r4,r3
 200286c:	100b883a 	mov	r5,r2
 2002870:	20074c80 	call	20074c8 <strcmp>
 2002874:	1000051e 	bne	r2,zero,200288c <http_handle_post+0x31c>
  {
    /* Kick off the flash programming. */
    flash_field.func( conn );
 2002878:	00808174 	movhi	r2,517
 200287c:	10903304 	addi	r2,r2,16588
 2002880:	10800017 	ldw	r2,0(r2)
 2002884:	e13fff17 	ldw	r4,-4(fp)
 2002888:	103ee83a 	callr	r2
    /* Close the socket. */
    send(conn->fd, conn->tx_buffer, (tx_wr_pos - conn->tx_buffer), 0);
    reset_field.func();
  }
#endif  
  return ret_code;
 200288c:	e0bffd17 	ldw	r2,-12(fp)
}
 2002890:	e037883a 	mov	sp,fp
 2002894:	dfc00117 	ldw	ra,4(sp)
 2002898:	df000017 	ldw	fp,0(sp)
 200289c:	dec00204 	addi	sp,sp,8
 20028a0:	f800283a 	ret

020028a4 <http_prepare_response>:
 * 
 * Service the various HTTP commands, calling the relevant subroutine. 
 * We only handle GET and POST.
 */
int http_prepare_response(http_conn* conn)
{
 20028a4:	defffc04 	addi	sp,sp,-16
 20028a8:	dfc00315 	stw	ra,12(sp)
 20028ac:	df000215 	stw	fp,8(sp)
 20028b0:	df000204 	addi	fp,sp,8
 20028b4:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 20028b8:	e03ffe15 	stw	zero,-8(fp)
  
  switch (conn->action)
 20028bc:	e0bfff17 	ldw	r2,-4(fp)
 20028c0:	10800117 	ldw	r2,4(r2)
 20028c4:	10c00060 	cmpeqi	r3,r2,1
 20028c8:	1800031e 	bne	r3,zero,20028d8 <http_prepare_response+0x34>
 20028cc:	108000a0 	cmpeqi	r2,r2,2
 20028d0:	1000051e 	bne	r2,zero,20028e8 <http_prepare_response+0x44>
 20028d4:	00000806 	br	20028f8 <http_prepare_response+0x54>
  {
    case GET:
    {
      /* Find file from uri */
      ret_code = http_find_file(conn);
 20028d8:	e13fff17 	ldw	r4,-4(fp)
 20028dc:	20022d40 	call	20022d4 <http_find_file>
 20028e0:	e0bffe15 	stw	r2,-8(fp)
      break;
 20028e4:	00000506 	br	20028fc <http_prepare_response+0x58>
    }
    case POST:
    {
      /* Handle POSTs. */
      ret_code = http_handle_post(conn);
 20028e8:	e13fff17 	ldw	r4,-4(fp)
 20028ec:	20025700 	call	2002570 <http_handle_post>
 20028f0:	e0bffe15 	stw	r2,-8(fp)
      break;
 20028f4:	00000106 	br	20028fc <http_prepare_response+0x58>
    }
    default:
    {
      break;
 20028f8:	0001883a 	nop
    }
  } /* switch (conn->action) */
  
  return ret_code;
 20028fc:	e0bffe17 	ldw	r2,-8(fp)
}
 2002900:	e037883a 	mov	sp,fp
 2002904:	dfc00117 	ldw	ra,4(sp)
 2002908:	df000017 	ldw	fp,0(sp)
 200290c:	dec00204 	addi	sp,sp,8
 2002910:	f800283a 	ret

02002914 <http_handle_receive>:
 * http_handle_receive()
 *
 * Work out what the request we received was, and handle it.
 */
void http_handle_receive(http_conn* conn, int http_instance)
{
 2002914:	defffa04 	addi	sp,sp,-24
 2002918:	dfc00515 	stw	ra,20(sp)
 200291c:	df000415 	stw	fp,16(sp)
 2002920:	df000404 	addi	fp,sp,16
 2002924:	e13ffe15 	stw	r4,-8(fp)
 2002928:	e17fff15 	stw	r5,-4(fp)
  int data_used, rx_code;
  
  if (conn->state == READY)
 200292c:	e0bffe17 	ldw	r2,-8(fp)
 2002930:	10800017 	ldw	r2,0(r2)
 2002934:	10002d1e 	bne	r2,zero,20029ec <http_handle_receive+0xd8>
  {
    rx_code = recv(conn->fd, conn->rx_wr_pos, 
 2002938:	e0bffe17 	ldw	r2,-8(fp)
 200293c:	11000317 	ldw	r4,12(r2)
 2002940:	e0bffe17 	ldw	r2,-8(fp)
 2002944:	10c00e17 	ldw	r3,56(r2)
 2002948:	e0bffe17 	ldw	r2,-8(fp)
 200294c:	10801117 	ldw	r2,68(r2)
 2002950:	100b883a 	mov	r5,r2
 2002954:	e0bffe17 	ldw	r2,-8(fp)
 2002958:	10800e17 	ldw	r2,56(r2)
 200295c:	2885c83a 	sub	r2,r5,r2
 2002960:	1087ffc4 	addi	r2,r2,8191
 2002964:	180b883a 	mov	r5,r3
 2002968:	100d883a 	mov	r6,r2
 200296c:	000f883a 	mov	r7,zero
 2002970:	202c1d40 	call	202c1d4 <t_recv>
 2002974:	e0bffc15 	stw	r2,-16(fp)
    /* 
     * If a valid data received, take care of buffer pointer & string 
     * termination and move on. Otherwise, we need to return and wait for more
     * data to arrive (until we time out).
     */
    if(rx_code > 0)
 2002978:	e0bffc17 	ldw	r2,-16(fp)
 200297c:	00801b0e 	bge	zero,r2,20029ec <http_handle_receive+0xd8>
    {
      /* Increment rx_wr_pos by the amount of data received. */
      conn->rx_wr_pos += rx_code;
 2002980:	e0bffe17 	ldw	r2,-8(fp)
 2002984:	10c00e17 	ldw	r3,56(r2)
 2002988:	e0bffc17 	ldw	r2,-16(fp)
 200298c:	1887883a 	add	r3,r3,r2
 2002990:	e0bffe17 	ldw	r2,-8(fp)
 2002994:	10c00e15 	stw	r3,56(r2)
      /* Place a zero just after the data received to serve as a terminator. */
      *(conn->rx_wr_pos+1) = 0;
 2002998:	e0bffe17 	ldw	r2,-8(fp)
 200299c:	10800e17 	ldw	r2,56(r2)
 20029a0:	10800044 	addi	r2,r2,1
 20029a4:	10000005 	stb	zero,0(r2)
      
      if(strstr(conn->rx_buffer, HTTP_END_OF_HEADERS))
 20029a8:	e0bffe17 	ldw	r2,-8(fp)
 20029ac:	10801117 	ldw	r2,68(r2)
 20029b0:	1009883a 	mov	r4,r2
 20029b4:	01408174 	movhi	r5,517
 20029b8:	29739104 	addi	r5,r5,-12732
 20029bc:	20083340 	call	2008334 <strstr>
 20029c0:	10000326 	beq	r2,zero,20029d0 <http_handle_receive+0xbc>
      {
        conn->state = PROCESS;
 20029c4:	e0bffe17 	ldw	r2,-8(fp)
 20029c8:	00c00044 	movi	r3,1
 20029cc:	10c00015 	stw	r3,0(r2)
      }
      /* If the connection is a file upload, skip right to DATA.*/
      if(conn->file_upload == 1)
 20029d0:	e0bffe17 	ldw	r2,-8(fp)
 20029d4:	10800a17 	ldw	r2,40(r2)
 20029d8:	10800058 	cmpnei	r2,r2,1
 20029dc:	1000031e 	bne	r2,zero,20029ec <http_handle_receive+0xd8>
      {
        conn->state = DATA;
 20029e0:	e0bffe17 	ldw	r2,-8(fp)
 20029e4:	00c00084 	movi	r3,2
 20029e8:	10c00015 	stw	r3,0(r2)
      }
    }
  }
  
  if(conn->state == PROCESS)
 20029ec:	e0bffe17 	ldw	r2,-8(fp)
 20029f0:	10800017 	ldw	r2,0(r2)
 20029f4:	10800058 	cmpnei	r2,r2,1
 20029f8:	1000a51e 	bne	r2,zero,2002c90 <http_handle_receive+0x37c>
 20029fc:	00808174 	movhi	r2,517
 2002a00:	10909604 	addi	r2,r2,16984
 2002a04:	10800017 	ldw	r2,0(r2)
  {
    /* 
     * If we (think) we have valid headers, keep the connection alive a bit
     * longer.
     */
    conn->activity_time = alt_nticks();
 2002a08:	1007883a 	mov	r3,r2
 2002a0c:	e0bffe17 	ldw	r2,-8(fp)
 2002a10:	10c00c15 	stw	r3,48(r2)
    /* 
     * Attempt to process the fundamentals of the HTTP request. We may 
     * error out and reset if the request wasn't complete, or something
     * was asked from us that we can't handle.
     */
    if (http_process_request(conn))
 2002a14:	e13ffe17 	ldw	r4,-8(fp)
 2002a18:	20017140 	call	2001714 <http_process_request>
 2002a1c:	10005326 	beq	r2,zero,2002b6c <http_handle_receive+0x258>
    {
      fprintf(stderr, "[http_handle_receive] http_process_request failed\n");
 2002a20:	00808174 	movhi	r2,517
 2002a24:	10903604 	addi	r2,r2,16600
 2002a28:	10800017 	ldw	r2,0(r2)
 2002a2c:	10800317 	ldw	r2,12(r2)
 2002a30:	01008174 	movhi	r4,517
 2002a34:	21339304 	addi	r4,r4,-12724
 2002a38:	01400044 	movi	r5,1
 2002a3c:	01800c84 	movi	r6,50
 2002a40:	100f883a 	mov	r7,r2
 2002a44:	2005ba80 	call	2005ba8 <fwrite>
      conn->state = RESET;
 2002a48:	e0bffe17 	ldw	r2,-8(fp)
 2002a4c:	00c00104 	movi	r3,4
 2002a50:	10c00015 	stw	r3,0(r2)
      http_manage_connection(conn, http_instance);
 2002a54:	e13ffe17 	ldw	r4,-8(fp)
 2002a58:	e17fff17 	ldw	r5,-4(fp)
 2002a5c:	20010980 	call	2001098 <http_manage_connection>
     * done, send some headers of our own back to let the client know 
     * what's happening. Also, once all in-coming headers have been parsed
     * we can manage our RX buffer to prepare for the next in-coming 
     * connection.
     */
    while(conn->state == PROCESS)
 2002a60:	00004206 	br	2002b6c <http_handle_receive+0x258>
    {
      if(http_read_line(conn))
 2002a64:	e13ffe17 	ldw	r4,-8(fp)
 2002a68:	20013500 	call	2001350 <http_read_line>
 2002a6c:	10001126 	beq	r2,zero,2002ab4 <http_handle_receive+0x1a0>
      {
        fprintf(stderr, "[http_handle_receive] error reading headers\n");
 2002a70:	00808174 	movhi	r2,517
 2002a74:	10903604 	addi	r2,r2,16600
 2002a78:	10800017 	ldw	r2,0(r2)
 2002a7c:	10800317 	ldw	r2,12(r2)
 2002a80:	01008174 	movhi	r4,517
 2002a84:	2133a004 	addi	r4,r4,-12672
 2002a88:	01400044 	movi	r5,1
 2002a8c:	01800b04 	movi	r6,44
 2002a90:	100f883a 	mov	r7,r2
 2002a94:	2005ba80 	call	2005ba8 <fwrite>
        conn->state = RESET;
 2002a98:	e0bffe17 	ldw	r2,-8(fp)
 2002a9c:	00c00104 	movi	r3,4
 2002aa0:	10c00015 	stw	r3,0(r2)
        http_manage_connection(conn, http_instance);
 2002aa4:	e13ffe17 	ldw	r4,-8(fp)
 2002aa8:	e17fff17 	ldw	r5,-4(fp)
 2002aac:	20010980 	call	2001098 <http_manage_connection>
        break;
 2002ab0:	00003306 	br	2002b80 <http_handle_receive+0x26c>
      }
      if(http_process_headers(conn))
 2002ab4:	e13ffe17 	ldw	r4,-8(fp)
 2002ab8:	20015000 	call	2001500 <http_process_headers>
 2002abc:	10002c26 	beq	r2,zero,2002b70 <http_handle_receive+0x25c>
      {
        if( (conn->rx_rd_pos = strstr(conn->rx_rd_pos, HTTP_CR_LF)) )
 2002ac0:	e0bffe17 	ldw	r2,-8(fp)
 2002ac4:	10800d17 	ldw	r2,52(r2)
 2002ac8:	1009883a 	mov	r4,r2
 2002acc:	01408174 	movhi	r5,517
 2002ad0:	2973ac04 	addi	r5,r5,-12624
 2002ad4:	20083340 	call	2008334 <strstr>
 2002ad8:	e0fffe17 	ldw	r3,-8(fp)
 2002adc:	18800d15 	stw	r2,52(r3)
 2002ae0:	e0bffe17 	ldw	r2,-8(fp)
 2002ae4:	10800d17 	ldw	r2,52(r2)
 2002ae8:	10000f26 	beq	r2,zero,2002b28 <http_handle_receive+0x214>
        {
          conn->rx_rd_pos += 2;
 2002aec:	e0bffe17 	ldw	r2,-8(fp)
 2002af0:	10800d17 	ldw	r2,52(r2)
 2002af4:	10c00084 	addi	r3,r2,2
 2002af8:	e0bffe17 	ldw	r2,-8(fp)
 2002afc:	10c00d15 	stw	r3,52(r2)
          conn->state = DATA;
 2002b00:	e0bffe17 	ldw	r2,-8(fp)
 2002b04:	00c00084 	movi	r3,2
 2002b08:	10c00015 	stw	r3,0(r2)
 2002b0c:	00808174 	movhi	r2,517
 2002b10:	10909604 	addi	r2,r2,16984
 2002b14:	10800017 	ldw	r2,0(r2)
          conn->activity_time = alt_nticks();
 2002b18:	1007883a 	mov	r3,r2
 2002b1c:	e0bffe17 	ldw	r2,-8(fp)
 2002b20:	10c00c15 	stw	r3,48(r2)
 2002b24:	00001206 	br	2002b70 <http_handle_receive+0x25c>
        }
        else
        {
          fprintf(stderr, "[http_handle_receive] Can't find end of headers!\n");
 2002b28:	00808174 	movhi	r2,517
 2002b2c:	10903604 	addi	r2,r2,16600
 2002b30:	10800017 	ldw	r2,0(r2)
 2002b34:	10800317 	ldw	r2,12(r2)
 2002b38:	01008174 	movhi	r4,517
 2002b3c:	2133ad04 	addi	r4,r4,-12620
 2002b40:	01400044 	movi	r5,1
 2002b44:	01800c44 	movi	r6,49
 2002b48:	100f883a 	mov	r7,r2
 2002b4c:	2005ba80 	call	2005ba8 <fwrite>
          conn->state = RESET;
 2002b50:	e0bffe17 	ldw	r2,-8(fp)
 2002b54:	00c00104 	movi	r3,4
 2002b58:	10c00015 	stw	r3,0(r2)
          http_manage_connection(conn, http_instance);
 2002b5c:	e13ffe17 	ldw	r4,-8(fp)
 2002b60:	e17fff17 	ldw	r5,-4(fp)
 2002b64:	20010980 	call	2001098 <http_manage_connection>
          break;
 2002b68:	00000506 	br	2002b80 <http_handle_receive+0x26c>
     * done, send some headers of our own back to let the client know 
     * what's happening. Also, once all in-coming headers have been parsed
     * we can manage our RX buffer to prepare for the next in-coming 
     * connection.
     */
    while(conn->state == PROCESS)
 2002b6c:	0001883a 	nop
 2002b70:	e0bffe17 	ldw	r2,-8(fp)
 2002b74:	10800017 	ldw	r2,0(r2)
 2002b78:	10800060 	cmpeqi	r2,r2,1
 2002b7c:	103fb91e 	bne	r2,zero,2002a64 <http_handle_receive+0x150>
          break;
        }
      } 
    } /* while(conn->state == PROCESS) */
    
    if( http_prepare_response(conn) )
 2002b80:	e13ffe17 	ldw	r4,-8(fp)
 2002b84:	20028a40 	call	20028a4 <http_prepare_response>
 2002b88:	10001026 	beq	r2,zero,2002bcc <http_handle_receive+0x2b8>
    {
      conn->state = RESET;
 2002b8c:	e0bffe17 	ldw	r2,-8(fp)
 2002b90:	00c00104 	movi	r3,4
 2002b94:	10c00015 	stw	r3,0(r2)
      fprintf(stderr, "[http_handle_receive] Error preparing response\n");
 2002b98:	00808174 	movhi	r2,517
 2002b9c:	10903604 	addi	r2,r2,16600
 2002ba0:	10800017 	ldw	r2,0(r2)
 2002ba4:	10800317 	ldw	r2,12(r2)
 2002ba8:	01008174 	movhi	r4,517
 2002bac:	2133ba04 	addi	r4,r4,-12568
 2002bb0:	01400044 	movi	r5,1
 2002bb4:	01800bc4 	movi	r6,47
 2002bb8:	100f883a 	mov	r7,r2
 2002bbc:	2005ba80 	call	2005ba8 <fwrite>
      http_manage_connection(conn, http_instance);
 2002bc0:	e13ffe17 	ldw	r4,-8(fp)
 2002bc4:	e17fff17 	ldw	r5,-4(fp)
 2002bc8:	20010980 	call	2001098 <http_manage_connection>
    /* 
     * Manage RX Buffer: Slide any un-read data in our input buffer 
     * down over previously-read data that can now be overwritten, and 
     * zero-out any bytes in question at the top of our new un-read space. 
     */
    if(conn->rx_rd_pos > (conn->rx_buffer + HTTP_RX_BUF_SIZE))
 2002bcc:	e0bffe17 	ldw	r2,-8(fp)
 2002bd0:	10800d17 	ldw	r2,52(r2)
 2002bd4:	e0fffe17 	ldw	r3,-8(fp)
 2002bd8:	18c01117 	ldw	r3,68(r3)
 2002bdc:	18c80004 	addi	r3,r3,8192
 2002be0:	1880052e 	bgeu	r3,r2,2002bf8 <http_handle_receive+0x2e4>
    {
      conn->rx_rd_pos = conn->rx_buffer + HTTP_RX_BUF_SIZE;
 2002be4:	e0bffe17 	ldw	r2,-8(fp)
 2002be8:	10801117 	ldw	r2,68(r2)
 2002bec:	10c80004 	addi	r3,r2,8192
 2002bf0:	e0bffe17 	ldw	r2,-8(fp)
 2002bf4:	10c00d15 	stw	r3,52(r2)
    }
        
    data_used = conn->rx_rd_pos - conn->rx_buffer;
 2002bf8:	e0bffe17 	ldw	r2,-8(fp)
 2002bfc:	10800d17 	ldw	r2,52(r2)
 2002c00:	1007883a 	mov	r3,r2
 2002c04:	e0bffe17 	ldw	r2,-8(fp)
 2002c08:	10801117 	ldw	r2,68(r2)
 2002c0c:	1885c83a 	sub	r2,r3,r2
 2002c10:	e0bffd15 	stw	r2,-12(fp)
    memmove(conn->rx_buffer,conn->rx_rd_pos,conn->rx_wr_pos-conn->rx_rd_pos);
 2002c14:	e0bffe17 	ldw	r2,-8(fp)
 2002c18:	11001117 	ldw	r4,68(r2)
 2002c1c:	e0bffe17 	ldw	r2,-8(fp)
 2002c20:	10c00d17 	ldw	r3,52(r2)
 2002c24:	e0bffe17 	ldw	r2,-8(fp)
 2002c28:	10800e17 	ldw	r2,56(r2)
 2002c2c:	100b883a 	mov	r5,r2
 2002c30:	e0bffe17 	ldw	r2,-8(fp)
 2002c34:	10800d17 	ldw	r2,52(r2)
 2002c38:	2885c83a 	sub	r2,r5,r2
 2002c3c:	180b883a 	mov	r5,r3
 2002c40:	100d883a 	mov	r6,r2
 2002c44:	20067040 	call	2006704 <memmove>
    conn->rx_rd_pos = conn->rx_buffer;
 2002c48:	e0bffe17 	ldw	r2,-8(fp)
 2002c4c:	10c01117 	ldw	r3,68(r2)
 2002c50:	e0bffe17 	ldw	r2,-8(fp)
 2002c54:	10c00d15 	stw	r3,52(r2)
    conn->rx_wr_pos -= data_used;
 2002c58:	e0bffe17 	ldw	r2,-8(fp)
 2002c5c:	10c00e17 	ldw	r3,56(r2)
 2002c60:	e0bffd17 	ldw	r2,-12(fp)
 2002c64:	0085c83a 	sub	r2,zero,r2
 2002c68:	1887883a 	add	r3,r3,r2
 2002c6c:	e0bffe17 	ldw	r2,-8(fp)
 2002c70:	10c00e15 	stw	r3,56(r2)
    memset(conn->rx_wr_pos, 0, data_used);
 2002c74:	e0bffe17 	ldw	r2,-8(fp)
 2002c78:	10c00e17 	ldw	r3,56(r2)
 2002c7c:	e0bffd17 	ldw	r2,-12(fp)
 2002c80:	1809883a 	mov	r4,r3
 2002c84:	000b883a 	mov	r5,zero
 2002c88:	100d883a 	mov	r6,r2
 2002c8c:	200682c0 	call	200682c <memset>
   }
   
  if (conn->state == DATA && conn->file_upload == 1 )
 2002c90:	e0bffe17 	ldw	r2,-8(fp)
 2002c94:	10800017 	ldw	r2,0(r2)
 2002c98:	10800098 	cmpnei	r2,r2,2
 2002c9c:	1000091e 	bne	r2,zero,2002cc4 <http_handle_receive+0x3b0>
 2002ca0:	e0bffe17 	ldw	r2,-8(fp)
 2002ca4:	10800a17 	ldw	r2,40(r2)
 2002ca8:	10800058 	cmpnei	r2,r2,1
 2002cac:	1000051e 	bne	r2,zero,2002cc4 <http_handle_receive+0x3b0>
  {
    /* Jump to the file_upload() function....process more received data. */
    upload_field.func(conn);
 2002cb0:	00808174 	movhi	r2,517
 2002cb4:	10903104 	addi	r2,r2,16580
 2002cb8:	10800017 	ldw	r2,0(r2)
 2002cbc:	e13ffe17 	ldw	r4,-8(fp)
 2002cc0:	103ee83a 	callr	r2
  }
}
 2002cc4:	e037883a 	mov	sp,fp
 2002cc8:	dfc00117 	ldw	ra,4(sp)
 2002ccc:	df000017 	ldw	fp,0(sp)
 2002cd0:	dec00204 	addi	sp,sp,8
 2002cd4:	f800283a 	ret

02002cd8 <http_handle_transmit>:
 * will be called from the thread's main loop when ever the socket is in 
 * the 'DATA' state and the socket is marked as available for writing (free
 * buffer space). 
 */
void http_handle_transmit(http_conn* conn, int http_instance)
{
 2002cd8:	defffc04 	addi	sp,sp,-16
 2002cdc:	dfc00315 	stw	ra,12(sp)
 2002ce0:	df000215 	stw	fp,8(sp)
 2002ce4:	df000204 	addi	fp,sp,8
 2002ce8:	e13ffe15 	stw	r4,-8(fp)
 2002cec:	e17fff15 	stw	r5,-4(fp)
  if( http_send_file_chunk(conn) )
 2002cf0:	e13ffe17 	ldw	r4,-8(fp)
 2002cf4:	20019e00 	call	20019e0 <http_send_file_chunk>
 2002cf8:	10000a26 	beq	r2,zero,2002d24 <http_handle_transmit+0x4c>
  {
    fprintf(stderr, "[http_handle_transmit]: Send file chunk failed\n");
 2002cfc:	00808174 	movhi	r2,517
 2002d00:	10903604 	addi	r2,r2,16600
 2002d04:	10800017 	ldw	r2,0(r2)
 2002d08:	10800317 	ldw	r2,12(r2)
 2002d0c:	01008174 	movhi	r4,517
 2002d10:	2133c604 	addi	r4,r4,-12520
 2002d14:	01400044 	movi	r5,1
 2002d18:	01800bc4 	movi	r6,47
 2002d1c:	100f883a 	mov	r7,r2
 2002d20:	2005ba80 	call	2005ba8 <fwrite>
  }
}
 2002d24:	e037883a 	mov	sp,fp
 2002d28:	dfc00117 	ldw	ra,4(sp)
 2002d2c:	df000017 	ldw	fp,0(sp)
 2002d30:	dec00204 	addi	sp,sp,8
 2002d34:	f800283a 	ret

02002d38 <WSTask>:
 * reading or writing. This, in conjunction with the use of non-blocking 
 * send() and recv() calls and sending responses broken up into chunks lets
 * us handle multiple active HTTP requests.
 */
void WSTask()
{
 2002d38:	deff7204 	addi	sp,sp,-568
 2002d3c:	dfc08d15 	stw	ra,564(sp)
 2002d40:	df008c15 	stw	fp,560(sp)
 2002d44:	df008c04 	addi	fp,sp,560
   * The socket() call creates an endpoint for TCP of UDP communication. It 
   * returns a descriptor (similar to a file descriptor) that we call fd_listen,
   * or, "the socket we're listening on for connection requests" in our web
   * server example.
   */ 
  if ((fd_listen = socket(AF_INET, SOCK_STREAM, 0)) < 0)
 2002d48:	01000084 	movi	r4,2
 2002d4c:	01400044 	movi	r5,1
 2002d50:	000d883a 	mov	r6,zero
 2002d54:	202b4e00 	call	202b4e0 <t_socket>
 2002d58:	e0bf7715 	stw	r2,-548(fp)
 2002d5c:	e0bf7717 	ldw	r2,-548(fp)
 2002d60:	1000030e 	bge	r2,zero,2002d70 <WSTask+0x38>
  {
    die_with_error("[WSTask] Listening socket creation failed");
 2002d64:	01008174 	movhi	r4,517
 2002d68:	2133d204 	addi	r4,r4,-12472
 2002d6c:	200308c0 	call	200308c <die_with_error>
   * port and incoming address. In this case we're binding to HTTP_PORT and to
   * INADDR_ANY address (allowing anyone to connect to us. Bind may fail for 
   * various reasons, but the most common is that some other socket is bound to
   * the port we're requesting. 
   */ 
  addr.sin_family = AF_INET;
 2002d70:	00800084 	movi	r2,2
 2002d74:	e0bf780d 	sth	r2,-544(fp)
  addr.sin_port = htons(HTTP_PORT);
 2002d78:	00940004 	movi	r2,20480
 2002d7c:	e0bf788d 	sth	r2,-542(fp)
  addr.sin_addr.s_addr = INADDR_ANY;
 2002d80:	e03f7915 	stw	zero,-540(fp)
    
  if ((bind(fd_listen,(struct sockaddr *)&addr,sizeof(addr))) < 0)
 2002d84:	e0bf7804 	addi	r2,fp,-544
 2002d88:	e13f7717 	ldw	r4,-548(fp)
 2002d8c:	100b883a 	mov	r5,r2
 2002d90:	01800404 	movi	r6,16
 2002d94:	202b5600 	call	202b560 <t_bind>
 2002d98:	1000030e 	bge	r2,zero,2002da8 <WSTask+0x70>
  {
    die_with_error("[WSTask] Bind failed");
 2002d9c:	01008174 	movhi	r4,517
 2002da0:	2133dd04 	addi	r4,r4,-12428
 2002da4:	200308c0 	call	200308c <die_with_error>
   * Sockets primer, continued...
   * The listen socket is a socket which is waiting for incoming connections.
   * This call to listen will block (i.e. not return) until someone tries to 
   * connect to this port.
   */ 
  if ((listen(fd_listen,1)) < 0)
 2002da8:	e13f7717 	ldw	r4,-548(fp)
 2002dac:	01400044 	movi	r5,1
 2002db0:	202b6bc0 	call	202b6bc <t_listen>
 2002db4:	1000030e 	bge	r2,zero,2002dc4 <WSTask+0x8c>
  {
    die_with_error("[WSTask] Listen failed");
 2002db8:	01008174 	movhi	r4,517
 2002dbc:	2133e304 	addi	r4,r4,-12404
 2002dc0:	200308c0 	call	200308c <die_with_error>

  /* 
   * At this point we have successfully created a socket which is listening
   * on HTTP_PORT for connection requests from any remote address.
   */
  for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2002dc4:	e03f7515 	stw	zero,-556(fp)
 2002dc8:	00000b06 	br	2002df8 <WSTask+0xc0>
  {
    http_reset_connection(&conn[i], i);
 2002dcc:	e0bf7517 	ldw	r2,-556(fp)
 2002dd0:	10c87624 	muli	r3,r2,8664
 2002dd4:	00808174 	movhi	r2,517
 2002dd8:	1090fe04 	addi	r2,r2,17400
 2002ddc:	1885883a 	add	r2,r3,r2
 2002de0:	1009883a 	mov	r4,r2
 2002de4:	e17f7517 	ldw	r5,-556(fp)
 2002de8:	2000fcc0 	call	2000fcc <http_reset_connection>

  /* 
   * At this point we have successfully created a socket which is listening
   * on HTTP_PORT for connection requests from any remote address.
   */
  for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2002dec:	e0bf7517 	ldw	r2,-556(fp)
 2002df0:	10800044 	addi	r2,r2,1
 2002df4:	e0bf7515 	stw	r2,-556(fp)
 2002df8:	e0bf7517 	ldw	r2,-556(fp)
 2002dfc:	10800190 	cmplti	r2,r2,6
 2002e00:	103ff21e 	bne	r2,zero,2002dcc <WSTask+0x94>
     * 
     *   FD_ZERO  - Zero's out the sockets we're interested in
     *   FD_SET   - Adds a socket to those we're interested in
     *   FD_ISSET - Tests whether the chosen socket is set 
     */
    FD_ZERO(&readfds);
 2002e04:	e03f7e15 	stw	zero,-520(fp)
    FD_ZERO(&writefds);
 2002e08:	e03fbf15 	stw	zero,-260(fp)
    FD_SET(fd_listen, &readfds);
 2002e0c:	e0bf7e04 	addi	r2,fp,-520
 2002e10:	e13f7717 	ldw	r4,-548(fp)
 2002e14:	100b883a 	mov	r5,r2
 2002e18:	203050c0 	call	203050c <ifd_set>
    
    max_socket = fd_listen+1;
 2002e1c:	e0bf7717 	ldw	r2,-548(fp)
 2002e20:	10800044 	addi	r2,r2,1
 2002e24:	e0bf7615 	stw	r2,-552(fp)
    
    for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2002e28:	e03f7515 	stw	zero,-556(fp)
 2002e2c:	00003c06 	br	2002f20 <WSTask+0x1e8>
    {
      if (conn[i].fd != -1)
 2002e30:	00c08174 	movhi	r3,517
 2002e34:	18d0fe04 	addi	r3,r3,17400
 2002e38:	e0bf7517 	ldw	r2,-556(fp)
 2002e3c:	10887624 	muli	r2,r2,8664
 2002e40:	1885883a 	add	r2,r3,r2
 2002e44:	10800304 	addi	r2,r2,12
 2002e48:	10800017 	ldw	r2,0(r2)
 2002e4c:	10bfffe0 	cmpeqi	r2,r2,-1
 2002e50:	1000301e 	bne	r2,zero,2002f14 <WSTask+0x1dc>
      {
        /* We're interested in reading any of our active sockets */
        FD_SET(conn[i].fd, &readfds);
 2002e54:	00c08174 	movhi	r3,517
 2002e58:	18d0fe04 	addi	r3,r3,17400
 2002e5c:	e0bf7517 	ldw	r2,-556(fp)
 2002e60:	10887624 	muli	r2,r2,8664
 2002e64:	1885883a 	add	r2,r3,r2
 2002e68:	10800304 	addi	r2,r2,12
 2002e6c:	10c00017 	ldw	r3,0(r2)
 2002e70:	e0bf7e04 	addi	r2,fp,-520
 2002e74:	1809883a 	mov	r4,r3
 2002e78:	100b883a 	mov	r5,r2
 2002e7c:	203050c0 	call	203050c <ifd_set>
        
        /* 
         * We're interested in writing to any of our active sockets in the DATA
         * state
         */
        if(conn[i].state == DATA)
 2002e80:	00c08174 	movhi	r3,517
 2002e84:	18d0fe04 	addi	r3,r3,17400
 2002e88:	e0bf7517 	ldw	r2,-556(fp)
 2002e8c:	10887624 	muli	r2,r2,8664
 2002e90:	1885883a 	add	r2,r3,r2
 2002e94:	10800017 	ldw	r2,0(r2)
 2002e98:	10800098 	cmpnei	r2,r2,2
 2002e9c:	10000b1e 	bne	r2,zero,2002ecc <WSTask+0x194>
        {
          FD_SET(conn[i].fd, &writefds);
 2002ea0:	00c08174 	movhi	r3,517
 2002ea4:	18d0fe04 	addi	r3,r3,17400
 2002ea8:	e0bf7517 	ldw	r2,-556(fp)
 2002eac:	10887624 	muli	r2,r2,8664
 2002eb0:	1885883a 	add	r2,r3,r2
 2002eb4:	10800304 	addi	r2,r2,12
 2002eb8:	10c00017 	ldw	r3,0(r2)
 2002ebc:	e0bfbf04 	addi	r2,fp,-260
 2002ec0:	1809883a 	mov	r4,r3
 2002ec4:	100b883a 	mov	r5,r2
 2002ec8:	203050c0 	call	203050c <ifd_set>
        /*
         * select() must be called with the maximum number of sockets to look 
         * through. This will be the largest socket number + 1 (since we start
         * at zero).
         */
        if (max_socket <= conn[i].fd)
 2002ecc:	00c08174 	movhi	r3,517
 2002ed0:	18d0fe04 	addi	r3,r3,17400
 2002ed4:	e0bf7517 	ldw	r2,-556(fp)
 2002ed8:	10887624 	muli	r2,r2,8664
 2002edc:	1885883a 	add	r2,r3,r2
 2002ee0:	10800304 	addi	r2,r2,12
 2002ee4:	10c00017 	ldw	r3,0(r2)
 2002ee8:	e0bf7617 	ldw	r2,-552(fp)
 2002eec:	18800916 	blt	r3,r2,2002f14 <WSTask+0x1dc>
        {
          max_socket = conn[i].fd+1;
 2002ef0:	00c08174 	movhi	r3,517
 2002ef4:	18d0fe04 	addi	r3,r3,17400
 2002ef8:	e0bf7517 	ldw	r2,-556(fp)
 2002efc:	10887624 	muli	r2,r2,8664
 2002f00:	1885883a 	add	r2,r3,r2
 2002f04:	10800304 	addi	r2,r2,12
 2002f08:	10800017 	ldw	r2,0(r2)
 2002f0c:	10800044 	addi	r2,r2,1
 2002f10:	e0bf7615 	stw	r2,-552(fp)
    FD_ZERO(&writefds);
    FD_SET(fd_listen, &readfds);
    
    max_socket = fd_listen+1;
    
    for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2002f14:	e0bf7517 	ldw	r2,-556(fp)
 2002f18:	10800044 	addi	r2,r2,1
 2002f1c:	e0bf7515 	stw	r2,-556(fp)
 2002f20:	e0bf7517 	ldw	r2,-556(fp)
 2002f24:	10800190 	cmplti	r2,r2,6
 2002f28:	103fc11e 	bne	r2,zero,2002e30 <WSTask+0xf8>

    /* 
     * Set timeout value for select. This must be reset for each select()
     * call.
     */
    select_timeout.tv_sec = 0;
 2002f2c:	e03f7c15 	stw	zero,-528(fp)
    select_timeout.tv_usec = 500000;
 2002f30:	00800234 	movhi	r2,8
 2002f34:	10a84804 	addi	r2,r2,-24288
 2002f38:	e0bf7d15 	stw	r2,-524(fp)

    select(max_socket, &readfds, &writefds, NULL, &select_timeout);
 2002f3c:	e0ff7e04 	addi	r3,fp,-520
 2002f40:	e0bfbf04 	addi	r2,fp,-260
 2002f44:	e13f7c04 	addi	r4,fp,-528
 2002f48:	d9000015 	stw	r4,0(sp)
 2002f4c:	e13f7617 	ldw	r4,-552(fp)
 2002f50:	180b883a 	mov	r5,r3
 2002f54:	100d883a 	mov	r6,r2
 2002f58:	000f883a 	mov	r7,zero
 2002f5c:	20264bc0 	call	20264bc <bsd_select>
     * If fd_listen (the listening socket we originally created in this thread
     * is "set" in readfds, then we have an incoming connection request. 
     * We'll call a routine to explicitly accept or deny the incoming connection 
     * request.
     */
    if (FD_ISSET(fd_listen, &readfds))
 2002f60:	e0bf7e04 	addi	r2,fp,-520
 2002f64:	e13f7717 	ldw	r4,-548(fp)
 2002f68:	100b883a 	mov	r5,r2
 2002f6c:	20305800 	call	2030580 <ifd_isset>
 2002f70:	10000426 	beq	r2,zero,2002f84 <WSTask+0x24c>
    {
      http_handle_accept(fd_listen, conn);
 2002f74:	e13f7717 	ldw	r4,-548(fp)
 2002f78:	01408174 	movhi	r5,517
 2002f7c:	2950fe04 	addi	r5,r5,17400
 2002f80:	20012340 	call	2001234 <http_handle_accept>
     * in conn[i].fd. Therefore if conn[i].fd is set in readfs, we have
     * incoming data for our HTTP server, and we call our receive routine
     * to process it. Likewise, if conn[i].fd is set in writefds, we have
     * an open connection that is *capable* of being written to.
     */
    for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2002f84:	e03f7515 	stw	zero,-556(fp)
 2002f88:	00003c06 	br	200307c <WSTask+0x344>
    {
      if (conn[i].fd != -1)
 2002f8c:	00c08174 	movhi	r3,517
 2002f90:	18d0fe04 	addi	r3,r3,17400
 2002f94:	e0bf7517 	ldw	r2,-556(fp)
 2002f98:	10887624 	muli	r2,r2,8664
 2002f9c:	1885883a 	add	r2,r3,r2
 2002fa0:	10800304 	addi	r2,r2,12
 2002fa4:	10800017 	ldw	r2,0(r2)
 2002fa8:	10bfffe0 	cmpeqi	r2,r2,-1
 2002fac:	1000301e 	bne	r2,zero,2003070 <WSTask+0x338>
      { 
        if(FD_ISSET(conn[i].fd,&readfds))
 2002fb0:	00c08174 	movhi	r3,517
 2002fb4:	18d0fe04 	addi	r3,r3,17400
 2002fb8:	e0bf7517 	ldw	r2,-556(fp)
 2002fbc:	10887624 	muli	r2,r2,8664
 2002fc0:	1885883a 	add	r2,r3,r2
 2002fc4:	10800304 	addi	r2,r2,12
 2002fc8:	10c00017 	ldw	r3,0(r2)
 2002fcc:	e0bf7e04 	addi	r2,fp,-520
 2002fd0:	1809883a 	mov	r4,r3
 2002fd4:	100b883a 	mov	r5,r2
 2002fd8:	20305800 	call	2030580 <ifd_isset>
 2002fdc:	10000826 	beq	r2,zero,2003000 <WSTask+0x2c8>
        {
          http_handle_receive(&conn[i], i);
 2002fe0:	e0bf7517 	ldw	r2,-556(fp)
 2002fe4:	10c87624 	muli	r3,r2,8664
 2002fe8:	00808174 	movhi	r2,517
 2002fec:	1090fe04 	addi	r2,r2,17400
 2002ff0:	1885883a 	add	r2,r3,r2
 2002ff4:	1009883a 	mov	r4,r2
 2002ff8:	e17f7517 	ldw	r5,-556(fp)
 2002ffc:	20029140 	call	2002914 <http_handle_receive>
        }
        
        if(FD_ISSET(conn[i].fd,&writefds))
 2003000:	00c08174 	movhi	r3,517
 2003004:	18d0fe04 	addi	r3,r3,17400
 2003008:	e0bf7517 	ldw	r2,-556(fp)
 200300c:	10887624 	muli	r2,r2,8664
 2003010:	1885883a 	add	r2,r3,r2
 2003014:	10800304 	addi	r2,r2,12
 2003018:	10c00017 	ldw	r3,0(r2)
 200301c:	e0bfbf04 	addi	r2,fp,-260
 2003020:	1809883a 	mov	r4,r3
 2003024:	100b883a 	mov	r5,r2
 2003028:	20305800 	call	2030580 <ifd_isset>
 200302c:	10000826 	beq	r2,zero,2003050 <WSTask+0x318>
        {
          http_handle_transmit(&conn[i], i);
 2003030:	e0bf7517 	ldw	r2,-556(fp)
 2003034:	10c87624 	muli	r3,r2,8664
 2003038:	00808174 	movhi	r2,517
 200303c:	1090fe04 	addi	r2,r2,17400
 2003040:	1885883a 	add	r2,r3,r2
 2003044:	1009883a 	mov	r4,r2
 2003048:	e17f7517 	ldw	r5,-556(fp)
 200304c:	2002cd80 	call	2002cd8 <http_handle_transmit>
        }
        
        http_manage_connection(&conn[i], i);
 2003050:	e0bf7517 	ldw	r2,-556(fp)
 2003054:	10c87624 	muli	r3,r2,8664
 2003058:	00808174 	movhi	r2,517
 200305c:	1090fe04 	addi	r2,r2,17400
 2003060:	1885883a 	add	r2,r3,r2
 2003064:	1009883a 	mov	r4,r2
 2003068:	e17f7517 	ldw	r5,-556(fp)
 200306c:	20010980 	call	2001098 <http_manage_connection>
     * in conn[i].fd. Therefore if conn[i].fd is set in readfs, we have
     * incoming data for our HTTP server, and we call our receive routine
     * to process it. Likewise, if conn[i].fd is set in writefds, we have
     * an open connection that is *capable* of being written to.
     */
    for(i=0; i<HTTP_NUM_CONNECTIONS; i++)
 2003070:	e0bf7517 	ldw	r2,-556(fp)
 2003074:	10800044 	addi	r2,r2,1
 2003078:	e0bf7515 	stw	r2,-556(fp)
 200307c:	e0bf7517 	ldw	r2,-556(fp)
 2003080:	10800190 	cmplti	r2,r2,6
 2003084:	103fc11e 	bne	r2,zero,2002f8c <WSTask+0x254>
        }
        
        http_manage_connection(&conn[i], i);
      }
    }  
  } /* while(1) */
 2003088:	003f5e06 	br	2002e04 <WSTask+0xcc>

0200308c <die_with_error>:
 * 
 * This routine is just called when a blocking error occurs with the example
 * design. It deletes the current task.
 */
void die_with_error(char err_msg[DIE_WITH_ERROR_BUFFER])
{
 200308c:	defffd04 	addi	sp,sp,-12
 2003090:	dfc00215 	stw	ra,8(sp)
 2003094:	df000115 	stw	fp,4(sp)
 2003098:	df000104 	addi	fp,sp,4
 200309c:	e13fff15 	stw	r4,-4(fp)
  printf("\n%s\n", err_msg);
 20030a0:	01008174 	movhi	r4,517
 20030a4:	2133e904 	addi	r4,r4,-12380
 20030a8:	e17fff17 	ldw	r5,-4(fp)
 20030ac:	2006a240 	call	2006a24 <printf>
  OSTaskDel(OS_PRIO_SELF);
 20030b0:	01003fc4 	movi	r4,255
 20030b4:	201cff80 	call	201cff8 <OSTaskDel>
  
  while(1);
 20030b8:	003fff06 	br	20030b8 <die_with_error+0x2c>

020030bc <get_serial_number>:
*
* Prompt user to enter 9-digit serial number. 
*
*/
alt_u32 get_serial_number (void)
{
 20030bc:	defff904 	addi	sp,sp,-28
 20030c0:	dfc00615 	stw	ra,24(sp)
 20030c4:	df000515 	stw	fp,20(sp)
 20030c8:	df000504 	addi	fp,sp,20
    alt_u32 ser_num = 0;
 20030cc:	e03ffb15 	stw	zero,-20(fp)
    char serial_number[9];
    int i = 0;
 20030d0:	e03ffc15 	stw	zero,-16(fp)
    
    while(!ser_num)
 20030d4:	00006506 	br	200326c <get_serial_number+0x1b0>
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
 20030d8:	01008174 	movhi	r4,517
 20030dc:	2133eb04 	addi	r4,r4,-12372
 20030e0:	2006cb40 	call	2006cb4 <puts>
        printf("label under your Nios dev. board. The first 3 digits of the \n");
 20030e4:	01008174 	movhi	r4,517
 20030e8:	2133fb04 	addi	r4,r4,-12308
 20030ec:	2006cb40 	call	2006cb4 <puts>
        printf("label are ASJ and the serial number follows this.\n -->");
 20030f0:	01008174 	movhi	r4,517
 20030f4:	21340b04 	addi	r4,r4,-12244
 20030f8:	2006a240 	call	2006a24 <printf>
        
        for(i=0; i<9; i++)
 20030fc:	e03ffc15 	stw	zero,-16(fp)
 2003100:	00002a06 	br	20031ac <get_serial_number+0xf0>
        {
            serial_number[i] = getchar();
 2003104:	00808174 	movhi	r2,517
 2003108:	10903604 	addi	r2,r2,16600
 200310c:	10800017 	ldw	r2,0(r2)
 2003110:	10800117 	ldw	r2,4(r2)
 2003114:	1009883a 	mov	r4,r2
 2003118:	2005c580 	call	2005c58 <getc>
 200311c:	1007883a 	mov	r3,r2
 2003120:	e13ffd04 	addi	r4,fp,-12
 2003124:	e0bffc17 	ldw	r2,-16(fp)
 2003128:	2085883a 	add	r2,r4,r2
 200312c:	10c00005 	stb	r3,0(r2)
            putchar(serial_number[i]);
 2003130:	e0fffd04 	addi	r3,fp,-12
 2003134:	e0bffc17 	ldw	r2,-16(fp)
 2003138:	1885883a 	add	r2,r3,r2
 200313c:	10800003 	ldbu	r2,0(r2)
 2003140:	10c03fcc 	andi	r3,r2,255
 2003144:	18c0201c 	xori	r3,r3,128
 2003148:	18ffe004 	addi	r3,r3,-128
 200314c:	00808174 	movhi	r2,517
 2003150:	10903604 	addi	r2,r2,16600
 2003154:	10800017 	ldw	r2,0(r2)
 2003158:	10800217 	ldw	r2,8(r2)
 200315c:	1809883a 	mov	r4,r3
 2003160:	100b883a 	mov	r5,r2
 2003164:	2006b1c0 	call	2006b1c <putc>
            
            /* Handle backspaces.  How civilized. */
            if ((serial_number[i] == 0x08) && (i >= 0)) 
 2003168:	e0fffd04 	addi	r3,fp,-12
 200316c:	e0bffc17 	ldw	r2,-16(fp)
 2003170:	1885883a 	add	r2,r3,r2
 2003174:	10800003 	ldbu	r2,0(r2)
 2003178:	10803fcc 	andi	r2,r2,255
 200317c:	1080201c 	xori	r2,r2,128
 2003180:	10bfe004 	addi	r2,r2,-128
 2003184:	10800218 	cmpnei	r2,r2,8
 2003188:	1000051e 	bne	r2,zero,20031a0 <get_serial_number+0xe4>
 200318c:	e0bffc17 	ldw	r2,-16(fp)
 2003190:	10000316 	blt	r2,zero,20031a0 <get_serial_number+0xe4>
            {
                i--;
 2003194:	e0bffc17 	ldw	r2,-16(fp)
 2003198:	10bfffc4 	addi	r2,r2,-1
 200319c:	e0bffc15 	stw	r2,-16(fp)
    {
        printf("Please enter your 9-digit serial number. This is printed on a \n");
        printf("label under your Nios dev. board. The first 3 digits of the \n");
        printf("label are ASJ and the serial number follows this.\n -->");
        
        for(i=0; i<9; i++)
 20031a0:	e0bffc17 	ldw	r2,-16(fp)
 20031a4:	10800044 	addi	r2,r2,1
 20031a8:	e0bffc15 	stw	r2,-16(fp)
 20031ac:	e0bffc17 	ldw	r2,-16(fp)
 20031b0:	10800250 	cmplti	r2,r2,9
 20031b4:	103fd31e 	bne	r2,zero,2003104 <get_serial_number+0x48>
            if ((serial_number[i] == 0x08) && (i >= 0)) 
            {
                i--;
            }
        }
        printf("\n");
 20031b8:	01000284 	movi	r4,10
 20031bc:	2006c140 	call	2006c14 <putchar>
                
        for(i=0; i<9; i++)
 20031c0:	e03ffc15 	stw	zero,-16(fp)
 20031c4:	00002606 	br	2003260 <get_serial_number+0x1a4>
        {
            if (isdigit(serial_number[i]))
 20031c8:	00808174 	movhi	r2,517
 20031cc:	10903404 	addi	r2,r2,16592
 20031d0:	10c00017 	ldw	r3,0(r2)
 20031d4:	e13ffd04 	addi	r4,fp,-12
 20031d8:	e0bffc17 	ldw	r2,-16(fp)
 20031dc:	2085883a 	add	r2,r4,r2
 20031e0:	10800003 	ldbu	r2,0(r2)
 20031e4:	10803fcc 	andi	r2,r2,255
 20031e8:	1080201c 	xori	r2,r2,128
 20031ec:	10bfe004 	addi	r2,r2,-128
 20031f0:	1885883a 	add	r2,r3,r2
 20031f4:	10800003 	ldbu	r2,0(r2)
 20031f8:	10803fcc 	andi	r2,r2,255
 20031fc:	1080010c 	andi	r2,r2,4
 2003200:	10001226 	beq	r2,zero,200324c <get_serial_number+0x190>
            {
                ser_num *= 10;
 2003204:	e0bffb17 	ldw	r2,-20(fp)
 2003208:	108002a4 	muli	r2,r2,10
 200320c:	e0bffb15 	stw	r2,-20(fp)
                ser_num += serial_number[i] - '0';
 2003210:	e0fffd04 	addi	r3,fp,-12
 2003214:	e0bffc17 	ldw	r2,-16(fp)
 2003218:	1885883a 	add	r2,r3,r2
 200321c:	10800003 	ldbu	r2,0(r2)
 2003220:	10c03fcc 	andi	r3,r2,255
 2003224:	18c0201c 	xori	r3,r3,128
 2003228:	18ffe004 	addi	r3,r3,-128
 200322c:	e0bffb17 	ldw	r2,-20(fp)
 2003230:	1885883a 	add	r2,r3,r2
 2003234:	10bff404 	addi	r2,r2,-48
 2003238:	e0bffb15 	stw	r2,-20(fp)
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 200323c:	e0bffc17 	ldw	r2,-16(fp)
 2003240:	10800044 	addi	r2,r2,1
 2003244:	e0bffc15 	stw	r2,-16(fp)
 2003248:	00000506 	br	2003260 <get_serial_number+0x1a4>
                ser_num *= 10;
                ser_num += serial_number[i] - '0';
            }
            else
            {
                ser_num = 0;
 200324c:	e03ffb15 	stw	zero,-20(fp)
                printf("Serial number only contains decimal digits and is non-zero\n");
 2003250:	01008174 	movhi	r4,517
 2003254:	21341904 	addi	r4,r4,-12188
 2003258:	2006cb40 	call	2006cb4 <puts>
                break;
 200325c:	00000306 	br	200326c <get_serial_number+0x1b0>
                i--;
            }
        }
        printf("\n");
                
        for(i=0; i<9; i++)
 2003260:	e0bffc17 	ldw	r2,-16(fp)
 2003264:	10800250 	cmplti	r2,r2,9
 2003268:	103fd71e 	bne	r2,zero,20031c8 <get_serial_number+0x10c>
{
    alt_u32 ser_num = 0;
    char serial_number[9];
    int i = 0;
    
    while(!ser_num)
 200326c:	e0bffb17 	ldw	r2,-20(fp)
 2003270:	103f9926 	beq	r2,zero,20030d8 <get_serial_number+0x1c>
                break;
            }
        }
    }
    
    return ser_num;
 2003274:	e0bffb17 	ldw	r2,-20(fp)
}
 2003278:	e037883a 	mov	sp,fp
 200327c:	dfc00117 	ldw	ra,4(sp)
 2003280:	df000017 	ldw	fp,0(sp)
 2003284:	dec00204 	addi	sp,sp,8
 2003288:	f800283a 	ret

0200328c <generate_and_store_mac_addr>:
 * sections. These fail-safe static settings are compatible with previous
 * Nios Ethernet designs, and allow the "factory-safe" design to behave 
 * as expected if the last flash sector is erased.
 */
error_t generate_and_store_mac_addr()
{
 200328c:	deffef04 	addi	sp,sp,-68
 2003290:	dfc01015 	stw	ra,64(sp)
 2003294:	df000f15 	stw	fp,60(sp)
 2003298:	df000f04 	addi	fp,sp,60
    error_t error = -1;
 200329c:	00bfffc4 	movi	r2,-1
 20032a0:	e0bff115 	stw	r2,-60(fp)
    alt_u32 ser_num = 0;
 20032a4:	e03ff215 	stw	zero,-56(fp)
    char flash_content[32];
    alt_flash_fd* flash_handle;
    
    printf("Can't read the MAC address from your board (this probably means\n");
 20032a8:	01008174 	movhi	r4,517
 20032ac:	21342804 	addi	r4,r4,-12128
 20032b0:	2006cb40 	call	2006cb4 <puts>
    printf("that your flash was erased). We will assign you a MAC address and\n");
 20032b4:	01008174 	movhi	r4,517
 20032b8:	21343804 	addi	r4,r4,-12064
 20032bc:	2006cb40 	call	2006cb4 <puts>
    printf("static network settings\n\n");
 20032c0:	01008174 	movhi	r4,517
 20032c4:	21344904 	addi	r4,r4,-11996
 20032c8:	2006cb40 	call	2006cb4 <puts>
    
    ser_num = get_serial_number();
 20032cc:	20030bc0 	call	20030bc <get_serial_number>
 20032d0:	e0bff215 	stw	r2,-56(fp)
  
    if (ser_num)
 20032d4:	e0bff217 	ldw	r2,-56(fp)
 20032d8:	10005626 	beq	r2,zero,2003434 <generate_and_store_mac_addr+0x1a8>
    {
        /* This says the image is safe */
        flash_content[0] = 0xfe;
 20032dc:	00bfff84 	movi	r2,-2
 20032e0:	e0bff805 	stb	r2,-32(fp)
        flash_content[1] = 0x5a;
 20032e4:	00801684 	movi	r2,90
 20032e8:	e0bff845 	stb	r2,-31(fp)
        flash_content[2] = 0x0;
 20032ec:	e03ff885 	stb	zero,-30(fp)
        flash_content[3] = 0x0;
 20032f0:	e03ff8c5 	stb	zero,-29(fp)
        
        /* This is the Altera Vendor ID */
        flash_content[4] = 0x0;
 20032f4:	e03ff905 	stb	zero,-28(fp)
        flash_content[5] = 0x7;
 20032f8:	008001c4 	movi	r2,7
 20032fc:	e0bff945 	stb	r2,-27(fp)
        flash_content[6] = 0xed;
 2003300:	00bffb44 	movi	r2,-19
 2003304:	e0bff985 	stb	r2,-26(fp)
        
        /* Reserverd Board identifier for erase boards */
        flash_content[7] = 0xFF;
 2003308:	00bfffc4 	movi	r2,-1
 200330c:	e0bff9c5 	stb	r2,-25(fp)
        flash_content[8] = (ser_num & 0xff00) >> 8;
 2003310:	e0bff217 	ldw	r2,-56(fp)
 2003314:	10bfc00c 	andi	r2,r2,65280
 2003318:	1004d23a 	srli	r2,r2,8
 200331c:	e0bffa05 	stb	r2,-24(fp)
        flash_content[9] = ser_num & 0xff;
 2003320:	e0bff217 	ldw	r2,-56(fp)
 2003324:	e0bffa45 	stb	r2,-23(fp)
        
        /* Then comes a 16-bit "flags" field */
        flash_content[10] = 0xFF;
 2003328:	00bfffc4 	movi	r2,-1
 200332c:	e0bffa85 	stb	r2,-22(fp)
        flash_content[11] = 0xFF;
 2003330:	00bfffc4 	movi	r2,-1
 2003334:	e0bffac5 	stb	r2,-21(fp)
        
        /* Then comes the static IP address */
        flash_content[12] = IPADDR0;
 2003338:	00bff004 	movi	r2,-64
 200333c:	e0bffb05 	stb	r2,-20(fp)
        flash_content[13] = IPADDR1;
 2003340:	00bfea04 	movi	r2,-88
 2003344:	e0bffb45 	stb	r2,-19(fp)
        flash_content[14] = IPADDR2;
 2003348:	00800044 	movi	r2,1
 200334c:	e0bffb85 	stb	r2,-18(fp)
        flash_content[15] = IPADDR3;
 2003350:	00bffa84 	movi	r2,-22
 2003354:	e0bffbc5 	stb	r2,-17(fp)
        
        /* Then comes the static nameserver address */
        flash_content[16] = 0xFF;
 2003358:	00bfffc4 	movi	r2,-1
 200335c:	e0bffc05 	stb	r2,-16(fp)
        flash_content[17] = 0xFF;
 2003360:	00bfffc4 	movi	r2,-1
 2003364:	e0bffc45 	stb	r2,-15(fp)
        flash_content[18] = 0xFF;
 2003368:	00bfffc4 	movi	r2,-1
 200336c:	e0bffc85 	stb	r2,-14(fp)
        flash_content[19] = 0xFF;
 2003370:	00bfffc4 	movi	r2,-1
 2003374:	e0bffcc5 	stb	r2,-13(fp)
        
        /* Then comes the static subnet mask */
        flash_content[20] = MSKADDR0;
 2003378:	00bfffc4 	movi	r2,-1
 200337c:	e0bffd05 	stb	r2,-12(fp)
        flash_content[21] = MSKADDR1;
 2003380:	00bfffc4 	movi	r2,-1
 2003384:	e0bffd45 	stb	r2,-11(fp)
        flash_content[22] = MSKADDR2;
 2003388:	00bfffc4 	movi	r2,-1
 200338c:	e0bffd85 	stb	r2,-10(fp)
        flash_content[23] = MSKADDR3;
 2003390:	e03ffdc5 	stb	zero,-9(fp)
        
        /* Then comes the static gateway address */
        flash_content[24] = GWADDR0;
 2003394:	00bff004 	movi	r2,-64
 2003398:	e0bffe05 	stb	r2,-8(fp)
        flash_content[25] = GWADDR1;
 200339c:	00bfea04 	movi	r2,-88
 20033a0:	e0bffe45 	stb	r2,-7(fp)
        flash_content[26] = GWADDR2;
 20033a4:	00800044 	movi	r2,1
 20033a8:	e0bffe85 	stb	r2,-6(fp)
        flash_content[27] = GWADDR3;
 20033ac:	00800044 	movi	r2,1
 20033b0:	e0bffec5 	stb	r2,-5(fp)
        
        /* And finally whether to use DHCP - set all bits to be safe */
        flash_content[28] = 0xFF;
 20033b4:	00bfffc4 	movi	r2,-1
 20033b8:	e0bfff05 	stb	r2,-4(fp)
        flash_content[29] = 0xFF;
 20033bc:	00bfffc4 	movi	r2,-1
 20033c0:	e0bfff45 	stb	r2,-3(fp)
        flash_content[30] = 0xFF;
 20033c4:	00bfffc4 	movi	r2,-1
 20033c8:	e0bfff85 	stb	r2,-2(fp)
        flash_content[31] = 0xFF;
 20033cc:	00bfffc4 	movi	r2,-1
 20033d0:	e0bfffc5 	stb	r2,-1(fp)
        
        /* Write the MAC address to flash */
        flash_handle = alt_flash_open_dev(EPCS_FLASH_CONTROLLER_NAME);
 20033d4:	01008174 	movhi	r4,517
 20033d8:	21345004 	addi	r4,r4,-11968
 20033dc:	20150280 	call	2015028 <alt_flash_open_dev>
 20033e0:	e0bff315 	stw	r2,-52(fp)
        if (flash_handle)
 20033e4:	e0bff317 	ldw	r2,-52(fp)
 20033e8:	10001226 	beq	r2,zero,2003434 <generate_and_store_mac_addr+0x1a8>
        {
            alt_write_flash(flash_handle,
 20033ec:	d0a05b17 	ldw	r2,-32404(gp)
 20033f0:	e0fff317 	ldw	r3,-52(fp)
 20033f4:	e0fff415 	stw	r3,-48(fp)
 20033f8:	e0bff515 	stw	r2,-44(fp)
                            last_flash_sector_offset,
                            flash_content,
 20033fc:	e0bff804 	addi	r2,fp,-32
 2003400:	e0bff615 	stw	r2,-40(fp)
 2003404:	00800804 	movi	r2,32
 2003408:	e0bff715 	stw	r2,-36(fp)
                                                           alt_flash_fd* fd, 
                                                           int offset, 
                                                           const void* src_addr, 
                                                           int length )
{
  return fd->write( fd, offset, src_addr, length );
 200340c:	e0bff417 	ldw	r2,-48(fp)
 2003410:	10800517 	ldw	r2,20(r2)
 2003414:	e13ff417 	ldw	r4,-48(fp)
 2003418:	e17ff517 	ldw	r5,-44(fp)
 200341c:	e1bff617 	ldw	r6,-40(fp)
 2003420:	e1fff717 	ldw	r7,-36(fp)
 2003424:	103ee83a 	callr	r2
                            32);
            alt_flash_close_dev(flash_handle);
 2003428:	e13ff317 	ldw	r4,-52(fp)
 200342c:	20150900 	call	2015090 <alt_flash_close_dev>
            error = 0;
 2003430:	e03ff115 	stw	zero,-60(fp)
        }
    }

    return error;    
 2003434:	e0bff117 	ldw	r2,-60(fp)
}
 2003438:	e037883a 	mov	sp,fp
 200343c:	dfc00117 	ldw	ra,4(sp)
 2003440:	df000017 	ldw	fp,0(sp)
 2003444:	dec00204 	addi	sp,sp,8
 2003448:	f800283a 	ret

0200344c <generate_mac_addr>:
 * Development Board serial number is 040800017, the corresponding ethernet 
 * number generated will be 00:07:ED:FF:8F:11.
 * 
 */
error_t generate_mac_addr(unsigned char mac_addr[6])
{
 200344c:	defff804 	addi	sp,sp,-32
 2003450:	dfc00715 	stw	ra,28(sp)
 2003454:	df000615 	stw	fp,24(sp)
 2003458:	df000604 	addi	fp,sp,24
 200345c:	e13fff15 	stw	r4,-4(fp)
    error_t error = -1;
 2003460:	00bfffc4 	movi	r2,-1
 2003464:	e0bffd15 	stw	r2,-12(fp)
    alt_u32 ser_num = 0;
 2003468:	e03ffe15 	stw	zero,-8(fp)
    
    printf("\nCan't read the MAC address from your board. We will assign you\n");
 200346c:	01008174 	movhi	r4,517
 2003470:	21345704 	addi	r4,r4,-11940
 2003474:	2006cb40 	call	2006cb4 <puts>
    printf("a MAC address.\n\n");
 2003478:	01008174 	movhi	r4,517
 200347c:	21346704 	addi	r4,r4,-11876
 2003480:	2006cb40 	call	2006cb4 <puts>
    
    ser_num = get_serial_number();
 2003484:	20030bc0 	call	20030bc <get_serial_number>
 2003488:	e0bffe15 	stw	r2,-8(fp)
  
    if (ser_num)
 200348c:	e0bffe17 	ldw	r2,-8(fp)
 2003490:	10003826 	beq	r2,zero,2003574 <generate_mac_addr+0x128>
    {
        /* This is the Altera Vendor ID */
        mac_addr[0] = 0x0;
 2003494:	e0bfff17 	ldw	r2,-4(fp)
 2003498:	10000005 	stb	zero,0(r2)
        mac_addr[1] = 0x7;
 200349c:	e0bfff17 	ldw	r2,-4(fp)
 20034a0:	10800044 	addi	r2,r2,1
 20034a4:	00c001c4 	movi	r3,7
 20034a8:	10c00005 	stb	r3,0(r2)
        mac_addr[2] = 0xed;
 20034ac:	e0bfff17 	ldw	r2,-4(fp)
 20034b0:	10800084 	addi	r2,r2,2
 20034b4:	00fffb44 	movi	r3,-19
 20034b8:	10c00005 	stb	r3,0(r2)
        
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
 20034bc:	e0bfff17 	ldw	r2,-4(fp)
 20034c0:	108000c4 	addi	r2,r2,3
 20034c4:	00ffffc4 	movi	r3,-1
 20034c8:	10c00005 	stb	r3,0(r2)
        mac_addr[4] = (ser_num & 0xff00) >> 8;
 20034cc:	e0bfff17 	ldw	r2,-4(fp)
 20034d0:	10800104 	addi	r2,r2,4
 20034d4:	e0fffe17 	ldw	r3,-8(fp)
 20034d8:	18ffc00c 	andi	r3,r3,65280
 20034dc:	1806d23a 	srli	r3,r3,8
 20034e0:	10c00005 	stb	r3,0(r2)
        mac_addr[5] = ser_num & 0xff;
 20034e4:	e0bfff17 	ldw	r2,-4(fp)
 20034e8:	10800144 	addi	r2,r2,5
 20034ec:	e0fffe17 	ldw	r3,-8(fp)
 20034f0:	10c00005 	stb	r3,0(r2)
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
            mac_addr[0],
 20034f4:	e0bfff17 	ldw	r2,-4(fp)
 20034f8:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 20034fc:	11403fcc 	andi	r5,r2,255
            mac_addr[0],
            mac_addr[1],
 2003500:	e0bfff17 	ldw	r2,-4(fp)
 2003504:	10800044 	addi	r2,r2,1
 2003508:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 200350c:	10c03fcc 	andi	r3,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 2003510:	e0bfff17 	ldw	r2,-4(fp)
 2003514:	10800084 	addi	r2,r2,2
 2003518:	10800003 	ldbu	r2,0(r2)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 200351c:	10803fcc 	andi	r2,r2,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 2003520:	e13fff17 	ldw	r4,-4(fp)
 2003524:	210000c4 	addi	r4,r4,3
 2003528:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 200352c:	21c03fcc 	andi	r7,r4,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 2003530:	e13fff17 	ldw	r4,-4(fp)
 2003534:	21000104 	addi	r4,r4,4
 2003538:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 200353c:	21803fcc 	andi	r6,r4,255
            mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 2003540:	e13fff17 	ldw	r4,-4(fp)
 2003544:	21000144 	addi	r4,r4,5
 2003548:	21000003 	ldbu	r4,0(r4)
        /* Reserverd Board identifier */
        mac_addr[3] = 0xFF;
        mac_addr[4] = (ser_num & 0xff00) >> 8;
        mac_addr[5] = ser_num & 0xff;
        
        printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 200354c:	21003fcc 	andi	r4,r4,255
 2003550:	d9c00015 	stw	r7,0(sp)
 2003554:	d9800115 	stw	r6,4(sp)
 2003558:	d9000215 	stw	r4,8(sp)
 200355c:	01008174 	movhi	r4,517
 2003560:	21346b04 	addi	r4,r4,-11860
 2003564:	180d883a 	mov	r6,r3
 2003568:	100f883a 	mov	r7,r2
 200356c:	2006a240 	call	2006a24 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
        
        error = 0;
 2003570:	e03ffd15 	stw	zero,-12(fp)
    }
  
    return error;    
 2003574:	e0bffd17 	ldw	r2,-12(fp)
}
 2003578:	e037883a 	mov	sp,fp
 200357c:	dfc00117 	ldw	ra,4(sp)
 2003580:	df000017 	ldw	fp,0(sp)
 2003584:	dec00204 	addi	sp,sp,8
 2003588:	f800283a 	ret

0200358c <get_board_mac_addr>:
 *
 * Read the MAC address in a board specific way
 *
 */
error_t get_board_mac_addr(unsigned char mac_addr[6])
{
 200358c:	defff904 	addi	sp,sp,-28
 2003590:	dfc00615 	stw	ra,24(sp)
 2003594:	df000515 	stw	fp,20(sp)
 2003598:	df000504 	addi	fp,sp,20
 200359c:	e13fff15 	stw	r4,-4(fp)
	error_t error = 0;
 20035a0:	e03ffe15 	stw	zero,-8(fp)

    mac_addr[0] = 40;
 20035a4:	e0bfff17 	ldw	r2,-4(fp)
 20035a8:	00c00a04 	movi	r3,40
 20035ac:	10c00005 	stb	r3,0(r2)
    mac_addr[1] = 51;
 20035b0:	e0bfff17 	ldw	r2,-4(fp)
 20035b4:	10800044 	addi	r2,r2,1
 20035b8:	00c00cc4 	movi	r3,51
 20035bc:	10c00005 	stb	r3,0(r2)
    mac_addr[2] = 62;
 20035c0:	e0bfff17 	ldw	r2,-4(fp)
 20035c4:	10800084 	addi	r2,r2,2
 20035c8:	00c00f84 	movi	r3,62
 20035cc:	10c00005 	stb	r3,0(r2)
    mac_addr[3] = 77;
 20035d0:	e0bfff17 	ldw	r2,-4(fp)
 20035d4:	108000c4 	addi	r2,r2,3
 20035d8:	00c01344 	movi	r3,77
 20035dc:	10c00005 	stb	r3,0(r2)
    mac_addr[4] = 89;
 20035e0:	e0bfff17 	ldw	r2,-4(fp)
 20035e4:	10800104 	addi	r2,r2,4
 20035e8:	00c01644 	movi	r3,89
 20035ec:	10c00005 	stb	r3,0(r2)
    mac_addr[5] = 90;
 20035f0:	e0bfff17 	ldw	r2,-4(fp)
 20035f4:	10800144 	addi	r2,r2,5
 20035f8:	00c01684 	movi	r3,90
 20035fc:	10c00005 	stb	r3,0(r2)
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
    		mac_addr[0],
 2003600:	e0bfff17 	ldw	r2,-4(fp)
 2003604:	10800003 	ldbu	r2,0(r2)
    mac_addr[2] = 62;
    mac_addr[3] = 77;
    mac_addr[4] = 89;
    mac_addr[5] = 90;
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 2003608:	11403fcc 	andi	r5,r2,255
    		mac_addr[0],
            mac_addr[1],
 200360c:	e0bfff17 	ldw	r2,-4(fp)
 2003610:	10800044 	addi	r2,r2,1
 2003614:	10800003 	ldbu	r2,0(r2)
    mac_addr[2] = 62;
    mac_addr[3] = 77;
    mac_addr[4] = 89;
    mac_addr[5] = 90;
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 2003618:	10c03fcc 	andi	r3,r2,255
    		mac_addr[0],
            mac_addr[1],
            mac_addr[2],
 200361c:	e0bfff17 	ldw	r2,-4(fp)
 2003620:	10800084 	addi	r2,r2,2
 2003624:	10800003 	ldbu	r2,0(r2)
    mac_addr[2] = 62;
    mac_addr[3] = 77;
    mac_addr[4] = 89;
    mac_addr[5] = 90;
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 2003628:	10803fcc 	andi	r2,r2,255
    		mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
 200362c:	e13fff17 	ldw	r4,-4(fp)
 2003630:	210000c4 	addi	r4,r4,3
 2003634:	21000003 	ldbu	r4,0(r4)
    mac_addr[2] = 62;
    mac_addr[3] = 77;
    mac_addr[4] = 89;
    mac_addr[5] = 90;
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 2003638:	21c03fcc 	andi	r7,r4,255
    		mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
 200363c:	e13fff17 	ldw	r4,-4(fp)
 2003640:	21000104 	addi	r4,r4,4
 2003644:	21000003 	ldbu	r4,0(r4)
    mac_addr[2] = 62;
    mac_addr[3] = 77;
    mac_addr[4] = 89;
    mac_addr[5] = 90;
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 2003648:	21803fcc 	andi	r6,r4,255
    		mac_addr[0],
            mac_addr[1],
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);
 200364c:	e13fff17 	ldw	r4,-4(fp)
 2003650:	21000144 	addi	r4,r4,5
 2003654:	21000003 	ldbu	r4,0(r4)
    mac_addr[2] = 62;
    mac_addr[3] = 77;
    mac_addr[4] = 89;
    mac_addr[5] = 90;
    
    printf("Your Ethernet MAC address is %02x:%02x:%02x:%02x:%02x:%02x\n", 
 2003658:	21003fcc 	andi	r4,r4,255
 200365c:	d9c00015 	stw	r7,0(sp)
 2003660:	d9800115 	stw	r6,4(sp)
 2003664:	d9000215 	stw	r4,8(sp)
 2003668:	01008174 	movhi	r4,517
 200366c:	21346b04 	addi	r4,r4,-11860
 2003670:	180d883a 	mov	r6,r3
 2003674:	100f883a 	mov	r7,r2
 2003678:	2006a240 	call	2006a24 <printf>
            mac_addr[2],
            mac_addr[3],
            mac_addr[4],
            mac_addr[5]);

    return error;
 200367c:	e0bffe17 	ldw	r2,-8(fp)
}
 2003680:	e037883a 	mov	sp,fp
 2003684:	dfc00117 	ldw	ra,4(sp)
 2003688:	df000017 	ldw	fp,0(sp)
 200368c:	dec00204 	addi	sp,sp,8
 2003690:	f800283a 	ret

02003694 <get_mac_addr>:
*
* Read the MAC address in a board specific way
*
*/
int get_mac_addr(NET net, unsigned char mac_addr[6])
{
 2003694:	defffb04 	addi	sp,sp,-20
 2003698:	dfc00415 	stw	ra,16(sp)
 200369c:	df000315 	stw	fp,12(sp)
 20036a0:	df000304 	addi	fp,sp,12
 20036a4:	e13ffe15 	stw	r4,-8(fp)
 20036a8:	e17fff15 	stw	r5,-4(fp)
    error_t error = 0;
 20036ac:	e03ffd15 	stw	zero,-12(fp)
    
    error = get_board_mac_addr(mac_addr);
 20036b0:	e13fff17 	ldw	r4,-4(fp)
 20036b4:	200358c0 	call	200358c <get_board_mac_addr>
 20036b8:	e0bffd15 	stw	r2,-12(fp)
    
    if(error)
 20036bc:	e0bffd17 	ldw	r2,-12(fp)
 20036c0:	10000326 	beq	r2,zero,20036d0 <get_mac_addr+0x3c>
    {
        /* Failed read MAC address from flash, prompt user to enter serial 
           number to generate MAC address. */
        error = generate_mac_addr(mac_addr);
 20036c4:	e13fff17 	ldw	r4,-4(fp)
 20036c8:	200344c0 	call	200344c <generate_mac_addr>
 20036cc:	e0bffd15 	stw	r2,-12(fp)
    }
    return error;
 20036d0:	e0bffd17 	ldw	r2,-12(fp)
}
 20036d4:	e037883a 	mov	sp,fp
 20036d8:	dfc00117 	ldw	ra,4(sp)
 20036dc:	df000017 	ldw	fp,0(sp)
 20036e0:	dec00204 	addi	sp,sp,8
 20036e4:	f800283a 	ret

020036e8 <get_ip_addr>:
int get_ip_addr(alt_iniche_dev *p_dev,
                ip_addr* ipaddr,
                ip_addr* netmask,
                ip_addr* gw,
                int* use_dhcp)
{
 20036e8:	defff904 	addi	sp,sp,-28
 20036ec:	dfc00615 	stw	ra,24(sp)
 20036f0:	df000515 	stw	fp,20(sp)
 20036f4:	df000504 	addi	fp,sp,20
 20036f8:	e13ffc15 	stw	r4,-16(fp)
 20036fc:	e17ffd15 	stw	r5,-12(fp)
 2003700:	e1bffe15 	stw	r6,-8(fp)
 2003704:	e1ffff15 	stw	r7,-4(fp)

    IP4_ADDR(*ipaddr, IPADDR0, IPADDR1, IPADDR2, IPADDR3);
 2003708:	e0bffd17 	ldw	r2,-12(fp)
 200370c:	00fa80b4 	movhi	r3,59906
 2003710:	18ea3004 	addi	r3,r3,-22336
 2003714:	10c00015 	stw	r3,0(r2)
    IP4_ADDR(*gw, GWADDR0, GWADDR1, GWADDR2, GWADDR3);
 2003718:	e0bfff17 	ldw	r2,-4(fp)
 200371c:	00c040b4 	movhi	r3,258
 2003720:	18ea3004 	addi	r3,r3,-22336
 2003724:	10c00015 	stw	r3,0(r2)
    IP4_ADDR(*netmask, MSKADDR0, MSKADDR1, MSKADDR2, MSKADDR3);
 2003728:	e0bffe17 	ldw	r2,-8(fp)
 200372c:	00c04034 	movhi	r3,256
 2003730:	18ffffc4 	addi	r3,r3,-1
 2003734:	10c00015 	stw	r3,0(r2)

#ifdef DHCP_CLIENT
    *use_dhcp = 1;
#else /* not DHCP_CLIENT */
    *use_dhcp = 0;
 2003738:	e0800217 	ldw	r2,8(fp)
 200373c:	10000015 	stw	zero,0(r2)

    printf("Static IP Address is %d.%d.%d.%d\n",
        ip4_addr1(*ipaddr),
 2003740:	e0bffd17 	ldw	r2,-12(fp)
 2003744:	10800017 	ldw	r2,0(r2)
 2003748:	1006d63a 	srli	r3,r2,24
 200374c:	e0bffd17 	ldw	r2,-12(fp)
 2003750:	10800017 	ldw	r2,0(r2)
 2003754:	1004d23a 	srli	r2,r2,8
 2003758:	10bfc00c 	andi	r2,r2,65280
 200375c:	1886b03a 	or	r3,r3,r2
 2003760:	e0bffd17 	ldw	r2,-12(fp)
 2003764:	10800017 	ldw	r2,0(r2)
 2003768:	10bfc00c 	andi	r2,r2,65280
 200376c:	1004923a 	slli	r2,r2,8
 2003770:	1886b03a 	or	r3,r3,r2
 2003774:	e0bffd17 	ldw	r2,-12(fp)
 2003778:	10800017 	ldw	r2,0(r2)
 200377c:	1004963a 	slli	r2,r2,24
 2003780:	1884b03a 	or	r2,r3,r2
 2003784:	100ad63a 	srli	r5,r2,24
        ip4_addr2(*ipaddr),
 2003788:	e0bffd17 	ldw	r2,-12(fp)
 200378c:	10800017 	ldw	r2,0(r2)
 2003790:	1006d63a 	srli	r3,r2,24
 2003794:	e0bffd17 	ldw	r2,-12(fp)
 2003798:	10800017 	ldw	r2,0(r2)
 200379c:	1004d23a 	srli	r2,r2,8
 20037a0:	10bfc00c 	andi	r2,r2,65280
 20037a4:	1886b03a 	or	r3,r3,r2
 20037a8:	e0bffd17 	ldw	r2,-12(fp)
 20037ac:	10800017 	ldw	r2,0(r2)
 20037b0:	10bfc00c 	andi	r2,r2,65280
 20037b4:	1004923a 	slli	r2,r2,8
 20037b8:	1886b03a 	or	r3,r3,r2
 20037bc:	e0bffd17 	ldw	r2,-12(fp)
 20037c0:	10800017 	ldw	r2,0(r2)
 20037c4:	1004963a 	slli	r2,r2,24
 20037c8:	1884b03a 	or	r2,r3,r2
 20037cc:	1004d43a 	srli	r2,r2,16
#ifdef DHCP_CLIENT
    *use_dhcp = 1;
#else /* not DHCP_CLIENT */
    *use_dhcp = 0;

    printf("Static IP Address is %d.%d.%d.%d\n",
 20037d0:	10c03fcc 	andi	r3,r2,255
        ip4_addr1(*ipaddr),
        ip4_addr2(*ipaddr),
        ip4_addr3(*ipaddr),
 20037d4:	e0bffd17 	ldw	r2,-12(fp)
 20037d8:	10800017 	ldw	r2,0(r2)
 20037dc:	1008d63a 	srli	r4,r2,24
 20037e0:	e0bffd17 	ldw	r2,-12(fp)
 20037e4:	10800017 	ldw	r2,0(r2)
 20037e8:	1004d23a 	srli	r2,r2,8
 20037ec:	10bfc00c 	andi	r2,r2,65280
 20037f0:	2088b03a 	or	r4,r4,r2
 20037f4:	e0bffd17 	ldw	r2,-12(fp)
 20037f8:	10800017 	ldw	r2,0(r2)
 20037fc:	10bfc00c 	andi	r2,r2,65280
 2003800:	1004923a 	slli	r2,r2,8
 2003804:	2088b03a 	or	r4,r4,r2
 2003808:	e0bffd17 	ldw	r2,-12(fp)
 200380c:	10800017 	ldw	r2,0(r2)
 2003810:	1004963a 	slli	r2,r2,24
 2003814:	2084b03a 	or	r2,r4,r2
 2003818:	1004d23a 	srli	r2,r2,8
#ifdef DHCP_CLIENT
    *use_dhcp = 1;
#else /* not DHCP_CLIENT */
    *use_dhcp = 0;

    printf("Static IP Address is %d.%d.%d.%d\n",
 200381c:	10803fcc 	andi	r2,r2,255
        ip4_addr1(*ipaddr),
        ip4_addr2(*ipaddr),
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
 2003820:	e13ffd17 	ldw	r4,-12(fp)
 2003824:	21000017 	ldw	r4,0(r4)
 2003828:	200cd63a 	srli	r6,r4,24
 200382c:	e13ffd17 	ldw	r4,-12(fp)
 2003830:	21000017 	ldw	r4,0(r4)
 2003834:	2008d23a 	srli	r4,r4,8
 2003838:	213fc00c 	andi	r4,r4,65280
 200383c:	310cb03a 	or	r6,r6,r4
 2003840:	e13ffd17 	ldw	r4,-12(fp)
 2003844:	21000017 	ldw	r4,0(r4)
 2003848:	213fc00c 	andi	r4,r4,65280
 200384c:	2008923a 	slli	r4,r4,8
 2003850:	310cb03a 	or	r6,r6,r4
 2003854:	e13ffd17 	ldw	r4,-12(fp)
 2003858:	21000017 	ldw	r4,0(r4)
 200385c:	2008963a 	slli	r4,r4,24
 2003860:	3108b03a 	or	r4,r6,r4
#ifdef DHCP_CLIENT
    *use_dhcp = 1;
#else /* not DHCP_CLIENT */
    *use_dhcp = 0;

    printf("Static IP Address is %d.%d.%d.%d\n",
 2003864:	21003fcc 	andi	r4,r4,255
 2003868:	d9000015 	stw	r4,0(sp)
 200386c:	01008174 	movhi	r4,517
 2003870:	21347a04 	addi	r4,r4,-11800
 2003874:	180d883a 	mov	r6,r3
 2003878:	100f883a 	mov	r7,r2
 200387c:	2006a240 	call	2006a24 <printf>
        ip4_addr3(*ipaddr),
        ip4_addr4(*ipaddr));
#endif /* not DHCP_CLIENT */

    /* Non-standard API: return 1 for success */
    return 1;
 2003880:	00800044 	movi	r2,1
}
 2003884:	e037883a 	mov	sp,fp
 2003888:	dfc00117 	ldw	ra,4(sp)
 200388c:	df000017 	ldw	fp,0(sp)
 2003890:	dec00204 	addi	sp,sp,8
 2003894:	f800283a 	ret

02003898 <FindLastFlashSectorOffset>:
 * in pLastFlashSectorOffset.
 */

int FindLastFlashSectorOffset(
    alt_u32                     *pLastFlashSectorOffset)
{
 2003898:	defff304 	addi	sp,sp,-52
 200389c:	dfc00c15 	stw	ra,48(sp)
 20038a0:	df000b15 	stw	fp,44(sp)
 20038a4:	df000b04 	addi	fp,sp,44
 20038a8:	e13fff15 	stw	r4,-4(fp)
    flash_region                *regions;
    int                         numRegions;
    flash_region                *pLastRegion;
    int                         lastFlashSectorOffset;
    int                         n;
    int                         error = 0;
 20038ac:	e03ff815 	stw	zero,-32(fp)

    /* Open the flash device. */
    fd = alt_flash_open_dev(EPCS_FLASH_CONTROLLER_NAME);
 20038b0:	01008174 	movhi	r4,517
 20038b4:	21345004 	addi	r4,r4,-11968
 20038b8:	20150280 	call	2015028 <alt_flash_open_dev>
 20038bc:	e0bff915 	stw	r2,-28(fp)
    if (fd <= 0)
 20038c0:	e0bff917 	ldw	r2,-28(fp)
 20038c4:	1000021e 	bne	r2,zero,20038d0 <FindLastFlashSectorOffset+0x38>
        error = -1;
 20038c8:	00bfffc4 	movi	r2,-1
 20038cc:	e0bff815 	stw	r2,-32(fp)

    /* Get the flash info. */
    if (!error)
 20038d0:	e0bff817 	ldw	r2,-32(fp)
 20038d4:	10000d1e 	bne	r2,zero,200390c <FindLastFlashSectorOffset+0x74>
 20038d8:	e0bff917 	ldw	r2,-28(fp)
 20038dc:	e0bffa15 	stw	r2,-24(fp)
        error = alt_get_flash_info(fd, &regions, &numRegions);
 20038e0:	e0bffd04 	addi	r2,fp,-12
 20038e4:	e0bffb15 	stw	r2,-20(fp)
 20038e8:	e0bffe04 	addi	r2,fp,-8
 20038ec:	e0bffc15 	stw	r2,-16(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_get_flash_info( 
                                      alt_flash_fd* fd, flash_region** info, 
                                      int* number_of_regions)
{
  return fd->get_info( fd, info, number_of_regions);
 20038f0:	e0bffa17 	ldw	r2,-24(fp)
 20038f4:	10800717 	ldw	r2,28(r2)
 20038f8:	e13ffa17 	ldw	r4,-24(fp)
 20038fc:	e17ffb17 	ldw	r5,-20(fp)
 2003900:	e1bffc17 	ldw	r6,-16(fp)
 2003904:	103ee83a 	callr	r2
 2003908:	e0bff815 	stw	r2,-32(fp)

    /* Find the last flash sector. */
    if (!error)
 200390c:	e0bff817 	ldw	r2,-32(fp)
 2003910:	1000211e 	bne	r2,zero,2003998 <FindLastFlashSectorOffset+0x100>
    {
        pLastRegion = &(regions[0]);
 2003914:	e0bffd17 	ldw	r2,-12(fp)
 2003918:	e0bff515 	stw	r2,-44(fp)
        for (n = 1; n < numRegions; n++)
 200391c:	00800044 	movi	r2,1
 2003920:	e0bff715 	stw	r2,-36(fp)
 2003924:	00001006 	br	2003968 <FindLastFlashSectorOffset+0xd0>
        {
            if (regions[n].offset > pLastRegion->offset)
 2003928:	e0fffd17 	ldw	r3,-12(fp)
 200392c:	e0bff717 	ldw	r2,-36(fp)
 2003930:	1004913a 	slli	r2,r2,4
 2003934:	1885883a 	add	r2,r3,r2
 2003938:	10800017 	ldw	r2,0(r2)
 200393c:	e0fff517 	ldw	r3,-44(fp)
 2003940:	18c00017 	ldw	r3,0(r3)
 2003944:	1880050e 	bge	r3,r2,200395c <FindLastFlashSectorOffset+0xc4>
                pLastRegion = &(regions[n]);
 2003948:	e0fffd17 	ldw	r3,-12(fp)
 200394c:	e0bff717 	ldw	r2,-36(fp)
 2003950:	1004913a 	slli	r2,r2,4
 2003954:	1885883a 	add	r2,r3,r2
 2003958:	e0bff515 	stw	r2,-44(fp)

    /* Find the last flash sector. */
    if (!error)
    {
        pLastRegion = &(regions[0]);
        for (n = 1; n < numRegions; n++)
 200395c:	e0bff717 	ldw	r2,-36(fp)
 2003960:	10800044 	addi	r2,r2,1
 2003964:	e0bff715 	stw	r2,-36(fp)
 2003968:	e0bffe17 	ldw	r2,-8(fp)
 200396c:	e0fff717 	ldw	r3,-36(fp)
 2003970:	18bfed16 	blt	r3,r2,2003928 <FindLastFlashSectorOffset+0x90>
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 2003974:	e0bff517 	ldw	r2,-44(fp)
 2003978:	10c00017 	ldw	r3,0(r2)
                                + pLastRegion->region_size
 200397c:	e0bff517 	ldw	r2,-44(fp)
 2003980:	10800117 	ldw	r2,4(r2)
 2003984:	1887883a 	add	r3,r3,r2
                                - pLastRegion->block_size;
 2003988:	e0bff517 	ldw	r2,-44(fp)
 200398c:	10800317 	ldw	r2,12(r2)
        for (n = 1; n < numRegions; n++)
        {
            if (regions[n].offset > pLastRegion->offset)
                pLastRegion = &(regions[n]);
        }
        lastFlashSectorOffset =   pLastRegion->offset
 2003990:	1885c83a 	sub	r2,r3,r2
 2003994:	e0bff615 	stw	r2,-40(fp)
                                + pLastRegion->region_size
                                - pLastRegion->block_size;
    }

    /* Return results. */
    if (!error)
 2003998:	e0bff817 	ldw	r2,-32(fp)
 200399c:	1000031e 	bne	r2,zero,20039ac <FindLastFlashSectorOffset+0x114>
        *pLastFlashSectorOffset = lastFlashSectorOffset;
 20039a0:	e0fff617 	ldw	r3,-40(fp)
 20039a4:	e0bfff17 	ldw	r2,-4(fp)
 20039a8:	10c00015 	stw	r3,0(r2)

    return (error);
 20039ac:	e0bff817 	ldw	r2,-32(fp)
}
 20039b0:	e037883a 	mov	sp,fp
 20039b4:	dfc00117 	ldw	ra,4(sp)
 20039b8:	df000017 	ldw	fp,0(sp)
 20039bc:	dec00204 	addi	sp,sp,8
 20039c0:	f800283a 	ret

020039c4 <ProgFlash>:
*  a pointer to a data buffer, and the size of the data buffer.
*
******************************************************************/
int ProgFlash(struct flash_inf_struct *flash_info, int target_addr,
              char* data, int data_len)
{
 20039c4:	deffdb04 	addi	sp,sp,-148
 20039c8:	dfc02415 	stw	ra,144(sp)
 20039cc:	df002315 	stw	fp,140(sp)
 20039d0:	df002304 	addi	fp,sp,140
 20039d4:	e13ffc15 	stw	r4,-16(fp)
 20039d8:	e17ffd15 	stw	r5,-12(fp)
 20039dc:	e1bffe15 	stw	r6,-8(fp)
 20039e0:	e1ffff15 	stw	r7,-4(fp)
  // Flash device variables
  alt_flash_fd* fd;
  int number_of_regions;
  flash_region* regions;
  char flashname[40]; /* Be conservative on the size of the string. */
  char* flashname_ptr = flashname;
 20039e4:	e0bff204 	addi	r2,fp,-56
 20039e8:	e0bfdf15 	stw	r2,-132(fp)
  int new_flash_block = -1;
 20039ec:	00bfffc4 	movi	r2,-1
 20039f0:	e0bfe015 	stw	r2,-128(fp)
  
  // General purpose variables
  unsigned int sw_offset = 0;
 20039f4:	e03fe115 	stw	zero,-124(fp)
  int ret_code = 0x0;
 20039f8:	e03fde15 	stw	zero,-136(fp)
   * - If you want your flash name to be an option, you must change the 
   * upload_image form in index.html to include your flash device's name 
   * in the pick list.  
   */
  
  flashname_ptr += sprintf( flashname_ptr, "/dev/%s", flash_info->device );  
 20039fc:	e0bffc17 	ldw	r2,-16(fp)
 2003a00:	10800204 	addi	r2,r2,8
 2003a04:	e13fdf17 	ldw	r4,-132(fp)
 2003a08:	01408174 	movhi	r5,517
 2003a0c:	29748304 	addi	r5,r5,-11764
 2003a10:	100d883a 	mov	r6,r2
 2003a14:	2006fec0 	call	2006fec <sprintf>
 2003a18:	e0ffdf17 	ldw	r3,-132(fp)
 2003a1c:	1885883a 	add	r2,r3,r2
 2003a20:	e0bfdf15 	stw	r2,-132(fp)
	*(flashname_ptr+1) = '\0';
 2003a24:	e0bfdf17 	ldw	r2,-132(fp)
 2003a28:	10800044 	addi	r2,r2,1
 2003a2c:	10000005 	stb	zero,0(r2)
  
  fd = alt_flash_open_dev(flashname);
 2003a30:	e0bff204 	addi	r2,fp,-56
 2003a34:	1009883a 	mov	r4,r2
 2003a38:	20150280 	call	2015028 <alt_flash_open_dev>
 2003a3c:	e0bfe215 	stw	r2,-120(fp)
  if (fd)
 2003a40:	e0bfe217 	ldw	r2,-120(fp)
 2003a44:	10007826 	beq	r2,zero,2003c28 <ProgFlash+0x264>
 2003a48:	e0bfe217 	ldw	r2,-120(fp)
 2003a4c:	e0bfe315 	stw	r2,-116(fp)
  { 
    /* Get some useful info about the flash */
    ret_code = alt_get_flash_info(fd, &regions, &number_of_regions);
 2003a50:	e0bff104 	addi	r2,fp,-60
 2003a54:	e0bfe415 	stw	r2,-112(fp)
 2003a58:	e0bff004 	addi	r2,fp,-64
 2003a5c:	e0bfe515 	stw	r2,-108(fp)
 2003a60:	e0bfe317 	ldw	r2,-116(fp)
 2003a64:	10800717 	ldw	r2,28(r2)
 2003a68:	e13fe317 	ldw	r4,-116(fp)
 2003a6c:	e17fe417 	ldw	r5,-112(fp)
 2003a70:	e1bfe517 	ldw	r6,-108(fp)
 2003a74:	103ee83a 	callr	r2
 2003a78:	e0bfde15 	stw	r2,-136(fp)
    /* new_flash_block = target_addr / regions->block_size; */
    /* Ahhh, but what happens if a line spans the end of one block and the 
     * beginning of another? 
     *  - Better to handle this case well...as well!
     */
    new_flash_block = (target_addr + data_len) / regions->block_size;
 2003a7c:	e0fffd17 	ldw	r3,-12(fp)
 2003a80:	e0bfff17 	ldw	r2,-4(fp)
 2003a84:	1887883a 	add	r3,r3,r2
 2003a88:	e0bff117 	ldw	r2,-60(fp)
 2003a8c:	10800317 	ldw	r2,12(r2)
 2003a90:	1885283a 	div	r2,r3,r2
 2003a94:	e0bfe015 	stw	r2,-128(fp)
    if( current_flash_block == -1 )
 2003a98:	d0a05e17 	ldw	r2,-32392(gp)
 2003a9c:	10bfffd8 	cmpnei	r2,r2,-1
 2003aa0:	1000081e 	bne	r2,zero,2003ac4 <ProgFlash+0x100>
    {
      /* Output various flash information when programming the first line. */
      printf( "\nFlash Name is %s.\nBlock size is %d bytes.\n\nProgramming Flash...\n", flashname, regions->block_size );
 2003aa4:	e0bff117 	ldw	r2,-60(fp)
 2003aa8:	10800317 	ldw	r2,12(r2)
 2003aac:	e0fff204 	addi	r3,fp,-56
 2003ab0:	01008174 	movhi	r4,517
 2003ab4:	21348504 	addi	r4,r4,-11756
 2003ab8:	180b883a 	mov	r5,r3
 2003abc:	100d883a 	mov	r6,r2
 2003ac0:	2006a240 	call	2006a24 <printf>
    }
    /* if it's a new block, we need to erase it first. */
    if(new_flash_block != current_flash_block)
 2003ac4:	d0a05e17 	ldw	r2,-32392(gp)
 2003ac8:	e0ffe017 	ldw	r3,-128(fp)
 2003acc:	18802026 	beq	r3,r2,2003b50 <ProgFlash+0x18c>
    {
      printf("\nFlash Block %d", new_flash_block);
 2003ad0:	01008174 	movhi	r4,517
 2003ad4:	21349604 	addi	r4,r4,-11688
 2003ad8:	e17fe017 	ldw	r5,-128(fp)
 2003adc:	2006a240 	call	2006a24 <printf>
      /* Blindly erase the new flash block */
      alt_erase_flash_block(fd, (new_flash_block * regions->block_size), regions->block_size);
 2003ae0:	e0bff117 	ldw	r2,-60(fp)
 2003ae4:	10c00317 	ldw	r3,12(r2)
 2003ae8:	e0bfe017 	ldw	r2,-128(fp)
 2003aec:	1887383a 	mul	r3,r3,r2
 2003af0:	e0bff117 	ldw	r2,-60(fp)
 2003af4:	10800317 	ldw	r2,12(r2)
 2003af8:	e13fe217 	ldw	r4,-120(fp)
 2003afc:	e13fe615 	stw	r4,-104(fp)
 2003b00:	e0ffe715 	stw	r3,-100(fp)
 2003b04:	e0bfe815 	stw	r2,-96(fp)
 */
static __inline__ int __attribute__ ((always_inline)) alt_erase_flash_block( 
                                      alt_flash_fd* fd, int offset, int length) 
{
  int ret_code;
  ret_code = fd->erase_block( fd, offset );
 2003b08:	e0bfe617 	ldw	r2,-104(fp)
 2003b0c:	10800817 	ldw	r2,32(r2)
 2003b10:	e13fe617 	ldw	r4,-104(fp)
 2003b14:	e17fe717 	ldw	r5,-100(fp)
 2003b18:	103ee83a 	callr	r2
 2003b1c:	e0bfe915 	stw	r2,-92(fp)
  
  if(!ret_code)
 2003b20:	e0bfe917 	ldw	r2,-92(fp)
 2003b24:	1000081e 	bne	r2,zero,2003b48 <ProgFlash+0x184>
      alt_dcache_flush((alt_u8*)fd->base_addr + offset, length);
 2003b28:	e0bfe617 	ldw	r2,-104(fp)
 2003b2c:	10c00a17 	ldw	r3,40(r2)
 2003b30:	e0bfe717 	ldw	r2,-100(fp)
 2003b34:	1887883a 	add	r3,r3,r2
 2003b38:	e0bfe817 	ldw	r2,-96(fp)
 2003b3c:	1809883a 	mov	r4,r3
 2003b40:	100b883a 	mov	r5,r2
 2003b44:	2014fb40 	call	2014fb4 <alt_dcache_flush>
      current_flash_block = new_flash_block;
 2003b48:	e0bfe017 	ldw	r2,-128(fp)
 2003b4c:	d0a05e15 	stw	r2,-32392(gp)
    }
    alt_write_flash_block(fd, (current_flash_block * regions->block_size), target_addr, data, data_len);
 2003b50:	e0bff117 	ldw	r2,-60(fp)
 2003b54:	10c00317 	ldw	r3,12(r2)
 2003b58:	d0a05e17 	ldw	r2,-32392(gp)
 2003b5c:	1885383a 	mul	r2,r3,r2
 2003b60:	e0ffe217 	ldw	r3,-120(fp)
 2003b64:	e0ffea15 	stw	r3,-88(fp)
 2003b68:	e0bfeb15 	stw	r2,-84(fp)
 2003b6c:	e0bffd17 	ldw	r2,-12(fp)
 2003b70:	e0bfec15 	stw	r2,-80(fp)
 2003b74:	e0bffe17 	ldw	r2,-8(fp)
 2003b78:	e0bfed15 	stw	r2,-76(fp)
 2003b7c:	e0bfff17 	ldw	r2,-4(fp)
 2003b80:	e0bfee15 	stw	r2,-72(fp)
                                      int data_offset,
                                      const void *data, int length)
{

  int ret_code;
  ret_code = fd->write_block( fd, block_offset, data_offset, data, length );
 2003b84:	e0bfea17 	ldw	r2,-88(fp)
 2003b88:	10800917 	ldw	r2,36(r2)
 2003b8c:	e0ffee17 	ldw	r3,-72(fp)
 2003b90:	d8c00015 	stw	r3,0(sp)
 2003b94:	e13fea17 	ldw	r4,-88(fp)
 2003b98:	e17feb17 	ldw	r5,-84(fp)
 2003b9c:	e1bfec17 	ldw	r6,-80(fp)
 2003ba0:	e1ffed17 	ldw	r7,-76(fp)
 2003ba4:	103ee83a 	callr	r2
 2003ba8:	e0bfef15 	stw	r2,-68(fp)

  if(!ret_code)
 2003bac:	e0bfef17 	ldw	r2,-68(fp)
 2003bb0:	1000081e 	bne	r2,zero,2003bd4 <ProgFlash+0x210>
      alt_dcache_flush((alt_u8*)fd->base_addr + data_offset, length);
 2003bb4:	e0bfea17 	ldw	r2,-88(fp)
 2003bb8:	10c00a17 	ldw	r3,40(r2)
 2003bbc:	e0bfec17 	ldw	r2,-80(fp)
 2003bc0:	1887883a 	add	r3,r3,r2
 2003bc4:	e0bfee17 	ldw	r2,-72(fp)
 2003bc8:	1809883a 	mov	r4,r3
 2003bcc:	100b883a 	mov	r5,r2
 2003bd0:	2014fb40 	call	2014fb4 <alt_dcache_flush>
    /* This just gives us some zippy dots so we know hard work is being done */
    if ((target_addr - sw_offset) % (regions->block_size / 8) < data_len)
 2003bd4:	e0fffd17 	ldw	r3,-12(fp)
 2003bd8:	e0bfe117 	ldw	r2,-124(fp)
 2003bdc:	1887c83a 	sub	r3,r3,r2
 2003be0:	e0bff117 	ldw	r2,-60(fp)
 2003be4:	10800317 	ldw	r2,12(r2)
 2003be8:	1000010e 	bge	r2,zero,2003bf0 <ProgFlash+0x22c>
 2003bec:	108001c4 	addi	r2,r2,7
 2003bf0:	1005d0fa 	srai	r2,r2,3
 2003bf4:	1889203a 	divu	r4,r3,r2
 2003bf8:	2085383a 	mul	r2,r4,r2
 2003bfc:	1887c83a 	sub	r3,r3,r2
 2003c00:	e0bfff17 	ldw	r2,-4(fp)
 2003c04:	18800b2e 	bgeu	r3,r2,2003c34 <ProgFlash+0x270>
    {
      printf("\n 0x%8.8X: ", (target_addr & 0xFFFFFF00));
 2003c08:	e0fffd17 	ldw	r3,-12(fp)
 2003c0c:	00bfc004 	movi	r2,-256
 2003c10:	1884703a 	and	r2,r3,r2
 2003c14:	01008174 	movhi	r4,517
 2003c18:	21349a04 	addi	r4,r4,-11672
 2003c1c:	100b883a 	mov	r5,r2
 2003c20:	2006a240 	call	2006a24 <printf>
 2003c24:	00000306 	br	2003c34 <ProgFlash+0x270>
      printf(".");
    }*/
  }
  else
  {
    printf("Error Opening flash device. Exiting.");
 2003c28:	01008174 	movhi	r4,517
 2003c2c:	21349d04 	addi	r4,r4,-11660
 2003c30:	2006a240 	call	2006a24 <printf>
  }
  alt_flash_close_dev(fd);
 2003c34:	e13fe217 	ldw	r4,-120(fp)
 2003c38:	20150900 	call	2015090 <alt_flash_close_dev>

  return (ret_code);  
 2003c3c:	e0bfde17 	ldw	r2,-136(fp)
}
 2003c40:	e037883a 	mov	sp,fp
 2003c44:	dfc00117 	ldw	ra,4(sp)
 2003c48:	df000017 	ldw	fp,0(sp)
 2003c4c:	dec00204 	addi	sp,sp,8
 2003c50:	f800283a 	ret

02003c54 <ParseAndProgramLine>:
 *    - These are left as an exercise up to the user.
 * 
 ******************************************************************/
 
 int ParseAndProgramLine( char* lineBuf, struct flash_inf_struct *flash_info )
 {
 2003c54:	deffe004 	addi	sp,sp,-128
 2003c58:	dfc01f15 	stw	ra,124(sp)
 2003c5c:	df001e15 	stw	fp,120(sp)
 2003c60:	df001e04 	addi	fp,sp,120
 2003c64:	e13ffe15 	stw	r4,-8(fp)
 2003c68:	e17fff15 	stw	r5,-4(fp)
  int temp;       /* Temporary variable for checksum calculation. */
  char data[80];
  char* data_ptr;
  int data_len;

  if( *lineBuf != 'S' )
 2003c6c:	e0bffe17 	ldw	r2,-8(fp)
 2003c70:	10800003 	ldbu	r2,0(r2)
 2003c74:	10803fcc 	andi	r2,r2,255
 2003c78:	1080201c 	xori	r2,r2,128
 2003c7c:	10bfe004 	addi	r2,r2,-128
 2003c80:	108014e0 	cmpeqi	r2,r2,83
 2003c84:	10000b1e 	bne	r2,zero,2003cb4 <ParseAndProgramLine+0x60>
  {
    printf( "\nSREC ERROR: line starts with %c.\n", *lineBuf );
 2003c88:	e0bffe17 	ldw	r2,-8(fp)
 2003c8c:	10800003 	ldbu	r2,0(r2)
 2003c90:	10803fcc 	andi	r2,r2,255
 2003c94:	1080201c 	xori	r2,r2,128
 2003c98:	10bfe004 	addi	r2,r2,-128
 2003c9c:	01008174 	movhi	r4,517
 2003ca0:	2134a704 	addi	r4,r4,-11620
 2003ca4:	100b883a 	mov	r5,r2
 2003ca8:	2006a240 	call	2006a24 <printf>
    return( 10 );
 2003cac:	00800284 	movi	r2,10
 2003cb0:	00008e06 	br	2003eec <ParseAndProgramLine+0x298>
  }
   
  switch( *(lineBuf + 1) )
 2003cb4:	e0bffe17 	ldw	r2,-8(fp)
 2003cb8:	10800044 	addi	r2,r2,1
 2003cbc:	10800003 	ldbu	r2,0(r2)
 2003cc0:	10803fcc 	andi	r2,r2,255
 2003cc4:	1080201c 	xori	r2,r2,128
 2003cc8:	10bfe004 	addi	r2,r2,-128
 2003ccc:	10c00c60 	cmpeqi	r3,r2,49
 2003cd0:	18000c1e 	bne	r3,zero,2003d04 <ParseAndProgramLine+0xb0>
 2003cd4:	10c00c88 	cmpgei	r3,r2,50
 2003cd8:	1800031e 	bne	r3,zero,2003ce8 <ParseAndProgramLine+0x94>
 2003cdc:	10800c20 	cmpeqi	r2,r2,48
 2003ce0:	1000061e 	bne	r2,zero,2003cfc <ParseAndProgramLine+0xa8>
 2003ce4:	00003d06 	br	2003ddc <ParseAndProgramLine+0x188>
 2003ce8:	10c00ca0 	cmpeqi	r3,r2,50
 2003cec:	1800171e 	bne	r3,zero,2003d4c <ParseAndProgramLine+0xf8>
 2003cf0:	10800ce0 	cmpeqi	r2,r2,51
 2003cf4:	1000271e 	bne	r2,zero,2003d94 <ParseAndProgramLine+0x140>
 2003cf8:	00003806 	br	2003ddc <ParseAndProgramLine+0x188>
  {
    case '0': /* Ignore S0 (header/filename) lines. */
      return( 0 );
 2003cfc:	0005883a 	mov	r2,zero
 2003d00:	00007a06 	br	2003eec <ParseAndProgramLine+0x298>
    case '1':
      if( sscanf( lineBuf, "S1%2x%4x", &byte_count, &target_addr) != 2 )
 2003d04:	e0ffe804 	addi	r3,fp,-96
 2003d08:	e0bfe704 	addi	r2,fp,-100
 2003d0c:	e13ffe17 	ldw	r4,-8(fp)
 2003d10:	01408174 	movhi	r5,517
 2003d14:	2974b004 	addi	r5,r5,-11584
 2003d18:	180d883a 	mov	r6,r3
 2003d1c:	100f883a 	mov	r7,r2
 2003d20:	20070600 	call	2007060 <sscanf>
 2003d24:	108000a0 	cmpeqi	r2,r2,2
 2003d28:	1000051e 	bne	r2,zero,2003d40 <ParseAndProgramLine+0xec>
      {
        printf("\nSREC Error:  Error scanning S1 type.\n");
 2003d2c:	01008174 	movhi	r4,517
 2003d30:	2134b304 	addi	r4,r4,-11572
 2003d34:	2006cb40 	call	2006cb4 <puts>
        return( 11 );
 2003d38:	008002c4 	movi	r2,11
 2003d3c:	00006b06 	br	2003eec <ParseAndProgramLine+0x298>
      }
      overhead = 3;
 2003d40:	008000c4 	movi	r2,3
 2003d44:	e0bfe415 	stw	r2,-112(fp)
      break;
 2003d48:	00002606 	br	2003de4 <ParseAndProgramLine+0x190>
    case '2':
      if( sscanf( lineBuf, "S2%2x%6x", &byte_count, &target_addr) != 2 )
 2003d4c:	e0ffe804 	addi	r3,fp,-96
 2003d50:	e0bfe704 	addi	r2,fp,-100
 2003d54:	e13ffe17 	ldw	r4,-8(fp)
 2003d58:	01408174 	movhi	r5,517
 2003d5c:	2974bd04 	addi	r5,r5,-11532
 2003d60:	180d883a 	mov	r6,r3
 2003d64:	100f883a 	mov	r7,r2
 2003d68:	20070600 	call	2007060 <sscanf>
 2003d6c:	108000a0 	cmpeqi	r2,r2,2
 2003d70:	1000051e 	bne	r2,zero,2003d88 <ParseAndProgramLine+0x134>
      {
        printf("\nSREC Error:  Error scanning S2 type.\n");
 2003d74:	01008174 	movhi	r4,517
 2003d78:	2134c004 	addi	r4,r4,-11520
 2003d7c:	2006cb40 	call	2006cb4 <puts>
        return( 12 );
 2003d80:	00800304 	movi	r2,12
 2003d84:	00005906 	br	2003eec <ParseAndProgramLine+0x298>
      }
      overhead = 4;
 2003d88:	00800104 	movi	r2,4
 2003d8c:	e0bfe415 	stw	r2,-112(fp)
      break;
 2003d90:	00001406 	br	2003de4 <ParseAndProgramLine+0x190>
    case '3':
      if( sscanf( lineBuf, "S3%2x%8x", &byte_count, &target_addr) != 2 )
 2003d94:	e0ffe804 	addi	r3,fp,-96
 2003d98:	e0bfe704 	addi	r2,fp,-100
 2003d9c:	e13ffe17 	ldw	r4,-8(fp)
 2003da0:	01408174 	movhi	r5,517
 2003da4:	2974ca04 	addi	r5,r5,-11480
 2003da8:	180d883a 	mov	r6,r3
 2003dac:	100f883a 	mov	r7,r2
 2003db0:	20070600 	call	2007060 <sscanf>
 2003db4:	108000a0 	cmpeqi	r2,r2,2
 2003db8:	1000051e 	bne	r2,zero,2003dd0 <ParseAndProgramLine+0x17c>
      {
        printf("\nSREC Error:  Error scanning S3 type.\n");
 2003dbc:	01008174 	movhi	r4,517
 2003dc0:	2134cd04 	addi	r4,r4,-11468
 2003dc4:	2006cb40 	call	2006cb4 <puts>
        return( 13 );
 2003dc8:	00800344 	movi	r2,13
 2003dcc:	00004706 	br	2003eec <ParseAndProgramLine+0x298>
      }
      overhead = 5;
 2003dd0:	00800144 	movi	r2,5
 2003dd4:	e0bfe415 	stw	r2,-112(fp)
      break;
 2003dd8:	00000206 	br	2003de4 <ParseAndProgramLine+0x190>
      
    default:
      return( 0 );
 2003ddc:	0005883a 	mov	r2,zero
 2003de0:	00004206 	br	2003eec <ParseAndProgramLine+0x298>
  }
  
  data_len = byte_count - overhead; /* The amount of data in this SREC line. */
 2003de4:	e0ffe817 	ldw	r3,-96(fp)
 2003de8:	e0bfe417 	ldw	r2,-112(fp)
 2003dec:	1885c83a 	sub	r2,r3,r2
 2003df0:	e0bfe615 	stw	r2,-104(fp)
  data_ptr = data; /* Initialize the data pointer */
 2003df4:	e0bfea04 	addi	r2,fp,-88
 2003df8:	e0bfe515 	stw	r2,-108(fp)
  
  cksm = 0;
 2003dfc:	e03fe205 	stb	zero,-120(fp)
  byte_count++; /* Add one to counter to read the final checksum, as well. */
 2003e00:	e0bfe817 	ldw	r2,-96(fp)
 2003e04:	10800044 	addi	r2,r2,1
 2003e08:	e0bfe815 	stw	r2,-96(fp)
  
  for( i = 1; i <= byte_count; i++ )
 2003e0c:	00800044 	movi	r2,1
 2003e10:	e0bfe315 	stw	r2,-116(fp)
 2003e14:	00001f06 	br	2003e94 <ParseAndProgramLine+0x240>
  {
    sscanf( lineBuf + i*2, "%2x", &temp ); /* Do the hex->binary conversion.*/
 2003e18:	e0bfe317 	ldw	r2,-116(fp)
 2003e1c:	1085883a 	add	r2,r2,r2
 2003e20:	e0fffe17 	ldw	r3,-8(fp)
 2003e24:	1887883a 	add	r3,r3,r2
 2003e28:	e0bfe904 	addi	r2,fp,-92
 2003e2c:	1809883a 	mov	r4,r3
 2003e30:	01408174 	movhi	r5,517
 2003e34:	2974d704 	addi	r5,r5,-11428
 2003e38:	100d883a 	mov	r6,r2
 2003e3c:	20070600 	call	2007060 <sscanf>
    cksm += (unsigned char) temp; /* Rolling checksum addition. */
 2003e40:	e0bfe917 	ldw	r2,-92(fp)
 2003e44:	1007883a 	mov	r3,r2
 2003e48:	e0bfe203 	ldbu	r2,-120(fp)
 2003e4c:	1885883a 	add	r2,r3,r2
 2003e50:	e0bfe205 	stb	r2,-120(fp)
    if( ( i > overhead ) && ( i < byte_count )) /* Copy data into data buffer. */
 2003e54:	e0bfe317 	ldw	r2,-116(fp)
 2003e58:	e0ffe417 	ldw	r3,-112(fp)
 2003e5c:	18800a0e 	bge	r3,r2,2003e88 <ParseAndProgramLine+0x234>
 2003e60:	e0bfe817 	ldw	r2,-96(fp)
 2003e64:	e0ffe317 	ldw	r3,-116(fp)
 2003e68:	1880070e 	bge	r3,r2,2003e88 <ParseAndProgramLine+0x234>
    {
      *data_ptr++ = (unsigned char) temp; /* Copy value into the data buffer. */
 2003e6c:	e0bfe917 	ldw	r2,-92(fp)
 2003e70:	1007883a 	mov	r3,r2
 2003e74:	e0bfe517 	ldw	r2,-108(fp)
 2003e78:	10c00005 	stb	r3,0(r2)
 2003e7c:	e0bfe517 	ldw	r2,-108(fp)
 2003e80:	10800044 	addi	r2,r2,1
 2003e84:	e0bfe515 	stw	r2,-108(fp)
  data_ptr = data; /* Initialize the data pointer */
  
  cksm = 0;
  byte_count++; /* Add one to counter to read the final checksum, as well. */
  
  for( i = 1; i <= byte_count; i++ )
 2003e88:	e0bfe317 	ldw	r2,-116(fp)
 2003e8c:	10800044 	addi	r2,r2,1
 2003e90:	e0bfe315 	stw	r2,-116(fp)
 2003e94:	e0ffe817 	ldw	r3,-96(fp)
 2003e98:	e0bfe317 	ldw	r2,-116(fp)
 2003e9c:	18bfde0e 	bge	r3,r2,2003e18 <ParseAndProgramLine+0x1c4>
    if( ( i > overhead ) && ( i < byte_count )) /* Copy data into data buffer. */
    {
      *data_ptr++ = (unsigned char) temp; /* Copy value into the data buffer. */
    }
  }
  if( cksm += 1 ) /* Catch checksum error. */
 2003ea0:	e0bfe203 	ldbu	r2,-120(fp)
 2003ea4:	10800044 	addi	r2,r2,1
 2003ea8:	e0bfe205 	stb	r2,-120(fp)
 2003eac:	e0bfe207 	ldb	r2,-120(fp)
 2003eb0:	10000226 	beq	r2,zero,2003ebc <ParseAndProgramLine+0x268>
  {
    return( 14 );
 2003eb4:	00800384 	movi	r2,14
 2003eb8:	00000c06 	br	2003eec <ParseAndProgramLine+0x298>
  }
  
  if (ProgFlash( flash_info, target_addr, data, data_len) != 0)
 2003ebc:	e0ffe717 	ldw	r3,-100(fp)
 2003ec0:	e0bfea04 	addi	r2,fp,-88
 2003ec4:	e13fff17 	ldw	r4,-4(fp)
 2003ec8:	180b883a 	mov	r5,r3
 2003ecc:	100d883a 	mov	r6,r2
 2003ed0:	e1ffe617 	ldw	r7,-104(fp)
 2003ed4:	20039c40 	call	20039c4 <ProgFlash>
 2003ed8:	10000326 	beq	r2,zero,2003ee8 <ParseAndProgramLine+0x294>
  {
    printf("\nFLASH:  Error in flash programming.\n");
 2003edc:	01008174 	movhi	r4,517
 2003ee0:	2134d804 	addi	r4,r4,-11424
 2003ee4:	2006cb40 	call	2006cb4 <puts>
  }
  
  return( 0 );
 2003ee8:	0005883a 	mov	r2,zero
 }
 2003eec:	e037883a 	mov	sp,fp
 2003ef0:	dfc00117 	ldw	ra,4(sp)
 2003ef4:	df000017 	ldw	fp,0(sp)
 2003ef8:	dec00204 	addi	sp,sp,8
 2003efc:	f800283a 	ret

02003f00 <ParseSRECBuf>:
 * 
 * 
 ******************************************************************/
 
int ParseSRECBuf(struct flash_inf_struct *flash_info)
{
 2003f00:	deff7704 	addi	sp,sp,-548
 2003f04:	dfc08815 	stw	ra,544(sp)
 2003f08:	df008715 	stw	fp,540(sp)
 2003f0c:	df008704 	addi	fp,sp,540
 2003f10:	e13fff15 	stw	r4,-4(fp)
  char* cur_ptr;
  char *lineBuf_ptr, *frag_end;
  int lineBuf_len = 0;
 2003f14:	e03f7c15 	stw	zero,-528(fp)
  char lineBuf[MAXLINE];
  char tmpStrBuf[MAXLINE];
  int ret_code;
  alt_u8 eol_flag = 0;
 2003f18:	e03f7b05 	stb	zero,-532(fp)
  
  lineBuf_ptr = lineBuf; /* Point to beginning of line buffer. */
 2003f1c:	e0bf7f04 	addi	r2,fp,-516
 2003f20:	e0bf7a15 	stw	r2,-536(fp)
  cur_ptr = flash_info->start; /* Point to the beginning of the SREC buffer. */
 2003f24:	e0bfff17 	ldw	r2,-4(fp)
 2003f28:	10800017 	ldw	r2,0(r2)
 2003f2c:	e0bf7915 	stw	r2,-540(fp)

  //printf( "cur_ptr = 0x%x\n", (int) cur_ptr );
  
  /* Iterate over entire buffer. */
  while( cur_ptr <= ( flash_info->start + flash_info->size ))
 2003f30:	00008406 	br	2004144 <ParseSRECBuf+0x244>
  { 
    /* End of line processing follows. */
    if ( (*cur_ptr == '\r') || (*cur_ptr == '\n') )
 2003f34:	e0bf7917 	ldw	r2,-540(fp)
 2003f38:	10800003 	ldbu	r2,0(r2)
 2003f3c:	10803fcc 	andi	r2,r2,255
 2003f40:	1080201c 	xori	r2,r2,128
 2003f44:	10bfe004 	addi	r2,r2,-128
 2003f48:	10800360 	cmpeqi	r2,r2,13
 2003f4c:	1000071e 	bne	r2,zero,2003f6c <ParseSRECBuf+0x6c>
 2003f50:	e0bf7917 	ldw	r2,-540(fp)
 2003f54:	10800003 	ldbu	r2,0(r2)
 2003f58:	10803fcc 	andi	r2,r2,255
 2003f5c:	1080201c 	xori	r2,r2,128
 2003f60:	10bfe004 	addi	r2,r2,-128
 2003f64:	10800298 	cmpnei	r2,r2,10
 2003f68:	1000681e 	bne	r2,zero,200410c <ParseSRECBuf+0x20c>
    {
      /* Exception for when \r\n span buffers. */
      if ( (cur_ptr == flash_info->start) && (*cur_ptr == '\n') && (frag.len == 0))
 2003f6c:	e0bfff17 	ldw	r2,-4(fp)
 2003f70:	10c00017 	ldw	r3,0(r2)
 2003f74:	e0bf7917 	ldw	r2,-540(fp)
 2003f78:	18800b1e 	bne	r3,r2,2003fa8 <ParseSRECBuf+0xa8>
 2003f7c:	e0bf7917 	ldw	r2,-540(fp)
 2003f80:	10800003 	ldbu	r2,0(r2)
 2003f84:	10803fcc 	andi	r2,r2,255
 2003f88:	1080201c 	xori	r2,r2,128
 2003f8c:	10bfe004 	addi	r2,r2,-128
 2003f90:	10800298 	cmpnei	r2,r2,10
 2003f94:	1000041e 	bne	r2,zero,2003fa8 <ParseSRECBuf+0xa8>
 2003f98:	008098f4 	movhi	r2,611
 2003f9c:	10876204 	addi	r2,r2,7560
 2003fa0:	10800017 	ldw	r2,0(r2)
 2003fa4:	10006426 	beq	r2,zero,2004138 <ParseSRECBuf+0x238>
        /* Dont' do anything when '\n' is the first character received and
         * there's no data in the frag (line fragment) structure.
         */
        continue;
      }
      eol_flag = 1; /* Set the End of Line flag to 1. */
 2003fa8:	00800044 	movi	r2,1
 2003fac:	e0bf7b05 	stb	r2,-532(fp)
      *lineBuf_ptr = 0; /* Terminate the Line String...do not include CR/LFs. */
 2003fb0:	e0bf7a17 	ldw	r2,-536(fp)
 2003fb4:	10000005 	stb	zero,0(r2)
      lineBuf_len = lineBuf_ptr - lineBuf;
 2003fb8:	e0ff7a17 	ldw	r3,-536(fp)
 2003fbc:	e0bf7f04 	addi	r2,fp,-516
 2003fc0:	1885c83a 	sub	r2,r3,r2
 2003fc4:	e0bf7c15 	stw	r2,-528(fp)
      if ( frag.len > 0 ) /* We have leftovers from the last buffer parsed. */
 2003fc8:	008098f4 	movhi	r2,611
 2003fcc:	10876204 	addi	r2,r2,7560
 2003fd0:	10800017 	ldw	r2,0(r2)
 2003fd4:	0080240e 	bge	zero,r2,2004068 <ParseSRECBuf+0x168>
      {
        if ( lineBuf_len != 0 ) /* If the line buffer has a partial line. */
 2003fd8:	e0bf7c17 	ldw	r2,-528(fp)
 2003fdc:	10001626 	beq	r2,zero,2004038 <ParseSRECBuf+0x138>
        {
          /* A little bit of string shuffling to get things in the right order. */
          strcpy( tmpStrBuf, frag.data );
 2003fe0:	e0bfbf04 	addi	r2,fp,-260
 2003fe4:	1009883a 	mov	r4,r2
 2003fe8:	014098f4 	movhi	r5,611
 2003fec:	29476304 	addi	r5,r5,7564
 2003ff0:	200756c0 	call	200756c <strcpy>
          strcat( tmpStrBuf, lineBuf ); /* Concatenate the lineBuf to the leftovers. */
 2003ff4:	e0ffbf04 	addi	r3,fp,-260
 2003ff8:	e0bf7f04 	addi	r2,fp,-516
 2003ffc:	1809883a 	mov	r4,r3
 2004000:	100b883a 	mov	r5,r2
 2004004:	20073480 	call	2007348 <strcat>
          strcpy( lineBuf, tmpStrBuf ); /* Should have a line's worth of data, now. */
 2004008:	e0ff7f04 	addi	r3,fp,-516
 200400c:	e0bfbf04 	addi	r2,fp,-260
 2004010:	1809883a 	mov	r4,r3
 2004014:	100b883a 	mov	r5,r2
 2004018:	200756c0 	call	200756c <strcpy>
          lineBuf_len = lineBuf_len + frag.len; /* Update the actual line buffer length. */
 200401c:	008098f4 	movhi	r2,611
 2004020:	10876204 	addi	r2,r2,7560
 2004024:	10800017 	ldw	r2,0(r2)
 2004028:	e0ff7c17 	ldw	r3,-528(fp)
 200402c:	1885883a 	add	r2,r3,r2
 2004030:	e0bf7c15 	stw	r2,-528(fp)
 2004034:	00000906 	br	200405c <ParseSRECBuf+0x15c>
        else /* If the entire line is in frag.data. */
        {
          /* This case is possible when the buffer is '\n' terminated and
           * '\n' is the first character received in a new buffer.
           */
          strcpy( lineBuf, frag.data );
 2004038:	e0bf7f04 	addi	r2,fp,-516
 200403c:	1009883a 	mov	r4,r2
 2004040:	014098f4 	movhi	r5,611
 2004044:	29476304 	addi	r5,r5,7564
 2004048:	200756c0 	call	200756c <strcpy>
          lineBuf_len = frag.len;
 200404c:	008098f4 	movhi	r2,611
 2004050:	10876204 	addi	r2,r2,7560
 2004054:	10800017 	ldw	r2,0(r2)
 2004058:	e0bf7c15 	stw	r2,-528(fp)
        }
        frag.len = 0; /* The line fragment has been copied into lineBuf. */
 200405c:	008098f4 	movhi	r2,611
 2004060:	10876204 	addi	r2,r2,7560
 2004064:	10000015 	stw	zero,0(r2)
      }
      ++line_count;
 2004068:	d0a05d17 	ldw	r2,-32396(gp)
 200406c:	10800044 	addi	r2,r2,1
 2004070:	d0a05d15 	stw	r2,-32396(gp)
      /* Since a full (hopefully valid) line has been received, parse it and
       * program it to flash.
       */
      if( (ret_code = ParseAndProgramLine( lineBuf, flash_info)) )
 2004074:	e0bf7f04 	addi	r2,fp,-516
 2004078:	1009883a 	mov	r4,r2
 200407c:	e17fff17 	ldw	r5,-4(fp)
 2004080:	2003c540 	call	2003c54 <ParseAndProgramLine>
 2004084:	e0bf7d15 	stw	r2,-524(fp)
 2004088:	e0bf7d17 	ldw	r2,-524(fp)
 200408c:	10000626 	beq	r2,zero,20040a8 <ParseSRECBuf+0x1a8>
      {
        printf("SREC ERR:  SREC Line Parser returned Error %d.\n", ret_code);
 2004090:	01008174 	movhi	r4,517
 2004094:	2134e204 	addi	r4,r4,-11384
 2004098:	e17f7d17 	ldw	r5,-524(fp)
 200409c:	2006a240 	call	2006a24 <printf>
        return( -1 );
 20040a0:	00bfffc4 	movi	r2,-1
 20040a4:	00004606 	br	20041c0 <ParseSRECBuf+0x2c0>
      }
      lineBuf_ptr = lineBuf; /* Reset the line buffer pointer. */
 20040a8:	e0bf7f04 	addi	r2,fp,-516
 20040ac:	e0bf7a15 	stw	r2,-536(fp)
      eol_flag = 0; /* Reset the end of line flag. */
 20040b0:	e03f7b05 	stb	zero,-532(fp)
      /* Need to skip over the end of line markers.
       *    - Both '\n' (UNIX) and '\r\n' (DOS) are supported. */
      if ( (*cur_ptr == '\r') )
 20040b4:	e0bf7917 	ldw	r2,-540(fp)
 20040b8:	10800003 	ldbu	r2,0(r2)
 20040bc:	10803fcc 	andi	r2,r2,255
 20040c0:	1080201c 	xori	r2,r2,128
 20040c4:	10bfe004 	addi	r2,r2,-128
 20040c8:	10800358 	cmpnei	r2,r2,13
 20040cc:	1000041e 	bne	r2,zero,20040e0 <ParseSRECBuf+0x1e0>
      {
        cur_ptr = cur_ptr + 2;
 20040d0:	e0bf7917 	ldw	r2,-540(fp)
 20040d4:	10800084 	addi	r2,r2,2
 20040d8:	e0bf7915 	stw	r2,-540(fp)
      }
      lineBuf_ptr = lineBuf; /* Reset the line buffer pointer. */
      eol_flag = 0; /* Reset the end of line flag. */
      /* Need to skip over the end of line markers.
       *    - Both '\n' (UNIX) and '\r\n' (DOS) are supported. */
      if ( (*cur_ptr == '\r') )
 20040dc:	00001806 	br	2004140 <ParseSRECBuf+0x240>
      {
        cur_ptr = cur_ptr + 2;
      }
      else if ( (*cur_ptr == '\n' ))
 20040e0:	e0bf7917 	ldw	r2,-540(fp)
 20040e4:	10800003 	ldbu	r2,0(r2)
 20040e8:	10803fcc 	andi	r2,r2,255
 20040ec:	1080201c 	xori	r2,r2,128
 20040f0:	10bfe004 	addi	r2,r2,-128
 20040f4:	10800298 	cmpnei	r2,r2,10
 20040f8:	1000111e 	bne	r2,zero,2004140 <ParseSRECBuf+0x240>
      {
        ++cur_ptr;
 20040fc:	e0bf7917 	ldw	r2,-540(fp)
 2004100:	10800044 	addi	r2,r2,1
 2004104:	e0bf7915 	stw	r2,-540(fp)
      }
      lineBuf_ptr = lineBuf; /* Reset the line buffer pointer. */
      eol_flag = 0; /* Reset the end of line flag. */
      /* Need to skip over the end of line markers.
       *    - Both '\n' (UNIX) and '\r\n' (DOS) are supported. */
      if ( (*cur_ptr == '\r') )
 2004108:	00000d06 	br	2004140 <ParseSRECBuf+0x240>
      }
    }
    else
    {
      /* Filling the line buffer. */
      *lineBuf_ptr = *cur_ptr; /* Copy byte from current buffer to line buffer. */
 200410c:	e0bf7917 	ldw	r2,-540(fp)
 2004110:	10c00003 	ldbu	r3,0(r2)
 2004114:	e0bf7a17 	ldw	r2,-536(fp)
 2004118:	10c00005 	stb	r3,0(r2)
      ++cur_ptr; /* Increment current buffer pointer. */
 200411c:	e0bf7917 	ldw	r2,-540(fp)
 2004120:	10800044 	addi	r2,r2,1
 2004124:	e0bf7915 	stw	r2,-540(fp)
      ++lineBuf_ptr; /* Increment the line buffer pointer. */
 2004128:	e0bf7a17 	ldw	r2,-536(fp)
 200412c:	10800044 	addi	r2,r2,1
 2004130:	e0bf7a15 	stw	r2,-536(fp)
 2004134:	00000306 	br	2004144 <ParseSRECBuf+0x244>
      if ( (cur_ptr == flash_info->start) && (*cur_ptr == '\n') && (frag.len == 0))
      {
        /* Dont' do anything when '\n' is the first character received and
         * there's no data in the frag (line fragment) structure.
         */
        continue;
 2004138:	0001883a 	nop
 200413c:	00000106 	br	2004144 <ParseSRECBuf+0x244>
      }
      lineBuf_ptr = lineBuf; /* Reset the line buffer pointer. */
      eol_flag = 0; /* Reset the end of line flag. */
      /* Need to skip over the end of line markers.
       *    - Both '\n' (UNIX) and '\r\n' (DOS) are supported. */
      if ( (*cur_ptr == '\r') )
 2004140:	0001883a 	nop
  cur_ptr = flash_info->start; /* Point to the beginning of the SREC buffer. */

  //printf( "cur_ptr = 0x%x\n", (int) cur_ptr );
  
  /* Iterate over entire buffer. */
  while( cur_ptr <= ( flash_info->start + flash_info->size ))
 2004144:	e0bfff17 	ldw	r2,-4(fp)
 2004148:	10c00017 	ldw	r3,0(r2)
 200414c:	e0bfff17 	ldw	r2,-4(fp)
 2004150:	10800117 	ldw	r2,4(r2)
 2004154:	1887883a 	add	r3,r3,r2
 2004158:	e0bf7917 	ldw	r2,-540(fp)
 200415c:	18bf752e 	bgeu	r3,r2,2003f34 <ParseSRECBuf+0x34>
      *lineBuf_ptr = *cur_ptr; /* Copy byte from current buffer to line buffer. */
      ++cur_ptr; /* Increment current buffer pointer. */
      ++lineBuf_ptr; /* Increment the line buffer pointer. */
    }
  } /* End of while( cur_ptr <= ( buf + buf_size )) */
  if ( !eol_flag ) /* End of line wasn't reached, but end of buffer was. */
 2004160:	e0bf7b03 	ldbu	r2,-532(fp)
 2004164:	1000151e 	bne	r2,zero,20041bc <ParseSRECBuf+0x2bc>
  {
    /* The following fills the frag (line fragment) data structure
     * which is prepended to the first line received in the next buffer.
     */
    frag.len = lineBuf_ptr - lineBuf; /* Length of line "fragment". */
 2004168:	e0ff7a17 	ldw	r3,-536(fp)
 200416c:	e0bf7f04 	addi	r2,fp,-516
 2004170:	1887c83a 	sub	r3,r3,r2
 2004174:	008098f4 	movhi	r2,611
 2004178:	10876204 	addi	r2,r2,7560
 200417c:	10c00015 	stw	r3,0(r2)
    strcpy( frag.data, lineBuf ); /* Store line fragment. */
 2004180:	e0bf7f04 	addi	r2,fp,-516
 2004184:	010098f4 	movhi	r4,611
 2004188:	21076304 	addi	r4,r4,7564
 200418c:	100b883a 	mov	r5,r2
 2004190:	200756c0 	call	200756c <strcpy>
    frag_end = (char*) (frag.data + frag.len); /* End of the line fragment. */
 2004194:	008098f4 	movhi	r2,611
 2004198:	10876204 	addi	r2,r2,7560
 200419c:	10800017 	ldw	r2,0(r2)
 20041a0:	10c00104 	addi	r3,r2,4
 20041a4:	008098f4 	movhi	r2,611
 20041a8:	10876204 	addi	r2,r2,7560
 20041ac:	1885883a 	add	r2,r3,r2
 20041b0:	e0bf7e15 	stw	r2,-520(fp)
    *frag_end = 0; /* Be sure fragment is a NULL terminated string. */
 20041b4:	e0bf7e17 	ldw	r2,-520(fp)
 20041b8:	10000005 	stb	zero,0(r2)
  }
  return( 0 );
 20041bc:	0005883a 	mov	r2,zero
}
 20041c0:	e037883a 	mov	sp,fp
 20041c4:	dfc00117 	ldw	ra,4(sp)
 20041c8:	df000017 	ldw	fp,0(sp)
 20041cc:	dec00204 	addi	sp,sp,8
 20041d0:	f800283a 	ret

020041d4 <WSInitialTask>:
/* WSInitialTask will initialize the NichStack TCP/IP stack and then initialize
 * the rest of the web server example tasks.
 */

void WSInitialTask(void* pdata)
{
 20041d4:	defffc04 	addi	sp,sp,-16
 20041d8:	dfc00315 	stw	ra,12(sp)
 20041dc:	df000215 	stw	fp,8(sp)
 20041e0:	df000204 	addi	fp,sp,8
 20041e4:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_NO_ERR;
 20041e8:	e03ffe05 	stb	zero,-8(fp)
  * NicheStack is initialized from a task, so that RTOS will have started, and 
  * I/O drivers are available.  Two tasks are created:
  *    "Inet main"  task with priority 2
  *    "clock tick" task with priority 3
  */   
  alt_iniche_init();
 20041ec:	2028d440 	call	2028d44 <alt_iniche_init>
  /* Start the Iniche-specific network tasks and initialize the network
   * devices.
   */
  netmain(); 
 20041f0:	20272ac0 	call	20272ac <netmain>
  /* Wait for the network stack to be ready before proceeding. */
  while (!iniche_net_ready)
 20041f4:	00000206 	br	2004200 <WSInitialTask+0x2c>
    TK_SLEEP(1);
 20041f8:	01000084 	movi	r4,2
 20041fc:	201e00c0 	call	201e00c <OSTimeDly>
  /* Start the Iniche-specific network tasks and initialize the network
   * devices.
   */
  netmain(); 
  /* Wait for the network stack to be ready before proceeding. */
  while (!iniche_net_ready)
 2004200:	00808174 	movhi	r2,517
 2004204:	1090bb04 	addi	r2,r2,17132
 2004208:	10800017 	ldw	r2,0(r2)
 200420c:	103ffa26 	beq	r2,zero,20041f8 <WSInitialTask+0x24>
    TK_SLEEP(1);

  /* Create the main network task.  In this case, a web server. */
  TK_NEWTASK(&wstask);
 2004210:	01008174 	movhi	r4,517
 2004214:	21086a04 	addi	r4,r4,8616
 2004218:	20289e00 	call	20289e0 <TK_NEWTASK>

  /* Application specific code starts here... */
  
  /*Create Tasks*/
  WSCreateTasks();
 200421c:	20042dc0 	call	20042dc <WSCreateTasks>
  printf("\nWeb Server starting up\n");
 2004220:	01008174 	movhi	r4,517
 2004224:	2134f104 	addi	r4,r4,-11324
 2004228:	2006cb40 	call	2006cb4 <puts>
  lcd_ip_addr();
  #endif
  /*This task deletes itself, since there's no reason to keep it around, once
   *it's complete.
   */
  error_code = OSTaskDel(OS_PRIO_SELF);
 200422c:	01003fc4 	movi	r4,255
 2004230:	201cff80 	call	201cff8 <OSTaskDel>
 2004234:	e0bffe05 	stb	r2,-8(fp)
  alt_uCOSIIErrorHandler(error_code, 0);
 2004238:	e0bffe03 	ldbu	r2,-8(fp)
 200423c:	1009883a 	mov	r4,r2
 2004240:	000b883a 	mov	r5,zero
 2004244:	20002040 	call	2000204 <alt_uCOSIIErrorHandler>

  while(1); /*Correct Program Flow should not reach here.*/
 2004248:	003fff06 	br	2004248 <WSInitialTask+0x74>

0200424c <main>:
 * 
 */
OS_EVENT *board_control_mbox;

int main (int argc, char* argv[], char* envp[])
{
 200424c:	defff504 	addi	sp,sp,-44
 2004250:	dfc00a15 	stw	ra,40(sp)
 2004254:	df000915 	stw	fp,36(sp)
 2004258:	df000904 	addi	fp,sp,36
 200425c:	e13ffd15 	stw	r4,-12(fp)
 2004260:	e17ffe15 	stw	r5,-8(fp)
 2004264:	e1bfff15 	stw	r6,-4(fp)
  /* Initialize the current flash block, for flash programming. */
  
  current_flash_block = -1;
 2004268:	00808174 	movhi	r2,517
 200426c:	10908804 	addi	r2,r2,16928
 2004270:	00ffffc4 	movi	r3,-1
 2004274:	10c00015 	stw	r3,0(r2)
  
  INT8U error_code;

  /* Clear the RTOS timer */
  OSTimeSet(0);
 2004278:	0009883a 	mov	r4,zero
 200427c:	201e5d40 	call	201e5d4 <OSTimeSet>
  
  /* WSInitialTask will initialize the NicheStack TCP/IP Stack and then 
   * initialize the rest of the web server's tasks.
   */ 

  error_code = OSTaskCreateExt(WSInitialTask,
 2004280:	00800144 	movi	r2,5
 2004284:	d8800015 	stw	r2,0(sp)
 2004288:	008098f4 	movhi	r2,611
 200428c:	108fa304 	addi	r2,r2,16012
 2004290:	d8800115 	stw	r2,4(sp)
 2004294:	00820004 	movi	r2,2048
 2004298:	d8800215 	stw	r2,8(sp)
 200429c:	d8000315 	stw	zero,12(sp)
 20042a0:	d8000415 	stw	zero,16(sp)
 20042a4:	01008034 	movhi	r4,512
 20042a8:	21107504 	addi	r4,r4,16852
 20042ac:	000b883a 	mov	r5,zero
 20042b0:	018098f4 	movhi	r6,611
 20042b4:	3197a204 	addi	r6,r6,24200
 20042b8:	01c00144 	movi	r7,5
 20042bc:	201ce040 	call	201ce04 <OSTaskCreateExt>
 20042c0:	e0bffc05 	stb	r2,-16(fp)
                             WS_INITIAL_TASK_PRIO,
                             WSInitialTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 20042c4:	e0bffc03 	ldbu	r2,-16(fp)
 20042c8:	1009883a 	mov	r4,r2
 20042cc:	000b883a 	mov	r5,zero
 20042d0:	20002040 	call	2000204 <alt_uCOSIIErrorHandler>

  /*
   * As with all MicroC/OS-II designs, once the initial thread(s) and 
   * associated RTOS resources are declared, we start the RTOS. That's it!
   */
  OSStart();
 20042d4:	20168980 	call	2016898 <OSStart>
  
  while(1); /* Correct Program Flow never gets here. */
 20042d8:	003fff06 	br	20042d8 <main+0x8c>

020042dc <WSCreateTasks>:

  return -1;
}

static void WSCreateTasks()
{
 20042dc:	defff804 	addi	sp,sp,-32
 20042e0:	dfc00715 	stw	ra,28(sp)
 20042e4:	df000615 	stw	fp,24(sp)
 20042e8:	df000604 	addi	fp,sp,24
  INT8U error_code = OS_NO_ERR;
 20042ec:	e03fff05 	stb	zero,-4(fp)
  
  /* Start LED Task. */
  
  error_code = OSTaskCreateExt(LED_task,
 20042f0:	00800184 	movi	r2,6
 20042f4:	d8800015 	stw	r2,0(sp)
 20042f8:	008098f4 	movhi	r2,611
 20042fc:	1097a304 	addi	r2,r2,24204
 2004300:	d8800115 	stw	r2,4(sp)
 2004304:	00820004 	movi	r2,2048
 2004308:	d8800215 	stw	r2,8(sp)
 200430c:	d8000315 	stw	zero,12(sp)
 2004310:	d8000415 	stw	zero,16(sp)
 2004314:	01008034 	movhi	r4,512
 2004318:	21111504 	addi	r4,r4,17492
 200431c:	000b883a 	mov	r5,zero
 2004320:	018098f4 	movhi	r6,611
 2004324:	319fa204 	addi	r6,r6,32392
 2004328:	01c00184 	movi	r7,6
 200432c:	201ce040 	call	201ce04 <OSTaskCreateExt>
 2004330:	e0bfff05 	stb	r2,-4(fp)
                             LED_PRIO,
                             LEDTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 2004334:	e0bfff03 	ldbu	r2,-4(fp)
 2004338:	1009883a 	mov	r4,r2
 200433c:	000b883a 	mov	r5,zero
 2004340:	20002040 	call	2000204 <alt_uCOSIIErrorHandler>
  alt_uCOSIIErrorHandler(error_code, 0);
  #endif
  
  /* Start Board Control Task. */
  
  error_code = OSTaskCreateExt(board_control_task,
 2004344:	00800204 	movi	r2,8
 2004348:	d8800015 	stw	r2,0(sp)
 200434c:	008098f4 	movhi	r2,611
 2004350:	109fa304 	addi	r2,r2,32396
 2004354:	d8800115 	stw	r2,4(sp)
 2004358:	00820004 	movi	r2,2048
 200435c:	d8800215 	stw	r2,8(sp)
 2004360:	d8000315 	stw	zero,12(sp)
 2004364:	d8000415 	stw	zero,16(sp)
 2004368:	01008034 	movhi	r4,512
 200436c:	2110ef04 	addi	r4,r4,17340
 2004370:	000b883a 	mov	r5,zero
 2004374:	01809934 	movhi	r6,612
 2004378:	31a7a204 	addi	r6,r6,-24952
 200437c:	01c00204 	movi	r7,8
 2004380:	201ce040 	call	201ce04 <OSTaskCreateExt>
 2004384:	e0bfff05 	stb	r2,-4(fp)
                             BOARD_PRIO,
                             BCTaskStk,
                             TASK_STACKSIZE,
                             NULL,
                             0);
  alt_uCOSIIErrorHandler(error_code, 0);
 2004388:	e0bfff03 	ldbu	r2,-4(fp)
 200438c:	1009883a 	mov	r4,r2
 2004390:	000b883a 	mov	r5,zero
 2004394:	20002040 	call	2000204 <alt_uCOSIIErrorHandler>
  
  /* Suspend both the LED and SSD tasks on start. */
  
  OSTaskSuspend(LED_PRIO);
 2004398:	01000184 	movi	r4,6
 200439c:	201dc600 	call	201dc60 <OSTaskSuspend>
  OSTaskSuspend(SSD_PRIO);
 20043a0:	010001c4 	movi	r4,7
 20043a4:	201dc600 	call	201dc60 <OSTaskSuspend>

  /* The web server task is started by the Interniche stack, as the "main" network servicing task. */
  
}
 20043a8:	e037883a 	mov	sp,fp
 20043ac:	dfc00117 	ldw	ra,4(sp)
 20043b0:	df000017 	ldw	fp,0(sp)
 20043b4:	dec00204 	addi	sp,sp,8
 20043b8:	f800283a 	ret

020043bc <board_control_task>:
  }
}
#endif

void board_control_task(void *pdata)
{
 20043bc:	defffb04 	addi	sp,sp,-20
 20043c0:	dfc00415 	stw	ra,16(sp)
 20043c4:	df000315 	stw	fp,12(sp)
 20043c8:	df000304 	addi	fp,sp,12
 20043cc:	e13fff15 	stw	r4,-4(fp)
  INT8U error_code = OS_NO_ERR;
 20043d0:	e03ffe05 	stb	zero,-8(fp)
  board_control_mbox = OSMboxCreate((void *)NULL);
 20043d4:	0009883a 	mov	r4,zero
 20043d8:	20197440 	call	2019744 <OSMboxCreate>
 20043dc:	d0a05f15 	stw	r2,-32388(gp)

  struct http_form_data* board_control_mbox_contents;
  
  while(1)
  {
      board_control_mbox_contents = (void*)OSMboxPend(board_control_mbox, 0, &error_code);
 20043e0:	d0e05f17 	ldw	r3,-32388(gp)
 20043e4:	e0bffe04 	addi	r2,fp,-8
 20043e8:	1809883a 	mov	r4,r3
 20043ec:	000b883a 	mov	r5,zero
 20043f0:	100d883a 	mov	r6,r2
 20043f4:	2019ab00 	call	2019ab0 <OSMboxPend>
 20043f8:	e0bffd15 	stw	r2,-12(fp)
      
      if (board_control_mbox_contents->LED_ON)
 20043fc:	e0bffd17 	ldw	r2,-12(fp)
 2004400:	10800003 	ldbu	r2,0(r2)
 2004404:	10803fcc 	andi	r2,r2,255
 2004408:	10000326 	beq	r2,zero,2004418 <board_control_task+0x5c>
      {
        OSTaskResume(LED_PRIO);
 200440c:	01000184 	movi	r4,6
 2004410:	201d8980 	call	201d898 <OSTaskResume>
 2004414:	00000506 	br	200442c <board_control_task+0x70>
      }
      else
      {
        /* Suspend the task and clear the LED. */
        OSTaskSuspend(LED_PRIO);
 2004418:	01000184 	movi	r4,6
 200441c:	201dc600 	call	201dc60 <OSTaskSuspend>
        IOWR_ALTERA_AVALON_PIO_DATA( LED_PIO_BASE, 0 );
 2004420:	0007883a 	mov	r3,zero
 2004424:	0087b004 	movi	r2,7872
 2004428:	10c00035 	stwio	r3,0(r2)
      }
      
      if (board_control_mbox_contents->SSD_ON)
 200442c:	e0bffd17 	ldw	r2,-12(fp)
 2004430:	10800043 	ldbu	r2,1(r2)
 2004434:	10803fcc 	andi	r2,r2,255
 2004438:	10000326 	beq	r2,zero,2004448 <board_control_task+0x8c>
      {
        OSTaskResume(SSD_PRIO);
 200443c:	010001c4 	movi	r4,7
 2004440:	201d8980 	call	201d898 <OSTaskResume>

      /* Always dump text to the LCD... */
	  #ifdef LCD_DISPLAY_NAME
      lcd_output_text( board_control_mbox_contents->LCD_TEXT );
	  #endif
  }
 2004444:	003fe606 	br	20043e0 <board_control_task+0x24>
        OSTaskResume(SSD_PRIO);
      }
      else
      {
        /* Suspend the task and set SSD to all zeros. */
        OSTaskSuspend(SSD_PRIO);
 2004448:	010001c4 	movi	r4,7
 200444c:	201dc600 	call	201dc60 <OSTaskSuspend>

      /* Always dump text to the LCD... */
	  #ifdef LCD_DISPLAY_NAME
      lcd_output_text( board_control_mbox_contents->LCD_TEXT );
	  #endif
  }
 2004450:	003fe306 	br	20043e0 <board_control_task+0x24>

02004454 <LED_task>:
}

void LED_task(void* pdata)
{
 2004454:	defffc04 	addi	sp,sp,-16
 2004458:	dfc00315 	stw	ra,12(sp)
 200445c:	df000215 	stw	fp,8(sp)
 2004460:	df000204 	addi	fp,sp,8
 2004464:	e13fff15 	stw	r4,-4(fp)
  
  alt_u8 led = 0x2;
 2004468:	00800084 	movi	r2,2
 200446c:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 dir = 0;
 2004470:	e03ffe45 	stb	zero,-7(fp)
   * Infinitely shift a variable with one bit set back and forth, and write
   * it to the LED PIO.  Software loop provides delay element.
   */
  while (1) 
  {
    if (led & 0x81) 
 2004474:	e0bffe03 	ldbu	r2,-8(fp)
 2004478:	1080204c 	andi	r2,r2,129
 200447c:	10000326 	beq	r2,zero,200448c <LED_task+0x38>
    {
      dir = (dir ^ 0x1);
 2004480:	e0bffe43 	ldbu	r2,-7(fp)
 2004484:	1080005c 	xori	r2,r2,1
 2004488:	e0bffe45 	stb	r2,-7(fp)
    }

    if (dir) 
 200448c:	e0bffe43 	ldbu	r2,-7(fp)
 2004490:	10000426 	beq	r2,zero,20044a4 <LED_task+0x50>
    {
      led = led >> 1;
 2004494:	e0bffe03 	ldbu	r2,-8(fp)
 2004498:	1004d07a 	srli	r2,r2,1
 200449c:	e0bffe05 	stb	r2,-8(fp)
 20044a0:	00000306 	br	20044b0 <LED_task+0x5c>
    } 
    else 
    {
      led = led << 1;
 20044a4:	e0bffe03 	ldbu	r2,-8(fp)
 20044a8:	1085883a 	add	r2,r2,r2
 20044ac:	e0bffe05 	stb	r2,-8(fp)
    }
    IOWR_ALTERA_AVALON_PIO_DATA(LED_PIO_BASE, led);
 20044b0:	e0fffe03 	ldbu	r3,-8(fp)
 20044b4:	0087b004 	movi	r2,7872
 20044b8:	10c00035 	stwio	r3,0(r2)
    OSTimeDlyHMSM(0,0,0,50);
 20044bc:	0009883a 	mov	r4,zero
 20044c0:	000b883a 	mov	r5,zero
 20044c4:	000d883a 	mov	r6,zero
 20044c8:	01c00c84 	movi	r7,50
 20044cc:	201e1540 	call	201e154 <OSTimeDlyHMSM>
  }
 20044d0:	003fe806 	br	2004474 <LED_task+0x20>

020044d4 <atoi>:
 20044d4:	000b883a 	mov	r5,zero
 20044d8:	01800284 	movi	r6,10
 20044dc:	20089d01 	jmpi	20089d0 <strtol>

020044e0 <_atoi_r>:
 20044e0:	000d883a 	mov	r6,zero
 20044e4:	01c00284 	movi	r7,10
 20044e8:	200876c1 	jmpi	200876c <_strtol_r>

020044ec <_fclose_r>:
 20044ec:	defffc04 	addi	sp,sp,-16
 20044f0:	dc400115 	stw	r17,4(sp)
 20044f4:	dc000015 	stw	r16,0(sp)
 20044f8:	dfc00315 	stw	ra,12(sp)
 20044fc:	dc800215 	stw	r18,8(sp)
 2004500:	2821883a 	mov	r16,r5
 2004504:	2023883a 	mov	r17,r4
 2004508:	28003426 	beq	r5,zero,20045dc <_fclose_r+0xf0>
 200450c:	2004b340 	call	2004b34 <__sfp_lock_acquire>
 2004510:	88000226 	beq	r17,zero,200451c <_fclose_r+0x30>
 2004514:	88800e17 	ldw	r2,56(r17)
 2004518:	10003826 	beq	r2,zero,20045fc <_fclose_r+0x110>
 200451c:	8080030f 	ldh	r2,12(r16)
 2004520:	10002526 	beq	r2,zero,20045b8 <_fclose_r+0xcc>
 2004524:	8809883a 	mov	r4,r17
 2004528:	800b883a 	mov	r5,r16
 200452c:	200463c0 	call	200463c <_fflush_r>
 2004530:	1025883a 	mov	r18,r2
 2004534:	80800b17 	ldw	r2,44(r16)
 2004538:	10000426 	beq	r2,zero,200454c <_fclose_r+0x60>
 200453c:	81400717 	ldw	r5,28(r16)
 2004540:	8809883a 	mov	r4,r17
 2004544:	103ee83a 	callr	r2
 2004548:	10003516 	blt	r2,zero,2004620 <_fclose_r+0x134>
 200454c:	8080030b 	ldhu	r2,12(r16)
 2004550:	1080200c 	andi	r2,r2,128
 2004554:	10bfffcc 	andi	r2,r2,65535
 2004558:	10a0001c 	xori	r2,r2,32768
 200455c:	10a00004 	addi	r2,r2,-32768
 2004560:	10002b1e 	bne	r2,zero,2004610 <_fclose_r+0x124>
 2004564:	81400c17 	ldw	r5,48(r16)
 2004568:	28000526 	beq	r5,zero,2004580 <_fclose_r+0x94>
 200456c:	80801004 	addi	r2,r16,64
 2004570:	28800226 	beq	r5,r2,200457c <_fclose_r+0x90>
 2004574:	8809883a 	mov	r4,r17
 2004578:	20050b40 	call	20050b4 <_free_r>
 200457c:	80000c15 	stw	zero,48(r16)
 2004580:	81401117 	ldw	r5,68(r16)
 2004584:	28000326 	beq	r5,zero,2004594 <_fclose_r+0xa8>
 2004588:	8809883a 	mov	r4,r17
 200458c:	20050b40 	call	20050b4 <_free_r>
 2004590:	80001115 	stw	zero,68(r16)
 2004594:	8000030d 	sth	zero,12(r16)
 2004598:	2004b380 	call	2004b38 <__sfp_lock_release>
 200459c:	9005883a 	mov	r2,r18
 20045a0:	dfc00317 	ldw	ra,12(sp)
 20045a4:	dc800217 	ldw	r18,8(sp)
 20045a8:	dc400117 	ldw	r17,4(sp)
 20045ac:	dc000017 	ldw	r16,0(sp)
 20045b0:	dec00404 	addi	sp,sp,16
 20045b4:	f800283a 	ret
 20045b8:	2004b380 	call	2004b38 <__sfp_lock_release>
 20045bc:	0025883a 	mov	r18,zero
 20045c0:	9005883a 	mov	r2,r18
 20045c4:	dfc00317 	ldw	ra,12(sp)
 20045c8:	dc800217 	ldw	r18,8(sp)
 20045cc:	dc400117 	ldw	r17,4(sp)
 20045d0:	dc000017 	ldw	r16,0(sp)
 20045d4:	dec00404 	addi	sp,sp,16
 20045d8:	f800283a 	ret
 20045dc:	0025883a 	mov	r18,zero
 20045e0:	9005883a 	mov	r2,r18
 20045e4:	dfc00317 	ldw	ra,12(sp)
 20045e8:	dc800217 	ldw	r18,8(sp)
 20045ec:	dc400117 	ldw	r17,4(sp)
 20045f0:	dc000017 	ldw	r16,0(sp)
 20045f4:	dec00404 	addi	sp,sp,16
 20045f8:	f800283a 	ret
 20045fc:	8809883a 	mov	r4,r17
 2004600:	200492c0 	call	200492c <__sinit>
 2004604:	8080030f 	ldh	r2,12(r16)
 2004608:	103fc61e 	bne	r2,zero,2004524 <_fclose_r+0x38>
 200460c:	003fea06 	br	20045b8 <_fclose_r+0xcc>
 2004610:	81400417 	ldw	r5,16(r16)
 2004614:	8809883a 	mov	r4,r17
 2004618:	20050b40 	call	20050b4 <_free_r>
 200461c:	003fd106 	br	2004564 <_fclose_r+0x78>
 2004620:	04bfffc4 	movi	r18,-1
 2004624:	003fc906 	br	200454c <_fclose_r+0x60>

02004628 <fclose>:
 2004628:	00808174 	movhi	r2,517
 200462c:	10903604 	addi	r2,r2,16600
 2004630:	200b883a 	mov	r5,r4
 2004634:	11000017 	ldw	r4,0(r2)
 2004638:	20044ec1 	jmpi	20044ec <_fclose_r>

0200463c <_fflush_r>:
 200463c:	defffb04 	addi	sp,sp,-20
 2004640:	dcc00315 	stw	r19,12(sp)
 2004644:	dc400115 	stw	r17,4(sp)
 2004648:	dfc00415 	stw	ra,16(sp)
 200464c:	dc800215 	stw	r18,8(sp)
 2004650:	dc000015 	stw	r16,0(sp)
 2004654:	2027883a 	mov	r19,r4
 2004658:	2823883a 	mov	r17,r5
 200465c:	20000226 	beq	r4,zero,2004668 <_fflush_r+0x2c>
 2004660:	20800e17 	ldw	r2,56(r4)
 2004664:	10005726 	beq	r2,zero,20047c4 <_fflush_r+0x188>
 2004668:	8880030b 	ldhu	r2,12(r17)
 200466c:	10c0020c 	andi	r3,r2,8
 2004670:	18ffffcc 	andi	r3,r3,65535
 2004674:	18e0001c 	xori	r3,r3,32768
 2004678:	18e00004 	addi	r3,r3,-32768
 200467c:	1800311e 	bne	r3,zero,2004744 <_fflush_r+0x108>
 2004680:	89000117 	ldw	r4,4(r17)
 2004684:	10c20014 	ori	r3,r2,2048
 2004688:	88c0030d 	sth	r3,12(r17)
 200468c:	180b883a 	mov	r5,r3
 2004690:	0100520e 	bge	zero,r4,20047dc <_fflush_r+0x1a0>
 2004694:	88c00a17 	ldw	r3,40(r17)
 2004698:	18002226 	beq	r3,zero,2004724 <_fflush_r+0xe8>
 200469c:	1084000c 	andi	r2,r2,4096
 20046a0:	10bfffcc 	andi	r2,r2,65535
 20046a4:	10a0001c 	xori	r2,r2,32768
 20046a8:	10a00004 	addi	r2,r2,-32768
 20046ac:	10004e26 	beq	r2,zero,20047e8 <_fflush_r+0x1ac>
 20046b0:	8c001417 	ldw	r16,80(r17)
 20046b4:	2940010c 	andi	r5,r5,4
 20046b8:	297fffcc 	andi	r5,r5,65535
 20046bc:	2960001c 	xori	r5,r5,32768
 20046c0:	29600004 	addi	r5,r5,-32768
 20046c4:	28000626 	beq	r5,zero,20046e0 <_fflush_r+0xa4>
 20046c8:	89000117 	ldw	r4,4(r17)
 20046cc:	88800c17 	ldw	r2,48(r17)
 20046d0:	8121c83a 	sub	r16,r16,r4
 20046d4:	10000226 	beq	r2,zero,20046e0 <_fflush_r+0xa4>
 20046d8:	88800f17 	ldw	r2,60(r17)
 20046dc:	80a1c83a 	sub	r16,r16,r2
 20046e0:	89400717 	ldw	r5,28(r17)
 20046e4:	9809883a 	mov	r4,r19
 20046e8:	800d883a 	mov	r6,r16
 20046ec:	000f883a 	mov	r7,zero
 20046f0:	183ee83a 	callr	r3
 20046f4:	8080281e 	bne	r16,r2,2004798 <_fflush_r+0x15c>
 20046f8:	8880030b 	ldhu	r2,12(r17)
 20046fc:	88c00417 	ldw	r3,16(r17)
 2004700:	88000115 	stw	zero,4(r17)
 2004704:	113dffcc 	andi	r4,r2,63487
 2004708:	1084000c 	andi	r2,r2,4096
 200470c:	10bfffcc 	andi	r2,r2,65535
 2004710:	10a0001c 	xori	r2,r2,32768
 2004714:	8900030d 	sth	r4,12(r17)
 2004718:	88c00015 	stw	r3,0(r17)
 200471c:	10a00004 	addi	r2,r2,-32768
 2004720:	10002c1e 	bne	r2,zero,20047d4 <_fflush_r+0x198>
 2004724:	0005883a 	mov	r2,zero
 2004728:	dfc00417 	ldw	ra,16(sp)
 200472c:	dcc00317 	ldw	r19,12(sp)
 2004730:	dc800217 	ldw	r18,8(sp)
 2004734:	dc400117 	ldw	r17,4(sp)
 2004738:	dc000017 	ldw	r16,0(sp)
 200473c:	dec00504 	addi	sp,sp,20
 2004740:	f800283a 	ret
 2004744:	8c800417 	ldw	r18,16(r17)
 2004748:	903ff626 	beq	r18,zero,2004724 <_fflush_r+0xe8>
 200474c:	8c000017 	ldw	r16,0(r17)
 2004750:	108000cc 	andi	r2,r2,3
 2004754:	8c800015 	stw	r18,0(r17)
 2004758:	84a1c83a 	sub	r16,r16,r18
 200475c:	10001b1e 	bne	r2,zero,20047cc <_fflush_r+0x190>
 2004760:	88800517 	ldw	r2,20(r17)
 2004764:	88800215 	stw	r2,8(r17)
 2004768:	04000316 	blt	zero,r16,2004778 <_fflush_r+0x13c>
 200476c:	003fed06 	br	2004724 <_fflush_r+0xe8>
 2004770:	90a5883a 	add	r18,r18,r2
 2004774:	043feb0e 	bge	zero,r16,2004724 <_fflush_r+0xe8>
 2004778:	88800917 	ldw	r2,36(r17)
 200477c:	89400717 	ldw	r5,28(r17)
 2004780:	800f883a 	mov	r7,r16
 2004784:	900d883a 	mov	r6,r18
 2004788:	9809883a 	mov	r4,r19
 200478c:	103ee83a 	callr	r2
 2004790:	80a1c83a 	sub	r16,r16,r2
 2004794:	00bff616 	blt	zero,r2,2004770 <_fflush_r+0x134>
 2004798:	88c0030b 	ldhu	r3,12(r17)
 200479c:	00bfffc4 	movi	r2,-1
 20047a0:	18c01014 	ori	r3,r3,64
 20047a4:	88c0030d 	sth	r3,12(r17)
 20047a8:	dfc00417 	ldw	ra,16(sp)
 20047ac:	dcc00317 	ldw	r19,12(sp)
 20047b0:	dc800217 	ldw	r18,8(sp)
 20047b4:	dc400117 	ldw	r17,4(sp)
 20047b8:	dc000017 	ldw	r16,0(sp)
 20047bc:	dec00504 	addi	sp,sp,20
 20047c0:	f800283a 	ret
 20047c4:	200492c0 	call	200492c <__sinit>
 20047c8:	003fa706 	br	2004668 <_fflush_r+0x2c>
 20047cc:	0005883a 	mov	r2,zero
 20047d0:	003fe406 	br	2004764 <_fflush_r+0x128>
 20047d4:	8c001415 	stw	r16,80(r17)
 20047d8:	003fd206 	br	2004724 <_fflush_r+0xe8>
 20047dc:	88c00f17 	ldw	r3,60(r17)
 20047e0:	00ffac16 	blt	zero,r3,2004694 <_fflush_r+0x58>
 20047e4:	003fcf06 	br	2004724 <_fflush_r+0xe8>
 20047e8:	89400717 	ldw	r5,28(r17)
 20047ec:	9809883a 	mov	r4,r19
 20047f0:	000d883a 	mov	r6,zero
 20047f4:	01c00044 	movi	r7,1
 20047f8:	183ee83a 	callr	r3
 20047fc:	1021883a 	mov	r16,r2
 2004800:	00bfffc4 	movi	r2,-1
 2004804:	80800326 	beq	r16,r2,2004814 <_fflush_r+0x1d8>
 2004808:	8940030b 	ldhu	r5,12(r17)
 200480c:	88c00a17 	ldw	r3,40(r17)
 2004810:	003fa806 	br	20046b4 <_fflush_r+0x78>
 2004814:	98c00017 	ldw	r3,0(r19)
 2004818:	00800744 	movi	r2,29
 200481c:	18bfde1e 	bne	r3,r2,2004798 <_fflush_r+0x15c>
 2004820:	003fc006 	br	2004724 <_fflush_r+0xe8>

02004824 <fflush>:
 2004824:	200b883a 	mov	r5,r4
 2004828:	20000426 	beq	r4,zero,200483c <fflush+0x18>
 200482c:	00808174 	movhi	r2,517
 2004830:	10903604 	addi	r2,r2,16600
 2004834:	11000017 	ldw	r4,0(r2)
 2004838:	200463c1 	jmpi	200463c <_fflush_r>
 200483c:	00808174 	movhi	r2,517
 2004840:	10903504 	addi	r2,r2,16596
 2004844:	11000017 	ldw	r4,0(r2)
 2004848:	01408034 	movhi	r5,512
 200484c:	29518f04 	addi	r5,r5,17980
 2004850:	2005a501 	jmpi	2005a50 <_fwalk_reent>

02004854 <_fgetpos_r>:
 2004854:	defffe04 	addi	sp,sp,-8
 2004858:	dc000015 	stw	r16,0(sp)
 200485c:	dfc00115 	stw	ra,4(sp)
 2004860:	3021883a 	mov	r16,r6
 2004864:	20058840 	call	2005884 <_ftell_r>
 2004868:	80800015 	stw	r2,0(r16)
 200486c:	10bfffe0 	cmpeqi	r2,r2,-1
 2004870:	dfc00117 	ldw	ra,4(sp)
 2004874:	dc000017 	ldw	r16,0(sp)
 2004878:	dec00204 	addi	sp,sp,8
 200487c:	f800283a 	ret

02004880 <fgetpos>:
 2004880:	00c08174 	movhi	r3,517
 2004884:	18d03604 	addi	r3,r3,16600
 2004888:	2005883a 	mov	r2,r4
 200488c:	19000017 	ldw	r4,0(r3)
 2004890:	280d883a 	mov	r6,r5
 2004894:	100b883a 	mov	r5,r2
 2004898:	20048541 	jmpi	2004854 <_fgetpos_r>

0200489c <__fp_lock>:
 200489c:	0005883a 	mov	r2,zero
 20048a0:	f800283a 	ret

020048a4 <__fp_unlock>:
 20048a4:	0005883a 	mov	r2,zero
 20048a8:	f800283a 	ret

020048ac <_cleanup_r>:
 20048ac:	01408034 	movhi	r5,512
 20048b0:	29518a04 	addi	r5,r5,17960
 20048b4:	20059a81 	jmpi	20059a8 <_fwalk>

020048b8 <__sfmoreglue>:
 20048b8:	defffc04 	addi	sp,sp,-16
 20048bc:	dc400115 	stw	r17,4(sp)
 20048c0:	2c401724 	muli	r17,r5,92
 20048c4:	dc800215 	stw	r18,8(sp)
 20048c8:	2825883a 	mov	r18,r5
 20048cc:	89400304 	addi	r5,r17,12
 20048d0:	dc000015 	stw	r16,0(sp)
 20048d4:	dfc00315 	stw	ra,12(sp)
 20048d8:	2005e880 	call	2005e88 <_malloc_r>
 20048dc:	1021883a 	mov	r16,r2
 20048e0:	10000726 	beq	r2,zero,2004900 <__sfmoreglue+0x48>
 20048e4:	11000304 	addi	r4,r2,12
 20048e8:	10000015 	stw	zero,0(r2)
 20048ec:	14800115 	stw	r18,4(r2)
 20048f0:	11000215 	stw	r4,8(r2)
 20048f4:	000b883a 	mov	r5,zero
 20048f8:	880d883a 	mov	r6,r17
 20048fc:	200682c0 	call	200682c <memset>
 2004900:	8005883a 	mov	r2,r16
 2004904:	dfc00317 	ldw	ra,12(sp)
 2004908:	dc800217 	ldw	r18,8(sp)
 200490c:	dc400117 	ldw	r17,4(sp)
 2004910:	dc000017 	ldw	r16,0(sp)
 2004914:	dec00404 	addi	sp,sp,16
 2004918:	f800283a 	ret

0200491c <_cleanup>:
 200491c:	00808174 	movhi	r2,517
 2004920:	10903504 	addi	r2,r2,16596
 2004924:	11000017 	ldw	r4,0(r2)
 2004928:	20048ac1 	jmpi	20048ac <_cleanup_r>

0200492c <__sinit>:
 200492c:	20800e17 	ldw	r2,56(r4)
 2004930:	1000401e 	bne	r2,zero,2004a34 <__sinit+0x108>
 2004934:	21400117 	ldw	r5,4(r4)
 2004938:	01808034 	movhi	r6,512
 200493c:	31922b04 	addi	r6,r6,18604
 2004940:	20c00217 	ldw	r3,8(r4)
 2004944:	21800f15 	stw	r6,60(r4)
 2004948:	2080bb04 	addi	r2,r4,748
 200494c:	02400044 	movi	r9,1
 2004950:	018000c4 	movi	r6,3
 2004954:	2180b915 	stw	r6,740(r4)
 2004958:	2080ba15 	stw	r2,744(r4)
 200495c:	22400e15 	stw	r9,56(r4)
 2004960:	20800317 	ldw	r2,12(r4)
 2004964:	2000b815 	stw	zero,736(r4)
 2004968:	02008034 	movhi	r8,512
 200496c:	421c5504 	addi	r8,r8,29012
 2004970:	01c08034 	movhi	r7,512
 2004974:	39dc6a04 	addi	r7,r7,29096
 2004978:	01808034 	movhi	r6,512
 200497c:	319c8c04 	addi	r6,r6,29232
 2004980:	01008034 	movhi	r4,512
 2004984:	211ca304 	addi	r4,r4,29324
 2004988:	02800104 	movi	r10,4
 200498c:	28000015 	stw	zero,0(r5)
 2004990:	28000115 	stw	zero,4(r5)
 2004994:	28000215 	stw	zero,8(r5)
 2004998:	2a80030d 	sth	r10,12(r5)
 200499c:	2800038d 	sth	zero,14(r5)
 20049a0:	28000415 	stw	zero,16(r5)
 20049a4:	28000515 	stw	zero,20(r5)
 20049a8:	28000615 	stw	zero,24(r5)
 20049ac:	29400715 	stw	r5,28(r5)
 20049b0:	2a000815 	stw	r8,32(r5)
 20049b4:	29c00915 	stw	r7,36(r5)
 20049b8:	29800a15 	stw	r6,40(r5)
 20049bc:	29000b15 	stw	r4,44(r5)
 20049c0:	01400284 	movi	r5,10
 20049c4:	18000015 	stw	zero,0(r3)
 20049c8:	18000115 	stw	zero,4(r3)
 20049cc:	18000215 	stw	zero,8(r3)
 20049d0:	1940030d 	sth	r5,12(r3)
 20049d4:	1a40038d 	sth	r9,14(r3)
 20049d8:	18000415 	stw	zero,16(r3)
 20049dc:	18000515 	stw	zero,20(r3)
 20049e0:	18000615 	stw	zero,24(r3)
 20049e4:	18c00715 	stw	r3,28(r3)
 20049e8:	1a000815 	stw	r8,32(r3)
 20049ec:	19c00915 	stw	r7,36(r3)
 20049f0:	19800a15 	stw	r6,40(r3)
 20049f4:	19000b15 	stw	r4,44(r3)
 20049f8:	00c00484 	movi	r3,18
 20049fc:	10c0030d 	sth	r3,12(r2)
 2004a00:	00c00084 	movi	r3,2
 2004a04:	10000015 	stw	zero,0(r2)
 2004a08:	10000115 	stw	zero,4(r2)
 2004a0c:	10000215 	stw	zero,8(r2)
 2004a10:	10c0038d 	sth	r3,14(r2)
 2004a14:	10000415 	stw	zero,16(r2)
 2004a18:	10000515 	stw	zero,20(r2)
 2004a1c:	10000615 	stw	zero,24(r2)
 2004a20:	10800715 	stw	r2,28(r2)
 2004a24:	12000815 	stw	r8,32(r2)
 2004a28:	11c00915 	stw	r7,36(r2)
 2004a2c:	11800a15 	stw	r6,40(r2)
 2004a30:	11000b15 	stw	r4,44(r2)
 2004a34:	f800283a 	ret

02004a38 <__sfp>:
 2004a38:	defffc04 	addi	sp,sp,-16
 2004a3c:	00808174 	movhi	r2,517
 2004a40:	10903504 	addi	r2,r2,16596
 2004a44:	dc400115 	stw	r17,4(sp)
 2004a48:	14400017 	ldw	r17,0(r2)
 2004a4c:	dc800215 	stw	r18,8(sp)
 2004a50:	dfc00315 	stw	ra,12(sp)
 2004a54:	88800e17 	ldw	r2,56(r17)
 2004a58:	dc000015 	stw	r16,0(sp)
 2004a5c:	2025883a 	mov	r18,r4
 2004a60:	10002826 	beq	r2,zero,2004b04 <__sfp+0xcc>
 2004a64:	8c40b804 	addi	r17,r17,736
 2004a68:	043fffc4 	movi	r16,-1
 2004a6c:	89400117 	ldw	r5,4(r17)
 2004a70:	88800217 	ldw	r2,8(r17)
 2004a74:	297fffc4 	addi	r5,r5,-1
 2004a78:	28000a16 	blt	r5,zero,2004aa4 <__sfp+0x6c>
 2004a7c:	10c0030f 	ldh	r3,12(r2)
 2004a80:	18000c26 	beq	r3,zero,2004ab4 <__sfp+0x7c>
 2004a84:	10c01a04 	addi	r3,r2,104
 2004a88:	00000206 	br	2004a94 <__sfp+0x5c>
 2004a8c:	19bfe90f 	ldh	r6,-92(r3)
 2004a90:	30000826 	beq	r6,zero,2004ab4 <__sfp+0x7c>
 2004a94:	297fffc4 	addi	r5,r5,-1
 2004a98:	18bffd04 	addi	r2,r3,-12
 2004a9c:	18c01704 	addi	r3,r3,92
 2004aa0:	2c3ffa1e 	bne	r5,r16,2004a8c <__sfp+0x54>
 2004aa4:	88800017 	ldw	r2,0(r17)
 2004aa8:	10001926 	beq	r2,zero,2004b10 <__sfp+0xd8>
 2004aac:	1023883a 	mov	r17,r2
 2004ab0:	003fee06 	br	2004a6c <__sfp+0x34>
 2004ab4:	00ffffc4 	movi	r3,-1
 2004ab8:	10c0038d 	sth	r3,14(r2)
 2004abc:	00c00044 	movi	r3,1
 2004ac0:	10c0030d 	sth	r3,12(r2)
 2004ac4:	10000015 	stw	zero,0(r2)
 2004ac8:	10000215 	stw	zero,8(r2)
 2004acc:	10000115 	stw	zero,4(r2)
 2004ad0:	10000415 	stw	zero,16(r2)
 2004ad4:	10000515 	stw	zero,20(r2)
 2004ad8:	10000615 	stw	zero,24(r2)
 2004adc:	10000c15 	stw	zero,48(r2)
 2004ae0:	10000d15 	stw	zero,52(r2)
 2004ae4:	10001115 	stw	zero,68(r2)
 2004ae8:	10001215 	stw	zero,72(r2)
 2004aec:	dfc00317 	ldw	ra,12(sp)
 2004af0:	dc800217 	ldw	r18,8(sp)
 2004af4:	dc400117 	ldw	r17,4(sp)
 2004af8:	dc000017 	ldw	r16,0(sp)
 2004afc:	dec00404 	addi	sp,sp,16
 2004b00:	f800283a 	ret
 2004b04:	8809883a 	mov	r4,r17
 2004b08:	200492c0 	call	200492c <__sinit>
 2004b0c:	003fd506 	br	2004a64 <__sfp+0x2c>
 2004b10:	9009883a 	mov	r4,r18
 2004b14:	01400104 	movi	r5,4
 2004b18:	20048b80 	call	20048b8 <__sfmoreglue>
 2004b1c:	88800015 	stw	r2,0(r17)
 2004b20:	103fe21e 	bne	r2,zero,2004aac <__sfp+0x74>
 2004b24:	00800304 	movi	r2,12
 2004b28:	90800015 	stw	r2,0(r18)
 2004b2c:	0005883a 	mov	r2,zero
 2004b30:	003fee06 	br	2004aec <__sfp+0xb4>

02004b34 <__sfp_lock_acquire>:
 2004b34:	f800283a 	ret

02004b38 <__sfp_lock_release>:
 2004b38:	f800283a 	ret

02004b3c <__sinit_lock_acquire>:
 2004b3c:	f800283a 	ret

02004b40 <__sinit_lock_release>:
 2004b40:	f800283a 	ret

02004b44 <__fp_lock_all>:
 2004b44:	00808174 	movhi	r2,517
 2004b48:	10903604 	addi	r2,r2,16600
 2004b4c:	11000017 	ldw	r4,0(r2)
 2004b50:	01408034 	movhi	r5,512
 2004b54:	29522704 	addi	r5,r5,18588
 2004b58:	20059a81 	jmpi	20059a8 <_fwalk>

02004b5c <__fp_unlock_all>:
 2004b5c:	00808174 	movhi	r2,517
 2004b60:	10903604 	addi	r2,r2,16600
 2004b64:	11000017 	ldw	r4,0(r2)
 2004b68:	01408034 	movhi	r5,512
 2004b6c:	29522904 	addi	r5,r5,18596
 2004b70:	20059a81 	jmpi	20059a8 <_fwalk>

02004b74 <_fopen_r>:
 2004b74:	defffa04 	addi	sp,sp,-24
 2004b78:	dcc00415 	stw	r19,16(sp)
 2004b7c:	2827883a 	mov	r19,r5
 2004b80:	300b883a 	mov	r5,r6
 2004b84:	d80d883a 	mov	r6,sp
 2004b88:	dc800315 	stw	r18,12(sp)
 2004b8c:	dc400215 	stw	r17,8(sp)
 2004b90:	dfc00515 	stw	ra,20(sp)
 2004b94:	dc000115 	stw	r16,4(sp)
 2004b98:	2025883a 	mov	r18,r4
 2004b9c:	200db440 	call	200db44 <__sflags>
 2004ba0:	1023883a 	mov	r17,r2
 2004ba4:	10002926 	beq	r2,zero,2004c4c <_fopen_r+0xd8>
 2004ba8:	9009883a 	mov	r4,r18
 2004bac:	2004a380 	call	2004a38 <__sfp>
 2004bb0:	1021883a 	mov	r16,r2
 2004bb4:	10002526 	beq	r2,zero,2004c4c <_fopen_r+0xd8>
 2004bb8:	d9800017 	ldw	r6,0(sp)
 2004bbc:	9009883a 	mov	r4,r18
 2004bc0:	980b883a 	mov	r5,r19
 2004bc4:	01c06d84 	movi	r7,438
 2004bc8:	20069080 	call	2006908 <_open_r>
 2004bcc:	10001c16 	blt	r2,zero,2004c40 <_fopen_r+0xcc>
 2004bd0:	8080038d 	sth	r2,14(r16)
 2004bd4:	00808034 	movhi	r2,512
 2004bd8:	109c5504 	addi	r2,r2,29012
 2004bdc:	80800815 	stw	r2,32(r16)
 2004be0:	00808034 	movhi	r2,512
 2004be4:	109c6a04 	addi	r2,r2,29096
 2004be8:	80800915 	stw	r2,36(r16)
 2004bec:	00808034 	movhi	r2,512
 2004bf0:	109c8c04 	addi	r2,r2,29232
 2004bf4:	88c0400c 	andi	r3,r17,256
 2004bf8:	80800a15 	stw	r2,40(r16)
 2004bfc:	00808034 	movhi	r2,512
 2004c00:	109ca304 	addi	r2,r2,29324
 2004c04:	80800b15 	stw	r2,44(r16)
 2004c08:	18bfffcc 	andi	r2,r3,65535
 2004c0c:	10a0001c 	xori	r2,r2,32768
 2004c10:	8440030d 	sth	r17,12(r16)
 2004c14:	84000715 	stw	r16,28(r16)
 2004c18:	10a00004 	addi	r2,r2,-32768
 2004c1c:	1000141e 	bne	r2,zero,2004c70 <_fopen_r+0xfc>
 2004c20:	8005883a 	mov	r2,r16
 2004c24:	dfc00517 	ldw	ra,20(sp)
 2004c28:	dcc00417 	ldw	r19,16(sp)
 2004c2c:	dc800317 	ldw	r18,12(sp)
 2004c30:	dc400217 	ldw	r17,8(sp)
 2004c34:	dc000117 	ldw	r16,4(sp)
 2004c38:	dec00604 	addi	sp,sp,24
 2004c3c:	f800283a 	ret
 2004c40:	2004b340 	call	2004b34 <__sfp_lock_acquire>
 2004c44:	8000030d 	sth	zero,12(r16)
 2004c48:	2004b380 	call	2004b38 <__sfp_lock_release>
 2004c4c:	0021883a 	mov	r16,zero
 2004c50:	8005883a 	mov	r2,r16
 2004c54:	dfc00517 	ldw	ra,20(sp)
 2004c58:	dcc00417 	ldw	r19,16(sp)
 2004c5c:	dc800317 	ldw	r18,12(sp)
 2004c60:	dc400217 	ldw	r17,8(sp)
 2004c64:	dc000117 	ldw	r16,4(sp)
 2004c68:	dec00604 	addi	sp,sp,24
 2004c6c:	f800283a 	ret
 2004c70:	9009883a 	mov	r4,r18
 2004c74:	800b883a 	mov	r5,r16
 2004c78:	000d883a 	mov	r6,zero
 2004c7c:	01c00084 	movi	r7,2
 2004c80:	20053840 	call	2005384 <_fseek_r>
 2004c84:	8005883a 	mov	r2,r16
 2004c88:	dfc00517 	ldw	ra,20(sp)
 2004c8c:	dcc00417 	ldw	r19,16(sp)
 2004c90:	dc800317 	ldw	r18,12(sp)
 2004c94:	dc400217 	ldw	r17,8(sp)
 2004c98:	dc000117 	ldw	r16,4(sp)
 2004c9c:	dec00604 	addi	sp,sp,24
 2004ca0:	f800283a 	ret

02004ca4 <fopen>:
 2004ca4:	00c08174 	movhi	r3,517
 2004ca8:	18d03604 	addi	r3,r3,16600
 2004cac:	2005883a 	mov	r2,r4
 2004cb0:	19000017 	ldw	r4,0(r3)
 2004cb4:	280d883a 	mov	r6,r5
 2004cb8:	100b883a 	mov	r5,r2
 2004cbc:	2004b741 	jmpi	2004b74 <_fopen_r>

02004cc0 <_fprintf_r>:
 2004cc0:	defffe04 	addi	sp,sp,-8
 2004cc4:	2809883a 	mov	r4,r5
 2004cc8:	dfc00015 	stw	ra,0(sp)
 2004ccc:	d9c00115 	stw	r7,4(sp)
 2004cd0:	300b883a 	mov	r5,r6
 2004cd4:	d9800104 	addi	r6,sp,4
 2004cd8:	200a8280 	call	200a828 <__vfprintf_internal>
 2004cdc:	dfc00017 	ldw	ra,0(sp)
 2004ce0:	dec00204 	addi	sp,sp,8
 2004ce4:	f800283a 	ret

02004ce8 <fprintf>:
 2004ce8:	defffd04 	addi	sp,sp,-12
 2004cec:	dfc00015 	stw	ra,0(sp)
 2004cf0:	d9800115 	stw	r6,4(sp)
 2004cf4:	d9c00215 	stw	r7,8(sp)
 2004cf8:	d9800104 	addi	r6,sp,4
 2004cfc:	200a8280 	call	200a828 <__vfprintf_internal>
 2004d00:	dfc00017 	ldw	ra,0(sp)
 2004d04:	dec00304 	addi	sp,sp,12
 2004d08:	f800283a 	ret

02004d0c <_fread_r>:
 2004d0c:	defff504 	addi	sp,sp,-44
 2004d10:	dd800715 	stw	r22,28(sp)
 2004d14:	39ad383a 	mul	r22,r7,r6
 2004d18:	ddc00815 	stw	r23,32(sp)
 2004d1c:	dd400615 	stw	r21,24(sp)
 2004d20:	dd000515 	stw	r20,20(sp)
 2004d24:	dcc00415 	stw	r19,16(sp)
 2004d28:	dc000115 	stw	r16,4(sp)
 2004d2c:	dfc00a15 	stw	ra,40(sp)
 2004d30:	df000915 	stw	fp,36(sp)
 2004d34:	dc800315 	stw	r18,12(sp)
 2004d38:	dc400215 	stw	r17,8(sp)
 2004d3c:	302f883a 	mov	r23,r6
 2004d40:	382b883a 	mov	r21,r7
 2004d44:	2029883a 	mov	r20,r4
 2004d48:	2827883a 	mov	r19,r5
 2004d4c:	dc000b17 	ldw	r16,44(sp)
 2004d50:	b0002e26 	beq	r22,zero,2004e0c <_fread_r+0x100>
 2004d54:	20000226 	beq	r4,zero,2004d60 <_fread_r+0x54>
 2004d58:	20800e17 	ldw	r2,56(r4)
 2004d5c:	10006726 	beq	r2,zero,2004efc <_fread_r+0x1f0>
 2004d60:	84400117 	ldw	r17,4(r16)
 2004d64:	88002b16 	blt	r17,zero,2004e14 <_fread_r+0x108>
 2004d68:	8080030b 	ldhu	r2,12(r16)
 2004d6c:	8807883a 	mov	r3,r17
 2004d70:	1080008c 	andi	r2,r2,2
 2004d74:	10bfffcc 	andi	r2,r2,65535
 2004d78:	10a0001c 	xori	r2,r2,32768
 2004d7c:	10a00004 	addi	r2,r2,-32768
 2004d80:	10002d1e 	bne	r2,zero,2004e38 <_fread_r+0x12c>
 2004d84:	b025883a 	mov	r18,r22
 2004d88:	00000106 	br	2004d90 <_fread_r+0x84>
 2004d8c:	84400117 	ldw	r17,4(r16)
 2004d90:	9809883a 	mov	r4,r19
 2004d94:	880d883a 	mov	r6,r17
 2004d98:	81400017 	ldw	r5,0(r16)
 2004d9c:	8c805b2e 	bgeu	r17,r18,2004f0c <_fread_r+0x200>
 2004da0:	200660c0 	call	200660c <memcpy>
 2004da4:	80800017 	ldw	r2,0(r16)
 2004da8:	9c67883a 	add	r19,r19,r17
 2004dac:	9465c83a 	sub	r18,r18,r17
 2004db0:	1463883a 	add	r17,r2,r17
 2004db4:	a009883a 	mov	r4,r20
 2004db8:	800b883a 	mov	r5,r16
 2004dbc:	84400015 	stw	r17,0(r16)
 2004dc0:	2006ce40 	call	2006ce4 <__srefill_r>
 2004dc4:	103ff126 	beq	r2,zero,2004d8c <_fread_r+0x80>
 2004dc8:	b489c83a 	sub	r4,r22,r18
 2004dcc:	b80b883a 	mov	r5,r23
 2004dd0:	201479c0 	call	201479c <__udivsi3>
 2004dd4:	102b883a 	mov	r21,r2
 2004dd8:	a805883a 	mov	r2,r21
 2004ddc:	dfc00a17 	ldw	ra,40(sp)
 2004de0:	df000917 	ldw	fp,36(sp)
 2004de4:	ddc00817 	ldw	r23,32(sp)
 2004de8:	dd800717 	ldw	r22,28(sp)
 2004dec:	dd400617 	ldw	r21,24(sp)
 2004df0:	dd000517 	ldw	r20,20(sp)
 2004df4:	dcc00417 	ldw	r19,16(sp)
 2004df8:	dc800317 	ldw	r18,12(sp)
 2004dfc:	dc400217 	ldw	r17,8(sp)
 2004e00:	dc000117 	ldw	r16,4(sp)
 2004e04:	dec00b04 	addi	sp,sp,44
 2004e08:	f800283a 	ret
 2004e0c:	002b883a 	mov	r21,zero
 2004e10:	003ff106 	br	2004dd8 <_fread_r+0xcc>
 2004e14:	8080030b 	ldhu	r2,12(r16)
 2004e18:	80000115 	stw	zero,4(r16)
 2004e1c:	0007883a 	mov	r3,zero
 2004e20:	1080008c 	andi	r2,r2,2
 2004e24:	10bfffcc 	andi	r2,r2,65535
 2004e28:	10a0001c 	xori	r2,r2,32768
 2004e2c:	10a00004 	addi	r2,r2,-32768
 2004e30:	0023883a 	mov	r17,zero
 2004e34:	103fd326 	beq	r2,zero,2004d84 <_fread_r+0x78>
 2004e38:	1823883a 	mov	r17,r3
 2004e3c:	b0c0012e 	bgeu	r22,r3,2004e44 <_fread_r+0x138>
 2004e40:	b023883a 	mov	r17,r22
 2004e44:	81400017 	ldw	r5,0(r16)
 2004e48:	9809883a 	mov	r4,r19
 2004e4c:	880d883a 	mov	r6,r17
 2004e50:	200660c0 	call	200660c <memcpy>
 2004e54:	80800117 	ldw	r2,4(r16)
 2004e58:	84800017 	ldw	r18,0(r16)
 2004e5c:	81400c17 	ldw	r5,48(r16)
 2004e60:	1445c83a 	sub	r2,r2,r17
 2004e64:	9465883a 	add	r18,r18,r17
 2004e68:	84800015 	stw	r18,0(r16)
 2004e6c:	80800115 	stw	r2,4(r16)
 2004e70:	9c67883a 	add	r19,r19,r17
 2004e74:	b463c83a 	sub	r17,r22,r17
 2004e78:	28002d26 	beq	r5,zero,2004f30 <_fread_r+0x224>
 2004e7c:	883fd626 	beq	r17,zero,2004dd8 <_fread_r+0xcc>
 2004e80:	80801004 	addi	r2,r16,64
 2004e84:	28800326 	beq	r5,r2,2004e94 <_fread_r+0x188>
 2004e88:	a009883a 	mov	r4,r20
 2004e8c:	20050b40 	call	20050b4 <_free_r>
 2004e90:	84800017 	ldw	r18,0(r16)
 2004e94:	80000c15 	stw	zero,48(r16)
 2004e98:	80c00517 	ldw	r3,20(r16)
 2004e9c:	87000417 	ldw	fp,16(r16)
 2004ea0:	d8c00015 	stw	r3,0(sp)
 2004ea4:	00000106 	br	2004eac <_fread_r+0x1a0>
 2004ea8:	883fcb26 	beq	r17,zero,2004dd8 <_fread_r+0xcc>
 2004eac:	84c00415 	stw	r19,16(r16)
 2004eb0:	84400515 	stw	r17,20(r16)
 2004eb4:	84c00015 	stw	r19,0(r16)
 2004eb8:	a009883a 	mov	r4,r20
 2004ebc:	800b883a 	mov	r5,r16
 2004ec0:	2006ce40 	call	2006ce4 <__srefill_r>
 2004ec4:	d8c00017 	ldw	r3,0(sp)
 2004ec8:	81000117 	ldw	r4,4(r16)
 2004ecc:	87000415 	stw	fp,16(r16)
 2004ed0:	80c00515 	stw	r3,20(r16)
 2004ed4:	84800015 	stw	r18,0(r16)
 2004ed8:	80000115 	stw	zero,4(r16)
 2004edc:	8923c83a 	sub	r17,r17,r4
 2004ee0:	9927883a 	add	r19,r19,r4
 2004ee4:	103ff026 	beq	r2,zero,2004ea8 <_fread_r+0x19c>
 2004ee8:	b449c83a 	sub	r4,r22,r17
 2004eec:	b80b883a 	mov	r5,r23
 2004ef0:	201479c0 	call	201479c <__udivsi3>
 2004ef4:	102b883a 	mov	r21,r2
 2004ef8:	003fb706 	br	2004dd8 <_fread_r+0xcc>
 2004efc:	200492c0 	call	200492c <__sinit>
 2004f00:	84400117 	ldw	r17,4(r16)
 2004f04:	883f980e 	bge	r17,zero,2004d68 <_fread_r+0x5c>
 2004f08:	003fc206 	br	2004e14 <_fread_r+0x108>
 2004f0c:	900d883a 	mov	r6,r18
 2004f10:	200660c0 	call	200660c <memcpy>
 2004f14:	80800117 	ldw	r2,4(r16)
 2004f18:	80c00017 	ldw	r3,0(r16)
 2004f1c:	1485c83a 	sub	r2,r2,r18
 2004f20:	1ca5883a 	add	r18,r3,r18
 2004f24:	80800115 	stw	r2,4(r16)
 2004f28:	84800015 	stw	r18,0(r16)
 2004f2c:	003faa06 	br	2004dd8 <_fread_r+0xcc>
 2004f30:	883fd91e 	bne	r17,zero,2004e98 <_fread_r+0x18c>
 2004f34:	003fa806 	br	2004dd8 <_fread_r+0xcc>

02004f38 <fread>:
 2004f38:	00808174 	movhi	r2,517
 2004f3c:	10903604 	addi	r2,r2,16600
 2004f40:	2011883a 	mov	r8,r4
 2004f44:	11000017 	ldw	r4,0(r2)
 2004f48:	defffe04 	addi	sp,sp,-8
 2004f4c:	2807883a 	mov	r3,r5
 2004f50:	3005883a 	mov	r2,r6
 2004f54:	d9c00015 	stw	r7,0(sp)
 2004f58:	400b883a 	mov	r5,r8
 2004f5c:	180d883a 	mov	r6,r3
 2004f60:	100f883a 	mov	r7,r2
 2004f64:	dfc00115 	stw	ra,4(sp)
 2004f68:	2004d0c0 	call	2004d0c <_fread_r>
 2004f6c:	dfc00117 	ldw	ra,4(sp)
 2004f70:	dec00204 	addi	sp,sp,8
 2004f74:	f800283a 	ret

02004f78 <_malloc_trim_r>:
 2004f78:	defffb04 	addi	sp,sp,-20
 2004f7c:	dcc00315 	stw	r19,12(sp)
 2004f80:	dc800215 	stw	r18,8(sp)
 2004f84:	dc400115 	stw	r17,4(sp)
 2004f88:	dc000015 	stw	r16,0(sp)
 2004f8c:	2827883a 	mov	r19,r5
 2004f90:	dfc00415 	stw	ra,16(sp)
 2004f94:	04408174 	movhi	r17,517
 2004f98:	8c497004 	addi	r17,r17,9664
 2004f9c:	2021883a 	mov	r16,r4
 2004fa0:	2015aec0 	call	2015aec <__malloc_lock>
 2004fa4:	88800217 	ldw	r2,8(r17)
 2004fa8:	14800117 	ldw	r18,4(r2)
 2004fac:	00bfff04 	movi	r2,-4
 2004fb0:	90a4703a 	and	r18,r18,r2
 2004fb4:	9083fbc4 	addi	r2,r18,4079
 2004fb8:	14e7c83a 	sub	r19,r2,r19
 2004fbc:	9826d33a 	srli	r19,r19,12
 2004fc0:	0083ffc4 	movi	r2,4095
 2004fc4:	9cffffc4 	addi	r19,r19,-1
 2004fc8:	9826933a 	slli	r19,r19,12
 2004fcc:	14c0060e 	bge	r2,r19,2004fe8 <_malloc_trim_r+0x70>
 2004fd0:	8009883a 	mov	r4,r16
 2004fd4:	000b883a 	mov	r5,zero
 2004fd8:	2006f300 	call	2006f30 <_sbrk_r>
 2004fdc:	88c00217 	ldw	r3,8(r17)
 2004fe0:	1c87883a 	add	r3,r3,r18
 2004fe4:	10c00a26 	beq	r2,r3,2005010 <_malloc_trim_r+0x98>
 2004fe8:	8009883a 	mov	r4,r16
 2004fec:	2015c000 	call	2015c00 <__malloc_unlock>
 2004ff0:	0005883a 	mov	r2,zero
 2004ff4:	dfc00417 	ldw	ra,16(sp)
 2004ff8:	dcc00317 	ldw	r19,12(sp)
 2004ffc:	dc800217 	ldw	r18,8(sp)
 2005000:	dc400117 	ldw	r17,4(sp)
 2005004:	dc000017 	ldw	r16,0(sp)
 2005008:	dec00504 	addi	sp,sp,20
 200500c:	f800283a 	ret
 2005010:	8009883a 	mov	r4,r16
 2005014:	04cbc83a 	sub	r5,zero,r19
 2005018:	2006f300 	call	2006f30 <_sbrk_r>
 200501c:	00ffffc4 	movi	r3,-1
 2005020:	10c01326 	beq	r2,r3,2005070 <_malloc_trim_r+0xf8>
 2005024:	008081b4 	movhi	r2,518
 2005028:	1083c204 	addi	r2,r2,3848
 200502c:	11000017 	ldw	r4,0(r2)
 2005030:	88c00217 	ldw	r3,8(r17)
 2005034:	94e5c83a 	sub	r18,r18,r19
 2005038:	94800054 	ori	r18,r18,1
 200503c:	24e7c83a 	sub	r19,r4,r19
 2005040:	1c800115 	stw	r18,4(r3)
 2005044:	8009883a 	mov	r4,r16
 2005048:	14c00015 	stw	r19,0(r2)
 200504c:	2015c000 	call	2015c00 <__malloc_unlock>
 2005050:	00800044 	movi	r2,1
 2005054:	dfc00417 	ldw	ra,16(sp)
 2005058:	dcc00317 	ldw	r19,12(sp)
 200505c:	dc800217 	ldw	r18,8(sp)
 2005060:	dc400117 	ldw	r17,4(sp)
 2005064:	dc000017 	ldw	r16,0(sp)
 2005068:	dec00504 	addi	sp,sp,20
 200506c:	f800283a 	ret
 2005070:	8009883a 	mov	r4,r16
 2005074:	000b883a 	mov	r5,zero
 2005078:	2006f300 	call	2006f30 <_sbrk_r>
 200507c:	88c00217 	ldw	r3,8(r17)
 2005080:	014003c4 	movi	r5,15
 2005084:	10c9c83a 	sub	r4,r2,r3
 2005088:	293fd70e 	bge	r5,r4,2004fe8 <_malloc_trim_r+0x70>
 200508c:	01408174 	movhi	r5,517
 2005090:	29503704 	addi	r5,r5,16604
 2005094:	29400017 	ldw	r5,0(r5)
 2005098:	21000054 	ori	r4,r4,1
 200509c:	19000115 	stw	r4,4(r3)
 20050a0:	1145c83a 	sub	r2,r2,r5
 20050a4:	014081b4 	movhi	r5,518
 20050a8:	2943c204 	addi	r5,r5,3848
 20050ac:	28800015 	stw	r2,0(r5)
 20050b0:	003fcd06 	br	2004fe8 <_malloc_trim_r+0x70>

020050b4 <_free_r>:
 20050b4:	defffd04 	addi	sp,sp,-12
 20050b8:	dc400115 	stw	r17,4(sp)
 20050bc:	dc000015 	stw	r16,0(sp)
 20050c0:	dfc00215 	stw	ra,8(sp)
 20050c4:	2821883a 	mov	r16,r5
 20050c8:	2023883a 	mov	r17,r4
 20050cc:	28004b26 	beq	r5,zero,20051fc <_free_r+0x148>
 20050d0:	2015aec0 	call	2015aec <__malloc_lock>
 20050d4:	823fff17 	ldw	r8,-4(r16)
 20050d8:	00bfff84 	movi	r2,-2
 20050dc:	81bffe04 	addi	r6,r16,-8
 20050e0:	4084703a 	and	r2,r8,r2
 20050e4:	3087883a 	add	r3,r6,r2
 20050e8:	01408174 	movhi	r5,517
 20050ec:	29497004 	addi	r5,r5,9664
 20050f0:	1a400117 	ldw	r9,4(r3)
 20050f4:	29000217 	ldw	r4,8(r5)
 20050f8:	01ffff04 	movi	r7,-4
 20050fc:	49ce703a 	and	r7,r9,r7
 2005100:	20c06526 	beq	r4,r3,2005298 <_free_r+0x1e4>
 2005104:	19c00115 	stw	r7,4(r3)
 2005108:	4200004c 	andi	r8,r8,1
 200510c:	40003026 	beq	r8,zero,20051d0 <_free_r+0x11c>
 2005110:	0009883a 	mov	r4,zero
 2005114:	19d1883a 	add	r8,r3,r7
 2005118:	42000117 	ldw	r8,4(r8)
 200511c:	4200004c 	andi	r8,r8,1
 2005120:	4000061e 	bne	r8,zero,200513c <_free_r+0x88>
 2005124:	11c5883a 	add	r2,r2,r7
 2005128:	19c00217 	ldw	r7,8(r3)
 200512c:	20004e26 	beq	r4,zero,2005268 <_free_r+0x1b4>
 2005130:	18c00317 	ldw	r3,12(r3)
 2005134:	38c00315 	stw	r3,12(r7)
 2005138:	19c00215 	stw	r7,8(r3)
 200513c:	11c00054 	ori	r7,r2,1
 2005140:	3087883a 	add	r3,r6,r2
 2005144:	31c00115 	stw	r7,4(r6)
 2005148:	18800015 	stw	r2,0(r3)
 200514c:	20001a1e 	bne	r4,zero,20051b8 <_free_r+0x104>
 2005150:	00c07fc4 	movi	r3,511
 2005154:	18802e2e 	bgeu	r3,r2,2005210 <_free_r+0x15c>
 2005158:	1006d27a 	srli	r3,r2,9
 200515c:	01000104 	movi	r4,4
 2005160:	20c06636 	bltu	r4,r3,20052fc <_free_r+0x248>
 2005164:	1008d1ba 	srli	r4,r2,6
 2005168:	21000e04 	addi	r4,r4,56
 200516c:	210f883a 	add	r7,r4,r4
 2005170:	39cf883a 	add	r7,r7,r7
 2005174:	39cf883a 	add	r7,r7,r7
 2005178:	29cf883a 	add	r7,r5,r7
 200517c:	38c00217 	ldw	r3,8(r7)
 2005180:	01408174 	movhi	r5,517
 2005184:	29497004 	addi	r5,r5,9664
 2005188:	19c06126 	beq	r3,r7,2005310 <_free_r+0x25c>
 200518c:	013fff04 	movi	r4,-4
 2005190:	19400117 	ldw	r5,4(r3)
 2005194:	290a703a 	and	r5,r5,r4
 2005198:	1140022e 	bgeu	r2,r5,20051a4 <_free_r+0xf0>
 200519c:	18c00217 	ldw	r3,8(r3)
 20051a0:	38fffb1e 	bne	r7,r3,2005190 <_free_r+0xdc>
 20051a4:	18800317 	ldw	r2,12(r3)
 20051a8:	30800315 	stw	r2,12(r6)
 20051ac:	30c00215 	stw	r3,8(r6)
 20051b0:	11800215 	stw	r6,8(r2)
 20051b4:	19800315 	stw	r6,12(r3)
 20051b8:	8809883a 	mov	r4,r17
 20051bc:	dfc00217 	ldw	ra,8(sp)
 20051c0:	dc400117 	ldw	r17,4(sp)
 20051c4:	dc000017 	ldw	r16,0(sp)
 20051c8:	dec00304 	addi	sp,sp,12
 20051cc:	2015c001 	jmpi	2015c00 <__malloc_unlock>
 20051d0:	813ffe17 	ldw	r4,-8(r16)
 20051d4:	2a400204 	addi	r9,r5,8
 20051d8:	310dc83a 	sub	r6,r6,r4
 20051dc:	32000217 	ldw	r8,8(r6)
 20051e0:	1105883a 	add	r2,r2,r4
 20051e4:	42404326 	beq	r8,r9,20052f4 <_free_r+0x240>
 20051e8:	32400317 	ldw	r9,12(r6)
 20051ec:	0009883a 	mov	r4,zero
 20051f0:	42400315 	stw	r9,12(r8)
 20051f4:	4a000215 	stw	r8,8(r9)
 20051f8:	003fc606 	br	2005114 <_free_r+0x60>
 20051fc:	dfc00217 	ldw	ra,8(sp)
 2005200:	dc400117 	ldw	r17,4(sp)
 2005204:	dc000017 	ldw	r16,0(sp)
 2005208:	dec00304 	addi	sp,sp,12
 200520c:	f800283a 	ret
 2005210:	1004d0fa 	srli	r2,r2,3
 2005214:	02000044 	movi	r8,1
 2005218:	29c00117 	ldw	r7,4(r5)
 200521c:	1087883a 	add	r3,r2,r2
 2005220:	18c7883a 	add	r3,r3,r3
 2005224:	1005d0ba 	srai	r2,r2,2
 2005228:	18c7883a 	add	r3,r3,r3
 200522c:	28c7883a 	add	r3,r5,r3
 2005230:	19000217 	ldw	r4,8(r3)
 2005234:	4084983a 	sll	r2,r8,r2
 2005238:	30c00315 	stw	r3,12(r6)
 200523c:	31000215 	stw	r4,8(r6)
 2005240:	11c4b03a 	or	r2,r2,r7
 2005244:	21800315 	stw	r6,12(r4)
 2005248:	8809883a 	mov	r4,r17
 200524c:	28800115 	stw	r2,4(r5)
 2005250:	19800215 	stw	r6,8(r3)
 2005254:	dfc00217 	ldw	ra,8(sp)
 2005258:	dc400117 	ldw	r17,4(sp)
 200525c:	dc000017 	ldw	r16,0(sp)
 2005260:	dec00304 	addi	sp,sp,12
 2005264:	2015c001 	jmpi	2015c00 <__malloc_unlock>
 2005268:	02008174 	movhi	r8,517
 200526c:	42097204 	addi	r8,r8,9672
 2005270:	3a3faf1e 	bne	r7,r8,2005130 <_free_r+0x7c>
 2005274:	29800515 	stw	r6,20(r5)
 2005278:	29800415 	stw	r6,16(r5)
 200527c:	11000054 	ori	r4,r2,1
 2005280:	3087883a 	add	r3,r6,r2
 2005284:	31c00315 	stw	r7,12(r6)
 2005288:	31c00215 	stw	r7,8(r6)
 200528c:	31000115 	stw	r4,4(r6)
 2005290:	18800015 	stw	r2,0(r3)
 2005294:	003fc806 	br	20051b8 <_free_r+0x104>
 2005298:	4200004c 	andi	r8,r8,1
 200529c:	3885883a 	add	r2,r7,r2
 20052a0:	4000071e 	bne	r8,zero,20052c0 <_free_r+0x20c>
 20052a4:	81fffe17 	ldw	r7,-8(r16)
 20052a8:	31cdc83a 	sub	r6,r6,r7
 20052ac:	30c00317 	ldw	r3,12(r6)
 20052b0:	31000217 	ldw	r4,8(r6)
 20052b4:	11c5883a 	add	r2,r2,r7
 20052b8:	20c00315 	stw	r3,12(r4)
 20052bc:	19000215 	stw	r4,8(r3)
 20052c0:	00c08174 	movhi	r3,517
 20052c4:	18d03804 	addi	r3,r3,16608
 20052c8:	18c00017 	ldw	r3,0(r3)
 20052cc:	11000054 	ori	r4,r2,1
 20052d0:	31000115 	stw	r4,4(r6)
 20052d4:	29800215 	stw	r6,8(r5)
 20052d8:	10ffb736 	bltu	r2,r3,20051b8 <_free_r+0x104>
 20052dc:	00808174 	movhi	r2,517
 20052e0:	10908e04 	addi	r2,r2,16952
 20052e4:	11400017 	ldw	r5,0(r2)
 20052e8:	8809883a 	mov	r4,r17
 20052ec:	2004f780 	call	2004f78 <_malloc_trim_r>
 20052f0:	003fb106 	br	20051b8 <_free_r+0x104>
 20052f4:	01000044 	movi	r4,1
 20052f8:	003f8606 	br	2005114 <_free_r+0x60>
 20052fc:	01000504 	movi	r4,20
 2005300:	20c00b36 	bltu	r4,r3,2005330 <_free_r+0x27c>
 2005304:	190016c4 	addi	r4,r3,91
 2005308:	210f883a 	add	r7,r4,r4
 200530c:	003f9806 	br	2005170 <_free_r+0xbc>
 2005310:	2009d0ba 	srai	r4,r4,2
 2005314:	00800044 	movi	r2,1
 2005318:	29c00117 	ldw	r7,4(r5)
 200531c:	1108983a 	sll	r4,r2,r4
 2005320:	1805883a 	mov	r2,r3
 2005324:	21c8b03a 	or	r4,r4,r7
 2005328:	29000115 	stw	r4,4(r5)
 200532c:	003f9e06 	br	20051a8 <_free_r+0xf4>
 2005330:	01001504 	movi	r4,84
 2005334:	20c00436 	bltu	r4,r3,2005348 <_free_r+0x294>
 2005338:	1008d33a 	srli	r4,r2,12
 200533c:	21001b84 	addi	r4,r4,110
 2005340:	210f883a 	add	r7,r4,r4
 2005344:	003f8a06 	br	2005170 <_free_r+0xbc>
 2005348:	01005504 	movi	r4,340
 200534c:	20c00436 	bltu	r4,r3,2005360 <_free_r+0x2ac>
 2005350:	1008d3fa 	srli	r4,r2,15
 2005354:	21001dc4 	addi	r4,r4,119
 2005358:	210f883a 	add	r7,r4,r4
 200535c:	003f8406 	br	2005170 <_free_r+0xbc>
 2005360:	01015504 	movi	r4,1364
 2005364:	20c00436 	bltu	r4,r3,2005378 <_free_r+0x2c4>
 2005368:	1008d4ba 	srli	r4,r2,18
 200536c:	21001f04 	addi	r4,r4,124
 2005370:	210f883a 	add	r7,r4,r4
 2005374:	003f7e06 	br	2005170 <_free_r+0xbc>
 2005378:	01c03f04 	movi	r7,252
 200537c:	01001f84 	movi	r4,126
 2005380:	003f7b06 	br	2005170 <_free_r+0xbc>

02005384 <_fseek_r>:
 2005384:	deffe804 	addi	sp,sp,-96
 2005388:	dd001315 	stw	r20,76(sp)
 200538c:	dc801115 	stw	r18,68(sp)
 2005390:	dc401015 	stw	r17,64(sp)
 2005394:	dc000f15 	stw	r16,60(sp)
 2005398:	dfc01715 	stw	ra,92(sp)
 200539c:	ddc01615 	stw	r23,88(sp)
 20053a0:	dd801515 	stw	r22,84(sp)
 20053a4:	dd401415 	stw	r21,80(sp)
 20053a8:	dcc01215 	stw	r19,72(sp)
 20053ac:	2023883a 	mov	r17,r4
 20053b0:	2821883a 	mov	r16,r5
 20053b4:	3029883a 	mov	r20,r6
 20053b8:	3825883a 	mov	r18,r7
 20053bc:	20000226 	beq	r4,zero,20053c8 <_fseek_r+0x44>
 20053c0:	20800e17 	ldw	r2,56(r4)
 20053c4:	10006226 	beq	r2,zero,2005550 <_fseek_r+0x1cc>
 20053c8:	80c0030b 	ldhu	r3,12(r16)
 20053cc:	00804204 	movi	r2,264
 20053d0:	18c0420c 	andi	r3,r3,264
 20053d4:	18806326 	beq	r3,r2,2005564 <_fseek_r+0x1e0>
 20053d8:	84c00a17 	ldw	r19,40(r16)
 20053dc:	98010226 	beq	r19,zero,20057e8 <_fseek_r+0x464>
 20053e0:	00800044 	movi	r2,1
 20053e4:	90803d26 	beq	r18,r2,20054dc <_fseek_r+0x158>
 20053e8:	00800084 	movi	r2,2
 20053ec:	90800126 	beq	r18,r2,20053f4 <_fseek_r+0x70>
 20053f0:	90002c1e 	bne	r18,zero,20054a4 <_fseek_r+0x120>
 20053f4:	80800417 	ldw	r2,16(r16)
 20053f8:	002d883a 	mov	r22,zero
 20053fc:	002b883a 	mov	r21,zero
 2005400:	1000e526 	beq	r2,zero,2005798 <_fseek_r+0x414>
 2005404:	80c0030b 	ldhu	r3,12(r16)
 2005408:	1882068c 	andi	r2,r3,2074
 200540c:	1809883a 	mov	r4,r3
 2005410:	10000a1e 	bne	r2,zero,200543c <_fseek_r+0xb8>
 2005414:	1881000c 	andi	r2,r3,1024
 2005418:	10bfffcc 	andi	r2,r2,65535
 200541c:	10a0001c 	xori	r2,r2,32768
 2005420:	10a00004 	addi	r2,r2,-32768
 2005424:	1000631e 	bne	r2,zero,20055b4 <_fseek_r+0x230>
 2005428:	00808034 	movhi	r2,512
 200542c:	109c8c04 	addi	r2,r2,29232
 2005430:	98805026 	beq	r19,r2,2005574 <_fseek_r+0x1f0>
 2005434:	18c20014 	ori	r3,r3,2048
 2005438:	80c0030d 	sth	r3,12(r16)
 200543c:	8809883a 	mov	r4,r17
 2005440:	800b883a 	mov	r5,r16
 2005444:	200463c0 	call	200463c <_fflush_r>
 2005448:	1000181e 	bne	r2,zero,20054ac <_fseek_r+0x128>
 200544c:	81400717 	ldw	r5,28(r16)
 2005450:	8809883a 	mov	r4,r17
 2005454:	a00d883a 	mov	r6,r20
 2005458:	900f883a 	mov	r7,r18
 200545c:	983ee83a 	callr	r19
 2005460:	00ffffc4 	movi	r3,-1
 2005464:	10c01126 	beq	r2,r3,20054ac <_fseek_r+0x128>
 2005468:	81400c17 	ldw	r5,48(r16)
 200546c:	28000526 	beq	r5,zero,2005484 <_fseek_r+0x100>
 2005470:	80801004 	addi	r2,r16,64
 2005474:	28800226 	beq	r5,r2,2005480 <_fseek_r+0xfc>
 2005478:	8809883a 	mov	r4,r17
 200547c:	20050b40 	call	20050b4 <_free_r>
 2005480:	80000c15 	stw	zero,48(r16)
 2005484:	8080030b 	ldhu	r2,12(r16)
 2005488:	80c00417 	ldw	r3,16(r16)
 200548c:	80000115 	stw	zero,4(r16)
 2005490:	10bdf7cc 	andi	r2,r2,63455
 2005494:	8080030d 	sth	r2,12(r16)
 2005498:	80c00015 	stw	r3,0(r16)
 200549c:	0005883a 	mov	r2,zero
 20054a0:	00000306 	br	20054b0 <_fseek_r+0x12c>
 20054a4:	00800584 	movi	r2,22
 20054a8:	88800015 	stw	r2,0(r17)
 20054ac:	00bfffc4 	movi	r2,-1
 20054b0:	dfc01717 	ldw	ra,92(sp)
 20054b4:	ddc01617 	ldw	r23,88(sp)
 20054b8:	dd801517 	ldw	r22,84(sp)
 20054bc:	dd401417 	ldw	r21,80(sp)
 20054c0:	dd001317 	ldw	r20,76(sp)
 20054c4:	dcc01217 	ldw	r19,72(sp)
 20054c8:	dc801117 	ldw	r18,68(sp)
 20054cc:	dc401017 	ldw	r17,64(sp)
 20054d0:	dc000f17 	ldw	r16,60(sp)
 20054d4:	dec01804 	addi	sp,sp,96
 20054d8:	f800283a 	ret
 20054dc:	8809883a 	mov	r4,r17
 20054e0:	800b883a 	mov	r5,r16
 20054e4:	200463c0 	call	200463c <_fflush_r>
 20054e8:	8080030b 	ldhu	r2,12(r16)
 20054ec:	10c4000c 	andi	r3,r2,4096
 20054f0:	18ffffcc 	andi	r3,r3,65535
 20054f4:	18e0001c 	xori	r3,r3,32768
 20054f8:	18e00004 	addi	r3,r3,-32768
 20054fc:	18007d26 	beq	r3,zero,20056f4 <_fseek_r+0x370>
 2005500:	85401417 	ldw	r21,80(r16)
 2005504:	10c0010c 	andi	r3,r2,4
 2005508:	18ffffcc 	andi	r3,r3,65535
 200550c:	18e0001c 	xori	r3,r3,32768
 2005510:	18e00004 	addi	r3,r3,-32768
 2005514:	18005f1e 	bne	r3,zero,2005694 <_fseek_r+0x310>
 2005518:	1080020c 	andi	r2,r2,8
 200551c:	10bfffcc 	andi	r2,r2,65535
 2005520:	10a0001c 	xori	r2,r2,32768
 2005524:	10a00004 	addi	r2,r2,-32768
 2005528:	10007026 	beq	r2,zero,20056ec <_fseek_r+0x368>
 200552c:	80c00017 	ldw	r3,0(r16)
 2005530:	80800417 	ldw	r2,16(r16)
 2005534:	18000226 	beq	r3,zero,2005540 <_fseek_r+0x1bc>
 2005538:	1887c83a 	sub	r3,r3,r2
 200553c:	a8eb883a 	add	r21,r21,r3
 2005540:	a569883a 	add	r20,r20,r21
 2005544:	05800044 	movi	r22,1
 2005548:	0025883a 	mov	r18,zero
 200554c:	003fac06 	br	2005400 <_fseek_r+0x7c>
 2005550:	200492c0 	call	200492c <__sinit>
 2005554:	80c0030b 	ldhu	r3,12(r16)
 2005558:	00804204 	movi	r2,264
 200555c:	18c0420c 	andi	r3,r3,264
 2005560:	18bf9d1e 	bne	r3,r2,20053d8 <_fseek_r+0x54>
 2005564:	8809883a 	mov	r4,r17
 2005568:	800b883a 	mov	r5,r16
 200556c:	200463c0 	call	200463c <_fflush_r>
 2005570:	003f9906 	br	20053d8 <_fseek_r+0x54>
 2005574:	8140038f 	ldh	r5,14(r16)
 2005578:	283fae16 	blt	r5,zero,2005434 <_fseek_r+0xb0>
 200557c:	8809883a 	mov	r4,r17
 2005580:	d80d883a 	mov	r6,sp
 2005584:	200581c0 	call	200581c <_fstat_r>
 2005588:	1000741e 	bne	r2,zero,200575c <_fseek_r+0x3d8>
 200558c:	d8c00117 	ldw	r3,4(sp)
 2005590:	00a00014 	movui	r2,32768
 2005594:	18fc000c 	andi	r3,r3,61440
 2005598:	1880701e 	bne	r3,r2,200575c <_fseek_r+0x3d8>
 200559c:	8100030b 	ldhu	r4,12(r16)
 20055a0:	00810004 	movi	r2,1024
 20055a4:	80801315 	stw	r2,76(r16)
 20055a8:	2084b03a 	or	r2,r4,r2
 20055ac:	1009883a 	mov	r4,r2
 20055b0:	8080030d 	sth	r2,12(r16)
 20055b4:	90003f1e 	bne	r18,zero,20056b4 <_fseek_r+0x330>
 20055b8:	a02f883a 	mov	r23,r20
 20055bc:	b000461e 	bne	r22,zero,20056d8 <_fseek_r+0x354>
 20055c0:	2084000c 	andi	r2,r4,4096
 20055c4:	10bfffcc 	andi	r2,r2,65535
 20055c8:	10a0001c 	xori	r2,r2,32768
 20055cc:	10a00004 	addi	r2,r2,-32768
 20055d0:	10007526 	beq	r2,zero,20057a8 <_fseek_r+0x424>
 20055d4:	80801417 	ldw	r2,80(r16)
 20055d8:	80c00117 	ldw	r3,4(r16)
 20055dc:	81400c17 	ldw	r5,48(r16)
 20055e0:	10ebc83a 	sub	r21,r2,r3
 20055e4:	28007926 	beq	r5,zero,20057cc <_fseek_r+0x448>
 20055e8:	81c00f17 	ldw	r7,60(r16)
 20055ec:	a9ebc83a 	sub	r21,r21,r7
 20055f0:	80800e17 	ldw	r2,56(r16)
 20055f4:	81800417 	ldw	r6,16(r16)
 20055f8:	a8eb883a 	add	r21,r21,r3
 20055fc:	1185c83a 	sub	r2,r2,r6
 2005600:	a8abc83a 	sub	r21,r21,r2
 2005604:	3885883a 	add	r2,r7,r2
 2005608:	2208000c 	andi	r8,r4,8192
 200560c:	423fffcc 	andi	r8,r8,65535
 2005610:	4220001c 	xori	r8,r8,32768
 2005614:	42200004 	addi	r8,r8,-32768
 2005618:	4000031e 	bne	r8,zero,2005628 <_fseek_r+0x2a4>
 200561c:	bd400216 	blt	r23,r21,2005628 <_fseek_r+0x2a4>
 2005620:	a887883a 	add	r3,r21,r2
 2005624:	b8c03d36 	bltu	r23,r3,200571c <_fseek_r+0x398>
 2005628:	85401317 	ldw	r21,76(r16)
 200562c:	81400717 	ldw	r5,28(r16)
 2005630:	8809883a 	mov	r4,r17
 2005634:	056bc83a 	sub	r21,zero,r21
 2005638:	bd6a703a 	and	r21,r23,r21
 200563c:	a80d883a 	mov	r6,r21
 2005640:	000f883a 	mov	r7,zero
 2005644:	983ee83a 	callr	r19
 2005648:	00ffffc4 	movi	r3,-1
 200564c:	10ff7b26 	beq	r2,r3,200543c <_fseek_r+0xb8>
 2005650:	80800417 	ldw	r2,16(r16)
 2005654:	81400c17 	ldw	r5,48(r16)
 2005658:	80000115 	stw	zero,4(r16)
 200565c:	80800015 	stw	r2,0(r16)
 2005660:	28000526 	beq	r5,zero,2005678 <_fseek_r+0x2f4>
 2005664:	80801004 	addi	r2,r16,64
 2005668:	28800226 	beq	r5,r2,2005674 <_fseek_r+0x2f0>
 200566c:	8809883a 	mov	r4,r17
 2005670:	20050b40 	call	20050b4 <_free_r>
 2005674:	80000c15 	stw	zero,48(r16)
 2005678:	8080030b 	ldhu	r2,12(r16)
 200567c:	bd6fc83a 	sub	r23,r23,r21
 2005680:	10bff7cc 	andi	r2,r2,65503
 2005684:	8080030d 	sth	r2,12(r16)
 2005688:	b800361e 	bne	r23,zero,2005764 <_fseek_r+0x3e0>
 200568c:	0005883a 	mov	r2,zero
 2005690:	003f8706 	br	20054b0 <_fseek_r+0x12c>
 2005694:	80c00117 	ldw	r3,4(r16)
 2005698:	80800c17 	ldw	r2,48(r16)
 200569c:	a8ebc83a 	sub	r21,r21,r3
 20056a0:	10001226 	beq	r2,zero,20056ec <_fseek_r+0x368>
 20056a4:	80c00f17 	ldw	r3,60(r16)
 20056a8:	80800417 	ldw	r2,16(r16)
 20056ac:	a8ebc83a 	sub	r21,r21,r3
 20056b0:	003fa306 	br	2005540 <_fseek_r+0x1bc>
 20056b4:	8140038f 	ldh	r5,14(r16)
 20056b8:	8809883a 	mov	r4,r17
 20056bc:	d80d883a 	mov	r6,sp
 20056c0:	200581c0 	call	200581c <_fstat_r>
 20056c4:	103f5d1e 	bne	r2,zero,200543c <_fseek_r+0xb8>
 20056c8:	ddc00417 	ldw	r23,16(sp)
 20056cc:	8100030b 	ldhu	r4,12(r16)
 20056d0:	a5ef883a 	add	r23,r20,r23
 20056d4:	b03fba26 	beq	r22,zero,20055c0 <_fseek_r+0x23c>
 20056d8:	81400c17 	ldw	r5,48(r16)
 20056dc:	80c00117 	ldw	r3,4(r16)
 20056e0:	28003a26 	beq	r5,zero,20057cc <_fseek_r+0x448>
 20056e4:	81c00f17 	ldw	r7,60(r16)
 20056e8:	003fc106 	br	20055f0 <_fseek_r+0x26c>
 20056ec:	80800417 	ldw	r2,16(r16)
 20056f0:	003f9306 	br	2005540 <_fseek_r+0x1bc>
 20056f4:	81400717 	ldw	r5,28(r16)
 20056f8:	8809883a 	mov	r4,r17
 20056fc:	000d883a 	mov	r6,zero
 2005700:	900f883a 	mov	r7,r18
 2005704:	983ee83a 	callr	r19
 2005708:	102b883a 	mov	r21,r2
 200570c:	00bfffc4 	movi	r2,-1
 2005710:	a8bf6626 	beq	r21,r2,20054ac <_fseek_r+0x128>
 2005714:	8080030b 	ldhu	r2,12(r16)
 2005718:	003f7a06 	br	2005504 <_fseek_r+0x180>
 200571c:	bd6bc83a 	sub	r21,r23,r21
 2005720:	354d883a 	add	r6,r6,r21
 2005724:	1545c83a 	sub	r2,r2,r21
 2005728:	81800015 	stw	r6,0(r16)
 200572c:	80800115 	stw	r2,4(r16)
 2005730:	28000626 	beq	r5,zero,200574c <_fseek_r+0x3c8>
 2005734:	80801004 	addi	r2,r16,64
 2005738:	28800326 	beq	r5,r2,2005748 <_fseek_r+0x3c4>
 200573c:	8809883a 	mov	r4,r17
 2005740:	20050b40 	call	20050b4 <_free_r>
 2005744:	8100030b 	ldhu	r4,12(r16)
 2005748:	80000c15 	stw	zero,48(r16)
 200574c:	213ff7cc 	andi	r4,r4,65503
 2005750:	8100030d 	sth	r4,12(r16)
 2005754:	0005883a 	mov	r2,zero
 2005758:	003f5506 	br	20054b0 <_fseek_r+0x12c>
 200575c:	80c0030b 	ldhu	r3,12(r16)
 2005760:	003f3406 	br	2005434 <_fseek_r+0xb0>
 2005764:	8809883a 	mov	r4,r17
 2005768:	800b883a 	mov	r5,r16
 200576c:	2006ce40 	call	2006ce4 <__srefill_r>
 2005770:	103f321e 	bne	r2,zero,200543c <_fseek_r+0xb8>
 2005774:	80800117 	ldw	r2,4(r16)
 2005778:	15ff3036 	bltu	r2,r23,200543c <_fseek_r+0xb8>
 200577c:	80c00017 	ldw	r3,0(r16)
 2005780:	15c5c83a 	sub	r2,r2,r23
 2005784:	80800115 	stw	r2,4(r16)
 2005788:	1def883a 	add	r23,r3,r23
 200578c:	85c00015 	stw	r23,0(r16)
 2005790:	0005883a 	mov	r2,zero
 2005794:	003f4606 	br	20054b0 <_fseek_r+0x12c>
 2005798:	8809883a 	mov	r4,r17
 200579c:	800b883a 	mov	r5,r16
 20057a0:	2005ce00 	call	2005ce0 <__smakebuf_r>
 20057a4:	003f1706 	br	2005404 <_fseek_r+0x80>
 20057a8:	81400717 	ldw	r5,28(r16)
 20057ac:	8809883a 	mov	r4,r17
 20057b0:	000d883a 	mov	r6,zero
 20057b4:	01c00044 	movi	r7,1
 20057b8:	983ee83a 	callr	r19
 20057bc:	00ffffc4 	movi	r3,-1
 20057c0:	10ff1e26 	beq	r2,r3,200543c <_fseek_r+0xb8>
 20057c4:	8100030b 	ldhu	r4,12(r16)
 20057c8:	003f8306 	br	20055d8 <_fseek_r+0x254>
 20057cc:	80800017 	ldw	r2,0(r16)
 20057d0:	81800417 	ldw	r6,16(r16)
 20057d4:	000b883a 	mov	r5,zero
 20057d8:	1185c83a 	sub	r2,r2,r6
 20057dc:	a8abc83a 	sub	r21,r21,r2
 20057e0:	1885883a 	add	r2,r3,r2
 20057e4:	003f8806 	br	2005608 <_fseek_r+0x284>
 20057e8:	00800744 	movi	r2,29
 20057ec:	88800015 	stw	r2,0(r17)
 20057f0:	00bfffc4 	movi	r2,-1
 20057f4:	003f2e06 	br	20054b0 <_fseek_r+0x12c>

020057f8 <fseek>:
 20057f8:	00808174 	movhi	r2,517
 20057fc:	10903604 	addi	r2,r2,16600
 2005800:	2007883a 	mov	r3,r4
 2005804:	11000017 	ldw	r4,0(r2)
 2005808:	2805883a 	mov	r2,r5
 200580c:	300f883a 	mov	r7,r6
 2005810:	180b883a 	mov	r5,r3
 2005814:	100d883a 	mov	r6,r2
 2005818:	20053841 	jmpi	2005384 <_fseek_r>

0200581c <_fstat_r>:
 200581c:	defffd04 	addi	sp,sp,-12
 2005820:	dc400115 	stw	r17,4(sp)
 2005824:	dc000015 	stw	r16,0(sp)
 2005828:	2023883a 	mov	r17,r4
 200582c:	04008174 	movhi	r16,517
 2005830:	84108b04 	addi	r16,r16,16940
 2005834:	2809883a 	mov	r4,r5
 2005838:	300b883a 	mov	r5,r6
 200583c:	dfc00215 	stw	ra,8(sp)
 2005840:	80000015 	stw	zero,0(r16)
 2005844:	20151300 	call	2015130 <fstat>
 2005848:	00ffffc4 	movi	r3,-1
 200584c:	10c00526 	beq	r2,r3,2005864 <_fstat_r+0x48>
 2005850:	dfc00217 	ldw	ra,8(sp)
 2005854:	dc400117 	ldw	r17,4(sp)
 2005858:	dc000017 	ldw	r16,0(sp)
 200585c:	dec00304 	addi	sp,sp,12
 2005860:	f800283a 	ret
 2005864:	80c00017 	ldw	r3,0(r16)
 2005868:	183ff926 	beq	r3,zero,2005850 <_fstat_r+0x34>
 200586c:	88c00015 	stw	r3,0(r17)
 2005870:	dfc00217 	ldw	ra,8(sp)
 2005874:	dc400117 	ldw	r17,4(sp)
 2005878:	dc000017 	ldw	r16,0(sp)
 200587c:	dec00304 	addi	sp,sp,12
 2005880:	f800283a 	ret

02005884 <_ftell_r>:
 2005884:	defffd04 	addi	sp,sp,-12
 2005888:	dc400115 	stw	r17,4(sp)
 200588c:	dc000015 	stw	r16,0(sp)
 2005890:	dfc00215 	stw	ra,8(sp)
 2005894:	2023883a 	mov	r17,r4
 2005898:	2821883a 	mov	r16,r5
 200589c:	20000226 	beq	r4,zero,20058a8 <_ftell_r+0x24>
 20058a0:	20800e17 	ldw	r2,56(r4)
 20058a4:	10003526 	beq	r2,zero,200597c <_ftell_r+0xf8>
 20058a8:	80800a17 	ldw	r2,40(r16)
 20058ac:	10003526 	beq	r2,zero,2005984 <_ftell_r+0x100>
 20058b0:	8809883a 	mov	r4,r17
 20058b4:	800b883a 	mov	r5,r16
 20058b8:	200463c0 	call	200463c <_fflush_r>
 20058bc:	80c0030b 	ldhu	r3,12(r16)
 20058c0:	1884000c 	andi	r2,r3,4096
 20058c4:	10bfffcc 	andi	r2,r2,65535
 20058c8:	10a0001c 	xori	r2,r2,32768
 20058cc:	10a00004 	addi	r2,r2,-32768
 20058d0:	10002026 	beq	r2,zero,2005954 <_ftell_r+0xd0>
 20058d4:	80801417 	ldw	r2,80(r16)
 20058d8:	1900010c 	andi	r4,r3,4
 20058dc:	213fffcc 	andi	r4,r4,65535
 20058e0:	2120001c 	xori	r4,r4,32768
 20058e4:	21200004 	addi	r4,r4,-32768
 20058e8:	20000b26 	beq	r4,zero,2005918 <_ftell_r+0x94>
 20058ec:	81000117 	ldw	r4,4(r16)
 20058f0:	80c00c17 	ldw	r3,48(r16)
 20058f4:	1105c83a 	sub	r2,r2,r4
 20058f8:	18000226 	beq	r3,zero,2005904 <_ftell_r+0x80>
 20058fc:	80c00f17 	ldw	r3,60(r16)
 2005900:	10c5c83a 	sub	r2,r2,r3
 2005904:	dfc00217 	ldw	ra,8(sp)
 2005908:	dc400117 	ldw	r17,4(sp)
 200590c:	dc000017 	ldw	r16,0(sp)
 2005910:	dec00304 	addi	sp,sp,12
 2005914:	f800283a 	ret
 2005918:	18c0020c 	andi	r3,r3,8
 200591c:	18ffffcc 	andi	r3,r3,65535
 2005920:	18e0001c 	xori	r3,r3,32768
 2005924:	18e00004 	addi	r3,r3,-32768
 2005928:	183ff626 	beq	r3,zero,2005904 <_ftell_r+0x80>
 200592c:	80c00017 	ldw	r3,0(r16)
 2005930:	183ff426 	beq	r3,zero,2005904 <_ftell_r+0x80>
 2005934:	81000417 	ldw	r4,16(r16)
 2005938:	1907c83a 	sub	r3,r3,r4
 200593c:	10c5883a 	add	r2,r2,r3
 2005940:	dfc00217 	ldw	ra,8(sp)
 2005944:	dc400117 	ldw	r17,4(sp)
 2005948:	dc000017 	ldw	r16,0(sp)
 200594c:	dec00304 	addi	sp,sp,12
 2005950:	f800283a 	ret
 2005954:	80800a17 	ldw	r2,40(r16)
 2005958:	81400717 	ldw	r5,28(r16)
 200595c:	8809883a 	mov	r4,r17
 2005960:	000d883a 	mov	r6,zero
 2005964:	01c00044 	movi	r7,1
 2005968:	103ee83a 	callr	r2
 200596c:	00ffffc4 	movi	r3,-1
 2005970:	10ffe426 	beq	r2,r3,2005904 <_ftell_r+0x80>
 2005974:	80c0030b 	ldhu	r3,12(r16)
 2005978:	003fd706 	br	20058d8 <_ftell_r+0x54>
 200597c:	200492c0 	call	200492c <__sinit>
 2005980:	003fc906 	br	20058a8 <_ftell_r+0x24>
 2005984:	00800744 	movi	r2,29
 2005988:	88800015 	stw	r2,0(r17)
 200598c:	00bfffc4 	movi	r2,-1
 2005990:	003fdc06 	br	2005904 <_ftell_r+0x80>

02005994 <ftell>:
 2005994:	00808174 	movhi	r2,517
 2005998:	10903604 	addi	r2,r2,16600
 200599c:	200b883a 	mov	r5,r4
 20059a0:	11000017 	ldw	r4,0(r2)
 20059a4:	20058841 	jmpi	2005884 <_ftell_r>

020059a8 <_fwalk>:
 20059a8:	defff904 	addi	sp,sp,-28
 20059ac:	dcc00315 	stw	r19,12(sp)
 20059b0:	24c0b804 	addi	r19,r4,736
 20059b4:	dd400515 	stw	r21,20(sp)
 20059b8:	dd000415 	stw	r20,16(sp)
 20059bc:	dfc00615 	stw	ra,24(sp)
 20059c0:	dc800215 	stw	r18,8(sp)
 20059c4:	dc400115 	stw	r17,4(sp)
 20059c8:	dc000015 	stw	r16,0(sp)
 20059cc:	282b883a 	mov	r21,r5
 20059d0:	0029883a 	mov	r20,zero
 20059d4:	2004b340 	call	2004b34 <__sfp_lock_acquire>
 20059d8:	98001226 	beq	r19,zero,2005a24 <_fwalk+0x7c>
 20059dc:	04bfffc4 	movi	r18,-1
 20059e0:	9c400117 	ldw	r17,4(r19)
 20059e4:	9c000217 	ldw	r16,8(r19)
 20059e8:	8c7fffc4 	addi	r17,r17,-1
 20059ec:	88000b16 	blt	r17,zero,2005a1c <_fwalk+0x74>
 20059f0:	84000304 	addi	r16,r16,12
 20059f4:	80c0000f 	ldh	r3,0(r16)
 20059f8:	8c7fffc4 	addi	r17,r17,-1
 20059fc:	813ffd04 	addi	r4,r16,-12
 2005a00:	18000426 	beq	r3,zero,2005a14 <_fwalk+0x6c>
 2005a04:	80c0008f 	ldh	r3,2(r16)
 2005a08:	1c800226 	beq	r3,r18,2005a14 <_fwalk+0x6c>
 2005a0c:	a83ee83a 	callr	r21
 2005a10:	a0a8b03a 	or	r20,r20,r2
 2005a14:	84001704 	addi	r16,r16,92
 2005a18:	8cbff61e 	bne	r17,r18,20059f4 <_fwalk+0x4c>
 2005a1c:	9cc00017 	ldw	r19,0(r19)
 2005a20:	983fef1e 	bne	r19,zero,20059e0 <_fwalk+0x38>
 2005a24:	2004b380 	call	2004b38 <__sfp_lock_release>
 2005a28:	a005883a 	mov	r2,r20
 2005a2c:	dfc00617 	ldw	ra,24(sp)
 2005a30:	dd400517 	ldw	r21,20(sp)
 2005a34:	dd000417 	ldw	r20,16(sp)
 2005a38:	dcc00317 	ldw	r19,12(sp)
 2005a3c:	dc800217 	ldw	r18,8(sp)
 2005a40:	dc400117 	ldw	r17,4(sp)
 2005a44:	dc000017 	ldw	r16,0(sp)
 2005a48:	dec00704 	addi	sp,sp,28
 2005a4c:	f800283a 	ret

02005a50 <_fwalk_reent>:
 2005a50:	defff804 	addi	sp,sp,-32
 2005a54:	dcc00315 	stw	r19,12(sp)
 2005a58:	24c0b804 	addi	r19,r4,736
 2005a5c:	dd800615 	stw	r22,24(sp)
 2005a60:	dd400515 	stw	r21,20(sp)
 2005a64:	dd000415 	stw	r20,16(sp)
 2005a68:	dfc00715 	stw	ra,28(sp)
 2005a6c:	dc800215 	stw	r18,8(sp)
 2005a70:	dc400115 	stw	r17,4(sp)
 2005a74:	dc000015 	stw	r16,0(sp)
 2005a78:	2029883a 	mov	r20,r4
 2005a7c:	282b883a 	mov	r21,r5
 2005a80:	002d883a 	mov	r22,zero
 2005a84:	2004b340 	call	2004b34 <__sfp_lock_acquire>
 2005a88:	98001326 	beq	r19,zero,2005ad8 <_fwalk_reent+0x88>
 2005a8c:	04bfffc4 	movi	r18,-1
 2005a90:	9c400117 	ldw	r17,4(r19)
 2005a94:	9c000217 	ldw	r16,8(r19)
 2005a98:	8c7fffc4 	addi	r17,r17,-1
 2005a9c:	88000c16 	blt	r17,zero,2005ad0 <_fwalk_reent+0x80>
 2005aa0:	84000304 	addi	r16,r16,12
 2005aa4:	80c0000f 	ldh	r3,0(r16)
 2005aa8:	8c7fffc4 	addi	r17,r17,-1
 2005aac:	817ffd04 	addi	r5,r16,-12
 2005ab0:	18000526 	beq	r3,zero,2005ac8 <_fwalk_reent+0x78>
 2005ab4:	80c0008f 	ldh	r3,2(r16)
 2005ab8:	a009883a 	mov	r4,r20
 2005abc:	1c800226 	beq	r3,r18,2005ac8 <_fwalk_reent+0x78>
 2005ac0:	a83ee83a 	callr	r21
 2005ac4:	b0acb03a 	or	r22,r22,r2
 2005ac8:	84001704 	addi	r16,r16,92
 2005acc:	8cbff51e 	bne	r17,r18,2005aa4 <_fwalk_reent+0x54>
 2005ad0:	9cc00017 	ldw	r19,0(r19)
 2005ad4:	983fee1e 	bne	r19,zero,2005a90 <_fwalk_reent+0x40>
 2005ad8:	2004b380 	call	2004b38 <__sfp_lock_release>
 2005adc:	b005883a 	mov	r2,r22
 2005ae0:	dfc00717 	ldw	ra,28(sp)
 2005ae4:	dd800617 	ldw	r22,24(sp)
 2005ae8:	dd400517 	ldw	r21,20(sp)
 2005aec:	dd000417 	ldw	r20,16(sp)
 2005af0:	dcc00317 	ldw	r19,12(sp)
 2005af4:	dc800217 	ldw	r18,8(sp)
 2005af8:	dc400117 	ldw	r17,4(sp)
 2005afc:	dc000017 	ldw	r16,0(sp)
 2005b00:	dec00804 	addi	sp,sp,32
 2005b04:	f800283a 	ret

02005b08 <_fwrite_r>:
 2005b08:	defff604 	addi	sp,sp,-40
 2005b0c:	dc800715 	stw	r18,28(sp)
 2005b10:	39a5383a 	mul	r18,r7,r6
 2005b14:	d8800304 	addi	r2,sp,12
 2005b18:	d8800015 	stw	r2,0(sp)
 2005b1c:	00800044 	movi	r2,1
 2005b20:	dcc00815 	stw	r19,32(sp)
 2005b24:	dc400615 	stw	r17,24(sp)
 2005b28:	dc000515 	stw	r16,20(sp)
 2005b2c:	dfc00915 	stw	ra,36(sp)
 2005b30:	d9400315 	stw	r5,12(sp)
 2005b34:	dc800415 	stw	r18,16(sp)
 2005b38:	dc800215 	stw	r18,8(sp)
 2005b3c:	d8800115 	stw	r2,4(sp)
 2005b40:	3027883a 	mov	r19,r6
 2005b44:	3823883a 	mov	r17,r7
 2005b48:	2021883a 	mov	r16,r4
 2005b4c:	20000226 	beq	r4,zero,2005b58 <_fwrite_r+0x50>
 2005b50:	20800e17 	ldw	r2,56(r4)
 2005b54:	10001226 	beq	r2,zero,2005ba0 <_fwrite_r+0x98>
 2005b58:	d9400a17 	ldw	r5,40(sp)
 2005b5c:	8009883a 	mov	r4,r16
 2005b60:	d80d883a 	mov	r6,sp
 2005b64:	200dd100 	call	200dd10 <__sfvwrite_r>
 2005b68:	10000526 	beq	r2,zero,2005b80 <_fwrite_r+0x78>
 2005b6c:	d9000217 	ldw	r4,8(sp)
 2005b70:	980b883a 	mov	r5,r19
 2005b74:	9109c83a 	sub	r4,r18,r4
 2005b78:	201479c0 	call	201479c <__udivsi3>
 2005b7c:	1023883a 	mov	r17,r2
 2005b80:	8805883a 	mov	r2,r17
 2005b84:	dfc00917 	ldw	ra,36(sp)
 2005b88:	dcc00817 	ldw	r19,32(sp)
 2005b8c:	dc800717 	ldw	r18,28(sp)
 2005b90:	dc400617 	ldw	r17,24(sp)
 2005b94:	dc000517 	ldw	r16,20(sp)
 2005b98:	dec00a04 	addi	sp,sp,40
 2005b9c:	f800283a 	ret
 2005ba0:	200492c0 	call	200492c <__sinit>
 2005ba4:	003fec06 	br	2005b58 <_fwrite_r+0x50>

02005ba8 <fwrite>:
 2005ba8:	00808174 	movhi	r2,517
 2005bac:	10903604 	addi	r2,r2,16600
 2005bb0:	2011883a 	mov	r8,r4
 2005bb4:	11000017 	ldw	r4,0(r2)
 2005bb8:	defffe04 	addi	sp,sp,-8
 2005bbc:	2807883a 	mov	r3,r5
 2005bc0:	3005883a 	mov	r2,r6
 2005bc4:	d9c00015 	stw	r7,0(sp)
 2005bc8:	400b883a 	mov	r5,r8
 2005bcc:	180d883a 	mov	r6,r3
 2005bd0:	100f883a 	mov	r7,r2
 2005bd4:	dfc00115 	stw	ra,4(sp)
 2005bd8:	2005b080 	call	2005b08 <_fwrite_r>
 2005bdc:	dfc00117 	ldw	ra,4(sp)
 2005be0:	dec00204 	addi	sp,sp,8
 2005be4:	f800283a 	ret

02005be8 <_getc_r>:
 2005be8:	defffd04 	addi	sp,sp,-12
 2005bec:	dc000115 	stw	r16,4(sp)
 2005bf0:	dfc00215 	stw	ra,8(sp)
 2005bf4:	2021883a 	mov	r16,r4
 2005bf8:	20000226 	beq	r4,zero,2005c04 <_getc_r+0x1c>
 2005bfc:	20800e17 	ldw	r2,56(r4)
 2005c00:	10000c26 	beq	r2,zero,2005c34 <_getc_r+0x4c>
 2005c04:	28800117 	ldw	r2,4(r5)
 2005c08:	10bfffc4 	addi	r2,r2,-1
 2005c0c:	28800115 	stw	r2,4(r5)
 2005c10:	10000c16 	blt	r2,zero,2005c44 <_getc_r+0x5c>
 2005c14:	28c00017 	ldw	r3,0(r5)
 2005c18:	18800003 	ldbu	r2,0(r3)
 2005c1c:	18c00044 	addi	r3,r3,1
 2005c20:	28c00015 	stw	r3,0(r5)
 2005c24:	dfc00217 	ldw	ra,8(sp)
 2005c28:	dc000117 	ldw	r16,4(sp)
 2005c2c:	dec00304 	addi	sp,sp,12
 2005c30:	f800283a 	ret
 2005c34:	d9400015 	stw	r5,0(sp)
 2005c38:	200492c0 	call	200492c <__sinit>
 2005c3c:	d9400017 	ldw	r5,0(sp)
 2005c40:	003ff006 	br	2005c04 <_getc_r+0x1c>
 2005c44:	8009883a 	mov	r4,r16
 2005c48:	dfc00217 	ldw	ra,8(sp)
 2005c4c:	dc000117 	ldw	r16,4(sp)
 2005c50:	dec00304 	addi	sp,sp,12
 2005c54:	2006ed01 	jmpi	2006ed0 <__srget_r>

02005c58 <getc>:
 2005c58:	defffd04 	addi	sp,sp,-12
 2005c5c:	dc400115 	stw	r17,4(sp)
 2005c60:	04408174 	movhi	r17,517
 2005c64:	8c503604 	addi	r17,r17,16600
 2005c68:	88800017 	ldw	r2,0(r17)
 2005c6c:	dc000015 	stw	r16,0(sp)
 2005c70:	dfc00215 	stw	ra,8(sp)
 2005c74:	2021883a 	mov	r16,r4
 2005c78:	10000226 	beq	r2,zero,2005c84 <getc+0x2c>
 2005c7c:	10c00e17 	ldw	r3,56(r2)
 2005c80:	18000d26 	beq	r3,zero,2005cb8 <getc+0x60>
 2005c84:	80800117 	ldw	r2,4(r16)
 2005c88:	10bfffc4 	addi	r2,r2,-1
 2005c8c:	80800115 	stw	r2,4(r16)
 2005c90:	10000c16 	blt	r2,zero,2005cc4 <getc+0x6c>
 2005c94:	80c00017 	ldw	r3,0(r16)
 2005c98:	18800003 	ldbu	r2,0(r3)
 2005c9c:	18c00044 	addi	r3,r3,1
 2005ca0:	80c00015 	stw	r3,0(r16)
 2005ca4:	dfc00217 	ldw	ra,8(sp)
 2005ca8:	dc400117 	ldw	r17,4(sp)
 2005cac:	dc000017 	ldw	r16,0(sp)
 2005cb0:	dec00304 	addi	sp,sp,12
 2005cb4:	f800283a 	ret
 2005cb8:	1009883a 	mov	r4,r2
 2005cbc:	200492c0 	call	200492c <__sinit>
 2005cc0:	003ff006 	br	2005c84 <getc+0x2c>
 2005cc4:	89000017 	ldw	r4,0(r17)
 2005cc8:	800b883a 	mov	r5,r16
 2005ccc:	dfc00217 	ldw	ra,8(sp)
 2005cd0:	dc400117 	ldw	r17,4(sp)
 2005cd4:	dc000017 	ldw	r16,0(sp)
 2005cd8:	dec00304 	addi	sp,sp,12
 2005cdc:	2006ed01 	jmpi	2006ed0 <__srget_r>

02005ce0 <__smakebuf_r>:
 2005ce0:	2880030b 	ldhu	r2,12(r5)
 2005ce4:	deffed04 	addi	sp,sp,-76
 2005ce8:	dc401015 	stw	r17,64(sp)
 2005cec:	10c0008c 	andi	r3,r2,2
 2005cf0:	18ffffcc 	andi	r3,r3,65535
 2005cf4:	18e0001c 	xori	r3,r3,32768
 2005cf8:	dc000f15 	stw	r16,60(sp)
 2005cfc:	dfc01215 	stw	ra,72(sp)
 2005d00:	dc801115 	stw	r18,68(sp)
 2005d04:	18e00004 	addi	r3,r3,-32768
 2005d08:	2821883a 	mov	r16,r5
 2005d0c:	2023883a 	mov	r17,r4
 2005d10:	1800381e 	bne	r3,zero,2005df4 <__smakebuf_r+0x114>
 2005d14:	2940038f 	ldh	r5,14(r5)
 2005d18:	28002d16 	blt	r5,zero,2005dd0 <__smakebuf_r+0xf0>
 2005d1c:	d80d883a 	mov	r6,sp
 2005d20:	200581c0 	call	200581c <_fstat_r>
 2005d24:	10002916 	blt	r2,zero,2005dcc <__smakebuf_r+0xec>
 2005d28:	d8800117 	ldw	r2,4(sp)
 2005d2c:	00e00014 	movui	r3,32768
 2005d30:	10bc000c 	andi	r2,r2,61440
 2005d34:	10c03c26 	beq	r2,r3,2005e28 <__smakebuf_r+0x148>
 2005d38:	80c0030b 	ldhu	r3,12(r16)
 2005d3c:	18c20014 	ori	r3,r3,2048
 2005d40:	80c0030d 	sth	r3,12(r16)
 2005d44:	00c80004 	movi	r3,8192
 2005d48:	10c00c1e 	bne	r2,r3,2005d7c <__smakebuf_r+0x9c>
 2005d4c:	8140038f 	ldh	r5,14(r16)
 2005d50:	8809883a 	mov	r4,r17
 2005d54:	200e1f40 	call	200e1f4 <_isatty_r>
 2005d58:	10000826 	beq	r2,zero,2005d7c <__smakebuf_r+0x9c>
 2005d5c:	80c0030b 	ldhu	r3,12(r16)
 2005d60:	808010c4 	addi	r2,r16,67
 2005d64:	80800015 	stw	r2,0(r16)
 2005d68:	18c00054 	ori	r3,r3,1
 2005d6c:	80800415 	stw	r2,16(r16)
 2005d70:	00800044 	movi	r2,1
 2005d74:	80c0030d 	sth	r3,12(r16)
 2005d78:	80800515 	stw	r2,20(r16)
 2005d7c:	04810004 	movi	r18,1024
 2005d80:	8809883a 	mov	r4,r17
 2005d84:	900b883a 	mov	r5,r18
 2005d88:	2005e880 	call	2005e88 <_malloc_r>
 2005d8c:	10003026 	beq	r2,zero,2005e50 <__smakebuf_r+0x170>
 2005d90:	80c0030b 	ldhu	r3,12(r16)
 2005d94:	01008034 	movhi	r4,512
 2005d98:	21122b04 	addi	r4,r4,18604
 2005d9c:	89000f15 	stw	r4,60(r17)
 2005da0:	18c02014 	ori	r3,r3,128
 2005da4:	80c0030d 	sth	r3,12(r16)
 2005da8:	80800015 	stw	r2,0(r16)
 2005dac:	80800415 	stw	r2,16(r16)
 2005db0:	84800515 	stw	r18,20(r16)
 2005db4:	dfc01217 	ldw	ra,72(sp)
 2005db8:	dc801117 	ldw	r18,68(sp)
 2005dbc:	dc401017 	ldw	r17,64(sp)
 2005dc0:	dc000f17 	ldw	r16,60(sp)
 2005dc4:	dec01304 	addi	sp,sp,76
 2005dc8:	f800283a 	ret
 2005dcc:	8080030b 	ldhu	r2,12(r16)
 2005dd0:	10c0200c 	andi	r3,r2,128
 2005dd4:	18ffffcc 	andi	r3,r3,65535
 2005dd8:	18e0001c 	xori	r3,r3,32768
 2005ddc:	18e00004 	addi	r3,r3,-32768
 2005de0:	18000f1e 	bne	r3,zero,2005e20 <__smakebuf_r+0x140>
 2005de4:	04810004 	movi	r18,1024
 2005de8:	10820014 	ori	r2,r2,2048
 2005dec:	8080030d 	sth	r2,12(r16)
 2005df0:	003fe306 	br	2005d80 <__smakebuf_r+0xa0>
 2005df4:	288010c4 	addi	r2,r5,67
 2005df8:	28800015 	stw	r2,0(r5)
 2005dfc:	28800415 	stw	r2,16(r5)
 2005e00:	00800044 	movi	r2,1
 2005e04:	28800515 	stw	r2,20(r5)
 2005e08:	dfc01217 	ldw	ra,72(sp)
 2005e0c:	dc801117 	ldw	r18,68(sp)
 2005e10:	dc401017 	ldw	r17,64(sp)
 2005e14:	dc000f17 	ldw	r16,60(sp)
 2005e18:	dec01304 	addi	sp,sp,76
 2005e1c:	f800283a 	ret
 2005e20:	04801004 	movi	r18,64
 2005e24:	003ff006 	br	2005de8 <__smakebuf_r+0x108>
 2005e28:	81000a17 	ldw	r4,40(r16)
 2005e2c:	00c08034 	movhi	r3,512
 2005e30:	18dc8c04 	addi	r3,r3,29232
 2005e34:	20ffc01e 	bne	r4,r3,2005d38 <__smakebuf_r+0x58>
 2005e38:	8080030b 	ldhu	r2,12(r16)
 2005e3c:	00c10004 	movi	r3,1024
 2005e40:	80c01315 	stw	r3,76(r16)
 2005e44:	10c4b03a 	or	r2,r2,r3
 2005e48:	8080030d 	sth	r2,12(r16)
 2005e4c:	003fcb06 	br	2005d7c <__smakebuf_r+0x9c>
 2005e50:	8080030b 	ldhu	r2,12(r16)
 2005e54:	10c0800c 	andi	r3,r2,512
 2005e58:	18ffffcc 	andi	r3,r3,65535
 2005e5c:	18e0001c 	xori	r3,r3,32768
 2005e60:	18e00004 	addi	r3,r3,-32768
 2005e64:	183fd31e 	bne	r3,zero,2005db4 <__smakebuf_r+0xd4>
 2005e68:	10800094 	ori	r2,r2,2
 2005e6c:	80c010c4 	addi	r3,r16,67
 2005e70:	8080030d 	sth	r2,12(r16)
 2005e74:	00800044 	movi	r2,1
 2005e78:	80c00015 	stw	r3,0(r16)
 2005e7c:	80c00415 	stw	r3,16(r16)
 2005e80:	80800515 	stw	r2,20(r16)
 2005e84:	003fcb06 	br	2005db4 <__smakebuf_r+0xd4>

02005e88 <_malloc_r>:
 2005e88:	defff604 	addi	sp,sp,-40
 2005e8c:	dc800215 	stw	r18,8(sp)
 2005e90:	dfc00915 	stw	ra,36(sp)
 2005e94:	df000815 	stw	fp,32(sp)
 2005e98:	ddc00715 	stw	r23,28(sp)
 2005e9c:	dd800615 	stw	r22,24(sp)
 2005ea0:	dd400515 	stw	r21,20(sp)
 2005ea4:	dd000415 	stw	r20,16(sp)
 2005ea8:	dcc00315 	stw	r19,12(sp)
 2005eac:	dc400115 	stw	r17,4(sp)
 2005eb0:	dc000015 	stw	r16,0(sp)
 2005eb4:	288002c4 	addi	r2,r5,11
 2005eb8:	00c00584 	movi	r3,22
 2005ebc:	2025883a 	mov	r18,r4
 2005ec0:	18802b2e 	bgeu	r3,r2,2005f70 <_malloc_r+0xe8>
 2005ec4:	047ffe04 	movi	r17,-8
 2005ec8:	1462703a 	and	r17,r2,r17
 2005ecc:	88002a16 	blt	r17,zero,2005f78 <_malloc_r+0xf0>
 2005ed0:	89402936 	bltu	r17,r5,2005f78 <_malloc_r+0xf0>
 2005ed4:	9009883a 	mov	r4,r18
 2005ed8:	2015aec0 	call	2015aec <__malloc_lock>
 2005edc:	00807dc4 	movi	r2,503
 2005ee0:	14402936 	bltu	r2,r17,2005f88 <_malloc_r+0x100>
 2005ee4:	8808d0fa 	srli	r4,r17,3
 2005ee8:	04c08174 	movhi	r19,517
 2005eec:	9cc97004 	addi	r19,r19,9664
 2005ef0:	2105883a 	add	r2,r4,r4
 2005ef4:	1085883a 	add	r2,r2,r2
 2005ef8:	1085883a 	add	r2,r2,r2
 2005efc:	9885883a 	add	r2,r19,r2
 2005f00:	14000317 	ldw	r16,12(r2)
 2005f04:	80815526 	beq	r16,r2,200645c <_malloc_r+0x5d4>
 2005f08:	81000117 	ldw	r4,4(r16)
 2005f0c:	00bfff04 	movi	r2,-4
 2005f10:	80c00317 	ldw	r3,12(r16)
 2005f14:	2084703a 	and	r2,r4,r2
 2005f18:	8085883a 	add	r2,r16,r2
 2005f1c:	11800117 	ldw	r6,4(r2)
 2005f20:	81400217 	ldw	r5,8(r16)
 2005f24:	9009883a 	mov	r4,r18
 2005f28:	31800054 	ori	r6,r6,1
 2005f2c:	11800115 	stw	r6,4(r2)
 2005f30:	28c00315 	stw	r3,12(r5)
 2005f34:	19400215 	stw	r5,8(r3)
 2005f38:	2015c000 	call	2015c00 <__malloc_unlock>
 2005f3c:	80800204 	addi	r2,r16,8
 2005f40:	dfc00917 	ldw	ra,36(sp)
 2005f44:	df000817 	ldw	fp,32(sp)
 2005f48:	ddc00717 	ldw	r23,28(sp)
 2005f4c:	dd800617 	ldw	r22,24(sp)
 2005f50:	dd400517 	ldw	r21,20(sp)
 2005f54:	dd000417 	ldw	r20,16(sp)
 2005f58:	dcc00317 	ldw	r19,12(sp)
 2005f5c:	dc800217 	ldw	r18,8(sp)
 2005f60:	dc400117 	ldw	r17,4(sp)
 2005f64:	dc000017 	ldw	r16,0(sp)
 2005f68:	dec00a04 	addi	sp,sp,40
 2005f6c:	f800283a 	ret
 2005f70:	04400404 	movi	r17,16
 2005f74:	897fd72e 	bgeu	r17,r5,2005ed4 <_malloc_r+0x4c>
 2005f78:	00800304 	movi	r2,12
 2005f7c:	90800015 	stw	r2,0(r18)
 2005f80:	0005883a 	mov	r2,zero
 2005f84:	003fee06 	br	2005f40 <_malloc_r+0xb8>
 2005f88:	8808d27a 	srli	r4,r17,9
 2005f8c:	20007126 	beq	r4,zero,2006154 <_malloc_r+0x2cc>
 2005f90:	00800104 	movi	r2,4
 2005f94:	1100eb36 	bltu	r2,r4,2006344 <_malloc_r+0x4bc>
 2005f98:	8808d1ba 	srli	r4,r17,6
 2005f9c:	21000e04 	addi	r4,r4,56
 2005fa0:	210b883a 	add	r5,r4,r4
 2005fa4:	294b883a 	add	r5,r5,r5
 2005fa8:	294b883a 	add	r5,r5,r5
 2005fac:	04c08174 	movhi	r19,517
 2005fb0:	9cc97004 	addi	r19,r19,9664
 2005fb4:	994b883a 	add	r5,r19,r5
 2005fb8:	2c000317 	ldw	r16,12(r5)
 2005fbc:	2c000e26 	beq	r5,r16,2005ff8 <_malloc_r+0x170>
 2005fc0:	80c00117 	ldw	r3,4(r16)
 2005fc4:	01ffff04 	movi	r7,-4
 2005fc8:	018003c4 	movi	r6,15
 2005fcc:	19c6703a 	and	r3,r3,r7
 2005fd0:	1c45c83a 	sub	r2,r3,r17
 2005fd4:	30800716 	blt	r6,r2,2005ff4 <_malloc_r+0x16c>
 2005fd8:	1000610e 	bge	r2,zero,2006160 <_malloc_r+0x2d8>
 2005fdc:	84000317 	ldw	r16,12(r16)
 2005fe0:	2c000526 	beq	r5,r16,2005ff8 <_malloc_r+0x170>
 2005fe4:	80c00117 	ldw	r3,4(r16)
 2005fe8:	19c6703a 	and	r3,r3,r7
 2005fec:	1c45c83a 	sub	r2,r3,r17
 2005ff0:	30bff90e 	bge	r6,r2,2005fd8 <_malloc_r+0x150>
 2005ff4:	213fffc4 	addi	r4,r4,-1
 2005ff8:	21000044 	addi	r4,r4,1
 2005ffc:	9c000417 	ldw	r16,16(r19)
 2006000:	00c08174 	movhi	r3,517
 2006004:	18c97004 	addi	r3,r3,9664
 2006008:	1a400204 	addi	r9,r3,8
 200600c:	8240ff26 	beq	r16,r9,200640c <_malloc_r+0x584>
 2006010:	81400117 	ldw	r5,4(r16)
 2006014:	00bfff04 	movi	r2,-4
 2006018:	018003c4 	movi	r6,15
 200601c:	2884703a 	and	r2,r5,r2
 2006020:	144bc83a 	sub	r5,r2,r17
 2006024:	3140ea16 	blt	r6,r5,20063d0 <_malloc_r+0x548>
 2006028:	1a400515 	stw	r9,20(r3)
 200602c:	1a400415 	stw	r9,16(r3)
 2006030:	2800570e 	bge	r5,zero,2006190 <_malloc_r+0x308>
 2006034:	01407fc4 	movi	r5,511
 2006038:	2880ca36 	bltu	r5,r2,2006364 <_malloc_r+0x4dc>
 200603c:	1004d0fa 	srli	r2,r2,3
 2006040:	02000044 	movi	r8,1
 2006044:	19c00117 	ldw	r7,4(r3)
 2006048:	108b883a 	add	r5,r2,r2
 200604c:	294b883a 	add	r5,r5,r5
 2006050:	1005d0ba 	srai	r2,r2,2
 2006054:	294b883a 	add	r5,r5,r5
 2006058:	28cb883a 	add	r5,r5,r3
 200605c:	29800217 	ldw	r6,8(r5)
 2006060:	4084983a 	sll	r2,r8,r2
 2006064:	81400315 	stw	r5,12(r16)
 2006068:	81800215 	stw	r6,8(r16)
 200606c:	11c4b03a 	or	r2,r2,r7
 2006070:	18800115 	stw	r2,4(r3)
 2006074:	2c000215 	stw	r16,8(r5)
 2006078:	34000315 	stw	r16,12(r6)
 200607c:	200bd0ba 	srai	r5,r4,2
 2006080:	00c00044 	movi	r3,1
 2006084:	194a983a 	sll	r5,r3,r5
 2006088:	11404936 	bltu	r2,r5,20061b0 <_malloc_r+0x328>
 200608c:	1146703a 	and	r3,r2,r5
 2006090:	18000a1e 	bne	r3,zero,20060bc <_malloc_r+0x234>
 2006094:	00ffff04 	movi	r3,-4
 2006098:	294b883a 	add	r5,r5,r5
 200609c:	20c8703a 	and	r4,r4,r3
 20060a0:	1146703a 	and	r3,r2,r5
 20060a4:	21000104 	addi	r4,r4,4
 20060a8:	1800041e 	bne	r3,zero,20060bc <_malloc_r+0x234>
 20060ac:	294b883a 	add	r5,r5,r5
 20060b0:	1146703a 	and	r3,r2,r5
 20060b4:	21000104 	addi	r4,r4,4
 20060b8:	183ffc26 	beq	r3,zero,20060ac <_malloc_r+0x224>
 20060bc:	023fff04 	movi	r8,-4
 20060c0:	01c003c4 	movi	r7,15
 20060c4:	2105883a 	add	r2,r4,r4
 20060c8:	1085883a 	add	r2,r2,r2
 20060cc:	1085883a 	add	r2,r2,r2
 20060d0:	9899883a 	add	r12,r19,r2
 20060d4:	62800304 	addi	r10,r12,12
 20060d8:	2017883a 	mov	r11,r4
 20060dc:	54000017 	ldw	r16,0(r10)
 20060e0:	51bffd04 	addi	r6,r10,-12
 20060e4:	8180041e 	bne	r16,r6,20060f8 <_malloc_r+0x270>
 20060e8:	0000ca06 	br	2006414 <_malloc_r+0x58c>
 20060ec:	10001c0e 	bge	r2,zero,2006160 <_malloc_r+0x2d8>
 20060f0:	84000317 	ldw	r16,12(r16)
 20060f4:	8180c726 	beq	r16,r6,2006414 <_malloc_r+0x58c>
 20060f8:	80c00117 	ldw	r3,4(r16)
 20060fc:	1a06703a 	and	r3,r3,r8
 2006100:	1c45c83a 	sub	r2,r3,r17
 2006104:	38bff90e 	bge	r7,r2,20060ec <_malloc_r+0x264>
 2006108:	81000317 	ldw	r4,12(r16)
 200610c:	81400217 	ldw	r5,8(r16)
 2006110:	8447883a 	add	r3,r16,r17
 2006114:	8c400054 	ori	r17,r17,1
 2006118:	29000315 	stw	r4,12(r5)
 200611c:	21400215 	stw	r5,8(r4)
 2006120:	84400115 	stw	r17,4(r16)
 2006124:	1889883a 	add	r4,r3,r2
 2006128:	11400054 	ori	r5,r2,1
 200612c:	98c00515 	stw	r3,20(r19)
 2006130:	98c00415 	stw	r3,16(r19)
 2006134:	20800015 	stw	r2,0(r4)
 2006138:	1a400315 	stw	r9,12(r3)
 200613c:	1a400215 	stw	r9,8(r3)
 2006140:	19400115 	stw	r5,4(r3)
 2006144:	9009883a 	mov	r4,r18
 2006148:	2015c000 	call	2015c00 <__malloc_unlock>
 200614c:	80800204 	addi	r2,r16,8
 2006150:	003f7b06 	br	2005f40 <_malloc_r+0xb8>
 2006154:	8808d0fa 	srli	r4,r17,3
 2006158:	210b883a 	add	r5,r4,r4
 200615c:	003f9106 	br	2005fa4 <_malloc_r+0x11c>
 2006160:	80c7883a 	add	r3,r16,r3
 2006164:	19400117 	ldw	r5,4(r3)
 2006168:	80800317 	ldw	r2,12(r16)
 200616c:	81000217 	ldw	r4,8(r16)
 2006170:	29400054 	ori	r5,r5,1
 2006174:	19400115 	stw	r5,4(r3)
 2006178:	20800315 	stw	r2,12(r4)
 200617c:	11000215 	stw	r4,8(r2)
 2006180:	9009883a 	mov	r4,r18
 2006184:	2015c000 	call	2015c00 <__malloc_unlock>
 2006188:	80800204 	addi	r2,r16,8
 200618c:	003f6c06 	br	2005f40 <_malloc_r+0xb8>
 2006190:	8085883a 	add	r2,r16,r2
 2006194:	10c00117 	ldw	r3,4(r2)
 2006198:	9009883a 	mov	r4,r18
 200619c:	18c00054 	ori	r3,r3,1
 20061a0:	10c00115 	stw	r3,4(r2)
 20061a4:	2015c000 	call	2015c00 <__malloc_unlock>
 20061a8:	80800204 	addi	r2,r16,8
 20061ac:	003f6406 	br	2005f40 <_malloc_r+0xb8>
 20061b0:	9c000217 	ldw	r16,8(r19)
 20061b4:	00bfff04 	movi	r2,-4
 20061b8:	85400117 	ldw	r21,4(r16)
 20061bc:	a8aa703a 	and	r21,r21,r2
 20061c0:	ac400336 	bltu	r21,r17,20061d0 <_malloc_r+0x348>
 20061c4:	ac45c83a 	sub	r2,r21,r17
 20061c8:	00c003c4 	movi	r3,15
 20061cc:	18805316 	blt	r3,r2,200631c <_malloc_r+0x494>
 20061d0:	d5e06417 	ldw	r23,-32368(gp)
 20061d4:	d0e00d17 	ldw	r3,-32716(gp)
 20061d8:	00bfffc4 	movi	r2,-1
 20061dc:	8579883a 	add	fp,r16,r21
 20061e0:	8def883a 	add	r23,r17,r23
 20061e4:	1880d226 	beq	r3,r2,2006530 <_malloc_r+0x6a8>
 20061e8:	bdc403c4 	addi	r23,r23,4111
 20061ec:	00bc0004 	movi	r2,-4096
 20061f0:	b8ae703a 	and	r23,r23,r2
 20061f4:	9009883a 	mov	r4,r18
 20061f8:	b80b883a 	mov	r5,r23
 20061fc:	2006f300 	call	2006f30 <_sbrk_r>
 2006200:	1029883a 	mov	r20,r2
 2006204:	00bfffc4 	movi	r2,-1
 2006208:	a080d126 	beq	r20,r2,2006550 <_malloc_r+0x6c8>
 200620c:	a7009f36 	bltu	r20,fp,200648c <_malloc_r+0x604>
 2006210:	058081b4 	movhi	r22,518
 2006214:	b583c204 	addi	r22,r22,3848
 2006218:	b0800017 	ldw	r2,0(r22)
 200621c:	b885883a 	add	r2,r23,r2
 2006220:	b0800015 	stw	r2,0(r22)
 2006224:	e500cf26 	beq	fp,r20,2006564 <_malloc_r+0x6dc>
 2006228:	d1200d17 	ldw	r4,-32716(gp)
 200622c:	00ffffc4 	movi	r3,-1
 2006230:	20c0e026 	beq	r4,r3,20065b4 <_malloc_r+0x72c>
 2006234:	a739c83a 	sub	fp,r20,fp
 2006238:	1705883a 	add	r2,r2,fp
 200623c:	b0800015 	stw	r2,0(r22)
 2006240:	a08001cc 	andi	r2,r20,7
 2006244:	1000a526 	beq	r2,zero,20064dc <_malloc_r+0x654>
 2006248:	a0a9c83a 	sub	r20,r20,r2
 200624c:	00c40204 	movi	r3,4104
 2006250:	a5000204 	addi	r20,r20,8
 2006254:	1885c83a 	sub	r2,r3,r2
 2006258:	a5c7883a 	add	r3,r20,r23
 200625c:	18c3ffcc 	andi	r3,r3,4095
 2006260:	10efc83a 	sub	r23,r2,r3
 2006264:	9009883a 	mov	r4,r18
 2006268:	b80b883a 	mov	r5,r23
 200626c:	2006f300 	call	2006f30 <_sbrk_r>
 2006270:	00ffffc4 	movi	r3,-1
 2006274:	10c0cc26 	beq	r2,r3,20065a8 <_malloc_r+0x720>
 2006278:	1505c83a 	sub	r2,r2,r20
 200627c:	b887883a 	add	r3,r23,r2
 2006280:	18c00054 	ori	r3,r3,1
 2006284:	b0800017 	ldw	r2,0(r22)
 2006288:	9d000215 	stw	r20,8(r19)
 200628c:	a0c00115 	stw	r3,4(r20)
 2006290:	b885883a 	add	r2,r23,r2
 2006294:	b0800015 	stw	r2,0(r22)
 2006298:	84c00e26 	beq	r16,r19,20062d4 <_malloc_r+0x44c>
 200629c:	00c003c4 	movi	r3,15
 20062a0:	1d40902e 	bgeu	r3,r21,20064e4 <_malloc_r+0x65c>
 20062a4:	ad7ffd04 	addi	r21,r21,-12
 20062a8:	013ffe04 	movi	r4,-8
 20062ac:	a908703a 	and	r4,r21,r4
 20062b0:	810b883a 	add	r5,r16,r4
 20062b4:	01800144 	movi	r6,5
 20062b8:	29800115 	stw	r6,4(r5)
 20062bc:	29800215 	stw	r6,8(r5)
 20062c0:	81400117 	ldw	r5,4(r16)
 20062c4:	2940004c 	andi	r5,r5,1
 20062c8:	214ab03a 	or	r5,r4,r5
 20062cc:	81400115 	stw	r5,4(r16)
 20062d0:	1900ae36 	bltu	r3,r4,200658c <_malloc_r+0x704>
 20062d4:	d0e06317 	ldw	r3,-32372(gp)
 20062d8:	1880012e 	bgeu	r3,r2,20062e0 <_malloc_r+0x458>
 20062dc:	d0a06315 	stw	r2,-32372(gp)
 20062e0:	d0e06217 	ldw	r3,-32376(gp)
 20062e4:	9c000217 	ldw	r16,8(r19)
 20062e8:	1880012e 	bgeu	r3,r2,20062f0 <_malloc_r+0x468>
 20062ec:	d0a06215 	stw	r2,-32376(gp)
 20062f0:	80c00117 	ldw	r3,4(r16)
 20062f4:	00bfff04 	movi	r2,-4
 20062f8:	1886703a 	and	r3,r3,r2
 20062fc:	1c45c83a 	sub	r2,r3,r17
 2006300:	1c400236 	bltu	r3,r17,200630c <_malloc_r+0x484>
 2006304:	00c003c4 	movi	r3,15
 2006308:	18800416 	blt	r3,r2,200631c <_malloc_r+0x494>
 200630c:	9009883a 	mov	r4,r18
 2006310:	2015c000 	call	2015c00 <__malloc_unlock>
 2006314:	0005883a 	mov	r2,zero
 2006318:	003f0906 	br	2005f40 <_malloc_r+0xb8>
 200631c:	88c00054 	ori	r3,r17,1
 2006320:	10800054 	ori	r2,r2,1
 2006324:	80c00115 	stw	r3,4(r16)
 2006328:	8463883a 	add	r17,r16,r17
 200632c:	88800115 	stw	r2,4(r17)
 2006330:	9009883a 	mov	r4,r18
 2006334:	9c400215 	stw	r17,8(r19)
 2006338:	2015c000 	call	2015c00 <__malloc_unlock>
 200633c:	80800204 	addi	r2,r16,8
 2006340:	003eff06 	br	2005f40 <_malloc_r+0xb8>
 2006344:	00800504 	movi	r2,20
 2006348:	1100492e 	bgeu	r2,r4,2006470 <_malloc_r+0x5e8>
 200634c:	00801504 	movi	r2,84
 2006350:	11005c36 	bltu	r2,r4,20064c4 <_malloc_r+0x63c>
 2006354:	8808d33a 	srli	r4,r17,12
 2006358:	21001b84 	addi	r4,r4,110
 200635c:	210b883a 	add	r5,r4,r4
 2006360:	003f1006 	br	2005fa4 <_malloc_r+0x11c>
 2006364:	1006d27a 	srli	r3,r2,9
 2006368:	01400104 	movi	r5,4
 200636c:	28c0432e 	bgeu	r5,r3,200647c <_malloc_r+0x5f4>
 2006370:	01400504 	movi	r5,20
 2006374:	28c07036 	bltu	r5,r3,2006538 <_malloc_r+0x6b0>
 2006378:	194016c4 	addi	r5,r3,91
 200637c:	294d883a 	add	r6,r5,r5
 2006380:	318d883a 	add	r6,r6,r6
 2006384:	318d883a 	add	r6,r6,r6
 2006388:	998d883a 	add	r6,r19,r6
 200638c:	30c00217 	ldw	r3,8(r6)
 2006390:	01c08174 	movhi	r7,517
 2006394:	39c97004 	addi	r7,r7,9664
 2006398:	19805726 	beq	r3,r6,20064f8 <_malloc_r+0x670>
 200639c:	01ffff04 	movi	r7,-4
 20063a0:	19400117 	ldw	r5,4(r3)
 20063a4:	29ca703a 	and	r5,r5,r7
 20063a8:	1140022e 	bgeu	r2,r5,20063b4 <_malloc_r+0x52c>
 20063ac:	18c00217 	ldw	r3,8(r3)
 20063b0:	30fffb1e 	bne	r6,r3,20063a0 <_malloc_r+0x518>
 20063b4:	19400317 	ldw	r5,12(r3)
 20063b8:	98800117 	ldw	r2,4(r19)
 20063bc:	81400315 	stw	r5,12(r16)
 20063c0:	80c00215 	stw	r3,8(r16)
 20063c4:	2c000215 	stw	r16,8(r5)
 20063c8:	1c000315 	stw	r16,12(r3)
 20063cc:	003f2b06 	br	200607c <_malloc_r+0x1f4>
 20063d0:	8445883a 	add	r2,r16,r17
 20063d4:	8c400054 	ori	r17,r17,1
 20063d8:	18800515 	stw	r2,20(r3)
 20063dc:	18800415 	stw	r2,16(r3)
 20063e0:	29000054 	ori	r4,r5,1
 20063e4:	1147883a 	add	r3,r2,r5
 20063e8:	84400115 	stw	r17,4(r16)
 20063ec:	11000115 	stw	r4,4(r2)
 20063f0:	12400315 	stw	r9,12(r2)
 20063f4:	12400215 	stw	r9,8(r2)
 20063f8:	19400015 	stw	r5,0(r3)
 20063fc:	9009883a 	mov	r4,r18
 2006400:	2015c000 	call	2015c00 <__malloc_unlock>
 2006404:	80800204 	addi	r2,r16,8
 2006408:	003ecd06 	br	2005f40 <_malloc_r+0xb8>
 200640c:	18800117 	ldw	r2,4(r3)
 2006410:	003f1a06 	br	200607c <_malloc_r+0x1f4>
 2006414:	5ac00044 	addi	r11,r11,1
 2006418:	588000cc 	andi	r2,r11,3
 200641c:	52800204 	addi	r10,r10,8
 2006420:	103f2e1e 	bne	r2,zero,20060dc <_malloc_r+0x254>
 2006424:	20c000cc 	andi	r3,r4,3
 2006428:	60bffe04 	addi	r2,r12,-8
 200642c:	18006f26 	beq	r3,zero,20065ec <_malloc_r+0x764>
 2006430:	63000017 	ldw	r12,0(r12)
 2006434:	213fffc4 	addi	r4,r4,-1
 2006438:	60bffa26 	beq	r12,r2,2006424 <_malloc_r+0x59c>
 200643c:	98800117 	ldw	r2,4(r19)
 2006440:	294b883a 	add	r5,r5,r5
 2006444:	117f5a36 	bltu	r2,r5,20061b0 <_malloc_r+0x328>
 2006448:	283f5926 	beq	r5,zero,20061b0 <_malloc_r+0x328>
 200644c:	1146703a 	and	r3,r2,r5
 2006450:	18001626 	beq	r3,zero,20064ac <_malloc_r+0x624>
 2006454:	5809883a 	mov	r4,r11
 2006458:	003f1a06 	br	20060c4 <_malloc_r+0x23c>
 200645c:	80800204 	addi	r2,r16,8
 2006460:	84000517 	ldw	r16,20(r16)
 2006464:	143ea81e 	bne	r2,r16,2005f08 <_malloc_r+0x80>
 2006468:	21000084 	addi	r4,r4,2
 200646c:	003ee306 	br	2005ffc <_malloc_r+0x174>
 2006470:	210016c4 	addi	r4,r4,91
 2006474:	210b883a 	add	r5,r4,r4
 2006478:	003eca06 	br	2005fa4 <_malloc_r+0x11c>
 200647c:	100ad1ba 	srli	r5,r2,6
 2006480:	29400e04 	addi	r5,r5,56
 2006484:	294d883a 	add	r6,r5,r5
 2006488:	003fbd06 	br	2006380 <_malloc_r+0x4f8>
 200648c:	84ff6026 	beq	r16,r19,2006210 <_malloc_r+0x388>
 2006490:	00808174 	movhi	r2,517
 2006494:	10897004 	addi	r2,r2,9664
 2006498:	14000217 	ldw	r16,8(r2)
 200649c:	00bfff04 	movi	r2,-4
 20064a0:	80c00117 	ldw	r3,4(r16)
 20064a4:	1886703a 	and	r3,r3,r2
 20064a8:	003f9406 	br	20062fc <_malloc_r+0x474>
 20064ac:	294b883a 	add	r5,r5,r5
 20064b0:	1146703a 	and	r3,r2,r5
 20064b4:	5ac00104 	addi	r11,r11,4
 20064b8:	183ffc26 	beq	r3,zero,20064ac <_malloc_r+0x624>
 20064bc:	5809883a 	mov	r4,r11
 20064c0:	003f0006 	br	20060c4 <_malloc_r+0x23c>
 20064c4:	00805504 	movi	r2,340
 20064c8:	11001336 	bltu	r2,r4,2006518 <_malloc_r+0x690>
 20064cc:	8808d3fa 	srli	r4,r17,15
 20064d0:	21001dc4 	addi	r4,r4,119
 20064d4:	210b883a 	add	r5,r4,r4
 20064d8:	003eb206 	br	2005fa4 <_malloc_r+0x11c>
 20064dc:	00840004 	movi	r2,4096
 20064e0:	003f5d06 	br	2006258 <_malloc_r+0x3d0>
 20064e4:	00800044 	movi	r2,1
 20064e8:	a0800115 	stw	r2,4(r20)
 20064ec:	a021883a 	mov	r16,r20
 20064f0:	0007883a 	mov	r3,zero
 20064f4:	003f8106 	br	20062fc <_malloc_r+0x474>
 20064f8:	280bd0ba 	srai	r5,r5,2
 20064fc:	01800044 	movi	r6,1
 2006500:	38800117 	ldw	r2,4(r7)
 2006504:	314c983a 	sll	r6,r6,r5
 2006508:	180b883a 	mov	r5,r3
 200650c:	3084b03a 	or	r2,r6,r2
 2006510:	38800115 	stw	r2,4(r7)
 2006514:	003fa906 	br	20063bc <_malloc_r+0x534>
 2006518:	00815504 	movi	r2,1364
 200651c:	11001836 	bltu	r2,r4,2006580 <_malloc_r+0x6f8>
 2006520:	8808d4ba 	srli	r4,r17,18
 2006524:	21001f04 	addi	r4,r4,124
 2006528:	210b883a 	add	r5,r4,r4
 200652c:	003e9d06 	br	2005fa4 <_malloc_r+0x11c>
 2006530:	bdc00404 	addi	r23,r23,16
 2006534:	003f2f06 	br	20061f4 <_malloc_r+0x36c>
 2006538:	01401504 	movi	r5,84
 200653c:	28c01f36 	bltu	r5,r3,20065bc <_malloc_r+0x734>
 2006540:	100ad33a 	srli	r5,r2,12
 2006544:	29401b84 	addi	r5,r5,110
 2006548:	294d883a 	add	r6,r5,r5
 200654c:	003f8c06 	br	2006380 <_malloc_r+0x4f8>
 2006550:	9c000217 	ldw	r16,8(r19)
 2006554:	00bfff04 	movi	r2,-4
 2006558:	80c00117 	ldw	r3,4(r16)
 200655c:	1886703a 	and	r3,r3,r2
 2006560:	003f6606 	br	20062fc <_malloc_r+0x474>
 2006564:	e0c3ffcc 	andi	r3,fp,4095
 2006568:	183f2f1e 	bne	r3,zero,2006228 <_malloc_r+0x3a0>
 200656c:	98c00217 	ldw	r3,8(r19)
 2006570:	bd49883a 	add	r4,r23,r21
 2006574:	21000054 	ori	r4,r4,1
 2006578:	19000115 	stw	r4,4(r3)
 200657c:	003f5506 	br	20062d4 <_malloc_r+0x44c>
 2006580:	01403f04 	movi	r5,252
 2006584:	01001f84 	movi	r4,126
 2006588:	003e8606 	br	2005fa4 <_malloc_r+0x11c>
 200658c:	9009883a 	mov	r4,r18
 2006590:	81400204 	addi	r5,r16,8
 2006594:	20050b40 	call	20050b4 <_free_r>
 2006598:	008081b4 	movhi	r2,518
 200659c:	1083c204 	addi	r2,r2,3848
 20065a0:	10800017 	ldw	r2,0(r2)
 20065a4:	003f4b06 	br	20062d4 <_malloc_r+0x44c>
 20065a8:	00c00044 	movi	r3,1
 20065ac:	002f883a 	mov	r23,zero
 20065b0:	003f3406 	br	2006284 <_malloc_r+0x3fc>
 20065b4:	d5200d15 	stw	r20,-32716(gp)
 20065b8:	003f2106 	br	2006240 <_malloc_r+0x3b8>
 20065bc:	01405504 	movi	r5,340
 20065c0:	28c00436 	bltu	r5,r3,20065d4 <_malloc_r+0x74c>
 20065c4:	100ad3fa 	srli	r5,r2,15
 20065c8:	29401dc4 	addi	r5,r5,119
 20065cc:	294d883a 	add	r6,r5,r5
 20065d0:	003f6b06 	br	2006380 <_malloc_r+0x4f8>
 20065d4:	01415504 	movi	r5,1364
 20065d8:	28c00936 	bltu	r5,r3,2006600 <_malloc_r+0x778>
 20065dc:	100ad4ba 	srli	r5,r2,18
 20065e0:	29401f04 	addi	r5,r5,124
 20065e4:	294d883a 	add	r6,r5,r5
 20065e8:	003f6506 	br	2006380 <_malloc_r+0x4f8>
 20065ec:	98800117 	ldw	r2,4(r19)
 20065f0:	0146303a 	nor	r3,zero,r5
 20065f4:	1884703a 	and	r2,r3,r2
 20065f8:	98800115 	stw	r2,4(r19)
 20065fc:	003f9006 	br	2006440 <_malloc_r+0x5b8>
 2006600:	01803f04 	movi	r6,252
 2006604:	01401f84 	movi	r5,126
 2006608:	003f5d06 	br	2006380 <_malloc_r+0x4f8>

0200660c <memcpy>:
 200660c:	00c003c4 	movi	r3,15
 2006610:	2005883a 	mov	r2,r4
 2006614:	3009883a 	mov	r4,r6
 2006618:	1980032e 	bgeu	r3,r6,2006628 <memcpy+0x1c>
 200661c:	2886b03a 	or	r3,r5,r2
 2006620:	18c000cc 	andi	r3,r3,3
 2006624:	18000926 	beq	r3,zero,200664c <memcpy+0x40>
 2006628:	1007883a 	mov	r3,r2
 200662c:	290f883a 	add	r7,r5,r4
 2006630:	20000526 	beq	r4,zero,2006648 <memcpy+0x3c>
 2006634:	29800003 	ldbu	r6,0(r5)
 2006638:	18c00044 	addi	r3,r3,1
 200663c:	29400044 	addi	r5,r5,1
 2006640:	19bfffc5 	stb	r6,-1(r3)
 2006644:	29fffb1e 	bne	r5,r7,2006634 <memcpy+0x28>
 2006648:	f800283a 	ret
 200664c:	327ffc04 	addi	r9,r6,-16
 2006650:	4812d13a 	srli	r9,r9,4
 2006654:	11000404 	addi	r4,r2,16
 2006658:	1007883a 	mov	r3,r2
 200665c:	4810913a 	slli	r8,r9,4
 2006660:	280f883a 	mov	r7,r5
 2006664:	2209883a 	add	r4,r4,r8
 2006668:	3a000017 	ldw	r8,0(r7)
 200666c:	18c00404 	addi	r3,r3,16
 2006670:	39c00404 	addi	r7,r7,16
 2006674:	1a3ffc15 	stw	r8,-16(r3)
 2006678:	3a3ffd17 	ldw	r8,-12(r7)
 200667c:	1a3ffd15 	stw	r8,-12(r3)
 2006680:	3a3ffe17 	ldw	r8,-8(r7)
 2006684:	1a3ffe15 	stw	r8,-8(r3)
 2006688:	3a3fff17 	ldw	r8,-4(r7)
 200668c:	1a3fff15 	stw	r8,-4(r3)
 2006690:	193ff51e 	bne	r3,r4,2006668 <memcpy+0x5c>
 2006694:	49c00044 	addi	r7,r9,1
 2006698:	380e913a 	slli	r7,r7,4
 200669c:	310003cc 	andi	r4,r6,15
 20066a0:	018000c4 	movi	r6,3
 20066a4:	11c7883a 	add	r3,r2,r7
 20066a8:	29cb883a 	add	r5,r5,r7
 20066ac:	313fdf2e 	bgeu	r6,r4,200662c <memcpy+0x20>
 20066b0:	213fff04 	addi	r4,r4,-4
 20066b4:	2014d0ba 	srli	r10,r4,2
 20066b8:	1a400104 	addi	r9,r3,4
 20066bc:	180d883a 	mov	r6,r3
 20066c0:	528f883a 	add	r7,r10,r10
 20066c4:	39cf883a 	add	r7,r7,r7
 20066c8:	49d3883a 	add	r9,r9,r7
 20066cc:	280f883a 	mov	r7,r5
 20066d0:	3a000017 	ldw	r8,0(r7)
 20066d4:	31800104 	addi	r6,r6,4
 20066d8:	39c00104 	addi	r7,r7,4
 20066dc:	323fff15 	stw	r8,-4(r6)
 20066e0:	327ffb1e 	bne	r6,r9,20066d0 <memcpy+0xc4>
 20066e4:	51800044 	addi	r6,r10,1
 20066e8:	52bfff24 	muli	r10,r10,-4
 20066ec:	318d883a 	add	r6,r6,r6
 20066f0:	318d883a 	add	r6,r6,r6
 20066f4:	5109883a 	add	r4,r10,r4
 20066f8:	298b883a 	add	r5,r5,r6
 20066fc:	1987883a 	add	r3,r3,r6
 2006700:	003fca06 	br	200662c <memcpy+0x20>

02006704 <memmove>:
 2006704:	2005883a 	mov	r2,r4
 2006708:	300f883a 	mov	r7,r6
 200670c:	29000b2e 	bgeu	r5,r4,200673c <memmove+0x38>
 2006710:	2987883a 	add	r3,r5,r6
 2006714:	20c0092e 	bgeu	r4,r3,200673c <memmove+0x38>
 2006718:	218b883a 	add	r5,r4,r6
 200671c:	198fc83a 	sub	r7,r3,r6
 2006720:	30003f26 	beq	r6,zero,2006820 <memmove+0x11c>
 2006724:	18ffffc4 	addi	r3,r3,-1
 2006728:	19000003 	ldbu	r4,0(r3)
 200672c:	297fffc4 	addi	r5,r5,-1
 2006730:	29000005 	stb	r4,0(r5)
 2006734:	19fffb1e 	bne	r3,r7,2006724 <memmove+0x20>
 2006738:	f800283a 	ret
 200673c:	00c003c4 	movi	r3,15
 2006740:	1980382e 	bgeu	r3,r6,2006824 <memmove+0x120>
 2006744:	2886b03a 	or	r3,r5,r2
 2006748:	18c000cc 	andi	r3,r3,3
 200674c:	1800351e 	bne	r3,zero,2006824 <memmove+0x120>
 2006750:	327ffc04 	addi	r9,r6,-16
 2006754:	4812d13a 	srli	r9,r9,4
 2006758:	12000404 	addi	r8,r2,16
 200675c:	1007883a 	mov	r3,r2
 2006760:	4808913a 	slli	r4,r9,4
 2006764:	280f883a 	mov	r7,r5
 2006768:	4111883a 	add	r8,r8,r4
 200676c:	39000017 	ldw	r4,0(r7)
 2006770:	18c00404 	addi	r3,r3,16
 2006774:	39c00404 	addi	r7,r7,16
 2006778:	193ffc15 	stw	r4,-16(r3)
 200677c:	393ffd17 	ldw	r4,-12(r7)
 2006780:	193ffd15 	stw	r4,-12(r3)
 2006784:	393ffe17 	ldw	r4,-8(r7)
 2006788:	193ffe15 	stw	r4,-8(r3)
 200678c:	393fff17 	ldw	r4,-4(r7)
 2006790:	193fff15 	stw	r4,-4(r3)
 2006794:	1a3ff51e 	bne	r3,r8,200676c <memmove+0x68>
 2006798:	49000044 	addi	r4,r9,1
 200679c:	2008913a 	slli	r4,r4,4
 20067a0:	31c003cc 	andi	r7,r6,15
 20067a4:	1107883a 	add	r3,r2,r4
 20067a8:	290b883a 	add	r5,r5,r4
 20067ac:	010000c4 	movi	r4,3
 20067b0:	21c0142e 	bgeu	r4,r7,2006804 <memmove+0x100>
 20067b4:	39ffff04 	addi	r7,r7,-4
 20067b8:	3814d0ba 	srli	r10,r7,2
 20067bc:	1a400104 	addi	r9,r3,4
 20067c0:	180d883a 	mov	r6,r3
 20067c4:	5289883a 	add	r4,r10,r10
 20067c8:	2109883a 	add	r4,r4,r4
 20067cc:	4913883a 	add	r9,r9,r4
 20067d0:	2809883a 	mov	r4,r5
 20067d4:	22000017 	ldw	r8,0(r4)
 20067d8:	31800104 	addi	r6,r6,4
 20067dc:	21000104 	addi	r4,r4,4
 20067e0:	323fff15 	stw	r8,-4(r6)
 20067e4:	327ffb1e 	bne	r6,r9,20067d4 <memmove+0xd0>
 20067e8:	51000044 	addi	r4,r10,1
 20067ec:	52bfff24 	muli	r10,r10,-4
 20067f0:	2109883a 	add	r4,r4,r4
 20067f4:	2109883a 	add	r4,r4,r4
 20067f8:	51cf883a 	add	r7,r10,r7
 20067fc:	290b883a 	add	r5,r5,r4
 2006800:	1907883a 	add	r3,r3,r4
 2006804:	38000626 	beq	r7,zero,2006820 <memmove+0x11c>
 2006808:	19cf883a 	add	r7,r3,r7
 200680c:	29800003 	ldbu	r6,0(r5)
 2006810:	18c00044 	addi	r3,r3,1
 2006814:	29400044 	addi	r5,r5,1
 2006818:	19bfffc5 	stb	r6,-1(r3)
 200681c:	19fffb1e 	bne	r3,r7,200680c <memmove+0x108>
 2006820:	f800283a 	ret
 2006824:	1007883a 	mov	r3,r2
 2006828:	003ff606 	br	2006804 <memmove+0x100>

0200682c <memset>:
 200682c:	00c000c4 	movi	r3,3
 2006830:	2005883a 	mov	r2,r4
 2006834:	29403fcc 	andi	r5,r5,255
 2006838:	19802d2e 	bgeu	r3,r6,20068f0 <memset+0xc4>
 200683c:	20c6703a 	and	r3,r4,r3
 2006840:	18002e1e 	bne	r3,zero,20068fc <memset+0xd0>
 2006844:	2806923a 	slli	r3,r5,8
 2006848:	010003c4 	movi	r4,15
 200684c:	3011883a 	mov	r8,r6
 2006850:	1946b03a 	or	r3,r3,r5
 2006854:	180e943a 	slli	r7,r3,16
 2006858:	38ceb03a 	or	r7,r7,r3
 200685c:	1007883a 	mov	r3,r2
 2006860:	21800f2e 	bgeu	r4,r6,20068a0 <memset+0x74>
 2006864:	19c00015 	stw	r7,0(r3)
 2006868:	19c00115 	stw	r7,4(r3)
 200686c:	19c00215 	stw	r7,8(r3)
 2006870:	19c00315 	stw	r7,12(r3)
 2006874:	423ffc04 	addi	r8,r8,-16
 2006878:	18c00404 	addi	r3,r3,16
 200687c:	223ff936 	bltu	r4,r8,2006864 <memset+0x38>
 2006880:	30fffc04 	addi	r3,r6,-16
 2006884:	1806d13a 	srli	r3,r3,4
 2006888:	318003cc 	andi	r6,r6,15
 200688c:	010000c4 	movi	r4,3
 2006890:	18c00044 	addi	r3,r3,1
 2006894:	1806913a 	slli	r3,r3,4
 2006898:	10c7883a 	add	r3,r2,r3
 200689c:	21800e2e 	bgeu	r4,r6,20068d8 <memset+0xac>
 20068a0:	1813883a 	mov	r9,r3
 20068a4:	3011883a 	mov	r8,r6
 20068a8:	010000c4 	movi	r4,3
 20068ac:	49c00015 	stw	r7,0(r9)
 20068b0:	423fff04 	addi	r8,r8,-4
 20068b4:	4a400104 	addi	r9,r9,4
 20068b8:	223ffc36 	bltu	r4,r8,20068ac <memset+0x80>
 20068bc:	313fff04 	addi	r4,r6,-4
 20068c0:	2008d0ba 	srli	r4,r4,2
 20068c4:	318000cc 	andi	r6,r6,3
 20068c8:	21000044 	addi	r4,r4,1
 20068cc:	2109883a 	add	r4,r4,r4
 20068d0:	2109883a 	add	r4,r4,r4
 20068d4:	1907883a 	add	r3,r3,r4
 20068d8:	30000a26 	beq	r6,zero,2006904 <memset+0xd8>
 20068dc:	198d883a 	add	r6,r3,r6
 20068e0:	19400005 	stb	r5,0(r3)
 20068e4:	18c00044 	addi	r3,r3,1
 20068e8:	19bffd1e 	bne	r3,r6,20068e0 <memset+0xb4>
 20068ec:	f800283a 	ret
 20068f0:	2007883a 	mov	r3,r4
 20068f4:	303ff91e 	bne	r6,zero,20068dc <memset+0xb0>
 20068f8:	00000206 	br	2006904 <memset+0xd8>
 20068fc:	2007883a 	mov	r3,r4
 2006900:	003ff606 	br	20068dc <memset+0xb0>
 2006904:	f800283a 	ret

02006908 <_open_r>:
 2006908:	defffd04 	addi	sp,sp,-12
 200690c:	dc400115 	stw	r17,4(sp)
 2006910:	dc000015 	stw	r16,0(sp)
 2006914:	2023883a 	mov	r17,r4
 2006918:	04008174 	movhi	r16,517
 200691c:	84108b04 	addi	r16,r16,16940
 2006920:	2809883a 	mov	r4,r5
 2006924:	300b883a 	mov	r5,r6
 2006928:	380d883a 	mov	r6,r7
 200692c:	dfc00215 	stw	ra,8(sp)
 2006930:	80000015 	stw	zero,0(r16)
 2006934:	20155d40 	call	20155d4 <open>
 2006938:	00ffffc4 	movi	r3,-1
 200693c:	10c00526 	beq	r2,r3,2006954 <_open_r+0x4c>
 2006940:	dfc00217 	ldw	ra,8(sp)
 2006944:	dc400117 	ldw	r17,4(sp)
 2006948:	dc000017 	ldw	r16,0(sp)
 200694c:	dec00304 	addi	sp,sp,12
 2006950:	f800283a 	ret
 2006954:	80c00017 	ldw	r3,0(r16)
 2006958:	183ff926 	beq	r3,zero,2006940 <_open_r+0x38>
 200695c:	88c00015 	stw	r3,0(r17)
 2006960:	dfc00217 	ldw	ra,8(sp)
 2006964:	dc400117 	ldw	r17,4(sp)
 2006968:	dc000017 	ldw	r16,0(sp)
 200696c:	dec00304 	addi	sp,sp,12
 2006970:	f800283a 	ret

02006974 <_perror_r>:
 2006974:	defffe04 	addi	sp,sp,-8
 2006978:	dc000015 	stw	r16,0(sp)
 200697c:	dfc00115 	stw	ra,4(sp)
 2006980:	2805883a 	mov	r2,r5
 2006984:	2021883a 	mov	r16,r4
 2006988:	28000226 	beq	r5,zero,2006994 <_perror_r+0x20>
 200698c:	28c00007 	ldb	r3,0(r5)
 2006990:	18000c1e 	bne	r3,zero,20069c4 <_perror_r+0x50>
 2006994:	81000017 	ldw	r4,0(r16)
 2006998:	20076000 	call	2007600 <strerror>
 200699c:	10000326 	beq	r2,zero,20069ac <_perror_r+0x38>
 20069a0:	81400317 	ldw	r5,12(r16)
 20069a4:	1009883a 	mov	r4,r2
 20069a8:	200dcf40 	call	200dcf4 <fputs>
 20069ac:	81400317 	ldw	r5,12(r16)
 20069b0:	01000284 	movi	r4,10
 20069b4:	dfc00117 	ldw	ra,4(sp)
 20069b8:	dc000017 	ldw	r16,0(sp)
 20069bc:	dec00204 	addi	sp,sp,8
 20069c0:	200dc201 	jmpi	200dc20 <fputc>
 20069c4:	21400317 	ldw	r5,12(r4)
 20069c8:	1009883a 	mov	r4,r2
 20069cc:	200dcf40 	call	200dcf4 <fputs>
 20069d0:	81400317 	ldw	r5,12(r16)
 20069d4:	01008174 	movhi	r4,517
 20069d8:	21359904 	addi	r4,r4,-10652
 20069dc:	200dcf40 	call	200dcf4 <fputs>
 20069e0:	003fec06 	br	2006994 <_perror_r+0x20>

020069e4 <perror>:
 20069e4:	00808174 	movhi	r2,517
 20069e8:	10903604 	addi	r2,r2,16600
 20069ec:	200b883a 	mov	r5,r4
 20069f0:	11000017 	ldw	r4,0(r2)
 20069f4:	20069741 	jmpi	2006974 <_perror_r>

020069f8 <_printf_r>:
 20069f8:	defffd04 	addi	sp,sp,-12
 20069fc:	dfc00015 	stw	ra,0(sp)
 2006a00:	d9800115 	stw	r6,4(sp)
 2006a04:	d9c00215 	stw	r7,8(sp)
 2006a08:	280d883a 	mov	r6,r5
 2006a0c:	21400217 	ldw	r5,8(r4)
 2006a10:	d9c00104 	addi	r7,sp,4
 2006a14:	2008a300 	call	2008a30 <___vfprintf_internal_r>
 2006a18:	dfc00017 	ldw	ra,0(sp)
 2006a1c:	dec00304 	addi	sp,sp,12
 2006a20:	f800283a 	ret

02006a24 <printf>:
 2006a24:	defffc04 	addi	sp,sp,-16
 2006a28:	dfc00015 	stw	ra,0(sp)
 2006a2c:	d9400115 	stw	r5,4(sp)
 2006a30:	d9800215 	stw	r6,8(sp)
 2006a34:	d9c00315 	stw	r7,12(sp)
 2006a38:	00808174 	movhi	r2,517
 2006a3c:	10903604 	addi	r2,r2,16600
 2006a40:	10800017 	ldw	r2,0(r2)
 2006a44:	200b883a 	mov	r5,r4
 2006a48:	d9800104 	addi	r6,sp,4
 2006a4c:	11000217 	ldw	r4,8(r2)
 2006a50:	200a8280 	call	200a828 <__vfprintf_internal>
 2006a54:	dfc00017 	ldw	ra,0(sp)
 2006a58:	dec00404 	addi	sp,sp,16
 2006a5c:	f800283a 	ret

02006a60 <_putc_r>:
 2006a60:	defffc04 	addi	sp,sp,-16
 2006a64:	dc000215 	stw	r16,8(sp)
 2006a68:	dfc00315 	stw	ra,12(sp)
 2006a6c:	2021883a 	mov	r16,r4
 2006a70:	20000226 	beq	r4,zero,2006a7c <_putc_r+0x1c>
 2006a74:	20800e17 	ldw	r2,56(r4)
 2006a78:	10001d26 	beq	r2,zero,2006af0 <_putc_r+0x90>
 2006a7c:	30800217 	ldw	r2,8(r6)
 2006a80:	10bfffc4 	addi	r2,r2,-1
 2006a84:	30800215 	stw	r2,8(r6)
 2006a88:	10000a16 	blt	r2,zero,2006ab4 <_putc_r+0x54>
 2006a8c:	30800017 	ldw	r2,0(r6)
 2006a90:	11400005 	stb	r5,0(r2)
 2006a94:	30800017 	ldw	r2,0(r6)
 2006a98:	10c00044 	addi	r3,r2,1
 2006a9c:	10800003 	ldbu	r2,0(r2)
 2006aa0:	30c00015 	stw	r3,0(r6)
 2006aa4:	dfc00317 	ldw	ra,12(sp)
 2006aa8:	dc000217 	ldw	r16,8(sp)
 2006aac:	dec00404 	addi	sp,sp,16
 2006ab0:	f800283a 	ret
 2006ab4:	30c00617 	ldw	r3,24(r6)
 2006ab8:	10c01316 	blt	r2,r3,2006b08 <_putc_r+0xa8>
 2006abc:	30800017 	ldw	r2,0(r6)
 2006ac0:	01000284 	movi	r4,10
 2006ac4:	11400005 	stb	r5,0(r2)
 2006ac8:	30c00017 	ldw	r3,0(r6)
 2006acc:	19400003 	ldbu	r5,0(r3)
 2006ad0:	29000d26 	beq	r5,r4,2006b08 <_putc_r+0xa8>
 2006ad4:	18c00044 	addi	r3,r3,1
 2006ad8:	2805883a 	mov	r2,r5
 2006adc:	30c00015 	stw	r3,0(r6)
 2006ae0:	dfc00317 	ldw	ra,12(sp)
 2006ae4:	dc000217 	ldw	r16,8(sp)
 2006ae8:	dec00404 	addi	sp,sp,16
 2006aec:	f800283a 	ret
 2006af0:	d9400015 	stw	r5,0(sp)
 2006af4:	d9800115 	stw	r6,4(sp)
 2006af8:	200492c0 	call	200492c <__sinit>
 2006afc:	d9800117 	ldw	r6,4(sp)
 2006b00:	d9400017 	ldw	r5,0(sp)
 2006b04:	003fdd06 	br	2006a7c <_putc_r+0x1c>
 2006b08:	8009883a 	mov	r4,r16
 2006b0c:	dfc00317 	ldw	ra,12(sp)
 2006b10:	dc000217 	ldw	r16,8(sp)
 2006b14:	dec00404 	addi	sp,sp,16
 2006b18:	200bf841 	jmpi	200bf84 <__swbuf_r>

02006b1c <putc>:
 2006b1c:	defffc04 	addi	sp,sp,-16
 2006b20:	dc400115 	stw	r17,4(sp)
 2006b24:	04408174 	movhi	r17,517
 2006b28:	8c503604 	addi	r17,r17,16600
 2006b2c:	88800017 	ldw	r2,0(r17)
 2006b30:	dc800215 	stw	r18,8(sp)
 2006b34:	dc000015 	stw	r16,0(sp)
 2006b38:	dfc00315 	stw	ra,12(sp)
 2006b3c:	2025883a 	mov	r18,r4
 2006b40:	2821883a 	mov	r16,r5
 2006b44:	10000226 	beq	r2,zero,2006b50 <putc+0x34>
 2006b48:	10c00e17 	ldw	r3,56(r2)
 2006b4c:	18002126 	beq	r3,zero,2006bd4 <putc+0xb8>
 2006b50:	80800217 	ldw	r2,8(r16)
 2006b54:	10bfffc4 	addi	r2,r2,-1
 2006b58:	80800215 	stw	r2,8(r16)
 2006b5c:	10000c16 	blt	r2,zero,2006b90 <putc+0x74>
 2006b60:	80800017 	ldw	r2,0(r16)
 2006b64:	14800005 	stb	r18,0(r2)
 2006b68:	80800017 	ldw	r2,0(r16)
 2006b6c:	10c00044 	addi	r3,r2,1
 2006b70:	10800003 	ldbu	r2,0(r2)
 2006b74:	80c00015 	stw	r3,0(r16)
 2006b78:	dfc00317 	ldw	ra,12(sp)
 2006b7c:	dc800217 	ldw	r18,8(sp)
 2006b80:	dc400117 	ldw	r17,4(sp)
 2006b84:	dc000017 	ldw	r16,0(sp)
 2006b88:	dec00404 	addi	sp,sp,16
 2006b8c:	f800283a 	ret
 2006b90:	80c00617 	ldw	r3,24(r16)
 2006b94:	10c01216 	blt	r2,r3,2006be0 <putc+0xc4>
 2006b98:	80800017 	ldw	r2,0(r16)
 2006b9c:	01000284 	movi	r4,10
 2006ba0:	14800005 	stb	r18,0(r2)
 2006ba4:	80c00017 	ldw	r3,0(r16)
 2006ba8:	19400003 	ldbu	r5,0(r3)
 2006bac:	29001526 	beq	r5,r4,2006c04 <putc+0xe8>
 2006bb0:	18c00044 	addi	r3,r3,1
 2006bb4:	2805883a 	mov	r2,r5
 2006bb8:	80c00015 	stw	r3,0(r16)
 2006bbc:	dfc00317 	ldw	ra,12(sp)
 2006bc0:	dc800217 	ldw	r18,8(sp)
 2006bc4:	dc400117 	ldw	r17,4(sp)
 2006bc8:	dc000017 	ldw	r16,0(sp)
 2006bcc:	dec00404 	addi	sp,sp,16
 2006bd0:	f800283a 	ret
 2006bd4:	1009883a 	mov	r4,r2
 2006bd8:	200492c0 	call	200492c <__sinit>
 2006bdc:	003fdc06 	br	2006b50 <putc+0x34>
 2006be0:	89000017 	ldw	r4,0(r17)
 2006be4:	900b883a 	mov	r5,r18
 2006be8:	800d883a 	mov	r6,r16
 2006bec:	dfc00317 	ldw	ra,12(sp)
 2006bf0:	dc800217 	ldw	r18,8(sp)
 2006bf4:	dc400117 	ldw	r17,4(sp)
 2006bf8:	dc000017 	ldw	r16,0(sp)
 2006bfc:	dec00404 	addi	sp,sp,16
 2006c00:	200bf841 	jmpi	200bf84 <__swbuf_r>
 2006c04:	89000017 	ldw	r4,0(r17)
 2006c08:	003ff706 	br	2006be8 <putc+0xcc>

02006c0c <_putchar_r>:
 2006c0c:	21800217 	ldw	r6,8(r4)
 2006c10:	2006a601 	jmpi	2006a60 <_putc_r>

02006c14 <putchar>:
 2006c14:	00808174 	movhi	r2,517
 2006c18:	10903604 	addi	r2,r2,16600
 2006c1c:	10800017 	ldw	r2,0(r2)
 2006c20:	200b883a 	mov	r5,r4
 2006c24:	11800217 	ldw	r6,8(r2)
 2006c28:	1009883a 	mov	r4,r2
 2006c2c:	2006a601 	jmpi	2006a60 <_putc_r>

02006c30 <_puts_r>:
 2006c30:	defff604 	addi	sp,sp,-40
 2006c34:	dc400815 	stw	r17,32(sp)
 2006c38:	2023883a 	mov	r17,r4
 2006c3c:	2809883a 	mov	r4,r5
 2006c40:	dc000715 	stw	r16,28(sp)
 2006c44:	dfc00915 	stw	ra,36(sp)
 2006c48:	2821883a 	mov	r16,r5
 2006c4c:	2007c640 	call	2007c64 <strlen>
 2006c50:	10c00044 	addi	r3,r2,1
 2006c54:	d8800115 	stw	r2,4(sp)
 2006c58:	89400217 	ldw	r5,8(r17)
 2006c5c:	00808174 	movhi	r2,517
 2006c60:	10b59a04 	addi	r2,r2,-10648
 2006c64:	d8800215 	stw	r2,8(sp)
 2006c68:	00800044 	movi	r2,1
 2006c6c:	d8800315 	stw	r2,12(sp)
 2006c70:	8809883a 	mov	r4,r17
 2006c74:	00800084 	movi	r2,2
 2006c78:	d9800404 	addi	r6,sp,16
 2006c7c:	dc000015 	stw	r16,0(sp)
 2006c80:	d8c00615 	stw	r3,24(sp)
 2006c84:	dec00415 	stw	sp,16(sp)
 2006c88:	d8800515 	stw	r2,20(sp)
 2006c8c:	200dd100 	call	200dd10 <__sfvwrite_r>
 2006c90:	1000061e 	bne	r2,zero,2006cac <_puts_r+0x7c>
 2006c94:	00800284 	movi	r2,10
 2006c98:	dfc00917 	ldw	ra,36(sp)
 2006c9c:	dc400817 	ldw	r17,32(sp)
 2006ca0:	dc000717 	ldw	r16,28(sp)
 2006ca4:	dec00a04 	addi	sp,sp,40
 2006ca8:	f800283a 	ret
 2006cac:	00bfffc4 	movi	r2,-1
 2006cb0:	003ff906 	br	2006c98 <_puts_r+0x68>

02006cb4 <puts>:
 2006cb4:	00808174 	movhi	r2,517
 2006cb8:	10903604 	addi	r2,r2,16600
 2006cbc:	200b883a 	mov	r5,r4
 2006cc0:	11000017 	ldw	r4,0(r2)
 2006cc4:	2006c301 	jmpi	2006c30 <_puts_r>

02006cc8 <lflush>:
 2006cc8:	20c0030b 	ldhu	r3,12(r4)
 2006ccc:	00800244 	movi	r2,9
 2006cd0:	18c0024c 	andi	r3,r3,9
 2006cd4:	18800226 	beq	r3,r2,2006ce0 <lflush+0x18>
 2006cd8:	0005883a 	mov	r2,zero
 2006cdc:	f800283a 	ret
 2006ce0:	20048241 	jmpi	2004824 <fflush>

02006ce4 <__srefill_r>:
 2006ce4:	defffd04 	addi	sp,sp,-12
 2006ce8:	dc400115 	stw	r17,4(sp)
 2006cec:	dc000015 	stw	r16,0(sp)
 2006cf0:	dfc00215 	stw	ra,8(sp)
 2006cf4:	2023883a 	mov	r17,r4
 2006cf8:	2821883a 	mov	r16,r5
 2006cfc:	20000226 	beq	r4,zero,2006d08 <__srefill_r+0x24>
 2006d00:	20800e17 	ldw	r2,56(r4)
 2006d04:	10004426 	beq	r2,zero,2006e18 <__srefill_r+0x134>
 2006d08:	8080030b 	ldhu	r2,12(r16)
 2006d0c:	80000115 	stw	zero,4(r16)
 2006d10:	10c0080c 	andi	r3,r2,32
 2006d14:	18ffffcc 	andi	r3,r3,65535
 2006d18:	18e0001c 	xori	r3,r3,32768
 2006d1c:	18e00004 	addi	r3,r3,-32768
 2006d20:	1800371e 	bne	r3,zero,2006e00 <__srefill_r+0x11c>
 2006d24:	10c0010c 	andi	r3,r2,4
 2006d28:	18ffffcc 	andi	r3,r3,65535
 2006d2c:	18e0001c 	xori	r3,r3,32768
 2006d30:	18e00004 	addi	r3,r3,-32768
 2006d34:	18002226 	beq	r3,zero,2006dc0 <__srefill_r+0xdc>
 2006d38:	81400c17 	ldw	r5,48(r16)
 2006d3c:	28000826 	beq	r5,zero,2006d60 <__srefill_r+0x7c>
 2006d40:	80801004 	addi	r2,r16,64
 2006d44:	28800226 	beq	r5,r2,2006d50 <__srefill_r+0x6c>
 2006d48:	8809883a 	mov	r4,r17
 2006d4c:	20050b40 	call	20050b4 <_free_r>
 2006d50:	80800f17 	ldw	r2,60(r16)
 2006d54:	80000c15 	stw	zero,48(r16)
 2006d58:	80800115 	stw	r2,4(r16)
 2006d5c:	1000401e 	bne	r2,zero,2006e60 <__srefill_r+0x17c>
 2006d60:	80800417 	ldw	r2,16(r16)
 2006d64:	10005026 	beq	r2,zero,2006ea8 <__srefill_r+0x1c4>
 2006d68:	8080030b 	ldhu	r2,12(r16)
 2006d6c:	108000cc 	andi	r2,r2,3
 2006d70:	10002b1e 	bne	r2,zero,2006e20 <__srefill_r+0x13c>
 2006d74:	81800417 	ldw	r6,16(r16)
 2006d78:	80800817 	ldw	r2,32(r16)
 2006d7c:	81400717 	ldw	r5,28(r16)
 2006d80:	81c00517 	ldw	r7,20(r16)
 2006d84:	8809883a 	mov	r4,r17
 2006d88:	81800015 	stw	r6,0(r16)
 2006d8c:	103ee83a 	callr	r2
 2006d90:	8100030b 	ldhu	r4,12(r16)
 2006d94:	00f7ffc4 	movi	r3,-8193
 2006d98:	80800115 	stw	r2,4(r16)
 2006d9c:	20c6703a 	and	r3,r4,r3
 2006da0:	80c0030d 	sth	r3,12(r16)
 2006da4:	0080130e 	bge	zero,r2,2006df4 <__srefill_r+0x110>
 2006da8:	0005883a 	mov	r2,zero
 2006dac:	dfc00217 	ldw	ra,8(sp)
 2006db0:	dc400117 	ldw	r17,4(sp)
 2006db4:	dc000017 	ldw	r16,0(sp)
 2006db8:	dec00304 	addi	sp,sp,12
 2006dbc:	f800283a 	ret
 2006dc0:	10c0040c 	andi	r3,r2,16
 2006dc4:	18ffffcc 	andi	r3,r3,65535
 2006dc8:	18e0001c 	xori	r3,r3,32768
 2006dcc:	18e00004 	addi	r3,r3,-32768
 2006dd0:	18003926 	beq	r3,zero,2006eb8 <__srefill_r+0x1d4>
 2006dd4:	10c0020c 	andi	r3,r2,8
 2006dd8:	18ffffcc 	andi	r3,r3,65535
 2006ddc:	18e0001c 	xori	r3,r3,32768
 2006de0:	18e00004 	addi	r3,r3,-32768
 2006de4:	1800261e 	bne	r3,zero,2006e80 <__srefill_r+0x19c>
 2006de8:	10800114 	ori	r2,r2,4
 2006dec:	8080030d 	sth	r2,12(r16)
 2006df0:	003fdb06 	br	2006d60 <__srefill_r+0x7c>
 2006df4:	1000111e 	bne	r2,zero,2006e3c <__srefill_r+0x158>
 2006df8:	18c00814 	ori	r3,r3,32
 2006dfc:	80c0030d 	sth	r3,12(r16)
 2006e00:	00bfffc4 	movi	r2,-1
 2006e04:	dfc00217 	ldw	ra,8(sp)
 2006e08:	dc400117 	ldw	r17,4(sp)
 2006e0c:	dc000017 	ldw	r16,0(sp)
 2006e10:	dec00304 	addi	sp,sp,12
 2006e14:	f800283a 	ret
 2006e18:	200492c0 	call	200492c <__sinit>
 2006e1c:	003fba06 	br	2006d08 <__srefill_r+0x24>
 2006e20:	00808174 	movhi	r2,517
 2006e24:	10903504 	addi	r2,r2,16596
 2006e28:	11000017 	ldw	r4,0(r2)
 2006e2c:	01408034 	movhi	r5,512
 2006e30:	295b3204 	addi	r5,r5,27848
 2006e34:	20059a80 	call	20059a8 <_fwalk>
 2006e38:	003fce06 	br	2006d74 <__srefill_r+0x90>
 2006e3c:	18c01014 	ori	r3,r3,64
 2006e40:	00bfffc4 	movi	r2,-1
 2006e44:	80000115 	stw	zero,4(r16)
 2006e48:	80c0030d 	sth	r3,12(r16)
 2006e4c:	dfc00217 	ldw	ra,8(sp)
 2006e50:	dc400117 	ldw	r17,4(sp)
 2006e54:	dc000017 	ldw	r16,0(sp)
 2006e58:	dec00304 	addi	sp,sp,12
 2006e5c:	f800283a 	ret
 2006e60:	80c00e17 	ldw	r3,56(r16)
 2006e64:	0005883a 	mov	r2,zero
 2006e68:	80c00015 	stw	r3,0(r16)
 2006e6c:	dfc00217 	ldw	ra,8(sp)
 2006e70:	dc400117 	ldw	r17,4(sp)
 2006e74:	dc000017 	ldw	r16,0(sp)
 2006e78:	dec00304 	addi	sp,sp,12
 2006e7c:	f800283a 	ret
 2006e80:	8809883a 	mov	r4,r17
 2006e84:	800b883a 	mov	r5,r16
 2006e88:	200463c0 	call	200463c <_fflush_r>
 2006e8c:	103fdc1e 	bne	r2,zero,2006e00 <__srefill_r+0x11c>
 2006e90:	8080030b 	ldhu	r2,12(r16)
 2006e94:	00fffdc4 	movi	r3,-9
 2006e98:	80000215 	stw	zero,8(r16)
 2006e9c:	1884703a 	and	r2,r3,r2
 2006ea0:	80000615 	stw	zero,24(r16)
 2006ea4:	003fd006 	br	2006de8 <__srefill_r+0x104>
 2006ea8:	8809883a 	mov	r4,r17
 2006eac:	800b883a 	mov	r5,r16
 2006eb0:	2005ce00 	call	2005ce0 <__smakebuf_r>
 2006eb4:	003fac06 	br	2006d68 <__srefill_r+0x84>
 2006eb8:	00c00244 	movi	r3,9
 2006ebc:	10801014 	ori	r2,r2,64
 2006ec0:	88c00015 	stw	r3,0(r17)
 2006ec4:	8080030d 	sth	r2,12(r16)
 2006ec8:	00bfffc4 	movi	r2,-1
 2006ecc:	003fb706 	br	2006dac <__srefill_r+0xc8>

02006ed0 <__srget_r>:
 2006ed0:	defffe04 	addi	sp,sp,-8
 2006ed4:	dc000015 	stw	r16,0(sp)
 2006ed8:	dfc00115 	stw	ra,4(sp)
 2006edc:	2821883a 	mov	r16,r5
 2006ee0:	2006ce40 	call	2006ce4 <__srefill_r>
 2006ee4:	10000b1e 	bne	r2,zero,2006f14 <__srget_r+0x44>
 2006ee8:	80c00117 	ldw	r3,4(r16)
 2006eec:	80800017 	ldw	r2,0(r16)
 2006ef0:	18ffffc4 	addi	r3,r3,-1
 2006ef4:	80c00115 	stw	r3,4(r16)
 2006ef8:	10c00044 	addi	r3,r2,1
 2006efc:	10800003 	ldbu	r2,0(r2)
 2006f00:	80c00015 	stw	r3,0(r16)
 2006f04:	dfc00117 	ldw	ra,4(sp)
 2006f08:	dc000017 	ldw	r16,0(sp)
 2006f0c:	dec00204 	addi	sp,sp,8
 2006f10:	f800283a 	ret
 2006f14:	00bfffc4 	movi	r2,-1
 2006f18:	003ffa06 	br	2006f04 <__srget_r+0x34>

02006f1c <__srget>:
 2006f1c:	00808174 	movhi	r2,517
 2006f20:	10903604 	addi	r2,r2,16600
 2006f24:	200b883a 	mov	r5,r4
 2006f28:	11000017 	ldw	r4,0(r2)
 2006f2c:	2006ed01 	jmpi	2006ed0 <__srget_r>

02006f30 <_sbrk_r>:
 2006f30:	defffd04 	addi	sp,sp,-12
 2006f34:	dc400115 	stw	r17,4(sp)
 2006f38:	dc000015 	stw	r16,0(sp)
 2006f3c:	2023883a 	mov	r17,r4
 2006f40:	04008174 	movhi	r16,517
 2006f44:	84108b04 	addi	r16,r16,16940
 2006f48:	2809883a 	mov	r4,r5
 2006f4c:	dfc00215 	stw	ra,8(sp)
 2006f50:	80000015 	stw	zero,0(r16)
 2006f54:	20157880 	call	2015788 <sbrk>
 2006f58:	00ffffc4 	movi	r3,-1
 2006f5c:	10c00526 	beq	r2,r3,2006f74 <_sbrk_r+0x44>
 2006f60:	dfc00217 	ldw	ra,8(sp)
 2006f64:	dc400117 	ldw	r17,4(sp)
 2006f68:	dc000017 	ldw	r16,0(sp)
 2006f6c:	dec00304 	addi	sp,sp,12
 2006f70:	f800283a 	ret
 2006f74:	80c00017 	ldw	r3,0(r16)
 2006f78:	183ff926 	beq	r3,zero,2006f60 <_sbrk_r+0x30>
 2006f7c:	88c00015 	stw	r3,0(r17)
 2006f80:	dfc00217 	ldw	ra,8(sp)
 2006f84:	dc400117 	ldw	r17,4(sp)
 2006f88:	dc000017 	ldw	r16,0(sp)
 2006f8c:	dec00304 	addi	sp,sp,12
 2006f90:	f800283a 	ret

02006f94 <_sprintf_r>:
 2006f94:	deffe704 	addi	sp,sp,-100
 2006f98:	2807883a 	mov	r3,r5
 2006f9c:	dfc01715 	stw	ra,92(sp)
 2006fa0:	d9c01815 	stw	r7,96(sp)
 2006fa4:	00a00034 	movhi	r2,32768
 2006fa8:	10bfffc4 	addi	r2,r2,-1
 2006fac:	02008204 	movi	r8,520
 2006fb0:	d8800215 	stw	r2,8(sp)
 2006fb4:	d8800515 	stw	r2,20(sp)
 2006fb8:	d80b883a 	mov	r5,sp
 2006fbc:	d9c01804 	addi	r7,sp,96
 2006fc0:	00bfffc4 	movi	r2,-1
 2006fc4:	d8c00015 	stw	r3,0(sp)
 2006fc8:	d8c00415 	stw	r3,16(sp)
 2006fcc:	da00030d 	sth	r8,12(sp)
 2006fd0:	d880038d 	sth	r2,14(sp)
 2006fd4:	2008a300 	call	2008a30 <___vfprintf_internal_r>
 2006fd8:	d8c00017 	ldw	r3,0(sp)
 2006fdc:	18000005 	stb	zero,0(r3)
 2006fe0:	dfc01717 	ldw	ra,92(sp)
 2006fe4:	dec01904 	addi	sp,sp,100
 2006fe8:	f800283a 	ret

02006fec <sprintf>:
 2006fec:	deffe604 	addi	sp,sp,-104
 2006ff0:	2007883a 	mov	r3,r4
 2006ff4:	dfc01715 	stw	ra,92(sp)
 2006ff8:	d9801815 	stw	r6,96(sp)
 2006ffc:	d9c01915 	stw	r7,100(sp)
 2007000:	00808174 	movhi	r2,517
 2007004:	10903604 	addi	r2,r2,16600
 2007008:	11000017 	ldw	r4,0(r2)
 200700c:	00a00034 	movhi	r2,32768
 2007010:	10bfffc4 	addi	r2,r2,-1
 2007014:	280d883a 	mov	r6,r5
 2007018:	02008204 	movi	r8,520
 200701c:	d8800215 	stw	r2,8(sp)
 2007020:	d8800515 	stw	r2,20(sp)
 2007024:	d80b883a 	mov	r5,sp
 2007028:	d9c01804 	addi	r7,sp,96
 200702c:	00bfffc4 	movi	r2,-1
 2007030:	d8c00015 	stw	r3,0(sp)
 2007034:	d8c00415 	stw	r3,16(sp)
 2007038:	da00030d 	sth	r8,12(sp)
 200703c:	d880038d 	sth	r2,14(sp)
 2007040:	2008a300 	call	2008a30 <___vfprintf_internal_r>
 2007044:	d8c00017 	ldw	r3,0(sp)
 2007048:	18000005 	stb	zero,0(r3)
 200704c:	dfc01717 	ldw	ra,92(sp)
 2007050:	dec01a04 	addi	sp,sp,104
 2007054:	f800283a 	ret

02007058 <eofread>:
 2007058:	0005883a 	mov	r2,zero
 200705c:	f800283a 	ret

02007060 <sscanf>:
 2007060:	deffe504 	addi	sp,sp,-108
 2007064:	dfc01815 	stw	ra,96(sp)
 2007068:	dc001715 	stw	r16,92(sp)
 200706c:	d9801915 	stw	r6,100(sp)
 2007070:	d9c01a15 	stw	r7,104(sp)
 2007074:	00c08104 	movi	r3,516
 2007078:	2821883a 	mov	r16,r5
 200707c:	d8c0030d 	sth	r3,12(sp)
 2007080:	d9000015 	stw	r4,0(sp)
 2007084:	d9000415 	stw	r4,16(sp)
 2007088:	2007c640 	call	2007c64 <strlen>
 200708c:	00c08174 	movhi	r3,517
 2007090:	18d03604 	addi	r3,r3,16600
 2007094:	19000017 	ldw	r4,0(r3)
 2007098:	d8800115 	stw	r2,4(sp)
 200709c:	d8800515 	stw	r2,20(sp)
 20070a0:	00808034 	movhi	r2,512
 20070a4:	109c1604 	addi	r2,r2,28760
 20070a8:	d8800815 	stw	r2,32(sp)
 20070ac:	d80b883a 	mov	r5,sp
 20070b0:	800d883a 	mov	r6,r16
 20070b4:	d9c01904 	addi	r7,sp,100
 20070b8:	00bfffc4 	movi	r2,-1
 20070bc:	d8000c15 	stw	zero,48(sp)
 20070c0:	d8001115 	stw	zero,68(sp)
 20070c4:	d880038d 	sth	r2,14(sp)
 20070c8:	200a84c0 	call	200a84c <__svfscanf_r>
 20070cc:	dfc01817 	ldw	ra,96(sp)
 20070d0:	dc001717 	ldw	r16,92(sp)
 20070d4:	dec01b04 	addi	sp,sp,108
 20070d8:	f800283a 	ret

020070dc <_sscanf_r>:
 20070dc:	deffe504 	addi	sp,sp,-108
 20070e0:	dc001815 	stw	r16,96(sp)
 20070e4:	2021883a 	mov	r16,r4
 20070e8:	dfc01915 	stw	ra,100(sp)
 20070ec:	d9c01a15 	stw	r7,104(sp)
 20070f0:	00808104 	movi	r2,516
 20070f4:	2809883a 	mov	r4,r5
 20070f8:	d9400015 	stw	r5,0(sp)
 20070fc:	d9400415 	stw	r5,16(sp)
 2007100:	d9801715 	stw	r6,92(sp)
 2007104:	d880030d 	sth	r2,12(sp)
 2007108:	2007c640 	call	2007c64 <strlen>
 200710c:	d9801717 	ldw	r6,92(sp)
 2007110:	d8800115 	stw	r2,4(sp)
 2007114:	d8800515 	stw	r2,20(sp)
 2007118:	00808034 	movhi	r2,512
 200711c:	109c1604 	addi	r2,r2,28760
 2007120:	d8800815 	stw	r2,32(sp)
 2007124:	8009883a 	mov	r4,r16
 2007128:	d80b883a 	mov	r5,sp
 200712c:	d9c01a04 	addi	r7,sp,104
 2007130:	00bfffc4 	movi	r2,-1
 2007134:	d8000c15 	stw	zero,48(sp)
 2007138:	d8001115 	stw	zero,68(sp)
 200713c:	d880038d 	sth	r2,14(sp)
 2007140:	200a84c0 	call	200a84c <__svfscanf_r>
 2007144:	dfc01917 	ldw	ra,100(sp)
 2007148:	dc001817 	ldw	r16,96(sp)
 200714c:	dec01b04 	addi	sp,sp,108
 2007150:	f800283a 	ret

02007154 <__sread>:
 2007154:	defffe04 	addi	sp,sp,-8
 2007158:	dc000015 	stw	r16,0(sp)
 200715c:	2821883a 	mov	r16,r5
 2007160:	2940038f 	ldh	r5,14(r5)
 2007164:	dfc00115 	stw	ra,4(sp)
 2007168:	200f5dc0 	call	200f5dc <_read_r>
 200716c:	10000716 	blt	r2,zero,200718c <__sread+0x38>
 2007170:	80c01417 	ldw	r3,80(r16)
 2007174:	1887883a 	add	r3,r3,r2
 2007178:	80c01415 	stw	r3,80(r16)
 200717c:	dfc00117 	ldw	ra,4(sp)
 2007180:	dc000017 	ldw	r16,0(sp)
 2007184:	dec00204 	addi	sp,sp,8
 2007188:	f800283a 	ret
 200718c:	80c0030b 	ldhu	r3,12(r16)
 2007190:	18fbffcc 	andi	r3,r3,61439
 2007194:	80c0030d 	sth	r3,12(r16)
 2007198:	dfc00117 	ldw	ra,4(sp)
 200719c:	dc000017 	ldw	r16,0(sp)
 20071a0:	dec00204 	addi	sp,sp,8
 20071a4:	f800283a 	ret

020071a8 <__swrite>:
 20071a8:	2880030b 	ldhu	r2,12(r5)
 20071ac:	defffb04 	addi	sp,sp,-20
 20071b0:	dcc00315 	stw	r19,12(sp)
 20071b4:	10c0400c 	andi	r3,r2,256
 20071b8:	18ffffcc 	andi	r3,r3,65535
 20071bc:	18e0001c 	xori	r3,r3,32768
 20071c0:	dc800215 	stw	r18,8(sp)
 20071c4:	dc400115 	stw	r17,4(sp)
 20071c8:	dc000015 	stw	r16,0(sp)
 20071cc:	dfc00415 	stw	ra,16(sp)
 20071d0:	18e00004 	addi	r3,r3,-32768
 20071d4:	2821883a 	mov	r16,r5
 20071d8:	2027883a 	mov	r19,r4
 20071dc:	3025883a 	mov	r18,r6
 20071e0:	3823883a 	mov	r17,r7
 20071e4:	18000526 	beq	r3,zero,20071fc <__swrite+0x54>
 20071e8:	2940038f 	ldh	r5,14(r5)
 20071ec:	000d883a 	mov	r6,zero
 20071f0:	01c00084 	movi	r7,2
 20071f4:	200e36c0 	call	200e36c <_lseek_r>
 20071f8:	8080030b 	ldhu	r2,12(r16)
 20071fc:	8140038f 	ldh	r5,14(r16)
 2007200:	10bbffcc 	andi	r2,r2,61439
 2007204:	9809883a 	mov	r4,r19
 2007208:	900d883a 	mov	r6,r18
 200720c:	880f883a 	mov	r7,r17
 2007210:	8080030d 	sth	r2,12(r16)
 2007214:	dfc00417 	ldw	ra,16(sp)
 2007218:	dcc00317 	ldw	r19,12(sp)
 200721c:	dc800217 	ldw	r18,8(sp)
 2007220:	dc400117 	ldw	r17,4(sp)
 2007224:	dc000017 	ldw	r16,0(sp)
 2007228:	dec00504 	addi	sp,sp,20
 200722c:	200c0dc1 	jmpi	200c0dc <_write_r>

02007230 <__sseek>:
 2007230:	defffe04 	addi	sp,sp,-8
 2007234:	dc000015 	stw	r16,0(sp)
 2007238:	2821883a 	mov	r16,r5
 200723c:	2940038f 	ldh	r5,14(r5)
 2007240:	dfc00115 	stw	ra,4(sp)
 2007244:	200e36c0 	call	200e36c <_lseek_r>
 2007248:	00ffffc4 	movi	r3,-1
 200724c:	10c00826 	beq	r2,r3,2007270 <__sseek+0x40>
 2007250:	80c0030b 	ldhu	r3,12(r16)
 2007254:	80801415 	stw	r2,80(r16)
 2007258:	18c40014 	ori	r3,r3,4096
 200725c:	80c0030d 	sth	r3,12(r16)
 2007260:	dfc00117 	ldw	ra,4(sp)
 2007264:	dc000017 	ldw	r16,0(sp)
 2007268:	dec00204 	addi	sp,sp,8
 200726c:	f800283a 	ret
 2007270:	80c0030b 	ldhu	r3,12(r16)
 2007274:	18fbffcc 	andi	r3,r3,61439
 2007278:	80c0030d 	sth	r3,12(r16)
 200727c:	dfc00117 	ldw	ra,4(sp)
 2007280:	dc000017 	ldw	r16,0(sp)
 2007284:	dec00204 	addi	sp,sp,8
 2007288:	f800283a 	ret

0200728c <__sclose>:
 200728c:	2940038f 	ldh	r5,14(r5)
 2007290:	200c2bc1 	jmpi	200c2bc <_close_r>

02007294 <strcasecmp>:
 2007294:	21c00003 	ldbu	r7,0(r4)
 2007298:	00808174 	movhi	r2,517
 200729c:	10903404 	addi	r2,r2,16592
 20072a0:	11800017 	ldw	r6,0(r2)
 20072a4:	38c03fcc 	andi	r3,r7,255
 20072a8:	18c0201c 	xori	r3,r3,128
 20072ac:	18ffe004 	addi	r3,r3,-128
 20072b0:	18001326 	beq	r3,zero,2007300 <strcasecmp+0x6c>
 20072b4:	30c5883a 	add	r2,r6,r3
 20072b8:	10800003 	ldbu	r2,0(r2)
 20072bc:	21000044 	addi	r4,r4,1
 20072c0:	1080004c 	andi	r2,r2,1
 20072c4:	10000126 	beq	r2,zero,20072cc <strcasecmp+0x38>
 20072c8:	18c00804 	addi	r3,r3,32
 20072cc:	28800007 	ldb	r2,0(r5)
 20072d0:	3091883a 	add	r8,r6,r2
 20072d4:	42000003 	ldbu	r8,0(r8)
 20072d8:	4200004c 	andi	r8,r8,1
 20072dc:	40000126 	beq	r8,zero,20072e4 <strcasecmp+0x50>
 20072e0:	10800804 	addi	r2,r2,32
 20072e4:	1880151e 	bne	r3,r2,200733c <strcasecmp+0xa8>
 20072e8:	21c00003 	ldbu	r7,0(r4)
 20072ec:	29400044 	addi	r5,r5,1
 20072f0:	38c03fcc 	andi	r3,r7,255
 20072f4:	18c0201c 	xori	r3,r3,128
 20072f8:	18ffe004 	addi	r3,r3,-128
 20072fc:	183fed1e 	bne	r3,zero,20072b4 <strcasecmp+0x20>
 2007300:	0005883a 	mov	r2,zero
 2007304:	000f883a 	mov	r7,zero
 2007308:	3085883a 	add	r2,r6,r2
 200730c:	10800003 	ldbu	r2,0(r2)
 2007310:	1080004c 	andi	r2,r2,1
 2007314:	10000126 	beq	r2,zero,200731c <strcasecmp+0x88>
 2007318:	39c00804 	addi	r7,r7,32
 200731c:	28800003 	ldbu	r2,0(r5)
 2007320:	308d883a 	add	r6,r6,r2
 2007324:	30c00003 	ldbu	r3,0(r6)
 2007328:	18c0004c 	andi	r3,r3,1
 200732c:	18000126 	beq	r3,zero,2007334 <strcasecmp+0xa0>
 2007330:	10800804 	addi	r2,r2,32
 2007334:	3885c83a 	sub	r2,r7,r2
 2007338:	f800283a 	ret
 200733c:	39c03fcc 	andi	r7,r7,255
 2007340:	3805883a 	mov	r2,r7
 2007344:	003ff006 	br	2007308 <strcasecmp+0x74>

02007348 <strcat>:
 2007348:	defffe04 	addi	sp,sp,-8
 200734c:	dc000015 	stw	r16,0(sp)
 2007350:	dfc00115 	stw	ra,4(sp)
 2007354:	208000cc 	andi	r2,r4,3
 2007358:	2021883a 	mov	r16,r4
 200735c:	1000141e 	bne	r2,zero,20073b0 <strcat+0x68>
 2007360:	20800017 	ldw	r2,0(r4)
 2007364:	027fbff4 	movhi	r9,65279
 2007368:	4a7fbfc4 	addi	r9,r9,-257
 200736c:	02202074 	movhi	r8,32897
 2007370:	42202004 	addi	r8,r8,-32640
 2007374:	1247883a 	add	r3,r2,r9
 2007378:	0084303a 	nor	r2,zero,r2
 200737c:	1884703a 	and	r2,r3,r2
 2007380:	1204703a 	and	r2,r2,r8
 2007384:	2007883a 	mov	r3,r4
 2007388:	1000091e 	bne	r2,zero,20073b0 <strcat+0x68>
 200738c:	18c00104 	addi	r3,r3,4
 2007390:	19800017 	ldw	r6,0(r3)
 2007394:	324f883a 	add	r7,r6,r9
 2007398:	018c303a 	nor	r6,zero,r6
 200739c:	398c703a 	and	r6,r7,r6
 20073a0:	320c703a 	and	r6,r6,r8
 20073a4:	303ff926 	beq	r6,zero,200738c <strcat+0x44>
 20073a8:	1809883a 	mov	r4,r3
 20073ac:	00000106 	br	20073b4 <strcat+0x6c>
 20073b0:	8009883a 	mov	r4,r16
 20073b4:	20800007 	ldb	r2,0(r4)
 20073b8:	10000326 	beq	r2,zero,20073c8 <strcat+0x80>
 20073bc:	21000044 	addi	r4,r4,1
 20073c0:	20c00007 	ldb	r3,0(r4)
 20073c4:	183ffd1e 	bne	r3,zero,20073bc <strcat+0x74>
 20073c8:	200756c0 	call	200756c <strcpy>
 20073cc:	8005883a 	mov	r2,r16
 20073d0:	dfc00117 	ldw	ra,4(sp)
 20073d4:	dc000017 	ldw	r16,0(sp)
 20073d8:	dec00204 	addi	sp,sp,8
 20073dc:	f800283a 	ret

020073e0 <strchr>:
 20073e0:	208000cc 	andi	r2,r4,3
 20073e4:	2815883a 	mov	r10,r5
 20073e8:	10000c26 	beq	r2,zero,200741c <strchr+0x3c>
 20073ec:	2005883a 	mov	r2,r4
 20073f0:	10c00003 	ldbu	r3,0(r2)
 20073f4:	51003fcc 	andi	r4,r10,255
 20073f8:	18000626 	beq	r3,zero,2007414 <strchr+0x34>
 20073fc:	20c0021e 	bne	r4,r3,2007408 <strchr+0x28>
 2007400:	00003006 	br	20074c4 <strchr+0xe4>
 2007404:	20c02e26 	beq	r4,r3,20074c0 <strchr+0xe0>
 2007408:	10800044 	addi	r2,r2,1
 200740c:	10c00003 	ldbu	r3,0(r2)
 2007410:	183ffc1e 	bne	r3,zero,2007404 <strchr+0x24>
 2007414:	2000281e 	bne	r4,zero,20074b8 <strchr+0xd8>
 2007418:	f800283a 	ret
 200741c:	29403fcc 	andi	r5,r5,255
 2007420:	2810923a 	slli	r8,r5,8
 2007424:	20800017 	ldw	r2,0(r4)
 2007428:	01ffbff4 	movhi	r7,65279
 200742c:	39ffbfc4 	addi	r7,r7,-257
 2007430:	4150b03a 	or	r8,r8,r5
 2007434:	4010923a 	slli	r8,r8,8
 2007438:	11cd883a 	add	r6,r2,r7
 200743c:	0086303a 	nor	r3,zero,r2
 2007440:	4150b03a 	or	r8,r8,r5
 2007444:	4010923a 	slli	r8,r8,8
 2007448:	30c6703a 	and	r3,r6,r3
 200744c:	01a02074 	movhi	r6,32897
 2007450:	31a02004 	addi	r6,r6,-32640
 2007454:	1986703a 	and	r3,r3,r6
 2007458:	414ab03a 	or	r5,r8,r5
 200745c:	183fe31e 	bne	r3,zero,20073ec <strchr+0xc>
 2007460:	2884f03a 	xor	r2,r5,r2
 2007464:	11c7883a 	add	r3,r2,r7
 2007468:	0084303a 	nor	r2,zero,r2
 200746c:	1884703a 	and	r2,r3,r2
 2007470:	1184703a 	and	r2,r2,r6
 2007474:	103fdd1e 	bne	r2,zero,20073ec <strchr+0xc>
 2007478:	2005883a 	mov	r2,r4
 200747c:	00000106 	br	2007484 <strchr+0xa4>
 2007480:	203fdb1e 	bne	r4,zero,20073f0 <strchr+0x10>
 2007484:	10800104 	addi	r2,r2,4
 2007488:	10c00017 	ldw	r3,0(r2)
 200748c:	28c8f03a 	xor	r4,r5,r3
 2007490:	19d3883a 	add	r9,r3,r7
 2007494:	00c6303a 	nor	r3,zero,r3
 2007498:	21d1883a 	add	r8,r4,r7
 200749c:	48c6703a 	and	r3,r9,r3
 20074a0:	0108303a 	nor	r4,zero,r4
 20074a4:	4108703a 	and	r4,r8,r4
 20074a8:	1986703a 	and	r3,r3,r6
 20074ac:	2188703a 	and	r4,r4,r6
 20074b0:	183ff326 	beq	r3,zero,2007480 <strchr+0xa0>
 20074b4:	003fce06 	br	20073f0 <strchr+0x10>
 20074b8:	0005883a 	mov	r2,zero
 20074bc:	f800283a 	ret
 20074c0:	f800283a 	ret
 20074c4:	f800283a 	ret

020074c8 <strcmp>:
 20074c8:	2904b03a 	or	r2,r5,r4
 20074cc:	108000cc 	andi	r2,r2,3
 20074d0:	1000171e 	bne	r2,zero,2007530 <strcmp+0x68>
 20074d4:	20800017 	ldw	r2,0(r4)
 20074d8:	28c00017 	ldw	r3,0(r5)
 20074dc:	10c0141e 	bne	r2,r3,2007530 <strcmp+0x68>
 20074e0:	027fbff4 	movhi	r9,65279
 20074e4:	4a7fbfc4 	addi	r9,r9,-257
 20074e8:	1247883a 	add	r3,r2,r9
 20074ec:	0084303a 	nor	r2,zero,r2
 20074f0:	1884703a 	and	r2,r3,r2
 20074f4:	02202074 	movhi	r8,32897
 20074f8:	42202004 	addi	r8,r8,-32640
 20074fc:	1204703a 	and	r2,r2,r8
 2007500:	10000226 	beq	r2,zero,200750c <strcmp+0x44>
 2007504:	00001706 	br	2007564 <strcmp+0x9c>
 2007508:	3000161e 	bne	r6,zero,2007564 <strcmp+0x9c>
 200750c:	21000104 	addi	r4,r4,4
 2007510:	20800017 	ldw	r2,0(r4)
 2007514:	29400104 	addi	r5,r5,4
 2007518:	28c00017 	ldw	r3,0(r5)
 200751c:	124f883a 	add	r7,r2,r9
 2007520:	008c303a 	nor	r6,zero,r2
 2007524:	398c703a 	and	r6,r7,r6
 2007528:	320c703a 	and	r6,r6,r8
 200752c:	10fff626 	beq	r2,r3,2007508 <strcmp+0x40>
 2007530:	20800007 	ldb	r2,0(r4)
 2007534:	1000051e 	bne	r2,zero,200754c <strcmp+0x84>
 2007538:	00000606 	br	2007554 <strcmp+0x8c>
 200753c:	21000044 	addi	r4,r4,1
 2007540:	20800007 	ldb	r2,0(r4)
 2007544:	29400044 	addi	r5,r5,1
 2007548:	10000226 	beq	r2,zero,2007554 <strcmp+0x8c>
 200754c:	28c00007 	ldb	r3,0(r5)
 2007550:	10fffa26 	beq	r2,r3,200753c <strcmp+0x74>
 2007554:	20c00003 	ldbu	r3,0(r4)
 2007558:	28800003 	ldbu	r2,0(r5)
 200755c:	1885c83a 	sub	r2,r3,r2
 2007560:	f800283a 	ret
 2007564:	0005883a 	mov	r2,zero
 2007568:	f800283a 	ret

0200756c <strcpy>:
 200756c:	2906b03a 	or	r3,r5,r4
 2007570:	18c000cc 	andi	r3,r3,3
 2007574:	2005883a 	mov	r2,r4
 2007578:	18001a1e 	bne	r3,zero,20075e4 <strcpy+0x78>
 200757c:	29800017 	ldw	r6,0(r5)
 2007580:	02bfbff4 	movhi	r10,65279
 2007584:	52bfbfc4 	addi	r10,r10,-257
 2007588:	02602074 	movhi	r9,32897
 200758c:	4a602004 	addi	r9,r9,-32640
 2007590:	0188303a 	nor	r4,zero,r6
 2007594:	3287883a 	add	r3,r6,r10
 2007598:	20c6703a 	and	r3,r4,r3
 200759c:	1a46703a 	and	r3,r3,r9
 20075a0:	1800101e 	bne	r3,zero,20075e4 <strcpy+0x78>
 20075a4:	1007883a 	mov	r3,r2
 20075a8:	19800015 	stw	r6,0(r3)
 20075ac:	29400104 	addi	r5,r5,4
 20075b0:	29800017 	ldw	r6,0(r5)
 20075b4:	18c00104 	addi	r3,r3,4
 20075b8:	0190303a 	nor	r8,zero,r6
 20075bc:	328f883a 	add	r7,r6,r10
 20075c0:	41ce703a 	and	r7,r8,r7
 20075c4:	3a4e703a 	and	r7,r7,r9
 20075c8:	383ff726 	beq	r7,zero,20075a8 <strcpy+0x3c>
 20075cc:	29800007 	ldb	r6,0(r5)
 20075d0:	18c00044 	addi	r3,r3,1
 20075d4:	29400044 	addi	r5,r5,1
 20075d8:	19bfffc5 	stb	r6,-1(r3)
 20075dc:	3000021e 	bne	r6,zero,20075e8 <strcpy+0x7c>
 20075e0:	f800283a 	ret
 20075e4:	1007883a 	mov	r3,r2
 20075e8:	29800007 	ldb	r6,0(r5)
 20075ec:	18c00044 	addi	r3,r3,1
 20075f0:	29400044 	addi	r5,r5,1
 20075f4:	19bfffc5 	stb	r6,-1(r3)
 20075f8:	303ffb1e 	bne	r6,zero,20075e8 <strcpy+0x7c>
 20075fc:	f800283a 	ret

02007600 <strerror>:
 2007600:	deffff04 	addi	sp,sp,-4
 2007604:	dfc00015 	stw	ra,0(sp)
 2007608:	00802184 	movi	r2,134
 200760c:	1100052e 	bgeu	r2,r4,2007624 <strerror+0x24>
 2007610:	20089f40 	call	20089f4 <_user_strerror>
 2007614:	10019026 	beq	r2,zero,2007c58 <strerror+0x658>
 2007618:	dfc00017 	ldw	ra,0(sp)
 200761c:	dec00104 	addi	sp,sp,4
 2007620:	f800283a 	ret
 2007624:	2105883a 	add	r2,r4,r4
 2007628:	1085883a 	add	r2,r2,r2
 200762c:	00c08034 	movhi	r3,512
 2007630:	18dd9004 	addi	r3,r3,30272
 2007634:	10c5883a 	add	r2,r2,r3
 2007638:	10800017 	ldw	r2,0(r2)
 200763c:	1000683a 	jmp	r2
 2007640:	02007610 	cmplti	r8,zero,472
 2007644:	02007c4c 	andi	r8,zero,497
 2007648:	02007c40 	call	2007c4 <__alt_mem_descriptor_memory+0x1febc4>
 200764c:	02007c34 	movhi	r8,496
 2007650:	02007c28 	cmpgeui	r8,zero,496
 2007654:	02007c1c 	xori	r8,zero,496
 2007658:	02007c10 	cmplti	r8,zero,496
 200765c:	02007c04 	movi	r8,496
 2007660:	02007bf8 	rdprs	r8,zero,495
 2007664:	02007bec 	andhi	r8,zero,495
 2007668:	02007be0 	cmpeqi	r8,zero,495
 200766c:	02007bd4 	movui	r8,495
 2007670:	02007bc8 	cmpgei	r8,zero,495
 2007674:	02007bbc 	xorhi	r8,zero,494
 2007678:	02007bb0 	cmpltui	r8,zero,494
 200767c:	02007ba4 	muli	r8,zero,494
 2007680:	02007b98 	cmpnei	r8,zero,494
 2007684:	02007b8c 	andi	r8,zero,494
 2007688:	02007b80 	call	2007b8 <__alt_mem_descriptor_memory+0x1febb8>
 200768c:	02007b74 	movhi	r8,493
 2007690:	02007b68 	cmpgeui	r8,zero,493
 2007694:	02007b5c 	xori	r8,zero,493
 2007698:	02007b50 	cmplti	r8,zero,493
 200769c:	02007b44 	movi	r8,493
 20076a0:	02007b38 	rdprs	r8,zero,492
 20076a4:	02007b2c 	andhi	r8,zero,492
 20076a8:	02007b20 	cmpeqi	r8,zero,492
 20076ac:	02007b14 	movui	r8,492
 20076b0:	02007b08 	cmpgei	r8,zero,492
 20076b4:	02007afc 	xorhi	r8,zero,491
 20076b8:	02007af0 	cmpltui	r8,zero,491
 20076bc:	02007ae4 	muli	r8,zero,491
 20076c0:	02007ad8 	cmpnei	r8,zero,491
 20076c4:	02007acc 	andi	r8,zero,491
 20076c8:	02007ac0 	call	2007ac <__alt_mem_descriptor_memory+0x1febac>
 20076cc:	02007ab4 	movhi	r8,490
 20076d0:	02007aa8 	cmpgeui	r8,zero,490
 20076d4:	02007610 	cmplti	r8,zero,472
 20076d8:	02007610 	cmplti	r8,zero,472
 20076dc:	02007610 	cmplti	r8,zero,472
 20076e0:	02007610 	cmplti	r8,zero,472
 20076e4:	02007610 	cmplti	r8,zero,472
 20076e8:	02007610 	cmplti	r8,zero,472
 20076ec:	02007610 	cmplti	r8,zero,472
 20076f0:	02007610 	cmplti	r8,zero,472
 20076f4:	02007a9c 	xori	r8,zero,490
 20076f8:	02007a90 	cmplti	r8,zero,490
 20076fc:	02007610 	cmplti	r8,zero,472
 2007700:	02007610 	cmplti	r8,zero,472
 2007704:	02007610 	cmplti	r8,zero,472
 2007708:	02007610 	cmplti	r8,zero,472
 200770c:	02007610 	cmplti	r8,zero,472
 2007710:	02007610 	cmplti	r8,zero,472
 2007714:	02007610 	cmplti	r8,zero,472
 2007718:	02007610 	cmplti	r8,zero,472
 200771c:	02007610 	cmplti	r8,zero,472
 2007720:	02007610 	cmplti	r8,zero,472
 2007724:	02007610 	cmplti	r8,zero,472
 2007728:	02007610 	cmplti	r8,zero,472
 200772c:	02007610 	cmplti	r8,zero,472
 2007730:	02007a84 	movi	r8,490
 2007734:	02007610 	cmplti	r8,zero,472
 2007738:	02007a78 	rdprs	r8,zero,489
 200773c:	02007a6c 	andhi	r8,zero,489
 2007740:	02007a60 	cmpeqi	r8,zero,489
 2007744:	02007a54 	movui	r8,489
 2007748:	02007a48 	cmpgei	r8,zero,489
 200774c:	02007a3c 	xorhi	r8,zero,488
 2007750:	02007a30 	cmpltui	r8,zero,488
 2007754:	02007a24 	muli	r8,zero,488
 2007758:	02007a18 	cmpnei	r8,zero,488
 200775c:	02007a0c 	andi	r8,zero,488
 2007760:	02007610 	cmplti	r8,zero,472
 2007764:	02007610 	cmplti	r8,zero,472
 2007768:	02007a00 	call	2007a0 <__alt_mem_descriptor_memory+0x1feba0>
 200776c:	02007610 	cmplti	r8,zero,472
 2007770:	02007610 	cmplti	r8,zero,472
 2007774:	020079f4 	movhi	r8,487
 2007778:	02007610 	cmplti	r8,zero,472
 200777c:	02007610 	cmplti	r8,zero,472
 2007780:	02007610 	cmplti	r8,zero,472
 2007784:	02007610 	cmplti	r8,zero,472
 2007788:	02007610 	cmplti	r8,zero,472
 200778c:	020079e8 	cmpgeui	r8,zero,487
 2007790:	020079dc 	xori	r8,zero,487
 2007794:	020079d0 	cmplti	r8,zero,487
 2007798:	020079c4 	movi	r8,487
 200779c:	020079b8 	rdprs	r8,zero,486
 20077a0:	020079ac 	andhi	r8,zero,486
 20077a4:	020079a0 	cmpeqi	r8,zero,486
 20077a8:	02007994 	movui	r8,486
 20077ac:	02007988 	cmpgei	r8,zero,486
 20077b0:	0200797c 	xorhi	r8,zero,485
 20077b4:	02007610 	cmplti	r8,zero,472
 20077b8:	02007610 	cmplti	r8,zero,472
 20077bc:	02007970 	cmpltui	r8,zero,485
 20077c0:	02007610 	cmplti	r8,zero,472
 20077c4:	02007610 	cmplti	r8,zero,472
 20077c8:	02007610 	cmplti	r8,zero,472
 20077cc:	02007610 	cmplti	r8,zero,472
 20077d0:	02007610 	cmplti	r8,zero,472
 20077d4:	02007610 	cmplti	r8,zero,472
 20077d8:	02007610 	cmplti	r8,zero,472
 20077dc:	02007610 	cmplti	r8,zero,472
 20077e0:	02007610 	cmplti	r8,zero,472
 20077e4:	02007964 	muli	r8,zero,485
 20077e8:	02007958 	cmpnei	r8,zero,485
 20077ec:	0200794c 	andi	r8,zero,485
 20077f0:	02007940 	call	200794 <__alt_mem_descriptor_memory+0x1feb94>
 20077f4:	02007934 	movhi	r8,484
 20077f8:	02007928 	cmpgeui	r8,zero,484
 20077fc:	0200791c 	xori	r8,zero,484
 2007800:	02007910 	cmplti	r8,zero,484
 2007804:	02007904 	movi	r8,484
 2007808:	020078f8 	rdprs	r8,zero,483
 200780c:	020078ec 	andhi	r8,zero,483
 2007810:	020078e0 	cmpeqi	r8,zero,483
 2007814:	020078d4 	movui	r8,483
 2007818:	020078c8 	cmpgei	r8,zero,483
 200781c:	020078bc 	xorhi	r8,zero,482
 2007820:	020078b0 	cmpltui	r8,zero,482
 2007824:	020078a4 	muli	r8,zero,482
 2007828:	02007898 	cmpnei	r8,zero,482
 200782c:	0200788c 	andi	r8,zero,482
 2007830:	02007880 	call	200788 <__alt_mem_descriptor_memory+0x1feb88>
 2007834:	02007610 	cmplti	r8,zero,472
 2007838:	02007610 	cmplti	r8,zero,472
 200783c:	02007874 	movhi	r8,481
 2007840:	02007868 	cmpgeui	r8,zero,481
 2007844:	02007610 	cmplti	r8,zero,472
 2007848:	02007610 	cmplti	r8,zero,472
 200784c:	02007610 	cmplti	r8,zero,472
 2007850:	02007610 	cmplti	r8,zero,472
 2007854:	02007610 	cmplti	r8,zero,472
 2007858:	0200785c 	xori	r8,zero,481
 200785c:	00808174 	movhi	r2,517
 2007860:	10b64b04 	addi	r2,r2,-9940
 2007864:	003f6c06 	br	2007618 <strerror+0x18>
 2007868:	00808174 	movhi	r2,517
 200786c:	10b75c04 	addi	r2,r2,-8848
 2007870:	003f6906 	br	2007618 <strerror+0x18>
 2007874:	00808174 	movhi	r2,517
 2007878:	10b76904 	addi	r2,r2,-8796
 200787c:	003f6606 	br	2007618 <strerror+0x18>
 2007880:	00808174 	movhi	r2,517
 2007884:	10b76204 	addi	r2,r2,-8824
 2007888:	003f6306 	br	2007618 <strerror+0x18>
 200788c:	00808174 	movhi	r2,517
 2007890:	10b6b604 	addi	r2,r2,-9512
 2007894:	003f6006 	br	2007618 <strerror+0x18>
 2007898:	00808174 	movhi	r2,517
 200789c:	10b77904 	addi	r2,r2,-8732
 20078a0:	003f5d06 	br	2007618 <strerror+0x18>
 20078a4:	00808174 	movhi	r2,517
 20078a8:	10b5d104 	addi	r2,r2,-10428
 20078ac:	003f5a06 	br	2007618 <strerror+0x18>
 20078b0:	00808174 	movhi	r2,517
 20078b4:	10b5c304 	addi	r2,r2,-10484
 20078b8:	003f5706 	br	2007618 <strerror+0x18>
 20078bc:	00808174 	movhi	r2,517
 20078c0:	10b60b04 	addi	r2,r2,-10196
 20078c4:	003f5406 	br	2007618 <strerror+0x18>
 20078c8:	00808174 	movhi	r2,517
 20078cc:	10b64004 	addi	r2,r2,-9984
 20078d0:	003f5106 	br	2007618 <strerror+0x18>
 20078d4:	00808174 	movhi	r2,517
 20078d8:	10b60704 	addi	r2,r2,-10212
 20078dc:	003f4e06 	br	2007618 <strerror+0x18>
 20078e0:	00808174 	movhi	r2,517
 20078e4:	10b77e04 	addi	r2,r2,-8712
 20078e8:	003f4b06 	br	2007618 <strerror+0x18>
 20078ec:	00808174 	movhi	r2,517
 20078f0:	10b61c04 	addi	r2,r2,-10128
 20078f4:	003f4806 	br	2007618 <strerror+0x18>
 20078f8:	00808174 	movhi	r2,517
 20078fc:	10b67804 	addi	r2,r2,-9760
 2007900:	003f4506 	br	2007618 <strerror+0x18>
 2007904:	00808174 	movhi	r2,517
 2007908:	10b75304 	addi	r2,r2,-8884
 200790c:	003f4206 	br	2007618 <strerror+0x18>
 2007910:	00808174 	movhi	r2,517
 2007914:	10b74d04 	addi	r2,r2,-8908
 2007918:	003f3f06 	br	2007618 <strerror+0x18>
 200791c:	00808174 	movhi	r2,517
 2007920:	10b74804 	addi	r2,r2,-8928
 2007924:	003f3c06 	br	2007618 <strerror+0x18>
 2007928:	00808174 	movhi	r2,517
 200792c:	10b73f04 	addi	r2,r2,-8964
 2007930:	003f3906 	br	2007618 <strerror+0x18>
 2007934:	00808174 	movhi	r2,517
 2007938:	10b73904 	addi	r2,r2,-8988
 200793c:	003f3606 	br	2007618 <strerror+0x18>
 2007940:	00808174 	movhi	r2,517
 2007944:	10b73104 	addi	r2,r2,-9020
 2007948:	003f3306 	br	2007618 <strerror+0x18>
 200794c:	00808174 	movhi	r2,517
 2007950:	10b72904 	addi	r2,r2,-9052
 2007954:	003f3006 	br	2007618 <strerror+0x18>
 2007958:	00808174 	movhi	r2,517
 200795c:	10b71d04 	addi	r2,r2,-9100
 2007960:	003f2d06 	br	2007618 <strerror+0x18>
 2007964:	00808174 	movhi	r2,517
 2007968:	10b71604 	addi	r2,r2,-9128
 200796c:	003f2a06 	br	2007618 <strerror+0x18>
 2007970:	00808174 	movhi	r2,517
 2007974:	10b77004 	addi	r2,r2,-8768
 2007978:	003f2706 	br	2007618 <strerror+0x18>
 200797c:	00808174 	movhi	r2,517
 2007980:	10b71004 	addi	r2,r2,-9152
 2007984:	003f2406 	br	2007618 <strerror+0x18>
 2007988:	00808174 	movhi	r2,517
 200798c:	10b70904 	addi	r2,r2,-9180
 2007990:	003f2106 	br	2007618 <strerror+0x18>
 2007994:	00808174 	movhi	r2,517
 2007998:	10b70404 	addi	r2,r2,-9200
 200799c:	003f1e06 	br	2007618 <strerror+0x18>
 20079a0:	00808174 	movhi	r2,517
 20079a4:	10b70004 	addi	r2,r2,-9216
 20079a8:	003f1b06 	br	2007618 <strerror+0x18>
 20079ac:	00808174 	movhi	r2,517
 20079b0:	10b6f904 	addi	r2,r2,-9244
 20079b4:	003f1806 	br	2007618 <strerror+0x18>
 20079b8:	00808174 	movhi	r2,517
 20079bc:	10b6ef04 	addi	r2,r2,-9284
 20079c0:	003f1506 	br	2007618 <strerror+0x18>
 20079c4:	00808174 	movhi	r2,517
 20079c8:	10b6df04 	addi	r2,r2,-9348
 20079cc:	003f1206 	br	2007618 <strerror+0x18>
 20079d0:	00808174 	movhi	r2,517
 20079d4:	10b6d704 	addi	r2,r2,-9380
 20079d8:	003f0f06 	br	2007618 <strerror+0x18>
 20079dc:	00808174 	movhi	r2,517
 20079e0:	10b6cd04 	addi	r2,r2,-9420
 20079e4:	003f0c06 	br	2007618 <strerror+0x18>
 20079e8:	00808174 	movhi	r2,517
 20079ec:	10b6c304 	addi	r2,r2,-9460
 20079f0:	003f0906 	br	2007618 <strerror+0x18>
 20079f4:	00808174 	movhi	r2,517
 20079f8:	10b6c004 	addi	r2,r2,-9472
 20079fc:	003f0606 	br	2007618 <strerror+0x18>
 2007a00:	00808174 	movhi	r2,517
 2007a04:	10b6bb04 	addi	r2,r2,-9492
 2007a08:	003f0306 	br	2007618 <strerror+0x18>
 2007a0c:	00808174 	movhi	r2,517
 2007a10:	10b6b204 	addi	r2,r2,-9528
 2007a14:	003f0006 	br	2007618 <strerror+0x18>
 2007a18:	00808174 	movhi	r2,517
 2007a1c:	10b6ad04 	addi	r2,r2,-9548
 2007a20:	003efd06 	br	2007618 <strerror+0x18>
 2007a24:	00808174 	movhi	r2,517
 2007a28:	10b6a904 	addi	r2,r2,-9564
 2007a2c:	003efa06 	br	2007618 <strerror+0x18>
 2007a30:	00808174 	movhi	r2,517
 2007a34:	10b6a504 	addi	r2,r2,-9580
 2007a38:	003ef706 	br	2007618 <strerror+0x18>
 2007a3c:	00808174 	movhi	r2,517
 2007a40:	10b69f04 	addi	r2,r2,-9604
 2007a44:	003ef406 	br	2007618 <strerror+0x18>
 2007a48:	00808174 	movhi	r2,517
 2007a4c:	10b69a04 	addi	r2,r2,-9624
 2007a50:	003ef106 	br	2007618 <strerror+0x18>
 2007a54:	00808174 	movhi	r2,517
 2007a58:	10b69704 	addi	r2,r2,-9636
 2007a5c:	003eee06 	br	2007618 <strerror+0x18>
 2007a60:	00808174 	movhi	r2,517
 2007a64:	10b68f04 	addi	r2,r2,-9668
 2007a68:	003eeb06 	br	2007618 <strerror+0x18>
 2007a6c:	00808174 	movhi	r2,517
 2007a70:	10b68a04 	addi	r2,r2,-9688
 2007a74:	003ee806 	br	2007618 <strerror+0x18>
 2007a78:	00808174 	movhi	r2,517
 2007a7c:	10b68404 	addi	r2,r2,-9712
 2007a80:	003ee506 	br	2007618 <strerror+0x18>
 2007a84:	00808174 	movhi	r2,517
 2007a88:	10b68004 	addi	r2,r2,-9728
 2007a8c:	003ee206 	br	2007618 <strerror+0x18>
 2007a90:	00808174 	movhi	r2,517
 2007a94:	10b67e04 	addi	r2,r2,-9736
 2007a98:	003edf06 	br	2007618 <strerror+0x18>
 2007a9c:	00808174 	movhi	r2,517
 2007aa0:	10b67504 	addi	r2,r2,-9772
 2007aa4:	003edc06 	br	2007618 <strerror+0x18>
 2007aa8:	00808174 	movhi	r2,517
 2007aac:	10b67004 	addi	r2,r2,-9792
 2007ab0:	003ed906 	br	2007618 <strerror+0x18>
 2007ab4:	00808174 	movhi	r2,517
 2007ab8:	10b66904 	addi	r2,r2,-9820
 2007abc:	003ed606 	br	2007618 <strerror+0x18>
 2007ac0:	00808174 	movhi	r2,517
 2007ac4:	10b66404 	addi	r2,r2,-9840
 2007ac8:	003ed306 	br	2007618 <strerror+0x18>
 2007acc:	00808174 	movhi	r2,517
 2007ad0:	10b66004 	addi	r2,r2,-9856
 2007ad4:	003ed006 	br	2007618 <strerror+0x18>
 2007ad8:	00808174 	movhi	r2,517
 2007adc:	10b65d04 	addi	r2,r2,-9868
 2007ae0:	003ecd06 	br	2007618 <strerror+0x18>
 2007ae4:	00808174 	movhi	r2,517
 2007ae8:	10b65904 	addi	r2,r2,-9884
 2007aec:	003eca06 	br	2007618 <strerror+0x18>
 2007af0:	00808174 	movhi	r2,517
 2007af4:	10b65304 	addi	r2,r2,-9908
 2007af8:	003ec706 	br	2007618 <strerror+0x18>
 2007afc:	00808174 	movhi	r2,517
 2007b00:	10b64f04 	addi	r2,r2,-9924
 2007b04:	003ec406 	br	2007618 <strerror+0x18>
 2007b08:	00808174 	movhi	r2,517
 2007b0c:	10b64504 	addi	r2,r2,-9964
 2007b10:	003ec106 	br	2007618 <strerror+0x18>
 2007b14:	00808174 	movhi	r2,517
 2007b18:	10b63c04 	addi	r2,r2,-10000
 2007b1c:	003ebe06 	br	2007618 <strerror+0x18>
 2007b20:	00808174 	movhi	r2,517
 2007b24:	10b63804 	addi	r2,r2,-10016
 2007b28:	003ebb06 	br	2007618 <strerror+0x18>
 2007b2c:	00808174 	movhi	r2,517
 2007b30:	10b63204 	addi	r2,r2,-10040
 2007b34:	003eb806 	br	2007618 <strerror+0x18>
 2007b38:	00808174 	movhi	r2,517
 2007b3c:	10b62d04 	addi	r2,r2,-10060
 2007b40:	003eb506 	br	2007618 <strerror+0x18>
 2007b44:	00808174 	movhi	r2,517
 2007b48:	10b62504 	addi	r2,r2,-10092
 2007b4c:	003eb206 	br	2007618 <strerror+0x18>
 2007b50:	00808174 	movhi	r2,517
 2007b54:	10b61704 	addi	r2,r2,-10148
 2007b58:	003eaf06 	br	2007618 <strerror+0x18>
 2007b5c:	00808174 	movhi	r2,517
 2007b60:	10b61304 	addi	r2,r2,-10164
 2007b64:	003eac06 	br	2007618 <strerror+0x18>
 2007b68:	00808174 	movhi	r2,517
 2007b6c:	10b60304 	addi	r2,r2,-10228
 2007b70:	003ea906 	br	2007618 <strerror+0x18>
 2007b74:	00808174 	movhi	r2,517
 2007b78:	10b5ff04 	addi	r2,r2,-10244
 2007b7c:	003ea606 	br	2007618 <strerror+0x18>
 2007b80:	00808174 	movhi	r2,517
 2007b84:	10b5fa04 	addi	r2,r2,-10264
 2007b88:	003ea306 	br	2007618 <strerror+0x18>
 2007b8c:	00808174 	movhi	r2,517
 2007b90:	10b5f704 	addi	r2,r2,-10276
 2007b94:	003ea006 	br	2007618 <strerror+0x18>
 2007b98:	00808174 	movhi	r2,517
 2007b9c:	10b5f104 	addi	r2,r2,-10300
 2007ba0:	003e9d06 	br	2007618 <strerror+0x18>
 2007ba4:	00808174 	movhi	r2,517
 2007ba8:	10b5eb04 	addi	r2,r2,-10324
 2007bac:	003e9a06 	br	2007618 <strerror+0x18>
 2007bb0:	00808174 	movhi	r2,517
 2007bb4:	10b5e804 	addi	r2,r2,-10336
 2007bb8:	003e9706 	br	2007618 <strerror+0x18>
 2007bbc:	00808174 	movhi	r2,517
 2007bc0:	10b5e304 	addi	r2,r2,-10356
 2007bc4:	003e9406 	br	2007618 <strerror+0x18>
 2007bc8:	00808174 	movhi	r2,517
 2007bcc:	10b5de04 	addi	r2,r2,-10376
 2007bd0:	003e9106 	br	2007618 <strerror+0x18>
 2007bd4:	00808174 	movhi	r2,517
 2007bd8:	10b5d904 	addi	r2,r2,-10396
 2007bdc:	003e8e06 	br	2007618 <strerror+0x18>
 2007be0:	00808174 	movhi	r2,517
 2007be4:	10b5ce04 	addi	r2,r2,-10440
 2007be8:	003e8b06 	br	2007618 <strerror+0x18>
 2007bec:	00808174 	movhi	r2,517
 2007bf0:	10b5ca04 	addi	r2,r2,-10456
 2007bf4:	003e8806 	br	2007618 <strerror+0x18>
 2007bf8:	00808174 	movhi	r2,517
 2007bfc:	10b5be04 	addi	r2,r2,-10504
 2007c00:	003e8506 	br	2007618 <strerror+0x18>
 2007c04:	00808174 	movhi	r2,517
 2007c08:	10b5b904 	addi	r2,r2,-10524
 2007c0c:	003e8206 	br	2007618 <strerror+0x18>
 2007c10:	00808174 	movhi	r2,517
 2007c14:	10b5b204 	addi	r2,r2,-10552
 2007c18:	003e7f06 	br	2007618 <strerror+0x18>
 2007c1c:	00808174 	movhi	r2,517
 2007c20:	10b5af04 	addi	r2,r2,-10564
 2007c24:	003e7c06 	br	2007618 <strerror+0x18>
 2007c28:	00808174 	movhi	r2,517
 2007c2c:	10b5a904 	addi	r2,r2,-10588
 2007c30:	003e7906 	br	2007618 <strerror+0x18>
 2007c34:	00808174 	movhi	r2,517
 2007c38:	10b5a504 	addi	r2,r2,-10604
 2007c3c:	003e7606 	br	2007618 <strerror+0x18>
 2007c40:	00808174 	movhi	r2,517
 2007c44:	10b59e04 	addi	r2,r2,-10632
 2007c48:	003e7306 	br	2007618 <strerror+0x18>
 2007c4c:	00808174 	movhi	r2,517
 2007c50:	10b59b04 	addi	r2,r2,-10644
 2007c54:	003e7006 	br	2007618 <strerror+0x18>
 2007c58:	00808174 	movhi	r2,517
 2007c5c:	10b78c04 	addi	r2,r2,-8656
 2007c60:	003e6d06 	br	2007618 <strerror+0x18>

02007c64 <strlen>:
 2007c64:	208000cc 	andi	r2,r4,3
 2007c68:	10001f1e 	bne	r2,zero,2007ce8 <strlen+0x84>
 2007c6c:	20800017 	ldw	r2,0(r4)
 2007c70:	01ffbff4 	movhi	r7,65279
 2007c74:	39ffbfc4 	addi	r7,r7,-257
 2007c78:	01a02074 	movhi	r6,32897
 2007c7c:	31a02004 	addi	r6,r6,-32640
 2007c80:	11c7883a 	add	r3,r2,r7
 2007c84:	0084303a 	nor	r2,zero,r2
 2007c88:	1886703a 	and	r3,r3,r2
 2007c8c:	1986703a 	and	r3,r3,r6
 2007c90:	2005883a 	mov	r2,r4
 2007c94:	1800101e 	bne	r3,zero,2007cd8 <strlen+0x74>
 2007c98:	10800104 	addi	r2,r2,4
 2007c9c:	10c00017 	ldw	r3,0(r2)
 2007ca0:	19cb883a 	add	r5,r3,r7
 2007ca4:	00c6303a 	nor	r3,zero,r3
 2007ca8:	28c6703a 	and	r3,r5,r3
 2007cac:	1986703a 	and	r3,r3,r6
 2007cb0:	1800091e 	bne	r3,zero,2007cd8 <strlen+0x74>
 2007cb4:	10800104 	addi	r2,r2,4
 2007cb8:	10c00017 	ldw	r3,0(r2)
 2007cbc:	19cb883a 	add	r5,r3,r7
 2007cc0:	00c6303a 	nor	r3,zero,r3
 2007cc4:	28c6703a 	and	r3,r5,r3
 2007cc8:	1986703a 	and	r3,r3,r6
 2007ccc:	183ff226 	beq	r3,zero,2007c98 <strlen+0x34>
 2007cd0:	00000106 	br	2007cd8 <strlen+0x74>
 2007cd4:	10800044 	addi	r2,r2,1
 2007cd8:	10c00007 	ldb	r3,0(r2)
 2007cdc:	183ffd1e 	bne	r3,zero,2007cd4 <strlen+0x70>
 2007ce0:	1105c83a 	sub	r2,r2,r4
 2007ce4:	f800283a 	ret
 2007ce8:	2005883a 	mov	r2,r4
 2007cec:	003ffa06 	br	2007cd8 <strlen+0x74>

02007cf0 <strncmp>:
 2007cf0:	30001826 	beq	r6,zero,2007d54 <strncmp+0x64>
 2007cf4:	2904b03a 	or	r2,r5,r4
 2007cf8:	108000cc 	andi	r2,r2,3
 2007cfc:	10001726 	beq	r2,zero,2007d5c <strncmp+0x6c>
 2007d00:	31bfffc4 	addi	r6,r6,-1
 2007d04:	20800007 	ldb	r2,0(r4)
 2007d08:	28c00007 	ldb	r3,0(r5)
 2007d0c:	10c0331e 	bne	r2,r3,2007ddc <strncmp+0xec>
 2007d10:	30001026 	beq	r6,zero,2007d54 <strncmp+0x64>
 2007d14:	10000f26 	beq	r2,zero,2007d54 <strncmp+0x64>
 2007d18:	20800044 	addi	r2,r4,1
 2007d1c:	29400044 	addi	r5,r5,1
 2007d20:	2189883a 	add	r4,r4,r6
 2007d24:	00000406 	br	2007d38 <strncmp+0x48>
 2007d28:	11000a26 	beq	r2,r4,2007d54 <strncmp+0x64>
 2007d2c:	18000926 	beq	r3,zero,2007d54 <strncmp+0x64>
 2007d30:	10800044 	addi	r2,r2,1
 2007d34:	29400044 	addi	r5,r5,1
 2007d38:	10c00007 	ldb	r3,0(r2)
 2007d3c:	29800007 	ldb	r6,0(r5)
 2007d40:	19bff926 	beq	r3,r6,2007d28 <strncmp+0x38>
 2007d44:	10c00003 	ldbu	r3,0(r2)
 2007d48:	28800003 	ldbu	r2,0(r5)
 2007d4c:	1885c83a 	sub	r2,r3,r2
 2007d50:	f800283a 	ret
 2007d54:	0005883a 	mov	r2,zero
 2007d58:	f800283a 	ret
 2007d5c:	024000c4 	movi	r9,3
 2007d60:	49bfe72e 	bgeu	r9,r6,2007d00 <strncmp+0x10>
 2007d64:	20800017 	ldw	r2,0(r4)
 2007d68:	28c00017 	ldw	r3,0(r5)
 2007d6c:	10ffe41e 	bne	r2,r3,2007d00 <strncmp+0x10>
 2007d70:	30ffff04 	addi	r3,r6,-4
 2007d74:	183ff726 	beq	r3,zero,2007d54 <strncmp+0x64>
 2007d78:	02ffbff4 	movhi	r11,65279
 2007d7c:	5affbfc4 	addi	r11,r11,-257
 2007d80:	12cd883a 	add	r6,r2,r11
 2007d84:	0084303a 	nor	r2,zero,r2
 2007d88:	3084703a 	and	r2,r6,r2
 2007d8c:	02a02074 	movhi	r10,32897
 2007d90:	52a02004 	addi	r10,r10,-32640
 2007d94:	1284703a 	and	r2,r2,r10
 2007d98:	10000b26 	beq	r2,zero,2007dc8 <strncmp+0xd8>
 2007d9c:	003fed06 	br	2007d54 <strncmp+0x64>
 2007da0:	21800017 	ldw	r6,0(r4)
 2007da4:	28800017 	ldw	r2,0(r5)
 2007da8:	32d1883a 	add	r8,r6,r11
 2007dac:	018e303a 	nor	r7,zero,r6
 2007db0:	41ce703a 	and	r7,r8,r7
 2007db4:	3a8e703a 	and	r7,r7,r10
 2007db8:	30800a1e 	bne	r6,r2,2007de4 <strncmp+0xf4>
 2007dbc:	18ffff04 	addi	r3,r3,-4
 2007dc0:	183fe426 	beq	r3,zero,2007d54 <strncmp+0x64>
 2007dc4:	383fe31e 	bne	r7,zero,2007d54 <strncmp+0x64>
 2007dc8:	21000104 	addi	r4,r4,4
 2007dcc:	29400104 	addi	r5,r5,4
 2007dd0:	48fff336 	bltu	r9,r3,2007da0 <strncmp+0xb0>
 2007dd4:	19bfffc4 	addi	r6,r3,-1
 2007dd8:	183fca1e 	bne	r3,zero,2007d04 <strncmp+0x14>
 2007ddc:	2005883a 	mov	r2,r4
 2007de0:	003fd806 	br	2007d44 <strncmp+0x54>
 2007de4:	19bfffc4 	addi	r6,r3,-1
 2007de8:	003fc606 	br	2007d04 <strncmp+0x14>

02007dec <strncpy>:
 2007dec:	2906b03a 	or	r3,r5,r4
 2007df0:	18c000cc 	andi	r3,r3,3
 2007df4:	2005883a 	mov	r2,r4
 2007df8:	1800261e 	bne	r3,zero,2007e94 <strncpy+0xa8>
 2007dfc:	02c000c4 	movi	r11,3
 2007e00:	200f883a 	mov	r7,r4
 2007e04:	59800f2e 	bgeu	r11,r6,2007e44 <strncpy+0x58>
 2007e08:	02bfbff4 	movhi	r10,65279
 2007e0c:	52bfbfc4 	addi	r10,r10,-257
 2007e10:	01202074 	movhi	r4,32897
 2007e14:	21202004 	addi	r4,r4,-32640
 2007e18:	28c00017 	ldw	r3,0(r5)
 2007e1c:	00d2303a 	nor	r9,zero,r3
 2007e20:	1a91883a 	add	r8,r3,r10
 2007e24:	4a10703a 	and	r8,r9,r8
 2007e28:	4110703a 	and	r8,r8,r4
 2007e2c:	4000051e 	bne	r8,zero,2007e44 <strncpy+0x58>
 2007e30:	38c00015 	stw	r3,0(r7)
 2007e34:	31bfff04 	addi	r6,r6,-4
 2007e38:	39c00104 	addi	r7,r7,4
 2007e3c:	29400104 	addi	r5,r5,4
 2007e40:	59bff536 	bltu	r11,r6,2007e18 <strncpy+0x2c>
 2007e44:	30001226 	beq	r6,zero,2007e90 <strncpy+0xa4>
 2007e48:	29000007 	ldb	r4,0(r5)
 2007e4c:	31bfffc4 	addi	r6,r6,-1
 2007e50:	38c00044 	addi	r3,r7,1
 2007e54:	39000005 	stb	r4,0(r7)
 2007e58:	29400044 	addi	r5,r5,1
 2007e5c:	20000726 	beq	r4,zero,2007e7c <strncpy+0x90>
 2007e60:	30000e26 	beq	r6,zero,2007e9c <strncpy+0xb0>
 2007e64:	29c00007 	ldb	r7,0(r5)
 2007e68:	18c00044 	addi	r3,r3,1
 2007e6c:	31bfffc4 	addi	r6,r6,-1
 2007e70:	19ffffc5 	stb	r7,-1(r3)
 2007e74:	29400044 	addi	r5,r5,1
 2007e78:	383ff91e 	bne	r7,zero,2007e60 <strncpy+0x74>
 2007e7c:	198b883a 	add	r5,r3,r6
 2007e80:	30000726 	beq	r6,zero,2007ea0 <strncpy+0xb4>
 2007e84:	18000005 	stb	zero,0(r3)
 2007e88:	18c00044 	addi	r3,r3,1
 2007e8c:	197ffd1e 	bne	r3,r5,2007e84 <strncpy+0x98>
 2007e90:	f800283a 	ret
 2007e94:	200f883a 	mov	r7,r4
 2007e98:	003fea06 	br	2007e44 <strncpy+0x58>
 2007e9c:	f800283a 	ret
 2007ea0:	f800283a 	ret

02007ea4 <critical_factorization>:
 2007ea4:	03000044 	movi	r12,1
 2007ea8:	600f883a 	mov	r7,r12
 2007eac:	0011883a 	mov	r8,zero
 2007eb0:	00bfffc4 	movi	r2,-1
 2007eb4:	2087883a 	add	r3,r4,r2
 2007eb8:	19d7883a 	add	r11,r3,r7
 2007ebc:	3a07883a 	add	r3,r7,r8
 2007ec0:	20d3883a 	add	r9,r4,r3
 2007ec4:	19400b2e 	bgeu	r3,r5,2007ef4 <critical_factorization+0x50>
 2007ec8:	4a800003 	ldbu	r10,0(r9)
 2007ecc:	5a400003 	ldbu	r9,0(r11)
 2007ed0:	5240232e 	bgeu	r10,r9,2007f60 <critical_factorization+0xbc>
 2007ed4:	1811883a 	mov	r8,r3
 2007ed8:	01c00044 	movi	r7,1
 2007edc:	1899c83a 	sub	r12,r3,r2
 2007ee0:	2087883a 	add	r3,r4,r2
 2007ee4:	19d7883a 	add	r11,r3,r7
 2007ee8:	3a07883a 	add	r3,r7,r8
 2007eec:	20d3883a 	add	r9,r4,r3
 2007ef0:	197ff536 	bltu	r3,r5,2007ec8 <critical_factorization+0x24>
 2007ef4:	03400044 	movi	r13,1
 2007ef8:	33000015 	stw	r12,0(r6)
 2007efc:	680f883a 	mov	r7,r13
 2007f00:	0011883a 	mov	r8,zero
 2007f04:	02ffffc4 	movi	r11,-1
 2007f08:	22c7883a 	add	r3,r4,r11
 2007f0c:	19d9883a 	add	r12,r3,r7
 2007f10:	3a07883a 	add	r3,r7,r8
 2007f14:	20d3883a 	add	r9,r4,r3
 2007f18:	19400b2e 	bgeu	r3,r5,2007f48 <critical_factorization+0xa4>
 2007f1c:	4a800003 	ldbu	r10,0(r9)
 2007f20:	62400003 	ldbu	r9,0(r12)
 2007f24:	4a80142e 	bgeu	r9,r10,2007f78 <critical_factorization+0xd4>
 2007f28:	1811883a 	mov	r8,r3
 2007f2c:	01c00044 	movi	r7,1
 2007f30:	1adbc83a 	sub	r13,r3,r11
 2007f34:	22c7883a 	add	r3,r4,r11
 2007f38:	19d9883a 	add	r12,r3,r7
 2007f3c:	3a07883a 	add	r3,r7,r8
 2007f40:	20d3883a 	add	r9,r4,r3
 2007f44:	197ff536 	bltu	r3,r5,2007f1c <critical_factorization+0x78>
 2007f48:	5ac00044 	addi	r11,r11,1
 2007f4c:	10800044 	addi	r2,r2,1
 2007f50:	58800236 	bltu	r11,r2,2007f5c <critical_factorization+0xb8>
 2007f54:	33400015 	stw	r13,0(r6)
 2007f58:	5805883a 	mov	r2,r11
 2007f5c:	f800283a 	ret
 2007f60:	52400b26 	beq	r10,r9,2007f90 <critical_factorization+0xec>
 2007f64:	03000044 	movi	r12,1
 2007f68:	4005883a 	mov	r2,r8
 2007f6c:	600f883a 	mov	r7,r12
 2007f70:	4311883a 	add	r8,r8,r12
 2007f74:	003fcf06 	br	2007eb4 <critical_factorization+0x10>
 2007f78:	52400826 	beq	r10,r9,2007f9c <critical_factorization+0xf8>
 2007f7c:	03400044 	movi	r13,1
 2007f80:	4017883a 	mov	r11,r8
 2007f84:	680f883a 	mov	r7,r13
 2007f88:	4351883a 	add	r8,r8,r13
 2007f8c:	003fde06 	br	2007f08 <critical_factorization+0x64>
 2007f90:	3b000526 	beq	r7,r12,2007fa8 <critical_factorization+0x104>
 2007f94:	39c00044 	addi	r7,r7,1
 2007f98:	003fc606 	br	2007eb4 <critical_factorization+0x10>
 2007f9c:	3b400626 	beq	r7,r13,2007fb8 <critical_factorization+0x114>
 2007fa0:	39c00044 	addi	r7,r7,1
 2007fa4:	003fd806 	br	2007f08 <critical_factorization+0x64>
 2007fa8:	3819883a 	mov	r12,r7
 2007fac:	1811883a 	mov	r8,r3
 2007fb0:	01c00044 	movi	r7,1
 2007fb4:	003fbf06 	br	2007eb4 <critical_factorization+0x10>
 2007fb8:	381b883a 	mov	r13,r7
 2007fbc:	1811883a 	mov	r8,r3
 2007fc0:	01c00044 	movi	r7,1
 2007fc4:	003fd006 	br	2007f08 <critical_factorization+0x64>

02007fc8 <two_way_long_needle>:
 2007fc8:	defef004 	addi	sp,sp,-1088
 2007fcc:	dc810815 	stw	r18,1056(sp)
 2007fd0:	dc810004 	addi	r18,sp,1024
 2007fd4:	2817883a 	mov	r11,r5
 2007fd8:	df010e15 	stw	fp,1080(sp)
 2007fdc:	dc410715 	stw	r17,1052(sp)
 2007fe0:	2039883a 	mov	fp,r4
 2007fe4:	3023883a 	mov	r17,r6
 2007fe8:	3009883a 	mov	r4,r6
 2007fec:	380b883a 	mov	r5,r7
 2007ff0:	900d883a 	mov	r6,r18
 2007ff4:	dcc10915 	stw	r19,1060(sp)
 2007ff8:	dc010615 	stw	r16,1048(sp)
 2007ffc:	dac10515 	stw	r11,1044(sp)
 2008000:	dfc10f15 	stw	ra,1084(sp)
 2008004:	ddc10d15 	stw	r23,1076(sp)
 2008008:	dd810c15 	stw	r22,1072(sp)
 200800c:	dd410b15 	stw	r21,1068(sp)
 2008010:	dd010a15 	stw	r20,1064(sp)
 2008014:	3821883a 	mov	r16,r7
 2008018:	2007ea40 	call	2007ea4 <critical_factorization>
 200801c:	dac10517 	ldw	r11,1044(sp)
 2008020:	1027883a 	mov	r19,r2
 2008024:	d807883a 	mov	r3,sp
 2008028:	1c000015 	stw	r16,0(r3)
 200802c:	18c00104 	addi	r3,r3,4
 2008030:	90fffd1e 	bne	r18,r3,2008028 <two_way_long_needle+0x60>
 2008034:	80000b26 	beq	r16,zero,2008064 <two_way_long_needle+0x9c>
 2008038:	80ffffc4 	addi	r3,r16,-1
 200803c:	8805883a 	mov	r2,r17
 2008040:	844b883a 	add	r5,r16,r17
 2008044:	11000003 	ldbu	r4,0(r2)
 2008048:	10800044 	addi	r2,r2,1
 200804c:	2109883a 	add	r4,r4,r4
 2008050:	2109883a 	add	r4,r4,r4
 2008054:	d909883a 	add	r4,sp,r4
 2008058:	20c00015 	stw	r3,0(r4)
 200805c:	18ffffc4 	addi	r3,r3,-1
 2008060:	117ff81e 	bne	r2,r5,2008044 <two_way_long_needle+0x7c>
 2008064:	d9410017 	ldw	r5,1024(sp)
 2008068:	8809883a 	mov	r4,r17
 200806c:	980d883a 	mov	r6,r19
 2008070:	894b883a 	add	r5,r17,r5
 2008074:	dac10515 	stw	r11,1044(sp)
 2008078:	200e5b80 	call	200e5b8 <memcmp>
 200807c:	dac10517 	ldw	r11,1044(sp)
 2008080:	1000661e 	bne	r2,zero,200821c <two_way_long_needle+0x254>
 2008084:	9dffff84 	addi	r23,r19,-2
 2008088:	8def883a 	add	r23,r17,r23
 200808c:	88bfffc4 	addi	r2,r17,-1
 2008090:	9cbfffc4 	addi	r18,r19,-1
 2008094:	002b883a 	mov	r21,zero
 2008098:	8c8d883a 	add	r6,r17,r18
 200809c:	ddc10315 	stw	r23,1036(sp)
 20080a0:	d8810415 	stw	r2,1040(sp)
 20080a4:	ac2f883a 	add	r23,r21,r16
 20080a8:	00800044 	movi	r2,1
 20080ac:	d9810115 	stw	r6,1028(sp)
 20080b0:	14c5c83a 	sub	r2,r2,r19
 20080b4:	e2c9883a 	add	r4,fp,r11
 20080b8:	000b883a 	mov	r5,zero
 20080bc:	bacdc83a 	sub	r6,r23,r11
 20080c0:	0029883a 	mov	r20,zero
 20080c4:	85bfffc4 	addi	r22,r16,-1
 20080c8:	d8810215 	stw	r2,1032(sp)
 20080cc:	200e4c00 	call	200e4c0 <memchr>
 20080d0:	1000151e 	bne	r2,zero,2008128 <two_way_long_needle+0x160>
 20080d4:	b8001426 	beq	r23,zero,2008128 <two_way_long_needle+0x160>
 20080d8:	e5c5883a 	add	r2,fp,r23
 20080dc:	10bfffc3 	ldbu	r2,-1(r2)
 20080e0:	1085883a 	add	r2,r2,r2
 20080e4:	1085883a 	add	r2,r2,r2
 20080e8:	d885883a 	add	r2,sp,r2
 20080ec:	10800017 	ldw	r2,0(r2)
 20080f0:	10001a26 	beq	r2,zero,200815c <two_way_long_needle+0x194>
 20080f4:	a0000426 	beq	r20,zero,2008108 <two_way_long_needle+0x140>
 20080f8:	d8c10017 	ldw	r3,1024(sp)
 20080fc:	10c0022e 	bgeu	r2,r3,2008108 <two_way_long_needle+0x140>
 2008100:	80c5c83a 	sub	r2,r16,r3
 2008104:	0029883a 	mov	r20,zero
 2008108:	a8ab883a 	add	r21,r21,r2
 200810c:	b817883a 	mov	r11,r23
 2008110:	ac2f883a 	add	r23,r21,r16
 2008114:	e2c9883a 	add	r4,fp,r11
 2008118:	000b883a 	mov	r5,zero
 200811c:	bacdc83a 	sub	r6,r23,r11
 2008120:	200e4c00 	call	200e4c0 <memchr>
 2008124:	103feb26 	beq	r2,zero,20080d4 <two_way_long_needle+0x10c>
 2008128:	0005883a 	mov	r2,zero
 200812c:	dfc10f17 	ldw	ra,1084(sp)
 2008130:	df010e17 	ldw	fp,1080(sp)
 2008134:	ddc10d17 	ldw	r23,1076(sp)
 2008138:	dd810c17 	ldw	r22,1072(sp)
 200813c:	dd410b17 	ldw	r21,1068(sp)
 2008140:	dd010a17 	ldw	r20,1064(sp)
 2008144:	dcc10917 	ldw	r19,1060(sp)
 2008148:	dc810817 	ldw	r18,1056(sp)
 200814c:	dc410717 	ldw	r17,1052(sp)
 2008150:	dc010617 	ldw	r16,1048(sp)
 2008154:	dec11004 	addi	sp,sp,1088
 2008158:	f800283a 	ret
 200815c:	a007883a 	mov	r3,r20
 2008160:	a4c0012e 	bgeu	r20,r19,2008168 <two_way_long_needle+0x1a0>
 2008164:	9807883a 	mov	r3,r19
 2008168:	1d80112e 	bgeu	r3,r22,20081b0 <two_way_long_needle+0x1e8>
 200816c:	e545883a 	add	r2,fp,r21
 2008170:	88cb883a 	add	r5,r17,r3
 2008174:	10c9883a 	add	r4,r2,r3
 2008178:	00000406 	br	200818c <two_way_long_needle+0x1c4>
 200817c:	18c00044 	addi	r3,r3,1
 2008180:	88cb883a 	add	r5,r17,r3
 2008184:	10c9883a 	add	r4,r2,r3
 2008188:	1d80092e 	bgeu	r3,r22,20081b0 <two_way_long_needle+0x1e8>
 200818c:	29400003 	ldbu	r5,0(r5)
 2008190:	21000003 	ldbu	r4,0(r4)
 2008194:	293ff926 	beq	r5,r4,200817c <two_way_long_needle+0x1b4>
 2008198:	d8810217 	ldw	r2,1032(sp)
 200819c:	0029883a 	mov	r20,zero
 20081a0:	b817883a 	mov	r11,r23
 20081a4:	1553883a 	add	r9,r2,r21
 20081a8:	48eb883a 	add	r21,r9,r3
 20081ac:	003fd806 	br	2008110 <two_way_long_needle+0x148>
 20081b0:	900b883a 	mov	r5,r18
 20081b4:	a4c05b2e 	bgeu	r20,r19,2008324 <two_way_long_needle+0x35c>
 20081b8:	d9810117 	ldw	r6,1028(sp)
 20081bc:	e545883a 	add	r2,fp,r21
 20081c0:	1487883a 	add	r3,r2,r18
 20081c4:	31000003 	ldbu	r4,0(r6)
 20081c8:	18c00003 	ldbu	r3,0(r3)
 20081cc:	20c0551e 	bne	r4,r3,2008324 <two_way_long_needle+0x35c>
 20081d0:	d9010417 	ldw	r4,1040(sp)
 20081d4:	d8c10317 	ldw	r3,1036(sp)
 20081d8:	2519883a 	add	r12,r4,r20
 20081dc:	00000506 	br	20081f4 <two_way_long_needle+0x22c>
 20081e0:	1ac00003 	ldbu	r11,0(r3)
 20081e4:	31800003 	ldbu	r6,0(r6)
 20081e8:	18ffffc4 	addi	r3,r3,-1
 20081ec:	5980041e 	bne	r11,r6,2008200 <two_way_long_needle+0x238>
 20081f0:	200b883a 	mov	r5,r4
 20081f4:	293fffc4 	addi	r4,r5,-1
 20081f8:	110d883a 	add	r6,r2,r4
 20081fc:	1b3ff81e 	bne	r3,r12,20081e0 <two_way_long_needle+0x218>
 2008200:	a2800044 	addi	r10,r20,1
 2008204:	2a804936 	bltu	r5,r10,200832c <two_way_long_needle+0x364>
 2008208:	da810017 	ldw	r10,1024(sp)
 200820c:	b817883a 	mov	r11,r23
 2008210:	aaab883a 	add	r21,r21,r10
 2008214:	82a9c83a 	sub	r20,r16,r10
 2008218:	003fbd06 	br	2008110 <two_way_long_needle+0x148>
 200821c:	84c5c83a 	sub	r2,r16,r19
 2008220:	14c03e36 	bltu	r2,r19,200831c <two_way_long_needle+0x354>
 2008224:	9cbfffc4 	addi	r18,r19,-1
 2008228:	10800044 	addi	r2,r2,1
 200822c:	8c89883a 	add	r4,r17,r18
 2008230:	05000044 	movi	r20,1
 2008234:	d8810015 	stw	r2,1024(sp)
 2008238:	002b883a 	mov	r21,zero
 200823c:	85bfffc4 	addi	r22,r16,-1
 2008240:	d9010115 	stw	r4,1028(sp)
 2008244:	a4e9c83a 	sub	r20,r20,r19
 2008248:	ac2f883a 	add	r23,r21,r16
 200824c:	e2c9883a 	add	r4,fp,r11
 2008250:	000b883a 	mov	r5,zero
 2008254:	bacdc83a 	sub	r6,r23,r11
 2008258:	200e4c00 	call	200e4c0 <memchr>
 200825c:	103fb21e 	bne	r2,zero,2008128 <two_way_long_needle+0x160>
 2008260:	b83fb126 	beq	r23,zero,2008128 <two_way_long_needle+0x160>
 2008264:	e5c5883a 	add	r2,fp,r23
 2008268:	10bfffc3 	ldbu	r2,-1(r2)
 200826c:	1085883a 	add	r2,r2,r2
 2008270:	1085883a 	add	r2,r2,r2
 2008274:	d885883a 	add	r2,sp,r2
 2008278:	10800017 	ldw	r2,0(r2)
 200827c:	1000201e 	bne	r2,zero,2008300 <two_way_long_needle+0x338>
 2008280:	e545883a 	add	r2,fp,r21
 2008284:	9d800e2e 	bgeu	r19,r22,20082c0 <two_way_long_needle+0x2f8>
 2008288:	8cc9883a 	add	r4,r17,r19
 200828c:	14c7883a 	add	r3,r2,r19
 2008290:	21400003 	ldbu	r5,0(r4)
 2008294:	19000003 	ldbu	r4,0(r3)
 2008298:	9807883a 	mov	r3,r19
 200829c:	29000426 	beq	r5,r4,20082b0 <two_way_long_needle+0x2e8>
 20082a0:	00001a06 	br	200830c <two_way_long_needle+0x344>
 20082a4:	21800003 	ldbu	r6,0(r4)
 20082a8:	29000003 	ldbu	r4,0(r5)
 20082ac:	3100171e 	bne	r6,r4,200830c <two_way_long_needle+0x344>
 20082b0:	18c00044 	addi	r3,r3,1
 20082b4:	88c9883a 	add	r4,r17,r3
 20082b8:	10cb883a 	add	r5,r2,r3
 20082bc:	1dbff936 	bltu	r3,r22,20082a4 <two_way_long_needle+0x2dc>
 20082c0:	9007883a 	mov	r3,r18
 20082c4:	983f9926 	beq	r19,zero,200812c <two_way_long_needle+0x164>
 20082c8:	d9810117 	ldw	r6,1028(sp)
 20082cc:	1489883a 	add	r4,r2,r18
 20082d0:	21000003 	ldbu	r4,0(r4)
 20082d4:	31400003 	ldbu	r5,0(r6)
 20082d8:	2900081e 	bne	r5,r4,20082fc <two_way_long_needle+0x334>
 20082dc:	01bfffc4 	movi	r6,-1
 20082e0:	18ffffc4 	addi	r3,r3,-1
 20082e4:	88cb883a 	add	r5,r17,r3
 20082e8:	10c9883a 	add	r4,r2,r3
 20082ec:	19bf8f26 	beq	r3,r6,200812c <two_way_long_needle+0x164>
 20082f0:	29400003 	ldbu	r5,0(r5)
 20082f4:	21000003 	ldbu	r4,0(r4)
 20082f8:	293ff926 	beq	r5,r4,20082e0 <two_way_long_needle+0x318>
 20082fc:	d8810017 	ldw	r2,1024(sp)
 2008300:	a8ab883a 	add	r21,r21,r2
 2008304:	b817883a 	mov	r11,r23
 2008308:	003fcf06 	br	2008248 <two_way_long_needle+0x280>
 200830c:	a54f883a 	add	r7,r20,r21
 2008310:	38eb883a 	add	r21,r7,r3
 2008314:	b817883a 	mov	r11,r23
 2008318:	003fcb06 	br	2008248 <two_way_long_needle+0x280>
 200831c:	9805883a 	mov	r2,r19
 2008320:	003fc006 	br	2008224 <two_way_long_needle+0x25c>
 2008324:	980b883a 	mov	r5,r19
 2008328:	003fb506 	br	2008200 <two_way_long_needle+0x238>
 200832c:	e545883a 	add	r2,fp,r21
 2008330:	003f7e06 	br	200812c <two_way_long_needle+0x164>

02008334 <strstr>:
 2008334:	defff104 	addi	sp,sp,-60
 2008338:	dc800715 	stw	r18,28(sp)
 200833c:	dc000515 	stw	r16,20(sp)
 2008340:	dfc00e15 	stw	ra,56(sp)
 2008344:	df000d15 	stw	fp,52(sp)
 2008348:	ddc00c15 	stw	r23,48(sp)
 200834c:	dd800b15 	stw	r22,44(sp)
 2008350:	dd400a15 	stw	r21,40(sp)
 2008354:	dd000915 	stw	r20,36(sp)
 2008358:	dcc00815 	stw	r19,32(sp)
 200835c:	dc400615 	stw	r17,24(sp)
 2008360:	20c00007 	ldb	r3,0(r4)
 2008364:	2025883a 	mov	r18,r4
 2008368:	2821883a 	mov	r16,r5
 200836c:	1800c726 	beq	r3,zero,200868c <strstr+0x358>
 2008370:	2a000007 	ldb	r8,0(r5)
 2008374:	40000f26 	beq	r8,zero,20083b4 <strstr+0x80>
 2008378:	280f883a 	mov	r7,r5
 200837c:	2013883a 	mov	r9,r4
 2008380:	02800044 	movi	r10,1
 2008384:	00000206 	br	2008390 <strstr+0x5c>
 2008388:	3a000007 	ldb	r8,0(r7)
 200838c:	40000826 	beq	r8,zero,20083b0 <strstr+0x7c>
 2008390:	4a400044 	addi	r9,r9,1
 2008394:	1a11003a 	cmpeq	r8,r3,r8
 2008398:	48c00007 	ldb	r3,0(r9)
 200839c:	39c00044 	addi	r7,r7,1
 20083a0:	5214703a 	and	r10,r10,r8
 20083a4:	183ff81e 	bne	r3,zero,2008388 <strstr+0x54>
 20083a8:	38800007 	ldb	r2,0(r7)
 20083ac:	10000e1e 	bne	r2,zero,20083e8 <strstr+0xb4>
 20083b0:	50000f26 	beq	r10,zero,20083f0 <strstr+0xbc>
 20083b4:	9005883a 	mov	r2,r18
 20083b8:	dfc00e17 	ldw	ra,56(sp)
 20083bc:	df000d17 	ldw	fp,52(sp)
 20083c0:	ddc00c17 	ldw	r23,48(sp)
 20083c4:	dd800b17 	ldw	r22,44(sp)
 20083c8:	dd400a17 	ldw	r21,40(sp)
 20083cc:	dd000917 	ldw	r20,36(sp)
 20083d0:	dcc00817 	ldw	r19,32(sp)
 20083d4:	dc800717 	ldw	r18,28(sp)
 20083d8:	dc400617 	ldw	r17,24(sp)
 20083dc:	dc000517 	ldw	r16,20(sp)
 20083e0:	dec00f04 	addi	sp,sp,60
 20083e4:	f800283a 	ret
 20083e8:	0025883a 	mov	r18,zero
 20083ec:	003ff106 	br	20083b4 <strstr+0x80>
 20083f0:	81400007 	ldb	r5,0(r16)
 20083f4:	91000044 	addi	r4,r18,1
 20083f8:	3c23c83a 	sub	r17,r7,r16
 20083fc:	20073e00 	call	20073e0 <strchr>
 2008400:	102f883a 	mov	r23,r2
 2008404:	103ff826 	beq	r2,zero,20083e8 <strstr+0xb4>
 2008408:	00c00044 	movi	r3,1
 200840c:	88c05f26 	beq	r17,r3,200858c <strstr+0x258>
 2008410:	9465883a 	add	r18,r18,r17
 2008414:	90800136 	bltu	r18,r2,200841c <strstr+0xe8>
 2008418:	9087c83a 	sub	r3,r18,r2
 200841c:	008007c4 	movi	r2,31
 2008420:	1440072e 	bgeu	r2,r17,2008440 <strstr+0x10c>
 2008424:	b809883a 	mov	r4,r23
 2008428:	180b883a 	mov	r5,r3
 200842c:	800d883a 	mov	r6,r16
 2008430:	880f883a 	mov	r7,r17
 2008434:	2007fc80 	call	2007fc8 <two_way_long_needle>
 2008438:	1025883a 	mov	r18,r2
 200843c:	003fdd06 	br	20083b4 <strstr+0x80>
 2008440:	8009883a 	mov	r4,r16
 2008444:	880b883a 	mov	r5,r17
 2008448:	d80d883a 	mov	r6,sp
 200844c:	d8c00415 	stw	r3,16(sp)
 2008450:	2007ea40 	call	2007ea4 <critical_factorization>
 2008454:	d9400017 	ldw	r5,0(sp)
 2008458:	8009883a 	mov	r4,r16
 200845c:	100d883a 	mov	r6,r2
 2008460:	814b883a 	add	r5,r16,r5
 2008464:	1039883a 	mov	fp,r2
 2008468:	200e5b80 	call	200e5b8 <memcmp>
 200846c:	d8c00417 	ldw	r3,16(sp)
 2008470:	1000481e 	bne	r2,zero,2008594 <strstr+0x260>
 2008474:	e4bfffc4 	addi	r18,fp,-1
 2008478:	e5bfff84 	addi	r22,fp,-2
 200847c:	8485883a 	add	r2,r16,r18
 2008480:	85ad883a 	add	r22,r16,r22
 2008484:	817fffc4 	addi	r5,r16,-1
 2008488:	04c00044 	movi	r19,1
 200848c:	0029883a 	mov	r20,zero
 2008490:	002b883a 	mov	r21,zero
 2008494:	d8800115 	stw	r2,4(sp)
 2008498:	dd800215 	stw	r22,8(sp)
 200849c:	d9400315 	stw	r5,12(sp)
 20084a0:	9f27c83a 	sub	r19,r19,fp
 20084a4:	ac6d883a 	add	r22,r21,r17
 20084a8:	b8c9883a 	add	r4,r23,r3
 20084ac:	000b883a 	mov	r5,zero
 20084b0:	b0cdc83a 	sub	r6,r22,r3
 20084b4:	200e4c00 	call	200e4c0 <memchr>
 20084b8:	103fcb1e 	bne	r2,zero,20083e8 <strstr+0xb4>
 20084bc:	b03fca26 	beq	r22,zero,20083e8 <strstr+0xb4>
 20084c0:	a007883a 	mov	r3,r20
 20084c4:	a700012e 	bgeu	r20,fp,20084cc <strstr+0x198>
 20084c8:	e007883a 	mov	r3,fp
 20084cc:	1c400f2e 	bgeu	r3,r17,200850c <strstr+0x1d8>
 20084d0:	b8c5883a 	add	r2,r23,r3
 20084d4:	80c9883a 	add	r4,r16,r3
 20084d8:	1545883a 	add	r2,r2,r21
 20084dc:	21000003 	ldbu	r4,0(r4)
 20084e0:	10800003 	ldbu	r2,0(r2)
 20084e4:	2080241e 	bne	r4,r2,2008578 <strstr+0x244>
 20084e8:	bd4d883a 	add	r6,r23,r21
 20084ec:	00000306 	br	20084fc <strstr+0x1c8>
 20084f0:	11000003 	ldbu	r4,0(r2)
 20084f4:	28800003 	ldbu	r2,0(r5)
 20084f8:	20801f1e 	bne	r4,r2,2008578 <strstr+0x244>
 20084fc:	18c00044 	addi	r3,r3,1
 2008500:	80c5883a 	add	r2,r16,r3
 2008504:	30cb883a 	add	r5,r6,r3
 2008508:	1c7ff936 	bltu	r3,r17,20084f0 <strstr+0x1bc>
 200850c:	9009883a 	mov	r4,r18
 2008510:	a700612e 	bgeu	r20,fp,2008698 <strstr+0x364>
 2008514:	d9400117 	ldw	r5,4(sp)
 2008518:	bd55883a 	add	r10,r23,r21
 200851c:	5485883a 	add	r2,r10,r18
 2008520:	28c00003 	ldbu	r3,0(r5)
 2008524:	10800003 	ldbu	r2,0(r2)
 2008528:	18805b1e 	bne	r3,r2,2008698 <strstr+0x364>
 200852c:	d9800317 	ldw	r6,12(sp)
 2008530:	d8c00217 	ldw	r3,8(sp)
 2008534:	3517883a 	add	r11,r6,r20
 2008538:	00000506 	br	2008550 <strstr+0x21c>
 200853c:	19800003 	ldbu	r6,0(r3)
 2008540:	29400003 	ldbu	r5,0(r5)
 2008544:	18ffffc4 	addi	r3,r3,-1
 2008548:	3140041e 	bne	r6,r5,200855c <strstr+0x228>
 200854c:	1009883a 	mov	r4,r2
 2008550:	20bfffc4 	addi	r2,r4,-1
 2008554:	508b883a 	add	r5,r10,r2
 2008558:	1afff81e 	bne	r3,r11,200853c <strstr+0x208>
 200855c:	a2000044 	addi	r8,r20,1
 2008560:	22004f36 	bltu	r4,r8,20086a0 <strstr+0x36c>
 2008564:	da000017 	ldw	r8,0(sp)
 2008568:	b007883a 	mov	r3,r22
 200856c:	aa2b883a 	add	r21,r21,r8
 2008570:	8a29c83a 	sub	r20,r17,r8
 2008574:	003fcb06 	br	20084a4 <strstr+0x170>
 2008578:	9d4f883a 	add	r7,r19,r21
 200857c:	38eb883a 	add	r21,r7,r3
 2008580:	0029883a 	mov	r20,zero
 2008584:	b007883a 	mov	r3,r22
 2008588:	003fc606 	br	20084a4 <strstr+0x170>
 200858c:	1025883a 	mov	r18,r2
 2008590:	003f8806 	br	20083b4 <strstr+0x80>
 2008594:	8f05c83a 	sub	r2,r17,fp
 2008598:	1700012e 	bgeu	r2,fp,20085a0 <strstr+0x26c>
 200859c:	e005883a 	mov	r2,fp
 20085a0:	e4bfffc4 	addi	r18,fp,-1
 20085a4:	10800044 	addi	r2,r2,1
 20085a8:	04c00044 	movi	r19,1
 20085ac:	848d883a 	add	r6,r16,r18
 20085b0:	d8800015 	stw	r2,0(sp)
 20085b4:	002d883a 	mov	r22,zero
 20085b8:	9f27c83a 	sub	r19,r19,fp
 20085bc:	d9800115 	stw	r6,4(sp)
 20085c0:	057fffc4 	movi	r21,-1
 20085c4:	b469883a 	add	r20,r22,r17
 20085c8:	b8c9883a 	add	r4,r23,r3
 20085cc:	000b883a 	mov	r5,zero
 20085d0:	a0cdc83a 	sub	r6,r20,r3
 20085d4:	200e4c00 	call	200e4c0 <memchr>
 20085d8:	103f831e 	bne	r2,zero,20083e8 <strstr+0xb4>
 20085dc:	a03f8226 	beq	r20,zero,20083e8 <strstr+0xb4>
 20085e0:	bd85883a 	add	r2,r23,r22
 20085e4:	e440102e 	bgeu	fp,r17,2008628 <strstr+0x2f4>
 20085e8:	bf05883a 	add	r2,r23,fp
 20085ec:	8707883a 	add	r3,r16,fp
 20085f0:	1585883a 	add	r2,r2,r22
 20085f4:	18c00003 	ldbu	r3,0(r3)
 20085f8:	10800003 	ldbu	r2,0(r2)
 20085fc:	18801a1e 	bne	r3,r2,2008668 <strstr+0x334>
 2008600:	e007883a 	mov	r3,fp
 2008604:	bd85883a 	add	r2,r23,r22
 2008608:	00000306 	br	2008618 <strstr+0x2e4>
 200860c:	39800003 	ldbu	r6,0(r7)
 2008610:	29400003 	ldbu	r5,0(r5)
 2008614:	3140151e 	bne	r6,r5,200866c <strstr+0x338>
 2008618:	18c00044 	addi	r3,r3,1
 200861c:	80cf883a 	add	r7,r16,r3
 2008620:	10cb883a 	add	r5,r2,r3
 2008624:	1c7ff936 	bltu	r3,r17,200860c <strstr+0x2d8>
 2008628:	9007883a 	mov	r3,r18
 200862c:	e03f8226 	beq	fp,zero,2008438 <strstr+0x104>
 2008630:	d9800117 	ldw	r6,4(sp)
 2008634:	1489883a 	add	r4,r2,r18
 2008638:	21000003 	ldbu	r4,0(r4)
 200863c:	31400003 	ldbu	r5,0(r6)
 2008640:	29000426 	beq	r5,r4,2008654 <strstr+0x320>
 2008644:	00000d06 	br	200867c <strstr+0x348>
 2008648:	29400003 	ldbu	r5,0(r5)
 200864c:	21000003 	ldbu	r4,0(r4)
 2008650:	29000a1e 	bne	r5,r4,200867c <strstr+0x348>
 2008654:	18ffffc4 	addi	r3,r3,-1
 2008658:	80cb883a 	add	r5,r16,r3
 200865c:	10c9883a 	add	r4,r2,r3
 2008660:	1d7ff91e 	bne	r3,r21,2008648 <strstr+0x314>
 2008664:	003f7406 	br	2008438 <strstr+0x104>
 2008668:	e007883a 	mov	r3,fp
 200866c:	9dad883a 	add	r22,r19,r22
 2008670:	b0ed883a 	add	r22,r22,r3
 2008674:	a007883a 	mov	r3,r20
 2008678:	003fd206 	br	20085c4 <strstr+0x290>
 200867c:	d8800017 	ldw	r2,0(sp)
 2008680:	a007883a 	mov	r3,r20
 2008684:	b0ad883a 	add	r22,r22,r2
 2008688:	003fce06 	br	20085c4 <strstr+0x290>
 200868c:	280f883a 	mov	r7,r5
 2008690:	02800044 	movi	r10,1
 2008694:	003f4406 	br	20083a8 <strstr+0x74>
 2008698:	e009883a 	mov	r4,fp
 200869c:	003faf06 	br	200855c <strstr+0x228>
 20086a0:	bd65883a 	add	r18,r23,r21
 20086a4:	003f4306 	br	20083b4 <strstr+0x80>

020086a8 <strtok>:
 20086a8:	00808174 	movhi	r2,517
 20086ac:	10903604 	addi	r2,r2,16600
 20086b0:	11800017 	ldw	r6,0(r2)
 20086b4:	01c00044 	movi	r7,1
 20086b8:	31801704 	addi	r6,r6,92
 20086bc:	20086c01 	jmpi	20086c0 <__strtok_r>

020086c0 <__strtok_r>:
 20086c0:	20002126 	beq	r4,zero,2008748 <__strtok_r+0x88>
 20086c4:	22800007 	ldb	r10,0(r4)
 20086c8:	22400044 	addi	r9,r4,1
 20086cc:	2807883a 	mov	r3,r5
 20086d0:	1a000007 	ldb	r8,0(r3)
 20086d4:	18c00044 	addi	r3,r3,1
 20086d8:	40000426 	beq	r8,zero,20086ec <__strtok_r+0x2c>
 20086dc:	523ffc1e 	bne	r10,r8,20086d0 <__strtok_r+0x10>
 20086e0:	38001526 	beq	r7,zero,2008738 <__strtok_r+0x78>
 20086e4:	4809883a 	mov	r4,r9
 20086e8:	003ff606 	br	20086c4 <__strtok_r+0x4>
 20086ec:	4805883a 	mov	r2,r9
 20086f0:	5000021e 	bne	r10,zero,20086fc <__strtok_r+0x3c>
 20086f4:	00001806 	br	2008758 <__strtok_r+0x98>
 20086f8:	3800031e 	bne	r7,zero,2008708 <__strtok_r+0x48>
 20086fc:	4a000007 	ldb	r8,0(r9)
 2008700:	2807883a 	mov	r3,r5
 2008704:	4a400044 	addi	r9,r9,1
 2008708:	19c00007 	ldb	r7,0(r3)
 200870c:	18c00044 	addi	r3,r3,1
 2008710:	41fff91e 	bne	r8,r7,20086f8 <__strtok_r+0x38>
 2008714:	40000426 	beq	r8,zero,2008728 <__strtok_r+0x68>
 2008718:	483fffc5 	stb	zero,-1(r9)
 200871c:	32400015 	stw	r9,0(r6)
 2008720:	10bfffc4 	addi	r2,r2,-1
 2008724:	f800283a 	ret
 2008728:	0013883a 	mov	r9,zero
 200872c:	32400015 	stw	r9,0(r6)
 2008730:	10bfffc4 	addi	r2,r2,-1
 2008734:	f800283a 	ret
 2008738:	32400015 	stw	r9,0(r6)
 200873c:	483fffc5 	stb	zero,-1(r9)
 2008740:	2005883a 	mov	r2,r4
 2008744:	f800283a 	ret
 2008748:	31000017 	ldw	r4,0(r6)
 200874c:	203fdd1e 	bne	r4,zero,20086c4 <__strtok_r+0x4>
 2008750:	0005883a 	mov	r2,zero
 2008754:	f800283a 	ret
 2008758:	30000015 	stw	zero,0(r6)
 200875c:	0005883a 	mov	r2,zero
 2008760:	f800283a 	ret

02008764 <strtok_r>:
 2008764:	01c00044 	movi	r7,1
 2008768:	20086c01 	jmpi	20086c0 <__strtok_r>

0200876c <_strtol_r>:
 200876c:	defff404 	addi	sp,sp,-48
 2008770:	00808174 	movhi	r2,517
 2008774:	10903404 	addi	r2,r2,16592
 2008778:	dcc00515 	stw	r19,20(sp)
 200877c:	14c00017 	ldw	r19,0(r2)
 2008780:	ddc00915 	stw	r23,36(sp)
 2008784:	dd800815 	stw	r22,32(sp)
 2008788:	dd000615 	stw	r20,24(sp)
 200878c:	dc000215 	stw	r16,8(sp)
 2008790:	dfc00b15 	stw	ra,44(sp)
 2008794:	df000a15 	stw	fp,40(sp)
 2008798:	dd400715 	stw	r21,28(sp)
 200879c:	dc800415 	stw	r18,16(sp)
 20087a0:	dc400315 	stw	r17,12(sp)
 20087a4:	282d883a 	mov	r22,r5
 20087a8:	d9000015 	stw	r4,0(sp)
 20087ac:	302f883a 	mov	r23,r6
 20087b0:	3829883a 	mov	r20,r7
 20087b4:	2821883a 	mov	r16,r5
 20087b8:	84400007 	ldb	r17,0(r16)
 20087bc:	84000044 	addi	r16,r16,1
 20087c0:	9c45883a 	add	r2,r19,r17
 20087c4:	10800003 	ldbu	r2,0(r2)
 20087c8:	1080020c 	andi	r2,r2,8
 20087cc:	10803fcc 	andi	r2,r2,255
 20087d0:	1080201c 	xori	r2,r2,128
 20087d4:	10bfe004 	addi	r2,r2,-128
 20087d8:	103ff71e 	bne	r2,zero,20087b8 <_strtol_r+0x4c>
 20087dc:	00800b44 	movi	r2,45
 20087e0:	88806926 	beq	r17,r2,2008988 <_strtol_r+0x21c>
 20087e4:	00800ac4 	movi	r2,43
 20087e8:	88806b26 	beq	r17,r2,2008998 <_strtol_r+0x22c>
 20087ec:	0039883a 	mov	fp,zero
 20087f0:	a000451e 	bne	r20,zero,2008908 <_strtol_r+0x19c>
 20087f4:	00800c04 	movi	r2,48
 20087f8:	88804726 	beq	r17,r2,2008918 <_strtol_r+0x1ac>
 20087fc:	05000284 	movi	r20,10
 2008800:	a02b883a 	mov	r21,r20
 2008804:	e0004e26 	beq	fp,zero,2008940 <_strtol_r+0x1d4>
 2008808:	04a00034 	movhi	r18,32768
 200880c:	9009883a 	mov	r4,r18
 2008810:	a80b883a 	mov	r5,r21
 2008814:	20147a40 	call	20147a4 <__umodsi3>
 2008818:	9009883a 	mov	r4,r18
 200881c:	a80b883a 	mov	r5,r21
 2008820:	d8800115 	stw	r2,4(sp)
 2008824:	201479c0 	call	201479c <__udivsi3>
 2008828:	9c47883a 	add	r3,r19,r17
 200882c:	18c00003 	ldbu	r3,0(r3)
 2008830:	100f883a 	mov	r7,r2
 2008834:	0013883a 	mov	r9,zero
 2008838:	1a00010c 	andi	r8,r3,4
 200883c:	42003fcc 	andi	r8,r8,255
 2008840:	4200201c 	xori	r8,r8,128
 2008844:	423fe004 	addi	r8,r8,-128
 2008848:	0009883a 	mov	r4,zero
 200884c:	02bfffc4 	movi	r10,-1
 2008850:	d9800117 	ldw	r6,4(sp)
 2008854:	40001126 	beq	r8,zero,200889c <_strtol_r+0x130>
 2008858:	8c7ff404 	addi	r17,r17,-48
 200885c:	8d00160e 	bge	r17,r20,20088b8 <_strtol_r+0x14c>
 2008860:	4a800526 	beq	r9,r10,2008878 <_strtol_r+0x10c>
 2008864:	39003a36 	bltu	r7,r4,2008950 <_strtol_r+0x1e4>
 2008868:	21c03826 	beq	r4,r7,200894c <_strtol_r+0x1e0>
 200886c:	2549383a 	mul	r4,r4,r21
 2008870:	02400044 	movi	r9,1
 2008874:	8909883a 	add	r4,r17,r4
 2008878:	84400007 	ldb	r17,0(r16)
 200887c:	84000044 	addi	r16,r16,1
 2008880:	9c47883a 	add	r3,r19,r17
 2008884:	18c00003 	ldbu	r3,0(r3)
 2008888:	1a00010c 	andi	r8,r3,4
 200888c:	42003fcc 	andi	r8,r8,255
 2008890:	4200201c 	xori	r8,r8,128
 2008894:	423fe004 	addi	r8,r8,-128
 2008898:	403fef1e 	bne	r8,zero,2008858 <_strtol_r+0xec>
 200889c:	1a0000cc 	andi	r8,r3,3
 20088a0:	40000526 	beq	r8,zero,20088b8 <_strtol_r+0x14c>
 20088a4:	18c0004c 	andi	r3,r3,1
 20088a8:	18002b26 	beq	r3,zero,2008958 <_strtol_r+0x1ec>
 20088ac:	00800dc4 	movi	r2,55
 20088b0:	88a3c83a 	sub	r17,r17,r2
 20088b4:	8d3fea16 	blt	r17,r20,2008860 <_strtol_r+0xf4>
 20088b8:	00bfffc4 	movi	r2,-1
 20088bc:	48802926 	beq	r9,r2,2008964 <_strtol_r+0x1f8>
 20088c0:	e0000126 	beq	fp,zero,20088c8 <_strtol_r+0x15c>
 20088c4:	0109c83a 	sub	r4,zero,r4
 20088c8:	2005883a 	mov	r2,r4
 20088cc:	b8000226 	beq	r23,zero,20088d8 <_strtol_r+0x16c>
 20088d0:	48002b1e 	bne	r9,zero,2008980 <_strtol_r+0x214>
 20088d4:	bd800015 	stw	r22,0(r23)
 20088d8:	dfc00b17 	ldw	ra,44(sp)
 20088dc:	df000a17 	ldw	fp,40(sp)
 20088e0:	ddc00917 	ldw	r23,36(sp)
 20088e4:	dd800817 	ldw	r22,32(sp)
 20088e8:	dd400717 	ldw	r21,28(sp)
 20088ec:	dd000617 	ldw	r20,24(sp)
 20088f0:	dcc00517 	ldw	r19,20(sp)
 20088f4:	dc800417 	ldw	r18,16(sp)
 20088f8:	dc400317 	ldw	r17,12(sp)
 20088fc:	dc000217 	ldw	r16,8(sp)
 2008900:	dec00c04 	addi	sp,sp,48
 2008904:	f800283a 	ret
 2008908:	00800404 	movi	r2,16
 200890c:	a0bfbc1e 	bne	r20,r2,2008800 <_strtol_r+0x94>
 2008910:	00800c04 	movi	r2,48
 2008914:	88bfba1e 	bne	r17,r2,2008800 <_strtol_r+0x94>
 2008918:	80800007 	ldb	r2,0(r16)
 200891c:	00c01e04 	movi	r3,120
 2008920:	10c02326 	beq	r2,r3,20089b0 <_strtol_r+0x244>
 2008924:	00c01604 	movi	r3,88
 2008928:	10c02126 	beq	r2,r3,20089b0 <_strtol_r+0x244>
 200892c:	a000251e 	bne	r20,zero,20089c4 <_strtol_r+0x258>
 2008930:	05400204 	movi	r21,8
 2008934:	04400c04 	movi	r17,48
 2008938:	a829883a 	mov	r20,r21
 200893c:	e03fb21e 	bne	fp,zero,2008808 <_strtol_r+0x9c>
 2008940:	04a00034 	movhi	r18,32768
 2008944:	94bfffc4 	addi	r18,r18,-1
 2008948:	003fb006 	br	200880c <_strtol_r+0xa0>
 200894c:	347fc70e 	bge	r6,r17,200886c <_strtol_r+0x100>
 2008950:	027fffc4 	movi	r9,-1
 2008954:	003fc806 	br	2008878 <_strtol_r+0x10c>
 2008958:	008015c4 	movi	r2,87
 200895c:	88a3c83a 	sub	r17,r17,r2
 2008960:	003fd406 	br	20088b4 <_strtol_r+0x148>
 2008964:	e000101e 	bne	fp,zero,20089a8 <_strtol_r+0x23c>
 2008968:	00a00034 	movhi	r2,32768
 200896c:	10bfffc4 	addi	r2,r2,-1
 2008970:	d9000017 	ldw	r4,0(sp)
 2008974:	00c00884 	movi	r3,34
 2008978:	20c00015 	stw	r3,0(r4)
 200897c:	b83fd626 	beq	r23,zero,20088d8 <_strtol_r+0x16c>
 2008980:	85bfffc4 	addi	r22,r16,-1
 2008984:	003fd306 	br	20088d4 <_strtol_r+0x168>
 2008988:	07000044 	movi	fp,1
 200898c:	84400007 	ldb	r17,0(r16)
 2008990:	8721883a 	add	r16,r16,fp
 2008994:	003f9606 	br	20087f0 <_strtol_r+0x84>
 2008998:	84400007 	ldb	r17,0(r16)
 200899c:	0039883a 	mov	fp,zero
 20089a0:	84000044 	addi	r16,r16,1
 20089a4:	003f9206 	br	20087f0 <_strtol_r+0x84>
 20089a8:	00a00034 	movhi	r2,32768
 20089ac:	003ff006 	br	2008970 <_strtol_r+0x204>
 20089b0:	05400404 	movi	r21,16
 20089b4:	84400047 	ldb	r17,1(r16)
 20089b8:	a829883a 	mov	r20,r21
 20089bc:	84000084 	addi	r16,r16,2
 20089c0:	003f9006 	br	2008804 <_strtol_r+0x98>
 20089c4:	a02b883a 	mov	r21,r20
 20089c8:	04400c04 	movi	r17,48
 20089cc:	003f8d06 	br	2008804 <_strtol_r+0x98>

020089d0 <strtol>:
 20089d0:	00808174 	movhi	r2,517
 20089d4:	10903604 	addi	r2,r2,16600
 20089d8:	2007883a 	mov	r3,r4
 20089dc:	11000017 	ldw	r4,0(r2)
 20089e0:	2805883a 	mov	r2,r5
 20089e4:	300f883a 	mov	r7,r6
 20089e8:	180b883a 	mov	r5,r3
 20089ec:	100d883a 	mov	r6,r2
 20089f0:	200876c1 	jmpi	200876c <_strtol_r>

020089f4 <_user_strerror>:
 20089f4:	0005883a 	mov	r2,zero
 20089f8:	f800283a 	ret

020089fc <__sprint_r>:
 20089fc:	30800217 	ldw	r2,8(r6)
 2008a00:	defffe04 	addi	sp,sp,-8
 2008a04:	dc000015 	stw	r16,0(sp)
 2008a08:	dfc00115 	stw	ra,4(sp)
 2008a0c:	3021883a 	mov	r16,r6
 2008a10:	10000226 	beq	r2,zero,2008a1c <__sprint_r+0x20>
 2008a14:	200dd100 	call	200dd10 <__sfvwrite_r>
 2008a18:	80000215 	stw	zero,8(r16)
 2008a1c:	80000115 	stw	zero,4(r16)
 2008a20:	dfc00117 	ldw	ra,4(sp)
 2008a24:	dc000017 	ldw	r16,0(sp)
 2008a28:	dec00204 	addi	sp,sp,8
 2008a2c:	f800283a 	ret

02008a30 <___vfprintf_internal_r>:
 2008a30:	defeb904 	addi	sp,sp,-1308
 2008a34:	dc013d15 	stw	r16,1268(sp)
 2008a38:	d9013015 	stw	r4,1216(sp)
 2008a3c:	dfc14615 	stw	ra,1304(sp)
 2008a40:	df014515 	stw	fp,1300(sp)
 2008a44:	ddc14415 	stw	r23,1296(sp)
 2008a48:	dd814315 	stw	r22,1292(sp)
 2008a4c:	dd414215 	stw	r21,1288(sp)
 2008a50:	dd014115 	stw	r20,1284(sp)
 2008a54:	dcc14015 	stw	r19,1280(sp)
 2008a58:	dc813f15 	stw	r18,1276(sp)
 2008a5c:	dc413e15 	stw	r17,1272(sp)
 2008a60:	d9412915 	stw	r5,1188(sp)
 2008a64:	3021883a 	mov	r16,r6
 2008a68:	d9c12d15 	stw	r7,1204(sp)
 2008a6c:	200e3380 	call	200e338 <_localeconv_r>
 2008a70:	10800017 	ldw	r2,0(r2)
 2008a74:	d9013017 	ldw	r4,1216(sp)
 2008a78:	d8013315 	stw	zero,1228(sp)
 2008a7c:	d8813715 	stw	r2,1244(sp)
 2008a80:	d8013415 	stw	zero,1232(sp)
 2008a84:	20000226 	beq	r4,zero,2008a90 <___vfprintf_internal_r+0x60>
 2008a88:	20800e17 	ldw	r2,56(r4)
 2008a8c:	10019826 	beq	r2,zero,20090f0 <___vfprintf_internal_r+0x6c0>
 2008a90:	da012917 	ldw	r8,1188(sp)
 2008a94:	4080030b 	ldhu	r2,12(r8)
 2008a98:	10c0020c 	andi	r3,r2,8
 2008a9c:	18ffffcc 	andi	r3,r3,65535
 2008aa0:	18e0001c 	xori	r3,r3,32768
 2008aa4:	18e00004 	addi	r3,r3,-32768
 2008aa8:	18013a26 	beq	r3,zero,2008f94 <___vfprintf_internal_r+0x564>
 2008aac:	40c00417 	ldw	r3,16(r8)
 2008ab0:	18013826 	beq	r3,zero,2008f94 <___vfprintf_internal_r+0x564>
 2008ab4:	1100068c 	andi	r4,r2,26
 2008ab8:	00c00284 	movi	r3,10
 2008abc:	20c13e26 	beq	r4,r3,2008fb8 <___vfprintf_internal_r+0x588>
 2008ac0:	da010dc4 	addi	r8,sp,1079
 2008ac4:	d8800404 	addi	r2,sp,16
 2008ac8:	da012615 	stw	r8,1176(sp)
 2008acc:	d8811b15 	stw	r2,1132(sp)
 2008ad0:	1013883a 	mov	r9,r2
 2008ad4:	d8812617 	ldw	r2,1176(sp)
 2008ad8:	da010e04 	addi	r8,sp,1080
 2008adc:	dc413017 	ldw	r17,1216(sp)
 2008ae0:	da012715 	stw	r8,1180(sp)
 2008ae4:	4091c83a 	sub	r8,r8,r2
 2008ae8:	d8011d15 	stw	zero,1140(sp)
 2008aec:	d8011c15 	stw	zero,1136(sp)
 2008af0:	802b883a 	mov	r21,r16
 2008af4:	d8013215 	stw	zero,1224(sp)
 2008af8:	d8013615 	stw	zero,1240(sp)
 2008afc:	d8013515 	stw	zero,1236(sp)
 2008b00:	d8012c15 	stw	zero,1200(sp)
 2008b04:	da013915 	stw	r8,1252(sp)
 2008b08:	a8800007 	ldb	r2,0(r21)
 2008b0c:	1002ec26 	beq	r2,zero,20096c0 <___vfprintf_internal_r+0xc90>
 2008b10:	00c00944 	movi	r3,37
 2008b14:	a825883a 	mov	r18,r21
 2008b18:	10c0021e 	bne	r2,r3,2008b24 <___vfprintf_internal_r+0xf4>
 2008b1c:	00001406 	br	2008b70 <___vfprintf_internal_r+0x140>
 2008b20:	10c00326 	beq	r2,r3,2008b30 <___vfprintf_internal_r+0x100>
 2008b24:	94800044 	addi	r18,r18,1
 2008b28:	90800007 	ldb	r2,0(r18)
 2008b2c:	103ffc1e 	bne	r2,zero,2008b20 <___vfprintf_internal_r+0xf0>
 2008b30:	9561c83a 	sub	r16,r18,r21
 2008b34:	80000e26 	beq	r16,zero,2008b70 <___vfprintf_internal_r+0x140>
 2008b38:	da011d17 	ldw	r8,1140(sp)
 2008b3c:	d8c11c17 	ldw	r3,1136(sp)
 2008b40:	4d400015 	stw	r21,0(r9)
 2008b44:	4c000115 	stw	r16,4(r9)
 2008b48:	4411883a 	add	r8,r8,r16
 2008b4c:	18c00044 	addi	r3,r3,1
 2008b50:	da011d15 	stw	r8,1140(sp)
 2008b54:	d8c11c15 	stw	r3,1136(sp)
 2008b58:	008001c4 	movi	r2,7
 2008b5c:	10c15d16 	blt	r2,r3,20090d4 <___vfprintf_internal_r+0x6a4>
 2008b60:	4a400204 	addi	r9,r9,8
 2008b64:	d8812c17 	ldw	r2,1200(sp)
 2008b68:	1405883a 	add	r2,r2,r16
 2008b6c:	d8812c15 	stw	r2,1200(sp)
 2008b70:	90800007 	ldb	r2,0(r18)
 2008b74:	10013b26 	beq	r2,zero,2009064 <___vfprintf_internal_r+0x634>
 2008b78:	95400044 	addi	r21,r18,1
 2008b7c:	94800047 	ldb	r18,1(r18)
 2008b80:	d8012585 	stb	zero,1174(sp)
 2008b84:	073fffc4 	movi	fp,-1
 2008b88:	d8012e15 	stw	zero,1208(sp)
 2008b8c:	0021883a 	mov	r16,zero
 2008b90:	00c01604 	movi	r3,88
 2008b94:	01400244 	movi	r5,9
 2008b98:	02800a84 	movi	r10,42
 2008b9c:	01c01b04 	movi	r7,108
 2008ba0:	01800ac4 	movi	r6,43
 2008ba4:	02c00804 	movi	r11,32
 2008ba8:	ad400044 	addi	r21,r21,1
 2008bac:	90bff804 	addi	r2,r18,-32
 2008bb0:	1880092e 	bgeu	r3,r2,2008bd8 <___vfprintf_internal_r+0x1a8>
 2008bb4:	90012b26 	beq	r18,zero,2009064 <___vfprintf_internal_r+0x634>
 2008bb8:	00c00044 	movi	r3,1
 2008bbc:	d8c12815 	stw	r3,1184(sp)
 2008bc0:	dc810405 	stb	r18,1040(sp)
 2008bc4:	d8012585 	stb	zero,1174(sp)
 2008bc8:	d8c12b15 	stw	r3,1196(sp)
 2008bcc:	dcc10404 	addi	r19,sp,1040
 2008bd0:	d8013115 	stw	zero,1220(sp)
 2008bd4:	00008806 	br	2008df8 <___vfprintf_internal_r+0x3c8>
 2008bd8:	1085883a 	add	r2,r2,r2
 2008bdc:	1085883a 	add	r2,r2,r2
 2008be0:	01008074 	movhi	r4,513
 2008be4:	2122fd04 	addi	r4,r4,-29708
 2008be8:	1105883a 	add	r2,r2,r4
 2008bec:	10800017 	ldw	r2,0(r2)
 2008bf0:	1000683a 	jmp	r2
 2008bf4:	020091a8 	cmpgeui	r8,zero,582
 2008bf8:	02008bb4 	movhi	r8,558
 2008bfc:	02008bb4 	movhi	r8,558
 2008c00:	020091bc 	xorhi	r8,zero,582
 2008c04:	02008bb4 	movhi	r8,558
 2008c08:	02008bb4 	movhi	r8,558
 2008c0c:	02008bb4 	movhi	r8,558
 2008c10:	02008bb4 	movhi	r8,558
 2008c14:	02008bb4 	movhi	r8,558
 2008c18:	02008bb4 	movhi	r8,558
 2008c1c:	020092a4 	muli	r8,zero,586
 2008c20:	02009160 	cmpeqi	r8,zero,581
 2008c24:	02008bb4 	movhi	r8,558
 2008c28:	02008f88 	cmpgei	r8,zero,574
 2008c2c:	0200916c 	andhi	r8,zero,581
 2008c30:	02008bb4 	movhi	r8,558
 2008c34:	020091c8 	cmpgei	r8,zero,583
 2008c38:	020092c8 	cmpgei	r8,zero,587
 2008c3c:	020092c8 	cmpgei	r8,zero,587
 2008c40:	020092c8 	cmpgei	r8,zero,587
 2008c44:	020092c8 	cmpgei	r8,zero,587
 2008c48:	020092c8 	cmpgei	r8,zero,587
 2008c4c:	020092c8 	cmpgei	r8,zero,587
 2008c50:	020092c8 	cmpgei	r8,zero,587
 2008c54:	020092c8 	cmpgei	r8,zero,587
 2008c58:	020092c8 	cmpgei	r8,zero,587
 2008c5c:	02008bb4 	movhi	r8,558
 2008c60:	02008bb4 	movhi	r8,558
 2008c64:	02008bb4 	movhi	r8,558
 2008c68:	02008bb4 	movhi	r8,558
 2008c6c:	02008bb4 	movhi	r8,558
 2008c70:	02008bb4 	movhi	r8,558
 2008c74:	02008bb4 	movhi	r8,558
 2008c78:	02008bb4 	movhi	r8,558
 2008c7c:	02008bb4 	movhi	r8,558
 2008c80:	02008bb4 	movhi	r8,558
 2008c84:	02008f24 	muli	r8,zero,572
 2008c88:	020092f0 	cmpltui	r8,zero,587
 2008c8c:	02008bb4 	movhi	r8,558
 2008c90:	020092f0 	cmpltui	r8,zero,587
 2008c94:	02008bb4 	movhi	r8,558
 2008c98:	02008bb4 	movhi	r8,558
 2008c9c:	02008bb4 	movhi	r8,558
 2008ca0:	02008bb4 	movhi	r8,558
 2008ca4:	02009460 	cmpeqi	r8,zero,593
 2008ca8:	02008bb4 	movhi	r8,558
 2008cac:	02008bb4 	movhi	r8,558
 2008cb0:	02008eec 	andhi	r8,zero,571
 2008cb4:	02008bb4 	movhi	r8,558
 2008cb8:	02008bb4 	movhi	r8,558
 2008cbc:	02008bb4 	movhi	r8,558
 2008cc0:	02008bb4 	movhi	r8,558
 2008cc4:	02008bb4 	movhi	r8,558
 2008cc8:	02008d58 	cmpnei	r8,zero,565
 2008ccc:	02008bb4 	movhi	r8,558
 2008cd0:	02008bb4 	movhi	r8,558
 2008cd4:	020091d4 	movui	r8,583
 2008cd8:	02008bb4 	movhi	r8,558
 2008cdc:	02008bb4 	movhi	r8,558
 2008ce0:	02008bb4 	movhi	r8,558
 2008ce4:	02008bb4 	movhi	r8,558
 2008ce8:	02008bb4 	movhi	r8,558
 2008cec:	02008bb4 	movhi	r8,558
 2008cf0:	02008bb4 	movhi	r8,558
 2008cf4:	02008bb4 	movhi	r8,558
 2008cf8:	02008bb4 	movhi	r8,558
 2008cfc:	02008bb4 	movhi	r8,558
 2008d00:	02009248 	cmpgei	r8,zero,585
 2008d04:	02008f28 	cmpgeui	r8,zero,572
 2008d08:	020092f0 	cmpltui	r8,zero,587
 2008d0c:	020092f0 	cmpltui	r8,zero,587
 2008d10:	020092f0 	cmpltui	r8,zero,587
 2008d14:	02009228 	cmpgeui	r8,zero,584
 2008d18:	02008f28 	cmpgeui	r8,zero,572
 2008d1c:	02008bb4 	movhi	r8,558
 2008d20:	02008bb4 	movhi	r8,558
 2008d24:	02009234 	movhi	r8,584
 2008d28:	02008bb4 	movhi	r8,558
 2008d2c:	02009278 	rdprs	r8,zero,585
 2008d30:	02008ef0 	cmpltui	r8,zero,571
 2008d34:	02009378 	rdprs	r8,zero,589
 2008d38:	020093c4 	movi	r8,591
 2008d3c:	02008bb4 	movhi	r8,558
 2008d40:	020093d0 	cmplti	r8,zero,591
 2008d44:	02008bb4 	movhi	r8,558
 2008d48:	02008d5c 	xori	r8,zero,565
 2008d4c:	02008bb4 	movhi	r8,558
 2008d50:	02008bb4 	movhi	r8,558
 2008d54:	0200942c 	andhi	r8,zero,592
 2008d58:	84000414 	ori	r16,r16,16
 2008d5c:	8080080c 	andi	r2,r16,32
 2008d60:	1000f51e 	bne	r2,zero,2009138 <___vfprintf_internal_r+0x708>
 2008d64:	8080040c 	andi	r2,r16,16
 2008d68:	10042c26 	beq	r2,zero,2009e1c <___vfprintf_internal_r+0x13ec>
 2008d6c:	da012d17 	ldw	r8,1204(sp)
 2008d70:	002d883a 	mov	r22,zero
 2008d74:	00c00044 	movi	r3,1
 2008d78:	45c00017 	ldw	r23,0(r8)
 2008d7c:	42000104 	addi	r8,r8,4
 2008d80:	da012d15 	stw	r8,1204(sp)
 2008d84:	b805883a 	mov	r2,r23
 2008d88:	d8012585 	stb	zero,1174(sp)
 2008d8c:	e0000216 	blt	fp,zero,2008d98 <___vfprintf_internal_r+0x368>
 2008d90:	013fdfc4 	movi	r4,-129
 2008d94:	8120703a 	and	r16,r16,r4
 2008d98:	1002671e 	bne	r2,zero,2009738 <___vfprintf_internal_r+0xd08>
 2008d9c:	e002661e 	bne	fp,zero,2009738 <___vfprintf_internal_r+0xd08>
 2008da0:	18c03fcc 	andi	r3,r3,255
 2008da4:	1803561e 	bne	r3,zero,2009b00 <___vfprintf_internal_r+0x10d0>
 2008da8:	8080004c 	andi	r2,r16,1
 2008dac:	10035426 	beq	r2,zero,2009b00 <___vfprintf_internal_r+0x10d0>
 2008db0:	da013917 	ldw	r8,1252(sp)
 2008db4:	00800c04 	movi	r2,48
 2008db8:	d8810dc5 	stb	r2,1079(sp)
 2008dbc:	da012b15 	stw	r8,1196(sp)
 2008dc0:	dcc10dc4 	addi	r19,sp,1079
 2008dc4:	d8812b17 	ldw	r2,1196(sp)
 2008dc8:	d8812815 	stw	r2,1184(sp)
 2008dcc:	1700010e 	bge	r2,fp,2008dd4 <___vfprintf_internal_r+0x3a4>
 2008dd0:	df012815 	stw	fp,1184(sp)
 2008dd4:	d8812583 	ldbu	r2,1174(sp)
 2008dd8:	df013115 	stw	fp,1220(sp)
 2008ddc:	10803fcc 	andi	r2,r2,255
 2008de0:	1080201c 	xori	r2,r2,128
 2008de4:	10bfe004 	addi	r2,r2,-128
 2008de8:	10000326 	beq	r2,zero,2008df8 <___vfprintf_internal_r+0x3c8>
 2008dec:	da012817 	ldw	r8,1184(sp)
 2008df0:	42000044 	addi	r8,r8,1
 2008df4:	da012815 	stw	r8,1184(sp)
 2008df8:	80c0008c 	andi	r3,r16,2
 2008dfc:	d8c12a15 	stw	r3,1192(sp)
 2008e00:	18000326 	beq	r3,zero,2008e10 <___vfprintf_internal_r+0x3e0>
 2008e04:	da012817 	ldw	r8,1184(sp)
 2008e08:	42000084 	addi	r8,r8,2
 2008e0c:	da012815 	stw	r8,1184(sp)
 2008e10:	80c0210c 	andi	r3,r16,132
 2008e14:	d8c12f15 	stw	r3,1212(sp)
 2008e18:	1801941e 	bne	r3,zero,200946c <___vfprintf_internal_r+0xa3c>
 2008e1c:	da012e17 	ldw	r8,1208(sp)
 2008e20:	d8c12817 	ldw	r3,1184(sp)
 2008e24:	40edc83a 	sub	r22,r8,r3
 2008e28:	0581900e 	bge	zero,r22,200946c <___vfprintf_internal_r+0xa3c>
 2008e2c:	02800404 	movi	r10,16
 2008e30:	da011d17 	ldw	r8,1140(sp)
 2008e34:	d8c11c17 	ldw	r3,1136(sp)
 2008e38:	05c08174 	movhi	r23,517
 2008e3c:	bdf79484 	addi	r23,r23,-8622
 2008e40:	5580200e 	bge	r10,r22,2008ec4 <___vfprintf_internal_r+0x494>
 2008e44:	dc813815 	stw	r18,1248(sp)
 2008e48:	5039883a 	mov	fp,r10
 2008e4c:	b825883a 	mov	r18,r23
 2008e50:	050001c4 	movi	r20,7
 2008e54:	b02f883a 	mov	r23,r22
 2008e58:	802d883a 	mov	r22,r16
 2008e5c:	dc012917 	ldw	r16,1188(sp)
 2008e60:	00000306 	br	2008e70 <___vfprintf_internal_r+0x440>
 2008e64:	bdfffc04 	addi	r23,r23,-16
 2008e68:	4a400204 	addi	r9,r9,8
 2008e6c:	e5c0110e 	bge	fp,r23,2008eb4 <___vfprintf_internal_r+0x484>
 2008e70:	4c800015 	stw	r18,0(r9)
 2008e74:	4f000115 	stw	fp,4(r9)
 2008e78:	42000404 	addi	r8,r8,16
 2008e7c:	18c00044 	addi	r3,r3,1
 2008e80:	da011d15 	stw	r8,1140(sp)
 2008e84:	d8c11c15 	stw	r3,1136(sp)
 2008e88:	a0fff60e 	bge	r20,r3,2008e64 <___vfprintf_internal_r+0x434>
 2008e8c:	8809883a 	mov	r4,r17
 2008e90:	800b883a 	mov	r5,r16
 2008e94:	d9811b04 	addi	r6,sp,1132
 2008e98:	20089fc0 	call	20089fc <__sprint_r>
 2008e9c:	1000771e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2008ea0:	bdfffc04 	addi	r23,r23,-16
 2008ea4:	da011d17 	ldw	r8,1140(sp)
 2008ea8:	d8c11c17 	ldw	r3,1136(sp)
 2008eac:	da400404 	addi	r9,sp,16
 2008eb0:	e5ffef16 	blt	fp,r23,2008e70 <___vfprintf_internal_r+0x440>
 2008eb4:	b021883a 	mov	r16,r22
 2008eb8:	b82d883a 	mov	r22,r23
 2008ebc:	902f883a 	mov	r23,r18
 2008ec0:	dc813817 	ldw	r18,1248(sp)
 2008ec4:	4dc00015 	stw	r23,0(r9)
 2008ec8:	4d800115 	stw	r22,4(r9)
 2008ecc:	4591883a 	add	r8,r8,r22
 2008ed0:	18c00044 	addi	r3,r3,1
 2008ed4:	da011d15 	stw	r8,1140(sp)
 2008ed8:	d8c11c15 	stw	r3,1136(sp)
 2008edc:	008001c4 	movi	r2,7
 2008ee0:	10c36d16 	blt	r2,r3,2009c98 <___vfprintf_internal_r+0x1268>
 2008ee4:	4a400204 	addi	r9,r9,8
 2008ee8:	00016206 	br	2009474 <___vfprintf_internal_r+0xa44>
 2008eec:	84000414 	ori	r16,r16,16
 2008ef0:	8080080c 	andi	r2,r16,32
 2008ef4:	1000801e 	bne	r2,zero,20090f8 <___vfprintf_internal_r+0x6c8>
 2008ef8:	8080040c 	andi	r2,r16,16
 2008efc:	1003da26 	beq	r2,zero,2009e68 <___vfprintf_internal_r+0x1438>
 2008f00:	d8c12d17 	ldw	r3,1204(sp)
 2008f04:	002d883a 	mov	r22,zero
 2008f08:	1dc00017 	ldw	r23,0(r3)
 2008f0c:	18c00104 	addi	r3,r3,4
 2008f10:	d8c12d15 	stw	r3,1204(sp)
 2008f14:	b805883a 	mov	r2,r23
 2008f18:	0007883a 	mov	r3,zero
 2008f1c:	d8012585 	stb	zero,1174(sp)
 2008f20:	003f9a06 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2008f24:	84000414 	ori	r16,r16,16
 2008f28:	8080080c 	andi	r2,r16,32
 2008f2c:	10007b1e 	bne	r2,zero,200911c <___vfprintf_internal_r+0x6ec>
 2008f30:	8080040c 	andi	r2,r16,16
 2008f34:	1003ed26 	beq	r2,zero,2009eec <___vfprintf_internal_r+0x14bc>
 2008f38:	d9012d17 	ldw	r4,1204(sp)
 2008f3c:	25c00017 	ldw	r23,0(r4)
 2008f40:	21000104 	addi	r4,r4,4
 2008f44:	d9012d15 	stw	r4,1204(sp)
 2008f48:	b82dd7fa 	srai	r22,r23,31
 2008f4c:	b005883a 	mov	r2,r22
 2008f50:	1003230e 	bge	r2,zero,2009be0 <___vfprintf_internal_r+0x11b0>
 2008f54:	05efc83a 	sub	r23,zero,r23
 2008f58:	b804c03a 	cmpne	r2,r23,zero
 2008f5c:	05adc83a 	sub	r22,zero,r22
 2008f60:	b0adc83a 	sub	r22,r22,r2
 2008f64:	00800b44 	movi	r2,45
 2008f68:	d8812585 	stb	r2,1174(sp)
 2008f6c:	00c00044 	movi	r3,1
 2008f70:	bd84b03a 	or	r2,r23,r22
 2008f74:	003f8506 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2008f78:	da012e17 	ldw	r8,1208(sp)
 2008f7c:	d8812d15 	stw	r2,1204(sp)
 2008f80:	0211c83a 	sub	r8,zero,r8
 2008f84:	da012e15 	stw	r8,1208(sp)
 2008f88:	84000114 	ori	r16,r16,4
 2008f8c:	ac800007 	ldb	r18,0(r21)
 2008f90:	003f0506 	br	2008ba8 <___vfprintf_internal_r+0x178>
 2008f94:	d9013017 	ldw	r4,1216(sp)
 2008f98:	d9412917 	ldw	r5,1188(sp)
 2008f9c:	200c1480 	call	200c148 <__swsetup_r>
 2008fa0:	10003d1e 	bne	r2,zero,2009098 <___vfprintf_internal_r+0x668>
 2008fa4:	d8c12917 	ldw	r3,1188(sp)
 2008fa8:	1880030b 	ldhu	r2,12(r3)
 2008fac:	00c00284 	movi	r3,10
 2008fb0:	1100068c 	andi	r4,r2,26
 2008fb4:	20fec21e 	bne	r4,r3,2008ac0 <___vfprintf_internal_r+0x90>
 2008fb8:	d9012917 	ldw	r4,1188(sp)
 2008fbc:	20c0038b 	ldhu	r3,14(r4)
 2008fc0:	193fffcc 	andi	r4,r3,65535
 2008fc4:	2120001c 	xori	r4,r4,32768
 2008fc8:	21200004 	addi	r4,r4,-32768
 2008fcc:	203ebc16 	blt	r4,zero,2008ac0 <___vfprintf_internal_r+0x90>
 2008fd0:	da012917 	ldw	r8,1188(sp)
 2008fd4:	d9013017 	ldw	r4,1216(sp)
 2008fd8:	d9c12d17 	ldw	r7,1204(sp)
 2008fdc:	42800717 	ldw	r10,28(r8)
 2008fe0:	42400917 	ldw	r9,36(r8)
 2008fe4:	10bfff4c 	andi	r2,r2,65533
 2008fe8:	02010004 	movi	r8,1024
 2008fec:	d881070d 	sth	r2,1052(sp)
 2008ff0:	d9410404 	addi	r5,sp,1040
 2008ff4:	d8800404 	addi	r2,sp,16
 2008ff8:	800d883a 	mov	r6,r16
 2008ffc:	d8c1078d 	sth	r3,1054(sp)
 2009000:	da810b15 	stw	r10,1068(sp)
 2009004:	da410d15 	stw	r9,1076(sp)
 2009008:	d8810415 	stw	r2,1040(sp)
 200900c:	d8810815 	stw	r2,1056(sp)
 2009010:	da010615 	stw	r8,1048(sp)
 2009014:	da010915 	stw	r8,1060(sp)
 2009018:	d8010a15 	stw	zero,1064(sp)
 200901c:	2008a300 	call	2008a30 <___vfprintf_internal_r>
 2009020:	d8812c15 	stw	r2,1200(sp)
 2009024:	10000416 	blt	r2,zero,2009038 <___vfprintf_internal_r+0x608>
 2009028:	d9013017 	ldw	r4,1216(sp)
 200902c:	d9410404 	addi	r5,sp,1040
 2009030:	200463c0 	call	200463c <_fflush_r>
 2009034:	1005d81e 	bne	r2,zero,200a798 <___vfprintf_internal_r+0x1d68>
 2009038:	d881070b 	ldhu	r2,1052(sp)
 200903c:	1080100c 	andi	r2,r2,64
 2009040:	10bfffcc 	andi	r2,r2,65535
 2009044:	10a0001c 	xori	r2,r2,32768
 2009048:	10a00004 	addi	r2,r2,-32768
 200904c:	10001426 	beq	r2,zero,20090a0 <___vfprintf_internal_r+0x670>
 2009050:	d8c12917 	ldw	r3,1188(sp)
 2009054:	1880030b 	ldhu	r2,12(r3)
 2009058:	10801014 	ori	r2,r2,64
 200905c:	1880030d 	sth	r2,12(r3)
 2009060:	00000f06 	br	20090a0 <___vfprintf_internal_r+0x670>
 2009064:	d8811d17 	ldw	r2,1140(sp)
 2009068:	10000426 	beq	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200906c:	d9013017 	ldw	r4,1216(sp)
 2009070:	d9412917 	ldw	r5,1188(sp)
 2009074:	d9811b04 	addi	r6,sp,1132
 2009078:	20089fc0 	call	20089fc <__sprint_r>
 200907c:	d8c12917 	ldw	r3,1188(sp)
 2009080:	1880030b 	ldhu	r2,12(r3)
 2009084:	1080100c 	andi	r2,r2,64
 2009088:	10bfffcc 	andi	r2,r2,65535
 200908c:	10a0001c 	xori	r2,r2,32768
 2009090:	10a00004 	addi	r2,r2,-32768
 2009094:	10000226 	beq	r2,zero,20090a0 <___vfprintf_internal_r+0x670>
 2009098:	00bfffc4 	movi	r2,-1
 200909c:	d8812c15 	stw	r2,1200(sp)
 20090a0:	d8812c17 	ldw	r2,1200(sp)
 20090a4:	dfc14617 	ldw	ra,1304(sp)
 20090a8:	df014517 	ldw	fp,1300(sp)
 20090ac:	ddc14417 	ldw	r23,1296(sp)
 20090b0:	dd814317 	ldw	r22,1292(sp)
 20090b4:	dd414217 	ldw	r21,1288(sp)
 20090b8:	dd014117 	ldw	r20,1284(sp)
 20090bc:	dcc14017 	ldw	r19,1280(sp)
 20090c0:	dc813f17 	ldw	r18,1276(sp)
 20090c4:	dc413e17 	ldw	r17,1272(sp)
 20090c8:	dc013d17 	ldw	r16,1268(sp)
 20090cc:	dec14704 	addi	sp,sp,1308
 20090d0:	f800283a 	ret
 20090d4:	d9412917 	ldw	r5,1188(sp)
 20090d8:	8809883a 	mov	r4,r17
 20090dc:	d9811b04 	addi	r6,sp,1132
 20090e0:	20089fc0 	call	20089fc <__sprint_r>
 20090e4:	103fe51e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 20090e8:	da400404 	addi	r9,sp,16
 20090ec:	003e9d06 	br	2008b64 <___vfprintf_internal_r+0x134>
 20090f0:	200492c0 	call	200492c <__sinit>
 20090f4:	003e6606 	br	2008a90 <___vfprintf_internal_r+0x60>
 20090f8:	d8812d17 	ldw	r2,1204(sp)
 20090fc:	0007883a 	mov	r3,zero
 2009100:	15c00017 	ldw	r23,0(r2)
 2009104:	15800117 	ldw	r22,4(r2)
 2009108:	10800204 	addi	r2,r2,8
 200910c:	d8812d15 	stw	r2,1204(sp)
 2009110:	d8012585 	stb	zero,1174(sp)
 2009114:	bd84b03a 	or	r2,r23,r22
 2009118:	003f1c06 	br	2008d8c <___vfprintf_internal_r+0x35c>
 200911c:	d8c12d17 	ldw	r3,1204(sp)
 2009120:	18800117 	ldw	r2,4(r3)
 2009124:	1dc00017 	ldw	r23,0(r3)
 2009128:	18c00204 	addi	r3,r3,8
 200912c:	d8c12d15 	stw	r3,1204(sp)
 2009130:	102d883a 	mov	r22,r2
 2009134:	003f8606 	br	2008f50 <___vfprintf_internal_r+0x520>
 2009138:	d8c12d17 	ldw	r3,1204(sp)
 200913c:	d9012d17 	ldw	r4,1204(sp)
 2009140:	1dc00017 	ldw	r23,0(r3)
 2009144:	1d800117 	ldw	r22,4(r3)
 2009148:	21000204 	addi	r4,r4,8
 200914c:	00c00044 	movi	r3,1
 2009150:	d9012d15 	stw	r4,1204(sp)
 2009154:	bd84b03a 	or	r2,r23,r22
 2009158:	d8012585 	stb	zero,1174(sp)
 200915c:	003f0b06 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009160:	d9812585 	stb	r6,1174(sp)
 2009164:	ac800007 	ldb	r18,0(r21)
 2009168:	003e8f06 	br	2008ba8 <___vfprintf_internal_r+0x178>
 200916c:	ac800007 	ldb	r18,0(r21)
 2009170:	a9000044 	addi	r4,r21,1
 2009174:	92857d26 	beq	r18,r10,200a76c <___vfprintf_internal_r+0x1d3c>
 2009178:	90bff404 	addi	r2,r18,-48
 200917c:	0039883a 	mov	fp,zero
 2009180:	28800736 	bltu	r5,r2,20091a0 <___vfprintf_internal_r+0x770>
 2009184:	24800007 	ldb	r18,0(r4)
 2009188:	e70002a4 	muli	fp,fp,10
 200918c:	21000044 	addi	r4,r4,1
 2009190:	1739883a 	add	fp,r2,fp
 2009194:	90bff404 	addi	r2,r18,-48
 2009198:	28bffa2e 	bgeu	r5,r2,2009184 <___vfprintf_internal_r+0x754>
 200919c:	e0044216 	blt	fp,zero,200a2a8 <___vfprintf_internal_r+0x1878>
 20091a0:	202b883a 	mov	r21,r4
 20091a4:	003e8106 	br	2008bac <___vfprintf_internal_r+0x17c>
 20091a8:	d8812587 	ldb	r2,1174(sp)
 20091ac:	1003581e 	bne	r2,zero,2009f10 <___vfprintf_internal_r+0x14e0>
 20091b0:	dac12585 	stb	r11,1174(sp)
 20091b4:	ac800007 	ldb	r18,0(r21)
 20091b8:	003e7b06 	br	2008ba8 <___vfprintf_internal_r+0x178>
 20091bc:	84000054 	ori	r16,r16,1
 20091c0:	ac800007 	ldb	r18,0(r21)
 20091c4:	003e7806 	br	2008ba8 <___vfprintf_internal_r+0x178>
 20091c8:	84002014 	ori	r16,r16,128
 20091cc:	ac800007 	ldb	r18,0(r21)
 20091d0:	003e7506 	br	2008ba8 <___vfprintf_internal_r+0x178>
 20091d4:	02008174 	movhi	r8,517
 20091d8:	42378804 	addi	r8,r8,-8672
 20091dc:	da013615 	stw	r8,1240(sp)
 20091e0:	8080080c 	andi	r2,r16,32
 20091e4:	10009626 	beq	r2,zero,2009440 <___vfprintf_internal_r+0xa10>
 20091e8:	d8812d17 	ldw	r2,1204(sp)
 20091ec:	15c00017 	ldw	r23,0(r2)
 20091f0:	15800117 	ldw	r22,4(r2)
 20091f4:	10800204 	addi	r2,r2,8
 20091f8:	d8812d15 	stw	r2,1204(sp)
 20091fc:	8080004c 	andi	r2,r16,1
 2009200:	1002ae26 	beq	r2,zero,2009cbc <___vfprintf_internal_r+0x128c>
 2009204:	bd84b03a 	or	r2,r23,r22
 2009208:	10032a26 	beq	r2,zero,2009eb4 <___vfprintf_internal_r+0x1484>
 200920c:	00c00c04 	movi	r3,48
 2009210:	d8c12505 	stb	r3,1172(sp)
 2009214:	dc812545 	stb	r18,1173(sp)
 2009218:	84000094 	ori	r16,r16,2
 200921c:	00c00084 	movi	r3,2
 2009220:	d8012585 	stb	zero,1174(sp)
 2009224:	003ed906 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009228:	84001014 	ori	r16,r16,64
 200922c:	ac800007 	ldb	r18,0(r21)
 2009230:	003e5d06 	br	2008ba8 <___vfprintf_internal_r+0x178>
 2009234:	ac800007 	ldb	r18,0(r21)
 2009238:	a805883a 	mov	r2,r21
 200923c:	91c43226 	beq	r18,r7,200a308 <___vfprintf_internal_r+0x18d8>
 2009240:	84000414 	ori	r16,r16,16
 2009244:	003e5806 	br	2008ba8 <___vfprintf_internal_r+0x178>
 2009248:	d8c12d17 	ldw	r3,1204(sp)
 200924c:	02000044 	movi	r8,1
 2009250:	da012815 	stw	r8,1184(sp)
 2009254:	18800017 	ldw	r2,0(r3)
 2009258:	18c00104 	addi	r3,r3,4
 200925c:	d8012585 	stb	zero,1174(sp)
 2009260:	d8810405 	stb	r2,1040(sp)
 2009264:	d8c12d15 	stw	r3,1204(sp)
 2009268:	da012b15 	stw	r8,1196(sp)
 200926c:	dcc10404 	addi	r19,sp,1040
 2009270:	d8013115 	stw	zero,1220(sp)
 2009274:	003ee006 	br	2008df8 <___vfprintf_internal_r+0x3c8>
 2009278:	8080080c 	andi	r2,r16,32
 200927c:	10031026 	beq	r2,zero,2009ec0 <___vfprintf_internal_r+0x1490>
 2009280:	d9012d17 	ldw	r4,1204(sp)
 2009284:	da012c17 	ldw	r8,1200(sp)
 2009288:	20800017 	ldw	r2,0(r4)
 200928c:	4007d7fa 	srai	r3,r8,31
 2009290:	21000104 	addi	r4,r4,4
 2009294:	d9012d15 	stw	r4,1204(sp)
 2009298:	12000015 	stw	r8,0(r2)
 200929c:	10c00115 	stw	r3,4(r2)
 20092a0:	003e1906 	br	2008b08 <___vfprintf_internal_r+0xd8>
 20092a4:	da012d17 	ldw	r8,1204(sp)
 20092a8:	d9012d17 	ldw	r4,1204(sp)
 20092ac:	42000017 	ldw	r8,0(r8)
 20092b0:	20800104 	addi	r2,r4,4
 20092b4:	da012e15 	stw	r8,1208(sp)
 20092b8:	403f2f16 	blt	r8,zero,2008f78 <___vfprintf_internal_r+0x548>
 20092bc:	d8812d15 	stw	r2,1204(sp)
 20092c0:	ac800007 	ldb	r18,0(r21)
 20092c4:	003e3806 	br	2008ba8 <___vfprintf_internal_r+0x178>
 20092c8:	0009883a 	mov	r4,zero
 20092cc:	90bff404 	addi	r2,r18,-48
 20092d0:	ac800007 	ldb	r18,0(r21)
 20092d4:	210002a4 	muli	r4,r4,10
 20092d8:	ad400044 	addi	r21,r21,1
 20092dc:	2089883a 	add	r4,r4,r2
 20092e0:	90bff404 	addi	r2,r18,-48
 20092e4:	28bffa2e 	bgeu	r5,r2,20092d0 <___vfprintf_internal_r+0x8a0>
 20092e8:	d9012e15 	stw	r4,1208(sp)
 20092ec:	003e2f06 	br	2008bac <___vfprintf_internal_r+0x17c>
 20092f0:	8080020c 	andi	r2,r16,8
 20092f4:	1002d426 	beq	r2,zero,2009e48 <___vfprintf_internal_r+0x1418>
 20092f8:	d8c12d17 	ldw	r3,1204(sp)
 20092fc:	1d800017 	ldw	r22,0(r3)
 2009300:	1d000117 	ldw	r20,4(r3)
 2009304:	18c00204 	addi	r3,r3,8
 2009308:	d8c12d15 	stw	r3,1204(sp)
 200930c:	dd813315 	stw	r22,1228(sp)
 2009310:	dd013415 	stw	r20,1232(sp)
 2009314:	b009883a 	mov	r4,r22
 2009318:	a00b883a 	mov	r5,r20
 200931c:	da413c15 	stw	r9,1264(sp)
 2009320:	200fc440 	call	200fc44 <__isinfd>
 2009324:	da413c17 	ldw	r9,1264(sp)
 2009328:	b009883a 	mov	r4,r22
 200932c:	a00b883a 	mov	r5,r20
 2009330:	10035726 	beq	r2,zero,200a090 <___vfprintf_internal_r+0x1660>
 2009334:	000d883a 	mov	r6,zero
 2009338:	000f883a 	mov	r7,zero
 200933c:	20142a00 	call	20142a0 <__ltdf2>
 2009340:	da413c17 	ldw	r9,1264(sp)
 2009344:	10041b16 	blt	r2,zero,200a3b4 <___vfprintf_internal_r+0x1984>
 2009348:	d8812583 	ldbu	r2,1174(sp)
 200934c:	00c011c4 	movi	r3,71
 2009350:	1c830b16 	blt	r3,r18,2009f80 <___vfprintf_internal_r+0x1550>
 2009354:	04c08174 	movhi	r19,517
 2009358:	9cf78404 	addi	r19,r19,-8688
 200935c:	020000c4 	movi	r8,3
 2009360:	00ffdfc4 	movi	r3,-129
 2009364:	da012815 	stw	r8,1184(sp)
 2009368:	80e0703a 	and	r16,r16,r3
 200936c:	da012b15 	stw	r8,1196(sp)
 2009370:	d8013115 	stw	zero,1220(sp)
 2009374:	003e9906 	br	2008ddc <___vfprintf_internal_r+0x3ac>
 2009378:	d8812d17 	ldw	r2,1204(sp)
 200937c:	d8c12d17 	ldw	r3,1204(sp)
 2009380:	02008174 	movhi	r8,517
 2009384:	42378d04 	addi	r8,r8,-8652
 2009388:	15c00017 	ldw	r23,0(r2)
 200938c:	00800c04 	movi	r2,48
 2009390:	18c00104 	addi	r3,r3,4
 2009394:	d8812505 	stb	r2,1172(sp)
 2009398:	00801e04 	movi	r2,120
 200939c:	d8812545 	stb	r2,1173(sp)
 20093a0:	d8c12d15 	stw	r3,1204(sp)
 20093a4:	002d883a 	mov	r22,zero
 20093a8:	84000094 	ori	r16,r16,2
 20093ac:	da013615 	stw	r8,1240(sp)
 20093b0:	00c00084 	movi	r3,2
 20093b4:	04801e04 	movi	r18,120
 20093b8:	b805883a 	mov	r2,r23
 20093bc:	d8012585 	stb	zero,1174(sp)
 20093c0:	003e7206 	br	2008d8c <___vfprintf_internal_r+0x35c>
 20093c4:	84000814 	ori	r16,r16,32
 20093c8:	ac800007 	ldb	r18,0(r21)
 20093cc:	003df606 	br	2008ba8 <___vfprintf_internal_r+0x178>
 20093d0:	d8812d17 	ldw	r2,1204(sp)
 20093d4:	d8012585 	stb	zero,1174(sp)
 20093d8:	14c00017 	ldw	r19,0(r2)
 20093dc:	15c00104 	addi	r23,r2,4
 20093e0:	98040126 	beq	r19,zero,200a3e8 <___vfprintf_internal_r+0x19b8>
 20093e4:	9809883a 	mov	r4,r19
 20093e8:	e003dd16 	blt	fp,zero,200a360 <___vfprintf_internal_r+0x1930>
 20093ec:	000b883a 	mov	r5,zero
 20093f0:	e00d883a 	mov	r6,fp
 20093f4:	da413c15 	stw	r9,1264(sp)
 20093f8:	200e4c00 	call	200e4c0 <memchr>
 20093fc:	da413c17 	ldw	r9,1264(sp)
 2009400:	10042e26 	beq	r2,zero,200a4bc <___vfprintf_internal_r+0x1a8c>
 2009404:	14c5c83a 	sub	r2,r2,r19
 2009408:	d8812b15 	stw	r2,1196(sp)
 200940c:	e083790e 	bge	fp,r2,200a1f4 <___vfprintf_internal_r+0x17c4>
 2009410:	df012815 	stw	fp,1184(sp)
 2009414:	e0049516 	blt	fp,zero,200a66c <___vfprintf_internal_r+0x1c3c>
 2009418:	d8812583 	ldbu	r2,1174(sp)
 200941c:	df012b15 	stw	fp,1196(sp)
 2009420:	ddc12d15 	stw	r23,1204(sp)
 2009424:	d8013115 	stw	zero,1220(sp)
 2009428:	003e6c06 	br	2008ddc <___vfprintf_internal_r+0x3ac>
 200942c:	02008174 	movhi	r8,517
 2009430:	42378d04 	addi	r8,r8,-8652
 2009434:	da013615 	stw	r8,1240(sp)
 2009438:	8080080c 	andi	r2,r16,32
 200943c:	103f6a1e 	bne	r2,zero,20091e8 <___vfprintf_internal_r+0x7b8>
 2009440:	8080040c 	andi	r2,r16,16
 2009444:	10029326 	beq	r2,zero,2009e94 <___vfprintf_internal_r+0x1464>
 2009448:	d8c12d17 	ldw	r3,1204(sp)
 200944c:	002d883a 	mov	r22,zero
 2009450:	1dc00017 	ldw	r23,0(r3)
 2009454:	18c00104 	addi	r3,r3,4
 2009458:	d8c12d15 	stw	r3,1204(sp)
 200945c:	003f6706 	br	20091fc <___vfprintf_internal_r+0x7cc>
 2009460:	84000214 	ori	r16,r16,8
 2009464:	ac800007 	ldb	r18,0(r21)
 2009468:	003dcf06 	br	2008ba8 <___vfprintf_internal_r+0x178>
 200946c:	da011d17 	ldw	r8,1140(sp)
 2009470:	d8c11c17 	ldw	r3,1136(sp)
 2009474:	d8812587 	ldb	r2,1174(sp)
 2009478:	10000b26 	beq	r2,zero,20094a8 <___vfprintf_internal_r+0xa78>
 200947c:	d8812584 	addi	r2,sp,1174
 2009480:	48800015 	stw	r2,0(r9)
 2009484:	00800044 	movi	r2,1
 2009488:	48800115 	stw	r2,4(r9)
 200948c:	4091883a 	add	r8,r8,r2
 2009490:	1887883a 	add	r3,r3,r2
 2009494:	da011d15 	stw	r8,1140(sp)
 2009498:	d8c11c15 	stw	r3,1136(sp)
 200949c:	008001c4 	movi	r2,7
 20094a0:	10c18516 	blt	r2,r3,2009ab8 <___vfprintf_internal_r+0x1088>
 20094a4:	4a400204 	addi	r9,r9,8
 20094a8:	d9012a17 	ldw	r4,1192(sp)
 20094ac:	20000b26 	beq	r4,zero,20094dc <___vfprintf_internal_r+0xaac>
 20094b0:	d8812504 	addi	r2,sp,1172
 20094b4:	48800015 	stw	r2,0(r9)
 20094b8:	00800084 	movi	r2,2
 20094bc:	48800115 	stw	r2,4(r9)
 20094c0:	4091883a 	add	r8,r8,r2
 20094c4:	18c00044 	addi	r3,r3,1
 20094c8:	da011d15 	stw	r8,1140(sp)
 20094cc:	d8c11c15 	stw	r3,1136(sp)
 20094d0:	008001c4 	movi	r2,7
 20094d4:	10c18116 	blt	r2,r3,2009adc <___vfprintf_internal_r+0x10ac>
 20094d8:	4a400204 	addi	r9,r9,8
 20094dc:	d9012f17 	ldw	r4,1212(sp)
 20094e0:	00802004 	movi	r2,128
 20094e4:	2080fc26 	beq	r4,r2,20098d8 <___vfprintf_internal_r+0xea8>
 20094e8:	d8813117 	ldw	r2,1220(sp)
 20094ec:	d9012b17 	ldw	r4,1196(sp)
 20094f0:	112fc83a 	sub	r23,r2,r4
 20094f4:	05c02a0e 	bge	zero,r23,20095a0 <___vfprintf_internal_r+0xb70>
 20094f8:	07000404 	movi	fp,16
 20094fc:	05008174 	movhi	r20,517
 2009500:	a5379884 	addi	r20,r20,-8606
 2009504:	e5c01d0e 	bge	fp,r23,200957c <___vfprintf_internal_r+0xb4c>
 2009508:	dc812a15 	stw	r18,1192(sp)
 200950c:	058001c4 	movi	r22,7
 2009510:	a025883a 	mov	r18,r20
 2009514:	8029883a 	mov	r20,r16
 2009518:	dc012917 	ldw	r16,1188(sp)
 200951c:	00000306 	br	200952c <___vfprintf_internal_r+0xafc>
 2009520:	bdfffc04 	addi	r23,r23,-16
 2009524:	4a400204 	addi	r9,r9,8
 2009528:	e5c0110e 	bge	fp,r23,2009570 <___vfprintf_internal_r+0xb40>
 200952c:	4c800015 	stw	r18,0(r9)
 2009530:	4f000115 	stw	fp,4(r9)
 2009534:	42000404 	addi	r8,r8,16
 2009538:	18c00044 	addi	r3,r3,1
 200953c:	da011d15 	stw	r8,1140(sp)
 2009540:	d8c11c15 	stw	r3,1136(sp)
 2009544:	b0fff60e 	bge	r22,r3,2009520 <___vfprintf_internal_r+0xaf0>
 2009548:	8809883a 	mov	r4,r17
 200954c:	800b883a 	mov	r5,r16
 2009550:	d9811b04 	addi	r6,sp,1132
 2009554:	20089fc0 	call	20089fc <__sprint_r>
 2009558:	103ec81e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200955c:	bdfffc04 	addi	r23,r23,-16
 2009560:	da011d17 	ldw	r8,1140(sp)
 2009564:	d8c11c17 	ldw	r3,1136(sp)
 2009568:	da400404 	addi	r9,sp,16
 200956c:	e5ffef16 	blt	fp,r23,200952c <___vfprintf_internal_r+0xafc>
 2009570:	a021883a 	mov	r16,r20
 2009574:	9029883a 	mov	r20,r18
 2009578:	dc812a17 	ldw	r18,1192(sp)
 200957c:	4d000015 	stw	r20,0(r9)
 2009580:	4dc00115 	stw	r23,4(r9)
 2009584:	45d1883a 	add	r8,r8,r23
 2009588:	18c00044 	addi	r3,r3,1
 200958c:	da011d15 	stw	r8,1140(sp)
 2009590:	d8c11c15 	stw	r3,1136(sp)
 2009594:	008001c4 	movi	r2,7
 2009598:	10c13e16 	blt	r2,r3,2009a94 <___vfprintf_internal_r+0x1064>
 200959c:	4a400204 	addi	r9,r9,8
 20095a0:	8080400c 	andi	r2,r16,256
 20095a4:	1000831e 	bne	r2,zero,20097b4 <___vfprintf_internal_r+0xd84>
 20095a8:	d8812b17 	ldw	r2,1196(sp)
 20095ac:	4cc00015 	stw	r19,0(r9)
 20095b0:	48800115 	stw	r2,4(r9)
 20095b4:	4091883a 	add	r8,r8,r2
 20095b8:	18c00044 	addi	r3,r3,1
 20095bc:	da011d15 	stw	r8,1140(sp)
 20095c0:	d8c11c15 	stw	r3,1136(sp)
 20095c4:	008001c4 	movi	r2,7
 20095c8:	10c05316 	blt	r2,r3,2009718 <___vfprintf_internal_r+0xce8>
 20095cc:	4a400204 	addi	r9,r9,8
 20095d0:	8400010c 	andi	r16,r16,4
 20095d4:	80002e26 	beq	r16,zero,2009690 <___vfprintf_internal_r+0xc60>
 20095d8:	d8812e17 	ldw	r2,1208(sp)
 20095dc:	d8c12817 	ldw	r3,1184(sp)
 20095e0:	10e1c83a 	sub	r16,r2,r3
 20095e4:	04002a0e 	bge	zero,r16,2009690 <___vfprintf_internal_r+0xc60>
 20095e8:	04800404 	movi	r18,16
 20095ec:	d8c11c17 	ldw	r3,1136(sp)
 20095f0:	05c08174 	movhi	r23,517
 20095f4:	bdf79484 	addi	r23,r23,-8622
 20095f8:	9400170e 	bge	r18,r16,2009658 <___vfprintf_internal_r+0xc28>
 20095fc:	04c001c4 	movi	r19,7
 2009600:	dd012917 	ldw	r20,1188(sp)
 2009604:	00000306 	br	2009614 <___vfprintf_internal_r+0xbe4>
 2009608:	843ffc04 	addi	r16,r16,-16
 200960c:	4a400204 	addi	r9,r9,8
 2009610:	9400110e 	bge	r18,r16,2009658 <___vfprintf_internal_r+0xc28>
 2009614:	4dc00015 	stw	r23,0(r9)
 2009618:	4c800115 	stw	r18,4(r9)
 200961c:	42000404 	addi	r8,r8,16
 2009620:	18c00044 	addi	r3,r3,1
 2009624:	da011d15 	stw	r8,1140(sp)
 2009628:	d8c11c15 	stw	r3,1136(sp)
 200962c:	98fff60e 	bge	r19,r3,2009608 <___vfprintf_internal_r+0xbd8>
 2009630:	8809883a 	mov	r4,r17
 2009634:	a00b883a 	mov	r5,r20
 2009638:	d9811b04 	addi	r6,sp,1132
 200963c:	20089fc0 	call	20089fc <__sprint_r>
 2009640:	103e8e1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009644:	843ffc04 	addi	r16,r16,-16
 2009648:	da011d17 	ldw	r8,1140(sp)
 200964c:	d8c11c17 	ldw	r3,1136(sp)
 2009650:	da400404 	addi	r9,sp,16
 2009654:	943fef16 	blt	r18,r16,2009614 <___vfprintf_internal_r+0xbe4>
 2009658:	4dc00015 	stw	r23,0(r9)
 200965c:	4c000115 	stw	r16,4(r9)
 2009660:	8211883a 	add	r8,r16,r8
 2009664:	18c00044 	addi	r3,r3,1
 2009668:	da011d15 	stw	r8,1140(sp)
 200966c:	d8c11c15 	stw	r3,1136(sp)
 2009670:	008001c4 	movi	r2,7
 2009674:	10c0060e 	bge	r2,r3,2009690 <___vfprintf_internal_r+0xc60>
 2009678:	d9412917 	ldw	r5,1188(sp)
 200967c:	8809883a 	mov	r4,r17
 2009680:	d9811b04 	addi	r6,sp,1132
 2009684:	20089fc0 	call	20089fc <__sprint_r>
 2009688:	103e7c1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200968c:	da011d17 	ldw	r8,1140(sp)
 2009690:	dd012817 	ldw	r20,1184(sp)
 2009694:	d9012e17 	ldw	r4,1208(sp)
 2009698:	a100010e 	bge	r20,r4,20096a0 <___vfprintf_internal_r+0xc70>
 200969c:	2029883a 	mov	r20,r4
 20096a0:	d8812c17 	ldw	r2,1200(sp)
 20096a4:	1505883a 	add	r2,r2,r20
 20096a8:	d8812c15 	stw	r2,1200(sp)
 20096ac:	4000b91e 	bne	r8,zero,2009994 <___vfprintf_internal_r+0xf64>
 20096b0:	d8011c15 	stw	zero,1136(sp)
 20096b4:	a8800007 	ldb	r2,0(r21)
 20096b8:	da400404 	addi	r9,sp,16
 20096bc:	103d141e 	bne	r2,zero,2008b10 <___vfprintf_internal_r+0xe0>
 20096c0:	a825883a 	mov	r18,r21
 20096c4:	003d2a06 	br	2008b70 <___vfprintf_internal_r+0x140>
 20096c8:	d9412917 	ldw	r5,1188(sp)
 20096cc:	8809883a 	mov	r4,r17
 20096d0:	d9811b04 	addi	r6,sp,1132
 20096d4:	20089fc0 	call	20089fc <__sprint_r>
 20096d8:	103e681e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 20096dc:	da011d17 	ldw	r8,1140(sp)
 20096e0:	da400404 	addi	r9,sp,16
 20096e4:	8080004c 	andi	r2,r16,1
 20096e8:	103fb926 	beq	r2,zero,20095d0 <___vfprintf_internal_r+0xba0>
 20096ec:	d8c11c17 	ldw	r3,1136(sp)
 20096f0:	d9013717 	ldw	r4,1244(sp)
 20096f4:	00800044 	movi	r2,1
 20096f8:	48800115 	stw	r2,4(r9)
 20096fc:	49000015 	stw	r4,0(r9)
 2009700:	4091883a 	add	r8,r8,r2
 2009704:	1887883a 	add	r3,r3,r2
 2009708:	da011d15 	stw	r8,1140(sp)
 200970c:	d8c11c15 	stw	r3,1136(sp)
 2009710:	008001c4 	movi	r2,7
 2009714:	10ffad0e 	bge	r2,r3,20095cc <___vfprintf_internal_r+0xb9c>
 2009718:	d9412917 	ldw	r5,1188(sp)
 200971c:	8809883a 	mov	r4,r17
 2009720:	d9811b04 	addi	r6,sp,1132
 2009724:	20089fc0 	call	20089fc <__sprint_r>
 2009728:	103e541e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200972c:	da400404 	addi	r9,sp,16
 2009730:	da011d17 	ldw	r8,1140(sp)
 2009734:	003fa606 	br	20095d0 <___vfprintf_internal_r+0xba0>
 2009738:	18803fcc 	andi	r2,r3,255
 200973c:	00c00044 	movi	r3,1
 2009740:	10c10126 	beq	r2,r3,2009b48 <___vfprintf_internal_r+0x1118>
 2009744:	00c00084 	movi	r3,2
 2009748:	10c0f026 	beq	r2,r3,2009b0c <___vfprintf_internal_r+0x10dc>
 200974c:	d8c10dc4 	addi	r3,sp,1079
 2009750:	b808d0fa 	srli	r4,r23,3
 2009754:	b00a977a 	slli	r5,r22,29
 2009758:	b02cd0fa 	srli	r22,r22,3
 200975c:	bdc001cc 	andi	r23,r23,7
 2009760:	b8800c04 	addi	r2,r23,48
 2009764:	292eb03a 	or	r23,r5,r4
 2009768:	18800005 	stb	r2,0(r3)
 200976c:	bd88b03a 	or	r4,r23,r22
 2009770:	1827883a 	mov	r19,r3
 2009774:	18ffffc4 	addi	r3,r3,-1
 2009778:	203ff51e 	bne	r4,zero,2009750 <___vfprintf_internal_r+0xd20>
 200977c:	8100004c 	andi	r4,r16,1
 2009780:	980b883a 	mov	r5,r19
 2009784:	20000726 	beq	r4,zero,20097a4 <___vfprintf_internal_r+0xd74>
 2009788:	10803fcc 	andi	r2,r2,255
 200978c:	1080201c 	xori	r2,r2,128
 2009790:	10bfe004 	addi	r2,r2,-128
 2009794:	01000c04 	movi	r4,48
 2009798:	11000226 	beq	r2,r4,20097a4 <___vfprintf_internal_r+0xd74>
 200979c:	1827883a 	mov	r19,r3
 20097a0:	293fffc5 	stb	r4,-1(r5)
 20097a4:	d8812717 	ldw	r2,1180(sp)
 20097a8:	14c5c83a 	sub	r2,r2,r19
 20097ac:	d8812b15 	stw	r2,1196(sp)
 20097b0:	003d8406 	br	2008dc4 <___vfprintf_internal_r+0x394>
 20097b4:	00801944 	movi	r2,101
 20097b8:	14807c0e 	bge	r2,r18,20099ac <___vfprintf_internal_r+0xf7c>
 20097bc:	d9013317 	ldw	r4,1228(sp)
 20097c0:	d9413417 	ldw	r5,1232(sp)
 20097c4:	000d883a 	mov	r6,zero
 20097c8:	000f883a 	mov	r7,zero
 20097cc:	d8c13b15 	stw	r3,1260(sp)
 20097d0:	da013a15 	stw	r8,1256(sp)
 20097d4:	da413c15 	stw	r9,1264(sp)
 20097d8:	20141200 	call	2014120 <__eqdf2>
 20097dc:	d8c13b17 	ldw	r3,1260(sp)
 20097e0:	da013a17 	ldw	r8,1256(sp)
 20097e4:	da413c17 	ldw	r9,1264(sp)
 20097e8:	1001001e 	bne	r2,zero,2009bec <___vfprintf_internal_r+0x11bc>
 20097ec:	00808174 	movhi	r2,517
 20097f0:	10b79404 	addi	r2,r2,-8624
 20097f4:	48800015 	stw	r2,0(r9)
 20097f8:	00800044 	movi	r2,1
 20097fc:	48800115 	stw	r2,4(r9)
 2009800:	4091883a 	add	r8,r8,r2
 2009804:	1887883a 	add	r3,r3,r2
 2009808:	da011d15 	stw	r8,1140(sp)
 200980c:	d8c11c15 	stw	r3,1136(sp)
 2009810:	008001c4 	movi	r2,7
 2009814:	10c1dd16 	blt	r2,r3,2009f8c <___vfprintf_internal_r+0x155c>
 2009818:	4a400204 	addi	r9,r9,8
 200981c:	d8812417 	ldw	r2,1168(sp)
 2009820:	d8c13217 	ldw	r3,1224(sp)
 2009824:	10c00216 	blt	r2,r3,2009830 <___vfprintf_internal_r+0xe00>
 2009828:	8080004c 	andi	r2,r16,1
 200982c:	103f6826 	beq	r2,zero,20095d0 <___vfprintf_internal_r+0xba0>
 2009830:	d8c11c17 	ldw	r3,1136(sp)
 2009834:	d9013717 	ldw	r4,1244(sp)
 2009838:	00800044 	movi	r2,1
 200983c:	48800115 	stw	r2,4(r9)
 2009840:	49000015 	stw	r4,0(r9)
 2009844:	4091883a 	add	r8,r8,r2
 2009848:	1887883a 	add	r3,r3,r2
 200984c:	da011d15 	stw	r8,1140(sp)
 2009850:	d8c11c15 	stw	r3,1136(sp)
 2009854:	008001c4 	movi	r2,7
 2009858:	10c2af16 	blt	r2,r3,200a318 <___vfprintf_internal_r+0x18e8>
 200985c:	4a400204 	addi	r9,r9,8
 2009860:	d8813217 	ldw	r2,1224(sp)
 2009864:	14bfffc4 	addi	r18,r2,-1
 2009868:	04bf590e 	bge	zero,r18,20095d0 <___vfprintf_internal_r+0xba0>
 200986c:	04c00404 	movi	r19,16
 2009870:	d8c11c17 	ldw	r3,1136(sp)
 2009874:	05008174 	movhi	r20,517
 2009878:	a5379884 	addi	r20,r20,-8606
 200987c:	9c81630e 	bge	r19,r18,2009e0c <___vfprintf_internal_r+0x13dc>
 2009880:	058001c4 	movi	r22,7
 2009884:	ddc12917 	ldw	r23,1188(sp)
 2009888:	00000306 	br	2009898 <___vfprintf_internal_r+0xe68>
 200988c:	4a400204 	addi	r9,r9,8
 2009890:	94bffc04 	addi	r18,r18,-16
 2009894:	9c815d0e 	bge	r19,r18,2009e0c <___vfprintf_internal_r+0x13dc>
 2009898:	4d000015 	stw	r20,0(r9)
 200989c:	4cc00115 	stw	r19,4(r9)
 20098a0:	42000404 	addi	r8,r8,16
 20098a4:	18c00044 	addi	r3,r3,1
 20098a8:	da011d15 	stw	r8,1140(sp)
 20098ac:	d8c11c15 	stw	r3,1136(sp)
 20098b0:	b0fff60e 	bge	r22,r3,200988c <___vfprintf_internal_r+0xe5c>
 20098b4:	8809883a 	mov	r4,r17
 20098b8:	b80b883a 	mov	r5,r23
 20098bc:	d9811b04 	addi	r6,sp,1132
 20098c0:	20089fc0 	call	20089fc <__sprint_r>
 20098c4:	103ded1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 20098c8:	da011d17 	ldw	r8,1140(sp)
 20098cc:	d8c11c17 	ldw	r3,1136(sp)
 20098d0:	da400404 	addi	r9,sp,16
 20098d4:	003fee06 	br	2009890 <___vfprintf_internal_r+0xe60>
 20098d8:	d8812e17 	ldw	r2,1208(sp)
 20098dc:	d9012817 	ldw	r4,1184(sp)
 20098e0:	112fc83a 	sub	r23,r2,r4
 20098e4:	05ff000e 	bge	zero,r23,20094e8 <___vfprintf_internal_r+0xab8>
 20098e8:	07000404 	movi	fp,16
 20098ec:	05008174 	movhi	r20,517
 20098f0:	a5379884 	addi	r20,r20,-8606
 20098f4:	e5c01d0e 	bge	fp,r23,200996c <___vfprintf_internal_r+0xf3c>
 20098f8:	dc812a15 	stw	r18,1192(sp)
 20098fc:	058001c4 	movi	r22,7
 2009900:	a025883a 	mov	r18,r20
 2009904:	8029883a 	mov	r20,r16
 2009908:	dc012917 	ldw	r16,1188(sp)
 200990c:	00000306 	br	200991c <___vfprintf_internal_r+0xeec>
 2009910:	bdfffc04 	addi	r23,r23,-16
 2009914:	4a400204 	addi	r9,r9,8
 2009918:	e5c0110e 	bge	fp,r23,2009960 <___vfprintf_internal_r+0xf30>
 200991c:	4c800015 	stw	r18,0(r9)
 2009920:	4f000115 	stw	fp,4(r9)
 2009924:	42000404 	addi	r8,r8,16
 2009928:	18c00044 	addi	r3,r3,1
 200992c:	da011d15 	stw	r8,1140(sp)
 2009930:	d8c11c15 	stw	r3,1136(sp)
 2009934:	b0fff60e 	bge	r22,r3,2009910 <___vfprintf_internal_r+0xee0>
 2009938:	8809883a 	mov	r4,r17
 200993c:	800b883a 	mov	r5,r16
 2009940:	d9811b04 	addi	r6,sp,1132
 2009944:	20089fc0 	call	20089fc <__sprint_r>
 2009948:	103dcc1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200994c:	bdfffc04 	addi	r23,r23,-16
 2009950:	da011d17 	ldw	r8,1140(sp)
 2009954:	d8c11c17 	ldw	r3,1136(sp)
 2009958:	da400404 	addi	r9,sp,16
 200995c:	e5ffef16 	blt	fp,r23,200991c <___vfprintf_internal_r+0xeec>
 2009960:	a021883a 	mov	r16,r20
 2009964:	9029883a 	mov	r20,r18
 2009968:	dc812a17 	ldw	r18,1192(sp)
 200996c:	4d000015 	stw	r20,0(r9)
 2009970:	4dc00115 	stw	r23,4(r9)
 2009974:	45d1883a 	add	r8,r8,r23
 2009978:	18c00044 	addi	r3,r3,1
 200997c:	da011d15 	stw	r8,1140(sp)
 2009980:	d8c11c15 	stw	r3,1136(sp)
 2009984:	008001c4 	movi	r2,7
 2009988:	10c11716 	blt	r2,r3,2009de8 <___vfprintf_internal_r+0x13b8>
 200998c:	4a400204 	addi	r9,r9,8
 2009990:	003ed506 	br	20094e8 <___vfprintf_internal_r+0xab8>
 2009994:	d9412917 	ldw	r5,1188(sp)
 2009998:	8809883a 	mov	r4,r17
 200999c:	d9811b04 	addi	r6,sp,1132
 20099a0:	20089fc0 	call	20089fc <__sprint_r>
 20099a4:	103f4226 	beq	r2,zero,20096b0 <___vfprintf_internal_r+0xc80>
 20099a8:	003db406 	br	200907c <___vfprintf_internal_r+0x64c>
 20099ac:	d9013217 	ldw	r4,1224(sp)
 20099b0:	00800044 	movi	r2,1
 20099b4:	4cc00015 	stw	r19,0(r9)
 20099b8:	1100e10e 	bge	r2,r4,2009d40 <___vfprintf_internal_r+0x1310>
 20099bc:	00800044 	movi	r2,1
 20099c0:	48800115 	stw	r2,4(r9)
 20099c4:	4091883a 	add	r8,r8,r2
 20099c8:	1887883a 	add	r3,r3,r2
 20099cc:	da011d15 	stw	r8,1140(sp)
 20099d0:	d8c11c15 	stw	r3,1136(sp)
 20099d4:	008001c4 	movi	r2,7
 20099d8:	10c0ed16 	blt	r2,r3,2009d90 <___vfprintf_internal_r+0x1360>
 20099dc:	4a400204 	addi	r9,r9,8
 20099e0:	d8813717 	ldw	r2,1244(sp)
 20099e4:	48800015 	stw	r2,0(r9)
 20099e8:	00800044 	movi	r2,1
 20099ec:	48800115 	stw	r2,4(r9)
 20099f0:	4091883a 	add	r8,r8,r2
 20099f4:	1887883a 	add	r3,r3,r2
 20099f8:	da011d15 	stw	r8,1140(sp)
 20099fc:	d8c11c15 	stw	r3,1136(sp)
 2009a00:	008001c4 	movi	r2,7
 2009a04:	10c0eb16 	blt	r2,r3,2009db4 <___vfprintf_internal_r+0x1384>
 2009a08:	4c800204 	addi	r18,r9,8
 2009a0c:	d9013317 	ldw	r4,1228(sp)
 2009a10:	d9413417 	ldw	r5,1232(sp)
 2009a14:	000d883a 	mov	r6,zero
 2009a18:	000f883a 	mov	r7,zero
 2009a1c:	d8c13b15 	stw	r3,1260(sp)
 2009a20:	da013a15 	stw	r8,1256(sp)
 2009a24:	201417c0 	call	201417c <__nedf2>
 2009a28:	d8c13b17 	ldw	r3,1260(sp)
 2009a2c:	da013a17 	ldw	r8,1256(sp)
 2009a30:	1000a626 	beq	r2,zero,2009ccc <___vfprintf_internal_r+0x129c>
 2009a34:	d9013217 	ldw	r4,1224(sp)
 2009a38:	9cc00044 	addi	r19,r19,1
 2009a3c:	94c00015 	stw	r19,0(r18)
 2009a40:	20bfffc4 	addi	r2,r4,-1
 2009a44:	90800115 	stw	r2,4(r18)
 2009a48:	4091883a 	add	r8,r8,r2
 2009a4c:	18c00044 	addi	r3,r3,1
 2009a50:	da011d15 	stw	r8,1140(sp)
 2009a54:	d8c11c15 	stw	r3,1136(sp)
 2009a58:	008001c4 	movi	r2,7
 2009a5c:	10c0c316 	blt	r2,r3,2009d6c <___vfprintf_internal_r+0x133c>
 2009a60:	94800204 	addi	r18,r18,8
 2009a64:	d9013517 	ldw	r4,1236(sp)
 2009a68:	d8811fc4 	addi	r2,sp,1151
 2009a6c:	90800015 	stw	r2,0(r18)
 2009a70:	91000115 	stw	r4,4(r18)
 2009a74:	4111883a 	add	r8,r8,r4
 2009a78:	18c00044 	addi	r3,r3,1
 2009a7c:	da011d15 	stw	r8,1140(sp)
 2009a80:	d8c11c15 	stw	r3,1136(sp)
 2009a84:	008001c4 	movi	r2,7
 2009a88:	10ff2316 	blt	r2,r3,2009718 <___vfprintf_internal_r+0xce8>
 2009a8c:	92400204 	addi	r9,r18,8
 2009a90:	003ecf06 	br	20095d0 <___vfprintf_internal_r+0xba0>
 2009a94:	d9412917 	ldw	r5,1188(sp)
 2009a98:	8809883a 	mov	r4,r17
 2009a9c:	d9811b04 	addi	r6,sp,1132
 2009aa0:	20089fc0 	call	20089fc <__sprint_r>
 2009aa4:	103d751e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009aa8:	da011d17 	ldw	r8,1140(sp)
 2009aac:	d8c11c17 	ldw	r3,1136(sp)
 2009ab0:	da400404 	addi	r9,sp,16
 2009ab4:	003eba06 	br	20095a0 <___vfprintf_internal_r+0xb70>
 2009ab8:	d9412917 	ldw	r5,1188(sp)
 2009abc:	8809883a 	mov	r4,r17
 2009ac0:	d9811b04 	addi	r6,sp,1132
 2009ac4:	20089fc0 	call	20089fc <__sprint_r>
 2009ac8:	103d6c1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009acc:	da011d17 	ldw	r8,1140(sp)
 2009ad0:	d8c11c17 	ldw	r3,1136(sp)
 2009ad4:	da400404 	addi	r9,sp,16
 2009ad8:	003e7306 	br	20094a8 <___vfprintf_internal_r+0xa78>
 2009adc:	d9412917 	ldw	r5,1188(sp)
 2009ae0:	8809883a 	mov	r4,r17
 2009ae4:	d9811b04 	addi	r6,sp,1132
 2009ae8:	20089fc0 	call	20089fc <__sprint_r>
 2009aec:	103d631e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009af0:	da011d17 	ldw	r8,1140(sp)
 2009af4:	d8c11c17 	ldw	r3,1136(sp)
 2009af8:	da400404 	addi	r9,sp,16
 2009afc:	003e7706 	br	20094dc <___vfprintf_internal_r+0xaac>
 2009b00:	d8012b15 	stw	zero,1196(sp)
 2009b04:	dcc10e04 	addi	r19,sp,1080
 2009b08:	003cae06 	br	2008dc4 <___vfprintf_internal_r+0x394>
 2009b0c:	d9413617 	ldw	r5,1240(sp)
 2009b10:	d8810dc4 	addi	r2,sp,1079
 2009b14:	b8c003cc 	andi	r3,r23,15
 2009b18:	b008973a 	slli	r4,r22,28
 2009b1c:	28c7883a 	add	r3,r5,r3
 2009b20:	b82ed13a 	srli	r23,r23,4
 2009b24:	18c00003 	ldbu	r3,0(r3)
 2009b28:	b02cd13a 	srli	r22,r22,4
 2009b2c:	25eeb03a 	or	r23,r4,r23
 2009b30:	10c00005 	stb	r3,0(r2)
 2009b34:	bd86b03a 	or	r3,r23,r22
 2009b38:	1027883a 	mov	r19,r2
 2009b3c:	10bfffc4 	addi	r2,r2,-1
 2009b40:	183ff41e 	bne	r3,zero,2009b14 <___vfprintf_internal_r+0x10e4>
 2009b44:	003f1706 	br	20097a4 <___vfprintf_internal_r+0xd74>
 2009b48:	b0025826 	beq	r22,zero,200a4ac <___vfprintf_internal_r+0x1a7c>
 2009b4c:	b807883a 	mov	r3,r23
 2009b50:	d8810dc4 	addi	r2,sp,1079
 2009b54:	882f883a 	mov	r23,r17
 2009b58:	04c00244 	movi	r19,9
 2009b5c:	8023883a 	mov	r17,r16
 2009b60:	da412815 	stw	r9,1184(sp)
 2009b64:	1821883a 	mov	r16,r3
 2009b68:	8009883a 	mov	r4,r16
 2009b6c:	b00b883a 	mov	r5,r22
 2009b70:	01800284 	movi	r6,10
 2009b74:	000f883a 	mov	r7,zero
 2009b78:	1029883a 	mov	r20,r2
 2009b7c:	20131f00 	call	20131f0 <__umoddi3>
 2009b80:	10800c04 	addi	r2,r2,48
 2009b84:	8009883a 	mov	r4,r16
 2009b88:	b00b883a 	mov	r5,r22
 2009b8c:	a0800005 	stb	r2,0(r20)
 2009b90:	01800284 	movi	r6,10
 2009b94:	000f883a 	mov	r7,zero
 2009b98:	2012c280 	call	2012c28 <__udivdi3>
 2009b9c:	1021883a 	mov	r16,r2
 2009ba0:	182d883a 	mov	r22,r3
 2009ba4:	a0bfffc4 	addi	r2,r20,-1
 2009ba8:	183fef1e 	bne	r3,zero,2009b68 <___vfprintf_internal_r+0x1138>
 2009bac:	9c3fee36 	bltu	r19,r16,2009b68 <___vfprintf_internal_r+0x1138>
 2009bb0:	da412817 	ldw	r9,1184(sp)
 2009bb4:	8005883a 	mov	r2,r16
 2009bb8:	8821883a 	mov	r16,r17
 2009bbc:	b823883a 	mov	r17,r23
 2009bc0:	102f883a 	mov	r23,r2
 2009bc4:	d8812717 	ldw	r2,1180(sp)
 2009bc8:	a4ffffc4 	addi	r19,r20,-1
 2009bcc:	bdc00c04 	addi	r23,r23,48
 2009bd0:	14c5c83a 	sub	r2,r2,r19
 2009bd4:	a5ffffc5 	stb	r23,-1(r20)
 2009bd8:	d8812b15 	stw	r2,1196(sp)
 2009bdc:	003c7906 	br	2008dc4 <___vfprintf_internal_r+0x394>
 2009be0:	00c00044 	movi	r3,1
 2009be4:	bd84b03a 	or	r2,r23,r22
 2009be8:	003c6806 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009bec:	dc812417 	ldw	r18,1168(sp)
 2009bf0:	0480ee0e 	bge	zero,r18,2009fac <___vfprintf_internal_r+0x157c>
 2009bf4:	d9013217 	ldw	r4,1224(sp)
 2009bf8:	4cc00015 	stw	r19,0(r9)
 2009bfc:	9100c616 	blt	r18,r4,2009f18 <___vfprintf_internal_r+0x14e8>
 2009c00:	49000115 	stw	r4,4(r9)
 2009c04:	4111883a 	add	r8,r8,r4
 2009c08:	18c00044 	addi	r3,r3,1
 2009c0c:	da011d15 	stw	r8,1140(sp)
 2009c10:	d8c11c15 	stw	r3,1136(sp)
 2009c14:	008001c4 	movi	r2,7
 2009c18:	10c20916 	blt	r2,r3,200a440 <___vfprintf_internal_r+0x1a10>
 2009c1c:	4a400204 	addi	r9,r9,8
 2009c20:	d8813217 	ldw	r2,1224(sp)
 2009c24:	90a5c83a 	sub	r18,r18,r2
 2009c28:	04beae0e 	bge	zero,r18,20096e4 <___vfprintf_internal_r+0xcb4>
 2009c2c:	04c00404 	movi	r19,16
 2009c30:	d8c11c17 	ldw	r3,1136(sp)
 2009c34:	05008174 	movhi	r20,517
 2009c38:	a5379884 	addi	r20,r20,-8606
 2009c3c:	9c81be0e 	bge	r19,r18,200a338 <___vfprintf_internal_r+0x1908>
 2009c40:	058001c4 	movi	r22,7
 2009c44:	ddc12917 	ldw	r23,1188(sp)
 2009c48:	00000306 	br	2009c58 <___vfprintf_internal_r+0x1228>
 2009c4c:	4a400204 	addi	r9,r9,8
 2009c50:	94bffc04 	addi	r18,r18,-16
 2009c54:	9c81b80e 	bge	r19,r18,200a338 <___vfprintf_internal_r+0x1908>
 2009c58:	4d000015 	stw	r20,0(r9)
 2009c5c:	4cc00115 	stw	r19,4(r9)
 2009c60:	42000404 	addi	r8,r8,16
 2009c64:	18c00044 	addi	r3,r3,1
 2009c68:	da011d15 	stw	r8,1140(sp)
 2009c6c:	d8c11c15 	stw	r3,1136(sp)
 2009c70:	b0fff60e 	bge	r22,r3,2009c4c <___vfprintf_internal_r+0x121c>
 2009c74:	8809883a 	mov	r4,r17
 2009c78:	b80b883a 	mov	r5,r23
 2009c7c:	d9811b04 	addi	r6,sp,1132
 2009c80:	20089fc0 	call	20089fc <__sprint_r>
 2009c84:	103cfd1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009c88:	da011d17 	ldw	r8,1140(sp)
 2009c8c:	d8c11c17 	ldw	r3,1136(sp)
 2009c90:	da400404 	addi	r9,sp,16
 2009c94:	003fee06 	br	2009c50 <___vfprintf_internal_r+0x1220>
 2009c98:	d9412917 	ldw	r5,1188(sp)
 2009c9c:	8809883a 	mov	r4,r17
 2009ca0:	d9811b04 	addi	r6,sp,1132
 2009ca4:	20089fc0 	call	20089fc <__sprint_r>
 2009ca8:	103cf41e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009cac:	da011d17 	ldw	r8,1140(sp)
 2009cb0:	d8c11c17 	ldw	r3,1136(sp)
 2009cb4:	da400404 	addi	r9,sp,16
 2009cb8:	003dee06 	br	2009474 <___vfprintf_internal_r+0xa44>
 2009cbc:	00c00084 	movi	r3,2
 2009cc0:	bd84b03a 	or	r2,r23,r22
 2009cc4:	d8012585 	stb	zero,1174(sp)
 2009cc8:	003c3006 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009ccc:	d8813217 	ldw	r2,1224(sp)
 2009cd0:	14ffffc4 	addi	r19,r2,-1
 2009cd4:	04ff630e 	bge	zero,r19,2009a64 <___vfprintf_internal_r+0x1034>
 2009cd8:	05800404 	movi	r22,16
 2009cdc:	05008174 	movhi	r20,517
 2009ce0:	a5379884 	addi	r20,r20,-8606
 2009ce4:	b4c03c0e 	bge	r22,r19,2009dd8 <___vfprintf_internal_r+0x13a8>
 2009ce8:	05c001c4 	movi	r23,7
 2009cec:	df012917 	ldw	fp,1188(sp)
 2009cf0:	00000306 	br	2009d00 <___vfprintf_internal_r+0x12d0>
 2009cf4:	94800204 	addi	r18,r18,8
 2009cf8:	9cfffc04 	addi	r19,r19,-16
 2009cfc:	b4c0360e 	bge	r22,r19,2009dd8 <___vfprintf_internal_r+0x13a8>
 2009d00:	95000015 	stw	r20,0(r18)
 2009d04:	95800115 	stw	r22,4(r18)
 2009d08:	42000404 	addi	r8,r8,16
 2009d0c:	18c00044 	addi	r3,r3,1
 2009d10:	da011d15 	stw	r8,1140(sp)
 2009d14:	d8c11c15 	stw	r3,1136(sp)
 2009d18:	b8fff60e 	bge	r23,r3,2009cf4 <___vfprintf_internal_r+0x12c4>
 2009d1c:	8809883a 	mov	r4,r17
 2009d20:	e00b883a 	mov	r5,fp
 2009d24:	d9811b04 	addi	r6,sp,1132
 2009d28:	20089fc0 	call	20089fc <__sprint_r>
 2009d2c:	103cd31e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009d30:	da011d17 	ldw	r8,1140(sp)
 2009d34:	d8c11c17 	ldw	r3,1136(sp)
 2009d38:	dc800404 	addi	r18,sp,16
 2009d3c:	003fee06 	br	2009cf8 <___vfprintf_internal_r+0x12c8>
 2009d40:	8088703a 	and	r4,r16,r2
 2009d44:	203f1d1e 	bne	r4,zero,20099bc <___vfprintf_internal_r+0xf8c>
 2009d48:	48800115 	stw	r2,4(r9)
 2009d4c:	42000044 	addi	r8,r8,1
 2009d50:	18c00044 	addi	r3,r3,1
 2009d54:	da011d15 	stw	r8,1140(sp)
 2009d58:	d8c11c15 	stw	r3,1136(sp)
 2009d5c:	008001c4 	movi	r2,7
 2009d60:	10c00216 	blt	r2,r3,2009d6c <___vfprintf_internal_r+0x133c>
 2009d64:	4c800204 	addi	r18,r9,8
 2009d68:	003f3e06 	br	2009a64 <___vfprintf_internal_r+0x1034>
 2009d6c:	d9412917 	ldw	r5,1188(sp)
 2009d70:	8809883a 	mov	r4,r17
 2009d74:	d9811b04 	addi	r6,sp,1132
 2009d78:	20089fc0 	call	20089fc <__sprint_r>
 2009d7c:	103cbf1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009d80:	dc800404 	addi	r18,sp,16
 2009d84:	da011d17 	ldw	r8,1140(sp)
 2009d88:	d8c11c17 	ldw	r3,1136(sp)
 2009d8c:	003f3506 	br	2009a64 <___vfprintf_internal_r+0x1034>
 2009d90:	d9412917 	ldw	r5,1188(sp)
 2009d94:	8809883a 	mov	r4,r17
 2009d98:	d9811b04 	addi	r6,sp,1132
 2009d9c:	20089fc0 	call	20089fc <__sprint_r>
 2009da0:	103cb61e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009da4:	da011d17 	ldw	r8,1140(sp)
 2009da8:	d8c11c17 	ldw	r3,1136(sp)
 2009dac:	da400404 	addi	r9,sp,16
 2009db0:	003f0b06 	br	20099e0 <___vfprintf_internal_r+0xfb0>
 2009db4:	d9412917 	ldw	r5,1188(sp)
 2009db8:	8809883a 	mov	r4,r17
 2009dbc:	d9811b04 	addi	r6,sp,1132
 2009dc0:	20089fc0 	call	20089fc <__sprint_r>
 2009dc4:	103cad1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009dc8:	da011d17 	ldw	r8,1140(sp)
 2009dcc:	d8c11c17 	ldw	r3,1136(sp)
 2009dd0:	dc800404 	addi	r18,sp,16
 2009dd4:	003f0d06 	br	2009a0c <___vfprintf_internal_r+0xfdc>
 2009dd8:	95000015 	stw	r20,0(r18)
 2009ddc:	94c00115 	stw	r19,4(r18)
 2009de0:	44d1883a 	add	r8,r8,r19
 2009de4:	003f1906 	br	2009a4c <___vfprintf_internal_r+0x101c>
 2009de8:	d9412917 	ldw	r5,1188(sp)
 2009dec:	8809883a 	mov	r4,r17
 2009df0:	d9811b04 	addi	r6,sp,1132
 2009df4:	20089fc0 	call	20089fc <__sprint_r>
 2009df8:	103ca01e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009dfc:	da011d17 	ldw	r8,1140(sp)
 2009e00:	d8c11c17 	ldw	r3,1136(sp)
 2009e04:	da400404 	addi	r9,sp,16
 2009e08:	003db706 	br	20094e8 <___vfprintf_internal_r+0xab8>
 2009e0c:	4d000015 	stw	r20,0(r9)
 2009e10:	4c800115 	stw	r18,4(r9)
 2009e14:	4491883a 	add	r8,r8,r18
 2009e18:	003de706 	br	20095b8 <___vfprintf_internal_r+0xb88>
 2009e1c:	8080100c 	andi	r2,r16,64
 2009e20:	10010226 	beq	r2,zero,200a22c <___vfprintf_internal_r+0x17fc>
 2009e24:	d8812d17 	ldw	r2,1204(sp)
 2009e28:	002d883a 	mov	r22,zero
 2009e2c:	00c00044 	movi	r3,1
 2009e30:	15c0000b 	ldhu	r23,0(r2)
 2009e34:	10800104 	addi	r2,r2,4
 2009e38:	d8812d15 	stw	r2,1204(sp)
 2009e3c:	d8012585 	stb	zero,1174(sp)
 2009e40:	b805883a 	mov	r2,r23
 2009e44:	003bd106 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009e48:	d9012d17 	ldw	r4,1204(sp)
 2009e4c:	25800017 	ldw	r22,0(r4)
 2009e50:	25000117 	ldw	r20,4(r4)
 2009e54:	21000204 	addi	r4,r4,8
 2009e58:	d9012d15 	stw	r4,1204(sp)
 2009e5c:	dd813315 	stw	r22,1228(sp)
 2009e60:	dd013415 	stw	r20,1232(sp)
 2009e64:	003d2b06 	br	2009314 <___vfprintf_internal_r+0x8e4>
 2009e68:	8080100c 	andi	r2,r16,64
 2009e6c:	1000fe26 	beq	r2,zero,200a268 <___vfprintf_internal_r+0x1838>
 2009e70:	d9012d17 	ldw	r4,1204(sp)
 2009e74:	002d883a 	mov	r22,zero
 2009e78:	0007883a 	mov	r3,zero
 2009e7c:	25c0000b 	ldhu	r23,0(r4)
 2009e80:	21000104 	addi	r4,r4,4
 2009e84:	d9012d15 	stw	r4,1204(sp)
 2009e88:	b805883a 	mov	r2,r23
 2009e8c:	d8012585 	stb	zero,1174(sp)
 2009e90:	003bbe06 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009e94:	8080100c 	andi	r2,r16,64
 2009e98:	1000ed26 	beq	r2,zero,200a250 <___vfprintf_internal_r+0x1820>
 2009e9c:	d9012d17 	ldw	r4,1204(sp)
 2009ea0:	002d883a 	mov	r22,zero
 2009ea4:	25c0000b 	ldhu	r23,0(r4)
 2009ea8:	21000104 	addi	r4,r4,4
 2009eac:	d9012d15 	stw	r4,1204(sp)
 2009eb0:	003cd206 	br	20091fc <___vfprintf_internal_r+0x7cc>
 2009eb4:	00c00084 	movi	r3,2
 2009eb8:	d8012585 	stb	zero,1174(sp)
 2009ebc:	003bb306 	br	2008d8c <___vfprintf_internal_r+0x35c>
 2009ec0:	8080040c 	andi	r2,r16,16
 2009ec4:	1000f11e 	bne	r2,zero,200a28c <___vfprintf_internal_r+0x185c>
 2009ec8:	8400100c 	andi	r16,r16,64
 2009ecc:	80015526 	beq	r16,zero,200a424 <___vfprintf_internal_r+0x19f4>
 2009ed0:	da012d17 	ldw	r8,1204(sp)
 2009ed4:	d8c12c17 	ldw	r3,1200(sp)
 2009ed8:	40800017 	ldw	r2,0(r8)
 2009edc:	42000104 	addi	r8,r8,4
 2009ee0:	da012d15 	stw	r8,1204(sp)
 2009ee4:	10c0000d 	sth	r3,0(r2)
 2009ee8:	003b0706 	br	2008b08 <___vfprintf_internal_r+0xd8>
 2009eec:	8080100c 	andi	r2,r16,64
 2009ef0:	1000c726 	beq	r2,zero,200a210 <___vfprintf_internal_r+0x17e0>
 2009ef4:	da012d17 	ldw	r8,1204(sp)
 2009ef8:	45c0000f 	ldh	r23,0(r8)
 2009efc:	42000104 	addi	r8,r8,4
 2009f00:	da012d15 	stw	r8,1204(sp)
 2009f04:	b82dd7fa 	srai	r22,r23,31
 2009f08:	b005883a 	mov	r2,r22
 2009f0c:	003c1006 	br	2008f50 <___vfprintf_internal_r+0x520>
 2009f10:	ac800007 	ldb	r18,0(r21)
 2009f14:	003b2406 	br	2008ba8 <___vfprintf_internal_r+0x178>
 2009f18:	4c800115 	stw	r18,4(r9)
 2009f1c:	9211883a 	add	r8,r18,r8
 2009f20:	18c00044 	addi	r3,r3,1
 2009f24:	da011d15 	stw	r8,1140(sp)
 2009f28:	d8c11c15 	stw	r3,1136(sp)
 2009f2c:	008001c4 	movi	r2,7
 2009f30:	10c15416 	blt	r2,r3,200a484 <___vfprintf_internal_r+0x1a54>
 2009f34:	4a400204 	addi	r9,r9,8
 2009f38:	d8813717 	ldw	r2,1244(sp)
 2009f3c:	9ca7883a 	add	r19,r19,r18
 2009f40:	48800015 	stw	r2,0(r9)
 2009f44:	00800044 	movi	r2,1
 2009f48:	48800115 	stw	r2,4(r9)
 2009f4c:	4091883a 	add	r8,r8,r2
 2009f50:	1887883a 	add	r3,r3,r2
 2009f54:	da011d15 	stw	r8,1140(sp)
 2009f58:	d8c11c15 	stw	r3,1136(sp)
 2009f5c:	008001c4 	movi	r2,7
 2009f60:	10c14016 	blt	r2,r3,200a464 <___vfprintf_internal_r+0x1a34>
 2009f64:	4a400204 	addi	r9,r9,8
 2009f68:	d9013217 	ldw	r4,1224(sp)
 2009f6c:	da011d17 	ldw	r8,1140(sp)
 2009f70:	d8c11c17 	ldw	r3,1136(sp)
 2009f74:	24a5c83a 	sub	r18,r4,r18
 2009f78:	4cc00015 	stw	r19,0(r9)
 2009f7c:	003fa406 	br	2009e10 <___vfprintf_internal_r+0x13e0>
 2009f80:	04c08174 	movhi	r19,517
 2009f84:	9cf78504 	addi	r19,r19,-8684
 2009f88:	003cf406 	br	200935c <___vfprintf_internal_r+0x92c>
 2009f8c:	d9412917 	ldw	r5,1188(sp)
 2009f90:	8809883a 	mov	r4,r17
 2009f94:	d9811b04 	addi	r6,sp,1132
 2009f98:	20089fc0 	call	20089fc <__sprint_r>
 2009f9c:	103c371e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 2009fa0:	da011d17 	ldw	r8,1140(sp)
 2009fa4:	da400404 	addi	r9,sp,16
 2009fa8:	003e1c06 	br	200981c <___vfprintf_internal_r+0xdec>
 2009fac:	00808174 	movhi	r2,517
 2009fb0:	10b79404 	addi	r2,r2,-8624
 2009fb4:	48800015 	stw	r2,0(r9)
 2009fb8:	00800044 	movi	r2,1
 2009fbc:	48800115 	stw	r2,4(r9)
 2009fc0:	4091883a 	add	r8,r8,r2
 2009fc4:	1887883a 	add	r3,r3,r2
 2009fc8:	da011d15 	stw	r8,1140(sp)
 2009fcc:	d8c11c15 	stw	r3,1136(sp)
 2009fd0:	008001c4 	movi	r2,7
 2009fd4:	10c0c316 	blt	r2,r3,200a2e4 <___vfprintf_internal_r+0x18b4>
 2009fd8:	4a400204 	addi	r9,r9,8
 2009fdc:	9000041e 	bne	r18,zero,2009ff0 <___vfprintf_internal_r+0x15c0>
 2009fe0:	d8c13217 	ldw	r3,1224(sp)
 2009fe4:	1800021e 	bne	r3,zero,2009ff0 <___vfprintf_internal_r+0x15c0>
 2009fe8:	8080004c 	andi	r2,r16,1
 2009fec:	103d7826 	beq	r2,zero,20095d0 <___vfprintf_internal_r+0xba0>
 2009ff0:	d8c11c17 	ldw	r3,1136(sp)
 2009ff4:	d9013717 	ldw	r4,1244(sp)
 2009ff8:	00800044 	movi	r2,1
 2009ffc:	48800115 	stw	r2,4(r9)
 200a000:	49000015 	stw	r4,0(r9)
 200a004:	4091883a 	add	r8,r8,r2
 200a008:	1887883a 	add	r3,r3,r2
 200a00c:	da011d15 	stw	r8,1140(sp)
 200a010:	d8c11c15 	stw	r3,1136(sp)
 200a014:	008001c4 	movi	r2,7
 200a018:	10c12e16 	blt	r2,r3,200a4d4 <___vfprintf_internal_r+0x1aa4>
 200a01c:	4a400204 	addi	r9,r9,8
 200a020:	04a5c83a 	sub	r18,zero,r18
 200a024:	0480de0e 	bge	zero,r18,200a3a0 <___vfprintf_internal_r+0x1970>
 200a028:	05800404 	movi	r22,16
 200a02c:	05008174 	movhi	r20,517
 200a030:	a5379884 	addi	r20,r20,-8606
 200a034:	b480e20e 	bge	r22,r18,200a3c0 <___vfprintf_internal_r+0x1990>
 200a038:	05c001c4 	movi	r23,7
 200a03c:	df012917 	ldw	fp,1188(sp)
 200a040:	00000306 	br	200a050 <___vfprintf_internal_r+0x1620>
 200a044:	4a400204 	addi	r9,r9,8
 200a048:	94bffc04 	addi	r18,r18,-16
 200a04c:	b480dc0e 	bge	r22,r18,200a3c0 <___vfprintf_internal_r+0x1990>
 200a050:	4d000015 	stw	r20,0(r9)
 200a054:	4d800115 	stw	r22,4(r9)
 200a058:	42000404 	addi	r8,r8,16
 200a05c:	18c00044 	addi	r3,r3,1
 200a060:	da011d15 	stw	r8,1140(sp)
 200a064:	d8c11c15 	stw	r3,1136(sp)
 200a068:	b8fff60e 	bge	r23,r3,200a044 <___vfprintf_internal_r+0x1614>
 200a06c:	8809883a 	mov	r4,r17
 200a070:	e00b883a 	mov	r5,fp
 200a074:	d9811b04 	addi	r6,sp,1132
 200a078:	20089fc0 	call	20089fc <__sprint_r>
 200a07c:	103bff1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a080:	da011d17 	ldw	r8,1140(sp)
 200a084:	d8c11c17 	ldw	r3,1136(sp)
 200a088:	da400404 	addi	r9,sp,16
 200a08c:	003fee06 	br	200a048 <___vfprintf_internal_r+0x1618>
 200a090:	da413c15 	stw	r9,1264(sp)
 200a094:	200fc7c0 	call	200fc7c <__isnand>
 200a098:	da413c17 	ldw	r9,1264(sp)
 200a09c:	1000851e 	bne	r2,zero,200a2b4 <___vfprintf_internal_r+0x1884>
 200a0a0:	00bfffc4 	movi	r2,-1
 200a0a4:	e0817626 	beq	fp,r2,200a680 <___vfprintf_internal_r+0x1c50>
 200a0a8:	008019c4 	movi	r2,103
 200a0ac:	90817126 	beq	r18,r2,200a674 <___vfprintf_internal_r+0x1c44>
 200a0b0:	008011c4 	movi	r2,71
 200a0b4:	90816f26 	beq	r18,r2,200a674 <___vfprintf_internal_r+0x1c44>
 200a0b8:	82004014 	ori	r8,r16,256
 200a0bc:	da012a15 	stw	r8,1192(sp)
 200a0c0:	a0017116 	blt	r20,zero,200a688 <___vfprintf_internal_r+0x1c58>
 200a0c4:	d8012f05 	stb	zero,1212(sp)
 200a0c8:	00801984 	movi	r2,102
 200a0cc:	90811226 	beq	r18,r2,200a518 <___vfprintf_internal_r+0x1ae8>
 200a0d0:	00801184 	movi	r2,70
 200a0d4:	90811026 	beq	r18,r2,200a518 <___vfprintf_internal_r+0x1ae8>
 200a0d8:	00801944 	movi	r2,101
 200a0dc:	90819b26 	beq	r18,r2,200a74c <___vfprintf_internal_r+0x1d1c>
 200a0e0:	00801144 	movi	r2,69
 200a0e4:	90819926 	beq	r18,r2,200a74c <___vfprintf_internal_r+0x1d1c>
 200a0e8:	e02f883a 	mov	r23,fp
 200a0ec:	d8812404 	addi	r2,sp,1168
 200a0f0:	d8800115 	stw	r2,4(sp)
 200a0f4:	d8812304 	addi	r2,sp,1164
 200a0f8:	d8800215 	stw	r2,8(sp)
 200a0fc:	d8812204 	addi	r2,sp,1160
 200a100:	ddc00015 	stw	r23,0(sp)
 200a104:	d8800315 	stw	r2,12(sp)
 200a108:	8809883a 	mov	r4,r17
 200a10c:	b00b883a 	mov	r5,r22
 200a110:	a00d883a 	mov	r6,r20
 200a114:	01c00084 	movi	r7,2
 200a118:	da413c15 	stw	r9,1264(sp)
 200a11c:	200c5280 	call	200c528 <_dtoa_r>
 200a120:	1027883a 	mov	r19,r2
 200a124:	008019c4 	movi	r2,103
 200a128:	da413c17 	ldw	r9,1264(sp)
 200a12c:	90818c1e 	bne	r18,r2,200a760 <___vfprintf_internal_r+0x1d30>
 200a130:	8080004c 	andi	r2,r16,1
 200a134:	10017926 	beq	r2,zero,200a71c <___vfprintf_internal_r+0x1cec>
 200a138:	00801184 	movi	r2,70
 200a13c:	9dc7883a 	add	r3,r19,r23
 200a140:	90810626 	beq	r18,r2,200a55c <___vfprintf_internal_r+0x1b2c>
 200a144:	b009883a 	mov	r4,r22
 200a148:	a00b883a 	mov	r5,r20
 200a14c:	000d883a 	mov	r6,zero
 200a150:	000f883a 	mov	r7,zero
 200a154:	d8c13b15 	stw	r3,1260(sp)
 200a158:	da413c15 	stw	r9,1264(sp)
 200a15c:	20141200 	call	2014120 <__eqdf2>
 200a160:	d8c13b17 	ldw	r3,1260(sp)
 200a164:	da413c17 	ldw	r9,1264(sp)
 200a168:	10000726 	beq	r2,zero,200a188 <___vfprintf_internal_r+0x1758>
 200a16c:	d8812217 	ldw	r2,1160(sp)
 200a170:	10c1962e 	bgeu	r2,r3,200a7cc <___vfprintf_internal_r+0x1d9c>
 200a174:	01000c04 	movi	r4,48
 200a178:	11000005 	stb	r4,0(r2)
 200a17c:	10800044 	addi	r2,r2,1
 200a180:	d8812215 	stw	r2,1160(sp)
 200a184:	10fffc1e 	bne	r2,r3,200a178 <___vfprintf_internal_r+0x1748>
 200a188:	1cc7c83a 	sub	r3,r3,r19
 200a18c:	d8c13215 	stw	r3,1224(sp)
 200a190:	008019c4 	movi	r2,103
 200a194:	90810626 	beq	r18,r2,200a5b0 <___vfprintf_internal_r+0x1b80>
 200a198:	008011c4 	movi	r2,71
 200a19c:	90810426 	beq	r18,r2,200a5b0 <___vfprintf_internal_r+0x1b80>
 200a1a0:	00801984 	movi	r2,102
 200a1a4:	90819a1e 	bne	r18,r2,200a810 <___vfprintf_internal_r+0x1de0>
 200a1a8:	d8812417 	ldw	r2,1168(sp)
 200a1ac:	d8812b15 	stw	r2,1196(sp)
 200a1b0:	0081880e 	bge	zero,r2,200a7d4 <___vfprintf_internal_r+0x1da4>
 200a1b4:	e000021e 	bne	fp,zero,200a1c0 <___vfprintf_internal_r+0x1790>
 200a1b8:	8400004c 	andi	r16,r16,1
 200a1bc:	80000426 	beq	r16,zero,200a1d0 <___vfprintf_internal_r+0x17a0>
 200a1c0:	d8812b17 	ldw	r2,1196(sp)
 200a1c4:	e2000044 	addi	r8,fp,1
 200a1c8:	1205883a 	add	r2,r2,r8
 200a1cc:	d8812b15 	stw	r2,1196(sp)
 200a1d0:	d8812815 	stw	r2,1184(sp)
 200a1d4:	10011716 	blt	r2,zero,200a634 <___vfprintf_internal_r+0x1c04>
 200a1d8:	ddc12f07 	ldb	r23,1212(sp)
 200a1dc:	b800ca26 	beq	r23,zero,200a508 <___vfprintf_internal_r+0x1ad8>
 200a1e0:	00800b44 	movi	r2,45
 200a1e4:	d8812585 	stb	r2,1174(sp)
 200a1e8:	dc012a17 	ldw	r16,1192(sp)
 200a1ec:	d8013115 	stw	zero,1220(sp)
 200a1f0:	003afe06 	br	2008dec <___vfprintf_internal_r+0x3bc>
 200a1f4:	d8812b17 	ldw	r2,1196(sp)
 200a1f8:	d8812815 	stw	r2,1184(sp)
 200a1fc:	10005e16 	blt	r2,zero,200a378 <___vfprintf_internal_r+0x1948>
 200a200:	d8812583 	ldbu	r2,1174(sp)
 200a204:	ddc12d15 	stw	r23,1204(sp)
 200a208:	d8013115 	stw	zero,1220(sp)
 200a20c:	003af306 	br	2008ddc <___vfprintf_internal_r+0x3ac>
 200a210:	d8812d17 	ldw	r2,1204(sp)
 200a214:	15c00017 	ldw	r23,0(r2)
 200a218:	10800104 	addi	r2,r2,4
 200a21c:	d8812d15 	stw	r2,1204(sp)
 200a220:	b82dd7fa 	srai	r22,r23,31
 200a224:	b005883a 	mov	r2,r22
 200a228:	003b4906 	br	2008f50 <___vfprintf_internal_r+0x520>
 200a22c:	d8c12d17 	ldw	r3,1204(sp)
 200a230:	002d883a 	mov	r22,zero
 200a234:	1dc00017 	ldw	r23,0(r3)
 200a238:	18c00104 	addi	r3,r3,4
 200a23c:	d8c12d15 	stw	r3,1204(sp)
 200a240:	b805883a 	mov	r2,r23
 200a244:	00c00044 	movi	r3,1
 200a248:	d8012585 	stb	zero,1174(sp)
 200a24c:	003acf06 	br	2008d8c <___vfprintf_internal_r+0x35c>
 200a250:	da012d17 	ldw	r8,1204(sp)
 200a254:	002d883a 	mov	r22,zero
 200a258:	45c00017 	ldw	r23,0(r8)
 200a25c:	42000104 	addi	r8,r8,4
 200a260:	da012d15 	stw	r8,1204(sp)
 200a264:	003be506 	br	20091fc <___vfprintf_internal_r+0x7cc>
 200a268:	da012d17 	ldw	r8,1204(sp)
 200a26c:	002d883a 	mov	r22,zero
 200a270:	0007883a 	mov	r3,zero
 200a274:	45c00017 	ldw	r23,0(r8)
 200a278:	42000104 	addi	r8,r8,4
 200a27c:	da012d15 	stw	r8,1204(sp)
 200a280:	b805883a 	mov	r2,r23
 200a284:	d8012585 	stb	zero,1174(sp)
 200a288:	003ac006 	br	2008d8c <___vfprintf_internal_r+0x35c>
 200a28c:	d8c12d17 	ldw	r3,1204(sp)
 200a290:	d9012c17 	ldw	r4,1200(sp)
 200a294:	18800017 	ldw	r2,0(r3)
 200a298:	18c00104 	addi	r3,r3,4
 200a29c:	d8c12d15 	stw	r3,1204(sp)
 200a2a0:	11000015 	stw	r4,0(r2)
 200a2a4:	003a1806 	br	2008b08 <___vfprintf_internal_r+0xd8>
 200a2a8:	073fffc4 	movi	fp,-1
 200a2ac:	202b883a 	mov	r21,r4
 200a2b0:	003a3e06 	br	2008bac <___vfprintf_internal_r+0x17c>
 200a2b4:	008011c4 	movi	r2,71
 200a2b8:	14809016 	blt	r2,r18,200a4fc <___vfprintf_internal_r+0x1acc>
 200a2bc:	04c08174 	movhi	r19,517
 200a2c0:	9cf78604 	addi	r19,r19,-8680
 200a2c4:	00c000c4 	movi	r3,3
 200a2c8:	00bfdfc4 	movi	r2,-129
 200a2cc:	80a0703a 	and	r16,r16,r2
 200a2d0:	d8c12815 	stw	r3,1184(sp)
 200a2d4:	d8812583 	ldbu	r2,1174(sp)
 200a2d8:	d8c12b15 	stw	r3,1196(sp)
 200a2dc:	d8013115 	stw	zero,1220(sp)
 200a2e0:	003abe06 	br	2008ddc <___vfprintf_internal_r+0x3ac>
 200a2e4:	d9412917 	ldw	r5,1188(sp)
 200a2e8:	8809883a 	mov	r4,r17
 200a2ec:	d9811b04 	addi	r6,sp,1132
 200a2f0:	20089fc0 	call	20089fc <__sprint_r>
 200a2f4:	103b611e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a2f8:	dc812417 	ldw	r18,1168(sp)
 200a2fc:	da011d17 	ldw	r8,1140(sp)
 200a300:	da400404 	addi	r9,sp,16
 200a304:	003f3506 	br	2009fdc <___vfprintf_internal_r+0x15ac>
 200a308:	ad400044 	addi	r21,r21,1
 200a30c:	84000814 	ori	r16,r16,32
 200a310:	14800047 	ldb	r18,1(r2)
 200a314:	003a2406 	br	2008ba8 <___vfprintf_internal_r+0x178>
 200a318:	d9412917 	ldw	r5,1188(sp)
 200a31c:	8809883a 	mov	r4,r17
 200a320:	d9811b04 	addi	r6,sp,1132
 200a324:	20089fc0 	call	20089fc <__sprint_r>
 200a328:	103b541e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a32c:	da011d17 	ldw	r8,1140(sp)
 200a330:	da400404 	addi	r9,sp,16
 200a334:	003d4a06 	br	2009860 <___vfprintf_internal_r+0xe30>
 200a338:	4d000015 	stw	r20,0(r9)
 200a33c:	4c800115 	stw	r18,4(r9)
 200a340:	4491883a 	add	r8,r8,r18
 200a344:	18c00044 	addi	r3,r3,1
 200a348:	da011d15 	stw	r8,1140(sp)
 200a34c:	d8c11c15 	stw	r3,1136(sp)
 200a350:	008001c4 	movi	r2,7
 200a354:	10fcdc16 	blt	r2,r3,20096c8 <___vfprintf_internal_r+0xc98>
 200a358:	4a400204 	addi	r9,r9,8
 200a35c:	003ce106 	br	20096e4 <___vfprintf_internal_r+0xcb4>
 200a360:	da413c15 	stw	r9,1264(sp)
 200a364:	2007c640 	call	2007c64 <strlen>
 200a368:	d8812b15 	stw	r2,1196(sp)
 200a36c:	d8812815 	stw	r2,1184(sp)
 200a370:	da413c17 	ldw	r9,1264(sp)
 200a374:	103fa20e 	bge	r2,zero,200a200 <___vfprintf_internal_r+0x17d0>
 200a378:	d8012815 	stw	zero,1184(sp)
 200a37c:	003fa006 	br	200a200 <___vfprintf_internal_r+0x17d0>
 200a380:	d9412917 	ldw	r5,1188(sp)
 200a384:	8809883a 	mov	r4,r17
 200a388:	d9811b04 	addi	r6,sp,1132
 200a38c:	20089fc0 	call	20089fc <__sprint_r>
 200a390:	103b3a1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a394:	da011d17 	ldw	r8,1140(sp)
 200a398:	d8c11c17 	ldw	r3,1136(sp)
 200a39c:	da400404 	addi	r9,sp,16
 200a3a0:	d8813217 	ldw	r2,1224(sp)
 200a3a4:	4cc00015 	stw	r19,0(r9)
 200a3a8:	48800115 	stw	r2,4(r9)
 200a3ac:	4091883a 	add	r8,r8,r2
 200a3b0:	003c8106 	br	20095b8 <___vfprintf_internal_r+0xb88>
 200a3b4:	00800b44 	movi	r2,45
 200a3b8:	d8812585 	stb	r2,1174(sp)
 200a3bc:	003be306 	br	200934c <___vfprintf_internal_r+0x91c>
 200a3c0:	4d000015 	stw	r20,0(r9)
 200a3c4:	4c800115 	stw	r18,4(r9)
 200a3c8:	4491883a 	add	r8,r8,r18
 200a3cc:	18c00044 	addi	r3,r3,1
 200a3d0:	da011d15 	stw	r8,1140(sp)
 200a3d4:	d8c11c15 	stw	r3,1136(sp)
 200a3d8:	008001c4 	movi	r2,7
 200a3dc:	10ffe816 	blt	r2,r3,200a380 <___vfprintf_internal_r+0x1950>
 200a3e0:	4a400204 	addi	r9,r9,8
 200a3e4:	003fee06 	br	200a3a0 <___vfprintf_internal_r+0x1970>
 200a3e8:	df012b15 	stw	fp,1196(sp)
 200a3ec:	00800184 	movi	r2,6
 200a3f0:	1700072e 	bgeu	r2,fp,200a410 <___vfprintf_internal_r+0x19e0>
 200a3f4:	d8812b15 	stw	r2,1196(sp)
 200a3f8:	d8812815 	stw	r2,1184(sp)
 200a3fc:	ddc12d15 	stw	r23,1204(sp)
 200a400:	04c08174 	movhi	r19,517
 200a404:	9cf79204 	addi	r19,r19,-8632
 200a408:	d8013115 	stw	zero,1220(sp)
 200a40c:	003a7a06 	br	2008df8 <___vfprintf_internal_r+0x3c8>
 200a410:	d8812b17 	ldw	r2,1196(sp)
 200a414:	d8812815 	stw	r2,1184(sp)
 200a418:	103ff80e 	bge	r2,zero,200a3fc <___vfprintf_internal_r+0x19cc>
 200a41c:	d8012815 	stw	zero,1184(sp)
 200a420:	003ff606 	br	200a3fc <___vfprintf_internal_r+0x19cc>
 200a424:	d9012d17 	ldw	r4,1204(sp)
 200a428:	da012c17 	ldw	r8,1200(sp)
 200a42c:	20800017 	ldw	r2,0(r4)
 200a430:	21000104 	addi	r4,r4,4
 200a434:	d9012d15 	stw	r4,1204(sp)
 200a438:	12000015 	stw	r8,0(r2)
 200a43c:	0039b206 	br	2008b08 <___vfprintf_internal_r+0xd8>
 200a440:	d9412917 	ldw	r5,1188(sp)
 200a444:	8809883a 	mov	r4,r17
 200a448:	d9811b04 	addi	r6,sp,1132
 200a44c:	20089fc0 	call	20089fc <__sprint_r>
 200a450:	103b0a1e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a454:	dc812417 	ldw	r18,1168(sp)
 200a458:	da011d17 	ldw	r8,1140(sp)
 200a45c:	da400404 	addi	r9,sp,16
 200a460:	003def06 	br	2009c20 <___vfprintf_internal_r+0x11f0>
 200a464:	d9412917 	ldw	r5,1188(sp)
 200a468:	8809883a 	mov	r4,r17
 200a46c:	d9811b04 	addi	r6,sp,1132
 200a470:	20089fc0 	call	20089fc <__sprint_r>
 200a474:	103b011e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a478:	dc812417 	ldw	r18,1168(sp)
 200a47c:	da400404 	addi	r9,sp,16
 200a480:	003eb906 	br	2009f68 <___vfprintf_internal_r+0x1538>
 200a484:	d9412917 	ldw	r5,1188(sp)
 200a488:	8809883a 	mov	r4,r17
 200a48c:	d9811b04 	addi	r6,sp,1132
 200a490:	20089fc0 	call	20089fc <__sprint_r>
 200a494:	103af91e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a498:	dc812417 	ldw	r18,1168(sp)
 200a49c:	da011d17 	ldw	r8,1140(sp)
 200a4a0:	d8c11c17 	ldw	r3,1136(sp)
 200a4a4:	da400404 	addi	r9,sp,16
 200a4a8:	003ea306 	br	2009f38 <___vfprintf_internal_r+0x1508>
 200a4ac:	00800244 	movi	r2,9
 200a4b0:	15fda636 	bltu	r2,r23,2009b4c <___vfprintf_internal_r+0x111c>
 200a4b4:	dd010e04 	addi	r20,sp,1080
 200a4b8:	003dc206 	br	2009bc4 <___vfprintf_internal_r+0x1194>
 200a4bc:	df012815 	stw	fp,1184(sp)
 200a4c0:	d8812583 	ldbu	r2,1174(sp)
 200a4c4:	df012b15 	stw	fp,1196(sp)
 200a4c8:	ddc12d15 	stw	r23,1204(sp)
 200a4cc:	d8013115 	stw	zero,1220(sp)
 200a4d0:	003a4206 	br	2008ddc <___vfprintf_internal_r+0x3ac>
 200a4d4:	d9412917 	ldw	r5,1188(sp)
 200a4d8:	8809883a 	mov	r4,r17
 200a4dc:	d9811b04 	addi	r6,sp,1132
 200a4e0:	20089fc0 	call	20089fc <__sprint_r>
 200a4e4:	103ae51e 	bne	r2,zero,200907c <___vfprintf_internal_r+0x64c>
 200a4e8:	dc812417 	ldw	r18,1168(sp)
 200a4ec:	da011d17 	ldw	r8,1140(sp)
 200a4f0:	d8c11c17 	ldw	r3,1136(sp)
 200a4f4:	da400404 	addi	r9,sp,16
 200a4f8:	003ec906 	br	200a020 <___vfprintf_internal_r+0x15f0>
 200a4fc:	04c08174 	movhi	r19,517
 200a500:	9cf78704 	addi	r19,r19,-8676
 200a504:	003f6f06 	br	200a2c4 <___vfprintf_internal_r+0x1894>
 200a508:	d8812583 	ldbu	r2,1174(sp)
 200a50c:	dc012a17 	ldw	r16,1192(sp)
 200a510:	d8013115 	stw	zero,1220(sp)
 200a514:	003a3106 	br	2008ddc <___vfprintf_internal_r+0x3ac>
 200a518:	d8812404 	addi	r2,sp,1168
 200a51c:	d8800115 	stw	r2,4(sp)
 200a520:	d8812304 	addi	r2,sp,1164
 200a524:	d8800215 	stw	r2,8(sp)
 200a528:	d8812204 	addi	r2,sp,1160
 200a52c:	df000015 	stw	fp,0(sp)
 200a530:	d8800315 	stw	r2,12(sp)
 200a534:	8809883a 	mov	r4,r17
 200a538:	b00b883a 	mov	r5,r22
 200a53c:	a00d883a 	mov	r6,r20
 200a540:	01c000c4 	movi	r7,3
 200a544:	da413c15 	stw	r9,1264(sp)
 200a548:	200c5280 	call	200c528 <_dtoa_r>
 200a54c:	da413c17 	ldw	r9,1264(sp)
 200a550:	1027883a 	mov	r19,r2
 200a554:	1707883a 	add	r3,r2,fp
 200a558:	e02f883a 	mov	r23,fp
 200a55c:	99000007 	ldb	r4,0(r19)
 200a560:	00800c04 	movi	r2,48
 200a564:	20800326 	beq	r4,r2,200a574 <___vfprintf_internal_r+0x1b44>
 200a568:	da812417 	ldw	r10,1168(sp)
 200a56c:	1a87883a 	add	r3,r3,r10
 200a570:	003ef406 	br	200a144 <___vfprintf_internal_r+0x1714>
 200a574:	b009883a 	mov	r4,r22
 200a578:	a00b883a 	mov	r5,r20
 200a57c:	000d883a 	mov	r6,zero
 200a580:	000f883a 	mov	r7,zero
 200a584:	d8c13b15 	stw	r3,1260(sp)
 200a588:	da413c15 	stw	r9,1264(sp)
 200a58c:	201417c0 	call	201417c <__nedf2>
 200a590:	d8c13b17 	ldw	r3,1260(sp)
 200a594:	da413c17 	ldw	r9,1264(sp)
 200a598:	103ff326 	beq	r2,zero,200a568 <___vfprintf_internal_r+0x1b38>
 200a59c:	00800044 	movi	r2,1
 200a5a0:	15d5c83a 	sub	r10,r2,r23
 200a5a4:	da812415 	stw	r10,1168(sp)
 200a5a8:	1a87883a 	add	r3,r3,r10
 200a5ac:	003ee506 	br	200a144 <___vfprintf_internal_r+0x1714>
 200a5b0:	d8812417 	ldw	r2,1168(sp)
 200a5b4:	d8812b15 	stw	r2,1196(sp)
 200a5b8:	1029883a 	mov	r20,r2
 200a5bc:	00bfff44 	movi	r2,-3
 200a5c0:	a0800116 	blt	r20,r2,200a5c8 <___vfprintf_internal_r+0x1b98>
 200a5c4:	e5001d0e 	bge	fp,r20,200a63c <___vfprintf_internal_r+0x1c0c>
 200a5c8:	94bfff84 	addi	r18,r18,-2
 200a5cc:	a53fffc4 	addi	r20,r20,-1
 200a5d0:	dd012415 	stw	r20,1168(sp)
 200a5d4:	dc811fc5 	stb	r18,1151(sp)
 200a5d8:	a0007816 	blt	r20,zero,200a7bc <___vfprintf_internal_r+0x1d8c>
 200a5dc:	00800ac4 	movi	r2,43
 200a5e0:	d8812005 	stb	r2,1152(sp)
 200a5e4:	00800244 	movi	r2,9
 200a5e8:	15002b16 	blt	r2,r20,200a698 <___vfprintf_internal_r+0x1c68>
 200a5ec:	00800c04 	movi	r2,48
 200a5f0:	a5000c04 	addi	r20,r20,48
 200a5f4:	d8812045 	stb	r2,1153(sp)
 200a5f8:	dd012085 	stb	r20,1154(sp)
 200a5fc:	d8c120c4 	addi	r3,sp,1155
 200a600:	d8811fc4 	addi	r2,sp,1151
 200a604:	da013217 	ldw	r8,1224(sp)
 200a608:	1885c83a 	sub	r2,r3,r2
 200a60c:	d8813515 	stw	r2,1236(sp)
 200a610:	4085883a 	add	r2,r8,r2
 200a614:	d8812b15 	stw	r2,1196(sp)
 200a618:	00800044 	movi	r2,1
 200a61c:	1200610e 	bge	r2,r8,200a7a4 <___vfprintf_internal_r+0x1d74>
 200a620:	d8812b17 	ldw	r2,1196(sp)
 200a624:	10800044 	addi	r2,r2,1
 200a628:	d8812b15 	stw	r2,1196(sp)
 200a62c:	d8812815 	stw	r2,1184(sp)
 200a630:	103ee90e 	bge	r2,zero,200a1d8 <___vfprintf_internal_r+0x17a8>
 200a634:	d8012815 	stw	zero,1184(sp)
 200a638:	003ee706 	br	200a1d8 <___vfprintf_internal_r+0x17a8>
 200a63c:	d8812b17 	ldw	r2,1196(sp)
 200a640:	da013217 	ldw	r8,1224(sp)
 200a644:	12003716 	blt	r2,r8,200a724 <___vfprintf_internal_r+0x1cf4>
 200a648:	8400004c 	andi	r16,r16,1
 200a64c:	80000326 	beq	r16,zero,200a65c <___vfprintf_internal_r+0x1c2c>
 200a650:	d8812b17 	ldw	r2,1196(sp)
 200a654:	10800044 	addi	r2,r2,1
 200a658:	d8812b15 	stw	r2,1196(sp)
 200a65c:	d8812815 	stw	r2,1184(sp)
 200a660:	10003716 	blt	r2,zero,200a740 <___vfprintf_internal_r+0x1d10>
 200a664:	048019c4 	movi	r18,103
 200a668:	003edb06 	br	200a1d8 <___vfprintf_internal_r+0x17a8>
 200a66c:	d8012815 	stw	zero,1184(sp)
 200a670:	003b6906 	br	2009418 <___vfprintf_internal_r+0x9e8>
 200a674:	e03e901e 	bne	fp,zero,200a0b8 <___vfprintf_internal_r+0x1688>
 200a678:	07000044 	movi	fp,1
 200a67c:	003e8e06 	br	200a0b8 <___vfprintf_internal_r+0x1688>
 200a680:	07000184 	movi	fp,6
 200a684:	003e8c06 	br	200a0b8 <___vfprintf_internal_r+0x1688>
 200a688:	00c00b44 	movi	r3,45
 200a68c:	a520003c 	xorhi	r20,r20,32768
 200a690:	d8c12f05 	stb	r3,1212(sp)
 200a694:	003e8c06 	br	200a0c8 <___vfprintf_internal_r+0x1698>
 200a698:	d8c11f84 	addi	r3,sp,1150
 200a69c:	102f883a 	mov	r23,r2
 200a6a0:	4839883a 	mov	fp,r9
 200a6a4:	a009883a 	mov	r4,r20
 200a6a8:	01400284 	movi	r5,10
 200a6ac:	182d883a 	mov	r22,r3
 200a6b0:	20147400 	call	2014740 <__modsi3>
 200a6b4:	10800c04 	addi	r2,r2,48
 200a6b8:	a009883a 	mov	r4,r20
 200a6bc:	b0800005 	stb	r2,0(r22)
 200a6c0:	01400284 	movi	r5,10
 200a6c4:	20146f00 	call	20146f0 <__divsi3>
 200a6c8:	1029883a 	mov	r20,r2
 200a6cc:	b0ffffc4 	addi	r3,r22,-1
 200a6d0:	b8bff416 	blt	r23,r2,200a6a4 <___vfprintf_internal_r+0x1c74>
 200a6d4:	11400c04 	addi	r5,r2,48
 200a6d8:	b17fffc5 	stb	r5,-1(r22)
 200a6dc:	d8811fc4 	addi	r2,sp,1151
 200a6e0:	e013883a 	mov	r9,fp
 200a6e4:	1880482e 	bgeu	r3,r2,200a808 <___vfprintf_internal_r+0x1dd8>
 200a6e8:	b007883a 	mov	r3,r22
 200a6ec:	d9012044 	addi	r4,sp,1153
 200a6f0:	00000206 	br	200a6fc <___vfprintf_internal_r+0x1ccc>
 200a6f4:	19400003 	ldbu	r5,0(r3)
 200a6f8:	18c00044 	addi	r3,r3,1
 200a6fc:	21400005 	stb	r5,0(r4)
 200a700:	21000044 	addi	r4,r4,1
 200a704:	10fffb1e 	bne	r2,r3,200a6f4 <___vfprintf_internal_r+0x1cc4>
 200a708:	d8c12004 	addi	r3,sp,1152
 200a70c:	1d87c83a 	sub	r3,r3,r22
 200a710:	d9012044 	addi	r4,sp,1153
 200a714:	20c7883a 	add	r3,r4,r3
 200a718:	003fba06 	br	200a604 <___vfprintf_internal_r+0x1bd4>
 200a71c:	d8c12217 	ldw	r3,1160(sp)
 200a720:	003e9906 	br	200a188 <___vfprintf_internal_r+0x1758>
 200a724:	05000b0e 	bge	zero,r20,200a754 <___vfprintf_internal_r+0x1d24>
 200a728:	05000044 	movi	r20,1
 200a72c:	da013217 	ldw	r8,1224(sp)
 200a730:	a229883a 	add	r20,r20,r8
 200a734:	dd012b15 	stw	r20,1196(sp)
 200a738:	dd012815 	stw	r20,1184(sp)
 200a73c:	a03fc90e 	bge	r20,zero,200a664 <___vfprintf_internal_r+0x1c34>
 200a740:	d8012815 	stw	zero,1184(sp)
 200a744:	048019c4 	movi	r18,103
 200a748:	003ea306 	br	200a1d8 <___vfprintf_internal_r+0x17a8>
 200a74c:	e5c00044 	addi	r23,fp,1
 200a750:	003e6606 	br	200a0ec <___vfprintf_internal_r+0x16bc>
 200a754:	00800084 	movi	r2,2
 200a758:	1529c83a 	sub	r20,r2,r20
 200a75c:	003ff306 	br	200a72c <___vfprintf_internal_r+0x1cfc>
 200a760:	008011c4 	movi	r2,71
 200a764:	90be7226 	beq	r18,r2,200a130 <___vfprintf_internal_r+0x1700>
 200a768:	003e7306 	br	200a138 <___vfprintf_internal_r+0x1708>
 200a76c:	d8812d17 	ldw	r2,1204(sp)
 200a770:	ac800043 	ldbu	r18,1(r21)
 200a774:	202b883a 	mov	r21,r4
 200a778:	17000017 	ldw	fp,0(r2)
 200a77c:	10800104 	addi	r2,r2,4
 200a780:	d8812d15 	stw	r2,1204(sp)
 200a784:	e0001b16 	blt	fp,zero,200a7f4 <___vfprintf_internal_r+0x1dc4>
 200a788:	94803fcc 	andi	r18,r18,255
 200a78c:	9480201c 	xori	r18,r18,128
 200a790:	94bfe004 	addi	r18,r18,-128
 200a794:	00390406 	br	2008ba8 <___vfprintf_internal_r+0x178>
 200a798:	00bfffc4 	movi	r2,-1
 200a79c:	d8812c15 	stw	r2,1200(sp)
 200a7a0:	003a2506 	br	2009038 <___vfprintf_internal_r+0x608>
 200a7a4:	80a0703a 	and	r16,r16,r2
 200a7a8:	803f9d1e 	bne	r16,zero,200a620 <___vfprintf_internal_r+0x1bf0>
 200a7ac:	d8812b17 	ldw	r2,1196(sp)
 200a7b0:	d8812815 	stw	r2,1184(sp)
 200a7b4:	103e880e 	bge	r2,zero,200a1d8 <___vfprintf_internal_r+0x17a8>
 200a7b8:	003f9e06 	br	200a634 <___vfprintf_internal_r+0x1c04>
 200a7bc:	00800b44 	movi	r2,45
 200a7c0:	0529c83a 	sub	r20,zero,r20
 200a7c4:	d8812005 	stb	r2,1152(sp)
 200a7c8:	003f8606 	br	200a5e4 <___vfprintf_internal_r+0x1bb4>
 200a7cc:	1007883a 	mov	r3,r2
 200a7d0:	003e6d06 	br	200a188 <___vfprintf_internal_r+0x1758>
 200a7d4:	e000021e 	bne	fp,zero,200a7e0 <___vfprintf_internal_r+0x1db0>
 200a7d8:	8400004c 	andi	r16,r16,1
 200a7dc:	80000e26 	beq	r16,zero,200a818 <___vfprintf_internal_r+0x1de8>
 200a7e0:	e7000084 	addi	fp,fp,2
 200a7e4:	df012b15 	stw	fp,1196(sp)
 200a7e8:	df012815 	stw	fp,1184(sp)
 200a7ec:	e03e7a0e 	bge	fp,zero,200a1d8 <___vfprintf_internal_r+0x17a8>
 200a7f0:	003f9006 	br	200a634 <___vfprintf_internal_r+0x1c04>
 200a7f4:	94803fcc 	andi	r18,r18,255
 200a7f8:	9480201c 	xori	r18,r18,128
 200a7fc:	073fffc4 	movi	fp,-1
 200a800:	94bfe004 	addi	r18,r18,-128
 200a804:	0038e806 	br	2008ba8 <___vfprintf_internal_r+0x178>
 200a808:	d8c12044 	addi	r3,sp,1153
 200a80c:	003f7d06 	br	200a604 <___vfprintf_internal_r+0x1bd4>
 200a810:	dd012417 	ldw	r20,1168(sp)
 200a814:	003f6d06 	br	200a5cc <___vfprintf_internal_r+0x1b9c>
 200a818:	00c00044 	movi	r3,1
 200a81c:	d8c12815 	stw	r3,1184(sp)
 200a820:	d8c12b15 	stw	r3,1196(sp)
 200a824:	003e6c06 	br	200a1d8 <___vfprintf_internal_r+0x17a8>

0200a828 <__vfprintf_internal>:
 200a828:	00808174 	movhi	r2,517
 200a82c:	10903604 	addi	r2,r2,16600
 200a830:	2007883a 	mov	r3,r4
 200a834:	11000017 	ldw	r4,0(r2)
 200a838:	2805883a 	mov	r2,r5
 200a83c:	300f883a 	mov	r7,r6
 200a840:	180b883a 	mov	r5,r3
 200a844:	100d883a 	mov	r6,r2
 200a848:	2008a301 	jmpi	2008a30 <___vfprintf_internal_r>

0200a84c <__svfscanf_r>:
 200a84c:	deff4c04 	addi	sp,sp,-720
 200a850:	df00b215 	stw	fp,712(sp)
 200a854:	ddc0b115 	stw	r23,708(sp)
 200a858:	dd00ae15 	stw	r20,696(sp)
 200a85c:	dc80ac15 	stw	r18,688(sp)
 200a860:	dc40ab15 	stw	r17,684(sp)
 200a864:	dc00aa15 	stw	r16,680(sp)
 200a868:	dfc0b315 	stw	ra,716(sp)
 200a86c:	dd80b015 	stw	r22,704(sp)
 200a870:	dd40af15 	stw	r21,700(sp)
 200a874:	dcc0ad15 	stw	r19,692(sp)
 200a878:	30800007 	ldb	r2,0(r6)
 200a87c:	0025883a 	mov	r18,zero
 200a880:	d9c09c15 	stw	r7,624(sp)
 200a884:	d800a015 	stw	zero,640(sp)
 200a888:	d8009f15 	stw	zero,636(sp)
 200a88c:	d8009e15 	stw	zero,632(sp)
 200a890:	d8809b15 	stw	r2,620(sp)
 200a894:	2023883a 	mov	r17,r4
 200a898:	05c08174 	movhi	r23,517
 200a89c:	bdd03404 	addi	r23,r23,16592
 200a8a0:	9029883a 	mov	r20,r18
 200a8a4:	2839883a 	mov	fp,r5
 200a8a8:	34000044 	addi	r16,r6,1
 200a8ac:	10002426 	beq	r2,zero,200a940 <__svfscanf_r+0xf4>
 200a8b0:	b9000017 	ldw	r4,0(r23)
 200a8b4:	2087883a 	add	r3,r4,r2
 200a8b8:	18c00003 	ldbu	r3,0(r3)
 200a8bc:	18c0020c 	andi	r3,r3,8
 200a8c0:	18c03fcc 	andi	r3,r3,255
 200a8c4:	18c0201c 	xori	r3,r3,128
 200a8c8:	18ffe004 	addi	r3,r3,-128
 200a8cc:	18002926 	beq	r3,zero,200a974 <__svfscanf_r+0x128>
 200a8d0:	e0800117 	ldw	r2,4(fp)
 200a8d4:	0080110e 	bge	zero,r2,200a91c <__svfscanf_r+0xd0>
 200a8d8:	e0c00017 	ldw	r3,0(fp)
 200a8dc:	b9000017 	ldw	r4,0(r23)
 200a8e0:	18800003 	ldbu	r2,0(r3)
 200a8e4:	2085883a 	add	r2,r4,r2
 200a8e8:	10800003 	ldbu	r2,0(r2)
 200a8ec:	1080020c 	andi	r2,r2,8
 200a8f0:	10803fcc 	andi	r2,r2,255
 200a8f4:	1080201c 	xori	r2,r2,128
 200a8f8:	10bfe004 	addi	r2,r2,-128
 200a8fc:	10000b26 	beq	r2,zero,200a92c <__svfscanf_r+0xe0>
 200a900:	e0800117 	ldw	r2,4(fp)
 200a904:	18c00044 	addi	r3,r3,1
 200a908:	e0c00015 	stw	r3,0(fp)
 200a90c:	10bfffc4 	addi	r2,r2,-1
 200a910:	e0800115 	stw	r2,4(fp)
 200a914:	a5000044 	addi	r20,r20,1
 200a918:	00bfef16 	blt	zero,r2,200a8d8 <__svfscanf_r+0x8c>
 200a91c:	8809883a 	mov	r4,r17
 200a920:	e00b883a 	mov	r5,fp
 200a924:	2006ce40 	call	2006ce4 <__srefill_r>
 200a928:	103feb26 	beq	r2,zero,200a8d8 <__svfscanf_r+0x8c>
 200a92c:	800d883a 	mov	r6,r16
 200a930:	30800007 	ldb	r2,0(r6)
 200a934:	34000044 	addi	r16,r6,1
 200a938:	d8809b15 	stw	r2,620(sp)
 200a93c:	103fdc1e 	bne	r2,zero,200a8b0 <__svfscanf_r+0x64>
 200a940:	d8809e17 	ldw	r2,632(sp)
 200a944:	dfc0b317 	ldw	ra,716(sp)
 200a948:	df00b217 	ldw	fp,712(sp)
 200a94c:	ddc0b117 	ldw	r23,708(sp)
 200a950:	dd80b017 	ldw	r22,704(sp)
 200a954:	dd40af17 	ldw	r21,700(sp)
 200a958:	dd00ae17 	ldw	r20,696(sp)
 200a95c:	dcc0ad17 	ldw	r19,692(sp)
 200a960:	dc80ac17 	ldw	r18,688(sp)
 200a964:	dc40ab17 	ldw	r17,684(sp)
 200a968:	dc00aa17 	ldw	r16,680(sp)
 200a96c:	dec0b404 	addi	sp,sp,720
 200a970:	f800283a 	ret
 200a974:	00c00944 	movi	r3,37
 200a978:	10c00e26 	beq	r2,r3,200a9b4 <__svfscanf_r+0x168>
 200a97c:	e0800117 	ldw	r2,4(fp)
 200a980:	0080e10e 	bge	zero,r2,200ad08 <__svfscanf_r+0x4bc>
 200a984:	e0800017 	ldw	r2,0(fp)
 200a988:	80ffffc7 	ldb	r3,-1(r16)
 200a98c:	11000003 	ldbu	r4,0(r2)
 200a990:	20ffeb1e 	bne	r4,r3,200a940 <__svfscanf_r+0xf4>
 200a994:	e0c00117 	ldw	r3,4(fp)
 200a998:	10800044 	addi	r2,r2,1
 200a99c:	e0800015 	stw	r2,0(fp)
 200a9a0:	18bfffc4 	addi	r2,r3,-1
 200a9a4:	e0800115 	stw	r2,4(fp)
 200a9a8:	a5000044 	addi	r20,r20,1
 200a9ac:	800d883a 	mov	r6,r16
 200a9b0:	003fdf06 	br	200a930 <__svfscanf_r+0xe4>
 200a9b4:	31400043 	ldbu	r5,1(r6)
 200a9b8:	002d883a 	mov	r22,zero
 200a9bc:	0027883a 	mov	r19,zero
 200a9c0:	01801e04 	movi	r6,120
 200a9c4:	01c01b04 	movi	r7,108
 200a9c8:	28803fcc 	andi	r2,r5,255
 200a9cc:	80c00044 	addi	r3,r16,1
 200a9d0:	30804d2e 	bgeu	r6,r2,200ab08 <__svfscanf_r+0x2bc>
 200a9d4:	29403fcc 	andi	r5,r5,255
 200a9d8:	2940201c 	xori	r5,r5,128
 200a9dc:	297fe004 	addi	r5,r5,-128
 200a9e0:	2149883a 	add	r4,r4,r5
 200a9e4:	20800003 	ldbu	r2,0(r4)
 200a9e8:	d8c09d15 	stw	r3,628(sp)
 200a9ec:	1080004c 	andi	r2,r2,1
 200a9f0:	1002d81e 	bne	r2,zero,200b554 <__svfscanf_r+0xd08>
 200a9f4:	02008074 	movhi	r8,513
 200a9f8:	4221db04 	addi	r8,r8,-30868
 200a9fc:	da00a015 	stw	r8,640(sp)
 200aa00:	02000284 	movi	r8,10
 200aa04:	da009f15 	stw	r8,636(sp)
 200aa08:	040000c4 	movi	r16,3
 200aa0c:	e0800117 	ldw	r2,4(fp)
 200aa10:	0081bd0e 	bge	zero,r2,200b108 <__svfscanf_r+0x8bc>
 200aa14:	b080100c 	andi	r2,r22,64
 200aa18:	1000ce26 	beq	r2,zero,200ad54 <__svfscanf_r+0x508>
 200aa1c:	00800084 	movi	r2,2
 200aa20:	80818426 	beq	r16,r2,200b034 <__svfscanf_r+0x7e8>
 200aa24:	1400f716 	blt	r2,r16,200ae04 <__svfscanf_r+0x5b8>
 200aa28:	00800044 	movi	r2,1
 200aa2c:	8080dc26 	beq	r16,r2,200ada0 <__svfscanf_r+0x554>
 200aa30:	9800011e 	bne	r19,zero,200aa38 <__svfscanf_r+0x1ec>
 200aa34:	04c00044 	movi	r19,1
 200aa38:	b080004c 	andi	r2,r22,1
 200aa3c:	10022826 	beq	r2,zero,200b2e0 <__svfscanf_r+0xa94>
 200aa40:	b480040c 	andi	r18,r22,16
 200aa44:	9004051e 	bne	r18,zero,200ba5c <__svfscanf_r+0x1210>
 200aa48:	d8809c17 	ldw	r2,624(sp)
 200aa4c:	15800017 	ldw	r22,0(r2)
 200aa50:	10800104 	addi	r2,r2,4
 200aa54:	d8809c15 	stw	r2,624(sp)
 200aa58:	0021883a 	mov	r16,zero
 200aa5c:	dd409904 	addi	r21,sp,612
 200aa60:	00c08174 	movhi	r3,517
 200aa64:	18d03904 	addi	r3,r3,16612
 200aa68:	18800017 	ldw	r2,0(r3)
 200aa6c:	8080aa26 	beq	r16,r2,200ad18 <__svfscanf_r+0x4cc>
 200aa70:	e0800017 	ldw	r2,0(fp)
 200aa74:	e2000117 	ldw	r8,4(fp)
 200aa78:	d9000104 	addi	r4,sp,4
 200aa7c:	11c00003 	ldbu	r7,0(r2)
 200aa80:	423fffc4 	addi	r8,r8,-1
 200aa84:	10800044 	addi	r2,r2,1
 200aa88:	2407883a 	add	r3,r4,r16
 200aa8c:	000b883a 	mov	r5,zero
 200aa90:	a809883a 	mov	r4,r21
 200aa94:	01800204 	movi	r6,8
 200aa98:	e2000115 	stw	r8,4(fp)
 200aa9c:	e0800015 	stw	r2,0(fp)
 200aaa0:	19c00005 	stb	r7,0(r3)
 200aaa4:	84000044 	addi	r16,r16,1
 200aaa8:	200682c0 	call	200682c <memset>
 200aaac:	b00b883a 	mov	r5,r22
 200aab0:	8809883a 	mov	r4,r17
 200aab4:	dd400015 	stw	r21,0(sp)
 200aab8:	d9800104 	addi	r6,sp,4
 200aabc:	800f883a 	mov	r7,r16
 200aac0:	200e3d80 	call	200e3d8 <_mbrtowc_r>
 200aac4:	017fffc4 	movi	r5,-1
 200aac8:	11409326 	beq	r2,r5,200ad18 <__svfscanf_r+0x4cc>
 200aacc:	10030d1e 	bne	r2,zero,200b704 <__svfscanf_r+0xeb8>
 200aad0:	9000011e 	bne	r18,zero,200aad8 <__svfscanf_r+0x28c>
 200aad4:	b0000015 	stw	zero,0(r22)
 200aad8:	a429883a 	add	r20,r20,r16
 200aadc:	9cffffc4 	addi	r19,r19,-1
 200aae0:	90030d1e 	bne	r18,zero,200b718 <__svfscanf_r+0xecc>
 200aae4:	b5800104 	addi	r22,r22,4
 200aae8:	0021883a 	mov	r16,zero
 200aaec:	e0800117 	ldw	r2,4(fp)
 200aaf0:	00820b0e 	bge	zero,r2,200b320 <__svfscanf_r+0xad4>
 200aaf4:	983fda1e 	bne	r19,zero,200aa60 <__svfscanf_r+0x214>
 200aaf8:	90012226 	beq	r18,zero,200af84 <__svfscanf_r+0x738>
 200aafc:	dc009d17 	ldw	r16,628(sp)
 200ab00:	800d883a 	mov	r6,r16
 200ab04:	003f8a06 	br	200a930 <__svfscanf_r+0xe4>
 200ab08:	1085883a 	add	r2,r2,r2
 200ab0c:	1085883a 	add	r2,r2,r2
 200ab10:	02008074 	movhi	r8,513
 200ab14:	422ac904 	addi	r8,r8,-21724
 200ab18:	1205883a 	add	r2,r2,r8
 200ab1c:	10800017 	ldw	r2,0(r2)
 200ab20:	1000683a 	jmp	r2
 200ab24:	0200ad38 	rdprs	r8,zero,692
 200ab28:	0200a9d4 	movui	r8,679
 200ab2c:	0200a9d4 	movui	r8,679
 200ab30:	0200a9d4 	movui	r8,679
 200ab34:	0200a9d4 	movui	r8,679
 200ab38:	0200a9d4 	movui	r8,679
 200ab3c:	0200a9d4 	movui	r8,679
 200ab40:	0200a9d4 	movui	r8,679
 200ab44:	0200a9d4 	movui	r8,679
 200ab48:	0200a9d4 	movui	r8,679
 200ab4c:	0200a9d4 	movui	r8,679
 200ab50:	0200a9d4 	movui	r8,679
 200ab54:	0200a9d4 	movui	r8,679
 200ab58:	0200a9d4 	movui	r8,679
 200ab5c:	0200a9d4 	movui	r8,679
 200ab60:	0200a9d4 	movui	r8,679
 200ab64:	0200a9d4 	movui	r8,679
 200ab68:	0200a9d4 	movui	r8,679
 200ab6c:	0200a9d4 	movui	r8,679
 200ab70:	0200a9d4 	movui	r8,679
 200ab74:	0200a9d4 	movui	r8,679
 200ab78:	0200a9d4 	movui	r8,679
 200ab7c:	0200a9d4 	movui	r8,679
 200ab80:	0200a9d4 	movui	r8,679
 200ab84:	0200a9d4 	movui	r8,679
 200ab88:	0200a9d4 	movui	r8,679
 200ab8c:	0200a9d4 	movui	r8,679
 200ab90:	0200a9d4 	movui	r8,679
 200ab94:	0200a9d4 	movui	r8,679
 200ab98:	0200a9d4 	movui	r8,679
 200ab9c:	0200a9d4 	movui	r8,679
 200aba0:	0200a9d4 	movui	r8,679
 200aba4:	0200a9d4 	movui	r8,679
 200aba8:	0200a9d4 	movui	r8,679
 200abac:	0200a9d4 	movui	r8,679
 200abb0:	0200a9d4 	movui	r8,679
 200abb4:	0200a9d4 	movui	r8,679
 200abb8:	0200b57c 	xorhi	r8,zero,725
 200abbc:	0200a9d4 	movui	r8,679
 200abc0:	0200a9d4 	movui	r8,679
 200abc4:	0200a9d4 	movui	r8,679
 200abc8:	0200a9d4 	movui	r8,679
 200abcc:	0200b5d4 	movui	r8,727
 200abd0:	0200a9d4 	movui	r8,679
 200abd4:	0200a9d4 	movui	r8,679
 200abd8:	0200a9d4 	movui	r8,679
 200abdc:	0200a9d4 	movui	r8,679
 200abe0:	0200a9d4 	movui	r8,679
 200abe4:	0200b5e4 	muli	r8,zero,727
 200abe8:	0200b5e4 	muli	r8,zero,727
 200abec:	0200b5e4 	muli	r8,zero,727
 200abf0:	0200b5e4 	muli	r8,zero,727
 200abf4:	0200b5e4 	muli	r8,zero,727
 200abf8:	0200b5e4 	muli	r8,zero,727
 200abfc:	0200b5e4 	muli	r8,zero,727
 200ac00:	0200b5e4 	muli	r8,zero,727
 200ac04:	0200b5e4 	muli	r8,zero,727
 200ac08:	0200b5e4 	muli	r8,zero,727
 200ac0c:	0200a9d4 	movui	r8,679
 200ac10:	0200a9d4 	movui	r8,679
 200ac14:	0200a9d4 	movui	r8,679
 200ac18:	0200a9d4 	movui	r8,679
 200ac1c:	0200a9d4 	movui	r8,679
 200ac20:	0200a9d4 	movui	r8,679
 200ac24:	0200a9d4 	movui	r8,679
 200ac28:	0200a9d4 	movui	r8,679
 200ac2c:	0200a9d4 	movui	r8,679
 200ac30:	0200a9d4 	movui	r8,679
 200ac34:	0200b588 	cmpgei	r8,zero,726
 200ac38:	0200b594 	movui	r8,726
 200ac3c:	0200a9d4 	movui	r8,679
 200ac40:	0200b594 	movui	r8,726
 200ac44:	0200a9d4 	movui	r8,679
 200ac48:	0200a9d4 	movui	r8,679
 200ac4c:	0200a9d4 	movui	r8,679
 200ac50:	0200a9d4 	movui	r8,679
 200ac54:	0200b5a0 	cmpeqi	r8,zero,726
 200ac58:	0200a9d4 	movui	r8,679
 200ac5c:	0200a9d4 	movui	r8,679
 200ac60:	0200b5b0 	cmpltui	r8,zero,726
 200ac64:	0200a9d4 	movui	r8,679
 200ac68:	0200a9d4 	movui	r8,679
 200ac6c:	0200a9d4 	movui	r8,679
 200ac70:	0200a9d4 	movui	r8,679
 200ac74:	0200a9d4 	movui	r8,679
 200ac78:	0200a9d4 	movui	r8,679
 200ac7c:	0200a9d4 	movui	r8,679
 200ac80:	0200a9d4 	movui	r8,679
 200ac84:	0200b608 	cmpgei	r8,zero,728
 200ac88:	0200a9d4 	movui	r8,679
 200ac8c:	0200a9d4 	movui	r8,679
 200ac90:	0200b62c 	andhi	r8,zero,728
 200ac94:	0200a9d4 	movui	r8,679
 200ac98:	0200a9d4 	movui	r8,679
 200ac9c:	0200a9d4 	movui	r8,679
 200aca0:	0200a9d4 	movui	r8,679
 200aca4:	0200a9d4 	movui	r8,679
 200aca8:	0200a9d4 	movui	r8,679
 200acac:	0200a9d4 	movui	r8,679
 200acb0:	0200b64c 	andi	r8,zero,729
 200acb4:	0200b65c 	xori	r8,zero,729
 200acb8:	0200b594 	movui	r8,726
 200acbc:	0200b594 	movui	r8,726
 200acc0:	0200b594 	movui	r8,726
 200acc4:	0200b664 	muli	r8,zero,729
 200acc8:	0200b674 	movhi	r8,729
 200accc:	0200a9d4 	movui	r8,679
 200acd0:	0200a9d4 	movui	r8,679
 200acd4:	0200b690 	cmplti	r8,zero,730
 200acd8:	0200a9d4 	movui	r8,679
 200acdc:	0200b6b0 	cmpltui	r8,zero,730
 200ace0:	0200b6f0 	cmpltui	r8,zero,731
 200ace4:	0200b6e4 	muli	r8,zero,731
 200ace8:	0200a9d4 	movui	r8,679
 200acec:	0200a9d4 	movui	r8,679
 200acf0:	0200b6f8 	rdprs	r8,zero,731
 200acf4:	0200a9d4 	movui	r8,679
 200acf8:	0200b55c 	xori	r8,zero,725
 200acfc:	0200a9d4 	movui	r8,679
 200ad00:	0200a9d4 	movui	r8,679
 200ad04:	0200b608 	cmpgei	r8,zero,728
 200ad08:	8809883a 	mov	r4,r17
 200ad0c:	e00b883a 	mov	r5,fp
 200ad10:	2006ce40 	call	2006ce4 <__srefill_r>
 200ad14:	103f1b26 	beq	r2,zero,200a984 <__svfscanf_r+0x138>
 200ad18:	d8809e17 	ldw	r2,632(sp)
 200ad1c:	10000626 	beq	r2,zero,200ad38 <__svfscanf_r+0x4ec>
 200ad20:	e080030b 	ldhu	r2,12(fp)
 200ad24:	1080100c 	andi	r2,r2,64
 200ad28:	10bfffcc 	andi	r2,r2,65535
 200ad2c:	10a0001c 	xori	r2,r2,32768
 200ad30:	10a00004 	addi	r2,r2,-32768
 200ad34:	103f0226 	beq	r2,zero,200a940 <__svfscanf_r+0xf4>
 200ad38:	00bfffc4 	movi	r2,-1
 200ad3c:	d8809e15 	stw	r2,632(sp)
 200ad40:	003eff06 	br	200a940 <__svfscanf_r+0xf4>
 200ad44:	8809883a 	mov	r4,r17
 200ad48:	e00b883a 	mov	r5,fp
 200ad4c:	2006ce40 	call	2006ce4 <__srefill_r>
 200ad50:	103ff11e 	bne	r2,zero,200ad18 <__svfscanf_r+0x4cc>
 200ad54:	b9400017 	ldw	r5,0(r23)
 200ad58:	e0800017 	ldw	r2,0(fp)
 200ad5c:	00000206 	br	200ad68 <__svfscanf_r+0x51c>
 200ad60:	10800044 	addi	r2,r2,1
 200ad64:	e0800015 	stw	r2,0(fp)
 200ad68:	10c00003 	ldbu	r3,0(r2)
 200ad6c:	28c7883a 	add	r3,r5,r3
 200ad70:	18c00003 	ldbu	r3,0(r3)
 200ad74:	18c0020c 	andi	r3,r3,8
 200ad78:	18c03fcc 	andi	r3,r3,255
 200ad7c:	18c0201c 	xori	r3,r3,128
 200ad80:	18ffe004 	addi	r3,r3,-128
 200ad84:	183f2526 	beq	r3,zero,200aa1c <__svfscanf_r+0x1d0>
 200ad88:	e0c00117 	ldw	r3,4(fp)
 200ad8c:	a5000044 	addi	r20,r20,1
 200ad90:	18ffffc4 	addi	r3,r3,-1
 200ad94:	e0c00115 	stw	r3,4(fp)
 200ad98:	00fff116 	blt	zero,r3,200ad60 <__svfscanf_r+0x514>
 200ad9c:	003fe906 	br	200ad44 <__svfscanf_r+0x4f8>
 200ada0:	9800011e 	bne	r19,zero,200ada8 <__svfscanf_r+0x55c>
 200ada4:	04ffffc4 	movi	r19,-1
 200ada8:	b580040c 	andi	r22,r22,16
 200adac:	b0016826 	beq	r22,zero,200b350 <__svfscanf_r+0xb04>
 200adb0:	e0800017 	ldw	r2,0(fp)
 200adb4:	0021883a 	mov	r16,zero
 200adb8:	dd405884 	addi	r21,sp,354
 200adbc:	10c00003 	ldbu	r3,0(r2)
 200adc0:	a8c7883a 	add	r3,r21,r3
 200adc4:	18c00007 	ldb	r3,0(r3)
 200adc8:	18036b26 	beq	r3,zero,200bb78 <__svfscanf_r+0x132c>
 200adcc:	e0c00117 	ldw	r3,4(fp)
 200add0:	10800044 	addi	r2,r2,1
 200add4:	84000044 	addi	r16,r16,1
 200add8:	18ffffc4 	addi	r3,r3,-1
 200addc:	e0c00115 	stw	r3,4(fp)
 200ade0:	e0800015 	stw	r2,0(fp)
 200ade4:	9c008f26 	beq	r19,r16,200b024 <__svfscanf_r+0x7d8>
 200ade8:	00fff416 	blt	zero,r3,200adbc <__svfscanf_r+0x570>
 200adec:	8809883a 	mov	r4,r17
 200adf0:	e00b883a 	mov	r5,fp
 200adf4:	2006ce40 	call	2006ce4 <__srefill_r>
 200adf8:	10008a1e 	bne	r2,zero,200b024 <__svfscanf_r+0x7d8>
 200adfc:	e0800017 	ldw	r2,0(fp)
 200ae00:	003fee06 	br	200adbc <__svfscanf_r+0x570>
 200ae04:	008000c4 	movi	r2,3
 200ae08:	80806426 	beq	r16,r2,200af9c <__svfscanf_r+0x750>
 200ae0c:	00800104 	movi	r2,4
 200ae10:	80bf071e 	bne	r16,r2,200aa30 <__svfscanf_r+0x1e4>
 200ae14:	98bfffc4 	addi	r2,r19,-1
 200ae18:	01005704 	movi	r4,348
 200ae1c:	20814736 	bltu	r4,r2,200b33c <__svfscanf_r+0xaf0>
 200ae20:	0017883a 	mov	r11,zero
 200ae24:	b581e014 	ori	r22,r22,1920
 200ae28:	0021883a 	mov	r16,zero
 200ae2c:	d800a115 	stw	zero,644(sp)
 200ae30:	d800a315 	stw	zero,652(sp)
 200ae34:	002b883a 	mov	r21,zero
 200ae38:	d800a215 	stw	zero,648(sp)
 200ae3c:	dc800104 	addi	r18,sp,4
 200ae40:	000d883a 	mov	r6,zero
 200ae44:	00c01384 	movi	r3,78
 200ae48:	03810004 	movi	r14,1024
 200ae4c:	033e1fc4 	movi	r12,-1921
 200ae50:	03ff5fc4 	movi	r15,-641
 200ae54:	e1c00017 	ldw	r7,0(fp)
 200ae58:	39400003 	ldbu	r5,0(r7)
 200ae5c:	28bff544 	addi	r2,r5,-43
 200ae60:	10803fcc 	andi	r2,r2,255
 200ae64:	1880c82e 	bgeu	r3,r2,200b188 <__svfscanf_r+0x93c>
 200ae68:	a8000226 	beq	r21,zero,200ae74 <__svfscanf_r+0x628>
 200ae6c:	00bfbfc4 	movi	r2,-257
 200ae70:	b0ac703a 	and	r22,r22,r2
 200ae74:	31bfffc4 	addi	r6,r6,-1
 200ae78:	00800044 	movi	r2,1
 200ae7c:	1183fd2e 	bgeu	r2,r6,200be74 <__svfscanf_r+0x1628>
 200ae80:	80803fcc 	andi	r2,r16,255
 200ae84:	1080201c 	xori	r2,r2,128
 200ae88:	10bfe004 	addi	r2,r2,-128
 200ae8c:	10ffffc4 	addi	r3,r2,-1
 200ae90:	01000184 	movi	r4,6
 200ae94:	20c01036 	bltu	r4,r3,200aed8 <__svfscanf_r+0x68c>
 200ae98:	00c00084 	movi	r3,2
 200ae9c:	1883e90e 	bge	r3,r2,200be44 <__svfscanf_r+0x15f8>
 200aea0:	00c000c4 	movi	r3,3
 200aea4:	10c00c26 	beq	r2,r3,200aed8 <__svfscanf_r+0x68c>
 200aea8:	843fff04 	addi	r16,r16,-4
 200aeac:	84c03fcc 	andi	r19,r16,255
 200aeb0:	04c4303a 	nor	r2,zero,r19
 200aeb4:	90a1883a 	add	r16,r18,r2
 200aeb8:	94bfffc4 	addi	r18,r18,-1
 200aebc:	91400007 	ldb	r5,0(r18)
 200aec0:	8809883a 	mov	r4,r17
 200aec4:	e00d883a 	mov	r6,fp
 200aec8:	2011d640 	call	2011d64 <_ungetc_r>
 200aecc:	943ffa1e 	bne	r18,r16,200aeb8 <__svfscanf_r+0x66c>
 200aed0:	a27fffc4 	addi	r9,r20,-1
 200aed4:	4ce9c83a 	sub	r20,r9,r19
 200aed8:	b080400c 	andi	r2,r22,256
 200aedc:	10001326 	beq	r2,zero,200af2c <__svfscanf_r+0x6e0>
 200aee0:	b081000c 	andi	r2,r22,1024
 200aee4:	1003c41e 	bne	r2,zero,200bdf8 <__svfscanf_r+0x15ac>
 200aee8:	917fffc7 	ldb	r5,-1(r18)
 200aeec:	00801944 	movi	r2,101
 200aef0:	943fffc4 	addi	r16,r18,-1
 200aef4:	a53fffc4 	addi	r20,r20,-1
 200aef8:	28800826 	beq	r5,r2,200af1c <__svfscanf_r+0x6d0>
 200aefc:	00801144 	movi	r2,69
 200af00:	28800626 	beq	r5,r2,200af1c <__svfscanf_r+0x6d0>
 200af04:	8809883a 	mov	r4,r17
 200af08:	e00d883a 	mov	r6,fp
 200af0c:	2011d640 	call	2011d64 <_ungetc_r>
 200af10:	917fff87 	ldb	r5,-2(r18)
 200af14:	943fff84 	addi	r16,r18,-2
 200af18:	a53fffc4 	addi	r20,r20,-1
 200af1c:	8809883a 	mov	r4,r17
 200af20:	e00d883a 	mov	r6,fp
 200af24:	2011d640 	call	2011d64 <_ungetc_r>
 200af28:	8025883a 	mov	r18,r16
 200af2c:	b080040c 	andi	r2,r22,16
 200af30:	103ef21e 	bne	r2,zero,200aafc <__svfscanf_r+0x2b0>
 200af34:	90000005 	stb	zero,0(r18)
 200af38:	b0c1800c 	andi	r3,r22,1536
 200af3c:	00810004 	movi	r2,1024
 200af40:	18834326 	beq	r3,r2,200bc50 <__svfscanf_r+0x1404>
 200af44:	d8c0a317 	ldw	r3,652(sp)
 200af48:	18032f1e 	bne	r3,zero,200bc08 <__svfscanf_r+0x13bc>
 200af4c:	8809883a 	mov	r4,r17
 200af50:	d9400104 	addi	r5,sp,4
 200af54:	000d883a 	mov	r6,zero
 200af58:	200fd740 	call	200fd74 <_strtod_r>
 200af5c:	102b883a 	mov	r21,r2
 200af60:	b080004c 	andi	r2,r22,1
 200af64:	1827883a 	mov	r19,r3
 200af68:	10030526 	beq	r2,zero,200bb80 <__svfscanf_r+0x1334>
 200af6c:	d9409c17 	ldw	r5,624(sp)
 200af70:	28800017 	ldw	r2,0(r5)
 200af74:	29400104 	addi	r5,r5,4
 200af78:	d9409c15 	stw	r5,624(sp)
 200af7c:	15400015 	stw	r21,0(r2)
 200af80:	10c00115 	stw	r3,4(r2)
 200af84:	d8809e17 	ldw	r2,632(sp)
 200af88:	dc009d17 	ldw	r16,628(sp)
 200af8c:	10800044 	addi	r2,r2,1
 200af90:	d8809e15 	stw	r2,632(sp)
 200af94:	800d883a 	mov	r6,r16
 200af98:	003e6506 	br	200a930 <__svfscanf_r+0xe4>
 200af9c:	98bfffc4 	addi	r2,r19,-1
 200afa0:	01005704 	movi	r4,348
 200afa4:	2080e82e 	bgeu	r4,r2,200b348 <__svfscanf_r+0xafc>
 200afa8:	98ffa8c4 	addi	r3,r19,-349
 200afac:	04c05744 	movi	r19,349
 200afb0:	da409f17 	ldw	r9,636(sp)
 200afb4:	b5836014 	ori	r22,r22,3456
 200afb8:	0021883a 	mov	r16,zero
 200afbc:	dc800104 	addi	r18,sp,4
 200afc0:	05401344 	movi	r21,77
 200afc4:	01c08004 	movi	r7,512
 200afc8:	01bf7fc4 	movi	r6,-513
 200afcc:	e2000017 	ldw	r8,0(fp)
 200afd0:	41400003 	ldbu	r5,0(r8)
 200afd4:	28bff544 	addi	r2,r5,-43
 200afd8:	10803fcc 	andi	r2,r2,255
 200afdc:	a881d02e 	bgeu	r21,r2,200b720 <__svfscanf_r+0xed4>
 200afe0:	da409f15 	stw	r9,636(sp)
 200afe4:	b080400c 	andi	r2,r22,256
 200afe8:	10000926 	beq	r2,zero,200b010 <__svfscanf_r+0x7c4>
 200afec:	d9400104 	addi	r5,sp,4
 200aff0:	2c80052e 	bgeu	r5,r18,200b008 <__svfscanf_r+0x7bc>
 200aff4:	917fffc7 	ldb	r5,-1(r18)
 200aff8:	8809883a 	mov	r4,r17
 200affc:	e00d883a 	mov	r6,fp
 200b000:	94bfffc4 	addi	r18,r18,-1
 200b004:	2011d640 	call	2011d64 <_ungetc_r>
 200b008:	da000104 	addi	r8,sp,4
 200b00c:	44be4c26 	beq	r8,r18,200a940 <__svfscanf_r+0xf4>
 200b010:	b080040c 	andi	r2,r22,16
 200b014:	10029326 	beq	r2,zero,200ba64 <__svfscanf_r+0x1218>
 200b018:	d8c00104 	addi	r3,sp,4
 200b01c:	90e5c83a 	sub	r18,r18,r3
 200b020:	9421883a 	add	r16,r18,r16
 200b024:	a429883a 	add	r20,r20,r16
 200b028:	dc009d17 	ldw	r16,628(sp)
 200b02c:	800d883a 	mov	r6,r16
 200b030:	003e3f06 	br	200a930 <__svfscanf_r+0xe4>
 200b034:	9800011e 	bne	r19,zero,200b03c <__svfscanf_r+0x7f0>
 200b038:	04ffffc4 	movi	r19,-1
 200b03c:	b080004c 	andi	r2,r22,1
 200b040:	b580040c 	andi	r22,r22,16
 200b044:	10003526 	beq	r2,zero,200b11c <__svfscanf_r+0x8d0>
 200b048:	b002c21e 	bne	r22,zero,200bb54 <__svfscanf_r+0x1308>
 200b04c:	d8c09c17 	ldw	r3,624(sp)
 200b050:	1d400017 	ldw	r21,0(r3)
 200b054:	18c00104 	addi	r3,r3,4
 200b058:	d8c09c15 	stw	r3,624(sp)
 200b05c:	0021883a 	mov	r16,zero
 200b060:	dc809904 	addi	r18,sp,612
 200b064:	e0c00017 	ldw	r3,0(fp)
 200b068:	b9400017 	ldw	r5,0(r23)
 200b06c:	18800003 	ldbu	r2,0(r3)
 200b070:	11003fcc 	andi	r4,r2,255
 200b074:	2909883a 	add	r4,r5,r4
 200b078:	21000003 	ldbu	r4,0(r4)
 200b07c:	2100020c 	andi	r4,r4,8
 200b080:	21003fcc 	andi	r4,r4,255
 200b084:	2100201c 	xori	r4,r4,128
 200b088:	213fe004 	addi	r4,r4,-128
 200b08c:	2002581e 	bne	r4,zero,200b9f0 <__svfscanf_r+0x11a4>
 200b090:	98025726 	beq	r19,zero,200b9f0 <__svfscanf_r+0x11a4>
 200b094:	01408174 	movhi	r5,517
 200b098:	29503904 	addi	r5,r5,16612
 200b09c:	29000017 	ldw	r4,0(r5)
 200b0a0:	813f1d26 	beq	r16,r4,200ad18 <__svfscanf_r+0x4cc>
 200b0a4:	e2000117 	ldw	r8,4(fp)
 200b0a8:	18c00044 	addi	r3,r3,1
 200b0ac:	d9000104 	addi	r4,sp,4
 200b0b0:	423fffc4 	addi	r8,r8,-1
 200b0b4:	240f883a 	add	r7,r4,r16
 200b0b8:	000b883a 	mov	r5,zero
 200b0bc:	9009883a 	mov	r4,r18
 200b0c0:	01800204 	movi	r6,8
 200b0c4:	e2000115 	stw	r8,4(fp)
 200b0c8:	e0c00015 	stw	r3,0(fp)
 200b0cc:	38800005 	stb	r2,0(r7)
 200b0d0:	84000044 	addi	r16,r16,1
 200b0d4:	200682c0 	call	200682c <memset>
 200b0d8:	a80b883a 	mov	r5,r21
 200b0dc:	8809883a 	mov	r4,r17
 200b0e0:	dc800015 	stw	r18,0(sp)
 200b0e4:	d9800104 	addi	r6,sp,4
 200b0e8:	800f883a 	mov	r7,r16
 200b0ec:	200e3d80 	call	200e3d8 <_mbrtowc_r>
 200b0f0:	017fffc4 	movi	r5,-1
 200b0f4:	117f0826 	beq	r2,r5,200ad18 <__svfscanf_r+0x4cc>
 200b0f8:	1002db1e 	bne	r2,zero,200bc68 <__svfscanf_r+0x141c>
 200b0fc:	a8000015 	stw	zero,0(r21)
 200b100:	0009883a 	mov	r4,zero
 200b104:	0002db06 	br	200bc74 <__svfscanf_r+0x1428>
 200b108:	8809883a 	mov	r4,r17
 200b10c:	e00b883a 	mov	r5,fp
 200b110:	2006ce40 	call	2006ce4 <__srefill_r>
 200b114:	103e3f26 	beq	r2,zero,200aa14 <__svfscanf_r+0x1c8>
 200b118:	003eff06 	br	200ad18 <__svfscanf_r+0x4cc>
 200b11c:	b0026326 	beq	r22,zero,200baac <__svfscanf_r+0x1260>
 200b120:	b9400017 	ldw	r5,0(r23)
 200b124:	e0800017 	ldw	r2,0(fp)
 200b128:	0021883a 	mov	r16,zero
 200b12c:	10c00003 	ldbu	r3,0(r2)
 200b130:	28c7883a 	add	r3,r5,r3
 200b134:	18c00003 	ldbu	r3,0(r3)
 200b138:	18c0020c 	andi	r3,r3,8
 200b13c:	18c03fcc 	andi	r3,r3,255
 200b140:	18c0201c 	xori	r3,r3,128
 200b144:	18ffe004 	addi	r3,r3,-128
 200b148:	183fb61e 	bne	r3,zero,200b024 <__svfscanf_r+0x7d8>
 200b14c:	e0c00117 	ldw	r3,4(fp)
 200b150:	10800044 	addi	r2,r2,1
 200b154:	84000044 	addi	r16,r16,1
 200b158:	18ffffc4 	addi	r3,r3,-1
 200b15c:	e0c00115 	stw	r3,4(fp)
 200b160:	e0800015 	stw	r2,0(fp)
 200b164:	9c3faf26 	beq	r19,r16,200b024 <__svfscanf_r+0x7d8>
 200b168:	00fff016 	blt	zero,r3,200b12c <__svfscanf_r+0x8e0>
 200b16c:	8809883a 	mov	r4,r17
 200b170:	e00b883a 	mov	r5,fp
 200b174:	2006ce40 	call	2006ce4 <__srefill_r>
 200b178:	103faa1e 	bne	r2,zero,200b024 <__svfscanf_r+0x7d8>
 200b17c:	b9400017 	ldw	r5,0(r23)
 200b180:	e0800017 	ldw	r2,0(fp)
 200b184:	003fe906 	br	200b12c <__svfscanf_r+0x8e0>
 200b188:	1085883a 	add	r2,r2,r2
 200b18c:	1085883a 	add	r2,r2,r2
 200b190:	01008074 	movhi	r4,513
 200b194:	212c6904 	addi	r4,r4,-20060
 200b198:	1105883a 	add	r2,r2,r4
 200b19c:	10800017 	ldw	r2,0(r2)
 200b1a0:	1000683a 	jmp	r2
 200b1a4:	0200b444 	movi	r8,721
 200b1a8:	0200ae68 	cmpgeui	r8,zero,697
 200b1ac:	0200b444 	movi	r8,721
 200b1b0:	0200b430 	cmpltui	r8,zero,720
 200b1b4:	0200ae68 	cmpgeui	r8,zero,697
 200b1b8:	0200b40c 	andi	r8,zero,720
 200b1bc:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1c0:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1c4:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1c8:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1cc:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1d0:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1d4:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1d8:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1dc:	0200b3c0 	call	200b3c <__alt_mem_descriptor_memory+0x1fef3c>
 200b1e0:	0200ae68 	cmpgeui	r8,zero,697
 200b1e4:	0200ae68 	cmpgeui	r8,zero,697
 200b1e8:	0200ae68 	cmpgeui	r8,zero,697
 200b1ec:	0200ae68 	cmpgeui	r8,zero,697
 200b1f0:	0200ae68 	cmpgeui	r8,zero,697
 200b1f4:	0200ae68 	cmpgeui	r8,zero,697
 200b1f8:	0200ae68 	cmpgeui	r8,zero,697
 200b1fc:	0200b528 	cmpgeui	r8,zero,724
 200b200:	0200ae68 	cmpgeui	r8,zero,697
 200b204:	0200ae68 	cmpgeui	r8,zero,697
 200b208:	0200ae68 	cmpgeui	r8,zero,697
 200b20c:	0200b4ec 	andhi	r8,zero,723
 200b210:	0200b538 	rdprs	r8,zero,724
 200b214:	0200ae68 	cmpgeui	r8,zero,697
 200b218:	0200ae68 	cmpgeui	r8,zero,697
 200b21c:	0200b4c4 	movi	r8,723
 200b220:	0200ae68 	cmpgeui	r8,zero,697
 200b224:	0200ae68 	cmpgeui	r8,zero,697
 200b228:	0200ae68 	cmpgeui	r8,zero,697
 200b22c:	0200ae68 	cmpgeui	r8,zero,697
 200b230:	0200b490 	cmplti	r8,zero,722
 200b234:	0200ae68 	cmpgeui	r8,zero,697
 200b238:	0200ae68 	cmpgeui	r8,zero,697
 200b23c:	0200ae68 	cmpgeui	r8,zero,697
 200b240:	0200ae68 	cmpgeui	r8,zero,697
 200b244:	0200ae68 	cmpgeui	r8,zero,697
 200b248:	0200b474 	movhi	r8,721
 200b24c:	0200ae68 	cmpgeui	r8,zero,697
 200b250:	0200ae68 	cmpgeui	r8,zero,697
 200b254:	0200ae68 	cmpgeui	r8,zero,697
 200b258:	0200ae68 	cmpgeui	r8,zero,697
 200b25c:	0200b458 	cmpnei	r8,zero,721
 200b260:	0200ae68 	cmpgeui	r8,zero,697
 200b264:	0200ae68 	cmpgeui	r8,zero,697
 200b268:	0200ae68 	cmpgeui	r8,zero,697
 200b26c:	0200ae68 	cmpgeui	r8,zero,697
 200b270:	0200ae68 	cmpgeui	r8,zero,697
 200b274:	0200ae68 	cmpgeui	r8,zero,697
 200b278:	0200ae68 	cmpgeui	r8,zero,697
 200b27c:	0200b528 	cmpgeui	r8,zero,724
 200b280:	0200ae68 	cmpgeui	r8,zero,697
 200b284:	0200ae68 	cmpgeui	r8,zero,697
 200b288:	0200ae68 	cmpgeui	r8,zero,697
 200b28c:	0200b4ec 	andhi	r8,zero,723
 200b290:	0200b538 	rdprs	r8,zero,724
 200b294:	0200ae68 	cmpgeui	r8,zero,697
 200b298:	0200ae68 	cmpgeui	r8,zero,697
 200b29c:	0200b4c4 	movi	r8,723
 200b2a0:	0200ae68 	cmpgeui	r8,zero,697
 200b2a4:	0200ae68 	cmpgeui	r8,zero,697
 200b2a8:	0200ae68 	cmpgeui	r8,zero,697
 200b2ac:	0200ae68 	cmpgeui	r8,zero,697
 200b2b0:	0200b490 	cmplti	r8,zero,722
 200b2b4:	0200ae68 	cmpgeui	r8,zero,697
 200b2b8:	0200ae68 	cmpgeui	r8,zero,697
 200b2bc:	0200ae68 	cmpgeui	r8,zero,697
 200b2c0:	0200ae68 	cmpgeui	r8,zero,697
 200b2c4:	0200ae68 	cmpgeui	r8,zero,697
 200b2c8:	0200b474 	movhi	r8,721
 200b2cc:	0200ae68 	cmpgeui	r8,zero,697
 200b2d0:	0200ae68 	cmpgeui	r8,zero,697
 200b2d4:	0200ae68 	cmpgeui	r8,zero,697
 200b2d8:	0200ae68 	cmpgeui	r8,zero,697
 200b2dc:	0200b458 	cmpnei	r8,zero,721
 200b2e0:	b580040c 	andi	r22,r22,16
 200b2e4:	b0023726 	beq	r22,zero,200bbc4 <__svfscanf_r+0x1378>
 200b2e8:	0021883a 	mov	r16,zero
 200b2ec:	e0800117 	ldw	r2,4(fp)
 200b2f0:	14c2810e 	bge	r2,r19,200bcf8 <__svfscanf_r+0x14ac>
 200b2f4:	e0c00017 	ldw	r3,0(fp)
 200b2f8:	8809883a 	mov	r4,r17
 200b2fc:	e00b883a 	mov	r5,fp
 200b300:	1887883a 	add	r3,r3,r2
 200b304:	e0c00015 	stw	r3,0(fp)
 200b308:	80a1883a 	add	r16,r16,r2
 200b30c:	98a7c83a 	sub	r19,r19,r2
 200b310:	2006ce40 	call	2006ce4 <__srefill_r>
 200b314:	103ff526 	beq	r2,zero,200b2ec <__svfscanf_r+0xaa0>
 200b318:	803f421e 	bne	r16,zero,200b024 <__svfscanf_r+0x7d8>
 200b31c:	003e7e06 	br	200ad18 <__svfscanf_r+0x4cc>
 200b320:	8809883a 	mov	r4,r17
 200b324:	e00b883a 	mov	r5,fp
 200b328:	2006ce40 	call	2006ce4 <__srefill_r>
 200b32c:	103df126 	beq	r2,zero,200aaf4 <__svfscanf_r+0x2a8>
 200b330:	803e791e 	bne	r16,zero,200ad18 <__svfscanf_r+0x4cc>
 200b334:	903f1326 	beq	r18,zero,200af84 <__svfscanf_r+0x738>
 200b338:	003df006 	br	200aafc <__svfscanf_r+0x2b0>
 200b33c:	9affa8c4 	addi	r11,r19,-349
 200b340:	04c05744 	movi	r19,349
 200b344:	003eb706 	br	200ae24 <__svfscanf_r+0x5d8>
 200b348:	0007883a 	mov	r3,zero
 200b34c:	003f1806 	br	200afb0 <__svfscanf_r+0x764>
 200b350:	d8c09c17 	ldw	r3,624(sp)
 200b354:	e0800017 	ldw	r2,0(fp)
 200b358:	dd405884 	addi	r21,sp,354
 200b35c:	1c000017 	ldw	r16,0(r3)
 200b360:	1d800104 	addi	r22,r3,4
 200b364:	8025883a 	mov	r18,r16
 200b368:	10c00003 	ldbu	r3,0(r2)
 200b36c:	a8c7883a 	add	r3,r21,r3
 200b370:	18c00007 	ldb	r3,0(r3)
 200b374:	1801a726 	beq	r3,zero,200ba14 <__svfscanf_r+0x11c8>
 200b378:	e0c00117 	ldw	r3,4(fp)
 200b37c:	10800044 	addi	r2,r2,1
 200b380:	94800044 	addi	r18,r18,1
 200b384:	18ffffc4 	addi	r3,r3,-1
 200b388:	e0c00115 	stw	r3,4(fp)
 200b38c:	10ffffc3 	ldbu	r3,-1(r2)
 200b390:	9cffffc4 	addi	r19,r19,-1
 200b394:	90ffffc5 	stb	r3,-1(r18)
 200b398:	e0800015 	stw	r2,0(fp)
 200b39c:	98019d26 	beq	r19,zero,200ba14 <__svfscanf_r+0x11c8>
 200b3a0:	e0c00117 	ldw	r3,4(fp)
 200b3a4:	00fff016 	blt	zero,r3,200b368 <__svfscanf_r+0xb1c>
 200b3a8:	8809883a 	mov	r4,r17
 200b3ac:	e00b883a 	mov	r5,fp
 200b3b0:	2006ce40 	call	2006ce4 <__srefill_r>
 200b3b4:	1001961e 	bne	r2,zero,200ba10 <__svfscanf_r+0x11c4>
 200b3b8:	e0800017 	ldw	r2,0(fp)
 200b3bc:	003fea06 	br	200b368 <__svfscanf_r+0xb1c>
 200b3c0:	80803fcc 	andi	r2,r16,255
 200b3c4:	1080201c 	xori	r2,r2,128
 200b3c8:	10bfe004 	addi	r2,r2,-128
 200b3cc:	3085883a 	add	r2,r6,r2
 200b3d0:	103ea51e 	bne	r2,zero,200ae68 <__svfscanf_r+0x61c>
 200b3d4:	00bf9fc4 	movi	r2,-385
 200b3d8:	b0ac703a 	and	r22,r22,r2
 200b3dc:	91400005 	stb	r5,0(r18)
 200b3e0:	94800044 	addi	r18,r18,1
 200b3e4:	e0800117 	ldw	r2,4(fp)
 200b3e8:	9cffffc4 	addi	r19,r19,-1
 200b3ec:	a5000044 	addi	r20,r20,1
 200b3f0:	10bfffc4 	addi	r2,r2,-1
 200b3f4:	e0800115 	stw	r2,4(fp)
 200b3f8:	0081520e 	bge	zero,r2,200b944 <__svfscanf_r+0x10f8>
 200b3fc:	39c00044 	addi	r7,r7,1
 200b400:	e1c00015 	stw	r7,0(fp)
 200b404:	983e931e 	bne	r19,zero,200ae54 <__svfscanf_r+0x608>
 200b408:	003e9706 	br	200ae68 <__svfscanf_r+0x61c>
 200b40c:	b080400c 	andi	r2,r22,256
 200b410:	103feb26 	beq	r2,zero,200b3c0 <__svfscanf_r+0xb74>
 200b414:	00bfdfc4 	movi	r2,-129
 200b418:	b0ac703a 	and	r22,r22,r2
 200b41c:	ad400044 	addi	r21,r21,1
 200b420:	583ff026 	beq	r11,zero,200b3e4 <__svfscanf_r+0xb98>
 200b424:	5affffc4 	addi	r11,r11,-1
 200b428:	9cc00044 	addi	r19,r19,1
 200b42c:	003fed06 	br	200b3e4 <__svfscanf_r+0xb98>
 200b430:	b080800c 	andi	r2,r22,512
 200b434:	103e8c26 	beq	r2,zero,200ae68 <__svfscanf_r+0x61c>
 200b438:	b3ec703a 	and	r22,r22,r15
 200b43c:	dd40a215 	stw	r21,648(sp)
 200b440:	003fe606 	br	200b3dc <__svfscanf_r+0xb90>
 200b444:	b080200c 	andi	r2,r22,128
 200b448:	103e8726 	beq	r2,zero,200ae68 <__svfscanf_r+0x61c>
 200b44c:	00bfdfc4 	movi	r2,-129
 200b450:	b0ac703a 	and	r22,r22,r2
 200b454:	003fe106 	br	200b3dc <__svfscanf_r+0xb90>
 200b458:	81003fcc 	andi	r4,r16,255
 200b45c:	2100201c 	xori	r4,r4,128
 200b460:	213fe004 	addi	r4,r4,-128
 200b464:	008001c4 	movi	r2,7
 200b468:	20be7f1e 	bne	r4,r2,200ae68 <__svfscanf_r+0x61c>
 200b46c:	04000204 	movi	r16,8
 200b470:	003fda06 	br	200b3dc <__svfscanf_r+0xb90>
 200b474:	81003fcc 	andi	r4,r16,255
 200b478:	2100201c 	xori	r4,r4,128
 200b47c:	213fe004 	addi	r4,r4,-128
 200b480:	00800184 	movi	r2,6
 200b484:	20be781e 	bne	r4,r2,200ae68 <__svfscanf_r+0x61c>
 200b488:	040001c4 	movi	r16,7
 200b48c:	003fd306 	br	200b3dc <__svfscanf_r+0xb90>
 200b490:	3001681e 	bne	r6,zero,200ba34 <__svfscanf_r+0x11e8>
 200b494:	b101c00c 	andi	r4,r22,1792
 200b498:	0081c004 	movi	r2,1792
 200b49c:	20820126 	beq	r4,r2,200bca4 <__svfscanf_r+0x1458>
 200b4a0:	80803fcc 	andi	r2,r16,255
 200b4a4:	1080201c 	xori	r2,r2,128
 200b4a8:	10bfe004 	addi	r2,r2,-128
 200b4ac:	01000044 	movi	r4,1
 200b4b0:	11000226 	beq	r2,r4,200b4bc <__svfscanf_r+0xc70>
 200b4b4:	01000104 	movi	r4,4
 200b4b8:	113e6b1e 	bne	r2,r4,200ae68 <__svfscanf_r+0x61c>
 200b4bc:	84000044 	addi	r16,r16,1
 200b4c0:	003fc606 	br	200b3dc <__svfscanf_r+0xb90>
 200b4c4:	80803fcc 	andi	r2,r16,255
 200b4c8:	1080201c 	xori	r2,r2,128
 200b4cc:	10bfe004 	addi	r2,r2,-128
 200b4d0:	10015c1e 	bne	r2,zero,200ba44 <__svfscanf_r+0x11f8>
 200b4d4:	b101c00c 	andi	r4,r22,1792
 200b4d8:	0081c004 	movi	r2,1792
 200b4dc:	20be621e 	bne	r4,r2,200ae68 <__svfscanf_r+0x61c>
 200b4e0:	b32c703a 	and	r22,r22,r12
 200b4e4:	04000044 	movi	r16,1
 200b4e8:	003fbc06 	br	200b3dc <__svfscanf_r+0xb90>
 200b4ec:	b081400c 	andi	r2,r22,1280
 200b4f0:	13800326 	beq	r2,r14,200b500 <__svfscanf_r+0xcb4>
 200b4f4:	b081000c 	andi	r2,r22,1024
 200b4f8:	103e5b26 	beq	r2,zero,200ae68 <__svfscanf_r+0x61c>
 200b4fc:	a83e5d26 	beq	r21,zero,200ae74 <__svfscanf_r+0x628>
 200b500:	b080800c 	andi	r2,r22,512
 200b504:	1000041e 	bne	r2,zero,200b518 <__svfscanf_r+0xccc>
 200b508:	da00a217 	ldw	r8,648(sp)
 200b50c:	dc80a115 	stw	r18,644(sp)
 200b510:	aa2bc83a 	sub	r21,r21,r8
 200b514:	dd40a315 	stw	r21,652(sp)
 200b518:	b32c703a 	and	r22,r22,r12
 200b51c:	b5806014 	ori	r22,r22,384
 200b520:	002b883a 	mov	r21,zero
 200b524:	003fad06 	br	200b3dc <__svfscanf_r+0xb90>
 200b528:	00800044 	movi	r2,1
 200b52c:	30be4e1e 	bne	r6,r2,200ae68 <__svfscanf_r+0x61c>
 200b530:	01800084 	movi	r6,2
 200b534:	003fa906 	br	200b3dc <__svfscanf_r+0xb90>
 200b538:	81003fcc 	andi	r4,r16,255
 200b53c:	2100201c 	xori	r4,r4,128
 200b540:	213fe004 	addi	r4,r4,-128
 200b544:	00800084 	movi	r2,2
 200b548:	20be471e 	bne	r4,r2,200ae68 <__svfscanf_r+0x61c>
 200b54c:	040000c4 	movi	r16,3
 200b550:	003fa206 	br	200b3dc <__svfscanf_r+0xb90>
 200b554:	b5800054 	ori	r22,r22,1
 200b558:	003d2606 	br	200a9f4 <__svfscanf_r+0x1a8>
 200b55c:	02008074 	movhi	r8,513
 200b560:	42058e04 	addi	r8,r8,5688
 200b564:	da00a015 	stw	r8,640(sp)
 200b568:	02000284 	movi	r8,10
 200b56c:	d8c09d15 	stw	r3,628(sp)
 200b570:	da009f15 	stw	r8,636(sp)
 200b574:	040000c4 	movi	r16,3
 200b578:	003d2406 	br	200aa0c <__svfscanf_r+0x1c0>
 200b57c:	d8c09d15 	stw	r3,628(sp)
 200b580:	1821883a 	mov	r16,r3
 200b584:	003cfd06 	br	200a97c <__svfscanf_r+0x130>
 200b588:	d8c09d15 	stw	r3,628(sp)
 200b58c:	b5800054 	ori	r22,r22,1
 200b590:	003d1806 	br	200a9f4 <__svfscanf_r+0x1a8>
 200b594:	d8c09d15 	stw	r3,628(sp)
 200b598:	04000104 	movi	r16,4
 200b59c:	003d1b06 	br	200aa0c <__svfscanf_r+0x1c0>
 200b5a0:	81400043 	ldbu	r5,1(r16)
 200b5a4:	b5800094 	ori	r22,r22,2
 200b5a8:	1821883a 	mov	r16,r3
 200b5ac:	003d0606 	br	200a9c8 <__svfscanf_r+0x17c>
 200b5b0:	d8c09d15 	stw	r3,628(sp)
 200b5b4:	b5800054 	ori	r22,r22,1
 200b5b8:	02008074 	movhi	r8,513
 200b5bc:	42058e04 	addi	r8,r8,5688
 200b5c0:	da00a015 	stw	r8,640(sp)
 200b5c4:	02000204 	movi	r8,8
 200b5c8:	da009f15 	stw	r8,636(sp)
 200b5cc:	040000c4 	movi	r16,3
 200b5d0:	003d0e06 	br	200aa0c <__svfscanf_r+0x1c0>
 200b5d4:	81400043 	ldbu	r5,1(r16)
 200b5d8:	b5800414 	ori	r22,r22,16
 200b5dc:	1821883a 	mov	r16,r3
 200b5e0:	003cf906 	br	200a9c8 <__svfscanf_r+0x17c>
 200b5e4:	28803fcc 	andi	r2,r5,255
 200b5e8:	9cc002a4 	muli	r19,r19,10
 200b5ec:	1080201c 	xori	r2,r2,128
 200b5f0:	10bfe004 	addi	r2,r2,-128
 200b5f4:	98a7883a 	add	r19,r19,r2
 200b5f8:	81400043 	ldbu	r5,1(r16)
 200b5fc:	9cfff404 	addi	r19,r19,-48
 200b600:	1821883a 	mov	r16,r3
 200b604:	003cf006 	br	200a9c8 <__svfscanf_r+0x17c>
 200b608:	d8c09d15 	stw	r3,628(sp)
 200b60c:	b5808014 	ori	r22,r22,512
 200b610:	02008074 	movhi	r8,513
 200b614:	42058e04 	addi	r8,r8,5688
 200b618:	da00a015 	stw	r8,640(sp)
 200b61c:	02000404 	movi	r8,16
 200b620:	da009f15 	stw	r8,636(sp)
 200b624:	040000c4 	movi	r16,3
 200b628:	003cf806 	br	200aa0c <__svfscanf_r+0x1c0>
 200b62c:	d9005884 	addi	r4,sp,354
 200b630:	180b883a 	mov	r5,r3
 200b634:	d8c09d15 	stw	r3,628(sp)
 200b638:	200fca80 	call	200fca8 <__sccl>
 200b63c:	d8809d15 	stw	r2,628(sp)
 200b640:	b5801014 	ori	r22,r22,64
 200b644:	04000044 	movi	r16,1
 200b648:	003cf006 	br	200aa0c <__svfscanf_r+0x1c0>
 200b64c:	d8c09d15 	stw	r3,628(sp)
 200b650:	b5801014 	ori	r22,r22,64
 200b654:	0021883a 	mov	r16,zero
 200b658:	003cec06 	br	200aa0c <__svfscanf_r+0x1c0>
 200b65c:	d8c09d15 	stw	r3,628(sp)
 200b660:	003ce406 	br	200a9f4 <__svfscanf_r+0x1a8>
 200b664:	81400043 	ldbu	r5,1(r16)
 200b668:	b5800114 	ori	r22,r22,4
 200b66c:	1821883a 	mov	r16,r3
 200b670:	003cd506 	br	200a9c8 <__svfscanf_r+0x17c>
 200b674:	02008074 	movhi	r8,513
 200b678:	4221db04 	addi	r8,r8,-30868
 200b67c:	d8c09d15 	stw	r3,628(sp)
 200b680:	da00a015 	stw	r8,640(sp)
 200b684:	d8009f15 	stw	zero,636(sp)
 200b688:	040000c4 	movi	r16,3
 200b68c:	003cdf06 	br	200aa0c <__svfscanf_r+0x1c0>
 200b690:	81400043 	ldbu	r5,1(r16)
 200b694:	28803fcc 	andi	r2,r5,255
 200b698:	1080201c 	xori	r2,r2,128
 200b69c:	10bfe004 	addi	r2,r2,-128
 200b6a0:	11c18326 	beq	r2,r7,200bcb0 <__svfscanf_r+0x1464>
 200b6a4:	b5800054 	ori	r22,r22,1
 200b6a8:	1821883a 	mov	r16,r3
 200b6ac:	003cc606 	br	200a9c8 <__svfscanf_r+0x17c>
 200b6b0:	d8c09d15 	stw	r3,628(sp)
 200b6b4:	b080040c 	andi	r2,r22,16
 200b6b8:	103d101e 	bne	r2,zero,200aafc <__svfscanf_r+0x2b0>
 200b6bc:	b080010c 	andi	r2,r22,4
 200b6c0:	10017f26 	beq	r2,zero,200bcc0 <__svfscanf_r+0x1474>
 200b6c4:	d8c09c17 	ldw	r3,624(sp)
 200b6c8:	dc009d17 	ldw	r16,628(sp)
 200b6cc:	18800017 	ldw	r2,0(r3)
 200b6d0:	18c00104 	addi	r3,r3,4
 200b6d4:	d8c09c15 	stw	r3,624(sp)
 200b6d8:	1500000d 	sth	r20,0(r2)
 200b6dc:	800d883a 	mov	r6,r16
 200b6e0:	003c9306 	br	200a930 <__svfscanf_r+0xe4>
 200b6e4:	d8c09d15 	stw	r3,628(sp)
 200b6e8:	b5808814 	ori	r22,r22,544
 200b6ec:	003fc806 	br	200b610 <__svfscanf_r+0xdc4>
 200b6f0:	d8c09d15 	stw	r3,628(sp)
 200b6f4:	003fb006 	br	200b5b8 <__svfscanf_r+0xd6c>
 200b6f8:	d8c09d15 	stw	r3,628(sp)
 200b6fc:	04000084 	movi	r16,2
 200b700:	003cc206 	br	200aa0c <__svfscanf_r+0x1c0>
 200b704:	023fff84 	movi	r8,-2
 200b708:	123cf826 	beq	r2,r8,200aaec <__svfscanf_r+0x2a0>
 200b70c:	a429883a 	add	r20,r20,r16
 200b710:	9cffffc4 	addi	r19,r19,-1
 200b714:	903cf326 	beq	r18,zero,200aae4 <__svfscanf_r+0x298>
 200b718:	0021883a 	mov	r16,zero
 200b71c:	003cf306 	br	200aaec <__svfscanf_r+0x2a0>
 200b720:	1085883a 	add	r2,r2,r2
 200b724:	1085883a 	add	r2,r2,r2
 200b728:	01008074 	movhi	r4,513
 200b72c:	212dcf04 	addi	r4,r4,-18628
 200b730:	1105883a 	add	r2,r2,r4
 200b734:	10800017 	ldw	r2,0(r2)
 200b738:	1000683a 	jmp	r2
 200b73c:	0200b930 	cmpltui	r8,zero,740
 200b740:	0200afe0 	cmpeqi	r8,zero,703
 200b744:	0200b930 	cmpltui	r8,zero,740
 200b748:	0200afe0 	cmpeqi	r8,zero,703
 200b74c:	0200afe0 	cmpeqi	r8,zero,703
 200b750:	0200b908 	cmpgei	r8,zero,740
 200b754:	0200b8e8 	cmpgeui	r8,zero,739
 200b758:	0200b8e8 	cmpgeui	r8,zero,739
 200b75c:	0200b8e8 	cmpgeui	r8,zero,739
 200b760:	0200b8e8 	cmpgeui	r8,zero,739
 200b764:	0200b8e8 	cmpgeui	r8,zero,739
 200b768:	0200b8e8 	cmpgeui	r8,zero,739
 200b76c:	0200b8e8 	cmpgeui	r8,zero,739
 200b770:	0200b8c8 	cmpgei	r8,zero,739
 200b774:	0200b8c8 	cmpgei	r8,zero,739
 200b778:	0200afe0 	cmpeqi	r8,zero,703
 200b77c:	0200afe0 	cmpeqi	r8,zero,703
 200b780:	0200afe0 	cmpeqi	r8,zero,703
 200b784:	0200afe0 	cmpeqi	r8,zero,703
 200b788:	0200afe0 	cmpeqi	r8,zero,703
 200b78c:	0200afe0 	cmpeqi	r8,zero,703
 200b790:	0200afe0 	cmpeqi	r8,zero,703
 200b794:	0200b8b4 	movhi	r8,738
 200b798:	0200b8b4 	movhi	r8,738
 200b79c:	0200b8b4 	movhi	r8,738
 200b7a0:	0200b8b4 	movhi	r8,738
 200b7a4:	0200b8b4 	movhi	r8,738
 200b7a8:	0200b8b4 	movhi	r8,738
 200b7ac:	0200afe0 	cmpeqi	r8,zero,703
 200b7b0:	0200afe0 	cmpeqi	r8,zero,703
 200b7b4:	0200afe0 	cmpeqi	r8,zero,703
 200b7b8:	0200afe0 	cmpeqi	r8,zero,703
 200b7bc:	0200afe0 	cmpeqi	r8,zero,703
 200b7c0:	0200afe0 	cmpeqi	r8,zero,703
 200b7c4:	0200afe0 	cmpeqi	r8,zero,703
 200b7c8:	0200afe0 	cmpeqi	r8,zero,703
 200b7cc:	0200afe0 	cmpeqi	r8,zero,703
 200b7d0:	0200afe0 	cmpeqi	r8,zero,703
 200b7d4:	0200afe0 	cmpeqi	r8,zero,703
 200b7d8:	0200afe0 	cmpeqi	r8,zero,703
 200b7dc:	0200afe0 	cmpeqi	r8,zero,703
 200b7e0:	0200afe0 	cmpeqi	r8,zero,703
 200b7e4:	0200afe0 	cmpeqi	r8,zero,703
 200b7e8:	0200afe0 	cmpeqi	r8,zero,703
 200b7ec:	0200afe0 	cmpeqi	r8,zero,703
 200b7f0:	0200b874 	movhi	r8,737
 200b7f4:	0200afe0 	cmpeqi	r8,zero,703
 200b7f8:	0200afe0 	cmpeqi	r8,zero,703
 200b7fc:	0200afe0 	cmpeqi	r8,zero,703
 200b800:	0200afe0 	cmpeqi	r8,zero,703
 200b804:	0200afe0 	cmpeqi	r8,zero,703
 200b808:	0200afe0 	cmpeqi	r8,zero,703
 200b80c:	0200afe0 	cmpeqi	r8,zero,703
 200b810:	0200afe0 	cmpeqi	r8,zero,703
 200b814:	0200b8b4 	movhi	r8,738
 200b818:	0200b8b4 	movhi	r8,738
 200b81c:	0200b8b4 	movhi	r8,738
 200b820:	0200b8b4 	movhi	r8,738
 200b824:	0200b8b4 	movhi	r8,738
 200b828:	0200b8b4 	movhi	r8,738
 200b82c:	0200afe0 	cmpeqi	r8,zero,703
 200b830:	0200afe0 	cmpeqi	r8,zero,703
 200b834:	0200afe0 	cmpeqi	r8,zero,703
 200b838:	0200afe0 	cmpeqi	r8,zero,703
 200b83c:	0200afe0 	cmpeqi	r8,zero,703
 200b840:	0200afe0 	cmpeqi	r8,zero,703
 200b844:	0200afe0 	cmpeqi	r8,zero,703
 200b848:	0200afe0 	cmpeqi	r8,zero,703
 200b84c:	0200afe0 	cmpeqi	r8,zero,703
 200b850:	0200afe0 	cmpeqi	r8,zero,703
 200b854:	0200afe0 	cmpeqi	r8,zero,703
 200b858:	0200afe0 	cmpeqi	r8,zero,703
 200b85c:	0200afe0 	cmpeqi	r8,zero,703
 200b860:	0200afe0 	cmpeqi	r8,zero,703
 200b864:	0200afe0 	cmpeqi	r8,zero,703
 200b868:	0200afe0 	cmpeqi	r8,zero,703
 200b86c:	0200afe0 	cmpeqi	r8,zero,703
 200b870:	0200b874 	movhi	r8,737
 200b874:	b081800c 	andi	r2,r22,1536
 200b878:	11fdd91e 	bne	r2,r7,200afe0 <__svfscanf_r+0x794>
 200b87c:	b1ac703a 	and	r22,r22,r6
 200b880:	b5814014 	ori	r22,r22,1280
 200b884:	02400404 	movi	r9,16
 200b888:	91400005 	stb	r5,0(r18)
 200b88c:	94800044 	addi	r18,r18,1
 200b890:	e0800117 	ldw	r2,4(fp)
 200b894:	10bfffc4 	addi	r2,r2,-1
 200b898:	e0800115 	stw	r2,4(fp)
 200b89c:	00803b0e 	bge	zero,r2,200b98c <__svfscanf_r+0x1140>
 200b8a0:	42000044 	addi	r8,r8,1
 200b8a4:	e2000015 	stw	r8,0(fp)
 200b8a8:	9cffffc4 	addi	r19,r19,-1
 200b8ac:	983dc71e 	bne	r19,zero,200afcc <__svfscanf_r+0x780>
 200b8b0:	003dcb06 	br	200afe0 <__svfscanf_r+0x794>
 200b8b4:	00800284 	movi	r2,10
 200b8b8:	127dc90e 	bge	r2,r9,200afe0 <__svfscanf_r+0x794>
 200b8bc:	00bd1fc4 	movi	r2,-2945
 200b8c0:	b0ac703a 	and	r22,r22,r2
 200b8c4:	003ff006 	br	200b888 <__svfscanf_r+0x103c>
 200b8c8:	4a53883a 	add	r9,r9,r9
 200b8cc:	01008174 	movhi	r4,517
 200b8d0:	21379e84 	addi	r4,r4,-8582
 200b8d4:	2245883a 	add	r2,r4,r9
 200b8d8:	1240000f 	ldh	r9,0(r2)
 200b8dc:	00800204 	movi	r2,8
 200b8e0:	127ff616 	blt	r2,r9,200b8bc <__svfscanf_r+0x1070>
 200b8e4:	003dbe06 	br	200afe0 <__svfscanf_r+0x794>
 200b8e8:	4a53883a 	add	r9,r9,r9
 200b8ec:	01008174 	movhi	r4,517
 200b8f0:	21379e84 	addi	r4,r4,-8582
 200b8f4:	2245883a 	add	r2,r4,r9
 200b8f8:	1240000f 	ldh	r9,0(r2)
 200b8fc:	00bd1fc4 	movi	r2,-2945
 200b900:	b0ac703a 	and	r22,r22,r2
 200b904:	003fe006 	br	200b888 <__svfscanf_r+0x103c>
 200b908:	b082000c 	andi	r2,r22,2048
 200b90c:	103fde26 	beq	r2,zero,200b888 <__svfscanf_r+0x103c>
 200b910:	4800021e 	bne	r9,zero,200b91c <__svfscanf_r+0x10d0>
 200b914:	b5808014 	ori	r22,r22,512
 200b918:	02400204 	movi	r9,8
 200b91c:	b081000c 	andi	r2,r22,1024
 200b920:	10008e26 	beq	r2,zero,200bb5c <__svfscanf_r+0x1310>
 200b924:	00be9fc4 	movi	r2,-1409
 200b928:	b0ac703a 	and	r22,r22,r2
 200b92c:	003fd606 	br	200b888 <__svfscanf_r+0x103c>
 200b930:	b080200c 	andi	r2,r22,128
 200b934:	103daa26 	beq	r2,zero,200afe0 <__svfscanf_r+0x794>
 200b938:	00bfdfc4 	movi	r2,-129
 200b93c:	b0ac703a 	and	r22,r22,r2
 200b940:	003fd106 	br	200b888 <__svfscanf_r+0x103c>
 200b944:	8809883a 	mov	r4,r17
 200b948:	e00b883a 	mov	r5,fp
 200b94c:	d8c0a915 	stw	r3,676(sp)
 200b950:	d980a815 	stw	r6,672(sp)
 200b954:	dac0a715 	stw	r11,668(sp)
 200b958:	db00a515 	stw	r12,660(sp)
 200b95c:	db80a415 	stw	r14,656(sp)
 200b960:	dbc0a615 	stw	r15,664(sp)
 200b964:	2006ce40 	call	2006ce4 <__srefill_r>
 200b968:	d8c0a917 	ldw	r3,676(sp)
 200b96c:	d980a817 	ldw	r6,672(sp)
 200b970:	dac0a717 	ldw	r11,668(sp)
 200b974:	db00a517 	ldw	r12,660(sp)
 200b978:	db80a417 	ldw	r14,656(sp)
 200b97c:	dbc0a617 	ldw	r15,664(sp)
 200b980:	103d391e 	bne	r2,zero,200ae68 <__svfscanf_r+0x61c>
 200b984:	983d331e 	bne	r19,zero,200ae54 <__svfscanf_r+0x608>
 200b988:	003d3706 	br	200ae68 <__svfscanf_r+0x61c>
 200b98c:	8809883a 	mov	r4,r17
 200b990:	e00b883a 	mov	r5,fp
 200b994:	d8c0a915 	stw	r3,676(sp)
 200b998:	d980a815 	stw	r6,672(sp)
 200b99c:	d9c0a415 	stw	r7,656(sp)
 200b9a0:	da40a515 	stw	r9,660(sp)
 200b9a4:	2006ce40 	call	2006ce4 <__srefill_r>
 200b9a8:	d8c0a917 	ldw	r3,676(sp)
 200b9ac:	d980a817 	ldw	r6,672(sp)
 200b9b0:	d9c0a417 	ldw	r7,656(sp)
 200b9b4:	da40a517 	ldw	r9,660(sp)
 200b9b8:	103fbb26 	beq	r2,zero,200b8a8 <__svfscanf_r+0x105c>
 200b9bc:	003d8806 	br	200afe0 <__svfscanf_r+0x794>
 200b9c0:	a429883a 	add	r20,r20,r16
 200b9c4:	9cffffc4 	addi	r19,r19,-1
 200b9c8:	b000f41e 	bne	r22,zero,200bd9c <__svfscanf_r+0x1550>
 200b9cc:	ad400104 	addi	r21,r21,4
 200b9d0:	0021883a 	mov	r16,zero
 200b9d4:	e0800117 	ldw	r2,4(fp)
 200b9d8:	00bda216 	blt	zero,r2,200b064 <__svfscanf_r+0x818>
 200b9dc:	8809883a 	mov	r4,r17
 200b9e0:	e00b883a 	mov	r5,fp
 200b9e4:	2006ce40 	call	2006ce4 <__srefill_r>
 200b9e8:	103d9e26 	beq	r2,zero,200b064 <__svfscanf_r+0x818>
 200b9ec:	803cca1e 	bne	r16,zero,200ad18 <__svfscanf_r+0x4cc>
 200b9f0:	b03c421e 	bne	r22,zero,200aafc <__svfscanf_r+0x2b0>
 200b9f4:	d8809e17 	ldw	r2,632(sp)
 200b9f8:	dc009d17 	ldw	r16,628(sp)
 200b9fc:	a8000015 	stw	zero,0(r21)
 200ba00:	10800044 	addi	r2,r2,1
 200ba04:	d8809e15 	stw	r2,632(sp)
 200ba08:	800d883a 	mov	r6,r16
 200ba0c:	003bc806 	br	200a930 <__svfscanf_r+0xe4>
 200ba10:	84bcc126 	beq	r16,r18,200ad18 <__svfscanf_r+0x4cc>
 200ba14:	9421c83a 	sub	r16,r18,r16
 200ba18:	803bc926 	beq	r16,zero,200a940 <__svfscanf_r+0xf4>
 200ba1c:	d8809e17 	ldw	r2,632(sp)
 200ba20:	90000005 	stb	zero,0(r18)
 200ba24:	dd809c15 	stw	r22,624(sp)
 200ba28:	10800044 	addi	r2,r2,1
 200ba2c:	d8809e15 	stw	r2,632(sp)
 200ba30:	003d7c06 	br	200b024 <__svfscanf_r+0x7d8>
 200ba34:	00800084 	movi	r2,2
 200ba38:	30be991e 	bne	r6,r2,200b4a0 <__svfscanf_r+0xc54>
 200ba3c:	018000c4 	movi	r6,3
 200ba40:	003e6606 	br	200b3dc <__svfscanf_r+0xb90>
 200ba44:	010000c4 	movi	r4,3
 200ba48:	113e9c26 	beq	r2,r4,200b4bc <__svfscanf_r+0xc70>
 200ba4c:	01000144 	movi	r4,5
 200ba50:	113d051e 	bne	r2,r4,200ae68 <__svfscanf_r+0x61c>
 200ba54:	84000044 	addi	r16,r16,1
 200ba58:	003e6006 	br	200b3dc <__svfscanf_r+0xb90>
 200ba5c:	002d883a 	mov	r22,zero
 200ba60:	003bfd06 	br	200aa58 <__svfscanf_r+0x20c>
 200ba64:	d9c09f17 	ldw	r7,636(sp)
 200ba68:	da00a017 	ldw	r8,640(sp)
 200ba6c:	8809883a 	mov	r4,r17
 200ba70:	d9400104 	addi	r5,sp,4
 200ba74:	000d883a 	mov	r6,zero
 200ba78:	90000005 	stb	zero,0(r18)
 200ba7c:	403ee83a 	callr	r8
 200ba80:	b0c0080c 	andi	r3,r22,32
 200ba84:	18004726 	beq	r3,zero,200bba4 <__svfscanf_r+0x1358>
 200ba88:	d9009c17 	ldw	r4,624(sp)
 200ba8c:	20c00017 	ldw	r3,0(r4)
 200ba90:	21000104 	addi	r4,r4,4
 200ba94:	d9009c15 	stw	r4,624(sp)
 200ba98:	18800015 	stw	r2,0(r3)
 200ba9c:	d8809e17 	ldw	r2,632(sp)
 200baa0:	10800044 	addi	r2,r2,1
 200baa4:	d8809e15 	stw	r2,632(sp)
 200baa8:	003d5b06 	br	200b018 <__svfscanf_r+0x7cc>
 200baac:	d8c09c17 	ldw	r3,624(sp)
 200bab0:	e0800017 	ldw	r2,0(fp)
 200bab4:	1c800017 	ldw	r18,0(r3)
 200bab8:	1d400104 	addi	r21,r3,4
 200babc:	9021883a 	mov	r16,r18
 200bac0:	10c00003 	ldbu	r3,0(r2)
 200bac4:	b9400017 	ldw	r5,0(r23)
 200bac8:	28c7883a 	add	r3,r5,r3
 200bacc:	18c00003 	ldbu	r3,0(r3)
 200bad0:	18c0020c 	andi	r3,r3,8
 200bad4:	18c03fcc 	andi	r3,r3,255
 200bad8:	18c0201c 	xori	r3,r3,128
 200badc:	18ffe004 	addi	r3,r3,-128
 200bae0:	1800121e 	bne	r3,zero,200bb2c <__svfscanf_r+0x12e0>
 200bae4:	e0c00117 	ldw	r3,4(fp)
 200bae8:	10800044 	addi	r2,r2,1
 200baec:	84000044 	addi	r16,r16,1
 200baf0:	18ffffc4 	addi	r3,r3,-1
 200baf4:	e0c00115 	stw	r3,4(fp)
 200baf8:	10ffffc3 	ldbu	r3,-1(r2)
 200bafc:	9cffffc4 	addi	r19,r19,-1
 200bb00:	80ffffc5 	stb	r3,-1(r16)
 200bb04:	e0800015 	stw	r2,0(fp)
 200bb08:	98000826 	beq	r19,zero,200bb2c <__svfscanf_r+0x12e0>
 200bb0c:	e0c00117 	ldw	r3,4(fp)
 200bb10:	00ffeb16 	blt	zero,r3,200bac0 <__svfscanf_r+0x1274>
 200bb14:	8809883a 	mov	r4,r17
 200bb18:	e00b883a 	mov	r5,fp
 200bb1c:	2006ce40 	call	2006ce4 <__srefill_r>
 200bb20:	1000021e 	bne	r2,zero,200bb2c <__svfscanf_r+0x12e0>
 200bb24:	e0800017 	ldw	r2,0(fp)
 200bb28:	003fe506 	br	200bac0 <__svfscanf_r+0x1274>
 200bb2c:	d8809e17 	ldw	r2,632(sp)
 200bb30:	84a5c83a 	sub	r18,r16,r18
 200bb34:	80000005 	stb	zero,0(r16)
 200bb38:	dc009d17 	ldw	r16,628(sp)
 200bb3c:	10800044 	addi	r2,r2,1
 200bb40:	a4a9883a 	add	r20,r20,r18
 200bb44:	d8809e15 	stw	r2,632(sp)
 200bb48:	dd409c15 	stw	r21,624(sp)
 200bb4c:	800d883a 	mov	r6,r16
 200bb50:	003b7706 	br	200a930 <__svfscanf_r+0xe4>
 200bb54:	dd409b04 	addi	r21,sp,620
 200bb58:	003d4006 	br	200b05c <__svfscanf_r+0x810>
 200bb5c:	00bf1fc4 	movi	r2,-897
 200bb60:	b0ac703a 	and	r22,r22,r2
 200bb64:	18000226 	beq	r3,zero,200bb70 <__svfscanf_r+0x1324>
 200bb68:	18ffffc4 	addi	r3,r3,-1
 200bb6c:	9cc00044 	addi	r19,r19,1
 200bb70:	84000044 	addi	r16,r16,1
 200bb74:	003f4606 	br	200b890 <__svfscanf_r+0x1044>
 200bb78:	803d2a1e 	bne	r16,zero,200b024 <__svfscanf_r+0x7d8>
 200bb7c:	003b7006 	br	200a940 <__svfscanf_r+0xf4>
 200bb80:	b280008c 	andi	r10,r22,2
 200bb84:	50008f26 	beq	r10,zero,200bdc4 <__svfscanf_r+0x1578>
 200bb88:	da009c17 	ldw	r8,624(sp)
 200bb8c:	40800017 	ldw	r2,0(r8)
 200bb90:	42000104 	addi	r8,r8,4
 200bb94:	da009c15 	stw	r8,624(sp)
 200bb98:	15400015 	stw	r21,0(r2)
 200bb9c:	10c00115 	stw	r3,4(r2)
 200bba0:	003cf806 	br	200af84 <__svfscanf_r+0x738>
 200bba4:	b0c0010c 	andi	r3,r22,4
 200bba8:	18006226 	beq	r3,zero,200bd34 <__svfscanf_r+0x14e8>
 200bbac:	d9409c17 	ldw	r5,624(sp)
 200bbb0:	28c00017 	ldw	r3,0(r5)
 200bbb4:	29400104 	addi	r5,r5,4
 200bbb8:	d9409c15 	stw	r5,624(sp)
 200bbbc:	1880000d 	sth	r2,0(r3)
 200bbc0:	003fb606 	br	200ba9c <__svfscanf_r+0x1250>
 200bbc4:	d8c09c17 	ldw	r3,624(sp)
 200bbc8:	980d883a 	mov	r6,r19
 200bbcc:	01400044 	movi	r5,1
 200bbd0:	19000017 	ldw	r4,0(r3)
 200bbd4:	e00f883a 	mov	r7,fp
 200bbd8:	2004f380 	call	2004f38 <fread>
 200bbdc:	d9009c17 	ldw	r4,624(sp)
 200bbe0:	24c00104 	addi	r19,r4,4
 200bbe4:	103c4c26 	beq	r2,zero,200ad18 <__svfscanf_r+0x4cc>
 200bbe8:	1529883a 	add	r20,r2,r20
 200bbec:	d8809e17 	ldw	r2,632(sp)
 200bbf0:	dc009d17 	ldw	r16,628(sp)
 200bbf4:	dcc09c15 	stw	r19,624(sp)
 200bbf8:	10800044 	addi	r2,r2,1
 200bbfc:	d8809e15 	stw	r2,632(sp)
 200bc00:	800d883a 	mov	r6,r16
 200bc04:	003b4a06 	br	200a930 <__svfscanf_r+0xe4>
 200bc08:	da00a117 	ldw	r8,644(sp)
 200bc0c:	000d883a 	mov	r6,zero
 200bc10:	8809883a 	mov	r4,r17
 200bc14:	41400044 	addi	r5,r8,1
 200bc18:	01c00284 	movi	r7,10
 200bc1c:	200876c0 	call	200876c <_strtol_r>
 200bc20:	d8c0a317 	ldw	r3,652(sp)
 200bc24:	10cdc83a 	sub	r6,r2,r3
 200bc28:	d900a117 	ldw	r4,644(sp)
 200bc2c:	d88055c4 	addi	r2,sp,343
 200bc30:	20800236 	bltu	r4,r2,200bc3c <__svfscanf_r+0x13f0>
 200bc34:	d9005584 	addi	r4,sp,342
 200bc38:	d900a115 	stw	r4,644(sp)
 200bc3c:	d900a117 	ldw	r4,644(sp)
 200bc40:	01408174 	movhi	r5,517
 200bc44:	29779d04 	addi	r5,r5,-8588
 200bc48:	2006fec0 	call	2006fec <sprintf>
 200bc4c:	003cbf06 	br	200af4c <__svfscanf_r+0x700>
 200bc50:	da00a217 	ldw	r8,648(sp)
 200bc54:	aa05c83a 	sub	r2,r21,r8
 200bc58:	008dc83a 	sub	r6,zero,r2
 200bc5c:	103cbb26 	beq	r2,zero,200af4c <__svfscanf_r+0x700>
 200bc60:	dc80a115 	stw	r18,644(sp)
 200bc64:	003ff006 	br	200bc28 <__svfscanf_r+0x13dc>
 200bc68:	023fff84 	movi	r8,-2
 200bc6c:	123f5926 	beq	r2,r8,200b9d4 <__svfscanf_r+0x1188>
 200bc70:	a9000017 	ldw	r4,0(r21)
 200bc74:	200e2580 	call	200e258 <iswspace>
 200bc78:	103f5126 	beq	r2,zero,200b9c0 <__svfscanf_r+0x1174>
 200bc7c:	803f5c26 	beq	r16,zero,200b9f0 <__svfscanf_r+0x11a4>
 200bc80:	843fffc4 	addi	r16,r16,-1
 200bc84:	d8c00104 	addi	r3,sp,4
 200bc88:	1c05883a 	add	r2,r3,r16
 200bc8c:	11400003 	ldbu	r5,0(r2)
 200bc90:	8809883a 	mov	r4,r17
 200bc94:	e00d883a 	mov	r6,fp
 200bc98:	2011d640 	call	2011d64 <_ungetc_r>
 200bc9c:	803ff81e 	bne	r16,zero,200bc80 <__svfscanf_r+0x1434>
 200bca0:	003f5306 	br	200b9f0 <__svfscanf_r+0x11a4>
 200bca4:	b32c703a 	and	r22,r22,r12
 200bca8:	01800044 	movi	r6,1
 200bcac:	003dcb06 	br	200b3dc <__svfscanf_r+0xb90>
 200bcb0:	81400083 	ldbu	r5,2(r16)
 200bcb4:	b5800094 	ori	r22,r22,2
 200bcb8:	84000084 	addi	r16,r16,2
 200bcbc:	003b4206 	br	200a9c8 <__svfscanf_r+0x17c>
 200bcc0:	b080004c 	andi	r2,r22,1
 200bcc4:	1000131e 	bne	r2,zero,200bd14 <__svfscanf_r+0x14c8>
 200bcc8:	b580008c 	andi	r22,r22,2
 200bccc:	b0003526 	beq	r22,zero,200bda4 <__svfscanf_r+0x1558>
 200bcd0:	d9409c17 	ldw	r5,624(sp)
 200bcd4:	a007d7fa 	srai	r3,r20,31
 200bcd8:	dc009d17 	ldw	r16,628(sp)
 200bcdc:	28800017 	ldw	r2,0(r5)
 200bce0:	29400104 	addi	r5,r5,4
 200bce4:	d9409c15 	stw	r5,624(sp)
 200bce8:	15000015 	stw	r20,0(r2)
 200bcec:	10c00115 	stw	r3,4(r2)
 200bcf0:	800d883a 	mov	r6,r16
 200bcf4:	003b0e06 	br	200a930 <__svfscanf_r+0xe4>
 200bcf8:	e1000017 	ldw	r4,0(fp)
 200bcfc:	14c5c83a 	sub	r2,r2,r19
 200bd00:	84e1883a 	add	r16,r16,r19
 200bd04:	24c7883a 	add	r3,r4,r19
 200bd08:	e0800115 	stw	r2,4(fp)
 200bd0c:	e0c00015 	stw	r3,0(fp)
 200bd10:	003cc406 	br	200b024 <__svfscanf_r+0x7d8>
 200bd14:	d9009c17 	ldw	r4,624(sp)
 200bd18:	dc009d17 	ldw	r16,628(sp)
 200bd1c:	20800017 	ldw	r2,0(r4)
 200bd20:	21000104 	addi	r4,r4,4
 200bd24:	d9009c15 	stw	r4,624(sp)
 200bd28:	15000015 	stw	r20,0(r2)
 200bd2c:	800d883a 	mov	r6,r16
 200bd30:	003aff06 	br	200a930 <__svfscanf_r+0xe4>
 200bd34:	b0c0004c 	andi	r3,r22,1
 200bd38:	1800121e 	bne	r3,zero,200bd84 <__svfscanf_r+0x1538>
 200bd3c:	b580008c 	andi	r22,r22,2
 200bd40:	b0001026 	beq	r22,zero,200bd84 <__svfscanf_r+0x1538>
 200bd44:	da00a017 	ldw	r8,640(sp)
 200bd48:	00808074 	movhi	r2,513
 200bd4c:	10858e04 	addi	r2,r2,5688
 200bd50:	8809883a 	mov	r4,r17
 200bd54:	d9400104 	addi	r5,sp,4
 200bd58:	000d883a 	mov	r6,zero
 200bd5c:	d9c09f17 	ldw	r7,636(sp)
 200bd60:	40803626 	beq	r8,r2,200be3c <__svfscanf_r+0x15f0>
 200bd64:	20113080 	call	2011308 <_strtoll_r>
 200bd68:	d9409c17 	ldw	r5,624(sp)
 200bd6c:	29000017 	ldw	r4,0(r5)
 200bd70:	29400104 	addi	r5,r5,4
 200bd74:	d9409c15 	stw	r5,624(sp)
 200bd78:	20800015 	stw	r2,0(r4)
 200bd7c:	20c00115 	stw	r3,4(r4)
 200bd80:	003f4606 	br	200ba9c <__svfscanf_r+0x1250>
 200bd84:	da009c17 	ldw	r8,624(sp)
 200bd88:	40c00017 	ldw	r3,0(r8)
 200bd8c:	42000104 	addi	r8,r8,4
 200bd90:	da009c15 	stw	r8,624(sp)
 200bd94:	18800015 	stw	r2,0(r3)
 200bd98:	003f4006 	br	200ba9c <__svfscanf_r+0x1250>
 200bd9c:	0021883a 	mov	r16,zero
 200bda0:	003f0c06 	br	200b9d4 <__svfscanf_r+0x1188>
 200bda4:	da009c17 	ldw	r8,624(sp)
 200bda8:	dc009d17 	ldw	r16,628(sp)
 200bdac:	40800017 	ldw	r2,0(r8)
 200bdb0:	42000104 	addi	r8,r8,4
 200bdb4:	da009c15 	stw	r8,624(sp)
 200bdb8:	15000015 	stw	r20,0(r2)
 200bdbc:	800d883a 	mov	r6,r16
 200bdc0:	003adb06 	br	200a930 <__svfscanf_r+0xe4>
 200bdc4:	d8809c17 	ldw	r2,624(sp)
 200bdc8:	a809883a 	mov	r4,r21
 200bdcc:	180b883a 	mov	r5,r3
 200bdd0:	14000104 	addi	r16,r2,4
 200bdd4:	14800017 	ldw	r18,0(r2)
 200bdd8:	200fc7c0 	call	200fc7c <__isnand>
 200bddc:	1000121e 	bne	r2,zero,200be28 <__svfscanf_r+0x15dc>
 200bde0:	a809883a 	mov	r4,r21
 200bde4:	980b883a 	mov	r5,r19
 200bde8:	20145000 	call	2014500 <__truncdfsf2>
 200bdec:	90800015 	stw	r2,0(r18)
 200bdf0:	dc009c15 	stw	r16,624(sp)
 200bdf4:	003c6306 	br	200af84 <__svfscanf_r+0x738>
 200bdf8:	d9000104 	addi	r4,sp,4
 200bdfc:	e021883a 	mov	r16,fp
 200be00:	24bacf2e 	bgeu	r4,r18,200a940 <__svfscanf_r+0xf4>
 200be04:	94bfffc4 	addi	r18,r18,-1
 200be08:	dcc000c4 	addi	r19,sp,3
 200be0c:	91400007 	ldb	r5,0(r18)
 200be10:	8809883a 	mov	r4,r17
 200be14:	94bfffc4 	addi	r18,r18,-1
 200be18:	800d883a 	mov	r6,r16
 200be1c:	2011d640 	call	2011d64 <_ungetc_r>
 200be20:	94fffa1e 	bne	r18,r19,200be0c <__svfscanf_r+0x15c0>
 200be24:	003ac606 	br	200a940 <__svfscanf_r+0xf4>
 200be28:	0009883a 	mov	r4,zero
 200be2c:	200fd6c0 	call	200fd6c <nanf>
 200be30:	90800015 	stw	r2,0(r18)
 200be34:	dc009c15 	stw	r16,624(sp)
 200be38:	003c5206 	br	200af84 <__svfscanf_r+0x738>
 200be3c:	20118e00 	call	20118e0 <_strtoull_r>
 200be40:	003fc906 	br	200bd68 <__svfscanf_r+0x151c>
 200be44:	d8c00104 	addi	r3,sp,4
 200be48:	e021883a 	mov	r16,fp
 200be4c:	1cbabc2e 	bgeu	r3,r18,200a940 <__svfscanf_r+0xf4>
 200be50:	94bfffc4 	addi	r18,r18,-1
 200be54:	dcc000c4 	addi	r19,sp,3
 200be58:	91400007 	ldb	r5,0(r18)
 200be5c:	8809883a 	mov	r4,r17
 200be60:	94bfffc4 	addi	r18,r18,-1
 200be64:	800d883a 	mov	r6,r16
 200be68:	2011d640 	call	2011d64 <_ungetc_r>
 200be6c:	94fffa1e 	bne	r18,r19,200be58 <__svfscanf_r+0x160c>
 200be70:	003ab306 	br	200a940 <__svfscanf_r+0xf4>
 200be74:	d8800104 	addi	r2,sp,4
 200be78:	e021883a 	mov	r16,fp
 200be7c:	14bab02e 	bgeu	r2,r18,200a940 <__svfscanf_r+0xf4>
 200be80:	94bfffc4 	addi	r18,r18,-1
 200be84:	dcc000c4 	addi	r19,sp,3
 200be88:	91400007 	ldb	r5,0(r18)
 200be8c:	8809883a 	mov	r4,r17
 200be90:	94bfffc4 	addi	r18,r18,-1
 200be94:	800d883a 	mov	r6,r16
 200be98:	2011d640 	call	2011d64 <_ungetc_r>
 200be9c:	94fffa1e 	bne	r18,r19,200be88 <__svfscanf_r+0x163c>
 200bea0:	003aa706 	br	200a940 <__svfscanf_r+0xf4>

0200bea4 <_vfscanf_r>:
 200bea4:	defffb04 	addi	sp,sp,-20
 200bea8:	dc000315 	stw	r16,12(sp)
 200beac:	dfc00415 	stw	ra,16(sp)
 200beb0:	2021883a 	mov	r16,r4
 200beb4:	20000926 	beq	r4,zero,200bedc <_vfscanf_r+0x38>
 200beb8:	20800e17 	ldw	r2,56(r4)
 200bebc:	1000071e 	bne	r2,zero,200bedc <_vfscanf_r+0x38>
 200bec0:	d9400015 	stw	r5,0(sp)
 200bec4:	d9800115 	stw	r6,4(sp)
 200bec8:	d9c00215 	stw	r7,8(sp)
 200becc:	200492c0 	call	200492c <__sinit>
 200bed0:	d9c00217 	ldw	r7,8(sp)
 200bed4:	d9800117 	ldw	r6,4(sp)
 200bed8:	d9400017 	ldw	r5,0(sp)
 200bedc:	8009883a 	mov	r4,r16
 200bee0:	dfc00417 	ldw	ra,16(sp)
 200bee4:	dc000317 	ldw	r16,12(sp)
 200bee8:	dec00504 	addi	sp,sp,20
 200beec:	200a84c1 	jmpi	200a84c <__svfscanf_r>

0200bef0 <__svfscanf>:
 200bef0:	00808174 	movhi	r2,517
 200bef4:	10903604 	addi	r2,r2,16600
 200bef8:	2007883a 	mov	r3,r4
 200befc:	11000017 	ldw	r4,0(r2)
 200bf00:	2805883a 	mov	r2,r5
 200bf04:	300f883a 	mov	r7,r6
 200bf08:	180b883a 	mov	r5,r3
 200bf0c:	100d883a 	mov	r6,r2
 200bf10:	200a84c1 	jmpi	200a84c <__svfscanf_r>

0200bf14 <vfscanf>:
 200bf14:	defffb04 	addi	sp,sp,-20
 200bf18:	dc000115 	stw	r16,4(sp)
 200bf1c:	04008174 	movhi	r16,517
 200bf20:	84103604 	addi	r16,r16,16600
 200bf24:	80800017 	ldw	r2,0(r16)
 200bf28:	dc800315 	stw	r18,12(sp)
 200bf2c:	dc400215 	stw	r17,8(sp)
 200bf30:	dfc00415 	stw	ra,16(sp)
 200bf34:	2025883a 	mov	r18,r4
 200bf38:	2823883a 	mov	r17,r5
 200bf3c:	300f883a 	mov	r7,r6
 200bf40:	10000726 	beq	r2,zero,200bf60 <vfscanf+0x4c>
 200bf44:	10c00e17 	ldw	r3,56(r2)
 200bf48:	1800051e 	bne	r3,zero,200bf60 <vfscanf+0x4c>
 200bf4c:	1009883a 	mov	r4,r2
 200bf50:	d9800015 	stw	r6,0(sp)
 200bf54:	200492c0 	call	200492c <__sinit>
 200bf58:	80800017 	ldw	r2,0(r16)
 200bf5c:	d9c00017 	ldw	r7,0(sp)
 200bf60:	1009883a 	mov	r4,r2
 200bf64:	900b883a 	mov	r5,r18
 200bf68:	880d883a 	mov	r6,r17
 200bf6c:	dfc00417 	ldw	ra,16(sp)
 200bf70:	dc800317 	ldw	r18,12(sp)
 200bf74:	dc400217 	ldw	r17,8(sp)
 200bf78:	dc000117 	ldw	r16,4(sp)
 200bf7c:	dec00504 	addi	sp,sp,20
 200bf80:	200a84c1 	jmpi	200a84c <__svfscanf_r>

0200bf84 <__swbuf_r>:
 200bf84:	defffc04 	addi	sp,sp,-16
 200bf88:	dc800215 	stw	r18,8(sp)
 200bf8c:	dc400115 	stw	r17,4(sp)
 200bf90:	dc000015 	stw	r16,0(sp)
 200bf94:	dfc00315 	stw	ra,12(sp)
 200bf98:	2023883a 	mov	r17,r4
 200bf9c:	2825883a 	mov	r18,r5
 200bfa0:	3021883a 	mov	r16,r6
 200bfa4:	20000226 	beq	r4,zero,200bfb0 <__swbuf_r+0x2c>
 200bfa8:	20800e17 	ldw	r2,56(r4)
 200bfac:	10003b26 	beq	r2,zero,200c09c <__swbuf_r+0x118>
 200bfb0:	8080030b 	ldhu	r2,12(r16)
 200bfb4:	80c00617 	ldw	r3,24(r16)
 200bfb8:	1080020c 	andi	r2,r2,8
 200bfbc:	10bfffcc 	andi	r2,r2,65535
 200bfc0:	10a0001c 	xori	r2,r2,32768
 200bfc4:	80c00215 	stw	r3,8(r16)
 200bfc8:	10a00004 	addi	r2,r2,-32768
 200bfcc:	10002226 	beq	r2,zero,200c058 <__swbuf_r+0xd4>
 200bfd0:	80800417 	ldw	r2,16(r16)
 200bfd4:	10002026 	beq	r2,zero,200c058 <__swbuf_r+0xd4>
 200bfd8:	80c00017 	ldw	r3,0(r16)
 200bfdc:	81000517 	ldw	r4,20(r16)
 200bfe0:	94803fcc 	andi	r18,r18,255
 200bfe4:	1885c83a 	sub	r2,r3,r2
 200bfe8:	1100250e 	bge	r2,r4,200c080 <__swbuf_r+0xfc>
 200bfec:	10800044 	addi	r2,r2,1
 200bff0:	81400217 	ldw	r5,8(r16)
 200bff4:	19000044 	addi	r4,r3,1
 200bff8:	297fffc4 	addi	r5,r5,-1
 200bffc:	81400215 	stw	r5,8(r16)
 200c000:	1c800005 	stb	r18,0(r3)
 200c004:	80c00517 	ldw	r3,20(r16)
 200c008:	81000015 	stw	r4,0(r16)
 200c00c:	18800c26 	beq	r3,r2,200c040 <__swbuf_r+0xbc>
 200c010:	8080030b 	ldhu	r2,12(r16)
 200c014:	1080004c 	andi	r2,r2,1
 200c018:	10000226 	beq	r2,zero,200c024 <__swbuf_r+0xa0>
 200c01c:	00800284 	movi	r2,10
 200c020:	90800726 	beq	r18,r2,200c040 <__swbuf_r+0xbc>
 200c024:	9005883a 	mov	r2,r18
 200c028:	dfc00317 	ldw	ra,12(sp)
 200c02c:	dc800217 	ldw	r18,8(sp)
 200c030:	dc400117 	ldw	r17,4(sp)
 200c034:	dc000017 	ldw	r16,0(sp)
 200c038:	dec00404 	addi	sp,sp,16
 200c03c:	f800283a 	ret
 200c040:	8809883a 	mov	r4,r17
 200c044:	800b883a 	mov	r5,r16
 200c048:	200463c0 	call	200463c <_fflush_r>
 200c04c:	103ff526 	beq	r2,zero,200c024 <__swbuf_r+0xa0>
 200c050:	04bfffc4 	movi	r18,-1
 200c054:	003ff306 	br	200c024 <__swbuf_r+0xa0>
 200c058:	8809883a 	mov	r4,r17
 200c05c:	800b883a 	mov	r5,r16
 200c060:	200c1480 	call	200c148 <__swsetup_r>
 200c064:	10000f1e 	bne	r2,zero,200c0a4 <__swbuf_r+0x120>
 200c068:	80800417 	ldw	r2,16(r16)
 200c06c:	80c00017 	ldw	r3,0(r16)
 200c070:	81000517 	ldw	r4,20(r16)
 200c074:	94803fcc 	andi	r18,r18,255
 200c078:	1885c83a 	sub	r2,r3,r2
 200c07c:	113fdb16 	blt	r2,r4,200bfec <__swbuf_r+0x68>
 200c080:	8809883a 	mov	r4,r17
 200c084:	800b883a 	mov	r5,r16
 200c088:	200463c0 	call	200463c <_fflush_r>
 200c08c:	103ff01e 	bne	r2,zero,200c050 <__swbuf_r+0xcc>
 200c090:	80c00017 	ldw	r3,0(r16)
 200c094:	00800044 	movi	r2,1
 200c098:	003fd506 	br	200bff0 <__swbuf_r+0x6c>
 200c09c:	200492c0 	call	200492c <__sinit>
 200c0a0:	003fc306 	br	200bfb0 <__swbuf_r+0x2c>
 200c0a4:	8080030b 	ldhu	r2,12(r16)
 200c0a8:	04bfffc4 	movi	r18,-1
 200c0ac:	10801014 	ori	r2,r2,64
 200c0b0:	8080030d 	sth	r2,12(r16)
 200c0b4:	00800244 	movi	r2,9
 200c0b8:	88800015 	stw	r2,0(r17)
 200c0bc:	003fd906 	br	200c024 <__swbuf_r+0xa0>

0200c0c0 <__swbuf>:
 200c0c0:	00c08174 	movhi	r3,517
 200c0c4:	18d03604 	addi	r3,r3,16600
 200c0c8:	2005883a 	mov	r2,r4
 200c0cc:	19000017 	ldw	r4,0(r3)
 200c0d0:	280d883a 	mov	r6,r5
 200c0d4:	100b883a 	mov	r5,r2
 200c0d8:	200bf841 	jmpi	200bf84 <__swbuf_r>

0200c0dc <_write_r>:
 200c0dc:	defffd04 	addi	sp,sp,-12
 200c0e0:	dc400115 	stw	r17,4(sp)
 200c0e4:	dc000015 	stw	r16,0(sp)
 200c0e8:	2023883a 	mov	r17,r4
 200c0ec:	04008174 	movhi	r16,517
 200c0f0:	84108b04 	addi	r16,r16,16940
 200c0f4:	2809883a 	mov	r4,r5
 200c0f8:	300b883a 	mov	r5,r6
 200c0fc:	380d883a 	mov	r6,r7
 200c100:	dfc00215 	stw	ra,8(sp)
 200c104:	80000015 	stw	zero,0(r16)
 200c108:	20239480 	call	2023948 <write>
 200c10c:	00ffffc4 	movi	r3,-1
 200c110:	10c00526 	beq	r2,r3,200c128 <_write_r+0x4c>
 200c114:	dfc00217 	ldw	ra,8(sp)
 200c118:	dc400117 	ldw	r17,4(sp)
 200c11c:	dc000017 	ldw	r16,0(sp)
 200c120:	dec00304 	addi	sp,sp,12
 200c124:	f800283a 	ret
 200c128:	80c00017 	ldw	r3,0(r16)
 200c12c:	183ff926 	beq	r3,zero,200c114 <_write_r+0x38>
 200c130:	88c00015 	stw	r3,0(r17)
 200c134:	dfc00217 	ldw	ra,8(sp)
 200c138:	dc400117 	ldw	r17,4(sp)
 200c13c:	dc000017 	ldw	r16,0(sp)
 200c140:	dec00304 	addi	sp,sp,12
 200c144:	f800283a 	ret

0200c148 <__swsetup_r>:
 200c148:	00808174 	movhi	r2,517
 200c14c:	10903604 	addi	r2,r2,16600
 200c150:	10800017 	ldw	r2,0(r2)
 200c154:	defffd04 	addi	sp,sp,-12
 200c158:	dc400115 	stw	r17,4(sp)
 200c15c:	dc000015 	stw	r16,0(sp)
 200c160:	dfc00215 	stw	ra,8(sp)
 200c164:	2023883a 	mov	r17,r4
 200c168:	2821883a 	mov	r16,r5
 200c16c:	10000226 	beq	r2,zero,200c178 <__swsetup_r+0x30>
 200c170:	10c00e17 	ldw	r3,56(r2)
 200c174:	18003d26 	beq	r3,zero,200c26c <__swsetup_r+0x124>
 200c178:	8080030b 	ldhu	r2,12(r16)
 200c17c:	10c0020c 	andi	r3,r2,8
 200c180:	18ffffcc 	andi	r3,r3,65535
 200c184:	18e0001c 	xori	r3,r3,32768
 200c188:	18e00004 	addi	r3,r3,-32768
 200c18c:	18001226 	beq	r3,zero,200c1d8 <__swsetup_r+0x90>
 200c190:	80c00417 	ldw	r3,16(r16)
 200c194:	18001f26 	beq	r3,zero,200c214 <__swsetup_r+0xcc>
 200c198:	1100004c 	andi	r4,r2,1
 200c19c:	2000261e 	bne	r4,zero,200c238 <__swsetup_r+0xf0>
 200c1a0:	1080008c 	andi	r2,r2,2
 200c1a4:	10bfffcc 	andi	r2,r2,65535
 200c1a8:	10a0001c 	xori	r2,r2,32768
 200c1ac:	10a00004 	addi	r2,r2,-32768
 200c1b0:	1000311e 	bne	r2,zero,200c278 <__swsetup_r+0x130>
 200c1b4:	80800517 	ldw	r2,20(r16)
 200c1b8:	80800215 	stw	r2,8(r16)
 200c1bc:	18002326 	beq	r3,zero,200c24c <__swsetup_r+0x104>
 200c1c0:	0005883a 	mov	r2,zero
 200c1c4:	dfc00217 	ldw	ra,8(sp)
 200c1c8:	dc400117 	ldw	r17,4(sp)
 200c1cc:	dc000017 	ldw	r16,0(sp)
 200c1d0:	dec00304 	addi	sp,sp,12
 200c1d4:	f800283a 	ret
 200c1d8:	10c0040c 	andi	r3,r2,16
 200c1dc:	18ffffcc 	andi	r3,r3,65535
 200c1e0:	18e0001c 	xori	r3,r3,32768
 200c1e4:	18e00004 	addi	r3,r3,-32768
 200c1e8:	18001e26 	beq	r3,zero,200c264 <__swsetup_r+0x11c>
 200c1ec:	10c0010c 	andi	r3,r2,4
 200c1f0:	18ffffcc 	andi	r3,r3,65535
 200c1f4:	18e0001c 	xori	r3,r3,32768
 200c1f8:	18e00004 	addi	r3,r3,-32768
 200c1fc:	1800211e 	bne	r3,zero,200c284 <__swsetup_r+0x13c>
 200c200:	80c00417 	ldw	r3,16(r16)
 200c204:	11400214 	ori	r5,r2,8
 200c208:	8140030d 	sth	r5,12(r16)
 200c20c:	2805883a 	mov	r2,r5
 200c210:	183fe11e 	bne	r3,zero,200c198 <__swsetup_r+0x50>
 200c214:	1140a00c 	andi	r5,r2,640
 200c218:	01008004 	movi	r4,512
 200c21c:	293fde26 	beq	r5,r4,200c198 <__swsetup_r+0x50>
 200c220:	8809883a 	mov	r4,r17
 200c224:	800b883a 	mov	r5,r16
 200c228:	2005ce00 	call	2005ce0 <__smakebuf_r>
 200c22c:	8080030b 	ldhu	r2,12(r16)
 200c230:	80c00417 	ldw	r3,16(r16)
 200c234:	003fd806 	br	200c198 <__swsetup_r+0x50>
 200c238:	80800517 	ldw	r2,20(r16)
 200c23c:	80000215 	stw	zero,8(r16)
 200c240:	0085c83a 	sub	r2,zero,r2
 200c244:	80800615 	stw	r2,24(r16)
 200c248:	183fdd1e 	bne	r3,zero,200c1c0 <__swsetup_r+0x78>
 200c24c:	8080030b 	ldhu	r2,12(r16)
 200c250:	1080200c 	andi	r2,r2,128
 200c254:	10bfffcc 	andi	r2,r2,65535
 200c258:	10a0001c 	xori	r2,r2,32768
 200c25c:	10a00004 	addi	r2,r2,-32768
 200c260:	103fd826 	beq	r2,zero,200c1c4 <__swsetup_r+0x7c>
 200c264:	00bfffc4 	movi	r2,-1
 200c268:	003fd606 	br	200c1c4 <__swsetup_r+0x7c>
 200c26c:	1009883a 	mov	r4,r2
 200c270:	200492c0 	call	200492c <__sinit>
 200c274:	003fc006 	br	200c178 <__swsetup_r+0x30>
 200c278:	0005883a 	mov	r2,zero
 200c27c:	80800215 	stw	r2,8(r16)
 200c280:	003fce06 	br	200c1bc <__swsetup_r+0x74>
 200c284:	81400c17 	ldw	r5,48(r16)
 200c288:	28000626 	beq	r5,zero,200c2a4 <__swsetup_r+0x15c>
 200c28c:	80c01004 	addi	r3,r16,64
 200c290:	28c00326 	beq	r5,r3,200c2a0 <__swsetup_r+0x158>
 200c294:	8809883a 	mov	r4,r17
 200c298:	20050b40 	call	20050b4 <_free_r>
 200c29c:	8080030b 	ldhu	r2,12(r16)
 200c2a0:	80000c15 	stw	zero,48(r16)
 200c2a4:	80c00417 	ldw	r3,16(r16)
 200c2a8:	013ff6c4 	movi	r4,-37
 200c2ac:	2084703a 	and	r2,r4,r2
 200c2b0:	80000115 	stw	zero,4(r16)
 200c2b4:	80c00015 	stw	r3,0(r16)
 200c2b8:	003fd206 	br	200c204 <__swsetup_r+0xbc>

0200c2bc <_close_r>:
 200c2bc:	defffd04 	addi	sp,sp,-12
 200c2c0:	dc400115 	stw	r17,4(sp)
 200c2c4:	dc000015 	stw	r16,0(sp)
 200c2c8:	2023883a 	mov	r17,r4
 200c2cc:	04008174 	movhi	r16,517
 200c2d0:	84108b04 	addi	r16,r16,16940
 200c2d4:	2809883a 	mov	r4,r5
 200c2d8:	dfc00215 	stw	ra,8(sp)
 200c2dc:	80000015 	stw	zero,0(r16)
 200c2e0:	20237680 	call	2023768 <close>
 200c2e4:	00ffffc4 	movi	r3,-1
 200c2e8:	10c00526 	beq	r2,r3,200c300 <_close_r+0x44>
 200c2ec:	dfc00217 	ldw	ra,8(sp)
 200c2f0:	dc400117 	ldw	r17,4(sp)
 200c2f4:	dc000017 	ldw	r16,0(sp)
 200c2f8:	dec00304 	addi	sp,sp,12
 200c2fc:	f800283a 	ret
 200c300:	80c00017 	ldw	r3,0(r16)
 200c304:	183ff926 	beq	r3,zero,200c2ec <_close_r+0x30>
 200c308:	88c00015 	stw	r3,0(r17)
 200c30c:	dfc00217 	ldw	ra,8(sp)
 200c310:	dc400117 	ldw	r17,4(sp)
 200c314:	dc000017 	ldw	r16,0(sp)
 200c318:	dec00304 	addi	sp,sp,12
 200c31c:	f800283a 	ret

0200c320 <quorem>:
 200c320:	defff704 	addi	sp,sp,-36
 200c324:	dc400115 	stw	r17,4(sp)
 200c328:	20800417 	ldw	r2,16(r4)
 200c32c:	2c400417 	ldw	r17,16(r5)
 200c330:	dd800615 	stw	r22,24(sp)
 200c334:	dd400515 	stw	r21,20(sp)
 200c338:	dfc00815 	stw	ra,32(sp)
 200c33c:	ddc00715 	stw	r23,28(sp)
 200c340:	dd000415 	stw	r20,16(sp)
 200c344:	dcc00315 	stw	r19,12(sp)
 200c348:	dc800215 	stw	r18,8(sp)
 200c34c:	dc000015 	stw	r16,0(sp)
 200c350:	202b883a 	mov	r21,r4
 200c354:	282d883a 	mov	r22,r5
 200c358:	14407116 	blt	r2,r17,200c520 <quorem+0x200>
 200c35c:	88800104 	addi	r2,r17,4
 200c360:	1085883a 	add	r2,r2,r2
 200c364:	1085883a 	add	r2,r2,r2
 200c368:	28a7883a 	add	r19,r5,r2
 200c36c:	2085883a 	add	r2,r4,r2
 200c370:	15c00017 	ldw	r23,0(r2)
 200c374:	99400017 	ldw	r5,0(r19)
 200c378:	8c7fffc4 	addi	r17,r17,-1
 200c37c:	b809883a 	mov	r4,r23
 200c380:	29400044 	addi	r5,r5,1
 200c384:	201479c0 	call	201479c <__udivsi3>
 200c388:	1025883a 	mov	r18,r2
 200c38c:	b4000504 	addi	r16,r22,20
 200c390:	ad000504 	addi	r20,r21,20
 200c394:	10002d26 	beq	r2,zero,200c44c <quorem+0x12c>
 200c398:	800d883a 	mov	r6,r16
 200c39c:	a007883a 	mov	r3,r20
 200c3a0:	000f883a 	mov	r7,zero
 200c3a4:	0005883a 	mov	r2,zero
 200c3a8:	32c00017 	ldw	r11,0(r6)
 200c3ac:	1a400017 	ldw	r9,0(r3)
 200c3b0:	31800104 	addi	r6,r6,4
 200c3b4:	5abfffcc 	andi	r10,r11,65535
 200c3b8:	5495383a 	mul	r10,r10,r18
 200c3bc:	5816d43a 	srli	r11,r11,16
 200c3c0:	4a3fffcc 	andi	r8,r9,65535
 200c3c4:	3a95883a 	add	r10,r7,r10
 200c3c8:	500ed43a 	srli	r7,r10,16
 200c3cc:	5c97383a 	mul	r11,r11,r18
 200c3d0:	4085883a 	add	r2,r8,r2
 200c3d4:	52bfffcc 	andi	r10,r10,65535
 200c3d8:	1291c83a 	sub	r8,r2,r10
 200c3dc:	4804d43a 	srli	r2,r9,16
 200c3e0:	3acf883a 	add	r7,r7,r11
 200c3e4:	4015d43a 	srai	r10,r8,16
 200c3e8:	393fffcc 	andi	r4,r7,65535
 200c3ec:	1105c83a 	sub	r2,r2,r4
 200c3f0:	1285883a 	add	r2,r2,r10
 200c3f4:	1880008d 	sth	r2,2(r3)
 200c3f8:	1a00000d 	sth	r8,0(r3)
 200c3fc:	380ed43a 	srli	r7,r7,16
 200c400:	1005d43a 	srai	r2,r2,16
 200c404:	18c00104 	addi	r3,r3,4
 200c408:	99bfe72e 	bgeu	r19,r6,200c3a8 <quorem+0x88>
 200c40c:	b8000f1e 	bne	r23,zero,200c44c <quorem+0x12c>
 200c410:	88800144 	addi	r2,r17,5
 200c414:	1085883a 	add	r2,r2,r2
 200c418:	1085883a 	add	r2,r2,r2
 200c41c:	a887883a 	add	r3,r21,r2
 200c420:	18bfff04 	addi	r2,r3,-4
 200c424:	a080082e 	bgeu	r20,r2,200c448 <quorem+0x128>
 200c428:	18ffff17 	ldw	r3,-4(r3)
 200c42c:	18000326 	beq	r3,zero,200c43c <quorem+0x11c>
 200c430:	00000506 	br	200c448 <quorem+0x128>
 200c434:	10c00017 	ldw	r3,0(r2)
 200c438:	1800031e 	bne	r3,zero,200c448 <quorem+0x128>
 200c43c:	10bfff04 	addi	r2,r2,-4
 200c440:	8c7fffc4 	addi	r17,r17,-1
 200c444:	a0bffb36 	bltu	r20,r2,200c434 <quorem+0x114>
 200c448:	ac400415 	stw	r17,16(r21)
 200c44c:	a809883a 	mov	r4,r21
 200c450:	b00b883a 	mov	r5,r22
 200c454:	200eed80 	call	200eed8 <__mcmp>
 200c458:	10002516 	blt	r2,zero,200c4f0 <quorem+0x1d0>
 200c45c:	94800044 	addi	r18,r18,1
 200c460:	a007883a 	mov	r3,r20
 200c464:	000b883a 	mov	r5,zero
 200c468:	1a000017 	ldw	r8,0(r3)
 200c46c:	81c00017 	ldw	r7,0(r16)
 200c470:	84000104 	addi	r16,r16,4
 200c474:	41bfffcc 	andi	r6,r8,65535
 200c478:	38bfffcc 	andi	r2,r7,65535
 200c47c:	314b883a 	add	r5,r6,r5
 200c480:	288dc83a 	sub	r6,r5,r2
 200c484:	380ed43a 	srli	r7,r7,16
 200c488:	400ad43a 	srli	r5,r8,16
 200c48c:	3005d43a 	srai	r2,r6,16
 200c490:	1980000d 	sth	r6,0(r3)
 200c494:	29cbc83a 	sub	r5,r5,r7
 200c498:	288b883a 	add	r5,r5,r2
 200c49c:	1940008d 	sth	r5,2(r3)
 200c4a0:	280bd43a 	srai	r5,r5,16
 200c4a4:	18c00104 	addi	r3,r3,4
 200c4a8:	9c3fef2e 	bgeu	r19,r16,200c468 <quorem+0x148>
 200c4ac:	88800144 	addi	r2,r17,5
 200c4b0:	1085883a 	add	r2,r2,r2
 200c4b4:	1085883a 	add	r2,r2,r2
 200c4b8:	a885883a 	add	r2,r21,r2
 200c4bc:	10c00017 	ldw	r3,0(r2)
 200c4c0:	18000b1e 	bne	r3,zero,200c4f0 <quorem+0x1d0>
 200c4c4:	10ffff04 	addi	r3,r2,-4
 200c4c8:	a0c0082e 	bgeu	r20,r3,200c4ec <quorem+0x1cc>
 200c4cc:	10bfff17 	ldw	r2,-4(r2)
 200c4d0:	10000326 	beq	r2,zero,200c4e0 <quorem+0x1c0>
 200c4d4:	00000506 	br	200c4ec <quorem+0x1cc>
 200c4d8:	18800017 	ldw	r2,0(r3)
 200c4dc:	1000031e 	bne	r2,zero,200c4ec <quorem+0x1cc>
 200c4e0:	18ffff04 	addi	r3,r3,-4
 200c4e4:	8c7fffc4 	addi	r17,r17,-1
 200c4e8:	a0fffb36 	bltu	r20,r3,200c4d8 <quorem+0x1b8>
 200c4ec:	ac400415 	stw	r17,16(r21)
 200c4f0:	9005883a 	mov	r2,r18
 200c4f4:	dfc00817 	ldw	ra,32(sp)
 200c4f8:	ddc00717 	ldw	r23,28(sp)
 200c4fc:	dd800617 	ldw	r22,24(sp)
 200c500:	dd400517 	ldw	r21,20(sp)
 200c504:	dd000417 	ldw	r20,16(sp)
 200c508:	dcc00317 	ldw	r19,12(sp)
 200c50c:	dc800217 	ldw	r18,8(sp)
 200c510:	dc400117 	ldw	r17,4(sp)
 200c514:	dc000017 	ldw	r16,0(sp)
 200c518:	dec00904 	addi	sp,sp,36
 200c51c:	f800283a 	ret
 200c520:	0005883a 	mov	r2,zero
 200c524:	003ff306 	br	200c4f4 <quorem+0x1d4>

0200c528 <_dtoa_r>:
 200c528:	20801017 	ldw	r2,64(r4)
 200c52c:	deffdf04 	addi	sp,sp,-132
 200c530:	dcc01a15 	stw	r19,104(sp)
 200c534:	dc801915 	stw	r18,100(sp)
 200c538:	dc401815 	stw	r17,96(sp)
 200c53c:	dc001715 	stw	r16,92(sp)
 200c540:	dfc02015 	stw	ra,128(sp)
 200c544:	df001f15 	stw	fp,124(sp)
 200c548:	ddc01e15 	stw	r23,120(sp)
 200c54c:	dd801d15 	stw	r22,116(sp)
 200c550:	dd401c15 	stw	r21,112(sp)
 200c554:	dd001b15 	stw	r20,108(sp)
 200c558:	d9400315 	stw	r5,12(sp)
 200c55c:	d9c00415 	stw	r7,16(sp)
 200c560:	2021883a 	mov	r16,r4
 200c564:	3025883a 	mov	r18,r6
 200c568:	dcc02317 	ldw	r19,140(sp)
 200c56c:	3023883a 	mov	r17,r6
 200c570:	10000826 	beq	r2,zero,200c594 <_dtoa_r+0x6c>
 200c574:	20c01117 	ldw	r3,68(r4)
 200c578:	01800044 	movi	r6,1
 200c57c:	100b883a 	mov	r5,r2
 200c580:	30cc983a 	sll	r6,r6,r3
 200c584:	10c00115 	stw	r3,4(r2)
 200c588:	11800215 	stw	r6,8(r2)
 200c58c:	200e6dc0 	call	200e6dc <_Bfree>
 200c590:	80001015 	stw	zero,64(r16)
 200c594:	90002f16 	blt	r18,zero,200c654 <_dtoa_r+0x12c>
 200c598:	98000015 	stw	zero,0(r19)
 200c59c:	90dffc2c 	andhi	r3,r18,32752
 200c5a0:	009ffc34 	movhi	r2,32752
 200c5a4:	18801c26 	beq	r3,r2,200c618 <_dtoa_r+0xf0>
 200c5a8:	d9000317 	ldw	r4,12(sp)
 200c5ac:	880b883a 	mov	r5,r17
 200c5b0:	000d883a 	mov	r6,zero
 200c5b4:	000f883a 	mov	r7,zero
 200c5b8:	20141200 	call	2014120 <__eqdf2>
 200c5bc:	10002c1e 	bne	r2,zero,200c670 <_dtoa_r+0x148>
 200c5c0:	d9002217 	ldw	r4,136(sp)
 200c5c4:	d9c02417 	ldw	r7,144(sp)
 200c5c8:	00800044 	movi	r2,1
 200c5cc:	20800015 	stw	r2,0(r4)
 200c5d0:	38019426 	beq	r7,zero,200cc24 <_dtoa_r+0x6fc>
 200c5d4:	00808174 	movhi	r2,517
 200c5d8:	10b79444 	addi	r2,r2,-8623
 200c5dc:	38800015 	stw	r2,0(r7)
 200c5e0:	15ffffc4 	addi	r23,r2,-1
 200c5e4:	b805883a 	mov	r2,r23
 200c5e8:	dfc02017 	ldw	ra,128(sp)
 200c5ec:	df001f17 	ldw	fp,124(sp)
 200c5f0:	ddc01e17 	ldw	r23,120(sp)
 200c5f4:	dd801d17 	ldw	r22,116(sp)
 200c5f8:	dd401c17 	ldw	r21,112(sp)
 200c5fc:	dd001b17 	ldw	r20,108(sp)
 200c600:	dcc01a17 	ldw	r19,104(sp)
 200c604:	dc801917 	ldw	r18,100(sp)
 200c608:	dc401817 	ldw	r17,96(sp)
 200c60c:	dc001717 	ldw	r16,92(sp)
 200c610:	dec02104 	addi	sp,sp,132
 200c614:	f800283a 	ret
 200c618:	d8c02217 	ldw	r3,136(sp)
 200c61c:	d9000317 	ldw	r4,12(sp)
 200c620:	0089c3c4 	movi	r2,9999
 200c624:	18800015 	stw	r2,0(r3)
 200c628:	20016c26 	beq	r4,zero,200cbdc <_dtoa_r+0x6b4>
 200c62c:	05c08174 	movhi	r23,517
 200c630:	bdf7aa04 	addi	r23,r23,-8536
 200c634:	d9c02417 	ldw	r7,144(sp)
 200c638:	383fea26 	beq	r7,zero,200c5e4 <_dtoa_r+0xbc>
 200c63c:	b88000c7 	ldb	r2,3(r23)
 200c640:	10016d1e 	bne	r2,zero,200cbf8 <_dtoa_r+0x6d0>
 200c644:	b88000c4 	addi	r2,r23,3
 200c648:	d8c02417 	ldw	r3,144(sp)
 200c64c:	18800015 	stw	r2,0(r3)
 200c650:	003fe406 	br	200c5e4 <_dtoa_r+0xbc>
 200c654:	04600034 	movhi	r17,32768
 200c658:	8c7fffc4 	addi	r17,r17,-1
 200c65c:	9462703a 	and	r17,r18,r17
 200c660:	00800044 	movi	r2,1
 200c664:	98800015 	stw	r2,0(r19)
 200c668:	8825883a 	mov	r18,r17
 200c66c:	003fcb06 	br	200c59c <_dtoa_r+0x74>
 200c670:	d9400317 	ldw	r5,12(sp)
 200c674:	9028d53a 	srli	r20,r18,20
 200c678:	d8800204 	addi	r2,sp,8
 200c67c:	d8800015 	stw	r2,0(sp)
 200c680:	8009883a 	mov	r4,r16
 200c684:	880d883a 	mov	r6,r17
 200c688:	d9c00104 	addi	r7,sp,4
 200c68c:	200f2800 	call	200f280 <__d2b>
 200c690:	a501ffcc 	andi	r20,r20,2047
 200c694:	1039883a 	mov	fp,r2
 200c698:	a001591e 	bne	r20,zero,200cc00 <_dtoa_r+0x6d8>
 200c69c:	dd400217 	ldw	r21,8(sp)
 200c6a0:	dd000117 	ldw	r20,4(sp)
 200c6a4:	00befbc4 	movi	r2,-1041
 200c6a8:	ad29883a 	add	r20,r21,r20
 200c6ac:	a082d216 	blt	r20,r2,200d1f8 <_dtoa_r+0xcd0>
 200c6b0:	d8c00317 	ldw	r3,12(sp)
 200c6b4:	013f0384 	movi	r4,-1010
 200c6b8:	2509c83a 	sub	r4,r4,r20
 200c6bc:	a0810484 	addi	r2,r20,1042
 200c6c0:	9124983a 	sll	r18,r18,r4
 200c6c4:	1884d83a 	srl	r2,r3,r2
 200c6c8:	9088b03a 	or	r4,r18,r2
 200c6cc:	20145600 	call	2014560 <__floatunsidf>
 200c6d0:	1009883a 	mov	r4,r2
 200c6d4:	017f8434 	movhi	r5,65040
 200c6d8:	00800044 	movi	r2,1
 200c6dc:	194b883a 	add	r5,r3,r5
 200c6e0:	a53fffc4 	addi	r20,r20,-1
 200c6e4:	d8800f15 	stw	r2,60(sp)
 200c6e8:	000d883a 	mov	r6,zero
 200c6ec:	01cffe34 	movhi	r7,16376
 200c6f0:	2013c280 	call	2013c28 <__subdf3>
 200c6f4:	1009883a 	mov	r4,r2
 200c6f8:	180b883a 	mov	r5,r3
 200c6fc:	0198dbf4 	movhi	r6,25455
 200c700:	3190d844 	addi	r6,r6,17249
 200c704:	01cff4f4 	movhi	r7,16339
 200c708:	39e1e9c4 	addi	r7,r7,-30809
 200c70c:	2013c880 	call	2013c88 <__muldf3>
 200c710:	180b883a 	mov	r5,r3
 200c714:	01a2d874 	movhi	r6,35681
 200c718:	31b22cc4 	addi	r6,r6,-14157
 200c71c:	01cff1f4 	movhi	r7,16327
 200c720:	39e28a04 	addi	r7,r7,-30168
 200c724:	1009883a 	mov	r4,r2
 200c728:	2013bd40 	call	2013bd4 <__adddf3>
 200c72c:	a009883a 	mov	r4,r20
 200c730:	1027883a 	mov	r19,r2
 200c734:	1825883a 	mov	r18,r3
 200c738:	20143580 	call	2014358 <__floatsidf>
 200c73c:	1009883a 	mov	r4,r2
 200c740:	180b883a 	mov	r5,r3
 200c744:	019427f4 	movhi	r6,20639
 200c748:	319e7ec4 	addi	r6,r6,31227
 200c74c:	01cff4f4 	movhi	r7,16339
 200c750:	39d104c4 	addi	r7,r7,17427
 200c754:	2013c880 	call	2013c88 <__muldf3>
 200c758:	9809883a 	mov	r4,r19
 200c75c:	900b883a 	mov	r5,r18
 200c760:	100d883a 	mov	r6,r2
 200c764:	180f883a 	mov	r7,r3
 200c768:	2013bd40 	call	2013bd4 <__adddf3>
 200c76c:	1009883a 	mov	r4,r2
 200c770:	180b883a 	mov	r5,r3
 200c774:	1027883a 	mov	r19,r2
 200c778:	1825883a 	mov	r18,r3
 200c77c:	201442c0 	call	201442c <__fixdfsi>
 200c780:	9809883a 	mov	r4,r19
 200c784:	900b883a 	mov	r5,r18
 200c788:	000d883a 	mov	r6,zero
 200c78c:	000f883a 	mov	r7,zero
 200c790:	d8800615 	stw	r2,24(sp)
 200c794:	20142a00 	call	20142a0 <__ltdf2>
 200c798:	10027e16 	blt	r2,zero,200d194 <_dtoa_r+0xc6c>
 200c79c:	d8c00617 	ldw	r3,24(sp)
 200c7a0:	00800584 	movi	r2,22
 200c7a4:	10c26c36 	bltu	r2,r3,200d158 <_dtoa_r+0xc30>
 200c7a8:	180490fa 	slli	r2,r3,3
 200c7ac:	00c08174 	movhi	r3,517
 200c7b0:	18f7cf04 	addi	r3,r3,-8388
 200c7b4:	d9800317 	ldw	r6,12(sp)
 200c7b8:	1885883a 	add	r2,r3,r2
 200c7bc:	11000017 	ldw	r4,0(r2)
 200c7c0:	11400117 	ldw	r5,4(r2)
 200c7c4:	880f883a 	mov	r7,r17
 200c7c8:	20141d80 	call	20141d8 <__gtdf2>
 200c7cc:	00828f0e 	bge	zero,r2,200d20c <_dtoa_r+0xce4>
 200c7d0:	d8800617 	ldw	r2,24(sp)
 200c7d4:	d8000d15 	stw	zero,52(sp)
 200c7d8:	10bfffc4 	addi	r2,r2,-1
 200c7dc:	d8800615 	stw	r2,24(sp)
 200c7e0:	ad29c83a 	sub	r20,r21,r20
 200c7e4:	a53fffc4 	addi	r20,r20,-1
 200c7e8:	a0026616 	blt	r20,zero,200d184 <_dtoa_r+0xc5c>
 200c7ec:	dd000715 	stw	r20,28(sp)
 200c7f0:	d8000815 	stw	zero,32(sp)
 200c7f4:	d8800617 	ldw	r2,24(sp)
 200c7f8:	10025a16 	blt	r2,zero,200d164 <_dtoa_r+0xc3c>
 200c7fc:	d8c00717 	ldw	r3,28(sp)
 200c800:	d8800b15 	stw	r2,44(sp)
 200c804:	d8000a15 	stw	zero,40(sp)
 200c808:	1887883a 	add	r3,r3,r2
 200c80c:	d8c00715 	stw	r3,28(sp)
 200c810:	d9c00417 	ldw	r7,16(sp)
 200c814:	00800244 	movi	r2,9
 200c818:	11c10536 	bltu	r2,r7,200cc30 <_dtoa_r+0x708>
 200c81c:	00800144 	movi	r2,5
 200c820:	11c4c60e 	bge	r2,r7,200db3c <_dtoa_r+0x1614>
 200c824:	39ffff04 	addi	r7,r7,-4
 200c828:	d9c00415 	stw	r7,16(sp)
 200c82c:	0027883a 	mov	r19,zero
 200c830:	d9c00417 	ldw	r7,16(sp)
 200c834:	008000c4 	movi	r2,3
 200c838:	3883a226 	beq	r7,r2,200d6c4 <_dtoa_r+0x119c>
 200c83c:	11c2bc16 	blt	r2,r7,200d330 <_dtoa_r+0xe08>
 200c840:	00800084 	movi	r2,2
 200c844:	3880fb1e 	bne	r7,r2,200cc34 <_dtoa_r+0x70c>
 200c848:	d8000c15 	stw	zero,48(sp)
 200c84c:	d9002117 	ldw	r4,132(sp)
 200c850:	0103ae0e 	bge	zero,r4,200d70c <_dtoa_r+0x11e4>
 200c854:	2025883a 	mov	r18,r4
 200c858:	d9000e15 	stw	r4,56(sp)
 200c85c:	d9000915 	stw	r4,36(sp)
 200c860:	80001115 	stw	zero,68(r16)
 200c864:	008005c4 	movi	r2,23
 200c868:	1484b22e 	bgeu	r2,r18,200db34 <_dtoa_r+0x160c>
 200c86c:	00c00044 	movi	r3,1
 200c870:	00800104 	movi	r2,4
 200c874:	1085883a 	add	r2,r2,r2
 200c878:	11000504 	addi	r4,r2,20
 200c87c:	180b883a 	mov	r5,r3
 200c880:	18c00044 	addi	r3,r3,1
 200c884:	913ffb2e 	bgeu	r18,r4,200c874 <_dtoa_r+0x34c>
 200c888:	81401115 	stw	r5,68(r16)
 200c88c:	8009883a 	mov	r4,r16
 200c890:	200e6340 	call	200e634 <_Balloc>
 200c894:	102f883a 	mov	r23,r2
 200c898:	80801015 	stw	r2,64(r16)
 200c89c:	00800384 	movi	r2,14
 200c8a0:	1480f036 	bltu	r2,r18,200cc64 <_dtoa_r+0x73c>
 200c8a4:	9800ef26 	beq	r19,zero,200cc64 <_dtoa_r+0x73c>
 200c8a8:	d8800617 	ldw	r2,24(sp)
 200c8ac:	00839c0e 	bge	zero,r2,200d720 <_dtoa_r+0x11f8>
 200c8b0:	d8c00617 	ldw	r3,24(sp)
 200c8b4:	108003cc 	andi	r2,r2,15
 200c8b8:	100490fa 	slli	r2,r2,3
 200c8bc:	182bd13a 	srai	r21,r3,4
 200c8c0:	00c08174 	movhi	r3,517
 200c8c4:	18f7cf04 	addi	r3,r3,-8388
 200c8c8:	1885883a 	add	r2,r3,r2
 200c8cc:	a8c0040c 	andi	r3,r21,16
 200c8d0:	12800017 	ldw	r10,0(r2)
 200c8d4:	15800117 	ldw	r22,4(r2)
 200c8d8:	18038726 	beq	r3,zero,200d6f8 <_dtoa_r+0x11d0>
 200c8dc:	00808174 	movhi	r2,517
 200c8e0:	10b7c504 	addi	r2,r2,-8428
 200c8e4:	11800817 	ldw	r6,32(r2)
 200c8e8:	11c00917 	ldw	r7,36(r2)
 200c8ec:	d9000317 	ldw	r4,12(sp)
 200c8f0:	880b883a 	mov	r5,r17
 200c8f4:	da801515 	stw	r10,84(sp)
 200c8f8:	2013f6c0 	call	2013f6c <__divdf3>
 200c8fc:	da801517 	ldw	r10,84(sp)
 200c900:	d8801015 	stw	r2,64(sp)
 200c904:	1829883a 	mov	r20,r3
 200c908:	ad4003cc 	andi	r21,r21,15
 200c90c:	048000c4 	movi	r18,3
 200c910:	a8001126 	beq	r21,zero,200c958 <_dtoa_r+0x430>
 200c914:	04c08174 	movhi	r19,517
 200c918:	9cf7c504 	addi	r19,r19,-8428
 200c91c:	5005883a 	mov	r2,r10
 200c920:	b007883a 	mov	r3,r22
 200c924:	a980004c 	andi	r6,r21,1
 200c928:	1009883a 	mov	r4,r2
 200c92c:	a82bd07a 	srai	r21,r21,1
 200c930:	180b883a 	mov	r5,r3
 200c934:	30000426 	beq	r6,zero,200c948 <_dtoa_r+0x420>
 200c938:	99800017 	ldw	r6,0(r19)
 200c93c:	99c00117 	ldw	r7,4(r19)
 200c940:	94800044 	addi	r18,r18,1
 200c944:	2013c880 	call	2013c88 <__muldf3>
 200c948:	9cc00204 	addi	r19,r19,8
 200c94c:	a83ff51e 	bne	r21,zero,200c924 <_dtoa_r+0x3fc>
 200c950:	1015883a 	mov	r10,r2
 200c954:	182d883a 	mov	r22,r3
 200c958:	d9001017 	ldw	r4,64(sp)
 200c95c:	a00b883a 	mov	r5,r20
 200c960:	500d883a 	mov	r6,r10
 200c964:	b00f883a 	mov	r7,r22
 200c968:	2013f6c0 	call	2013f6c <__divdf3>
 200c96c:	1027883a 	mov	r19,r2
 200c970:	1829883a 	mov	r20,r3
 200c974:	d8c00d17 	ldw	r3,52(sp)
 200c978:	18000626 	beq	r3,zero,200c994 <_dtoa_r+0x46c>
 200c97c:	9809883a 	mov	r4,r19
 200c980:	a00b883a 	mov	r5,r20
 200c984:	000d883a 	mov	r6,zero
 200c988:	01cffc34 	movhi	r7,16368
 200c98c:	20142a00 	call	20142a0 <__ltdf2>
 200c990:	10040e16 	blt	r2,zero,200d9cc <_dtoa_r+0x14a4>
 200c994:	9009883a 	mov	r4,r18
 200c998:	20143580 	call	2014358 <__floatsidf>
 200c99c:	1009883a 	mov	r4,r2
 200c9a0:	180b883a 	mov	r5,r3
 200c9a4:	980d883a 	mov	r6,r19
 200c9a8:	a00f883a 	mov	r7,r20
 200c9ac:	2013c880 	call	2013c88 <__muldf3>
 200c9b0:	1009883a 	mov	r4,r2
 200c9b4:	180b883a 	mov	r5,r3
 200c9b8:	000d883a 	mov	r6,zero
 200c9bc:	01d00734 	movhi	r7,16412
 200c9c0:	2013bd40 	call	2013bd4 <__adddf3>
 200c9c4:	057f3034 	movhi	r21,64704
 200c9c8:	1d6b883a 	add	r21,r3,r21
 200c9cc:	d8c00917 	ldw	r3,36(sp)
 200c9d0:	1025883a 	mov	r18,r2
 200c9d4:	18031f26 	beq	r3,zero,200d654 <_dtoa_r+0x112c>
 200c9d8:	d8800617 	ldw	r2,24(sp)
 200c9dc:	dac00917 	ldw	r11,36(sp)
 200c9e0:	d8801315 	stw	r2,76(sp)
 200c9e4:	d8c00c17 	ldw	r3,48(sp)
 200c9e8:	18039026 	beq	r3,zero,200d82c <_dtoa_r+0x1304>
 200c9ec:	58bfffc4 	addi	r2,r11,-1
 200c9f0:	100490fa 	slli	r2,r2,3
 200c9f4:	00c08174 	movhi	r3,517
 200c9f8:	18f7cf04 	addi	r3,r3,-8388
 200c9fc:	0009883a 	mov	r4,zero
 200ca00:	1885883a 	add	r2,r3,r2
 200ca04:	11800017 	ldw	r6,0(r2)
 200ca08:	11c00117 	ldw	r7,4(r2)
 200ca0c:	014ff834 	movhi	r5,16352
 200ca10:	dac01615 	stw	r11,88(sp)
 200ca14:	2013f6c0 	call	2013f6c <__divdf3>
 200ca18:	900d883a 	mov	r6,r18
 200ca1c:	a80f883a 	mov	r7,r21
 200ca20:	1009883a 	mov	r4,r2
 200ca24:	180b883a 	mov	r5,r3
 200ca28:	2013c280 	call	2013c28 <__subdf3>
 200ca2c:	a00b883a 	mov	r5,r20
 200ca30:	9809883a 	mov	r4,r19
 200ca34:	182b883a 	mov	r21,r3
 200ca38:	d8801015 	stw	r2,64(sp)
 200ca3c:	201442c0 	call	201442c <__fixdfsi>
 200ca40:	1009883a 	mov	r4,r2
 200ca44:	d8801515 	stw	r2,84(sp)
 200ca48:	20143580 	call	2014358 <__floatsidf>
 200ca4c:	9809883a 	mov	r4,r19
 200ca50:	a00b883a 	mov	r5,r20
 200ca54:	100d883a 	mov	r6,r2
 200ca58:	180f883a 	mov	r7,r3
 200ca5c:	2013c280 	call	2013c28 <__subdf3>
 200ca60:	da401517 	ldw	r9,84(sp)
 200ca64:	d9001017 	ldw	r4,64(sp)
 200ca68:	a80b883a 	mov	r5,r21
 200ca6c:	4d000c04 	addi	r20,r9,48
 200ca70:	bd000005 	stb	r20,0(r23)
 200ca74:	100d883a 	mov	r6,r2
 200ca78:	180f883a 	mov	r7,r3
 200ca7c:	bd800044 	addi	r22,r23,1
 200ca80:	1025883a 	mov	r18,r2
 200ca84:	1827883a 	mov	r19,r3
 200ca88:	20141d80 	call	20141d8 <__gtdf2>
 200ca8c:	00842216 	blt	zero,r2,200db18 <_dtoa_r+0x15f0>
 200ca90:	0009883a 	mov	r4,zero
 200ca94:	014ffc34 	movhi	r5,16368
 200ca98:	900d883a 	mov	r6,r18
 200ca9c:	980f883a 	mov	r7,r19
 200caa0:	2013c280 	call	2013c28 <__subdf3>
 200caa4:	d9001017 	ldw	r4,64(sp)
 200caa8:	a80b883a 	mov	r5,r21
 200caac:	100d883a 	mov	r6,r2
 200cab0:	180f883a 	mov	r7,r3
 200cab4:	20141d80 	call	20141d8 <__gtdf2>
 200cab8:	dac01617 	ldw	r11,88(sp)
 200cabc:	00841316 	blt	zero,r2,200db0c <_dtoa_r+0x15e4>
 200cac0:	00800044 	movi	r2,1
 200cac4:	12c0670e 	bge	r2,r11,200cc64 <_dtoa_r+0x73c>
 200cac8:	bad7883a 	add	r11,r23,r11
 200cacc:	df001115 	stw	fp,68(sp)
 200cad0:	dc401215 	stw	r17,72(sp)
 200cad4:	5839883a 	mov	fp,r11
 200cad8:	dc401017 	ldw	r17,64(sp)
 200cadc:	00000806 	br	200cb00 <_dtoa_r+0x5d8>
 200cae0:	2013c280 	call	2013c28 <__subdf3>
 200cae4:	1009883a 	mov	r4,r2
 200cae8:	180b883a 	mov	r5,r3
 200caec:	880d883a 	mov	r6,r17
 200caf0:	a80f883a 	mov	r7,r21
 200caf4:	20142a00 	call	20142a0 <__ltdf2>
 200caf8:	1003ee16 	blt	r2,zero,200dab4 <_dtoa_r+0x158c>
 200cafc:	b703f126 	beq	r22,fp,200dac4 <_dtoa_r+0x159c>
 200cb00:	8809883a 	mov	r4,r17
 200cb04:	a80b883a 	mov	r5,r21
 200cb08:	000d883a 	mov	r6,zero
 200cb0c:	01d00934 	movhi	r7,16420
 200cb10:	2013c880 	call	2013c88 <__muldf3>
 200cb14:	000d883a 	mov	r6,zero
 200cb18:	01d00934 	movhi	r7,16420
 200cb1c:	9009883a 	mov	r4,r18
 200cb20:	980b883a 	mov	r5,r19
 200cb24:	1023883a 	mov	r17,r2
 200cb28:	182b883a 	mov	r21,r3
 200cb2c:	2013c880 	call	2013c88 <__muldf3>
 200cb30:	180b883a 	mov	r5,r3
 200cb34:	1009883a 	mov	r4,r2
 200cb38:	1825883a 	mov	r18,r3
 200cb3c:	1027883a 	mov	r19,r2
 200cb40:	201442c0 	call	201442c <__fixdfsi>
 200cb44:	1009883a 	mov	r4,r2
 200cb48:	1029883a 	mov	r20,r2
 200cb4c:	20143580 	call	2014358 <__floatsidf>
 200cb50:	9809883a 	mov	r4,r19
 200cb54:	900b883a 	mov	r5,r18
 200cb58:	100d883a 	mov	r6,r2
 200cb5c:	180f883a 	mov	r7,r3
 200cb60:	2013c280 	call	2013c28 <__subdf3>
 200cb64:	a5000c04 	addi	r20,r20,48
 200cb68:	b5000005 	stb	r20,0(r22)
 200cb6c:	1009883a 	mov	r4,r2
 200cb70:	180b883a 	mov	r5,r3
 200cb74:	880d883a 	mov	r6,r17
 200cb78:	a80f883a 	mov	r7,r21
 200cb7c:	1025883a 	mov	r18,r2
 200cb80:	1827883a 	mov	r19,r3
 200cb84:	20142a00 	call	20142a0 <__ltdf2>
 200cb88:	b5800044 	addi	r22,r22,1
 200cb8c:	0009883a 	mov	r4,zero
 200cb90:	014ffc34 	movhi	r5,16368
 200cb94:	900d883a 	mov	r6,r18
 200cb98:	980f883a 	mov	r7,r19
 200cb9c:	103fd00e 	bge	r2,zero,200cae0 <_dtoa_r+0x5b8>
 200cba0:	d9001317 	ldw	r4,76(sp)
 200cba4:	df001117 	ldw	fp,68(sp)
 200cba8:	d9000615 	stw	r4,24(sp)
 200cbac:	8009883a 	mov	r4,r16
 200cbb0:	e00b883a 	mov	r5,fp
 200cbb4:	200e6dc0 	call	200e6dc <_Bfree>
 200cbb8:	d9c00617 	ldw	r7,24(sp)
 200cbbc:	d8c02217 	ldw	r3,136(sp)
 200cbc0:	d9002417 	ldw	r4,144(sp)
 200cbc4:	b0000005 	stb	zero,0(r22)
 200cbc8:	38800044 	addi	r2,r7,1
 200cbcc:	18800015 	stw	r2,0(r3)
 200cbd0:	203e8426 	beq	r4,zero,200c5e4 <_dtoa_r+0xbc>
 200cbd4:	25800015 	stw	r22,0(r4)
 200cbd8:	003e8206 	br	200c5e4 <_dtoa_r+0xbc>
 200cbdc:	00800434 	movhi	r2,16
 200cbe0:	10bfffc4 	addi	r2,r2,-1
 200cbe4:	90a4703a 	and	r18,r18,r2
 200cbe8:	903e901e 	bne	r18,zero,200c62c <_dtoa_r+0x104>
 200cbec:	05c08174 	movhi	r23,517
 200cbf0:	bdf7a704 	addi	r23,r23,-8548
 200cbf4:	003e8f06 	br	200c634 <_dtoa_r+0x10c>
 200cbf8:	b8800204 	addi	r2,r23,8
 200cbfc:	003e9206 	br	200c648 <_dtoa_r+0x120>
 200cc00:	01400434 	movhi	r5,16
 200cc04:	297fffc4 	addi	r5,r5,-1
 200cc08:	894a703a 	and	r5,r17,r5
 200cc0c:	d9000317 	ldw	r4,12(sp)
 200cc10:	294ffc34 	orhi	r5,r5,16368
 200cc14:	a53f0044 	addi	r20,r20,-1023
 200cc18:	dd400217 	ldw	r21,8(sp)
 200cc1c:	d8000f15 	stw	zero,60(sp)
 200cc20:	003eb106 	br	200c6e8 <_dtoa_r+0x1c0>
 200cc24:	05c08174 	movhi	r23,517
 200cc28:	bdf79404 	addi	r23,r23,-8624
 200cc2c:	003e6d06 	br	200c5e4 <_dtoa_r+0xbc>
 200cc30:	d8000415 	stw	zero,16(sp)
 200cc34:	80001115 	stw	zero,68(r16)
 200cc38:	8009883a 	mov	r4,r16
 200cc3c:	000b883a 	mov	r5,zero
 200cc40:	200e6340 	call	200e634 <_Balloc>
 200cc44:	01ffffc4 	movi	r7,-1
 200cc48:	102f883a 	mov	r23,r2
 200cc4c:	80801015 	stw	r2,64(r16)
 200cc50:	00800044 	movi	r2,1
 200cc54:	d9c00915 	stw	r7,36(sp)
 200cc58:	d8002115 	stw	zero,132(sp)
 200cc5c:	d9c00e15 	stw	r7,56(sp)
 200cc60:	d8800c15 	stw	r2,48(sp)
 200cc64:	d8800117 	ldw	r2,4(sp)
 200cc68:	10008b16 	blt	r2,zero,200ce98 <_dtoa_r+0x970>
 200cc6c:	d9000617 	ldw	r4,24(sp)
 200cc70:	00c00384 	movi	r3,14
 200cc74:	19008816 	blt	r3,r4,200ce98 <_dtoa_r+0x970>
 200cc78:	200490fa 	slli	r2,r4,3
 200cc7c:	d9c02117 	ldw	r7,132(sp)
 200cc80:	00c08174 	movhi	r3,517
 200cc84:	18f7cf04 	addi	r3,r3,-8388
 200cc88:	1885883a 	add	r2,r3,r2
 200cc8c:	14800017 	ldw	r18,0(r2)
 200cc90:	14c00117 	ldw	r19,4(r2)
 200cc94:	3801c916 	blt	r7,zero,200d3bc <_dtoa_r+0xe94>
 200cc98:	d9000317 	ldw	r4,12(sp)
 200cc9c:	900d883a 	mov	r6,r18
 200cca0:	980f883a 	mov	r7,r19
 200cca4:	880b883a 	mov	r5,r17
 200cca8:	2013f6c0 	call	2013f6c <__divdf3>
 200ccac:	180b883a 	mov	r5,r3
 200ccb0:	1009883a 	mov	r4,r2
 200ccb4:	201442c0 	call	201442c <__fixdfsi>
 200ccb8:	1009883a 	mov	r4,r2
 200ccbc:	102b883a 	mov	r21,r2
 200ccc0:	20143580 	call	2014358 <__floatsidf>
 200ccc4:	1009883a 	mov	r4,r2
 200ccc8:	180b883a 	mov	r5,r3
 200cccc:	900d883a 	mov	r6,r18
 200ccd0:	980f883a 	mov	r7,r19
 200ccd4:	2013c880 	call	2013c88 <__muldf3>
 200ccd8:	d9000317 	ldw	r4,12(sp)
 200ccdc:	880b883a 	mov	r5,r17
 200cce0:	100d883a 	mov	r6,r2
 200cce4:	180f883a 	mov	r7,r3
 200cce8:	2013c280 	call	2013c28 <__subdf3>
 200ccec:	d9c00917 	ldw	r7,36(sp)
 200ccf0:	1009883a 	mov	r4,r2
 200ccf4:	a8800c04 	addi	r2,r21,48
 200ccf8:	b8800005 	stb	r2,0(r23)
 200ccfc:	01800044 	movi	r6,1
 200cd00:	180b883a 	mov	r5,r3
 200cd04:	2005883a 	mov	r2,r4
 200cd08:	bd800044 	addi	r22,r23,1
 200cd0c:	39803726 	beq	r7,r6,200cdec <_dtoa_r+0x8c4>
 200cd10:	000d883a 	mov	r6,zero
 200cd14:	01d00934 	movhi	r7,16420
 200cd18:	2013c880 	call	2013c88 <__muldf3>
 200cd1c:	1009883a 	mov	r4,r2
 200cd20:	180b883a 	mov	r5,r3
 200cd24:	000d883a 	mov	r6,zero
 200cd28:	000f883a 	mov	r7,zero
 200cd2c:	1029883a 	mov	r20,r2
 200cd30:	1823883a 	mov	r17,r3
 200cd34:	20141200 	call	2014120 <__eqdf2>
 200cd38:	103f9c26 	beq	r2,zero,200cbac <_dtoa_r+0x684>
 200cd3c:	dd400917 	ldw	r21,36(sp)
 200cd40:	dc000415 	stw	r16,16(sp)
 200cd44:	00000906 	br	200cd6c <_dtoa_r+0x844>
 200cd48:	2013c880 	call	2013c88 <__muldf3>
 200cd4c:	1009883a 	mov	r4,r2
 200cd50:	180b883a 	mov	r5,r3
 200cd54:	000d883a 	mov	r6,zero
 200cd58:	000f883a 	mov	r7,zero
 200cd5c:	1029883a 	mov	r20,r2
 200cd60:	1823883a 	mov	r17,r3
 200cd64:	20141200 	call	2014120 <__eqdf2>
 200cd68:	10022926 	beq	r2,zero,200d610 <_dtoa_r+0x10e8>
 200cd6c:	900d883a 	mov	r6,r18
 200cd70:	980f883a 	mov	r7,r19
 200cd74:	a009883a 	mov	r4,r20
 200cd78:	880b883a 	mov	r5,r17
 200cd7c:	2013f6c0 	call	2013f6c <__divdf3>
 200cd80:	180b883a 	mov	r5,r3
 200cd84:	1009883a 	mov	r4,r2
 200cd88:	201442c0 	call	201442c <__fixdfsi>
 200cd8c:	1009883a 	mov	r4,r2
 200cd90:	1021883a 	mov	r16,r2
 200cd94:	20143580 	call	2014358 <__floatsidf>
 200cd98:	1009883a 	mov	r4,r2
 200cd9c:	180b883a 	mov	r5,r3
 200cda0:	900d883a 	mov	r6,r18
 200cda4:	980f883a 	mov	r7,r19
 200cda8:	2013c880 	call	2013c88 <__muldf3>
 200cdac:	a009883a 	mov	r4,r20
 200cdb0:	880b883a 	mov	r5,r17
 200cdb4:	100d883a 	mov	r6,r2
 200cdb8:	180f883a 	mov	r7,r3
 200cdbc:	2013c280 	call	2013c28 <__subdf3>
 200cdc0:	82400c04 	addi	r9,r16,48
 200cdc4:	b2400005 	stb	r9,0(r22)
 200cdc8:	b5800044 	addi	r22,r22,1
 200cdcc:	b5d3c83a 	sub	r9,r22,r23
 200cdd0:	000d883a 	mov	r6,zero
 200cdd4:	01d00934 	movhi	r7,16420
 200cdd8:	1009883a 	mov	r4,r2
 200cddc:	180b883a 	mov	r5,r3
 200cde0:	aa7fd91e 	bne	r21,r9,200cd48 <_dtoa_r+0x820>
 200cde4:	802b883a 	mov	r21,r16
 200cde8:	dc000417 	ldw	r16,16(sp)
 200cdec:	1009883a 	mov	r4,r2
 200cdf0:	180b883a 	mov	r5,r3
 200cdf4:	100d883a 	mov	r6,r2
 200cdf8:	180f883a 	mov	r7,r3
 200cdfc:	2013bd40 	call	2013bd4 <__adddf3>
 200ce00:	9009883a 	mov	r4,r18
 200ce04:	980b883a 	mov	r5,r19
 200ce08:	100d883a 	mov	r6,r2
 200ce0c:	180f883a 	mov	r7,r3
 200ce10:	1023883a 	mov	r17,r2
 200ce14:	1829883a 	mov	r20,r3
 200ce18:	20142a00 	call	20142a0 <__ltdf2>
 200ce1c:	10000816 	blt	r2,zero,200ce40 <_dtoa_r+0x918>
 200ce20:	9009883a 	mov	r4,r18
 200ce24:	980b883a 	mov	r5,r19
 200ce28:	880d883a 	mov	r6,r17
 200ce2c:	a00f883a 	mov	r7,r20
 200ce30:	20141200 	call	2014120 <__eqdf2>
 200ce34:	103f5d1e 	bne	r2,zero,200cbac <_dtoa_r+0x684>
 200ce38:	ad40004c 	andi	r21,r21,1
 200ce3c:	a83f5b26 	beq	r21,zero,200cbac <_dtoa_r+0x684>
 200ce40:	b53fffc3 	ldbu	r20,-1(r22)
 200ce44:	b0ffff84 	addi	r3,r22,-2
 200ce48:	01400e44 	movi	r5,57
 200ce4c:	00000306 	br	200ce5c <_dtoa_r+0x934>
 200ce50:	1d000003 	ldbu	r20,0(r3)
 200ce54:	102d883a 	mov	r22,r2
 200ce58:	18ffffc4 	addi	r3,r3,-1
 200ce5c:	a1003fcc 	andi	r4,r20,255
 200ce60:	2100201c 	xori	r4,r4,128
 200ce64:	213fe004 	addi	r4,r4,-128
 200ce68:	b0bfffc4 	addi	r2,r22,-1
 200ce6c:	2142ca1e 	bne	r4,r5,200d998 <_dtoa_r+0x1470>
 200ce70:	b8bff71e 	bne	r23,r2,200ce50 <_dtoa_r+0x928>
 200ce74:	d8800617 	ldw	r2,24(sp)
 200ce78:	05000c44 	movi	r20,49
 200ce7c:	10800044 	addi	r2,r2,1
 200ce80:	d8800615 	stw	r2,24(sp)
 200ce84:	00800c04 	movi	r2,48
 200ce88:	b8800005 	stb	r2,0(r23)
 200ce8c:	b805883a 	mov	r2,r23
 200ce90:	15000005 	stb	r20,0(r2)
 200ce94:	003f4506 	br	200cbac <_dtoa_r+0x684>
 200ce98:	d9c00c17 	ldw	r7,48(sp)
 200ce9c:	3800c926 	beq	r7,zero,200d1c4 <_dtoa_r+0xc9c>
 200cea0:	d9c00417 	ldw	r7,16(sp)
 200cea4:	00c00044 	movi	r3,1
 200cea8:	19c16c0e 	bge	r3,r7,200d45c <_dtoa_r+0xf34>
 200ceac:	d9000917 	ldw	r4,36(sp)
 200ceb0:	d9c00a17 	ldw	r7,40(sp)
 200ceb4:	24ffffc4 	addi	r19,r4,-1
 200ceb8:	3cc20716 	blt	r7,r19,200d6d8 <_dtoa_r+0x11b0>
 200cebc:	3ce7c83a 	sub	r19,r7,r19
 200cec0:	d9c00917 	ldw	r7,36(sp)
 200cec4:	3802ae16 	blt	r7,zero,200d980 <_dtoa_r+0x1458>
 200cec8:	dc800817 	ldw	r18,32(sp)
 200cecc:	d8800917 	ldw	r2,36(sp)
 200ced0:	d8c00817 	ldw	r3,32(sp)
 200ced4:	d9c00717 	ldw	r7,28(sp)
 200ced8:	8009883a 	mov	r4,r16
 200cedc:	1887883a 	add	r3,r3,r2
 200cee0:	388f883a 	add	r7,r7,r2
 200cee4:	01400044 	movi	r5,1
 200cee8:	d8c00815 	stw	r3,32(sp)
 200ceec:	d9c00715 	stw	r7,28(sp)
 200cef0:	200ea340 	call	200ea34 <__i2b>
 200cef4:	102b883a 	mov	r21,r2
 200cef8:	90000a26 	beq	r18,zero,200cf24 <_dtoa_r+0x9fc>
 200cefc:	d8800717 	ldw	r2,28(sp)
 200cf00:	0080080e 	bge	zero,r2,200cf24 <_dtoa_r+0x9fc>
 200cf04:	90812b16 	blt	r18,r2,200d3b4 <_dtoa_r+0xe8c>
 200cf08:	d8c00817 	ldw	r3,32(sp)
 200cf0c:	d9000717 	ldw	r4,28(sp)
 200cf10:	90a5c83a 	sub	r18,r18,r2
 200cf14:	1887c83a 	sub	r3,r3,r2
 200cf18:	2089c83a 	sub	r4,r4,r2
 200cf1c:	d8c00815 	stw	r3,32(sp)
 200cf20:	d9000715 	stw	r4,28(sp)
 200cf24:	d9c00a17 	ldw	r7,40(sp)
 200cf28:	01c0140e 	bge	zero,r7,200cf7c <_dtoa_r+0xa54>
 200cf2c:	d8800c17 	ldw	r2,48(sp)
 200cf30:	1001de26 	beq	r2,zero,200d6ac <_dtoa_r+0x1184>
 200cf34:	04c00e0e 	bge	zero,r19,200cf70 <_dtoa_r+0xa48>
 200cf38:	a80b883a 	mov	r5,r21
 200cf3c:	8009883a 	mov	r4,r16
 200cf40:	980d883a 	mov	r6,r19
 200cf44:	200ec500 	call	200ec50 <__pow5mult>
 200cf48:	e00d883a 	mov	r6,fp
 200cf4c:	8009883a 	mov	r4,r16
 200cf50:	100b883a 	mov	r5,r2
 200cf54:	102b883a 	mov	r21,r2
 200cf58:	200ea700 	call	200ea70 <__multiply>
 200cf5c:	1029883a 	mov	r20,r2
 200cf60:	e00b883a 	mov	r5,fp
 200cf64:	8009883a 	mov	r4,r16
 200cf68:	200e6dc0 	call	200e6dc <_Bfree>
 200cf6c:	a039883a 	mov	fp,r20
 200cf70:	d8c00a17 	ldw	r3,40(sp)
 200cf74:	1ccdc83a 	sub	r6,r3,r19
 200cf78:	3001291e 	bne	r6,zero,200d420 <_dtoa_r+0xef8>
 200cf7c:	8009883a 	mov	r4,r16
 200cf80:	01400044 	movi	r5,1
 200cf84:	200ea340 	call	200ea34 <__i2b>
 200cf88:	d9000b17 	ldw	r4,44(sp)
 200cf8c:	1029883a 	mov	r20,r2
 200cf90:	0100050e 	bge	zero,r4,200cfa8 <_dtoa_r+0xa80>
 200cf94:	d9800b17 	ldw	r6,44(sp)
 200cf98:	8009883a 	mov	r4,r16
 200cf9c:	100b883a 	mov	r5,r2
 200cfa0:	200ec500 	call	200ec50 <__pow5mult>
 200cfa4:	1029883a 	mov	r20,r2
 200cfa8:	d9c00417 	ldw	r7,16(sp)
 200cfac:	00800044 	movi	r2,1
 200cfb0:	11c0f00e 	bge	r2,r7,200d374 <_dtoa_r+0xe4c>
 200cfb4:	0023883a 	mov	r17,zero
 200cfb8:	d8800b17 	ldw	r2,44(sp)
 200cfbc:	1001741e 	bne	r2,zero,200d590 <_dtoa_r+0x1068>
 200cfc0:	00800044 	movi	r2,1
 200cfc4:	d8c00717 	ldw	r3,28(sp)
 200cfc8:	10c5883a 	add	r2,r2,r3
 200cfcc:	108007cc 	andi	r2,r2,31
 200cfd0:	10008026 	beq	r2,zero,200d1d4 <_dtoa_r+0xcac>
 200cfd4:	01000804 	movi	r4,32
 200cfd8:	2089c83a 	sub	r4,r4,r2
 200cfdc:	00c00104 	movi	r3,4
 200cfe0:	1902d00e 	bge	r3,r4,200db24 <_dtoa_r+0x15fc>
 200cfe4:	d9000817 	ldw	r4,32(sp)
 200cfe8:	d9c00717 	ldw	r7,28(sp)
 200cfec:	00c00704 	movi	r3,28
 200cff0:	1885c83a 	sub	r2,r3,r2
 200cff4:	2089883a 	add	r4,r4,r2
 200cff8:	388f883a 	add	r7,r7,r2
 200cffc:	d9000815 	stw	r4,32(sp)
 200d000:	90a5883a 	add	r18,r18,r2
 200d004:	d9c00715 	stw	r7,28(sp)
 200d008:	d9c00817 	ldw	r7,32(sp)
 200d00c:	01c0050e 	bge	zero,r7,200d024 <_dtoa_r+0xafc>
 200d010:	e00b883a 	mov	r5,fp
 200d014:	8009883a 	mov	r4,r16
 200d018:	380d883a 	mov	r6,r7
 200d01c:	200ed7c0 	call	200ed7c <__lshift>
 200d020:	1039883a 	mov	fp,r2
 200d024:	d8800717 	ldw	r2,28(sp)
 200d028:	0080050e 	bge	zero,r2,200d040 <_dtoa_r+0xb18>
 200d02c:	a00b883a 	mov	r5,r20
 200d030:	8009883a 	mov	r4,r16
 200d034:	100d883a 	mov	r6,r2
 200d038:	200ed7c0 	call	200ed7c <__lshift>
 200d03c:	1029883a 	mov	r20,r2
 200d040:	d8c00d17 	ldw	r3,52(sp)
 200d044:	1801401e 	bne	r3,zero,200d548 <_dtoa_r+0x1020>
 200d048:	d8800917 	ldw	r2,36(sp)
 200d04c:	00815a0e 	bge	zero,r2,200d5b8 <_dtoa_r+0x1090>
 200d050:	d8c00c17 	ldw	r3,48(sp)
 200d054:	18006f1e 	bne	r3,zero,200d214 <_dtoa_r+0xcec>
 200d058:	b823883a 	mov	r17,r23
 200d05c:	dc800917 	ldw	r18,36(sp)
 200d060:	00000206 	br	200d06c <_dtoa_r+0xb44>
 200d064:	200e7040 	call	200e704 <__multadd>
 200d068:	1039883a 	mov	fp,r2
 200d06c:	e009883a 	mov	r4,fp
 200d070:	a00b883a 	mov	r5,r20
 200d074:	200c3200 	call	200c320 <quorem>
 200d078:	10800c04 	addi	r2,r2,48
 200d07c:	88800005 	stb	r2,0(r17)
 200d080:	8c400044 	addi	r17,r17,1
 200d084:	8dc7c83a 	sub	r3,r17,r23
 200d088:	8009883a 	mov	r4,r16
 200d08c:	e00b883a 	mov	r5,fp
 200d090:	01800284 	movi	r6,10
 200d094:	000f883a 	mov	r7,zero
 200d098:	1cbff216 	blt	r3,r18,200d064 <_dtoa_r+0xb3c>
 200d09c:	dd800917 	ldw	r22,36(sp)
 200d0a0:	1007883a 	mov	r3,r2
 200d0a4:	05823a0e 	bge	zero,r22,200d990 <_dtoa_r+0x1468>
 200d0a8:	bdad883a 	add	r22,r23,r22
 200d0ac:	0023883a 	mov	r17,zero
 200d0b0:	e00b883a 	mov	r5,fp
 200d0b4:	01800044 	movi	r6,1
 200d0b8:	8009883a 	mov	r4,r16
 200d0bc:	d8c01515 	stw	r3,84(sp)
 200d0c0:	200ed7c0 	call	200ed7c <__lshift>
 200d0c4:	1009883a 	mov	r4,r2
 200d0c8:	a00b883a 	mov	r5,r20
 200d0cc:	1039883a 	mov	fp,r2
 200d0d0:	200eed80 	call	200eed8 <__mcmp>
 200d0d4:	d8c01517 	ldw	r3,84(sp)
 200d0d8:	0080d60e 	bge	zero,r2,200d434 <_dtoa_r+0xf0c>
 200d0dc:	b13fffc3 	ldbu	r4,-1(r22)
 200d0e0:	b0ffff84 	addi	r3,r22,-2
 200d0e4:	01800e44 	movi	r6,57
 200d0e8:	00000306 	br	200d0f8 <_dtoa_r+0xbd0>
 200d0ec:	19000003 	ldbu	r4,0(r3)
 200d0f0:	102d883a 	mov	r22,r2
 200d0f4:	18ffffc4 	addi	r3,r3,-1
 200d0f8:	21403fcc 	andi	r5,r4,255
 200d0fc:	2940201c 	xori	r5,r5,128
 200d100:	297fe004 	addi	r5,r5,-128
 200d104:	b0bfffc4 	addi	r2,r22,-1
 200d108:	2981a71e 	bne	r5,r6,200d7a8 <_dtoa_r+0x1280>
 200d10c:	b8bff71e 	bne	r23,r2,200d0ec <_dtoa_r+0xbc4>
 200d110:	d8800617 	ldw	r2,24(sp)
 200d114:	10800044 	addi	r2,r2,1
 200d118:	d8800615 	stw	r2,24(sp)
 200d11c:	00800c44 	movi	r2,49
 200d120:	b8800005 	stb	r2,0(r23)
 200d124:	8009883a 	mov	r4,r16
 200d128:	a00b883a 	mov	r5,r20
 200d12c:	200e6dc0 	call	200e6dc <_Bfree>
 200d130:	a83e9e26 	beq	r21,zero,200cbac <_dtoa_r+0x684>
 200d134:	88000426 	beq	r17,zero,200d148 <_dtoa_r+0xc20>
 200d138:	8d400326 	beq	r17,r21,200d148 <_dtoa_r+0xc20>
 200d13c:	8009883a 	mov	r4,r16
 200d140:	880b883a 	mov	r5,r17
 200d144:	200e6dc0 	call	200e6dc <_Bfree>
 200d148:	8009883a 	mov	r4,r16
 200d14c:	a80b883a 	mov	r5,r21
 200d150:	200e6dc0 	call	200e6dc <_Bfree>
 200d154:	003e9506 	br	200cbac <_dtoa_r+0x684>
 200d158:	00c00044 	movi	r3,1
 200d15c:	d8c00d15 	stw	r3,52(sp)
 200d160:	003d9f06 	br	200c7e0 <_dtoa_r+0x2b8>
 200d164:	d9000817 	ldw	r4,32(sp)
 200d168:	d8800617 	ldw	r2,24(sp)
 200d16c:	d8000b15 	stw	zero,44(sp)
 200d170:	2089c83a 	sub	r4,r4,r2
 200d174:	0087c83a 	sub	r3,zero,r2
 200d178:	d9000815 	stw	r4,32(sp)
 200d17c:	d8c00a15 	stw	r3,40(sp)
 200d180:	003da306 	br	200c810 <_dtoa_r+0x2e8>
 200d184:	0529c83a 	sub	r20,zero,r20
 200d188:	dd000815 	stw	r20,32(sp)
 200d18c:	d8000715 	stw	zero,28(sp)
 200d190:	003d9806 	br	200c7f4 <_dtoa_r+0x2cc>
 200d194:	d9000617 	ldw	r4,24(sp)
 200d198:	20143580 	call	2014358 <__floatsidf>
 200d19c:	1009883a 	mov	r4,r2
 200d1a0:	180b883a 	mov	r5,r3
 200d1a4:	980d883a 	mov	r6,r19
 200d1a8:	900f883a 	mov	r7,r18
 200d1ac:	201417c0 	call	201417c <__nedf2>
 200d1b0:	103d7a26 	beq	r2,zero,200c79c <_dtoa_r+0x274>
 200d1b4:	d8800617 	ldw	r2,24(sp)
 200d1b8:	10bfffc4 	addi	r2,r2,-1
 200d1bc:	d8800615 	stw	r2,24(sp)
 200d1c0:	003d7606 	br	200c79c <_dtoa_r+0x274>
 200d1c4:	dcc00a17 	ldw	r19,40(sp)
 200d1c8:	dc800817 	ldw	r18,32(sp)
 200d1cc:	002b883a 	mov	r21,zero
 200d1d0:	003f4906 	br	200cef8 <_dtoa_r+0x9d0>
 200d1d4:	00800704 	movi	r2,28
 200d1d8:	d8c00817 	ldw	r3,32(sp)
 200d1dc:	d9000717 	ldw	r4,28(sp)
 200d1e0:	90a5883a 	add	r18,r18,r2
 200d1e4:	1887883a 	add	r3,r3,r2
 200d1e8:	2089883a 	add	r4,r4,r2
 200d1ec:	d8c00815 	stw	r3,32(sp)
 200d1f0:	d9000715 	stw	r4,28(sp)
 200d1f4:	003f8406 	br	200d008 <_dtoa_r+0xae0>
 200d1f8:	d9c00317 	ldw	r7,12(sp)
 200d1fc:	013efb84 	movi	r4,-1042
 200d200:	2509c83a 	sub	r4,r4,r20
 200d204:	3908983a 	sll	r4,r7,r4
 200d208:	003d3006 	br	200c6cc <_dtoa_r+0x1a4>
 200d20c:	d8000d15 	stw	zero,52(sp)
 200d210:	003d7306 	br	200c7e0 <_dtoa_r+0x2b8>
 200d214:	0480050e 	bge	zero,r18,200d22c <_dtoa_r+0xd04>
 200d218:	a80b883a 	mov	r5,r21
 200d21c:	8009883a 	mov	r4,r16
 200d220:	900d883a 	mov	r6,r18
 200d224:	200ed7c0 	call	200ed7c <__lshift>
 200d228:	102b883a 	mov	r21,r2
 200d22c:	8801611e 	bne	r17,zero,200d7b4 <_dtoa_r+0x128c>
 200d230:	a827883a 	mov	r19,r21
 200d234:	d8c00317 	ldw	r3,12(sp)
 200d238:	d9000917 	ldw	r4,36(sp)
 200d23c:	b8bfffc4 	addi	r2,r23,-1
 200d240:	18c0004c 	andi	r3,r3,1
 200d244:	1105883a 	add	r2,r2,r4
 200d248:	b825883a 	mov	r18,r23
 200d24c:	d8800515 	stw	r2,20(sp)
 200d250:	a823883a 	mov	r17,r21
 200d254:	d8c00315 	stw	r3,12(sp)
 200d258:	ddc00715 	stw	r23,28(sp)
 200d25c:	e009883a 	mov	r4,fp
 200d260:	a00b883a 	mov	r5,r20
 200d264:	200c3200 	call	200c320 <quorem>
 200d268:	e009883a 	mov	r4,fp
 200d26c:	880b883a 	mov	r5,r17
 200d270:	102d883a 	mov	r22,r2
 200d274:	200eed80 	call	200eed8 <__mcmp>
 200d278:	980d883a 	mov	r6,r19
 200d27c:	8009883a 	mov	r4,r16
 200d280:	a00b883a 	mov	r5,r20
 200d284:	102b883a 	mov	r21,r2
 200d288:	200ef300 	call	200ef30 <__mdiff>
 200d28c:	100d883a 	mov	r6,r2
 200d290:	10800317 	ldw	r2,12(r2)
 200d294:	b5c00c04 	addi	r23,r22,48
 200d298:	10008c26 	beq	r2,zero,200d4cc <_dtoa_r+0xfa4>
 200d29c:	8009883a 	mov	r4,r16
 200d2a0:	300b883a 	mov	r5,r6
 200d2a4:	200e6dc0 	call	200e6dc <_Bfree>
 200d2a8:	00800044 	movi	r2,1
 200d2ac:	a8007116 	blt	r21,zero,200d474 <_dtoa_r+0xf4c>
 200d2b0:	a800041e 	bne	r21,zero,200d2c4 <_dtoa_r+0xd9c>
 200d2b4:	d9c00417 	ldw	r7,16(sp)
 200d2b8:	3800021e 	bne	r7,zero,200d2c4 <_dtoa_r+0xd9c>
 200d2bc:	d8c00317 	ldw	r3,12(sp)
 200d2c0:	18006c26 	beq	r3,zero,200d474 <_dtoa_r+0xf4c>
 200d2c4:	00814c16 	blt	zero,r2,200d7f8 <_dtoa_r+0x12d0>
 200d2c8:	d8c00517 	ldw	r3,20(sp)
 200d2cc:	95400044 	addi	r21,r18,1
 200d2d0:	95c00005 	stb	r23,0(r18)
 200d2d4:	a82d883a 	mov	r22,r21
 200d2d8:	90c14d26 	beq	r18,r3,200d810 <_dtoa_r+0x12e8>
 200d2dc:	e00b883a 	mov	r5,fp
 200d2e0:	8009883a 	mov	r4,r16
 200d2e4:	01800284 	movi	r6,10
 200d2e8:	000f883a 	mov	r7,zero
 200d2ec:	200e7040 	call	200e704 <__multadd>
 200d2f0:	1039883a 	mov	fp,r2
 200d2f4:	8cc08b26 	beq	r17,r19,200d524 <_dtoa_r+0xffc>
 200d2f8:	880b883a 	mov	r5,r17
 200d2fc:	01800284 	movi	r6,10
 200d300:	000f883a 	mov	r7,zero
 200d304:	8009883a 	mov	r4,r16
 200d308:	200e7040 	call	200e704 <__multadd>
 200d30c:	980b883a 	mov	r5,r19
 200d310:	8009883a 	mov	r4,r16
 200d314:	01800284 	movi	r6,10
 200d318:	000f883a 	mov	r7,zero
 200d31c:	1023883a 	mov	r17,r2
 200d320:	200e7040 	call	200e704 <__multadd>
 200d324:	1027883a 	mov	r19,r2
 200d328:	a825883a 	mov	r18,r21
 200d32c:	003fcb06 	br	200d25c <_dtoa_r+0xd34>
 200d330:	d9c00417 	ldw	r7,16(sp)
 200d334:	00800104 	movi	r2,4
 200d338:	3880e426 	beq	r7,r2,200d6cc <_dtoa_r+0x11a4>
 200d33c:	00800144 	movi	r2,5
 200d340:	38be3c1e 	bne	r7,r2,200cc34 <_dtoa_r+0x70c>
 200d344:	00c00044 	movi	r3,1
 200d348:	d8c00c15 	stw	r3,48(sp)
 200d34c:	d9c02117 	ldw	r7,132(sp)
 200d350:	d8800617 	ldw	r2,24(sp)
 200d354:	388f883a 	add	r7,r7,r2
 200d358:	3c800044 	addi	r18,r7,1
 200d35c:	d9c00e15 	stw	r7,56(sp)
 200d360:	dc800915 	stw	r18,36(sp)
 200d364:	04bd3e16 	blt	zero,r18,200c860 <_dtoa_r+0x338>
 200d368:	80001115 	stw	zero,68(r16)
 200d36c:	000b883a 	mov	r5,zero
 200d370:	003d4606 	br	200c88c <_dtoa_r+0x364>
 200d374:	d8c00317 	ldw	r3,12(sp)
 200d378:	183f0e1e 	bne	r3,zero,200cfb4 <_dtoa_r+0xa8c>
 200d37c:	00c00434 	movhi	r3,16
 200d380:	18ffffc4 	addi	r3,r3,-1
 200d384:	88c6703a 	and	r3,r17,r3
 200d388:	183f0a1e 	bne	r3,zero,200cfb4 <_dtoa_r+0xa8c>
 200d38c:	8c5ffc2c 	andhi	r17,r17,32752
 200d390:	883f0826 	beq	r17,zero,200cfb4 <_dtoa_r+0xa8c>
 200d394:	d9000817 	ldw	r4,32(sp)
 200d398:	d9c00717 	ldw	r7,28(sp)
 200d39c:	1023883a 	mov	r17,r2
 200d3a0:	2089883a 	add	r4,r4,r2
 200d3a4:	388f883a 	add	r7,r7,r2
 200d3a8:	d9000815 	stw	r4,32(sp)
 200d3ac:	d9c00715 	stw	r7,28(sp)
 200d3b0:	003f0106 	br	200cfb8 <_dtoa_r+0xa90>
 200d3b4:	9005883a 	mov	r2,r18
 200d3b8:	003ed306 	br	200cf08 <_dtoa_r+0x9e0>
 200d3bc:	d8800917 	ldw	r2,36(sp)
 200d3c0:	00be3516 	blt	zero,r2,200cc98 <_dtoa_r+0x770>
 200d3c4:	1000b61e 	bne	r2,zero,200d6a0 <_dtoa_r+0x1178>
 200d3c8:	9009883a 	mov	r4,r18
 200d3cc:	980b883a 	mov	r5,r19
 200d3d0:	000d883a 	mov	r6,zero
 200d3d4:	01d00534 	movhi	r7,16404
 200d3d8:	2013c880 	call	2013c88 <__muldf3>
 200d3dc:	d9800317 	ldw	r6,12(sp)
 200d3e0:	1009883a 	mov	r4,r2
 200d3e4:	180b883a 	mov	r5,r3
 200d3e8:	880f883a 	mov	r7,r17
 200d3ec:	201423c0 	call	201423c <__gedf2>
 200d3f0:	0029883a 	mov	r20,zero
 200d3f4:	002b883a 	mov	r21,zero
 200d3f8:	10007e16 	blt	r2,zero,200d5f4 <_dtoa_r+0x10cc>
 200d3fc:	d8802117 	ldw	r2,132(sp)
 200d400:	b82d883a 	mov	r22,r23
 200d404:	0084303a 	nor	r2,zero,r2
 200d408:	d8800615 	stw	r2,24(sp)
 200d40c:	8009883a 	mov	r4,r16
 200d410:	a00b883a 	mov	r5,r20
 200d414:	200e6dc0 	call	200e6dc <_Bfree>
 200d418:	a83f4b1e 	bne	r21,zero,200d148 <_dtoa_r+0xc20>
 200d41c:	003de306 	br	200cbac <_dtoa_r+0x684>
 200d420:	e00b883a 	mov	r5,fp
 200d424:	8009883a 	mov	r4,r16
 200d428:	200ec500 	call	200ec50 <__pow5mult>
 200d42c:	1039883a 	mov	fp,r2
 200d430:	003ed206 	br	200cf7c <_dtoa_r+0xa54>
 200d434:	1000021e 	bne	r2,zero,200d440 <_dtoa_r+0xf18>
 200d438:	18c0004c 	andi	r3,r3,1
 200d43c:	183f271e 	bne	r3,zero,200d0dc <_dtoa_r+0xbb4>
 200d440:	01000c04 	movi	r4,48
 200d444:	00000106 	br	200d44c <_dtoa_r+0xf24>
 200d448:	102d883a 	mov	r22,r2
 200d44c:	b0bfffc4 	addi	r2,r22,-1
 200d450:	10c00007 	ldb	r3,0(r2)
 200d454:	193ffc26 	beq	r3,r4,200d448 <_dtoa_r+0xf20>
 200d458:	003f3206 	br	200d124 <_dtoa_r+0xbfc>
 200d45c:	d8c00f17 	ldw	r3,60(sp)
 200d460:	18015026 	beq	r3,zero,200d9a4 <_dtoa_r+0x147c>
 200d464:	10810cc4 	addi	r2,r2,1075
 200d468:	dcc00a17 	ldw	r19,40(sp)
 200d46c:	dc800817 	ldw	r18,32(sp)
 200d470:	003e9706 	br	200ced0 <_dtoa_r+0x9a8>
 200d474:	b807883a 	mov	r3,r23
 200d478:	182b883a 	mov	r21,r3
 200d47c:	ddc00717 	ldw	r23,28(sp)
 200d480:	00800e0e 	bge	zero,r2,200d4bc <_dtoa_r+0xf94>
 200d484:	e00b883a 	mov	r5,fp
 200d488:	01800044 	movi	r6,1
 200d48c:	8009883a 	mov	r4,r16
 200d490:	d8c01515 	stw	r3,84(sp)
 200d494:	200ed7c0 	call	200ed7c <__lshift>
 200d498:	1009883a 	mov	r4,r2
 200d49c:	a00b883a 	mov	r5,r20
 200d4a0:	1039883a 	mov	fp,r2
 200d4a4:	200eed80 	call	200eed8 <__mcmp>
 200d4a8:	d8c01517 	ldw	r3,84(sp)
 200d4ac:	0081880e 	bge	zero,r2,200dad0 <_dtoa_r+0x15a8>
 200d4b0:	00800e44 	movi	r2,57
 200d4b4:	b0c00c44 	addi	r3,r22,49
 200d4b8:	a8816326 	beq	r21,r2,200da48 <_dtoa_r+0x1520>
 200d4bc:	90c00005 	stb	r3,0(r18)
 200d4c0:	95800044 	addi	r22,r18,1
 200d4c4:	982b883a 	mov	r21,r19
 200d4c8:	003f1606 	br	200d124 <_dtoa_r+0xbfc>
 200d4cc:	300b883a 	mov	r5,r6
 200d4d0:	e009883a 	mov	r4,fp
 200d4d4:	d9801515 	stw	r6,84(sp)
 200d4d8:	200eed80 	call	200eed8 <__mcmp>
 200d4dc:	d9801517 	ldw	r6,84(sp)
 200d4e0:	8009883a 	mov	r4,r16
 200d4e4:	d8801515 	stw	r2,84(sp)
 200d4e8:	300b883a 	mov	r5,r6
 200d4ec:	200e6dc0 	call	200e6dc <_Bfree>
 200d4f0:	d8801517 	ldw	r2,84(sp)
 200d4f4:	103f6d1e 	bne	r2,zero,200d2ac <_dtoa_r+0xd84>
 200d4f8:	d9c00417 	ldw	r7,16(sp)
 200d4fc:	383f6b1e 	bne	r7,zero,200d2ac <_dtoa_r+0xd84>
 200d500:	d8c00317 	ldw	r3,12(sp)
 200d504:	183f691e 	bne	r3,zero,200d2ac <_dtoa_r+0xd84>
 200d508:	b807883a 	mov	r3,r23
 200d50c:	00800e44 	movi	r2,57
 200d510:	ddc00717 	ldw	r23,28(sp)
 200d514:	18814c26 	beq	r3,r2,200da48 <_dtoa_r+0x1520>
 200d518:	057fe80e 	bge	zero,r21,200d4bc <_dtoa_r+0xf94>
 200d51c:	b0c00c44 	addi	r3,r22,49
 200d520:	003fe606 	br	200d4bc <_dtoa_r+0xf94>
 200d524:	880b883a 	mov	r5,r17
 200d528:	8009883a 	mov	r4,r16
 200d52c:	01800284 	movi	r6,10
 200d530:	000f883a 	mov	r7,zero
 200d534:	200e7040 	call	200e704 <__multadd>
 200d538:	1023883a 	mov	r17,r2
 200d53c:	1027883a 	mov	r19,r2
 200d540:	a825883a 	mov	r18,r21
 200d544:	003f4506 	br	200d25c <_dtoa_r+0xd34>
 200d548:	e009883a 	mov	r4,fp
 200d54c:	a00b883a 	mov	r5,r20
 200d550:	200eed80 	call	200eed8 <__mcmp>
 200d554:	103ebc0e 	bge	r2,zero,200d048 <_dtoa_r+0xb20>
 200d558:	e00b883a 	mov	r5,fp
 200d55c:	8009883a 	mov	r4,r16
 200d560:	01800284 	movi	r6,10
 200d564:	000f883a 	mov	r7,zero
 200d568:	200e7040 	call	200e704 <__multadd>
 200d56c:	1039883a 	mov	fp,r2
 200d570:	d8800617 	ldw	r2,24(sp)
 200d574:	d8c00c17 	ldw	r3,48(sp)
 200d578:	10bfffc4 	addi	r2,r2,-1
 200d57c:	d8800615 	stw	r2,24(sp)
 200d580:	1801571e 	bne	r3,zero,200dae0 <_dtoa_r+0x15b8>
 200d584:	d9c00e17 	ldw	r7,56(sp)
 200d588:	d9c00915 	stw	r7,36(sp)
 200d58c:	003eae06 	br	200d048 <_dtoa_r+0xb20>
 200d590:	a0800417 	ldw	r2,16(r20)
 200d594:	10800104 	addi	r2,r2,4
 200d598:	1085883a 	add	r2,r2,r2
 200d59c:	1085883a 	add	r2,r2,r2
 200d5a0:	a085883a 	add	r2,r20,r2
 200d5a4:	11000017 	ldw	r4,0(r2)
 200d5a8:	200e91c0 	call	200e91c <__hi0bits>
 200d5ac:	00c00804 	movi	r3,32
 200d5b0:	1885c83a 	sub	r2,r3,r2
 200d5b4:	003e8306 	br	200cfc4 <_dtoa_r+0xa9c>
 200d5b8:	d9c00417 	ldw	r7,16(sp)
 200d5bc:	00800084 	movi	r2,2
 200d5c0:	11fea30e 	bge	r2,r7,200d050 <_dtoa_r+0xb28>
 200d5c4:	d8800917 	ldw	r2,36(sp)
 200d5c8:	103f8c1e 	bne	r2,zero,200d3fc <_dtoa_r+0xed4>
 200d5cc:	a00b883a 	mov	r5,r20
 200d5d0:	8009883a 	mov	r4,r16
 200d5d4:	01800144 	movi	r6,5
 200d5d8:	000f883a 	mov	r7,zero
 200d5dc:	200e7040 	call	200e704 <__multadd>
 200d5e0:	e009883a 	mov	r4,fp
 200d5e4:	100b883a 	mov	r5,r2
 200d5e8:	1029883a 	mov	r20,r2
 200d5ec:	200eed80 	call	200eed8 <__mcmp>
 200d5f0:	00bf820e 	bge	zero,r2,200d3fc <_dtoa_r+0xed4>
 200d5f4:	00800c44 	movi	r2,49
 200d5f8:	b8800005 	stb	r2,0(r23)
 200d5fc:	d8800617 	ldw	r2,24(sp)
 200d600:	bd800044 	addi	r22,r23,1
 200d604:	10800044 	addi	r2,r2,1
 200d608:	d8800615 	stw	r2,24(sp)
 200d60c:	003f7f06 	br	200d40c <_dtoa_r+0xee4>
 200d610:	dc000417 	ldw	r16,16(sp)
 200d614:	003d6506 	br	200cbac <_dtoa_r+0x684>
 200d618:	9009883a 	mov	r4,r18
 200d61c:	20143580 	call	2014358 <__floatsidf>
 200d620:	1009883a 	mov	r4,r2
 200d624:	180b883a 	mov	r5,r3
 200d628:	980d883a 	mov	r6,r19
 200d62c:	a00f883a 	mov	r7,r20
 200d630:	2013c880 	call	2013c88 <__muldf3>
 200d634:	1009883a 	mov	r4,r2
 200d638:	180b883a 	mov	r5,r3
 200d63c:	000d883a 	mov	r6,zero
 200d640:	01d00734 	movhi	r7,16412
 200d644:	2013bd40 	call	2013bd4 <__adddf3>
 200d648:	057f3034 	movhi	r21,64704
 200d64c:	1025883a 	mov	r18,r2
 200d650:	1d6b883a 	add	r21,r3,r21
 200d654:	9809883a 	mov	r4,r19
 200d658:	a00b883a 	mov	r5,r20
 200d65c:	000d883a 	mov	r6,zero
 200d660:	01d00534 	movhi	r7,16404
 200d664:	2013c280 	call	2013c28 <__subdf3>
 200d668:	1009883a 	mov	r4,r2
 200d66c:	180b883a 	mov	r5,r3
 200d670:	900d883a 	mov	r6,r18
 200d674:	a80f883a 	mov	r7,r21
 200d678:	1027883a 	mov	r19,r2
 200d67c:	1829883a 	mov	r20,r3
 200d680:	20141d80 	call	20141d8 <__gtdf2>
 200d684:	00806616 	blt	zero,r2,200d820 <_dtoa_r+0x12f8>
 200d688:	a9e0003c 	xorhi	r7,r21,32768
 200d68c:	9809883a 	mov	r4,r19
 200d690:	a00b883a 	mov	r5,r20
 200d694:	900d883a 	mov	r6,r18
 200d698:	20142a00 	call	20142a0 <__ltdf2>
 200d69c:	103d710e 	bge	r2,zero,200cc64 <_dtoa_r+0x73c>
 200d6a0:	0029883a 	mov	r20,zero
 200d6a4:	002b883a 	mov	r21,zero
 200d6a8:	003f5406 	br	200d3fc <_dtoa_r+0xed4>
 200d6ac:	d9800a17 	ldw	r6,40(sp)
 200d6b0:	e00b883a 	mov	r5,fp
 200d6b4:	8009883a 	mov	r4,r16
 200d6b8:	200ec500 	call	200ec50 <__pow5mult>
 200d6bc:	1039883a 	mov	fp,r2
 200d6c0:	003e2e06 	br	200cf7c <_dtoa_r+0xa54>
 200d6c4:	d8000c15 	stw	zero,48(sp)
 200d6c8:	003f2006 	br	200d34c <_dtoa_r+0xe24>
 200d6cc:	00800044 	movi	r2,1
 200d6d0:	d8800c15 	stw	r2,48(sp)
 200d6d4:	003c5d06 	br	200c84c <_dtoa_r+0x324>
 200d6d8:	d8c00a17 	ldw	r3,40(sp)
 200d6dc:	d9000b17 	ldw	r4,44(sp)
 200d6e0:	dcc00a15 	stw	r19,40(sp)
 200d6e4:	98c5c83a 	sub	r2,r19,r3
 200d6e8:	2089883a 	add	r4,r4,r2
 200d6ec:	d9000b15 	stw	r4,44(sp)
 200d6f0:	0027883a 	mov	r19,zero
 200d6f4:	003df206 	br	200cec0 <_dtoa_r+0x998>
 200d6f8:	d9000317 	ldw	r4,12(sp)
 200d6fc:	8829883a 	mov	r20,r17
 200d700:	04800084 	movi	r18,2
 200d704:	d9001015 	stw	r4,64(sp)
 200d708:	003c8106 	br	200c910 <_dtoa_r+0x3e8>
 200d70c:	04800044 	movi	r18,1
 200d710:	dc800e15 	stw	r18,56(sp)
 200d714:	dc800915 	stw	r18,36(sp)
 200d718:	dc802115 	stw	r18,132(sp)
 200d71c:	003f1206 	br	200d368 <_dtoa_r+0xe40>
 200d720:	d8800617 	ldw	r2,24(sp)
 200d724:	00abc83a 	sub	r21,zero,r2
 200d728:	a800a426 	beq	r21,zero,200d9bc <_dtoa_r+0x1494>
 200d72c:	a88003cc 	andi	r2,r21,15
 200d730:	100490fa 	slli	r2,r2,3
 200d734:	00c08174 	movhi	r3,517
 200d738:	18f7cf04 	addi	r3,r3,-8388
 200d73c:	d9000317 	ldw	r4,12(sp)
 200d740:	1885883a 	add	r2,r3,r2
 200d744:	11800017 	ldw	r6,0(r2)
 200d748:	11c00117 	ldw	r7,4(r2)
 200d74c:	a82bd13a 	srai	r21,r21,4
 200d750:	880b883a 	mov	r5,r17
 200d754:	2013c880 	call	2013c88 <__muldf3>
 200d758:	1027883a 	mov	r19,r2
 200d75c:	1829883a 	mov	r20,r3
 200d760:	a800e826 	beq	r21,zero,200db04 <_dtoa_r+0x15dc>
 200d764:	05808174 	movhi	r22,517
 200d768:	b5b7c504 	addi	r22,r22,-8428
 200d76c:	04800084 	movi	r18,2
 200d770:	a980004c 	andi	r6,r21,1
 200d774:	1009883a 	mov	r4,r2
 200d778:	a82bd07a 	srai	r21,r21,1
 200d77c:	180b883a 	mov	r5,r3
 200d780:	30000426 	beq	r6,zero,200d794 <_dtoa_r+0x126c>
 200d784:	b1800017 	ldw	r6,0(r22)
 200d788:	b1c00117 	ldw	r7,4(r22)
 200d78c:	94800044 	addi	r18,r18,1
 200d790:	2013c880 	call	2013c88 <__muldf3>
 200d794:	b5800204 	addi	r22,r22,8
 200d798:	a83ff51e 	bne	r21,zero,200d770 <_dtoa_r+0x1248>
 200d79c:	1027883a 	mov	r19,r2
 200d7a0:	1829883a 	mov	r20,r3
 200d7a4:	003c7306 	br	200c974 <_dtoa_r+0x44c>
 200d7a8:	21000044 	addi	r4,r4,1
 200d7ac:	11000005 	stb	r4,0(r2)
 200d7b0:	003e5c06 	br	200d124 <_dtoa_r+0xbfc>
 200d7b4:	a9400117 	ldw	r5,4(r21)
 200d7b8:	8009883a 	mov	r4,r16
 200d7bc:	200e6340 	call	200e634 <_Balloc>
 200d7c0:	a9800417 	ldw	r6,16(r21)
 200d7c4:	11000304 	addi	r4,r2,12
 200d7c8:	a9400304 	addi	r5,r21,12
 200d7cc:	31800084 	addi	r6,r6,2
 200d7d0:	318d883a 	add	r6,r6,r6
 200d7d4:	318d883a 	add	r6,r6,r6
 200d7d8:	1023883a 	mov	r17,r2
 200d7dc:	200660c0 	call	200660c <memcpy>
 200d7e0:	8009883a 	mov	r4,r16
 200d7e4:	880b883a 	mov	r5,r17
 200d7e8:	01800044 	movi	r6,1
 200d7ec:	200ed7c0 	call	200ed7c <__lshift>
 200d7f0:	1027883a 	mov	r19,r2
 200d7f4:	003e8f06 	br	200d234 <_dtoa_r+0xd0c>
 200d7f8:	b807883a 	mov	r3,r23
 200d7fc:	00800e44 	movi	r2,57
 200d800:	ddc00717 	ldw	r23,28(sp)
 200d804:	18809026 	beq	r3,r2,200da48 <_dtoa_r+0x1520>
 200d808:	18c00044 	addi	r3,r3,1
 200d80c:	003f2b06 	br	200d4bc <_dtoa_r+0xf94>
 200d810:	b807883a 	mov	r3,r23
 200d814:	982b883a 	mov	r21,r19
 200d818:	ddc00717 	ldw	r23,28(sp)
 200d81c:	003e2406 	br	200d0b0 <_dtoa_r+0xb88>
 200d820:	0029883a 	mov	r20,zero
 200d824:	002b883a 	mov	r21,zero
 200d828:	003f7206 	br	200d5f4 <_dtoa_r+0x10cc>
 200d82c:	593fffc4 	addi	r4,r11,-1
 200d830:	200490fa 	slli	r2,r4,3
 200d834:	00c08174 	movhi	r3,517
 200d838:	18f7cf04 	addi	r3,r3,-8388
 200d83c:	d9001015 	stw	r4,64(sp)
 200d840:	1885883a 	add	r2,r3,r2
 200d844:	11000017 	ldw	r4,0(r2)
 200d848:	11400117 	ldw	r5,4(r2)
 200d84c:	900d883a 	mov	r6,r18
 200d850:	a80f883a 	mov	r7,r21
 200d854:	dac01615 	stw	r11,88(sp)
 200d858:	2013c880 	call	2013c88 <__muldf3>
 200d85c:	a00b883a 	mov	r5,r20
 200d860:	9809883a 	mov	r4,r19
 200d864:	d8c01215 	stw	r3,72(sp)
 200d868:	d8801115 	stw	r2,68(sp)
 200d86c:	201442c0 	call	201442c <__fixdfsi>
 200d870:	1009883a 	mov	r4,r2
 200d874:	1025883a 	mov	r18,r2
 200d878:	20143580 	call	2014358 <__floatsidf>
 200d87c:	9809883a 	mov	r4,r19
 200d880:	a00b883a 	mov	r5,r20
 200d884:	100d883a 	mov	r6,r2
 200d888:	180f883a 	mov	r7,r3
 200d88c:	94800c04 	addi	r18,r18,48
 200d890:	2013c280 	call	2013c28 <__subdf3>
 200d894:	bc800005 	stb	r18,0(r23)
 200d898:	dac01617 	ldw	r11,88(sp)
 200d89c:	102b883a 	mov	r21,r2
 200d8a0:	00800044 	movi	r2,1
 200d8a4:	bd800044 	addi	r22,r23,1
 200d8a8:	1815883a 	mov	r10,r3
 200d8ac:	58802226 	beq	r11,r2,200d938 <_dtoa_r+0x1410>
 200d8b0:	bad7883a 	add	r11,r23,r11
 200d8b4:	dc001415 	stw	r16,80(sp)
 200d8b8:	a805883a 	mov	r2,r21
 200d8bc:	b027883a 	mov	r19,r22
 200d8c0:	5821883a 	mov	r16,r11
 200d8c4:	882b883a 	mov	r21,r17
 200d8c8:	000d883a 	mov	r6,zero
 200d8cc:	01d00934 	movhi	r7,16420
 200d8d0:	1009883a 	mov	r4,r2
 200d8d4:	180b883a 	mov	r5,r3
 200d8d8:	2013c880 	call	2013c88 <__muldf3>
 200d8dc:	180b883a 	mov	r5,r3
 200d8e0:	1009883a 	mov	r4,r2
 200d8e4:	1829883a 	mov	r20,r3
 200d8e8:	1023883a 	mov	r17,r2
 200d8ec:	201442c0 	call	201442c <__fixdfsi>
 200d8f0:	1009883a 	mov	r4,r2
 200d8f4:	1025883a 	mov	r18,r2
 200d8f8:	20143580 	call	2014358 <__floatsidf>
 200d8fc:	8809883a 	mov	r4,r17
 200d900:	a00b883a 	mov	r5,r20
 200d904:	100d883a 	mov	r6,r2
 200d908:	180f883a 	mov	r7,r3
 200d90c:	94800c04 	addi	r18,r18,48
 200d910:	2013c280 	call	2013c28 <__subdf3>
 200d914:	9cc00044 	addi	r19,r19,1
 200d918:	9cbfffc5 	stb	r18,-1(r19)
 200d91c:	9c3fea1e 	bne	r19,r16,200d8c8 <_dtoa_r+0x13a0>
 200d920:	1815883a 	mov	r10,r3
 200d924:	d8c01017 	ldw	r3,64(sp)
 200d928:	dc001417 	ldw	r16,80(sp)
 200d92c:	a823883a 	mov	r17,r21
 200d930:	b0ed883a 	add	r22,r22,r3
 200d934:	102b883a 	mov	r21,r2
 200d938:	d9001117 	ldw	r4,68(sp)
 200d93c:	d9401217 	ldw	r5,72(sp)
 200d940:	000d883a 	mov	r6,zero
 200d944:	01cff834 	movhi	r7,16352
 200d948:	da801515 	stw	r10,84(sp)
 200d94c:	2013bd40 	call	2013bd4 <__adddf3>
 200d950:	da801517 	ldw	r10,84(sp)
 200d954:	1009883a 	mov	r4,r2
 200d958:	180b883a 	mov	r5,r3
 200d95c:	500f883a 	mov	r7,r10
 200d960:	a80d883a 	mov	r6,r21
 200d964:	20142a00 	call	20142a0 <__ltdf2>
 200d968:	da801517 	ldw	r10,84(sp)
 200d96c:	10003b0e 	bge	r2,zero,200da5c <_dtoa_r+0x1534>
 200d970:	d9c01317 	ldw	r7,76(sp)
 200d974:	b53fffc3 	ldbu	r20,-1(r22)
 200d978:	d9c00615 	stw	r7,24(sp)
 200d97c:	003d3106 	br	200ce44 <_dtoa_r+0x91c>
 200d980:	d8800817 	ldw	r2,32(sp)
 200d984:	11e5c83a 	sub	r18,r2,r7
 200d988:	0005883a 	mov	r2,zero
 200d98c:	003d5006 	br	200ced0 <_dtoa_r+0x9a8>
 200d990:	05800044 	movi	r22,1
 200d994:	003dc406 	br	200d0a8 <_dtoa_r+0xb80>
 200d998:	a5000044 	addi	r20,r20,1
 200d99c:	15000005 	stb	r20,0(r2)
 200d9a0:	003c8206 	br	200cbac <_dtoa_r+0x684>
 200d9a4:	d8800217 	ldw	r2,8(sp)
 200d9a8:	00c00d84 	movi	r3,54
 200d9ac:	dcc00a17 	ldw	r19,40(sp)
 200d9b0:	1885c83a 	sub	r2,r3,r2
 200d9b4:	dc800817 	ldw	r18,32(sp)
 200d9b8:	003d4506 	br	200ced0 <_dtoa_r+0x9a8>
 200d9bc:	dcc00317 	ldw	r19,12(sp)
 200d9c0:	8829883a 	mov	r20,r17
 200d9c4:	04800084 	movi	r18,2
 200d9c8:	003bea06 	br	200c974 <_dtoa_r+0x44c>
 200d9cc:	d9000917 	ldw	r4,36(sp)
 200d9d0:	203f1126 	beq	r4,zero,200d618 <_dtoa_r+0x10f0>
 200d9d4:	d9c00e17 	ldw	r7,56(sp)
 200d9d8:	01fca20e 	bge	zero,r7,200cc64 <_dtoa_r+0x73c>
 200d9dc:	a00b883a 	mov	r5,r20
 200d9e0:	9809883a 	mov	r4,r19
 200d9e4:	000d883a 	mov	r6,zero
 200d9e8:	01d00934 	movhi	r7,16420
 200d9ec:	2013c880 	call	2013c88 <__muldf3>
 200d9f0:	91000044 	addi	r4,r18,1
 200d9f4:	1027883a 	mov	r19,r2
 200d9f8:	1829883a 	mov	r20,r3
 200d9fc:	20143580 	call	2014358 <__floatsidf>
 200da00:	9809883a 	mov	r4,r19
 200da04:	a00b883a 	mov	r5,r20
 200da08:	100d883a 	mov	r6,r2
 200da0c:	180f883a 	mov	r7,r3
 200da10:	2013c880 	call	2013c88 <__muldf3>
 200da14:	1009883a 	mov	r4,r2
 200da18:	180b883a 	mov	r5,r3
 200da1c:	000d883a 	mov	r6,zero
 200da20:	01d00734 	movhi	r7,16412
 200da24:	2013bd40 	call	2013bd4 <__adddf3>
 200da28:	1025883a 	mov	r18,r2
 200da2c:	d8800617 	ldw	r2,24(sp)
 200da30:	057f3034 	movhi	r21,64704
 200da34:	1d6b883a 	add	r21,r3,r21
 200da38:	10bfffc4 	addi	r2,r2,-1
 200da3c:	d8801315 	stw	r2,76(sp)
 200da40:	dac00e17 	ldw	r11,56(sp)
 200da44:	003be706 	br	200c9e4 <_dtoa_r+0x4bc>
 200da48:	01000e44 	movi	r4,57
 200da4c:	91000005 	stb	r4,0(r18)
 200da50:	95800044 	addi	r22,r18,1
 200da54:	982b883a 	mov	r21,r19
 200da58:	003da106 	br	200d0e0 <_dtoa_r+0xbb8>
 200da5c:	d9801117 	ldw	r6,68(sp)
 200da60:	d9c01217 	ldw	r7,72(sp)
 200da64:	0009883a 	mov	r4,zero
 200da68:	014ff834 	movhi	r5,16352
 200da6c:	da801515 	stw	r10,84(sp)
 200da70:	2013c280 	call	2013c28 <__subdf3>
 200da74:	da801517 	ldw	r10,84(sp)
 200da78:	1009883a 	mov	r4,r2
 200da7c:	180b883a 	mov	r5,r3
 200da80:	a80d883a 	mov	r6,r21
 200da84:	500f883a 	mov	r7,r10
 200da88:	20141d80 	call	20141d8 <__gtdf2>
 200da8c:	00bc750e 	bge	zero,r2,200cc64 <_dtoa_r+0x73c>
 200da90:	01000c04 	movi	r4,48
 200da94:	00000106 	br	200da9c <_dtoa_r+0x1574>
 200da98:	102d883a 	mov	r22,r2
 200da9c:	b0bfffc4 	addi	r2,r22,-1
 200daa0:	10c00007 	ldb	r3,0(r2)
 200daa4:	193ffc26 	beq	r3,r4,200da98 <_dtoa_r+0x1570>
 200daa8:	d8801317 	ldw	r2,76(sp)
 200daac:	d8800615 	stw	r2,24(sp)
 200dab0:	003c3e06 	br	200cbac <_dtoa_r+0x684>
 200dab4:	d9001317 	ldw	r4,76(sp)
 200dab8:	df001117 	ldw	fp,68(sp)
 200dabc:	d9000615 	stw	r4,24(sp)
 200dac0:	003ce006 	br	200ce44 <_dtoa_r+0x91c>
 200dac4:	df001117 	ldw	fp,68(sp)
 200dac8:	dc401217 	ldw	r17,72(sp)
 200dacc:	003c6506 	br	200cc64 <_dtoa_r+0x73c>
 200dad0:	103e7a1e 	bne	r2,zero,200d4bc <_dtoa_r+0xf94>
 200dad4:	1880004c 	andi	r2,r3,1
 200dad8:	103e7826 	beq	r2,zero,200d4bc <_dtoa_r+0xf94>
 200dadc:	003e7406 	br	200d4b0 <_dtoa_r+0xf88>
 200dae0:	8009883a 	mov	r4,r16
 200dae4:	a80b883a 	mov	r5,r21
 200dae8:	01800284 	movi	r6,10
 200daec:	000f883a 	mov	r7,zero
 200daf0:	200e7040 	call	200e704 <__multadd>
 200daf4:	d9000e17 	ldw	r4,56(sp)
 200daf8:	102b883a 	mov	r21,r2
 200dafc:	d9000915 	stw	r4,36(sp)
 200db00:	003d5106 	br	200d048 <_dtoa_r+0xb20>
 200db04:	04800084 	movi	r18,2
 200db08:	003b9a06 	br	200c974 <_dtoa_r+0x44c>
 200db0c:	d8c01317 	ldw	r3,76(sp)
 200db10:	d8c00615 	stw	r3,24(sp)
 200db14:	003ccb06 	br	200ce44 <_dtoa_r+0x91c>
 200db18:	d8c01317 	ldw	r3,76(sp)
 200db1c:	d8c00615 	stw	r3,24(sp)
 200db20:	003c2206 	br	200cbac <_dtoa_r+0x684>
 200db24:	20fd3826 	beq	r4,r3,200d008 <_dtoa_r+0xae0>
 200db28:	00c00f04 	movi	r3,60
 200db2c:	1885c83a 	sub	r2,r3,r2
 200db30:	003da906 	br	200d1d8 <_dtoa_r+0xcb0>
 200db34:	000b883a 	mov	r5,zero
 200db38:	003b5406 	br	200c88c <_dtoa_r+0x364>
 200db3c:	04c00044 	movi	r19,1
 200db40:	003b3b06 	br	200c830 <_dtoa_r+0x308>

0200db44 <__sflags>:
 200db44:	28800007 	ldb	r2,0(r5)
 200db48:	00c01c84 	movi	r3,114
 200db4c:	10c01826 	beq	r2,r3,200dbb0 <__sflags+0x6c>
 200db50:	00c01dc4 	movi	r3,119
 200db54:	10c01226 	beq	r2,r3,200dba0 <__sflags+0x5c>
 200db58:	00c01844 	movi	r3,97
 200db5c:	10c00426 	beq	r2,r3,200db70 <__sflags+0x2c>
 200db60:	00800584 	movi	r2,22
 200db64:	20800015 	stw	r2,0(r4)
 200db68:	0005883a 	mov	r2,zero
 200db6c:	f800283a 	ret
 200db70:	01c08204 	movi	r7,520
 200db74:	01000044 	movi	r4,1
 200db78:	00804204 	movi	r2,264
 200db7c:	28c00047 	ldb	r3,1(r5)
 200db80:	18000426 	beq	r3,zero,200db94 <__sflags+0x50>
 200db84:	02000ac4 	movi	r8,43
 200db88:	1a000d26 	beq	r3,r8,200dbc0 <__sflags+0x7c>
 200db8c:	28c00087 	ldb	r3,2(r5)
 200db90:	1a000b26 	beq	r3,r8,200dbc0 <__sflags+0x7c>
 200db94:	21c8b03a 	or	r4,r4,r7
 200db98:	31000015 	stw	r4,0(r6)
 200db9c:	f800283a 	ret
 200dba0:	01c18004 	movi	r7,1536
 200dba4:	01000044 	movi	r4,1
 200dba8:	00800204 	movi	r2,8
 200dbac:	003ff306 	br	200db7c <__sflags+0x38>
 200dbb0:	000f883a 	mov	r7,zero
 200dbb4:	0009883a 	mov	r4,zero
 200dbb8:	00800104 	movi	r2,4
 200dbbc:	003fef06 	br	200db7c <__sflags+0x38>
 200dbc0:	00fff8c4 	movi	r3,-29
 200dbc4:	01000084 	movi	r4,2
 200dbc8:	10c4703a 	and	r2,r2,r3
 200dbcc:	21c8b03a 	or	r4,r4,r7
 200dbd0:	10800414 	ori	r2,r2,16
 200dbd4:	31000015 	stw	r4,0(r6)
 200dbd8:	f800283a 	ret

0200dbdc <_fputc_r>:
 200dbdc:	defffc04 	addi	sp,sp,-16
 200dbe0:	dc000215 	stw	r16,8(sp)
 200dbe4:	dfc00315 	stw	ra,12(sp)
 200dbe8:	2021883a 	mov	r16,r4
 200dbec:	20000726 	beq	r4,zero,200dc0c <_fputc_r+0x30>
 200dbf0:	20800e17 	ldw	r2,56(r4)
 200dbf4:	1000051e 	bne	r2,zero,200dc0c <_fputc_r+0x30>
 200dbf8:	d9400015 	stw	r5,0(sp)
 200dbfc:	d9800115 	stw	r6,4(sp)
 200dc00:	200492c0 	call	200492c <__sinit>
 200dc04:	d9800117 	ldw	r6,4(sp)
 200dc08:	d9400017 	ldw	r5,0(sp)
 200dc0c:	8009883a 	mov	r4,r16
 200dc10:	dfc00317 	ldw	ra,12(sp)
 200dc14:	dc000217 	ldw	r16,8(sp)
 200dc18:	dec00404 	addi	sp,sp,16
 200dc1c:	2006a601 	jmpi	2006a60 <_putc_r>

0200dc20 <fputc>:
 200dc20:	defffc04 	addi	sp,sp,-16
 200dc24:	dc000115 	stw	r16,4(sp)
 200dc28:	04008174 	movhi	r16,517
 200dc2c:	84103604 	addi	r16,r16,16600
 200dc30:	80800017 	ldw	r2,0(r16)
 200dc34:	dc400215 	stw	r17,8(sp)
 200dc38:	dfc00315 	stw	ra,12(sp)
 200dc3c:	2023883a 	mov	r17,r4
 200dc40:	280d883a 	mov	r6,r5
 200dc44:	10000726 	beq	r2,zero,200dc64 <fputc+0x44>
 200dc48:	10c00e17 	ldw	r3,56(r2)
 200dc4c:	1800051e 	bne	r3,zero,200dc64 <fputc+0x44>
 200dc50:	1009883a 	mov	r4,r2
 200dc54:	d9400015 	stw	r5,0(sp)
 200dc58:	200492c0 	call	200492c <__sinit>
 200dc5c:	80800017 	ldw	r2,0(r16)
 200dc60:	d9800017 	ldw	r6,0(sp)
 200dc64:	1009883a 	mov	r4,r2
 200dc68:	880b883a 	mov	r5,r17
 200dc6c:	dfc00317 	ldw	ra,12(sp)
 200dc70:	dc400217 	ldw	r17,8(sp)
 200dc74:	dc000117 	ldw	r16,4(sp)
 200dc78:	dec00404 	addi	sp,sp,16
 200dc7c:	2006a601 	jmpi	2006a60 <_putc_r>

0200dc80 <_fputs_r>:
 200dc80:	defff804 	addi	sp,sp,-32
 200dc84:	dc000515 	stw	r16,20(sp)
 200dc88:	2021883a 	mov	r16,r4
 200dc8c:	2809883a 	mov	r4,r5
 200dc90:	dc400615 	stw	r17,24(sp)
 200dc94:	dfc00715 	stw	ra,28(sp)
 200dc98:	3023883a 	mov	r17,r6
 200dc9c:	d9400315 	stw	r5,12(sp)
 200dca0:	2007c640 	call	2007c64 <strlen>
 200dca4:	d8800215 	stw	r2,8(sp)
 200dca8:	d8800415 	stw	r2,16(sp)
 200dcac:	d8800304 	addi	r2,sp,12
 200dcb0:	d8800015 	stw	r2,0(sp)
 200dcb4:	00800044 	movi	r2,1
 200dcb8:	d8800115 	stw	r2,4(sp)
 200dcbc:	80000426 	beq	r16,zero,200dcd0 <_fputs_r+0x50>
 200dcc0:	80800e17 	ldw	r2,56(r16)
 200dcc4:	1000021e 	bne	r2,zero,200dcd0 <_fputs_r+0x50>
 200dcc8:	8009883a 	mov	r4,r16
 200dccc:	200492c0 	call	200492c <__sinit>
 200dcd0:	8009883a 	mov	r4,r16
 200dcd4:	880b883a 	mov	r5,r17
 200dcd8:	d80d883a 	mov	r6,sp
 200dcdc:	200dd100 	call	200dd10 <__sfvwrite_r>
 200dce0:	dfc00717 	ldw	ra,28(sp)
 200dce4:	dc400617 	ldw	r17,24(sp)
 200dce8:	dc000517 	ldw	r16,20(sp)
 200dcec:	dec00804 	addi	sp,sp,32
 200dcf0:	f800283a 	ret

0200dcf4 <fputs>:
 200dcf4:	00c08174 	movhi	r3,517
 200dcf8:	18d03604 	addi	r3,r3,16600
 200dcfc:	2005883a 	mov	r2,r4
 200dd00:	19000017 	ldw	r4,0(r3)
 200dd04:	280d883a 	mov	r6,r5
 200dd08:	100b883a 	mov	r5,r2
 200dd0c:	200dc801 	jmpi	200dc80 <_fputs_r>

0200dd10 <__sfvwrite_r>:
 200dd10:	30800217 	ldw	r2,8(r6)
 200dd14:	defff504 	addi	sp,sp,-44
 200dd18:	dd400615 	stw	r21,24(sp)
 200dd1c:	dd000515 	stw	r20,20(sp)
 200dd20:	dc000115 	stw	r16,4(sp)
 200dd24:	dfc00a15 	stw	ra,40(sp)
 200dd28:	df000915 	stw	fp,36(sp)
 200dd2c:	ddc00815 	stw	r23,32(sp)
 200dd30:	dd800715 	stw	r22,28(sp)
 200dd34:	dcc00415 	stw	r19,16(sp)
 200dd38:	dc800315 	stw	r18,12(sp)
 200dd3c:	dc400215 	stw	r17,8(sp)
 200dd40:	3029883a 	mov	r20,r6
 200dd44:	202b883a 	mov	r21,r4
 200dd48:	2821883a 	mov	r16,r5
 200dd4c:	10002126 	beq	r2,zero,200ddd4 <__sfvwrite_r+0xc4>
 200dd50:	2880030b 	ldhu	r2,12(r5)
 200dd54:	10c0020c 	andi	r3,r2,8
 200dd58:	18ffffcc 	andi	r3,r3,65535
 200dd5c:	18e0001c 	xori	r3,r3,32768
 200dd60:	18e00004 	addi	r3,r3,-32768
 200dd64:	18002826 	beq	r3,zero,200de08 <__sfvwrite_r+0xf8>
 200dd68:	28c00417 	ldw	r3,16(r5)
 200dd6c:	18002626 	beq	r3,zero,200de08 <__sfvwrite_r+0xf8>
 200dd70:	10c0008c 	andi	r3,r2,2
 200dd74:	18ffffcc 	andi	r3,r3,65535
 200dd78:	18e0001c 	xori	r3,r3,32768
 200dd7c:	18e00004 	addi	r3,r3,-32768
 200dd80:	a4400017 	ldw	r17,0(r20)
 200dd84:	18002b26 	beq	r3,zero,200de34 <__sfvwrite_r+0x124>
 200dd88:	0027883a 	mov	r19,zero
 200dd8c:	0025883a 	mov	r18,zero
 200dd90:	05810004 	movi	r22,1024
 200dd94:	980d883a 	mov	r6,r19
 200dd98:	a809883a 	mov	r4,r21
 200dd9c:	90004f26 	beq	r18,zero,200dedc <__sfvwrite_r+0x1cc>
 200dda0:	900f883a 	mov	r7,r18
 200dda4:	81400717 	ldw	r5,28(r16)
 200dda8:	b480012e 	bgeu	r22,r18,200ddb0 <__sfvwrite_r+0xa0>
 200ddac:	01c10004 	movi	r7,1024
 200ddb0:	80800917 	ldw	r2,36(r16)
 200ddb4:	103ee83a 	callr	r2
 200ddb8:	0080540e 	bge	zero,r2,200df0c <__sfvwrite_r+0x1fc>
 200ddbc:	a0c00217 	ldw	r3,8(r20)
 200ddc0:	98a7883a 	add	r19,r19,r2
 200ddc4:	90a5c83a 	sub	r18,r18,r2
 200ddc8:	1885c83a 	sub	r2,r3,r2
 200ddcc:	a0800215 	stw	r2,8(r20)
 200ddd0:	103ff01e 	bne	r2,zero,200dd94 <__sfvwrite_r+0x84>
 200ddd4:	0005883a 	mov	r2,zero
 200ddd8:	dfc00a17 	ldw	ra,40(sp)
 200dddc:	df000917 	ldw	fp,36(sp)
 200dde0:	ddc00817 	ldw	r23,32(sp)
 200dde4:	dd800717 	ldw	r22,28(sp)
 200dde8:	dd400617 	ldw	r21,24(sp)
 200ddec:	dd000517 	ldw	r20,20(sp)
 200ddf0:	dcc00417 	ldw	r19,16(sp)
 200ddf4:	dc800317 	ldw	r18,12(sp)
 200ddf8:	dc400217 	ldw	r17,8(sp)
 200ddfc:	dc000117 	ldw	r16,4(sp)
 200de00:	dec00b04 	addi	sp,sp,44
 200de04:	f800283a 	ret
 200de08:	a809883a 	mov	r4,r21
 200de0c:	800b883a 	mov	r5,r16
 200de10:	200c1480 	call	200c148 <__swsetup_r>
 200de14:	1000f01e 	bne	r2,zero,200e1d8 <__sfvwrite_r+0x4c8>
 200de18:	8080030b 	ldhu	r2,12(r16)
 200de1c:	a4400017 	ldw	r17,0(r20)
 200de20:	10c0008c 	andi	r3,r2,2
 200de24:	18ffffcc 	andi	r3,r3,65535
 200de28:	18e0001c 	xori	r3,r3,32768
 200de2c:	18e00004 	addi	r3,r3,-32768
 200de30:	183fd51e 	bne	r3,zero,200dd88 <__sfvwrite_r+0x78>
 200de34:	10c0004c 	andi	r3,r2,1
 200de38:	002d883a 	mov	r22,zero
 200de3c:	1800381e 	bne	r3,zero,200df20 <__sfvwrite_r+0x210>
 200de40:	0025883a 	mov	r18,zero
 200de44:	90002126 	beq	r18,zero,200decc <__sfvwrite_r+0x1bc>
 200de48:	10c0800c 	andi	r3,r2,512
 200de4c:	18ffffcc 	andi	r3,r3,65535
 200de50:	18e0001c 	xori	r3,r3,32768
 200de54:	18e00004 	addi	r3,r3,-32768
 200de58:	84c00217 	ldw	r19,8(r16)
 200de5c:	18006b26 	beq	r3,zero,200e00c <__sfvwrite_r+0x2fc>
 200de60:	980f883a 	mov	r7,r19
 200de64:	94c08636 	bltu	r18,r19,200e080 <__sfvwrite_r+0x370>
 200de68:	10c1200c 	andi	r3,r2,1152
 200de6c:	18009f1e 	bne	r3,zero,200e0ec <__sfvwrite_r+0x3dc>
 200de70:	81000017 	ldw	r4,0(r16)
 200de74:	982f883a 	mov	r23,r19
 200de78:	9039883a 	mov	fp,r18
 200de7c:	9027883a 	mov	r19,r18
 200de80:	380d883a 	mov	r6,r7
 200de84:	b00b883a 	mov	r5,r22
 200de88:	d9c00015 	stw	r7,0(sp)
 200de8c:	20067040 	call	2006704 <memmove>
 200de90:	d9c00017 	ldw	r7,0(sp)
 200de94:	81000217 	ldw	r4,8(r16)
 200de98:	80800017 	ldw	r2,0(r16)
 200de9c:	25efc83a 	sub	r23,r4,r23
 200dea0:	11cf883a 	add	r7,r2,r7
 200dea4:	85c00215 	stw	r23,8(r16)
 200dea8:	81c00015 	stw	r7,0(r16)
 200deac:	a0800217 	ldw	r2,8(r20)
 200deb0:	b72d883a 	add	r22,r22,fp
 200deb4:	9725c83a 	sub	r18,r18,fp
 200deb8:	14e7c83a 	sub	r19,r2,r19
 200debc:	a4c00215 	stw	r19,8(r20)
 200dec0:	983fc426 	beq	r19,zero,200ddd4 <__sfvwrite_r+0xc4>
 200dec4:	8080030b 	ldhu	r2,12(r16)
 200dec8:	903fdf1e 	bne	r18,zero,200de48 <__sfvwrite_r+0x138>
 200decc:	8d800017 	ldw	r22,0(r17)
 200ded0:	8c800117 	ldw	r18,4(r17)
 200ded4:	8c400204 	addi	r17,r17,8
 200ded8:	003fda06 	br	200de44 <__sfvwrite_r+0x134>
 200dedc:	8cc00017 	ldw	r19,0(r17)
 200dee0:	8c800117 	ldw	r18,4(r17)
 200dee4:	8c400204 	addi	r17,r17,8
 200dee8:	003faa06 	br	200dd94 <__sfvwrite_r+0x84>
 200deec:	200f6480 	call	200f648 <_realloc_r>
 200def0:	102f883a 	mov	r23,r2
 200def4:	10009f1e 	bne	r2,zero,200e174 <__sfvwrite_r+0x464>
 200def8:	81400417 	ldw	r5,16(r16)
 200defc:	a809883a 	mov	r4,r21
 200df00:	20050b40 	call	20050b4 <_free_r>
 200df04:	00800304 	movi	r2,12
 200df08:	a8800015 	stw	r2,0(r21)
 200df0c:	80c0030b 	ldhu	r3,12(r16)
 200df10:	00bfffc4 	movi	r2,-1
 200df14:	18c01014 	ori	r3,r3,64
 200df18:	80c0030d 	sth	r3,12(r16)
 200df1c:	003fae06 	br	200ddd8 <__sfvwrite_r+0xc8>
 200df20:	0007883a 	mov	r3,zero
 200df24:	0039883a 	mov	fp,zero
 200df28:	0025883a 	mov	r18,zero
 200df2c:	90001e26 	beq	r18,zero,200dfa8 <__sfvwrite_r+0x298>
 200df30:	18006526 	beq	r3,zero,200e0c8 <__sfvwrite_r+0x3b8>
 200df34:	b02f883a 	mov	r23,r22
 200df38:	9580012e 	bgeu	r18,r22,200df40 <__sfvwrite_r+0x230>
 200df3c:	902f883a 	mov	r23,r18
 200df40:	81000017 	ldw	r4,0(r16)
 200df44:	80800417 	ldw	r2,16(r16)
 200df48:	84c00217 	ldw	r19,8(r16)
 200df4c:	81c00517 	ldw	r7,20(r16)
 200df50:	1100022e 	bgeu	r2,r4,200df5c <__sfvwrite_r+0x24c>
 200df54:	99e7883a 	add	r19,r19,r7
 200df58:	9dc01816 	blt	r19,r23,200dfbc <__sfvwrite_r+0x2ac>
 200df5c:	b9c03b16 	blt	r23,r7,200e04c <__sfvwrite_r+0x33c>
 200df60:	80800917 	ldw	r2,36(r16)
 200df64:	81400717 	ldw	r5,28(r16)
 200df68:	a809883a 	mov	r4,r21
 200df6c:	d8c00015 	stw	r3,0(sp)
 200df70:	e00d883a 	mov	r6,fp
 200df74:	103ee83a 	callr	r2
 200df78:	1027883a 	mov	r19,r2
 200df7c:	d8c00017 	ldw	r3,0(sp)
 200df80:	00bfe20e 	bge	zero,r2,200df0c <__sfvwrite_r+0x1fc>
 200df84:	b4edc83a 	sub	r22,r22,r19
 200df88:	b0001a26 	beq	r22,zero,200dff4 <__sfvwrite_r+0x2e4>
 200df8c:	a0800217 	ldw	r2,8(r20)
 200df90:	e4f9883a 	add	fp,fp,r19
 200df94:	94e5c83a 	sub	r18,r18,r19
 200df98:	14e7c83a 	sub	r19,r2,r19
 200df9c:	a4c00215 	stw	r19,8(r20)
 200dfa0:	983f8c26 	beq	r19,zero,200ddd4 <__sfvwrite_r+0xc4>
 200dfa4:	903fe21e 	bne	r18,zero,200df30 <__sfvwrite_r+0x220>
 200dfa8:	8f000017 	ldw	fp,0(r17)
 200dfac:	8c800117 	ldw	r18,4(r17)
 200dfb0:	0007883a 	mov	r3,zero
 200dfb4:	8c400204 	addi	r17,r17,8
 200dfb8:	003fdc06 	br	200df2c <__sfvwrite_r+0x21c>
 200dfbc:	e00b883a 	mov	r5,fp
 200dfc0:	980d883a 	mov	r6,r19
 200dfc4:	d8c00015 	stw	r3,0(sp)
 200dfc8:	20067040 	call	2006704 <memmove>
 200dfcc:	80800017 	ldw	r2,0(r16)
 200dfd0:	a809883a 	mov	r4,r21
 200dfd4:	800b883a 	mov	r5,r16
 200dfd8:	14c5883a 	add	r2,r2,r19
 200dfdc:	80800015 	stw	r2,0(r16)
 200dfe0:	200463c0 	call	200463c <_fflush_r>
 200dfe4:	d8c00017 	ldw	r3,0(sp)
 200dfe8:	103fc81e 	bne	r2,zero,200df0c <__sfvwrite_r+0x1fc>
 200dfec:	b4edc83a 	sub	r22,r22,r19
 200dff0:	b03fe61e 	bne	r22,zero,200df8c <__sfvwrite_r+0x27c>
 200dff4:	a809883a 	mov	r4,r21
 200dff8:	800b883a 	mov	r5,r16
 200dffc:	200463c0 	call	200463c <_fflush_r>
 200e000:	103fc21e 	bne	r2,zero,200df0c <__sfvwrite_r+0x1fc>
 200e004:	0007883a 	mov	r3,zero
 200e008:	003fe006 	br	200df8c <__sfvwrite_r+0x27c>
 200e00c:	81000017 	ldw	r4,0(r16)
 200e010:	80800417 	ldw	r2,16(r16)
 200e014:	1100022e 	bgeu	r2,r4,200e020 <__sfvwrite_r+0x310>
 200e018:	9839883a 	mov	fp,r19
 200e01c:	9c806036 	bltu	r19,r18,200e1a0 <__sfvwrite_r+0x490>
 200e020:	81c00517 	ldw	r7,20(r16)
 200e024:	91c01c36 	bltu	r18,r7,200e098 <__sfvwrite_r+0x388>
 200e028:	80800917 	ldw	r2,36(r16)
 200e02c:	81400717 	ldw	r5,28(r16)
 200e030:	a809883a 	mov	r4,r21
 200e034:	b00d883a 	mov	r6,r22
 200e038:	103ee83a 	callr	r2
 200e03c:	1027883a 	mov	r19,r2
 200e040:	00bfb20e 	bge	zero,r2,200df0c <__sfvwrite_r+0x1fc>
 200e044:	1039883a 	mov	fp,r2
 200e048:	003f9806 	br	200deac <__sfvwrite_r+0x19c>
 200e04c:	b80d883a 	mov	r6,r23
 200e050:	e00b883a 	mov	r5,fp
 200e054:	d8c00015 	stw	r3,0(sp)
 200e058:	20067040 	call	2006704 <memmove>
 200e05c:	80800217 	ldw	r2,8(r16)
 200e060:	81000017 	ldw	r4,0(r16)
 200e064:	b827883a 	mov	r19,r23
 200e068:	15c5c83a 	sub	r2,r2,r23
 200e06c:	25ef883a 	add	r23,r4,r23
 200e070:	80800215 	stw	r2,8(r16)
 200e074:	85c00015 	stw	r23,0(r16)
 200e078:	d8c00017 	ldw	r3,0(sp)
 200e07c:	003fc106 	br	200df84 <__sfvwrite_r+0x274>
 200e080:	81000017 	ldw	r4,0(r16)
 200e084:	902f883a 	mov	r23,r18
 200e088:	9039883a 	mov	fp,r18
 200e08c:	9027883a 	mov	r19,r18
 200e090:	900f883a 	mov	r7,r18
 200e094:	003f7a06 	br	200de80 <__sfvwrite_r+0x170>
 200e098:	b00b883a 	mov	r5,r22
 200e09c:	900d883a 	mov	r6,r18
 200e0a0:	20067040 	call	2006704 <memmove>
 200e0a4:	80c00217 	ldw	r3,8(r16)
 200e0a8:	80800017 	ldw	r2,0(r16)
 200e0ac:	9027883a 	mov	r19,r18
 200e0b0:	1c87c83a 	sub	r3,r3,r18
 200e0b4:	1485883a 	add	r2,r2,r18
 200e0b8:	80c00215 	stw	r3,8(r16)
 200e0bc:	80800015 	stw	r2,0(r16)
 200e0c0:	9039883a 	mov	fp,r18
 200e0c4:	003f7906 	br	200deac <__sfvwrite_r+0x19c>
 200e0c8:	e009883a 	mov	r4,fp
 200e0cc:	01400284 	movi	r5,10
 200e0d0:	900d883a 	mov	r6,r18
 200e0d4:	200e4c00 	call	200e4c0 <memchr>
 200e0d8:	10003c26 	beq	r2,zero,200e1cc <__sfvwrite_r+0x4bc>
 200e0dc:	15800044 	addi	r22,r2,1
 200e0e0:	b72dc83a 	sub	r22,r22,fp
 200e0e4:	00c00044 	movi	r3,1
 200e0e8:	003f9206 	br	200df34 <__sfvwrite_r+0x224>
 200e0ec:	81000517 	ldw	r4,20(r16)
 200e0f0:	81400417 	ldw	r5,16(r16)
 200e0f4:	80c00017 	ldw	r3,0(r16)
 200e0f8:	210d883a 	add	r6,r4,r4
 200e0fc:	3109883a 	add	r4,r6,r4
 200e100:	2026d7fa 	srli	r19,r4,31
 200e104:	1979c83a 	sub	fp,r3,r5
 200e108:	e1800044 	addi	r6,fp,1
 200e10c:	9909883a 	add	r4,r19,r4
 200e110:	2027d07a 	srai	r19,r4,1
 200e114:	3489883a 	add	r4,r6,r18
 200e118:	980d883a 	mov	r6,r19
 200e11c:	9900022e 	bgeu	r19,r4,200e128 <__sfvwrite_r+0x418>
 200e120:	2027883a 	mov	r19,r4
 200e124:	200d883a 	mov	r6,r4
 200e128:	1081000c 	andi	r2,r2,1024
 200e12c:	10bfffcc 	andi	r2,r2,65535
 200e130:	10a0001c 	xori	r2,r2,32768
 200e134:	10a00004 	addi	r2,r2,-32768
 200e138:	a809883a 	mov	r4,r21
 200e13c:	103f6b26 	beq	r2,zero,200deec <__sfvwrite_r+0x1dc>
 200e140:	300b883a 	mov	r5,r6
 200e144:	2005e880 	call	2005e88 <_malloc_r>
 200e148:	102f883a 	mov	r23,r2
 200e14c:	103f6d26 	beq	r2,zero,200df04 <__sfvwrite_r+0x1f4>
 200e150:	81400417 	ldw	r5,16(r16)
 200e154:	1009883a 	mov	r4,r2
 200e158:	e00d883a 	mov	r6,fp
 200e15c:	200660c0 	call	200660c <memcpy>
 200e160:	8080030b 	ldhu	r2,12(r16)
 200e164:	00fedfc4 	movi	r3,-1153
 200e168:	10c4703a 	and	r2,r2,r3
 200e16c:	10802014 	ori	r2,r2,128
 200e170:	8080030d 	sth	r2,12(r16)
 200e174:	bf09883a 	add	r4,r23,fp
 200e178:	9f07c83a 	sub	r3,r19,fp
 200e17c:	85c00415 	stw	r23,16(r16)
 200e180:	84c00515 	stw	r19,20(r16)
 200e184:	81000015 	stw	r4,0(r16)
 200e188:	902f883a 	mov	r23,r18
 200e18c:	80c00215 	stw	r3,8(r16)
 200e190:	9039883a 	mov	fp,r18
 200e194:	9027883a 	mov	r19,r18
 200e198:	900f883a 	mov	r7,r18
 200e19c:	003f3806 	br	200de80 <__sfvwrite_r+0x170>
 200e1a0:	b00b883a 	mov	r5,r22
 200e1a4:	980d883a 	mov	r6,r19
 200e1a8:	20067040 	call	2006704 <memmove>
 200e1ac:	80800017 	ldw	r2,0(r16)
 200e1b0:	a809883a 	mov	r4,r21
 200e1b4:	800b883a 	mov	r5,r16
 200e1b8:	14c5883a 	add	r2,r2,r19
 200e1bc:	80800015 	stw	r2,0(r16)
 200e1c0:	200463c0 	call	200463c <_fflush_r>
 200e1c4:	103f3926 	beq	r2,zero,200deac <__sfvwrite_r+0x19c>
 200e1c8:	003f5006 	br	200df0c <__sfvwrite_r+0x1fc>
 200e1cc:	95800044 	addi	r22,r18,1
 200e1d0:	00c00044 	movi	r3,1
 200e1d4:	003f5706 	br	200df34 <__sfvwrite_r+0x224>
 200e1d8:	80c0030b 	ldhu	r3,12(r16)
 200e1dc:	00bfffc4 	movi	r2,-1
 200e1e0:	18c01014 	ori	r3,r3,64
 200e1e4:	80c0030d 	sth	r3,12(r16)
 200e1e8:	00c00244 	movi	r3,9
 200e1ec:	a8c00015 	stw	r3,0(r21)
 200e1f0:	003ef906 	br	200ddd8 <__sfvwrite_r+0xc8>

0200e1f4 <_isatty_r>:
 200e1f4:	defffd04 	addi	sp,sp,-12
 200e1f8:	dc400115 	stw	r17,4(sp)
 200e1fc:	dc000015 	stw	r16,0(sp)
 200e200:	2023883a 	mov	r17,r4
 200e204:	04008174 	movhi	r16,517
 200e208:	84108b04 	addi	r16,r16,16940
 200e20c:	2809883a 	mov	r4,r5
 200e210:	dfc00215 	stw	ra,8(sp)
 200e214:	80000015 	stw	zero,0(r16)
 200e218:	201522c0 	call	201522c <isatty>
 200e21c:	00ffffc4 	movi	r3,-1
 200e220:	10c00526 	beq	r2,r3,200e238 <_isatty_r+0x44>
 200e224:	dfc00217 	ldw	ra,8(sp)
 200e228:	dc400117 	ldw	r17,4(sp)
 200e22c:	dc000017 	ldw	r16,0(sp)
 200e230:	dec00304 	addi	sp,sp,12
 200e234:	f800283a 	ret
 200e238:	80c00017 	ldw	r3,0(r16)
 200e23c:	183ff926 	beq	r3,zero,200e224 <_isatty_r+0x30>
 200e240:	88c00015 	stw	r3,0(r17)
 200e244:	dfc00217 	ldw	ra,8(sp)
 200e248:	dc400117 	ldw	r17,4(sp)
 200e24c:	dc000017 	ldw	r16,0(sp)
 200e250:	dec00304 	addi	sp,sp,12
 200e254:	f800283a 	ret

0200e258 <iswspace>:
 200e258:	00803fc4 	movi	r2,255
 200e25c:	11000a36 	bltu	r2,r4,200e288 <iswspace+0x30>
 200e260:	00808174 	movhi	r2,517
 200e264:	10903404 	addi	r2,r2,16592
 200e268:	10800017 	ldw	r2,0(r2)
 200e26c:	1109883a 	add	r4,r2,r4
 200e270:	20800003 	ldbu	r2,0(r4)
 200e274:	1080020c 	andi	r2,r2,8
 200e278:	10803fcc 	andi	r2,r2,255
 200e27c:	1080201c 	xori	r2,r2,128
 200e280:	10bfe004 	addi	r2,r2,-128
 200e284:	f800283a 	ret
 200e288:	0005883a 	mov	r2,zero
 200e28c:	f800283a 	ret

0200e290 <_setlocale_r>:
 200e290:	defffc04 	addi	sp,sp,-16
 200e294:	dc800215 	stw	r18,8(sp)
 200e298:	dc400115 	stw	r17,4(sp)
 200e29c:	dc000015 	stw	r16,0(sp)
 200e2a0:	dfc00315 	stw	ra,12(sp)
 200e2a4:	3021883a 	mov	r16,r6
 200e2a8:	2023883a 	mov	r17,r4
 200e2ac:	2825883a 	mov	r18,r5
 200e2b0:	30001626 	beq	r6,zero,200e30c <_setlocale_r+0x7c>
 200e2b4:	3009883a 	mov	r4,r6
 200e2b8:	01408174 	movhi	r5,517
 200e2bc:	29759804 	addi	r5,r5,-10656
 200e2c0:	20074c80 	call	20074c8 <strcmp>
 200e2c4:	10000a1e 	bne	r2,zero,200e2f0 <_setlocale_r+0x60>
 200e2c8:	8c800c15 	stw	r18,48(r17)
 200e2cc:	8c000d15 	stw	r16,52(r17)
 200e2d0:	00808174 	movhi	r2,517
 200e2d4:	10b59804 	addi	r2,r2,-10656
 200e2d8:	dfc00317 	ldw	ra,12(sp)
 200e2dc:	dc800217 	ldw	r18,8(sp)
 200e2e0:	dc400117 	ldw	r17,4(sp)
 200e2e4:	dc000017 	ldw	r16,0(sp)
 200e2e8:	dec00404 	addi	sp,sp,16
 200e2ec:	f800283a 	ret
 200e2f0:	8009883a 	mov	r4,r16
 200e2f4:	01408174 	movhi	r5,517
 200e2f8:	29778c04 	addi	r5,r5,-8656
 200e2fc:	20074c80 	call	20074c8 <strcmp>
 200e300:	103ff126 	beq	r2,zero,200e2c8 <_setlocale_r+0x38>
 200e304:	0005883a 	mov	r2,zero
 200e308:	003ff306 	br	200e2d8 <_setlocale_r+0x48>
 200e30c:	00808174 	movhi	r2,517
 200e310:	10b59804 	addi	r2,r2,-10656
 200e314:	dfc00317 	ldw	ra,12(sp)
 200e318:	dc800217 	ldw	r18,8(sp)
 200e31c:	dc400117 	ldw	r17,4(sp)
 200e320:	dc000017 	ldw	r16,0(sp)
 200e324:	dec00404 	addi	sp,sp,16
 200e328:	f800283a 	ret

0200e32c <__locale_charset>:
 200e32c:	00808174 	movhi	r2,517
 200e330:	10b7ab04 	addi	r2,r2,-8532
 200e334:	f800283a 	ret

0200e338 <_localeconv_r>:
 200e338:	00808174 	movhi	r2,517
 200e33c:	10b7af04 	addi	r2,r2,-8516
 200e340:	f800283a 	ret

0200e344 <setlocale>:
 200e344:	00c08174 	movhi	r3,517
 200e348:	18d03604 	addi	r3,r3,16600
 200e34c:	2005883a 	mov	r2,r4
 200e350:	19000017 	ldw	r4,0(r3)
 200e354:	280d883a 	mov	r6,r5
 200e358:	100b883a 	mov	r5,r2
 200e35c:	200e2901 	jmpi	200e290 <_setlocale_r>

0200e360 <localeconv>:
 200e360:	00808174 	movhi	r2,517
 200e364:	10b7af04 	addi	r2,r2,-8516
 200e368:	f800283a 	ret

0200e36c <_lseek_r>:
 200e36c:	defffd04 	addi	sp,sp,-12
 200e370:	dc400115 	stw	r17,4(sp)
 200e374:	dc000015 	stw	r16,0(sp)
 200e378:	2023883a 	mov	r17,r4
 200e37c:	04008174 	movhi	r16,517
 200e380:	84108b04 	addi	r16,r16,16940
 200e384:	2809883a 	mov	r4,r5
 200e388:	300b883a 	mov	r5,r6
 200e38c:	380d883a 	mov	r6,r7
 200e390:	dfc00215 	stw	ra,8(sp)
 200e394:	80000015 	stw	zero,0(r16)
 200e398:	201531c0 	call	201531c <lseek>
 200e39c:	00ffffc4 	movi	r3,-1
 200e3a0:	10c00526 	beq	r2,r3,200e3b8 <_lseek_r+0x4c>
 200e3a4:	dfc00217 	ldw	ra,8(sp)
 200e3a8:	dc400117 	ldw	r17,4(sp)
 200e3ac:	dc000017 	ldw	r16,0(sp)
 200e3b0:	dec00304 	addi	sp,sp,12
 200e3b4:	f800283a 	ret
 200e3b8:	80c00017 	ldw	r3,0(r16)
 200e3bc:	183ff926 	beq	r3,zero,200e3a4 <_lseek_r+0x38>
 200e3c0:	88c00015 	stw	r3,0(r17)
 200e3c4:	dfc00217 	ldw	ra,8(sp)
 200e3c8:	dc400117 	ldw	r17,4(sp)
 200e3cc:	dc000017 	ldw	r16,0(sp)
 200e3d0:	dec00304 	addi	sp,sp,12
 200e3d4:	f800283a 	ret

0200e3d8 <_mbrtowc_r>:
 200e3d8:	defffc04 	addi	sp,sp,-16
 200e3dc:	dc000115 	stw	r16,4(sp)
 200e3e0:	dc000417 	ldw	r16,16(sp)
 200e3e4:	dc400215 	stw	r17,8(sp)
 200e3e8:	dfc00315 	stw	ra,12(sp)
 200e3ec:	dc000015 	stw	r16,0(sp)
 200e3f0:	2023883a 	mov	r17,r4
 200e3f4:	30000b26 	beq	r6,zero,200e424 <_mbrtowc_r+0x4c>
 200e3f8:	200e47c0 	call	200e47c <_mbtowc_r>
 200e3fc:	00ffffc4 	movi	r3,-1
 200e400:	10c0031e 	bne	r2,r3,200e410 <_mbrtowc_r+0x38>
 200e404:	80000015 	stw	zero,0(r16)
 200e408:	00c02284 	movi	r3,138
 200e40c:	88c00015 	stw	r3,0(r17)
 200e410:	dfc00317 	ldw	ra,12(sp)
 200e414:	dc400217 	ldw	r17,8(sp)
 200e418:	dc000117 	ldw	r16,4(sp)
 200e41c:	dec00404 	addi	sp,sp,16
 200e420:	f800283a 	ret
 200e424:	000b883a 	mov	r5,zero
 200e428:	01808174 	movhi	r6,517
 200e42c:	31b78c04 	addi	r6,r6,-8656
 200e430:	01c00044 	movi	r7,1
 200e434:	200e47c0 	call	200e47c <_mbtowc_r>
 200e438:	003ff006 	br	200e3fc <_mbrtowc_r+0x24>

0200e43c <mbrtowc>:
 200e43c:	00808174 	movhi	r2,517
 200e440:	10903604 	addi	r2,r2,16600
 200e444:	2011883a 	mov	r8,r4
 200e448:	11000017 	ldw	r4,0(r2)
 200e44c:	defffe04 	addi	sp,sp,-8
 200e450:	2807883a 	mov	r3,r5
 200e454:	3005883a 	mov	r2,r6
 200e458:	d9c00015 	stw	r7,0(sp)
 200e45c:	400b883a 	mov	r5,r8
 200e460:	180d883a 	mov	r6,r3
 200e464:	100f883a 	mov	r7,r2
 200e468:	dfc00115 	stw	ra,4(sp)
 200e46c:	200e3d80 	call	200e3d8 <_mbrtowc_r>
 200e470:	dfc00117 	ldw	ra,4(sp)
 200e474:	dec00204 	addi	sp,sp,8
 200e478:	f800283a 	ret

0200e47c <_mbtowc_r>:
 200e47c:	deffff04 	addi	sp,sp,-4
 200e480:	28000826 	beq	r5,zero,200e4a4 <_mbtowc_r+0x28>
 200e484:	30000926 	beq	r6,zero,200e4ac <_mbtowc_r+0x30>
 200e488:	38000b26 	beq	r7,zero,200e4b8 <_mbtowc_r+0x3c>
 200e48c:	30800003 	ldbu	r2,0(r6)
 200e490:	28800015 	stw	r2,0(r5)
 200e494:	30800003 	ldbu	r2,0(r6)
 200e498:	1004c03a 	cmpne	r2,r2,zero
 200e49c:	dec00104 	addi	sp,sp,4
 200e4a0:	f800283a 	ret
 200e4a4:	d80b883a 	mov	r5,sp
 200e4a8:	303ff71e 	bne	r6,zero,200e488 <_mbtowc_r+0xc>
 200e4ac:	0005883a 	mov	r2,zero
 200e4b0:	dec00104 	addi	sp,sp,4
 200e4b4:	f800283a 	ret
 200e4b8:	00bfff84 	movi	r2,-2
 200e4bc:	003ff706 	br	200e49c <_mbtowc_r+0x20>

0200e4c0 <memchr>:
 200e4c0:	008000c4 	movi	r2,3
 200e4c4:	29403fcc 	andi	r5,r5,255
 200e4c8:	1180282e 	bgeu	r2,r6,200e56c <memchr+0xac>
 200e4cc:	2086703a 	and	r3,r4,r2
 200e4d0:	1800351e 	bne	r3,zero,200e5a8 <memchr+0xe8>
 200e4d4:	2816923a 	slli	r11,r5,8
 200e4d8:	2093883a 	add	r9,r4,r2
 200e4dc:	22000084 	addi	r8,r4,2
 200e4e0:	5957883a 	add	r11,r11,r5
 200e4e4:	5816923a 	slli	r11,r11,8
 200e4e8:	20c00044 	addi	r3,r4,1
 200e4ec:	037fbff4 	movhi	r13,65279
 200e4f0:	6b7fbfc4 	addi	r13,r13,-257
 200e4f4:	5957883a 	add	r11,r11,r5
 200e4f8:	5816923a 	slli	r11,r11,8
 200e4fc:	03202074 	movhi	r12,32897
 200e500:	63202004 	addi	r12,r12,-32640
 200e504:	101d883a 	mov	r14,r2
 200e508:	5957883a 	add	r11,r11,r5
 200e50c:	21c00017 	ldw	r7,0(r4)
 200e510:	31bfff04 	addi	r6,r6,-4
 200e514:	1805883a 	mov	r2,r3
 200e518:	3acef03a 	xor	r7,r7,r11
 200e51c:	3b55883a 	add	r10,r7,r13
 200e520:	01ce303a 	nor	r7,zero,r7
 200e524:	51ce703a 	and	r7,r10,r7
 200e528:	3b0e703a 	and	r7,r7,r12
 200e52c:	38000a26 	beq	r7,zero,200e558 <memchr+0x98>
 200e530:	21c00003 	ldbu	r7,0(r4)
 200e534:	39401e26 	beq	r7,r5,200e5b0 <memchr+0xf0>
 200e538:	19c00003 	ldbu	r7,0(r3)
 200e53c:	39401926 	beq	r7,r5,200e5a4 <memchr+0xe4>
 200e540:	41c00003 	ldbu	r7,0(r8)
 200e544:	4005883a 	mov	r2,r8
 200e548:	39401626 	beq	r7,r5,200e5a4 <memchr+0xe4>
 200e54c:	49c00003 	ldbu	r7,0(r9)
 200e550:	4805883a 	mov	r2,r9
 200e554:	39401326 	beq	r7,r5,200e5a4 <memchr+0xe4>
 200e558:	21000104 	addi	r4,r4,4
 200e55c:	4a400104 	addi	r9,r9,4
 200e560:	42000104 	addi	r8,r8,4
 200e564:	18c00104 	addi	r3,r3,4
 200e568:	71bfe836 	bltu	r14,r6,200e50c <memchr+0x4c>
 200e56c:	2005883a 	mov	r2,r4
 200e570:	30000a26 	beq	r6,zero,200e59c <memchr+0xdc>
 200e574:	10c00003 	ldbu	r3,0(r2)
 200e578:	19400a26 	beq	r3,r5,200e5a4 <memchr+0xe4>
 200e57c:	10c00044 	addi	r3,r2,1
 200e580:	118d883a 	add	r6,r2,r6
 200e584:	00000306 	br	200e594 <memchr+0xd4>
 200e588:	11000003 	ldbu	r4,0(r2)
 200e58c:	18c00044 	addi	r3,r3,1
 200e590:	21400426 	beq	r4,r5,200e5a4 <memchr+0xe4>
 200e594:	1805883a 	mov	r2,r3
 200e598:	19bffb1e 	bne	r3,r6,200e588 <memchr+0xc8>
 200e59c:	0005883a 	mov	r2,zero
 200e5a0:	f800283a 	ret
 200e5a4:	f800283a 	ret
 200e5a8:	2005883a 	mov	r2,r4
 200e5ac:	003ff106 	br	200e574 <memchr+0xb4>
 200e5b0:	2005883a 	mov	r2,r4
 200e5b4:	f800283a 	ret

0200e5b8 <memcmp>:
 200e5b8:	01c000c4 	movi	r7,3
 200e5bc:	3980192e 	bgeu	r7,r6,200e624 <memcmp+0x6c>
 200e5c0:	2904b03a 	or	r2,r5,r4
 200e5c4:	11c4703a 	and	r2,r2,r7
 200e5c8:	10000f26 	beq	r2,zero,200e608 <memcmp+0x50>
 200e5cc:	20c00003 	ldbu	r3,0(r4)
 200e5d0:	28800003 	ldbu	r2,0(r5)
 200e5d4:	1880151e 	bne	r3,r2,200e62c <memcmp+0x74>
 200e5d8:	31bfff84 	addi	r6,r6,-2
 200e5dc:	01ffffc4 	movi	r7,-1
 200e5e0:	00000406 	br	200e5f4 <memcmp+0x3c>
 200e5e4:	20c00003 	ldbu	r3,0(r4)
 200e5e8:	28800003 	ldbu	r2,0(r5)
 200e5ec:	31bfffc4 	addi	r6,r6,-1
 200e5f0:	18800e1e 	bne	r3,r2,200e62c <memcmp+0x74>
 200e5f4:	21000044 	addi	r4,r4,1
 200e5f8:	29400044 	addi	r5,r5,1
 200e5fc:	31fff91e 	bne	r6,r7,200e5e4 <memcmp+0x2c>
 200e600:	0005883a 	mov	r2,zero
 200e604:	f800283a 	ret
 200e608:	20c00017 	ldw	r3,0(r4)
 200e60c:	28800017 	ldw	r2,0(r5)
 200e610:	1880041e 	bne	r3,r2,200e624 <memcmp+0x6c>
 200e614:	31bfff04 	addi	r6,r6,-4
 200e618:	21000104 	addi	r4,r4,4
 200e61c:	29400104 	addi	r5,r5,4
 200e620:	39bff936 	bltu	r7,r6,200e608 <memcmp+0x50>
 200e624:	303fe91e 	bne	r6,zero,200e5cc <memcmp+0x14>
 200e628:	003ff506 	br	200e600 <memcmp+0x48>
 200e62c:	1885c83a 	sub	r2,r3,r2
 200e630:	f800283a 	ret

0200e634 <_Balloc>:
 200e634:	20801317 	ldw	r2,76(r4)
 200e638:	defffc04 	addi	sp,sp,-16
 200e63c:	dc400115 	stw	r17,4(sp)
 200e640:	dc000015 	stw	r16,0(sp)
 200e644:	dfc00315 	stw	ra,12(sp)
 200e648:	dc800215 	stw	r18,8(sp)
 200e64c:	2023883a 	mov	r17,r4
 200e650:	2821883a 	mov	r16,r5
 200e654:	10000f26 	beq	r2,zero,200e694 <_Balloc+0x60>
 200e658:	8407883a 	add	r3,r16,r16
 200e65c:	18c7883a 	add	r3,r3,r3
 200e660:	10c7883a 	add	r3,r2,r3
 200e664:	18800017 	ldw	r2,0(r3)
 200e668:	10001126 	beq	r2,zero,200e6b0 <_Balloc+0x7c>
 200e66c:	11000017 	ldw	r4,0(r2)
 200e670:	19000015 	stw	r4,0(r3)
 200e674:	10000415 	stw	zero,16(r2)
 200e678:	10000315 	stw	zero,12(r2)
 200e67c:	dfc00317 	ldw	ra,12(sp)
 200e680:	dc800217 	ldw	r18,8(sp)
 200e684:	dc400117 	ldw	r17,4(sp)
 200e688:	dc000017 	ldw	r16,0(sp)
 200e68c:	dec00404 	addi	sp,sp,16
 200e690:	f800283a 	ret
 200e694:	01400104 	movi	r5,4
 200e698:	01800404 	movi	r6,16
 200e69c:	2011f1c0 	call	2011f1c <_calloc_r>
 200e6a0:	88801315 	stw	r2,76(r17)
 200e6a4:	103fec1e 	bne	r2,zero,200e658 <_Balloc+0x24>
 200e6a8:	0005883a 	mov	r2,zero
 200e6ac:	003ff306 	br	200e67c <_Balloc+0x48>
 200e6b0:	01400044 	movi	r5,1
 200e6b4:	2c24983a 	sll	r18,r5,r16
 200e6b8:	8809883a 	mov	r4,r17
 200e6bc:	91800144 	addi	r6,r18,5
 200e6c0:	318d883a 	add	r6,r6,r6
 200e6c4:	318d883a 	add	r6,r6,r6
 200e6c8:	2011f1c0 	call	2011f1c <_calloc_r>
 200e6cc:	103ff626 	beq	r2,zero,200e6a8 <_Balloc+0x74>
 200e6d0:	14000115 	stw	r16,4(r2)
 200e6d4:	14800215 	stw	r18,8(r2)
 200e6d8:	003fe606 	br	200e674 <_Balloc+0x40>

0200e6dc <_Bfree>:
 200e6dc:	28000826 	beq	r5,zero,200e700 <_Bfree+0x24>
 200e6e0:	28c00117 	ldw	r3,4(r5)
 200e6e4:	20801317 	ldw	r2,76(r4)
 200e6e8:	18c7883a 	add	r3,r3,r3
 200e6ec:	18c7883a 	add	r3,r3,r3
 200e6f0:	10c5883a 	add	r2,r2,r3
 200e6f4:	10c00017 	ldw	r3,0(r2)
 200e6f8:	28c00015 	stw	r3,0(r5)
 200e6fc:	11400015 	stw	r5,0(r2)
 200e700:	f800283a 	ret

0200e704 <__multadd>:
 200e704:	defffa04 	addi	sp,sp,-24
 200e708:	dc000115 	stw	r16,4(sp)
 200e70c:	2c000417 	ldw	r16,16(r5)
 200e710:	dc800315 	stw	r18,12(sp)
 200e714:	dc400215 	stw	r17,8(sp)
 200e718:	dfc00515 	stw	ra,20(sp)
 200e71c:	dcc00415 	stw	r19,16(sp)
 200e720:	2823883a 	mov	r17,r5
 200e724:	2025883a 	mov	r18,r4
 200e728:	28c00504 	addi	r3,r5,20
 200e72c:	0011883a 	mov	r8,zero
 200e730:	1a800017 	ldw	r10,0(r3)
 200e734:	18c00104 	addi	r3,r3,4
 200e738:	42000044 	addi	r8,r8,1
 200e73c:	527fffcc 	andi	r9,r10,65535
 200e740:	4993383a 	mul	r9,r9,r6
 200e744:	5014d43a 	srli	r10,r10,16
 200e748:	49d3883a 	add	r9,r9,r7
 200e74c:	480ed43a 	srli	r7,r9,16
 200e750:	5195383a 	mul	r10,r10,r6
 200e754:	4a7fffcc 	andi	r9,r9,65535
 200e758:	3a8f883a 	add	r7,r7,r10
 200e75c:	3814943a 	slli	r10,r7,16
 200e760:	380ed43a 	srli	r7,r7,16
 200e764:	5253883a 	add	r9,r10,r9
 200e768:	1a7fff15 	stw	r9,-4(r3)
 200e76c:	443ff016 	blt	r8,r16,200e730 <__multadd+0x2c>
 200e770:	38000926 	beq	r7,zero,200e798 <__multadd+0x94>
 200e774:	88800217 	ldw	r2,8(r17)
 200e778:	80800f0e 	bge	r16,r2,200e7b8 <__multadd+0xb4>
 200e77c:	80800144 	addi	r2,r16,5
 200e780:	1085883a 	add	r2,r2,r2
 200e784:	1085883a 	add	r2,r2,r2
 200e788:	8885883a 	add	r2,r17,r2
 200e78c:	84000044 	addi	r16,r16,1
 200e790:	11c00015 	stw	r7,0(r2)
 200e794:	8c000415 	stw	r16,16(r17)
 200e798:	8805883a 	mov	r2,r17
 200e79c:	dfc00517 	ldw	ra,20(sp)
 200e7a0:	dcc00417 	ldw	r19,16(sp)
 200e7a4:	dc800317 	ldw	r18,12(sp)
 200e7a8:	dc400217 	ldw	r17,8(sp)
 200e7ac:	dc000117 	ldw	r16,4(sp)
 200e7b0:	dec00604 	addi	sp,sp,24
 200e7b4:	f800283a 	ret
 200e7b8:	89400117 	ldw	r5,4(r17)
 200e7bc:	9009883a 	mov	r4,r18
 200e7c0:	d9c00015 	stw	r7,0(sp)
 200e7c4:	29400044 	addi	r5,r5,1
 200e7c8:	200e6340 	call	200e634 <_Balloc>
 200e7cc:	89800417 	ldw	r6,16(r17)
 200e7d0:	89400304 	addi	r5,r17,12
 200e7d4:	11000304 	addi	r4,r2,12
 200e7d8:	31800084 	addi	r6,r6,2
 200e7dc:	318d883a 	add	r6,r6,r6
 200e7e0:	318d883a 	add	r6,r6,r6
 200e7e4:	1027883a 	mov	r19,r2
 200e7e8:	200660c0 	call	200660c <memcpy>
 200e7ec:	88c00117 	ldw	r3,4(r17)
 200e7f0:	90801317 	ldw	r2,76(r18)
 200e7f4:	d9c00017 	ldw	r7,0(sp)
 200e7f8:	18c7883a 	add	r3,r3,r3
 200e7fc:	18c7883a 	add	r3,r3,r3
 200e800:	10c5883a 	add	r2,r2,r3
 200e804:	10c00017 	ldw	r3,0(r2)
 200e808:	88c00015 	stw	r3,0(r17)
 200e80c:	14400015 	stw	r17,0(r2)
 200e810:	9823883a 	mov	r17,r19
 200e814:	003fd906 	br	200e77c <__multadd+0x78>

0200e818 <__s2b>:
 200e818:	defff904 	addi	sp,sp,-28
 200e81c:	dd000415 	stw	r20,16(sp)
 200e820:	dc400115 	stw	r17,4(sp)
 200e824:	2829883a 	mov	r20,r5
 200e828:	2023883a 	mov	r17,r4
 200e82c:	01400244 	movi	r5,9
 200e830:	39000204 	addi	r4,r7,8
 200e834:	dcc00315 	stw	r19,12(sp)
 200e838:	dc800215 	stw	r18,8(sp)
 200e83c:	dfc00615 	stw	ra,24(sp)
 200e840:	dd400515 	stw	r21,20(sp)
 200e844:	dc000015 	stw	r16,0(sp)
 200e848:	3825883a 	mov	r18,r7
 200e84c:	3027883a 	mov	r19,r6
 200e850:	20146f00 	call	20146f0 <__divsi3>
 200e854:	00c00044 	movi	r3,1
 200e858:	000b883a 	mov	r5,zero
 200e85c:	1880030e 	bge	r3,r2,200e86c <__s2b+0x54>
 200e860:	18c7883a 	add	r3,r3,r3
 200e864:	29400044 	addi	r5,r5,1
 200e868:	18bffd16 	blt	r3,r2,200e860 <__s2b+0x48>
 200e86c:	8809883a 	mov	r4,r17
 200e870:	200e6340 	call	200e634 <_Balloc>
 200e874:	d8c00717 	ldw	r3,28(sp)
 200e878:	10c00515 	stw	r3,20(r2)
 200e87c:	00c00044 	movi	r3,1
 200e880:	10c00415 	stw	r3,16(r2)
 200e884:	00c00244 	movi	r3,9
 200e888:	1cc0210e 	bge	r3,r19,200e910 <__s2b+0xf8>
 200e88c:	a0eb883a 	add	r21,r20,r3
 200e890:	a821883a 	mov	r16,r21
 200e894:	a4e9883a 	add	r20,r20,r19
 200e898:	81c00007 	ldb	r7,0(r16)
 200e89c:	8809883a 	mov	r4,r17
 200e8a0:	84000044 	addi	r16,r16,1
 200e8a4:	100b883a 	mov	r5,r2
 200e8a8:	01800284 	movi	r6,10
 200e8ac:	39fff404 	addi	r7,r7,-48
 200e8b0:	200e7040 	call	200e704 <__multadd>
 200e8b4:	853ff81e 	bne	r16,r20,200e898 <__s2b+0x80>
 200e8b8:	ace1883a 	add	r16,r21,r19
 200e8bc:	843ffe04 	addi	r16,r16,-8
 200e8c0:	9c800a0e 	bge	r19,r18,200e8ec <__s2b+0xd4>
 200e8c4:	94e5c83a 	sub	r18,r18,r19
 200e8c8:	84a5883a 	add	r18,r16,r18
 200e8cc:	81c00007 	ldb	r7,0(r16)
 200e8d0:	8809883a 	mov	r4,r17
 200e8d4:	84000044 	addi	r16,r16,1
 200e8d8:	100b883a 	mov	r5,r2
 200e8dc:	01800284 	movi	r6,10
 200e8e0:	39fff404 	addi	r7,r7,-48
 200e8e4:	200e7040 	call	200e704 <__multadd>
 200e8e8:	84bff81e 	bne	r16,r18,200e8cc <__s2b+0xb4>
 200e8ec:	dfc00617 	ldw	ra,24(sp)
 200e8f0:	dd400517 	ldw	r21,20(sp)
 200e8f4:	dd000417 	ldw	r20,16(sp)
 200e8f8:	dcc00317 	ldw	r19,12(sp)
 200e8fc:	dc800217 	ldw	r18,8(sp)
 200e900:	dc400117 	ldw	r17,4(sp)
 200e904:	dc000017 	ldw	r16,0(sp)
 200e908:	dec00704 	addi	sp,sp,28
 200e90c:	f800283a 	ret
 200e910:	a4000284 	addi	r16,r20,10
 200e914:	1827883a 	mov	r19,r3
 200e918:	003fe906 	br	200e8c0 <__s2b+0xa8>

0200e91c <__hi0bits>:
 200e91c:	20bfffec 	andhi	r2,r4,65535
 200e920:	1000141e 	bne	r2,zero,200e974 <__hi0bits+0x58>
 200e924:	2008943a 	slli	r4,r4,16
 200e928:	00800404 	movi	r2,16
 200e92c:	20ffc02c 	andhi	r3,r4,65280
 200e930:	1800021e 	bne	r3,zero,200e93c <__hi0bits+0x20>
 200e934:	2008923a 	slli	r4,r4,8
 200e938:	10800204 	addi	r2,r2,8
 200e93c:	20fc002c 	andhi	r3,r4,61440
 200e940:	1800021e 	bne	r3,zero,200e94c <__hi0bits+0x30>
 200e944:	2008913a 	slli	r4,r4,4
 200e948:	10800104 	addi	r2,r2,4
 200e94c:	20f0002c 	andhi	r3,r4,49152
 200e950:	1800031e 	bne	r3,zero,200e960 <__hi0bits+0x44>
 200e954:	2109883a 	add	r4,r4,r4
 200e958:	10800084 	addi	r2,r2,2
 200e95c:	2109883a 	add	r4,r4,r4
 200e960:	20000316 	blt	r4,zero,200e970 <__hi0bits+0x54>
 200e964:	2110002c 	andhi	r4,r4,16384
 200e968:	2000041e 	bne	r4,zero,200e97c <__hi0bits+0x60>
 200e96c:	00800804 	movi	r2,32
 200e970:	f800283a 	ret
 200e974:	0005883a 	mov	r2,zero
 200e978:	003fec06 	br	200e92c <__hi0bits+0x10>
 200e97c:	10800044 	addi	r2,r2,1
 200e980:	f800283a 	ret

0200e984 <__lo0bits>:
 200e984:	20c00017 	ldw	r3,0(r4)
 200e988:	188001cc 	andi	r2,r3,7
 200e98c:	10000826 	beq	r2,zero,200e9b0 <__lo0bits+0x2c>
 200e990:	1880004c 	andi	r2,r3,1
 200e994:	1000211e 	bne	r2,zero,200ea1c <__lo0bits+0x98>
 200e998:	1880008c 	andi	r2,r3,2
 200e99c:	1000211e 	bne	r2,zero,200ea24 <__lo0bits+0xa0>
 200e9a0:	1806d0ba 	srli	r3,r3,2
 200e9a4:	00800084 	movi	r2,2
 200e9a8:	20c00015 	stw	r3,0(r4)
 200e9ac:	f800283a 	ret
 200e9b0:	18bfffcc 	andi	r2,r3,65535
 200e9b4:	10001326 	beq	r2,zero,200ea04 <__lo0bits+0x80>
 200e9b8:	0005883a 	mov	r2,zero
 200e9bc:	19403fcc 	andi	r5,r3,255
 200e9c0:	2800021e 	bne	r5,zero,200e9cc <__lo0bits+0x48>
 200e9c4:	1806d23a 	srli	r3,r3,8
 200e9c8:	10800204 	addi	r2,r2,8
 200e9cc:	194003cc 	andi	r5,r3,15
 200e9d0:	2800021e 	bne	r5,zero,200e9dc <__lo0bits+0x58>
 200e9d4:	1806d13a 	srli	r3,r3,4
 200e9d8:	10800104 	addi	r2,r2,4
 200e9dc:	194000cc 	andi	r5,r3,3
 200e9e0:	2800021e 	bne	r5,zero,200e9ec <__lo0bits+0x68>
 200e9e4:	1806d0ba 	srli	r3,r3,2
 200e9e8:	10800084 	addi	r2,r2,2
 200e9ec:	1940004c 	andi	r5,r3,1
 200e9f0:	2800081e 	bne	r5,zero,200ea14 <__lo0bits+0x90>
 200e9f4:	1806d07a 	srli	r3,r3,1
 200e9f8:	1800051e 	bne	r3,zero,200ea10 <__lo0bits+0x8c>
 200e9fc:	00800804 	movi	r2,32
 200ea00:	f800283a 	ret
 200ea04:	1806d43a 	srli	r3,r3,16
 200ea08:	00800404 	movi	r2,16
 200ea0c:	003feb06 	br	200e9bc <__lo0bits+0x38>
 200ea10:	10800044 	addi	r2,r2,1
 200ea14:	20c00015 	stw	r3,0(r4)
 200ea18:	f800283a 	ret
 200ea1c:	0005883a 	mov	r2,zero
 200ea20:	f800283a 	ret
 200ea24:	1806d07a 	srli	r3,r3,1
 200ea28:	00800044 	movi	r2,1
 200ea2c:	20c00015 	stw	r3,0(r4)
 200ea30:	f800283a 	ret

0200ea34 <__i2b>:
 200ea34:	defffd04 	addi	sp,sp,-12
 200ea38:	dc000015 	stw	r16,0(sp)
 200ea3c:	04000044 	movi	r16,1
 200ea40:	dc400115 	stw	r17,4(sp)
 200ea44:	2823883a 	mov	r17,r5
 200ea48:	800b883a 	mov	r5,r16
 200ea4c:	dfc00215 	stw	ra,8(sp)
 200ea50:	200e6340 	call	200e634 <_Balloc>
 200ea54:	14400515 	stw	r17,20(r2)
 200ea58:	14000415 	stw	r16,16(r2)
 200ea5c:	dfc00217 	ldw	ra,8(sp)
 200ea60:	dc400117 	ldw	r17,4(sp)
 200ea64:	dc000017 	ldw	r16,0(sp)
 200ea68:	dec00304 	addi	sp,sp,12
 200ea6c:	f800283a 	ret

0200ea70 <__multiply>:
 200ea70:	defffa04 	addi	sp,sp,-24
 200ea74:	dcc00315 	stw	r19,12(sp)
 200ea78:	dc400115 	stw	r17,4(sp)
 200ea7c:	34c00417 	ldw	r19,16(r6)
 200ea80:	2c400417 	ldw	r17,16(r5)
 200ea84:	dd000415 	stw	r20,16(sp)
 200ea88:	dc800215 	stw	r18,8(sp)
 200ea8c:	dfc00515 	stw	ra,20(sp)
 200ea90:	dc000015 	stw	r16,0(sp)
 200ea94:	2825883a 	mov	r18,r5
 200ea98:	3029883a 	mov	r20,r6
 200ea9c:	8cc0050e 	bge	r17,r19,200eab4 <__multiply+0x44>
 200eaa0:	8807883a 	mov	r3,r17
 200eaa4:	3025883a 	mov	r18,r6
 200eaa8:	9823883a 	mov	r17,r19
 200eaac:	2829883a 	mov	r20,r5
 200eab0:	1827883a 	mov	r19,r3
 200eab4:	90800217 	ldw	r2,8(r18)
 200eab8:	8ce1883a 	add	r16,r17,r19
 200eabc:	91400117 	ldw	r5,4(r18)
 200eac0:	1400010e 	bge	r2,r16,200eac8 <__multiply+0x58>
 200eac4:	29400044 	addi	r5,r5,1
 200eac8:	200e6340 	call	200e634 <_Balloc>
 200eacc:	83c00144 	addi	r15,r16,5
 200ead0:	7bdf883a 	add	r15,r15,r15
 200ead4:	7bdf883a 	add	r15,r15,r15
 200ead8:	13800504 	addi	r14,r2,20
 200eadc:	13df883a 	add	r15,r2,r15
 200eae0:	7007883a 	mov	r3,r14
 200eae4:	73c0032e 	bgeu	r14,r15,200eaf4 <__multiply+0x84>
 200eae8:	18000015 	stw	zero,0(r3)
 200eaec:	18c00104 	addi	r3,r3,4
 200eaf0:	1bfffd36 	bltu	r3,r15,200eae8 <__multiply+0x78>
 200eaf4:	99800144 	addi	r6,r19,5
 200eaf8:	8b000144 	addi	r12,r17,5
 200eafc:	318d883a 	add	r6,r6,r6
 200eb00:	6319883a 	add	r12,r12,r12
 200eb04:	318d883a 	add	r6,r6,r6
 200eb08:	6319883a 	add	r12,r12,r12
 200eb0c:	a3400504 	addi	r13,r20,20
 200eb10:	a18d883a 	add	r6,r20,r6
 200eb14:	94400504 	addi	r17,r18,20
 200eb18:	9319883a 	add	r12,r18,r12
 200eb1c:	6980392e 	bgeu	r13,r6,200ec04 <__multiply+0x194>
 200eb20:	6a800017 	ldw	r10,0(r13)
 200eb24:	52ffffcc 	andi	r11,r10,65535
 200eb28:	58001826 	beq	r11,zero,200eb8c <__multiply+0x11c>
 200eb2c:	7007883a 	mov	r3,r14
 200eb30:	8809883a 	mov	r4,r17
 200eb34:	000b883a 	mov	r5,zero
 200eb38:	22400017 	ldw	r9,0(r4)
 200eb3c:	1a000017 	ldw	r8,0(r3)
 200eb40:	21000104 	addi	r4,r4,4
 200eb44:	49ffffcc 	andi	r7,r9,65535
 200eb48:	3acf383a 	mul	r7,r7,r11
 200eb4c:	4812d43a 	srli	r9,r9,16
 200eb50:	42bfffcc 	andi	r10,r8,65535
 200eb54:	3a8f883a 	add	r7,r7,r10
 200eb58:	394f883a 	add	r7,r7,r5
 200eb5c:	4010d43a 	srli	r8,r8,16
 200eb60:	4acb383a 	mul	r5,r9,r11
 200eb64:	3814d43a 	srli	r10,r7,16
 200eb68:	19c0000d 	sth	r7,0(r3)
 200eb6c:	2a0b883a 	add	r5,r5,r8
 200eb70:	2a8b883a 	add	r5,r5,r10
 200eb74:	1940008d 	sth	r5,2(r3)
 200eb78:	280ad43a 	srli	r5,r5,16
 200eb7c:	18c00104 	addi	r3,r3,4
 200eb80:	233fed36 	bltu	r4,r12,200eb38 <__multiply+0xc8>
 200eb84:	19400015 	stw	r5,0(r3)
 200eb88:	6a800017 	ldw	r10,0(r13)
 200eb8c:	5014d43a 	srli	r10,r10,16
 200eb90:	50001926 	beq	r10,zero,200ebf8 <__multiply+0x188>
 200eb94:	71400017 	ldw	r5,0(r14)
 200eb98:	7007883a 	mov	r3,r14
 200eb9c:	8809883a 	mov	r4,r17
 200eba0:	280f883a 	mov	r7,r5
 200eba4:	0017883a 	mov	r11,zero
 200eba8:	22400017 	ldw	r9,0(r4)
 200ebac:	380ed43a 	srli	r7,r7,16
 200ebb0:	1940000d 	sth	r5,0(r3)
 200ebb4:	4a3fffcc 	andi	r8,r9,65535
 200ebb8:	4291383a 	mul	r8,r8,r10
 200ebbc:	4812d43a 	srli	r9,r9,16
 200ebc0:	18c00104 	addi	r3,r3,4
 200ebc4:	41d1883a 	add	r8,r8,r7
 200ebc8:	19c00017 	ldw	r7,0(r3)
 200ebcc:	42d1883a 	add	r8,r8,r11
 200ebd0:	4a93383a 	mul	r9,r9,r10
 200ebd4:	1a3fff8d 	sth	r8,-2(r3)
 200ebd8:	4010d43a 	srli	r8,r8,16
 200ebdc:	397fffcc 	andi	r5,r7,65535
 200ebe0:	2a4b883a 	add	r5,r5,r9
 200ebe4:	2a0b883a 	add	r5,r5,r8
 200ebe8:	21000104 	addi	r4,r4,4
 200ebec:	2816d43a 	srli	r11,r5,16
 200ebf0:	233fed36 	bltu	r4,r12,200eba8 <__multiply+0x138>
 200ebf4:	19400015 	stw	r5,0(r3)
 200ebf8:	6b400104 	addi	r13,r13,4
 200ebfc:	73800104 	addi	r14,r14,4
 200ec00:	69bfc736 	bltu	r13,r6,200eb20 <__multiply+0xb0>
 200ec04:	0400090e 	bge	zero,r16,200ec2c <__multiply+0x1bc>
 200ec08:	78ffff17 	ldw	r3,-4(r15)
 200ec0c:	7bffff04 	addi	r15,r15,-4
 200ec10:	18000326 	beq	r3,zero,200ec20 <__multiply+0x1b0>
 200ec14:	00000506 	br	200ec2c <__multiply+0x1bc>
 200ec18:	78c00017 	ldw	r3,0(r15)
 200ec1c:	1800031e 	bne	r3,zero,200ec2c <__multiply+0x1bc>
 200ec20:	843fffc4 	addi	r16,r16,-1
 200ec24:	7bffff04 	addi	r15,r15,-4
 200ec28:	803ffb1e 	bne	r16,zero,200ec18 <__multiply+0x1a8>
 200ec2c:	14000415 	stw	r16,16(r2)
 200ec30:	dfc00517 	ldw	ra,20(sp)
 200ec34:	dd000417 	ldw	r20,16(sp)
 200ec38:	dcc00317 	ldw	r19,12(sp)
 200ec3c:	dc800217 	ldw	r18,8(sp)
 200ec40:	dc400117 	ldw	r17,4(sp)
 200ec44:	dc000017 	ldw	r16,0(sp)
 200ec48:	dec00604 	addi	sp,sp,24
 200ec4c:	f800283a 	ret

0200ec50 <__pow5mult>:
 200ec50:	defffb04 	addi	sp,sp,-20
 200ec54:	dcc00315 	stw	r19,12(sp)
 200ec58:	dc800215 	stw	r18,8(sp)
 200ec5c:	dc000015 	stw	r16,0(sp)
 200ec60:	dfc00415 	stw	ra,16(sp)
 200ec64:	dc400115 	stw	r17,4(sp)
 200ec68:	308000cc 	andi	r2,r6,3
 200ec6c:	3021883a 	mov	r16,r6
 200ec70:	2027883a 	mov	r19,r4
 200ec74:	2825883a 	mov	r18,r5
 200ec78:	10002e1e 	bne	r2,zero,200ed34 <__pow5mult+0xe4>
 200ec7c:	8021d0ba 	srai	r16,r16,2
 200ec80:	80001a26 	beq	r16,zero,200ecec <__pow5mult+0x9c>
 200ec84:	9c401217 	ldw	r17,72(r19)
 200ec88:	8800061e 	bne	r17,zero,200eca4 <__pow5mult+0x54>
 200ec8c:	00003406 	br	200ed60 <__pow5mult+0x110>
 200ec90:	8021d07a 	srai	r16,r16,1
 200ec94:	80001526 	beq	r16,zero,200ecec <__pow5mult+0x9c>
 200ec98:	88c00017 	ldw	r3,0(r17)
 200ec9c:	18001b26 	beq	r3,zero,200ed0c <__pow5mult+0xbc>
 200eca0:	1823883a 	mov	r17,r3
 200eca4:	80c0004c 	andi	r3,r16,1
 200eca8:	183ff926 	beq	r3,zero,200ec90 <__pow5mult+0x40>
 200ecac:	900b883a 	mov	r5,r18
 200ecb0:	880d883a 	mov	r6,r17
 200ecb4:	9809883a 	mov	r4,r19
 200ecb8:	200ea700 	call	200ea70 <__multiply>
 200ecbc:	90001b26 	beq	r18,zero,200ed2c <__pow5mult+0xdc>
 200ecc0:	91000117 	ldw	r4,4(r18)
 200ecc4:	98c01317 	ldw	r3,76(r19)
 200ecc8:	8021d07a 	srai	r16,r16,1
 200eccc:	2109883a 	add	r4,r4,r4
 200ecd0:	2109883a 	add	r4,r4,r4
 200ecd4:	1907883a 	add	r3,r3,r4
 200ecd8:	19000017 	ldw	r4,0(r3)
 200ecdc:	91000015 	stw	r4,0(r18)
 200ece0:	1c800015 	stw	r18,0(r3)
 200ece4:	1025883a 	mov	r18,r2
 200ece8:	803feb1e 	bne	r16,zero,200ec98 <__pow5mult+0x48>
 200ecec:	9005883a 	mov	r2,r18
 200ecf0:	dfc00417 	ldw	ra,16(sp)
 200ecf4:	dcc00317 	ldw	r19,12(sp)
 200ecf8:	dc800217 	ldw	r18,8(sp)
 200ecfc:	dc400117 	ldw	r17,4(sp)
 200ed00:	dc000017 	ldw	r16,0(sp)
 200ed04:	dec00504 	addi	sp,sp,20
 200ed08:	f800283a 	ret
 200ed0c:	880b883a 	mov	r5,r17
 200ed10:	880d883a 	mov	r6,r17
 200ed14:	9809883a 	mov	r4,r19
 200ed18:	200ea700 	call	200ea70 <__multiply>
 200ed1c:	88800015 	stw	r2,0(r17)
 200ed20:	10000015 	stw	zero,0(r2)
 200ed24:	1023883a 	mov	r17,r2
 200ed28:	003fde06 	br	200eca4 <__pow5mult+0x54>
 200ed2c:	1025883a 	mov	r18,r2
 200ed30:	003fd706 	br	200ec90 <__pow5mult+0x40>
 200ed34:	10bfffc4 	addi	r2,r2,-1
 200ed38:	1085883a 	add	r2,r2,r2
 200ed3c:	00c08174 	movhi	r3,517
 200ed40:	18f80104 	addi	r3,r3,-8188
 200ed44:	1085883a 	add	r2,r2,r2
 200ed48:	1885883a 	add	r2,r3,r2
 200ed4c:	11800017 	ldw	r6,0(r2)
 200ed50:	000f883a 	mov	r7,zero
 200ed54:	200e7040 	call	200e704 <__multadd>
 200ed58:	1025883a 	mov	r18,r2
 200ed5c:	003fc706 	br	200ec7c <__pow5mult+0x2c>
 200ed60:	9809883a 	mov	r4,r19
 200ed64:	01409c44 	movi	r5,625
 200ed68:	200ea340 	call	200ea34 <__i2b>
 200ed6c:	98801215 	stw	r2,72(r19)
 200ed70:	1023883a 	mov	r17,r2
 200ed74:	10000015 	stw	zero,0(r2)
 200ed78:	003fca06 	br	200eca4 <__pow5mult+0x54>

0200ed7c <__lshift>:
 200ed7c:	defff904 	addi	sp,sp,-28
 200ed80:	dd400515 	stw	r21,20(sp)
 200ed84:	dc400115 	stw	r17,4(sp)
 200ed88:	2d400417 	ldw	r21,16(r5)
 200ed8c:	3023d17a 	srai	r17,r6,5
 200ed90:	28800217 	ldw	r2,8(r5)
 200ed94:	dd000415 	stw	r20,16(sp)
 200ed98:	8d6b883a 	add	r21,r17,r21
 200ed9c:	dcc00315 	stw	r19,12(sp)
 200eda0:	dc800215 	stw	r18,8(sp)
 200eda4:	dc000015 	stw	r16,0(sp)
 200eda8:	dfc00615 	stw	ra,24(sp)
 200edac:	ac000044 	addi	r16,r21,1
 200edb0:	2825883a 	mov	r18,r5
 200edb4:	3029883a 	mov	r20,r6
 200edb8:	2027883a 	mov	r19,r4
 200edbc:	29400117 	ldw	r5,4(r5)
 200edc0:	1400030e 	bge	r2,r16,200edd0 <__lshift+0x54>
 200edc4:	1085883a 	add	r2,r2,r2
 200edc8:	29400044 	addi	r5,r5,1
 200edcc:	143ffd16 	blt	r2,r16,200edc4 <__lshift+0x48>
 200edd0:	9809883a 	mov	r4,r19
 200edd4:	200e6340 	call	200e634 <_Balloc>
 200edd8:	10c00504 	addi	r3,r2,20
 200eddc:	0440090e 	bge	zero,r17,200ee04 <__lshift+0x88>
 200ede0:	000f883a 	mov	r7,zero
 200ede4:	18000015 	stw	zero,0(r3)
 200ede8:	39c00044 	addi	r7,r7,1
 200edec:	18c00104 	addi	r3,r3,4
 200edf0:	3c7ffc1e 	bne	r7,r17,200ede4 <__lshift+0x68>
 200edf4:	38c00144 	addi	r3,r7,5
 200edf8:	18c7883a 	add	r3,r3,r3
 200edfc:	18c7883a 	add	r3,r3,r3
 200ee00:	10c7883a 	add	r3,r2,r3
 200ee04:	92000417 	ldw	r8,16(r18)
 200ee08:	a18007cc 	andi	r6,r20,31
 200ee0c:	91c00504 	addi	r7,r18,20
 200ee10:	42000144 	addi	r8,r8,5
 200ee14:	4211883a 	add	r8,r8,r8
 200ee18:	4211883a 	add	r8,r8,r8
 200ee1c:	9211883a 	add	r8,r18,r8
 200ee20:	30002226 	beq	r6,zero,200eeac <__lshift+0x130>
 200ee24:	02800804 	movi	r10,32
 200ee28:	5195c83a 	sub	r10,r10,r6
 200ee2c:	000b883a 	mov	r5,zero
 200ee30:	3a400017 	ldw	r9,0(r7)
 200ee34:	18c00104 	addi	r3,r3,4
 200ee38:	39c00104 	addi	r7,r7,4
 200ee3c:	4992983a 	sll	r9,r9,r6
 200ee40:	2a4ab03a 	or	r5,r5,r9
 200ee44:	197fff15 	stw	r5,-4(r3)
 200ee48:	397fff17 	ldw	r5,-4(r7)
 200ee4c:	2a8ad83a 	srl	r5,r5,r10
 200ee50:	3a3ff736 	bltu	r7,r8,200ee30 <__lshift+0xb4>
 200ee54:	19400015 	stw	r5,0(r3)
 200ee58:	28000126 	beq	r5,zero,200ee60 <__lshift+0xe4>
 200ee5c:	ac000084 	addi	r16,r21,2
 200ee60:	91000117 	ldw	r4,4(r18)
 200ee64:	98c01317 	ldw	r3,76(r19)
 200ee68:	843fffc4 	addi	r16,r16,-1
 200ee6c:	2109883a 	add	r4,r4,r4
 200ee70:	2109883a 	add	r4,r4,r4
 200ee74:	1907883a 	add	r3,r3,r4
 200ee78:	19000017 	ldw	r4,0(r3)
 200ee7c:	14000415 	stw	r16,16(r2)
 200ee80:	91000015 	stw	r4,0(r18)
 200ee84:	1c800015 	stw	r18,0(r3)
 200ee88:	dfc00617 	ldw	ra,24(sp)
 200ee8c:	dd400517 	ldw	r21,20(sp)
 200ee90:	dd000417 	ldw	r20,16(sp)
 200ee94:	dcc00317 	ldw	r19,12(sp)
 200ee98:	dc800217 	ldw	r18,8(sp)
 200ee9c:	dc400117 	ldw	r17,4(sp)
 200eea0:	dc000017 	ldw	r16,0(sp)
 200eea4:	dec00704 	addi	sp,sp,28
 200eea8:	f800283a 	ret
 200eeac:	39400017 	ldw	r5,0(r7)
 200eeb0:	18c00104 	addi	r3,r3,4
 200eeb4:	39c00104 	addi	r7,r7,4
 200eeb8:	197fff15 	stw	r5,-4(r3)
 200eebc:	3a3fe82e 	bgeu	r7,r8,200ee60 <__lshift+0xe4>
 200eec0:	39400017 	ldw	r5,0(r7)
 200eec4:	18c00104 	addi	r3,r3,4
 200eec8:	39c00104 	addi	r7,r7,4
 200eecc:	197fff15 	stw	r5,-4(r3)
 200eed0:	3a3ff636 	bltu	r7,r8,200eeac <__lshift+0x130>
 200eed4:	003fe206 	br	200ee60 <__lshift+0xe4>

0200eed8 <__mcmp>:
 200eed8:	20800417 	ldw	r2,16(r4)
 200eedc:	28c00417 	ldw	r3,16(r5)
 200eee0:	10c5c83a 	sub	r2,r2,r3
 200eee4:	10000f1e 	bne	r2,zero,200ef24 <__mcmp+0x4c>
 200eee8:	18c00144 	addi	r3,r3,5
 200eeec:	18c7883a 	add	r3,r3,r3
 200eef0:	18c7883a 	add	r3,r3,r3
 200eef4:	21c00504 	addi	r7,r4,20
 200eef8:	28cb883a 	add	r5,r5,r3
 200eefc:	20c9883a 	add	r4,r4,r3
 200ef00:	213fff04 	addi	r4,r4,-4
 200ef04:	297fff04 	addi	r5,r5,-4
 200ef08:	21800017 	ldw	r6,0(r4)
 200ef0c:	28c00017 	ldw	r3,0(r5)
 200ef10:	30c0021e 	bne	r6,r3,200ef1c <__mcmp+0x44>
 200ef14:	393ffa36 	bltu	r7,r4,200ef00 <__mcmp+0x28>
 200ef18:	f800283a 	ret
 200ef1c:	30c00236 	bltu	r6,r3,200ef28 <__mcmp+0x50>
 200ef20:	00800044 	movi	r2,1
 200ef24:	f800283a 	ret
 200ef28:	00bfffc4 	movi	r2,-1
 200ef2c:	f800283a 	ret

0200ef30 <__mdiff>:
 200ef30:	defffb04 	addi	sp,sp,-20
 200ef34:	dc000015 	stw	r16,0(sp)
 200ef38:	2821883a 	mov	r16,r5
 200ef3c:	dc800215 	stw	r18,8(sp)
 200ef40:	300b883a 	mov	r5,r6
 200ef44:	2025883a 	mov	r18,r4
 200ef48:	8009883a 	mov	r4,r16
 200ef4c:	dc400115 	stw	r17,4(sp)
 200ef50:	dfc00415 	stw	ra,16(sp)
 200ef54:	dcc00315 	stw	r19,12(sp)
 200ef58:	3023883a 	mov	r17,r6
 200ef5c:	200eed80 	call	200eed8 <__mcmp>
 200ef60:	10005026 	beq	r2,zero,200f0a4 <__mdiff+0x174>
 200ef64:	10004a16 	blt	r2,zero,200f090 <__mdiff+0x160>
 200ef68:	0027883a 	mov	r19,zero
 200ef6c:	81400117 	ldw	r5,4(r16)
 200ef70:	9009883a 	mov	r4,r18
 200ef74:	200e6340 	call	200e634 <_Balloc>
 200ef78:	82400417 	ldw	r9,16(r16)
 200ef7c:	89800417 	ldw	r6,16(r17)
 200ef80:	14c00315 	stw	r19,12(r2)
 200ef84:	4b800144 	addi	r14,r9,5
 200ef88:	31800144 	addi	r6,r6,5
 200ef8c:	739d883a 	add	r14,r14,r14
 200ef90:	318d883a 	add	r6,r6,r6
 200ef94:	739d883a 	add	r14,r14,r14
 200ef98:	318d883a 	add	r6,r6,r6
 200ef9c:	81c00504 	addi	r7,r16,20
 200efa0:	839d883a 	add	r14,r16,r14
 200efa4:	8a000504 	addi	r8,r17,20
 200efa8:	898d883a 	add	r6,r17,r6
 200efac:	10c00504 	addi	r3,r2,20
 200efb0:	0009883a 	mov	r4,zero
 200efb4:	3b000017 	ldw	r12,0(r7)
 200efb8:	42c00017 	ldw	r11,0(r8)
 200efbc:	42000104 	addi	r8,r8,4
 200efc0:	62bfffcc 	andi	r10,r12,65535
 200efc4:	5b7fffcc 	andi	r13,r11,65535
 200efc8:	5109883a 	add	r4,r10,r4
 200efcc:	2355c83a 	sub	r10,r4,r13
 200efd0:	5816d43a 	srli	r11,r11,16
 200efd4:	6008d43a 	srli	r4,r12,16
 200efd8:	501bd43a 	srai	r13,r10,16
 200efdc:	1a80000d 	sth	r10,0(r3)
 200efe0:	22c9c83a 	sub	r4,r4,r11
 200efe4:	2349883a 	add	r4,r4,r13
 200efe8:	1900008d 	sth	r4,2(r3)
 200efec:	39c00104 	addi	r7,r7,4
 200eff0:	2009d43a 	srai	r4,r4,16
 200eff4:	18c00104 	addi	r3,r3,4
 200eff8:	41bfee36 	bltu	r8,r6,200efb4 <__mdiff+0x84>
 200effc:	180b883a 	mov	r5,r3
 200f000:	3815883a 	mov	r10,r7
 200f004:	3b80132e 	bgeu	r7,r14,200f054 <__mdiff+0x124>
 200f008:	3a000017 	ldw	r8,0(r7)
 200f00c:	18c00104 	addi	r3,r3,4
 200f010:	39c00104 	addi	r7,r7,4
 200f014:	41bfffcc 	andi	r6,r8,65535
 200f018:	310d883a 	add	r6,r6,r4
 200f01c:	3009d43a 	srai	r4,r6,16
 200f020:	4010d43a 	srli	r8,r8,16
 200f024:	19bfff0d 	sth	r6,-4(r3)
 200f028:	2209883a 	add	r4,r4,r8
 200f02c:	193fff8d 	sth	r4,-2(r3)
 200f030:	2009d43a 	srai	r4,r4,16
 200f034:	3bbff436 	bltu	r7,r14,200f008 <__mdiff+0xd8>
 200f038:	0286303a 	nor	r3,zero,r10
 200f03c:	1b87883a 	add	r3,r3,r14
 200f040:	1806d0ba 	srli	r3,r3,2
 200f044:	18c00044 	addi	r3,r3,1
 200f048:	18c7883a 	add	r3,r3,r3
 200f04c:	18c7883a 	add	r3,r3,r3
 200f050:	28c7883a 	add	r3,r5,r3
 200f054:	193fff17 	ldw	r4,-4(r3)
 200f058:	18ffff04 	addi	r3,r3,-4
 200f05c:	2000041e 	bne	r4,zero,200f070 <__mdiff+0x140>
 200f060:	18ffff04 	addi	r3,r3,-4
 200f064:	19000017 	ldw	r4,0(r3)
 200f068:	4a7fffc4 	addi	r9,r9,-1
 200f06c:	203ffc26 	beq	r4,zero,200f060 <__mdiff+0x130>
 200f070:	12400415 	stw	r9,16(r2)
 200f074:	dfc00417 	ldw	ra,16(sp)
 200f078:	dcc00317 	ldw	r19,12(sp)
 200f07c:	dc800217 	ldw	r18,8(sp)
 200f080:	dc400117 	ldw	r17,4(sp)
 200f084:	dc000017 	ldw	r16,0(sp)
 200f088:	dec00504 	addi	sp,sp,20
 200f08c:	f800283a 	ret
 200f090:	8005883a 	mov	r2,r16
 200f094:	04c00044 	movi	r19,1
 200f098:	8821883a 	mov	r16,r17
 200f09c:	1023883a 	mov	r17,r2
 200f0a0:	003fb206 	br	200ef6c <__mdiff+0x3c>
 200f0a4:	9009883a 	mov	r4,r18
 200f0a8:	000b883a 	mov	r5,zero
 200f0ac:	200e6340 	call	200e634 <_Balloc>
 200f0b0:	00c00044 	movi	r3,1
 200f0b4:	10c00415 	stw	r3,16(r2)
 200f0b8:	10000515 	stw	zero,20(r2)
 200f0bc:	dfc00417 	ldw	ra,16(sp)
 200f0c0:	dcc00317 	ldw	r19,12(sp)
 200f0c4:	dc800217 	ldw	r18,8(sp)
 200f0c8:	dc400117 	ldw	r17,4(sp)
 200f0cc:	dc000017 	ldw	r16,0(sp)
 200f0d0:	dec00504 	addi	sp,sp,20
 200f0d4:	f800283a 	ret

0200f0d8 <__ulp>:
 200f0d8:	295ffc2c 	andhi	r5,r5,32752
 200f0dc:	00bf3034 	movhi	r2,64704
 200f0e0:	2887883a 	add	r3,r5,r2
 200f0e4:	00c0020e 	bge	zero,r3,200f0f0 <__ulp+0x18>
 200f0e8:	0005883a 	mov	r2,zero
 200f0ec:	f800283a 	ret
 200f0f0:	00c7c83a 	sub	r3,zero,r3
 200f0f4:	1805d53a 	srai	r2,r3,20
 200f0f8:	00c004c4 	movi	r3,19
 200f0fc:	18800a0e 	bge	r3,r2,200f128 <__ulp+0x50>
 200f100:	01000c84 	movi	r4,50
 200f104:	0007883a 	mov	r3,zero
 200f108:	20800516 	blt	r4,r2,200f120 <__ulp+0x48>
 200f10c:	01000cc4 	movi	r4,51
 200f110:	2085c83a 	sub	r2,r4,r2
 200f114:	01000044 	movi	r4,1
 200f118:	2084983a 	sll	r2,r4,r2
 200f11c:	f800283a 	ret
 200f120:	00800044 	movi	r2,1
 200f124:	f800283a 	ret
 200f128:	00c00234 	movhi	r3,8
 200f12c:	1887d83a 	sra	r3,r3,r2
 200f130:	0005883a 	mov	r2,zero
 200f134:	f800283a 	ret

0200f138 <__b2d>:
 200f138:	defffa04 	addi	sp,sp,-24
 200f13c:	dc000015 	stw	r16,0(sp)
 200f140:	24000417 	ldw	r16,16(r4)
 200f144:	dc400115 	stw	r17,4(sp)
 200f148:	dcc00315 	stw	r19,12(sp)
 200f14c:	84000144 	addi	r16,r16,5
 200f150:	8421883a 	add	r16,r16,r16
 200f154:	8421883a 	add	r16,r16,r16
 200f158:	2421883a 	add	r16,r4,r16
 200f15c:	847fff17 	ldw	r17,-4(r16)
 200f160:	24c00504 	addi	r19,r4,20
 200f164:	dd000415 	stw	r20,16(sp)
 200f168:	8809883a 	mov	r4,r17
 200f16c:	dc800215 	stw	r18,8(sp)
 200f170:	2829883a 	mov	r20,r5
 200f174:	dfc00515 	stw	ra,20(sp)
 200f178:	200e91c0 	call	200e91c <__hi0bits>
 200f17c:	00c00804 	movi	r3,32
 200f180:	1887c83a 	sub	r3,r3,r2
 200f184:	a0c00015 	stw	r3,0(r20)
 200f188:	00c00284 	movi	r3,10
 200f18c:	84bfff04 	addi	r18,r16,-4
 200f190:	18801216 	blt	r3,r2,200f1dc <__b2d+0xa4>
 200f194:	010002c4 	movi	r4,11
 200f198:	2089c83a 	sub	r4,r4,r2
 200f19c:	8906d83a 	srl	r3,r17,r4
 200f1a0:	18cffc34 	orhi	r3,r3,16368
 200f1a4:	9c80322e 	bgeu	r19,r18,200f270 <__b2d+0x138>
 200f1a8:	817ffe17 	ldw	r5,-8(r16)
 200f1ac:	2908d83a 	srl	r4,r5,r4
 200f1b0:	10800544 	addi	r2,r2,21
 200f1b4:	88a2983a 	sll	r17,r17,r2
 200f1b8:	2444b03a 	or	r2,r4,r17
 200f1bc:	dfc00517 	ldw	ra,20(sp)
 200f1c0:	dd000417 	ldw	r20,16(sp)
 200f1c4:	dcc00317 	ldw	r19,12(sp)
 200f1c8:	dc800217 	ldw	r18,8(sp)
 200f1cc:	dc400117 	ldw	r17,4(sp)
 200f1d0:	dc000017 	ldw	r16,0(sp)
 200f1d4:	dec00604 	addi	sp,sp,24
 200f1d8:	f800283a 	ret
 200f1dc:	9c801636 	bltu	r19,r18,200f238 <__b2d+0x100>
 200f1e0:	113ffd44 	addi	r4,r2,-11
 200f1e4:	000b883a 	mov	r5,zero
 200f1e8:	20001726 	beq	r4,zero,200f248 <__b2d+0x110>
 200f1ec:	00c00ac4 	movi	r3,43
 200f1f0:	1885c83a 	sub	r2,r3,r2
 200f1f4:	8906983a 	sll	r3,r17,r4
 200f1f8:	288cd83a 	srl	r6,r5,r2
 200f1fc:	18cffc34 	orhi	r3,r3,16368
 200f200:	1986b03a 	or	r3,r3,r6
 200f204:	9c801c2e 	bgeu	r19,r18,200f278 <__b2d+0x140>
 200f208:	91bfff17 	ldw	r6,-4(r18)
 200f20c:	3084d83a 	srl	r2,r6,r2
 200f210:	2908983a 	sll	r4,r5,r4
 200f214:	1104b03a 	or	r2,r2,r4
 200f218:	dfc00517 	ldw	ra,20(sp)
 200f21c:	dd000417 	ldw	r20,16(sp)
 200f220:	dcc00317 	ldw	r19,12(sp)
 200f224:	dc800217 	ldw	r18,8(sp)
 200f228:	dc400117 	ldw	r17,4(sp)
 200f22c:	dc000017 	ldw	r16,0(sp)
 200f230:	dec00604 	addi	sp,sp,24
 200f234:	f800283a 	ret
 200f238:	113ffd44 	addi	r4,r2,-11
 200f23c:	84bffe04 	addi	r18,r16,-8
 200f240:	817ffe17 	ldw	r5,-8(r16)
 200f244:	203fe91e 	bne	r4,zero,200f1ec <__b2d+0xb4>
 200f248:	88cffc34 	orhi	r3,r17,16368
 200f24c:	2805883a 	mov	r2,r5
 200f250:	dfc00517 	ldw	ra,20(sp)
 200f254:	dd000417 	ldw	r20,16(sp)
 200f258:	dcc00317 	ldw	r19,12(sp)
 200f25c:	dc800217 	ldw	r18,8(sp)
 200f260:	dc400117 	ldw	r17,4(sp)
 200f264:	dc000017 	ldw	r16,0(sp)
 200f268:	dec00604 	addi	sp,sp,24
 200f26c:	f800283a 	ret
 200f270:	0009883a 	mov	r4,zero
 200f274:	003fce06 	br	200f1b0 <__b2d+0x78>
 200f278:	0005883a 	mov	r2,zero
 200f27c:	003fe406 	br	200f210 <__b2d+0xd8>

0200f280 <__d2b>:
 200f280:	defff804 	addi	sp,sp,-32
 200f284:	dc400315 	stw	r17,12(sp)
 200f288:	3023883a 	mov	r17,r6
 200f28c:	dc800415 	stw	r18,16(sp)
 200f290:	8824907a 	slli	r18,r17,1
 200f294:	dcc00515 	stw	r19,20(sp)
 200f298:	2827883a 	mov	r19,r5
 200f29c:	9024d57a 	srli	r18,r18,21
 200f2a0:	01400044 	movi	r5,1
 200f2a4:	dd000615 	stw	r20,24(sp)
 200f2a8:	dc000215 	stw	r16,8(sp)
 200f2ac:	dfc00715 	stw	ra,28(sp)
 200f2b0:	3829883a 	mov	r20,r7
 200f2b4:	200e6340 	call	200e634 <_Balloc>
 200f2b8:	1021883a 	mov	r16,r2
 200f2bc:	00800434 	movhi	r2,16
 200f2c0:	10bfffc4 	addi	r2,r2,-1
 200f2c4:	88a2703a 	and	r17,r17,r2
 200f2c8:	90000126 	beq	r18,zero,200f2d0 <__d2b+0x50>
 200f2cc:	8c400434 	orhi	r17,r17,16
 200f2d0:	dc400015 	stw	r17,0(sp)
 200f2d4:	98002226 	beq	r19,zero,200f360 <__d2b+0xe0>
 200f2d8:	d9000104 	addi	r4,sp,4
 200f2dc:	dcc00115 	stw	r19,4(sp)
 200f2e0:	200e9840 	call	200e984 <__lo0bits>
 200f2e4:	d8c00017 	ldw	r3,0(sp)
 200f2e8:	10002d1e 	bne	r2,zero,200f3a0 <__d2b+0x120>
 200f2ec:	d9000117 	ldw	r4,4(sp)
 200f2f0:	81000515 	stw	r4,20(r16)
 200f2f4:	1823003a 	cmpeq	r17,r3,zero
 200f2f8:	01000084 	movi	r4,2
 200f2fc:	2463c83a 	sub	r17,r4,r17
 200f300:	80c00615 	stw	r3,24(r16)
 200f304:	84400415 	stw	r17,16(r16)
 200f308:	90001d1e 	bne	r18,zero,200f380 <__d2b+0x100>
 200f30c:	88c00104 	addi	r3,r17,4
 200f310:	18c7883a 	add	r3,r3,r3
 200f314:	18c7883a 	add	r3,r3,r3
 200f318:	80c7883a 	add	r3,r16,r3
 200f31c:	19000017 	ldw	r4,0(r3)
 200f320:	10bef384 	addi	r2,r2,-1074
 200f324:	a0800015 	stw	r2,0(r20)
 200f328:	200e91c0 	call	200e91c <__hi0bits>
 200f32c:	8822917a 	slli	r17,r17,5
 200f330:	d8c00817 	ldw	r3,32(sp)
 200f334:	8885c83a 	sub	r2,r17,r2
 200f338:	18800015 	stw	r2,0(r3)
 200f33c:	8005883a 	mov	r2,r16
 200f340:	dfc00717 	ldw	ra,28(sp)
 200f344:	dd000617 	ldw	r20,24(sp)
 200f348:	dcc00517 	ldw	r19,20(sp)
 200f34c:	dc800417 	ldw	r18,16(sp)
 200f350:	dc400317 	ldw	r17,12(sp)
 200f354:	dc000217 	ldw	r16,8(sp)
 200f358:	dec00804 	addi	sp,sp,32
 200f35c:	f800283a 	ret
 200f360:	d809883a 	mov	r4,sp
 200f364:	200e9840 	call	200e984 <__lo0bits>
 200f368:	d8c00017 	ldw	r3,0(sp)
 200f36c:	04400044 	movi	r17,1
 200f370:	84400415 	stw	r17,16(r16)
 200f374:	80c00515 	stw	r3,20(r16)
 200f378:	10800804 	addi	r2,r2,32
 200f37c:	903fe326 	beq	r18,zero,200f30c <__d2b+0x8c>
 200f380:	00c00d44 	movi	r3,53
 200f384:	94bef344 	addi	r18,r18,-1075
 200f388:	90a5883a 	add	r18,r18,r2
 200f38c:	1885c83a 	sub	r2,r3,r2
 200f390:	d8c00817 	ldw	r3,32(sp)
 200f394:	a4800015 	stw	r18,0(r20)
 200f398:	18800015 	stw	r2,0(r3)
 200f39c:	003fe706 	br	200f33c <__d2b+0xbc>
 200f3a0:	01000804 	movi	r4,32
 200f3a4:	2089c83a 	sub	r4,r4,r2
 200f3a8:	1908983a 	sll	r4,r3,r4
 200f3ac:	d9400117 	ldw	r5,4(sp)
 200f3b0:	1886d83a 	srl	r3,r3,r2
 200f3b4:	2148b03a 	or	r4,r4,r5
 200f3b8:	81000515 	stw	r4,20(r16)
 200f3bc:	d8c00015 	stw	r3,0(sp)
 200f3c0:	003fcc06 	br	200f2f4 <__d2b+0x74>

0200f3c4 <__ratio>:
 200f3c4:	defff904 	addi	sp,sp,-28
 200f3c8:	dc400315 	stw	r17,12(sp)
 200f3cc:	2823883a 	mov	r17,r5
 200f3d0:	d9400104 	addi	r5,sp,4
 200f3d4:	dfc00615 	stw	ra,24(sp)
 200f3d8:	dcc00515 	stw	r19,20(sp)
 200f3dc:	dc800415 	stw	r18,16(sp)
 200f3e0:	2027883a 	mov	r19,r4
 200f3e4:	dc000215 	stw	r16,8(sp)
 200f3e8:	200f1380 	call	200f138 <__b2d>
 200f3ec:	8809883a 	mov	r4,r17
 200f3f0:	d80b883a 	mov	r5,sp
 200f3f4:	1025883a 	mov	r18,r2
 200f3f8:	1821883a 	mov	r16,r3
 200f3fc:	200f1380 	call	200f138 <__b2d>
 200f400:	99400417 	ldw	r5,16(r19)
 200f404:	89000417 	ldw	r4,16(r17)
 200f408:	d9800117 	ldw	r6,4(sp)
 200f40c:	2909c83a 	sub	r4,r5,r4
 200f410:	d9400017 	ldw	r5,0(sp)
 200f414:	2008917a 	slli	r4,r4,5
 200f418:	314bc83a 	sub	r5,r6,r5
 200f41c:	290b883a 	add	r5,r5,r4
 200f420:	01400e0e 	bge	zero,r5,200f45c <__ratio+0x98>
 200f424:	280a953a 	slli	r5,r5,20
 200f428:	2c21883a 	add	r16,r5,r16
 200f42c:	9009883a 	mov	r4,r18
 200f430:	800b883a 	mov	r5,r16
 200f434:	100d883a 	mov	r6,r2
 200f438:	180f883a 	mov	r7,r3
 200f43c:	2013f6c0 	call	2013f6c <__divdf3>
 200f440:	dfc00617 	ldw	ra,24(sp)
 200f444:	dcc00517 	ldw	r19,20(sp)
 200f448:	dc800417 	ldw	r18,16(sp)
 200f44c:	dc400317 	ldw	r17,12(sp)
 200f450:	dc000217 	ldw	r16,8(sp)
 200f454:	dec00704 	addi	sp,sp,28
 200f458:	f800283a 	ret
 200f45c:	280a953a 	slli	r5,r5,20
 200f460:	1947c83a 	sub	r3,r3,r5
 200f464:	003ff106 	br	200f42c <__ratio+0x68>

0200f468 <_mprec_log10>:
 200f468:	defffe04 	addi	sp,sp,-8
 200f46c:	dc000015 	stw	r16,0(sp)
 200f470:	dfc00115 	stw	ra,4(sp)
 200f474:	008005c4 	movi	r2,23
 200f478:	2021883a 	mov	r16,r4
 200f47c:	11000d0e 	bge	r2,r4,200f4b4 <_mprec_log10+0x4c>
 200f480:	0005883a 	mov	r2,zero
 200f484:	00cffc34 	movhi	r3,16368
 200f488:	843fffc4 	addi	r16,r16,-1
 200f48c:	1009883a 	mov	r4,r2
 200f490:	180b883a 	mov	r5,r3
 200f494:	000d883a 	mov	r6,zero
 200f498:	01d00934 	movhi	r7,16420
 200f49c:	2013c880 	call	2013c88 <__muldf3>
 200f4a0:	803ff91e 	bne	r16,zero,200f488 <_mprec_log10+0x20>
 200f4a4:	dfc00117 	ldw	ra,4(sp)
 200f4a8:	dc000017 	ldw	r16,0(sp)
 200f4ac:	dec00204 	addi	sp,sp,8
 200f4b0:	f800283a 	ret
 200f4b4:	202090fa 	slli	r16,r4,3
 200f4b8:	00808174 	movhi	r2,517
 200f4bc:	10b7cf04 	addi	r2,r2,-8388
 200f4c0:	1421883a 	add	r16,r2,r16
 200f4c4:	80800017 	ldw	r2,0(r16)
 200f4c8:	80c00117 	ldw	r3,4(r16)
 200f4cc:	dfc00117 	ldw	ra,4(sp)
 200f4d0:	dc000017 	ldw	r16,0(sp)
 200f4d4:	dec00204 	addi	sp,sp,8
 200f4d8:	f800283a 	ret

0200f4dc <__copybits>:
 200f4dc:	297fffc4 	addi	r5,r5,-1
 200f4e0:	31c00417 	ldw	r7,16(r6)
 200f4e4:	2811d17a 	srai	r8,r5,5
 200f4e8:	30800504 	addi	r2,r6,20
 200f4ec:	39c00144 	addi	r7,r7,5
 200f4f0:	42000044 	addi	r8,r8,1
 200f4f4:	39cf883a 	add	r7,r7,r7
 200f4f8:	4211883a 	add	r8,r8,r8
 200f4fc:	39cf883a 	add	r7,r7,r7
 200f500:	4211883a 	add	r8,r8,r8
 200f504:	31cf883a 	add	r7,r6,r7
 200f508:	2211883a 	add	r8,r4,r8
 200f50c:	11c00d2e 	bgeu	r2,r7,200f544 <__copybits+0x68>
 200f510:	2007883a 	mov	r3,r4
 200f514:	11400017 	ldw	r5,0(r2)
 200f518:	18c00104 	addi	r3,r3,4
 200f51c:	10800104 	addi	r2,r2,4
 200f520:	197fff15 	stw	r5,-4(r3)
 200f524:	11fffb36 	bltu	r2,r7,200f514 <__copybits+0x38>
 200f528:	3985c83a 	sub	r2,r7,r6
 200f52c:	10bffac4 	addi	r2,r2,-21
 200f530:	1004d0ba 	srli	r2,r2,2
 200f534:	10800044 	addi	r2,r2,1
 200f538:	1085883a 	add	r2,r2,r2
 200f53c:	1085883a 	add	r2,r2,r2
 200f540:	2089883a 	add	r4,r4,r2
 200f544:	2200032e 	bgeu	r4,r8,200f554 <__copybits+0x78>
 200f548:	20000015 	stw	zero,0(r4)
 200f54c:	21000104 	addi	r4,r4,4
 200f550:	223ffd36 	bltu	r4,r8,200f548 <__copybits+0x6c>
 200f554:	f800283a 	ret

0200f558 <__any_on>:
 200f558:	21800417 	ldw	r6,16(r4)
 200f55c:	2805d17a 	srai	r2,r5,5
 200f560:	20c00504 	addi	r3,r4,20
 200f564:	30800f0e 	bge	r6,r2,200f5a4 <__any_on+0x4c>
 200f568:	3005883a 	mov	r2,r6
 200f56c:	10800144 	addi	r2,r2,5
 200f570:	1085883a 	add	r2,r2,r2
 200f574:	1085883a 	add	r2,r2,r2
 200f578:	2089883a 	add	r4,r4,r2
 200f57c:	1900152e 	bgeu	r3,r4,200f5d4 <__any_on+0x7c>
 200f580:	20bfff17 	ldw	r2,-4(r4)
 200f584:	213fff04 	addi	r4,r4,-4
 200f588:	1000041e 	bne	r2,zero,200f59c <__any_on+0x44>
 200f58c:	1900112e 	bgeu	r3,r4,200f5d4 <__any_on+0x7c>
 200f590:	213fff04 	addi	r4,r4,-4
 200f594:	20800017 	ldw	r2,0(r4)
 200f598:	103ffc26 	beq	r2,zero,200f58c <__any_on+0x34>
 200f59c:	00800044 	movi	r2,1
 200f5a0:	f800283a 	ret
 200f5a4:	11bff10e 	bge	r2,r6,200f56c <__any_on+0x14>
 200f5a8:	294007cc 	andi	r5,r5,31
 200f5ac:	283fef26 	beq	r5,zero,200f56c <__any_on+0x14>
 200f5b0:	11800144 	addi	r6,r2,5
 200f5b4:	318d883a 	add	r6,r6,r6
 200f5b8:	318d883a 	add	r6,r6,r6
 200f5bc:	218d883a 	add	r6,r4,r6
 200f5c0:	31800017 	ldw	r6,0(r6)
 200f5c4:	314ed83a 	srl	r7,r6,r5
 200f5c8:	394a983a 	sll	r5,r7,r5
 200f5cc:	29bff31e 	bne	r5,r6,200f59c <__any_on+0x44>
 200f5d0:	003fe606 	br	200f56c <__any_on+0x14>
 200f5d4:	0005883a 	mov	r2,zero
 200f5d8:	f800283a 	ret

0200f5dc <_read_r>:
 200f5dc:	defffd04 	addi	sp,sp,-12
 200f5e0:	dc400115 	stw	r17,4(sp)
 200f5e4:	dc000015 	stw	r16,0(sp)
 200f5e8:	2023883a 	mov	r17,r4
 200f5ec:	04008174 	movhi	r16,517
 200f5f0:	84108b04 	addi	r16,r16,16940
 200f5f4:	2809883a 	mov	r4,r5
 200f5f8:	300b883a 	mov	r5,r6
 200f5fc:	380d883a 	mov	r6,r7
 200f600:	dfc00215 	stw	ra,8(sp)
 200f604:	80000015 	stw	zero,0(r16)
 200f608:	20238d80 	call	20238d8 <read>
 200f60c:	00ffffc4 	movi	r3,-1
 200f610:	10c00526 	beq	r2,r3,200f628 <_read_r+0x4c>
 200f614:	dfc00217 	ldw	ra,8(sp)
 200f618:	dc400117 	ldw	r17,4(sp)
 200f61c:	dc000017 	ldw	r16,0(sp)
 200f620:	dec00304 	addi	sp,sp,12
 200f624:	f800283a 	ret
 200f628:	80c00017 	ldw	r3,0(r16)
 200f62c:	183ff926 	beq	r3,zero,200f614 <_read_r+0x38>
 200f630:	88c00015 	stw	r3,0(r17)
 200f634:	dfc00217 	ldw	ra,8(sp)
 200f638:	dc400117 	ldw	r17,4(sp)
 200f63c:	dc000017 	ldw	r16,0(sp)
 200f640:	dec00304 	addi	sp,sp,12
 200f644:	f800283a 	ret

0200f648 <_realloc_r>:
 200f648:	defff504 	addi	sp,sp,-44
 200f64c:	dd400615 	stw	r21,24(sp)
 200f650:	dc800315 	stw	r18,12(sp)
 200f654:	dc000115 	stw	r16,4(sp)
 200f658:	dfc00a15 	stw	ra,40(sp)
 200f65c:	df000915 	stw	fp,36(sp)
 200f660:	ddc00815 	stw	r23,32(sp)
 200f664:	dd800715 	stw	r22,28(sp)
 200f668:	dd000515 	stw	r20,20(sp)
 200f66c:	dcc00415 	stw	r19,16(sp)
 200f670:	dc400215 	stw	r17,8(sp)
 200f674:	2821883a 	mov	r16,r5
 200f678:	202b883a 	mov	r21,r4
 200f67c:	3025883a 	mov	r18,r6
 200f680:	28009626 	beq	r5,zero,200f8dc <_realloc_r+0x294>
 200f684:	2015aec0 	call	2015aec <__malloc_lock>
 200f688:	80bfff17 	ldw	r2,-4(r16)
 200f68c:	04ffff04 	movi	r19,-4
 200f690:	90c002c4 	addi	r3,r18,11
 200f694:	01000584 	movi	r4,22
 200f698:	85bffe04 	addi	r22,r16,-8
 200f69c:	14e6703a 	and	r19,r2,r19
 200f6a0:	20c0372e 	bgeu	r4,r3,200f780 <_realloc_r+0x138>
 200f6a4:	047ffe04 	movi	r17,-8
 200f6a8:	1c62703a 	and	r17,r3,r17
 200f6ac:	8807883a 	mov	r3,r17
 200f6b0:	88005a16 	blt	r17,zero,200f81c <_realloc_r+0x1d4>
 200f6b4:	8c805936 	bltu	r17,r18,200f81c <_realloc_r+0x1d4>
 200f6b8:	98c0340e 	bge	r19,r3,200f78c <_realloc_r+0x144>
 200f6bc:	07008174 	movhi	fp,517
 200f6c0:	e7097004 	addi	fp,fp,9664
 200f6c4:	e1400217 	ldw	r5,8(fp)
 200f6c8:	b4c9883a 	add	r4,r22,r19
 200f6cc:	29009026 	beq	r5,r4,200f910 <_realloc_r+0x2c8>
 200f6d0:	21800117 	ldw	r6,4(r4)
 200f6d4:	01ffff84 	movi	r7,-2
 200f6d8:	31ce703a 	and	r7,r6,r7
 200f6dc:	21cf883a 	add	r7,r4,r7
 200f6e0:	39c00117 	ldw	r7,4(r7)
 200f6e4:	39c0004c 	andi	r7,r7,1
 200f6e8:	38004326 	beq	r7,zero,200f7f8 <_realloc_r+0x1b0>
 200f6ec:	000d883a 	mov	r6,zero
 200f6f0:	0009883a 	mov	r4,zero
 200f6f4:	1080004c 	andi	r2,r2,1
 200f6f8:	10005a1e 	bne	r2,zero,200f864 <_realloc_r+0x21c>
 200f6fc:	85fffe17 	ldw	r23,-8(r16)
 200f700:	00bfff04 	movi	r2,-4
 200f704:	b5efc83a 	sub	r23,r22,r23
 200f708:	b9c00117 	ldw	r7,4(r23)
 200f70c:	388e703a 	and	r7,r7,r2
 200f710:	3ccf883a 	add	r7,r7,r19
 200f714:	20005226 	beq	r4,zero,200f860 <_realloc_r+0x218>
 200f718:	31e9883a 	add	r20,r6,r7
 200f71c:	2140c726 	beq	r4,r5,200fa3c <_realloc_r+0x3f4>
 200f720:	a0c04f16 	blt	r20,r3,200f860 <_realloc_r+0x218>
 200f724:	20800317 	ldw	r2,12(r4)
 200f728:	20c00217 	ldw	r3,8(r4)
 200f72c:	99bfff04 	addi	r6,r19,-4
 200f730:	01000904 	movi	r4,36
 200f734:	18800315 	stw	r2,12(r3)
 200f738:	10c00215 	stw	r3,8(r2)
 200f73c:	b8c00217 	ldw	r3,8(r23)
 200f740:	b8800317 	ldw	r2,12(r23)
 200f744:	bc800204 	addi	r18,r23,8
 200f748:	18800315 	stw	r2,12(r3)
 200f74c:	10c00215 	stw	r3,8(r2)
 200f750:	2180ed36 	bltu	r4,r6,200fb08 <_realloc_r+0x4c0>
 200f754:	008004c4 	movi	r2,19
 200f758:	11809b2e 	bgeu	r2,r6,200f9c8 <_realloc_r+0x380>
 200f75c:	80800017 	ldw	r2,0(r16)
 200f760:	b8800215 	stw	r2,8(r23)
 200f764:	80800117 	ldw	r2,4(r16)
 200f768:	b8800315 	stw	r2,12(r23)
 200f76c:	008006c4 	movi	r2,27
 200f770:	1180f936 	bltu	r2,r6,200fb58 <_realloc_r+0x510>
 200f774:	b8800404 	addi	r2,r23,16
 200f778:	80c00204 	addi	r3,r16,8
 200f77c:	00009406 	br	200f9d0 <_realloc_r+0x388>
 200f780:	00c00404 	movi	r3,16
 200f784:	1823883a 	mov	r17,r3
 200f788:	003fca06 	br	200f6b4 <_realloc_r+0x6c>
 200f78c:	9829883a 	mov	r20,r19
 200f790:	a447c83a 	sub	r3,r20,r17
 200f794:	010003c4 	movi	r4,15
 200f798:	1080004c 	andi	r2,r2,1
 200f79c:	20c02336 	bltu	r4,r3,200f82c <_realloc_r+0x1e4>
 200f7a0:	1504b03a 	or	r2,r2,r20
 200f7a4:	b0800115 	stw	r2,4(r22)
 200f7a8:	b52d883a 	add	r22,r22,r20
 200f7ac:	b0800117 	ldw	r2,4(r22)
 200f7b0:	10800054 	ori	r2,r2,1
 200f7b4:	b0800115 	stw	r2,4(r22)
 200f7b8:	a809883a 	mov	r4,r21
 200f7bc:	2015c000 	call	2015c00 <__malloc_unlock>
 200f7c0:	8025883a 	mov	r18,r16
 200f7c4:	9005883a 	mov	r2,r18
 200f7c8:	dfc00a17 	ldw	ra,40(sp)
 200f7cc:	df000917 	ldw	fp,36(sp)
 200f7d0:	ddc00817 	ldw	r23,32(sp)
 200f7d4:	dd800717 	ldw	r22,28(sp)
 200f7d8:	dd400617 	ldw	r21,24(sp)
 200f7dc:	dd000517 	ldw	r20,20(sp)
 200f7e0:	dcc00417 	ldw	r19,16(sp)
 200f7e4:	dc800317 	ldw	r18,12(sp)
 200f7e8:	dc400217 	ldw	r17,8(sp)
 200f7ec:	dc000117 	ldw	r16,4(sp)
 200f7f0:	dec00b04 	addi	sp,sp,44
 200f7f4:	f800283a 	ret
 200f7f8:	01ffff04 	movi	r7,-4
 200f7fc:	31cc703a 	and	r6,r6,r7
 200f800:	34e9883a 	add	r20,r6,r19
 200f804:	a0ffbb16 	blt	r20,r3,200f6f4 <_realloc_r+0xac>
 200f808:	20c00317 	ldw	r3,12(r4)
 200f80c:	21000217 	ldw	r4,8(r4)
 200f810:	20c00315 	stw	r3,12(r4)
 200f814:	19000215 	stw	r4,8(r3)
 200f818:	003fdd06 	br	200f790 <_realloc_r+0x148>
 200f81c:	00800304 	movi	r2,12
 200f820:	a8800015 	stw	r2,0(r21)
 200f824:	0025883a 	mov	r18,zero
 200f828:	003fe606 	br	200f7c4 <_realloc_r+0x17c>
 200f82c:	1444b03a 	or	r2,r2,r17
 200f830:	b0800115 	stw	r2,4(r22)
 200f834:	b44b883a 	add	r5,r22,r17
 200f838:	18800054 	ori	r2,r3,1
 200f83c:	28800115 	stw	r2,4(r5)
 200f840:	28c7883a 	add	r3,r5,r3
 200f844:	18800117 	ldw	r2,4(r3)
 200f848:	a809883a 	mov	r4,r21
 200f84c:	29400204 	addi	r5,r5,8
 200f850:	10800054 	ori	r2,r2,1
 200f854:	18800115 	stw	r2,4(r3)
 200f858:	20050b40 	call	20050b4 <_free_r>
 200f85c:	003fd606 	br	200f7b8 <_realloc_r+0x170>
 200f860:	38c0330e 	bge	r7,r3,200f930 <_realloc_r+0x2e8>
 200f864:	900b883a 	mov	r5,r18
 200f868:	a809883a 	mov	r4,r21
 200f86c:	2005e880 	call	2005e88 <_malloc_r>
 200f870:	1025883a 	mov	r18,r2
 200f874:	10001626 	beq	r2,zero,200f8d0 <_realloc_r+0x288>
 200f878:	80bfff17 	ldw	r2,-4(r16)
 200f87c:	00ffff84 	movi	r3,-2
 200f880:	913ffe04 	addi	r4,r18,-8
 200f884:	10c6703a 	and	r3,r2,r3
 200f888:	b0c7883a 	add	r3,r22,r3
 200f88c:	20c09926 	beq	r4,r3,200faf4 <_realloc_r+0x4ac>
 200f890:	99bfff04 	addi	r6,r19,-4
 200f894:	00800904 	movi	r2,36
 200f898:	11806436 	bltu	r2,r6,200fa2c <_realloc_r+0x3e4>
 200f89c:	00c004c4 	movi	r3,19
 200f8a0:	19804036 	bltu	r3,r6,200f9a4 <_realloc_r+0x35c>
 200f8a4:	9005883a 	mov	r2,r18
 200f8a8:	8007883a 	mov	r3,r16
 200f8ac:	19000017 	ldw	r4,0(r3)
 200f8b0:	11000015 	stw	r4,0(r2)
 200f8b4:	19000117 	ldw	r4,4(r3)
 200f8b8:	11000115 	stw	r4,4(r2)
 200f8bc:	18c00217 	ldw	r3,8(r3)
 200f8c0:	10c00215 	stw	r3,8(r2)
 200f8c4:	a809883a 	mov	r4,r21
 200f8c8:	800b883a 	mov	r5,r16
 200f8cc:	20050b40 	call	20050b4 <_free_r>
 200f8d0:	a809883a 	mov	r4,r21
 200f8d4:	2015c000 	call	2015c00 <__malloc_unlock>
 200f8d8:	003fba06 	br	200f7c4 <_realloc_r+0x17c>
 200f8dc:	300b883a 	mov	r5,r6
 200f8e0:	dfc00a17 	ldw	ra,40(sp)
 200f8e4:	df000917 	ldw	fp,36(sp)
 200f8e8:	ddc00817 	ldw	r23,32(sp)
 200f8ec:	dd800717 	ldw	r22,28(sp)
 200f8f0:	dd400617 	ldw	r21,24(sp)
 200f8f4:	dd000517 	ldw	r20,20(sp)
 200f8f8:	dcc00417 	ldw	r19,16(sp)
 200f8fc:	dc800317 	ldw	r18,12(sp)
 200f900:	dc400217 	ldw	r17,8(sp)
 200f904:	dc000117 	ldw	r16,4(sp)
 200f908:	dec00b04 	addi	sp,sp,44
 200f90c:	2005e881 	jmpi	2005e88 <_malloc_r>
 200f910:	29800117 	ldw	r6,4(r5)
 200f914:	013fff04 	movi	r4,-4
 200f918:	89c00404 	addi	r7,r17,16
 200f91c:	310c703a 	and	r6,r6,r4
 200f920:	34c9883a 	add	r4,r6,r19
 200f924:	21c0340e 	bge	r4,r7,200f9f8 <_realloc_r+0x3b0>
 200f928:	2809883a 	mov	r4,r5
 200f92c:	003f7106 	br	200f6f4 <_realloc_r+0xac>
 200f930:	b8800317 	ldw	r2,12(r23)
 200f934:	b8c00217 	ldw	r3,8(r23)
 200f938:	99bfff04 	addi	r6,r19,-4
 200f93c:	01000904 	movi	r4,36
 200f940:	18800315 	stw	r2,12(r3)
 200f944:	10c00215 	stw	r3,8(r2)
 200f948:	bc800204 	addi	r18,r23,8
 200f94c:	21807836 	bltu	r4,r6,200fb30 <_realloc_r+0x4e8>
 200f950:	008004c4 	movi	r2,19
 200f954:	1180732e 	bgeu	r2,r6,200fb24 <_realloc_r+0x4dc>
 200f958:	80800017 	ldw	r2,0(r16)
 200f95c:	b8800215 	stw	r2,8(r23)
 200f960:	80800117 	ldw	r2,4(r16)
 200f964:	b8800315 	stw	r2,12(r23)
 200f968:	008006c4 	movi	r2,27
 200f96c:	11808936 	bltu	r2,r6,200fb94 <_realloc_r+0x54c>
 200f970:	b8800404 	addi	r2,r23,16
 200f974:	80c00204 	addi	r3,r16,8
 200f978:	19000017 	ldw	r4,0(r3)
 200f97c:	9021883a 	mov	r16,r18
 200f980:	3829883a 	mov	r20,r7
 200f984:	11000015 	stw	r4,0(r2)
 200f988:	19000117 	ldw	r4,4(r3)
 200f98c:	b82d883a 	mov	r22,r23
 200f990:	11000115 	stw	r4,4(r2)
 200f994:	18c00217 	ldw	r3,8(r3)
 200f998:	10c00215 	stw	r3,8(r2)
 200f99c:	b8800117 	ldw	r2,4(r23)
 200f9a0:	003f7b06 	br	200f790 <_realloc_r+0x148>
 200f9a4:	80c00017 	ldw	r3,0(r16)
 200f9a8:	90c00015 	stw	r3,0(r18)
 200f9ac:	80c00117 	ldw	r3,4(r16)
 200f9b0:	90c00115 	stw	r3,4(r18)
 200f9b4:	00c006c4 	movi	r3,27
 200f9b8:	19804636 	bltu	r3,r6,200fad4 <_realloc_r+0x48c>
 200f9bc:	90800204 	addi	r2,r18,8
 200f9c0:	80c00204 	addi	r3,r16,8
 200f9c4:	003fb906 	br	200f8ac <_realloc_r+0x264>
 200f9c8:	9005883a 	mov	r2,r18
 200f9cc:	8007883a 	mov	r3,r16
 200f9d0:	19000017 	ldw	r4,0(r3)
 200f9d4:	9021883a 	mov	r16,r18
 200f9d8:	b82d883a 	mov	r22,r23
 200f9dc:	11000015 	stw	r4,0(r2)
 200f9e0:	19000117 	ldw	r4,4(r3)
 200f9e4:	11000115 	stw	r4,4(r2)
 200f9e8:	18c00217 	ldw	r3,8(r3)
 200f9ec:	10c00215 	stw	r3,8(r2)
 200f9f0:	b8800117 	ldw	r2,4(r23)
 200f9f4:	003f6606 	br	200f790 <_realloc_r+0x148>
 200f9f8:	2445c83a 	sub	r2,r4,r17
 200f9fc:	b46d883a 	add	r22,r22,r17
 200fa00:	10800054 	ori	r2,r2,1
 200fa04:	b0800115 	stw	r2,4(r22)
 200fa08:	80bfff17 	ldw	r2,-4(r16)
 200fa0c:	a809883a 	mov	r4,r21
 200fa10:	e5800215 	stw	r22,8(fp)
 200fa14:	1080004c 	andi	r2,r2,1
 200fa18:	88a2b03a 	or	r17,r17,r2
 200fa1c:	847fff15 	stw	r17,-4(r16)
 200fa20:	2015c000 	call	2015c00 <__malloc_unlock>
 200fa24:	8025883a 	mov	r18,r16
 200fa28:	003f6606 	br	200f7c4 <_realloc_r+0x17c>
 200fa2c:	9009883a 	mov	r4,r18
 200fa30:	800b883a 	mov	r5,r16
 200fa34:	20067040 	call	2006704 <memmove>
 200fa38:	003fa206 	br	200f8c4 <_realloc_r+0x27c>
 200fa3c:	88800404 	addi	r2,r17,16
 200fa40:	a0bf8716 	blt	r20,r2,200f860 <_realloc_r+0x218>
 200fa44:	b8800317 	ldw	r2,12(r23)
 200fa48:	b8c00217 	ldw	r3,8(r23)
 200fa4c:	99bfff04 	addi	r6,r19,-4
 200fa50:	01000904 	movi	r4,36
 200fa54:	18800315 	stw	r2,12(r3)
 200fa58:	10c00215 	stw	r3,8(r2)
 200fa5c:	bc800204 	addi	r18,r23,8
 200fa60:	21806536 	bltu	r4,r6,200fbf8 <_realloc_r+0x5b0>
 200fa64:	008004c4 	movi	r2,19
 200fa68:	1180592e 	bgeu	r2,r6,200fbd0 <_realloc_r+0x588>
 200fa6c:	80800017 	ldw	r2,0(r16)
 200fa70:	b8800215 	stw	r2,8(r23)
 200fa74:	80800117 	ldw	r2,4(r16)
 200fa78:	b8800315 	stw	r2,12(r23)
 200fa7c:	008006c4 	movi	r2,27
 200fa80:	11806136 	bltu	r2,r6,200fc08 <_realloc_r+0x5c0>
 200fa84:	b8800404 	addi	r2,r23,16
 200fa88:	80c00204 	addi	r3,r16,8
 200fa8c:	19000017 	ldw	r4,0(r3)
 200fa90:	11000015 	stw	r4,0(r2)
 200fa94:	19000117 	ldw	r4,4(r3)
 200fa98:	11000115 	stw	r4,4(r2)
 200fa9c:	18c00217 	ldw	r3,8(r3)
 200faa0:	10c00215 	stw	r3,8(r2)
 200faa4:	a447c83a 	sub	r3,r20,r17
 200faa8:	bc45883a 	add	r2,r23,r17
 200faac:	18c00054 	ori	r3,r3,1
 200fab0:	10c00115 	stw	r3,4(r2)
 200fab4:	b8c00117 	ldw	r3,4(r23)
 200fab8:	e0800215 	stw	r2,8(fp)
 200fabc:	a809883a 	mov	r4,r21
 200fac0:	1880004c 	andi	r2,r3,1
 200fac4:	88a2b03a 	or	r17,r17,r2
 200fac8:	bc400115 	stw	r17,4(r23)
 200facc:	2015c000 	call	2015c00 <__malloc_unlock>
 200fad0:	003f3c06 	br	200f7c4 <_realloc_r+0x17c>
 200fad4:	80c00217 	ldw	r3,8(r16)
 200fad8:	90c00215 	stw	r3,8(r18)
 200fadc:	80c00317 	ldw	r3,12(r16)
 200fae0:	90c00315 	stw	r3,12(r18)
 200fae4:	30802426 	beq	r6,r2,200fb78 <_realloc_r+0x530>
 200fae8:	90800404 	addi	r2,r18,16
 200faec:	80c00404 	addi	r3,r16,16
 200faf0:	003f6e06 	br	200f8ac <_realloc_r+0x264>
 200faf4:	953fff17 	ldw	r20,-4(r18)
 200faf8:	00ffff04 	movi	r3,-4
 200fafc:	a0e8703a 	and	r20,r20,r3
 200fb00:	a4e9883a 	add	r20,r20,r19
 200fb04:	003f2206 	br	200f790 <_realloc_r+0x148>
 200fb08:	800b883a 	mov	r5,r16
 200fb0c:	9009883a 	mov	r4,r18
 200fb10:	20067040 	call	2006704 <memmove>
 200fb14:	9021883a 	mov	r16,r18
 200fb18:	b8800117 	ldw	r2,4(r23)
 200fb1c:	b82d883a 	mov	r22,r23
 200fb20:	003f1b06 	br	200f790 <_realloc_r+0x148>
 200fb24:	9005883a 	mov	r2,r18
 200fb28:	8007883a 	mov	r3,r16
 200fb2c:	003f9206 	br	200f978 <_realloc_r+0x330>
 200fb30:	800b883a 	mov	r5,r16
 200fb34:	9009883a 	mov	r4,r18
 200fb38:	d9c00015 	stw	r7,0(sp)
 200fb3c:	20067040 	call	2006704 <memmove>
 200fb40:	d9c00017 	ldw	r7,0(sp)
 200fb44:	9021883a 	mov	r16,r18
 200fb48:	b8800117 	ldw	r2,4(r23)
 200fb4c:	3829883a 	mov	r20,r7
 200fb50:	b82d883a 	mov	r22,r23
 200fb54:	003f0e06 	br	200f790 <_realloc_r+0x148>
 200fb58:	80800217 	ldw	r2,8(r16)
 200fb5c:	b8800415 	stw	r2,16(r23)
 200fb60:	80800317 	ldw	r2,12(r16)
 200fb64:	b8800515 	stw	r2,20(r23)
 200fb68:	31001226 	beq	r6,r4,200fbb4 <_realloc_r+0x56c>
 200fb6c:	b8800604 	addi	r2,r23,24
 200fb70:	80c00404 	addi	r3,r16,16
 200fb74:	003f9606 	br	200f9d0 <_realloc_r+0x388>
 200fb78:	81000417 	ldw	r4,16(r16)
 200fb7c:	90800604 	addi	r2,r18,24
 200fb80:	80c00604 	addi	r3,r16,24
 200fb84:	91000415 	stw	r4,16(r18)
 200fb88:	81000517 	ldw	r4,20(r16)
 200fb8c:	91000515 	stw	r4,20(r18)
 200fb90:	003f4606 	br	200f8ac <_realloc_r+0x264>
 200fb94:	80800217 	ldw	r2,8(r16)
 200fb98:	b8800415 	stw	r2,16(r23)
 200fb9c:	80800317 	ldw	r2,12(r16)
 200fba0:	b8800515 	stw	r2,20(r23)
 200fba4:	31000d26 	beq	r6,r4,200fbdc <_realloc_r+0x594>
 200fba8:	b8800604 	addi	r2,r23,24
 200fbac:	80c00404 	addi	r3,r16,16
 200fbb0:	003f7106 	br	200f978 <_realloc_r+0x330>
 200fbb4:	81000417 	ldw	r4,16(r16)
 200fbb8:	b8800804 	addi	r2,r23,32
 200fbbc:	80c00604 	addi	r3,r16,24
 200fbc0:	b9000615 	stw	r4,24(r23)
 200fbc4:	81000517 	ldw	r4,20(r16)
 200fbc8:	b9000715 	stw	r4,28(r23)
 200fbcc:	003f8006 	br	200f9d0 <_realloc_r+0x388>
 200fbd0:	9005883a 	mov	r2,r18
 200fbd4:	8007883a 	mov	r3,r16
 200fbd8:	003fac06 	br	200fa8c <_realloc_r+0x444>
 200fbdc:	81000417 	ldw	r4,16(r16)
 200fbe0:	b8800804 	addi	r2,r23,32
 200fbe4:	80c00604 	addi	r3,r16,24
 200fbe8:	b9000615 	stw	r4,24(r23)
 200fbec:	81000517 	ldw	r4,20(r16)
 200fbf0:	b9000715 	stw	r4,28(r23)
 200fbf4:	003f6006 	br	200f978 <_realloc_r+0x330>
 200fbf8:	9009883a 	mov	r4,r18
 200fbfc:	800b883a 	mov	r5,r16
 200fc00:	20067040 	call	2006704 <memmove>
 200fc04:	003fa706 	br	200faa4 <_realloc_r+0x45c>
 200fc08:	80800217 	ldw	r2,8(r16)
 200fc0c:	b8800415 	stw	r2,16(r23)
 200fc10:	80800317 	ldw	r2,12(r16)
 200fc14:	b8800515 	stw	r2,20(r23)
 200fc18:	31000326 	beq	r6,r4,200fc28 <_realloc_r+0x5e0>
 200fc1c:	b8800604 	addi	r2,r23,24
 200fc20:	80c00404 	addi	r3,r16,16
 200fc24:	003f9906 	br	200fa8c <_realloc_r+0x444>
 200fc28:	81000417 	ldw	r4,16(r16)
 200fc2c:	b8800804 	addi	r2,r23,32
 200fc30:	80c00604 	addi	r3,r16,24
 200fc34:	b9000615 	stw	r4,24(r23)
 200fc38:	81000517 	ldw	r4,20(r16)
 200fc3c:	b9000715 	stw	r4,28(r23)
 200fc40:	003f9206 	br	200fa8c <_realloc_r+0x444>

0200fc44 <__isinfd>:
 200fc44:	0105c83a 	sub	r2,zero,r4
 200fc48:	1108b03a 	or	r4,r2,r4
 200fc4c:	2004d7fa 	srli	r2,r4,31
 200fc50:	00e00034 	movhi	r3,32768
 200fc54:	18ffffc4 	addi	r3,r3,-1
 200fc58:	28ca703a 	and	r5,r5,r3
 200fc5c:	1144b03a 	or	r2,r2,r5
 200fc60:	00dffc34 	movhi	r3,32752
 200fc64:	1885c83a 	sub	r2,r3,r2
 200fc68:	0087c83a 	sub	r3,zero,r2
 200fc6c:	1884b03a 	or	r2,r3,r2
 200fc70:	1005d7fa 	srai	r2,r2,31
 200fc74:	10800044 	addi	r2,r2,1
 200fc78:	f800283a 	ret

0200fc7c <__isnand>:
 200fc7c:	0105c83a 	sub	r2,zero,r4
 200fc80:	1108b03a 	or	r4,r2,r4
 200fc84:	2004d7fa 	srli	r2,r4,31
 200fc88:	00e00034 	movhi	r3,32768
 200fc8c:	18ffffc4 	addi	r3,r3,-1
 200fc90:	28ca703a 	and	r5,r5,r3
 200fc94:	1144b03a 	or	r2,r2,r5
 200fc98:	00dffc34 	movhi	r3,32752
 200fc9c:	1885c83a 	sub	r2,r3,r2
 200fca0:	1004d7fa 	srli	r2,r2,31
 200fca4:	f800283a 	ret

0200fca8 <__sccl>:
 200fca8:	2a400003 	ldbu	r9,0(r5)
 200fcac:	00801784 	movi	r2,94
 200fcb0:	48802626 	beq	r9,r2,200fd4c <__sccl+0xa4>
 200fcb4:	28800044 	addi	r2,r5,1
 200fcb8:	0011883a 	mov	r8,zero
 200fcbc:	000b883a 	mov	r5,zero
 200fcc0:	0007883a 	mov	r3,zero
 200fcc4:	01c04004 	movi	r7,256
 200fcc8:	20cd883a 	add	r6,r4,r3
 200fccc:	32000005 	stb	r8,0(r6)
 200fcd0:	18c00044 	addi	r3,r3,1
 200fcd4:	19fffc1e 	bne	r3,r7,200fcc8 <__sccl+0x20>
 200fcd8:	48000f26 	beq	r9,zero,200fd18 <__sccl+0x70>
 200fcdc:	01800044 	movi	r6,1
 200fce0:	314dc83a 	sub	r6,r6,r5
 200fce4:	02001744 	movi	r8,93
 200fce8:	01400b44 	movi	r5,45
 200fcec:	2247883a 	add	r3,r4,r9
 200fcf0:	19800005 	stb	r6,0(r3)
 200fcf4:	10c00003 	ldbu	r3,0(r2)
 200fcf8:	11c00044 	addi	r7,r2,1
 200fcfc:	19400a26 	beq	r3,r5,200fd28 <__sccl+0x80>
 200fd00:	1a000726 	beq	r3,r8,200fd20 <__sccl+0x78>
 200fd04:	1800011e 	bne	r3,zero,200fd0c <__sccl+0x64>
 200fd08:	f800283a 	ret
 200fd0c:	1813883a 	mov	r9,r3
 200fd10:	3805883a 	mov	r2,r7
 200fd14:	003ff506 	br	200fcec <__sccl+0x44>
 200fd18:	10bfffc4 	addi	r2,r2,-1
 200fd1c:	f800283a 	ret
 200fd20:	3805883a 	mov	r2,r7
 200fd24:	f800283a 	ret
 200fd28:	10c00043 	ldbu	r3,1(r2)
 200fd2c:	1a000c26 	beq	r3,r8,200fd60 <__sccl+0xb8>
 200fd30:	1a400b16 	blt	r3,r9,200fd60 <__sccl+0xb8>
 200fd34:	10800084 	addi	r2,r2,2
 200fd38:	4a400044 	addi	r9,r9,1
 200fd3c:	224f883a 	add	r7,r4,r9
 200fd40:	39800005 	stb	r6,0(r7)
 200fd44:	48fffc16 	blt	r9,r3,200fd38 <__sccl+0x90>
 200fd48:	003fea06 	br	200fcf4 <__sccl+0x4c>
 200fd4c:	2a400043 	ldbu	r9,1(r5)
 200fd50:	28800084 	addi	r2,r5,2
 200fd54:	02000044 	movi	r8,1
 200fd58:	01400044 	movi	r5,1
 200fd5c:	003fd806 	br	200fcc0 <__sccl+0x18>
 200fd60:	2813883a 	mov	r9,r5
 200fd64:	3805883a 	mov	r2,r7
 200fd68:	003fe006 	br	200fcec <__sccl+0x44>

0200fd6c <nanf>:
 200fd6c:	009ff034 	movhi	r2,32704
 200fd70:	f800283a 	ret

0200fd74 <_strtod_r>:
 200fd74:	deffe004 	addi	sp,sp,-128
 200fd78:	dd801c15 	stw	r22,112(sp)
 200fd7c:	dc001615 	stw	r16,88(sp)
 200fd80:	282d883a 	mov	r22,r5
 200fd84:	d9801115 	stw	r6,68(sp)
 200fd88:	d9400c15 	stw	r5,48(sp)
 200fd8c:	2807883a 	mov	r3,r5
 200fd90:	dfc01f15 	stw	ra,124(sp)
 200fd94:	df001e15 	stw	fp,120(sp)
 200fd98:	ddc01d15 	stw	r23,116(sp)
 200fd9c:	dd401b15 	stw	r21,108(sp)
 200fda0:	dd001a15 	stw	r20,104(sp)
 200fda4:	dcc01915 	stw	r19,100(sp)
 200fda8:	dc801815 	stw	r18,96(sp)
 200fdac:	dc401715 	stw	r17,92(sp)
 200fdb0:	2021883a 	mov	r16,r4
 200fdb4:	d8000615 	stw	zero,24(sp)
 200fdb8:	d8000715 	stw	zero,28(sp)
 200fdbc:	01400b44 	movi	r5,45
 200fdc0:	01808074 	movhi	r6,513
 200fdc4:	31bfd904 	addi	r6,r6,-156
 200fdc8:	18800003 	ldbu	r2,0(r3)
 200fdcc:	11003fcc 	andi	r4,r2,255
 200fdd0:	29005f2e 	bgeu	r5,r4,200ff50 <_strtod_r+0x1dc>
 200fdd4:	10803fcc 	andi	r2,r2,255
 200fdd8:	1080201c 	xori	r2,r2,128
 200fddc:	1811883a 	mov	r8,r3
 200fde0:	d8001215 	stw	zero,72(sp)
 200fde4:	10bfe004 	addi	r2,r2,-128
 200fde8:	00c00c04 	movi	r3,48
 200fdec:	10c10426 	beq	r2,r3,2010200 <_strtod_r+0x48c>
 200fdf0:	000b883a 	mov	r5,zero
 200fdf4:	02400bc4 	movi	r9,47
 200fdf8:	100f883a 	mov	r7,r2
 200fdfc:	48843e0e 	bge	r9,r2,2010ef8 <_strtod_r+0x1184>
 200fe00:	02c00e44 	movi	r11,57
 200fe04:	58844116 	blt	r11,r2,2010f0c <_strtod_r+0x1198>
 200fe08:	40c00044 	addi	r3,r8,1
 200fe0c:	0029883a 	mov	r20,zero
 200fe10:	0025883a 	mov	r18,zero
 200fe14:	0023883a 	mov	r17,zero
 200fe18:	02800204 	movi	r10,8
 200fe1c:	010003c4 	movi	r4,15
 200fe20:	5440a216 	blt	r10,r17,20100ac <_strtod_r+0x338>
 200fe24:	948002a4 	muli	r18,r18,10
 200fe28:	90a5883a 	add	r18,r18,r2
 200fe2c:	94bff404 	addi	r18,r18,-48
 200fe30:	d8c00c15 	stw	r3,48(sp)
 200fe34:	18800007 	ldb	r2,0(r3)
 200fe38:	8c400044 	addi	r17,r17,1
 200fe3c:	180d883a 	mov	r6,r3
 200fe40:	100f883a 	mov	r7,r2
 200fe44:	4880a30e 	bge	r9,r2,20100d4 <_strtod_r+0x360>
 200fe48:	18c00044 	addi	r3,r3,1
 200fe4c:	58bff40e 	bge	r11,r2,200fe20 <_strtod_r+0xac>
 200fe50:	4027883a 	mov	r19,r8
 200fe54:	882b883a 	mov	r21,r17
 200fe58:	0007883a 	mov	r3,zero
 200fe5c:	000d883a 	mov	r6,zero
 200fe60:	0011883a 	mov	r8,zero
 200fe64:	00801944 	movi	r2,101
 200fe68:	3880f426 	beq	r7,r2,201023c <_strtod_r+0x4c8>
 200fe6c:	00801144 	movi	r2,69
 200fe70:	3880f226 	beq	r7,r2,201023c <_strtod_r+0x4c8>
 200fe74:	0009883a 	mov	r4,zero
 200fe78:	8800ca26 	beq	r17,zero,20101a4 <_strtod_r+0x430>
 200fe7c:	218dc83a 	sub	r6,r4,r6
 200fe80:	d9801015 	stw	r6,64(sp)
 200fe84:	a800011e 	bne	r21,zero,200fe8c <_strtod_r+0x118>
 200fe88:	882b883a 	mov	r21,r17
 200fe8c:	00800404 	movi	r2,16
 200fe90:	882d883a 	mov	r22,r17
 200fe94:	1440010e 	bge	r2,r17,200fe9c <_strtod_r+0x128>
 200fe98:	102d883a 	mov	r22,r2
 200fe9c:	9009883a 	mov	r4,r18
 200fea0:	20145600 	call	2014560 <__floatunsidf>
 200fea4:	d8800615 	stw	r2,24(sp)
 200fea8:	d8c00715 	stw	r3,28(sp)
 200feac:	01000244 	movi	r4,9
 200feb0:	2580150e 	bge	r4,r22,200ff08 <_strtod_r+0x194>
 200feb4:	b13ffdc4 	addi	r4,r22,-9
 200feb8:	200890fa 	slli	r4,r4,3
 200febc:	180b883a 	mov	r5,r3
 200fec0:	00c08174 	movhi	r3,517
 200fec4:	18f7cf04 	addi	r3,r3,-8388
 200fec8:	1907883a 	add	r3,r3,r4
 200fecc:	19800017 	ldw	r6,0(r3)
 200fed0:	19c00117 	ldw	r7,4(r3)
 200fed4:	1009883a 	mov	r4,r2
 200fed8:	2013c880 	call	2013c88 <__muldf3>
 200fedc:	a009883a 	mov	r4,r20
 200fee0:	102f883a 	mov	r23,r2
 200fee4:	1839883a 	mov	fp,r3
 200fee8:	20145600 	call	2014560 <__floatunsidf>
 200feec:	b809883a 	mov	r4,r23
 200fef0:	e00b883a 	mov	r5,fp
 200fef4:	100d883a 	mov	r6,r2
 200fef8:	180f883a 	mov	r7,r3
 200fefc:	2013bd40 	call	2013bd4 <__adddf3>
 200ff00:	d8800615 	stw	r2,24(sp)
 200ff04:	d8c00715 	stw	r3,28(sp)
 200ff08:	008003c4 	movi	r2,15
 200ff0c:	14411416 	blt	r2,r17,2010360 <_strtod_r+0x5ec>
 200ff10:	d9001017 	ldw	r4,64(sp)
 200ff14:	20010f26 	beq	r4,zero,2010354 <_strtod_r+0x5e0>
 200ff18:	d9401017 	ldw	r5,64(sp)
 200ff1c:	01441a0e 	bge	zero,r5,2010f88 <_strtod_r+0x1214>
 200ff20:	00c00584 	movi	r3,22
 200ff24:	1943fd16 	blt	r3,r5,2010f1c <_strtod_r+0x11a8>
 200ff28:	280490fa 	slli	r2,r5,3
 200ff2c:	00c08174 	movhi	r3,517
 200ff30:	18f7cf04 	addi	r3,r3,-8388
 200ff34:	d9000617 	ldw	r4,24(sp)
 200ff38:	1885883a 	add	r2,r3,r2
 200ff3c:	d9400717 	ldw	r5,28(sp)
 200ff40:	11800017 	ldw	r6,0(r2)
 200ff44:	11c00117 	ldw	r7,4(r2)
 200ff48:	2013c880 	call	2013c88 <__muldf3>
 200ff4c:	00003c06 	br	2010040 <_strtod_r+0x2cc>
 200ff50:	2109883a 	add	r4,r4,r4
 200ff54:	2109883a 	add	r4,r4,r4
 200ff58:	2189883a 	add	r4,r4,r6
 200ff5c:	21000017 	ldw	r4,0(r4)
 200ff60:	2000683a 	jmp	r4
 200ff64:	020100a4 	muli	r8,zero,1026
 200ff68:	0200fdd4 	movui	r8,1015
 200ff6c:	0200fdd4 	movui	r8,1015
 200ff70:	0200fdd4 	movui	r8,1015
 200ff74:	0200fdd4 	movui	r8,1015
 200ff78:	0200fdd4 	movui	r8,1015
 200ff7c:	0200fdd4 	movui	r8,1015
 200ff80:	0200fdd4 	movui	r8,1015
 200ff84:	0200fdd4 	movui	r8,1015
 200ff88:	02010098 	cmpnei	r8,zero,1026
 200ff8c:	02010098 	cmpnei	r8,zero,1026
 200ff90:	02010098 	cmpnei	r8,zero,1026
 200ff94:	02010098 	cmpnei	r8,zero,1026
 200ff98:	02010098 	cmpnei	r8,zero,1026
 200ff9c:	0200fdd4 	movui	r8,1015
 200ffa0:	0200fdd4 	movui	r8,1015
 200ffa4:	0200fdd4 	movui	r8,1015
 200ffa8:	0200fdd4 	movui	r8,1015
 200ffac:	0200fdd4 	movui	r8,1015
 200ffb0:	0200fdd4 	movui	r8,1015
 200ffb4:	0200fdd4 	movui	r8,1015
 200ffb8:	0200fdd4 	movui	r8,1015
 200ffbc:	0200fdd4 	movui	r8,1015
 200ffc0:	0200fdd4 	movui	r8,1015
 200ffc4:	0200fdd4 	movui	r8,1015
 200ffc8:	0200fdd4 	movui	r8,1015
 200ffcc:	0200fdd4 	movui	r8,1015
 200ffd0:	0200fdd4 	movui	r8,1015
 200ffd4:	0200fdd4 	movui	r8,1015
 200ffd8:	0200fdd4 	movui	r8,1015
 200ffdc:	0200fdd4 	movui	r8,1015
 200ffe0:	0200fdd4 	movui	r8,1015
 200ffe4:	02010098 	cmpnei	r8,zero,1026
 200ffe8:	0200fdd4 	movui	r8,1015
 200ffec:	0200fdd4 	movui	r8,1015
 200fff0:	0200fdd4 	movui	r8,1015
 200fff4:	0200fdd4 	movui	r8,1015
 200fff8:	0200fdd4 	movui	r8,1015
 200fffc:	0200fdd4 	movui	r8,1015
 2010000:	0200fdd4 	movui	r8,1015
 2010004:	0200fdd4 	movui	r8,1015
 2010008:	0200fdd4 	movui	r8,1015
 201000c:	0200fdd4 	movui	r8,1015
 2010010:	02010090 	cmplti	r8,zero,1026
 2010014:	0200fdd4 	movui	r8,1015
 2010018:	0201001c 	xori	r8,zero,1024
 201001c:	00800044 	movi	r2,1
 2010020:	d8801215 	stw	r2,72(sp)
 2010024:	1a000044 	addi	r8,r3,1
 2010028:	da000c15 	stw	r8,48(sp)
 201002c:	18800047 	ldb	r2,1(r3)
 2010030:	103f6d1e 	bne	r2,zero,200fde8 <_strtod_r+0x74>
 2010034:	0007883a 	mov	r3,zero
 2010038:	dd800c15 	stw	r22,48(sp)
 201003c:	d8001215 	stw	zero,72(sp)
 2010040:	d9001117 	ldw	r4,68(sp)
 2010044:	20000326 	beq	r4,zero,2010054 <_strtod_r+0x2e0>
 2010048:	d9000c17 	ldw	r4,48(sp)
 201004c:	d9401117 	ldw	r5,68(sp)
 2010050:	29000015 	stw	r4,0(r5)
 2010054:	d9001217 	ldw	r4,72(sp)
 2010058:	20000126 	beq	r4,zero,2010060 <_strtod_r+0x2ec>
 201005c:	18e0003c 	xorhi	r3,r3,32768
 2010060:	dfc01f17 	ldw	ra,124(sp)
 2010064:	df001e17 	ldw	fp,120(sp)
 2010068:	ddc01d17 	ldw	r23,116(sp)
 201006c:	dd801c17 	ldw	r22,112(sp)
 2010070:	dd401b17 	ldw	r21,108(sp)
 2010074:	dd001a17 	ldw	r20,104(sp)
 2010078:	dcc01917 	ldw	r19,100(sp)
 201007c:	dc801817 	ldw	r18,96(sp)
 2010080:	dc401717 	ldw	r17,92(sp)
 2010084:	dc001617 	ldw	r16,88(sp)
 2010088:	dec02004 	addi	sp,sp,128
 201008c:	f800283a 	ret
 2010090:	d8001215 	stw	zero,72(sp)
 2010094:	003fe306 	br	2010024 <_strtod_r+0x2b0>
 2010098:	18c00044 	addi	r3,r3,1
 201009c:	d8c00c15 	stw	r3,48(sp)
 20100a0:	003f4906 	br	200fdc8 <_strtod_r+0x54>
 20100a4:	0005883a 	mov	r2,zero
 20100a8:	003fe206 	br	2010034 <_strtod_r+0x2c0>
 20100ac:	247f6016 	blt	r4,r17,200fe30 <_strtod_r+0xbc>
 20100b0:	a50002a4 	muli	r20,r20,10
 20100b4:	d8c00c15 	stw	r3,48(sp)
 20100b8:	8c400044 	addi	r17,r17,1
 20100bc:	a0a9883a 	add	r20,r20,r2
 20100c0:	18800007 	ldb	r2,0(r3)
 20100c4:	a53ff404 	addi	r20,r20,-48
 20100c8:	180d883a 	mov	r6,r3
 20100cc:	100f883a 	mov	r7,r2
 20100d0:	48bf5d16 	blt	r9,r2,200fe48 <_strtod_r+0xd4>
 20100d4:	00c00b84 	movi	r3,46
 20100d8:	10c0901e 	bne	r2,r3,201031c <_strtod_r+0x5a8>
 20100dc:	30800044 	addi	r2,r6,1
 20100e0:	d8800c15 	stw	r2,48(sp)
 20100e4:	31c00047 	ldb	r7,1(r6)
 20100e8:	8802221e 	bne	r17,zero,2010974 <_strtod_r+0xc00>
 20100ec:	00800c04 	movi	r2,48
 20100f0:	3883cd1e 	bne	r7,r2,2011028 <_strtod_r+0x12b4>
 20100f4:	00800044 	movi	r2,1
 20100f8:	3813883a 	mov	r9,r7
 20100fc:	1007883a 	mov	r3,r2
 2010100:	10800044 	addi	r2,r2,1
 2010104:	3089883a 	add	r4,r6,r2
 2010108:	d9000c15 	stw	r4,48(sp)
 201010c:	30c9883a 	add	r4,r6,r3
 2010110:	21c00047 	ldb	r7,1(r4)
 2010114:	3a7ff926 	beq	r7,r9,20100fc <_strtod_r+0x388>
 2010118:	38bff3c4 	addi	r2,r7,-49
 201011c:	01000204 	movi	r4,8
 2010120:	20826d36 	bltu	r4,r2,2010ad8 <_strtod_r+0xd64>
 2010124:	dcc00c17 	ldw	r19,48(sp)
 2010128:	180d883a 	mov	r6,r3
 201012c:	0013883a 	mov	r9,zero
 2010130:	9817883a 	mov	r11,r19
 2010134:	00c00044 	movi	r3,1
 2010138:	3a3ff404 	addi	r8,r7,-48
 201013c:	40001526 	beq	r8,zero,2010194 <_strtod_r+0x420>
 2010140:	00800044 	movi	r2,1
 2010144:	30cd883a 	add	r6,r6,r3
 2010148:	18840126 	beq	r3,r2,2011150 <_strtod_r+0x13dc>
 201014c:	48d5883a 	add	r10,r9,r3
 2010150:	52bfffc4 	addi	r10,r10,-1
 2010154:	4805883a 	mov	r2,r9
 2010158:	01c00204 	movi	r7,8
 201015c:	03000404 	movi	r12,16
 2010160:	10800044 	addi	r2,r2,1
 2010164:	113fffc4 	addi	r4,r2,-1
 2010168:	39028016 	blt	r7,r4,2010b6c <_strtod_r+0xdf8>
 201016c:	948002a4 	muli	r18,r18,10
 2010170:	12bffb1e 	bne	r2,r10,2010160 <_strtod_r+0x3ec>
 2010174:	48c5883a 	add	r2,r9,r3
 2010178:	10bfffc4 	addi	r2,r2,-1
 201017c:	00c00204 	movi	r3,8
 2010180:	12400044 	addi	r9,r2,1
 2010184:	1883a216 	blt	r3,r2,2011010 <_strtod_r+0x129c>
 2010188:	948002a4 	muli	r18,r18,10
 201018c:	0007883a 	mov	r3,zero
 2010190:	9225883a 	add	r18,r18,r8
 2010194:	58800044 	addi	r2,r11,1
 2010198:	d8800c15 	stw	r2,48(sp)
 201019c:	59c00047 	ldb	r7,1(r11)
 20101a0:	0001f806 	br	2010984 <_strtod_r+0xc10>
 20101a4:	18006b1e 	bne	r3,zero,2010354 <_strtod_r+0x5e0>
 20101a8:	28006a1e 	bne	r5,zero,2010354 <_strtod_r+0x5e0>
 20101ac:	4002131e 	bne	r8,zero,20109fc <_strtod_r+0xc88>
 20101b0:	00801384 	movi	r2,78
 20101b4:	38838526 	beq	r7,r2,2010fcc <_strtod_r+0x1258>
 20101b8:	11c38016 	blt	r2,r7,2010fbc <_strtod_r+0x1248>
 20101bc:	00801244 	movi	r2,73
 20101c0:	38820e1e 	bne	r7,r2,20109fc <_strtod_r+0xc88>
 20101c4:	d8800c17 	ldw	r2,48(sp)
 20101c8:	01008174 	movhi	r4,517
 20101cc:	21380404 	addi	r4,r4,-8176
 20101d0:	01801004 	movi	r6,64
 20101d4:	01c01684 	movi	r7,90
 20101d8:	21400007 	ldb	r5,0(r4)
 20101dc:	21000044 	addi	r4,r4,1
 20101e0:	2803c126 	beq	r5,zero,20110e8 <_strtod_r+0x1374>
 20101e4:	10800044 	addi	r2,r2,1
 20101e8:	10c00007 	ldb	r3,0(r2)
 20101ec:	30c0020e 	bge	r6,r3,20101f8 <_strtod_r+0x484>
 20101f0:	38c00116 	blt	r7,r3,20101f8 <_strtod_r+0x484>
 20101f4:	18c00804 	addi	r3,r3,32
 20101f8:	197ff726 	beq	r3,r5,20101d8 <_strtod_r+0x464>
 20101fc:	0001ff06 	br	20109fc <_strtod_r+0xc88>
 2010200:	40c00047 	ldb	r3,1(r8)
 2010204:	01001604 	movi	r4,88
 2010208:	19025b26 	beq	r3,r4,2010b78 <_strtod_r+0xe04>
 201020c:	01001e04 	movi	r4,120
 2010210:	19025926 	beq	r3,r4,2010b78 <_strtod_r+0xe04>
 2010214:	40c00044 	addi	r3,r8,1
 2010218:	1009883a 	mov	r4,r2
 201021c:	d8c00c15 	stw	r3,48(sp)
 2010220:	18800007 	ldb	r2,0(r3)
 2010224:	1811883a 	mov	r8,r3
 2010228:	18c00044 	addi	r3,r3,1
 201022c:	113ffb26 	beq	r2,r4,201021c <_strtod_r+0x4a8>
 2010230:	1001e126 	beq	r2,zero,20109b8 <_strtod_r+0xc44>
 2010234:	01400044 	movi	r5,1
 2010238:	003eee06 	br	200fdf4 <_strtod_r+0x80>
 201023c:	8800011e 	bne	r17,zero,2010244 <_strtod_r+0x4d0>
 2010240:	1801ed26 	beq	r3,zero,20109f8 <_strtod_r+0xc84>
 2010244:	dd800c17 	ldw	r22,48(sp)
 2010248:	b0800044 	addi	r2,r22,1
 201024c:	d8800c15 	stw	r2,48(sp)
 2010250:	b1c00047 	ldb	r7,1(r22)
 2010254:	00800ac4 	movi	r2,43
 2010258:	3881d526 	beq	r7,r2,20109b0 <_strtod_r+0xc3c>
 201025c:	00800b44 	movi	r2,45
 2010260:	3881ce26 	beq	r7,r2,201099c <_strtod_r+0xc28>
 2010264:	0015883a 	mov	r10,zero
 2010268:	38bff404 	addi	r2,r7,-48
 201026c:	01000244 	movi	r4,9
 2010270:	2081bc36 	bltu	r4,r2,2010964 <_strtod_r+0xbf0>
 2010274:	00800c04 	movi	r2,48
 2010278:	3880071e 	bne	r7,r2,2010298 <_strtod_r+0x524>
 201027c:	d8800c17 	ldw	r2,48(sp)
 2010280:	3809883a 	mov	r4,r7
 2010284:	10800044 	addi	r2,r2,1
 2010288:	d8800c15 	stw	r2,48(sp)
 201028c:	11c00007 	ldb	r7,0(r2)
 2010290:	10800044 	addi	r2,r2,1
 2010294:	393ffc26 	beq	r7,r4,2010288 <_strtod_r+0x514>
 2010298:	38bff3c4 	addi	r2,r7,-49
 201029c:	01000204 	movi	r4,8
 20102a0:	20bef436 	bltu	r4,r2,200fe74 <_strtod_r+0x100>
 20102a4:	db400c17 	ldw	r13,48(sp)
 20102a8:	393ff404 	addi	r4,r7,-48
 20102ac:	02c00bc4 	movi	r11,47
 20102b0:	6a400044 	addi	r9,r13,1
 20102b4:	da400c15 	stw	r9,48(sp)
 20102b8:	69c00047 	ldb	r7,1(r13)
 20102bc:	59c00d0e 	bge	r11,r7,20102f4 <_strtod_r+0x580>
 20102c0:	03000e44 	movi	r12,57
 20102c4:	61c00b16 	blt	r12,r7,20102f4 <_strtod_r+0x580>
 20102c8:	68800084 	addi	r2,r13,2
 20102cc:	00000206 	br	20102d8 <_strtod_r+0x564>
 20102d0:	10800044 	addi	r2,r2,1
 20102d4:	61c00716 	blt	r12,r7,20102f4 <_strtod_r+0x580>
 20102d8:	210002a4 	muli	r4,r4,10
 20102dc:	d8800c15 	stw	r2,48(sp)
 20102e0:	1013883a 	mov	r9,r2
 20102e4:	21c9883a 	add	r4,r4,r7
 20102e8:	11c00007 	ldb	r7,0(r2)
 20102ec:	213ff404 	addi	r4,r4,-48
 20102f0:	59fff716 	blt	r11,r7,20102d0 <_strtod_r+0x55c>
 20102f4:	4b53c83a 	sub	r9,r9,r13
 20102f8:	00800204 	movi	r2,8
 20102fc:	1242fc16 	blt	r2,r9,2010ef0 <_strtod_r+0x117c>
 2010300:	009387c4 	movi	r2,19999
 2010304:	1100010e 	bge	r2,r4,201030c <_strtod_r+0x598>
 2010308:	1009883a 	mov	r4,r2
 201030c:	503eda26 	beq	r10,zero,200fe78 <_strtod_r+0x104>
 2010310:	0109c83a 	sub	r4,zero,r4
 2010314:	883ed91e 	bne	r17,zero,200fe7c <_strtod_r+0x108>
 2010318:	003fa206 	br	20101a4 <_strtod_r+0x430>
 201031c:	4027883a 	mov	r19,r8
 2010320:	882b883a 	mov	r21,r17
 2010324:	0007883a 	mov	r3,zero
 2010328:	000d883a 	mov	r6,zero
 201032c:	0011883a 	mov	r8,zero
 2010330:	003ece06 	br	200fe6c <_strtod_r+0xf8>
 2010334:	00dffc34 	movhi	r3,32752
 2010338:	d8c00715 	stw	r3,28(sp)
 201033c:	d8000615 	stw	zero,24(sp)
 2010340:	1080020c 	andi	r2,r2,8
 2010344:	10000326 	beq	r2,zero,2010354 <_strtod_r+0x5e0>
 2010348:	d8800717 	ldw	r2,28(sp)
 201034c:	10a00034 	orhi	r2,r2,32768
 2010350:	d8800715 	stw	r2,28(sp)
 2010354:	d8800617 	ldw	r2,24(sp)
 2010358:	d8c00717 	ldw	r3,28(sp)
 201035c:	003f3806 	br	2010040 <_strtod_r+0x2cc>
 2010360:	d9001017 	ldw	r4,64(sp)
 2010364:	8dadc83a 	sub	r22,r17,r22
 2010368:	25ad883a 	add	r22,r4,r22
 201036c:	05829b0e 	bge	zero,r22,2010ddc <_strtod_r+0x1068>
 2010370:	b08003cc 	andi	r2,r22,15
 2010374:	10000b26 	beq	r2,zero,20103a4 <_strtod_r+0x630>
 2010378:	100490fa 	slli	r2,r2,3
 201037c:	00c08174 	movhi	r3,517
 2010380:	18f7cf04 	addi	r3,r3,-8388
 2010384:	d9000617 	ldw	r4,24(sp)
 2010388:	1885883a 	add	r2,r3,r2
 201038c:	d9400717 	ldw	r5,28(sp)
 2010390:	11800017 	ldw	r6,0(r2)
 2010394:	11c00117 	ldw	r7,4(r2)
 2010398:	2013c880 	call	2013c88 <__muldf3>
 201039c:	d8800615 	stw	r2,24(sp)
 20103a0:	d8c00715 	stw	r3,28(sp)
 20103a4:	00bffc04 	movi	r2,-16
 20103a8:	b0ac703a 	and	r22,r22,r2
 20103ac:	b0019a1e 	bne	r22,zero,2010a18 <_strtod_r+0xca4>
 20103b0:	0029883a 	mov	r20,zero
 20103b4:	8009883a 	mov	r4,r16
 20103b8:	980b883a 	mov	r5,r19
 20103bc:	dc800015 	stw	r18,0(sp)
 20103c0:	a80d883a 	mov	r6,r21
 20103c4:	880f883a 	mov	r7,r17
 20103c8:	200e8180 	call	200e818 <__s2b>
 20103cc:	d9001017 	ldw	r4,64(sp)
 20103d0:	102d883a 	mov	r22,r2
 20103d4:	b1400304 	addi	r5,r22,12
 20103d8:	2005d7fa 	srai	r2,r4,31
 20103dc:	0107c83a 	sub	r3,zero,r4
 20103e0:	d9401315 	stw	r5,76(sp)
 20103e4:	1886703a 	and	r3,r3,r2
 20103e8:	d8c00e15 	stw	r3,56(sp)
 20103ec:	b1400117 	ldw	r5,4(r22)
 20103f0:	8009883a 	mov	r4,r16
 20103f4:	0027883a 	mov	r19,zero
 20103f8:	200e6340 	call	200e634 <_Balloc>
 20103fc:	b1800417 	ldw	r6,16(r22)
 2010400:	d9401317 	ldw	r5,76(sp)
 2010404:	11000304 	addi	r4,r2,12
 2010408:	31800084 	addi	r6,r6,2
 201040c:	318d883a 	add	r6,r6,r6
 2010410:	318d883a 	add	r6,r6,r6
 2010414:	1025883a 	mov	r18,r2
 2010418:	200660c0 	call	200660c <memcpy>
 201041c:	d9400617 	ldw	r5,24(sp)
 2010420:	d9800717 	ldw	r6,28(sp)
 2010424:	d8800a04 	addi	r2,sp,40
 2010428:	8009883a 	mov	r4,r16
 201042c:	d9c00d04 	addi	r7,sp,52
 2010430:	d8800015 	stw	r2,0(sp)
 2010434:	200f2800 	call	200f280 <__d2b>
 2010438:	8009883a 	mov	r4,r16
 201043c:	01400044 	movi	r5,1
 2010440:	d8800b15 	stw	r2,44(sp)
 2010444:	200ea340 	call	200ea34 <__i2b>
 2010448:	d8c01017 	ldw	r3,64(sp)
 201044c:	1023883a 	mov	r17,r2
 2010450:	00c0010e 	bge	zero,r3,2010458 <_strtod_r+0x6e4>
 2010454:	1827883a 	mov	r19,r3
 2010458:	d8800d17 	ldw	r2,52(sp)
 201045c:	1000de16 	blt	r2,zero,20107d8 <_strtod_r+0xa64>
 2010460:	d9000e17 	ldw	r4,56(sp)
 2010464:	9807883a 	mov	r3,r19
 2010468:	20af883a 	add	r23,r4,r2
 201046c:	d9000a17 	ldw	r4,40(sp)
 2010470:	1505c83a 	sub	r2,r2,r20
 2010474:	017f00c4 	movi	r5,-1021
 2010478:	110d883a 	add	r6,r2,r4
 201047c:	31409a0e 	bge	r6,r5,20106e8 <_strtod_r+0x974>
 2010480:	10810cc4 	addi	r2,r2,1075
 2010484:	b8b9883a 	add	fp,r23,r2
 2010488:	1885883a 	add	r2,r3,r2
 201048c:	152b883a 	add	r21,r2,r20
 2010490:	e005883a 	mov	r2,fp
 2010494:	bf00010e 	bge	r23,fp,201049c <_strtod_r+0x728>
 2010498:	b805883a 	mov	r2,r23
 201049c:	a880010e 	bge	r21,r2,20104a4 <_strtod_r+0x730>
 20104a0:	a805883a 	mov	r2,r21
 20104a4:	0080030e 	bge	zero,r2,20104b4 <_strtod_r+0x740>
 20104a8:	e0b9c83a 	sub	fp,fp,r2
 20104ac:	a8abc83a 	sub	r21,r21,r2
 20104b0:	b8afc83a 	sub	r23,r23,r2
 20104b4:	d9400e17 	ldw	r5,56(sp)
 20104b8:	28000f26 	beq	r5,zero,20104f8 <_strtod_r+0x784>
 20104bc:	280d883a 	mov	r6,r5
 20104c0:	8009883a 	mov	r4,r16
 20104c4:	880b883a 	mov	r5,r17
 20104c8:	200ec500 	call	200ec50 <__pow5mult>
 20104cc:	d9800b17 	ldw	r6,44(sp)
 20104d0:	8009883a 	mov	r4,r16
 20104d4:	100b883a 	mov	r5,r2
 20104d8:	1023883a 	mov	r17,r2
 20104dc:	200ea700 	call	200ea70 <__multiply>
 20104e0:	d9400b17 	ldw	r5,44(sp)
 20104e4:	8009883a 	mov	r4,r16
 20104e8:	d8801415 	stw	r2,80(sp)
 20104ec:	200e6dc0 	call	200e6dc <_Bfree>
 20104f0:	d8801417 	ldw	r2,80(sp)
 20104f4:	d8800b15 	stw	r2,44(sp)
 20104f8:	0700050e 	bge	zero,fp,2010510 <_strtod_r+0x79c>
 20104fc:	d9400b17 	ldw	r5,44(sp)
 2010500:	8009883a 	mov	r4,r16
 2010504:	e00d883a 	mov	r6,fp
 2010508:	200ed7c0 	call	200ed7c <__lshift>
 201050c:	d8800b15 	stw	r2,44(sp)
 2010510:	98000526 	beq	r19,zero,2010528 <_strtod_r+0x7b4>
 2010514:	900b883a 	mov	r5,r18
 2010518:	8009883a 	mov	r4,r16
 201051c:	980d883a 	mov	r6,r19
 2010520:	200ec500 	call	200ec50 <__pow5mult>
 2010524:	1025883a 	mov	r18,r2
 2010528:	0540050e 	bge	zero,r21,2010540 <_strtod_r+0x7cc>
 201052c:	900b883a 	mov	r5,r18
 2010530:	8009883a 	mov	r4,r16
 2010534:	a80d883a 	mov	r6,r21
 2010538:	200ed7c0 	call	200ed7c <__lshift>
 201053c:	1025883a 	mov	r18,r2
 2010540:	05c0050e 	bge	zero,r23,2010558 <_strtod_r+0x7e4>
 2010544:	880b883a 	mov	r5,r17
 2010548:	8009883a 	mov	r4,r16
 201054c:	b80d883a 	mov	r6,r23
 2010550:	200ed7c0 	call	200ed7c <__lshift>
 2010554:	1023883a 	mov	r17,r2
 2010558:	d9400b17 	ldw	r5,44(sp)
 201055c:	8009883a 	mov	r4,r16
 2010560:	900d883a 	mov	r6,r18
 2010564:	200ef300 	call	200ef30 <__mdiff>
 2010568:	1027883a 	mov	r19,r2
 201056c:	10800317 	ldw	r2,12(r2)
 2010570:	9809883a 	mov	r4,r19
 2010574:	98000315 	stw	zero,12(r19)
 2010578:	880b883a 	mov	r5,r17
 201057c:	d8800f15 	stw	r2,60(sp)
 2010580:	200eed80 	call	200eed8 <__mcmp>
 2010584:	1001bf16 	blt	r2,zero,2010c84 <_strtod_r+0xf10>
 2010588:	1001ee26 	beq	r2,zero,2010d44 <_strtod_r+0xfd0>
 201058c:	9809883a 	mov	r4,r19
 2010590:	880b883a 	mov	r5,r17
 2010594:	200f3c40 	call	200f3c4 <__ratio>
 2010598:	1009883a 	mov	r4,r2
 201059c:	180b883a 	mov	r5,r3
 20105a0:	000d883a 	mov	r6,zero
 20105a4:	01d00034 	movhi	r7,16384
 20105a8:	102f883a 	mov	r23,r2
 20105ac:	1839883a 	mov	fp,r3
 20105b0:	20142fc0 	call	20142fc <__ledf2>
 20105b4:	00804f16 	blt	zero,r2,20106f4 <_strtod_r+0x980>
 20105b8:	d9400f17 	ldw	r5,60(sp)
 20105bc:	28008926 	beq	r5,zero,20107e4 <_strtod_r+0xa70>
 20105c0:	da400717 	ldw	r9,28(sp)
 20105c4:	05cffc34 	movhi	r23,16368
 20105c8:	d8000815 	stw	zero,32(sp)
 20105cc:	ddc00915 	stw	r23,36(sp)
 20105d0:	002b883a 	mov	r21,zero
 20105d4:	4f1ffc2c 	andhi	fp,r9,32752
 20105d8:	009ff834 	movhi	r2,32736
 20105dc:	e0805526 	beq	fp,r2,2010734 <_strtod_r+0x9c0>
 20105e0:	a0001b26 	beq	r20,zero,2010650 <_strtod_r+0x8dc>
 20105e4:	0081a834 	movhi	r2,1696
 20105e8:	17001936 	bltu	r2,fp,2010650 <_strtod_r+0x8dc>
 20105ec:	a809883a 	mov	r4,r21
 20105f0:	b80b883a 	mov	r5,r23
 20105f4:	01bff034 	movhi	r6,65472
 20105f8:	01d07834 	movhi	r7,16864
 20105fc:	39ffffc4 	addi	r7,r7,-1
 2010600:	20142fc0 	call	20142fc <__ledf2>
 2010604:	00800d16 	blt	zero,r2,201063c <_strtod_r+0x8c8>
 2010608:	a809883a 	mov	r4,r21
 201060c:	b80b883a 	mov	r5,r23
 2010610:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 2010614:	1000d026 	beq	r2,zero,2010958 <_strtod_r+0xbe4>
 2010618:	1009883a 	mov	r4,r2
 201061c:	20145600 	call	2014560 <__floatunsidf>
 2010620:	102b883a 	mov	r21,r2
 2010624:	182f883a 	mov	r23,r3
 2010628:	d9400f17 	ldw	r5,60(sp)
 201062c:	2800c81e 	bne	r5,zero,2010950 <_strtod_r+0xbdc>
 2010630:	b8a0003c 	xorhi	r2,r23,32768
 2010634:	dd400815 	stw	r21,32(sp)
 2010638:	d8800915 	stw	r2,36(sp)
 201063c:	d8c00917 	ldw	r3,36(sp)
 2010640:	0081ac34 	movhi	r2,1712
 2010644:	1885883a 	add	r2,r3,r2
 2010648:	1705c83a 	sub	r2,r2,fp
 201064c:	d8800915 	stw	r2,36(sp)
 2010650:	d9000617 	ldw	r4,24(sp)
 2010654:	d9400717 	ldw	r5,28(sp)
 2010658:	200f0d80 	call	200f0d8 <__ulp>
 201065c:	da800617 	ldw	r10,24(sp)
 2010660:	da400717 	ldw	r9,28(sp)
 2010664:	d9800817 	ldw	r6,32(sp)
 2010668:	d9c00917 	ldw	r7,36(sp)
 201066c:	1009883a 	mov	r4,r2
 2010670:	180b883a 	mov	r5,r3
 2010674:	da401515 	stw	r9,84(sp)
 2010678:	da801415 	stw	r10,80(sp)
 201067c:	2013c880 	call	2013c88 <__muldf3>
 2010680:	da401517 	ldw	r9,84(sp)
 2010684:	da801417 	ldw	r10,80(sp)
 2010688:	100d883a 	mov	r6,r2
 201068c:	480b883a 	mov	r5,r9
 2010690:	5009883a 	mov	r4,r10
 2010694:	180f883a 	mov	r7,r3
 2010698:	2013bd40 	call	2013bd4 <__adddf3>
 201069c:	d8800615 	stw	r2,24(sp)
 20106a0:	d8c00715 	stw	r3,28(sp)
 20106a4:	1813883a 	mov	r9,r3
 20106a8:	a000021e 	bne	r20,zero,20106b4 <_strtod_r+0x940>
 20106ac:	489ffc2c 	andhi	r2,r9,32752
 20106b0:	e0807226 	beq	fp,r2,201087c <_strtod_r+0xb08>
 20106b4:	d9400b17 	ldw	r5,44(sp)
 20106b8:	8009883a 	mov	r4,r16
 20106bc:	200e6dc0 	call	200e6dc <_Bfree>
 20106c0:	8009883a 	mov	r4,r16
 20106c4:	900b883a 	mov	r5,r18
 20106c8:	200e6dc0 	call	200e6dc <_Bfree>
 20106cc:	8009883a 	mov	r4,r16
 20106d0:	880b883a 	mov	r5,r17
 20106d4:	200e6dc0 	call	200e6dc <_Bfree>
 20106d8:	8009883a 	mov	r4,r16
 20106dc:	980b883a 	mov	r5,r19
 20106e0:	200e6dc0 	call	200e6dc <_Bfree>
 20106e4:	003f4106 	br	20103ec <_strtod_r+0x678>
 20106e8:	00800d84 	movi	r2,54
 20106ec:	1105c83a 	sub	r2,r2,r4
 20106f0:	003f6406 	br	2010484 <_strtod_r+0x710>
 20106f4:	b809883a 	mov	r4,r23
 20106f8:	e00b883a 	mov	r5,fp
 20106fc:	000d883a 	mov	r6,zero
 2010700:	01cff834 	movhi	r7,16352
 2010704:	2013c880 	call	2013c88 <__muldf3>
 2010708:	d9000f17 	ldw	r4,60(sp)
 201070c:	102b883a 	mov	r21,r2
 2010710:	182f883a 	mov	r23,r3
 2010714:	2000011e 	bne	r4,zero,201071c <_strtod_r+0x9a8>
 2010718:	18e0003c 	xorhi	r3,r3,32768
 201071c:	da400717 	ldw	r9,28(sp)
 2010720:	d8800815 	stw	r2,32(sp)
 2010724:	d8c00915 	stw	r3,36(sp)
 2010728:	4f1ffc2c 	andhi	fp,r9,32752
 201072c:	009ff834 	movhi	r2,32736
 2010730:	e0bfab1e 	bne	fp,r2,20105e0 <_strtod_r+0x86c>
 2010734:	d8800617 	ldw	r2,24(sp)
 2010738:	00ff2c34 	movhi	r3,64688
 201073c:	48d3883a 	add	r9,r9,r3
 2010740:	1009883a 	mov	r4,r2
 2010744:	d8800415 	stw	r2,16(sp)
 2010748:	d8800717 	ldw	r2,28(sp)
 201074c:	480b883a 	mov	r5,r9
 2010750:	da400715 	stw	r9,28(sp)
 2010754:	d8800515 	stw	r2,20(sp)
 2010758:	200f0d80 	call	200f0d8 <__ulp>
 201075c:	da800617 	ldw	r10,24(sp)
 2010760:	da400717 	ldw	r9,28(sp)
 2010764:	d9800817 	ldw	r6,32(sp)
 2010768:	d9c00917 	ldw	r7,36(sp)
 201076c:	1009883a 	mov	r4,r2
 2010770:	180b883a 	mov	r5,r3
 2010774:	da401515 	stw	r9,84(sp)
 2010778:	da801415 	stw	r10,80(sp)
 201077c:	2013c880 	call	2013c88 <__muldf3>
 2010780:	da801417 	ldw	r10,80(sp)
 2010784:	da401517 	ldw	r9,84(sp)
 2010788:	100d883a 	mov	r6,r2
 201078c:	5009883a 	mov	r4,r10
 2010790:	480b883a 	mov	r5,r9
 2010794:	180f883a 	mov	r7,r3
 2010798:	2013bd40 	call	2013bd4 <__adddf3>
 201079c:	d8800615 	stw	r2,24(sp)
 20107a0:	015f2834 	movhi	r5,31904
 20107a4:	297fffc4 	addi	r5,r5,-1
 20107a8:	189ffc2c 	andhi	r2,r3,32752
 20107ac:	2880642e 	bgeu	r5,r2,2010940 <_strtod_r+0xbcc>
 20107b0:	d8800517 	ldw	r2,20(sp)
 20107b4:	00dffc34 	movhi	r3,32752
 20107b8:	18ffffc4 	addi	r3,r3,-1
 20107bc:	10c17926 	beq	r2,r3,2010da4 <_strtod_r+0x1030>
 20107c0:	011ffc34 	movhi	r4,32752
 20107c4:	213fffc4 	addi	r4,r4,-1
 20107c8:	00bfffc4 	movi	r2,-1
 20107cc:	d9000715 	stw	r4,28(sp)
 20107d0:	d8800615 	stw	r2,24(sp)
 20107d4:	003fb706 	br	20106b4 <_strtod_r+0x940>
 20107d8:	9887c83a 	sub	r3,r19,r2
 20107dc:	ddc00e17 	ldw	r23,56(sp)
 20107e0:	003f2206 	br	201046c <_strtod_r+0x6f8>
 20107e4:	d8800617 	ldw	r2,24(sp)
 20107e8:	10001a1e 	bne	r2,zero,2010854 <_strtod_r+0xae0>
 20107ec:	da400717 	ldw	r9,28(sp)
 20107f0:	00c00434 	movhi	r3,16
 20107f4:	18ffffc4 	addi	r3,r3,-1
 20107f8:	48c4703a 	and	r2,r9,r3
 20107fc:	1000191e 	bne	r2,zero,2010864 <_strtod_r+0xaf0>
 2010800:	b809883a 	mov	r4,r23
 2010804:	e00b883a 	mov	r5,fp
 2010808:	000d883a 	mov	r6,zero
 201080c:	01cffc34 	movhi	r7,16368
 2010810:	da401515 	stw	r9,84(sp)
 2010814:	20142a00 	call	20142a0 <__ltdf2>
 2010818:	da401517 	ldw	r9,84(sp)
 201081c:	1001af16 	blt	r2,zero,2010edc <_strtod_r+0x1168>
 2010820:	b809883a 	mov	r4,r23
 2010824:	e00b883a 	mov	r5,fp
 2010828:	000d883a 	mov	r6,zero
 201082c:	01cff834 	movhi	r7,16352
 2010830:	2013c880 	call	2013c88 <__muldf3>
 2010834:	da401517 	ldw	r9,84(sp)
 2010838:	182f883a 	mov	r23,r3
 201083c:	102b883a 	mov	r21,r2
 2010840:	1007883a 	mov	r3,r2
 2010844:	b8a0003c 	xorhi	r2,r23,32768
 2010848:	d8c00815 	stw	r3,32(sp)
 201084c:	d8800915 	stw	r2,36(sp)
 2010850:	003f6006 	br	20105d4 <_strtod_r+0x860>
 2010854:	00c00044 	movi	r3,1
 2010858:	da400717 	ldw	r9,28(sp)
 201085c:	10c0011e 	bne	r2,r3,2010864 <_strtod_r+0xaf0>
 2010860:	4800bd26 	beq	r9,zero,2010b58 <_strtod_r+0xde4>
 2010864:	00affc34 	movhi	r2,49136
 2010868:	d8000815 	stw	zero,32(sp)
 201086c:	d8800915 	stw	r2,36(sp)
 2010870:	002b883a 	mov	r21,zero
 2010874:	05cffc34 	movhi	r23,16368
 2010878:	003f5606 	br	20105d4 <_strtod_r+0x860>
 201087c:	b80b883a 	mov	r5,r23
 2010880:	a809883a 	mov	r4,r21
 2010884:	da401515 	stw	r9,84(sp)
 2010888:	201442c0 	call	201442c <__fixdfsi>
 201088c:	1009883a 	mov	r4,r2
 2010890:	20143580 	call	2014358 <__floatsidf>
 2010894:	b80b883a 	mov	r5,r23
 2010898:	a809883a 	mov	r4,r21
 201089c:	100d883a 	mov	r6,r2
 20108a0:	180f883a 	mov	r7,r3
 20108a4:	2013c280 	call	2013c28 <__subdf3>
 20108a8:	102f883a 	mov	r23,r2
 20108ac:	d8800f17 	ldw	r2,60(sp)
 20108b0:	1839883a 	mov	fp,r3
 20108b4:	da401517 	ldw	r9,84(sp)
 20108b8:	1000021e 	bne	r2,zero,20108c4 <_strtod_r+0xb50>
 20108bc:	d8800617 	ldw	r2,24(sp)
 20108c0:	10004026 	beq	r2,zero,20109c4 <_strtod_r+0xc50>
 20108c4:	b809883a 	mov	r4,r23
 20108c8:	e00b883a 	mov	r5,fp
 20108cc:	01a52834 	movhi	r6,38048
 20108d0:	318d6544 	addi	r6,r6,13717
 20108d4:	01cff834 	movhi	r7,16352
 20108d8:	39ffffc4 	addi	r7,r7,-1
 20108dc:	20142a00 	call	20142a0 <__ltdf2>
 20108e0:	10000716 	blt	r2,zero,2010900 <_strtod_r+0xb8c>
 20108e4:	b809883a 	mov	r4,r23
 20108e8:	e00b883a 	mov	r5,fp
 20108ec:	018d6c34 	movhi	r6,13744
 20108f0:	31b94d44 	addi	r6,r6,-6859
 20108f4:	01cff834 	movhi	r7,16352
 20108f8:	20141d80 	call	20141d8 <__gtdf2>
 20108fc:	00bf6d0e 	bge	zero,r2,20106b4 <_strtod_r+0x940>
 2010900:	d9400b17 	ldw	r5,44(sp)
 2010904:	8009883a 	mov	r4,r16
 2010908:	200e6dc0 	call	200e6dc <_Bfree>
 201090c:	8009883a 	mov	r4,r16
 2010910:	900b883a 	mov	r5,r18
 2010914:	200e6dc0 	call	200e6dc <_Bfree>
 2010918:	8009883a 	mov	r4,r16
 201091c:	880b883a 	mov	r5,r17
 2010920:	200e6dc0 	call	200e6dc <_Bfree>
 2010924:	8009883a 	mov	r4,r16
 2010928:	b00b883a 	mov	r5,r22
 201092c:	200e6dc0 	call	200e6dc <_Bfree>
 2010930:	8009883a 	mov	r4,r16
 2010934:	980b883a 	mov	r5,r19
 2010938:	200e6dc0 	call	200e6dc <_Bfree>
 201093c:	003e8506 	br	2010354 <_strtod_r+0x5e0>
 2010940:	0240d434 	movhi	r9,848
 2010944:	1a53883a 	add	r9,r3,r9
 2010948:	da400715 	stw	r9,28(sp)
 201094c:	003f5606 	br	20106a8 <_strtod_r+0x934>
 2010950:	b805883a 	mov	r2,r23
 2010954:	003f3706 	br	2010634 <_strtod_r+0x8c0>
 2010958:	002b883a 	mov	r21,zero
 201095c:	05cffc34 	movhi	r23,16368
 2010960:	003f3106 	br	2010628 <_strtod_r+0x8b4>
 2010964:	dd800c15 	stw	r22,48(sp)
 2010968:	0009883a 	mov	r4,zero
 201096c:	883d431e 	bne	r17,zero,200fe7c <_strtod_r+0x108>
 2010970:	003e0c06 	br	20101a4 <_strtod_r+0x430>
 2010974:	4027883a 	mov	r19,r8
 2010978:	8813883a 	mov	r9,r17
 201097c:	0007883a 	mov	r3,zero
 2010980:	000d883a 	mov	r6,zero
 2010984:	3a3ff404 	addi	r8,r7,-48
 2010988:	00800244 	movi	r2,9
 201098c:	12001e36 	bltu	r2,r8,2010a08 <_strtod_r+0xc94>
 2010990:	18c00044 	addi	r3,r3,1
 2010994:	dac00c17 	ldw	r11,48(sp)
 2010998:	003de806 	br	201013c <_strtod_r+0x3c8>
 201099c:	02800044 	movi	r10,1
 20109a0:	b0800084 	addi	r2,r22,2
 20109a4:	d8800c15 	stw	r2,48(sp)
 20109a8:	b1c00087 	ldb	r7,2(r22)
 20109ac:	003e2e06 	br	2010268 <_strtod_r+0x4f4>
 20109b0:	0015883a 	mov	r10,zero
 20109b4:	003ffa06 	br	20109a0 <_strtod_r+0xc2c>
 20109b8:	0005883a 	mov	r2,zero
 20109bc:	0007883a 	mov	r3,zero
 20109c0:	003d9f06 	br	2010040 <_strtod_r+0x2cc>
 20109c4:	00c00434 	movhi	r3,16
 20109c8:	18ffffc4 	addi	r3,r3,-1
 20109cc:	48d2703a 	and	r9,r9,r3
 20109d0:	483fbc1e 	bne	r9,zero,20108c4 <_strtod_r+0xb50>
 20109d4:	b809883a 	mov	r4,r23
 20109d8:	e00b883a 	mov	r5,fp
 20109dc:	01a52834 	movhi	r6,38048
 20109e0:	318d6544 	addi	r6,r6,13717
 20109e4:	01cff434 	movhi	r7,16336
 20109e8:	39ffffc4 	addi	r7,r7,-1
 20109ec:	20142a00 	call	20142a0 <__ltdf2>
 20109f0:	103f300e 	bge	r2,zero,20106b4 <_strtod_r+0x940>
 20109f4:	003fc206 	br	2010900 <_strtod_r+0xb8c>
 20109f8:	283e121e 	bne	r5,zero,2010244 <_strtod_r+0x4d0>
 20109fc:	d8800617 	ldw	r2,24(sp)
 2010a00:	d8c00717 	ldw	r3,28(sp)
 2010a04:	003d8c06 	br	2010038 <_strtod_r+0x2c4>
 2010a08:	882b883a 	mov	r21,r17
 2010a0c:	02000044 	movi	r8,1
 2010a10:	4823883a 	mov	r17,r9
 2010a14:	003d1306 	br	200fe64 <_strtod_r+0xf0>
 2010a18:	00804d04 	movi	r2,308
 2010a1c:	1580ea16 	blt	r2,r22,2010dc8 <_strtod_r+0x1054>
 2010a20:	b02dd13a 	srai	r22,r22,4
 2010a24:	02400044 	movi	r9,1
 2010a28:	4d81c40e 	bge	r9,r22,201113c <_strtod_r+0x13c8>
 2010a2c:	d8800617 	ldw	r2,24(sp)
 2010a30:	d8c00717 	ldw	r3,28(sp)
 2010a34:	01408174 	movhi	r5,517
 2010a38:	2977c504 	addi	r5,r5,-8428
 2010a3c:	d9400e15 	stw	r5,56(sp)
 2010a40:	2839883a 	mov	fp,r5
 2010a44:	002f883a 	mov	r23,zero
 2010a48:	4829883a 	mov	r20,r9
 2010a4c:	b180004c 	andi	r6,r22,1
 2010a50:	30000526 	beq	r6,zero,2010a68 <_strtod_r+0xcf4>
 2010a54:	e1800017 	ldw	r6,0(fp)
 2010a58:	e1c00117 	ldw	r7,4(fp)
 2010a5c:	1009883a 	mov	r4,r2
 2010a60:	180b883a 	mov	r5,r3
 2010a64:	2013c880 	call	2013c88 <__muldf3>
 2010a68:	b02dd07a 	srai	r22,r22,1
 2010a6c:	bdc00044 	addi	r23,r23,1
 2010a70:	e7000204 	addi	fp,fp,8
 2010a74:	a5bff516 	blt	r20,r22,2010a4c <_strtod_r+0xcd8>
 2010a78:	d8800615 	stw	r2,24(sp)
 2010a7c:	d8c00715 	stw	r3,28(sp)
 2010a80:	b81090fa 	slli	r8,r23,3
 2010a84:	d8c00e17 	ldw	r3,56(sp)
 2010a88:	d9400717 	ldw	r5,28(sp)
 2010a8c:	d9000617 	ldw	r4,24(sp)
 2010a90:	1a29883a 	add	r20,r3,r8
 2010a94:	a1800017 	ldw	r6,0(r20)
 2010a98:	a1c00117 	ldw	r7,4(r20)
 2010a9c:	00bf2c34 	movhi	r2,64688
 2010aa0:	288b883a 	add	r5,r5,r2
 2010aa4:	2013c880 	call	2013c88 <__muldf3>
 2010aa8:	d8800615 	stw	r2,24(sp)
 2010aac:	011f2834 	movhi	r4,31904
 2010ab0:	189ffc2c 	andhi	r2,r3,32752
 2010ab4:	2080c436 	bltu	r4,r2,2010dc8 <_strtod_r+0x1054>
 2010ab8:	011f2434 	movhi	r4,31888
 2010abc:	20815c2e 	bgeu	r4,r2,2011030 <_strtod_r+0x12bc>
 2010ac0:	009ffc34 	movhi	r2,32752
 2010ac4:	10bfffc4 	addi	r2,r2,-1
 2010ac8:	d8800715 	stw	r2,28(sp)
 2010acc:	00bfffc4 	movi	r2,-1
 2010ad0:	d8800615 	stw	r2,24(sp)
 2010ad4:	003e3606 	br	20103b0 <_strtod_r+0x63c>
 2010ad8:	4027883a 	mov	r19,r8
 2010adc:	002b883a 	mov	r21,zero
 2010ae0:	000d883a 	mov	r6,zero
 2010ae4:	02000044 	movi	r8,1
 2010ae8:	003cde06 	br	200fe64 <_strtod_r+0xf0>
 2010aec:	d8800717 	ldw	r2,28(sp)
 2010af0:	00c00434 	movhi	r3,16
 2010af4:	18ffffc4 	addi	r3,r3,-1
 2010af8:	10c6703a 	and	r3,r2,r3
 2010afc:	1801421e 	bne	r3,zero,2011008 <_strtod_r+0x1294>
 2010b00:	d8c00617 	ldw	r3,24(sp)
 2010b04:	18007a26 	beq	r3,zero,2010cf0 <_strtod_r+0xf7c>
 2010b08:	18c0004c 	andi	r3,r3,1
 2010b0c:	1800a326 	beq	r3,zero,2010d9c <_strtod_r+0x1028>
 2010b10:	df000617 	ldw	fp,24(sp)
 2010b14:	dd400717 	ldw	r21,28(sp)
 2010b18:	e009883a 	mov	r4,fp
 2010b1c:	a80b883a 	mov	r5,r21
 2010b20:	200f0d80 	call	200f0d8 <__ulp>
 2010b24:	e009883a 	mov	r4,fp
 2010b28:	a80b883a 	mov	r5,r21
 2010b2c:	100d883a 	mov	r6,r2
 2010b30:	180f883a 	mov	r7,r3
 2010b34:	2013c280 	call	2013c28 <__subdf3>
 2010b38:	1009883a 	mov	r4,r2
 2010b3c:	180b883a 	mov	r5,r3
 2010b40:	000d883a 	mov	r6,zero
 2010b44:	000f883a 	mov	r7,zero
 2010b48:	d8800615 	stw	r2,24(sp)
 2010b4c:	d8c00715 	stw	r3,28(sp)
 2010b50:	20141200 	call	2014120 <__eqdf2>
 2010b54:	1000911e 	bne	r2,zero,2010d9c <_strtod_r+0x1028>
 2010b58:	d8000615 	stw	zero,24(sp)
 2010b5c:	d8000715 	stw	zero,28(sp)
 2010b60:	00800884 	movi	r2,34
 2010b64:	80800015 	stw	r2,0(r16)
 2010b68:	003f6506 	br	2010900 <_strtod_r+0xb8c>
 2010b6c:	60bd8016 	blt	r12,r2,2010170 <_strtod_r+0x3fc>
 2010b70:	a50002a4 	muli	r20,r20,10
 2010b74:	003d7e06 	br	2010170 <_strtod_r+0x3fc>
 2010b78:	d8c01217 	ldw	r3,72(sp)
 2010b7c:	d8800b04 	addi	r2,sp,44
 2010b80:	04808174 	movhi	r18,517
 2010b84:	948a7504 	addi	r18,r18,10708
 2010b88:	d8800015 	stw	r2,0(sp)
 2010b8c:	d8c00115 	stw	r3,4(sp)
 2010b90:	8009883a 	mov	r4,r16
 2010b94:	d9400c04 	addi	r5,sp,48
 2010b98:	900d883a 	mov	r6,r18
 2010b9c:	d9c00a04 	addi	r7,sp,40
 2010ba0:	20121780 	call	2012178 <__gethex>
 2010ba4:	144001cc 	andi	r17,r2,7
 2010ba8:	883dea26 	beq	r17,zero,2010354 <_strtod_r+0x5e0>
 2010bac:	00c00184 	movi	r3,6
 2010bb0:	88c0f226 	beq	r17,r3,2010f7c <_strtod_r+0x1208>
 2010bb4:	d9800b17 	ldw	r6,44(sp)
 2010bb8:	30000826 	beq	r6,zero,2010bdc <_strtod_r+0xe68>
 2010bbc:	91400017 	ldw	r5,0(r18)
 2010bc0:	d9000204 	addi	r4,sp,8
 2010bc4:	d8801415 	stw	r2,80(sp)
 2010bc8:	200f4dc0 	call	200f4dc <__copybits>
 2010bcc:	d9400b17 	ldw	r5,44(sp)
 2010bd0:	8009883a 	mov	r4,r16
 2010bd4:	200e6dc0 	call	200e6dc <_Bfree>
 2010bd8:	d8801417 	ldw	r2,80(sp)
 2010bdc:	00c00184 	movi	r3,6
 2010be0:	d9000a17 	ldw	r4,40(sp)
 2010be4:	1c7dd636 	bltu	r3,r17,2010340 <_strtod_r+0x5cc>
 2010be8:	8c63883a 	add	r17,r17,r17
 2010bec:	8c63883a 	add	r17,r17,r17
 2010bf0:	00c08074 	movhi	r3,513
 2010bf4:	18c30104 	addi	r3,r3,3076
 2010bf8:	88c7883a 	add	r3,r17,r3
 2010bfc:	18c00017 	ldw	r3,0(r3)
 2010c00:	1800683a 	jmp	r3
 2010c04:	02010c78 	rdprs	r8,zero,1073
 2010c08:	02010c34 	movhi	r8,1072
 2010c0c:	02010c20 	cmpeqi	r8,zero,1072
 2010c10:	02010334 	movhi	r8,1036
 2010c14:	02010c60 	cmpeqi	r8,zero,1073
 2010c18:	02010c34 	movhi	r8,1072
 2010c1c:	02010c78 	rdprs	r8,zero,1073
 2010c20:	d8c00217 	ldw	r3,8(sp)
 2010c24:	d8c00615 	stw	r3,24(sp)
 2010c28:	d8c00317 	ldw	r3,12(sp)
 2010c2c:	d8c00715 	stw	r3,28(sp)
 2010c30:	003dc306 	br	2010340 <_strtod_r+0x5cc>
 2010c34:	21010cc4 	addi	r4,r4,1075
 2010c38:	d9400317 	ldw	r5,12(sp)
 2010c3c:	2008953a 	slli	r4,r4,20
 2010c40:	00fffc34 	movhi	r3,65520
 2010c44:	18ffffc4 	addi	r3,r3,-1
 2010c48:	28c6703a 	and	r3,r5,r3
 2010c4c:	20c6b03a 	or	r3,r4,r3
 2010c50:	d9000217 	ldw	r4,8(sp)
 2010c54:	d8c00715 	stw	r3,28(sp)
 2010c58:	d9000615 	stw	r4,24(sp)
 2010c5c:	003db806 	br	2010340 <_strtod_r+0x5cc>
 2010c60:	00e00034 	movhi	r3,32768
 2010c64:	18ffffc4 	addi	r3,r3,-1
 2010c68:	d8c00715 	stw	r3,28(sp)
 2010c6c:	00ffffc4 	movi	r3,-1
 2010c70:	d8c00615 	stw	r3,24(sp)
 2010c74:	003db206 	br	2010340 <_strtod_r+0x5cc>
 2010c78:	d8000715 	stw	zero,28(sp)
 2010c7c:	d8000615 	stw	zero,24(sp)
 2010c80:	003daf06 	br	2010340 <_strtod_r+0x5cc>
 2010c84:	d8c00f17 	ldw	r3,60(sp)
 2010c88:	1800441e 	bne	r3,zero,2010d9c <_strtod_r+0x1028>
 2010c8c:	d8800617 	ldw	r2,24(sp)
 2010c90:	1000421e 	bne	r2,zero,2010d9c <_strtod_r+0x1028>
 2010c94:	d8800717 	ldw	r2,28(sp)
 2010c98:	00c00434 	movhi	r3,16
 2010c9c:	18ffffc4 	addi	r3,r3,-1
 2010ca0:	10c6703a 	and	r3,r2,r3
 2010ca4:	18003d1e 	bne	r3,zero,2010d9c <_strtod_r+0x1028>
 2010ca8:	109ffc2c 	andhi	r2,r2,32752
 2010cac:	00c1ac34 	movhi	r3,1712
 2010cb0:	18803a2e 	bgeu	r3,r2,2010d9c <_strtod_r+0x1028>
 2010cb4:	98800517 	ldw	r2,20(r19)
 2010cb8:	1000031e 	bne	r2,zero,2010cc8 <_strtod_r+0xf54>
 2010cbc:	98800417 	ldw	r2,16(r19)
 2010cc0:	00c00044 	movi	r3,1
 2010cc4:	1880350e 	bge	r3,r2,2010d9c <_strtod_r+0x1028>
 2010cc8:	980b883a 	mov	r5,r19
 2010ccc:	8009883a 	mov	r4,r16
 2010cd0:	01800044 	movi	r6,1
 2010cd4:	200ed7c0 	call	200ed7c <__lshift>
 2010cd8:	1009883a 	mov	r4,r2
 2010cdc:	880b883a 	mov	r5,r17
 2010ce0:	1027883a 	mov	r19,r2
 2010ce4:	200eed80 	call	200eed8 <__mcmp>
 2010ce8:	00802c0e 	bge	zero,r2,2010d9c <_strtod_r+0x1028>
 2010cec:	d8800717 	ldw	r2,28(sp)
 2010cf0:	109ffc2c 	andhi	r2,r2,32752
 2010cf4:	a000e926 	beq	r20,zero,201109c <_strtod_r+0x1328>
 2010cf8:	00c1ac34 	movhi	r3,1712
 2010cfc:	1880e736 	bltu	r3,r2,201109c <_strtod_r+0x1328>
 2010d00:	00c0dc34 	movhi	r3,880
 2010d04:	18bf942e 	bgeu	r3,r2,2010b58 <_strtod_r+0xde4>
 2010d08:	d9000617 	ldw	r4,24(sp)
 2010d0c:	d9400717 	ldw	r5,28(sp)
 2010d10:	008e5434 	movhi	r2,14672
 2010d14:	000d883a 	mov	r6,zero
 2010d18:	100f883a 	mov	r7,r2
 2010d1c:	d8800515 	stw	r2,20(sp)
 2010d20:	d8000415 	stw	zero,16(sp)
 2010d24:	2013c880 	call	2013c88 <__muldf3>
 2010d28:	d8800615 	stw	r2,24(sp)
 2010d2c:	d8c00715 	stw	r3,28(sp)
 2010d30:	183ef31e 	bne	r3,zero,2010900 <_strtod_r+0xb8c>
 2010d34:	103ef21e 	bne	r2,zero,2010900 <_strtod_r+0xb8c>
 2010d38:	00800884 	movi	r2,34
 2010d3c:	80800015 	stw	r2,0(r16)
 2010d40:	003eef06 	br	2010900 <_strtod_r+0xb8c>
 2010d44:	d9000f17 	ldw	r4,60(sp)
 2010d48:	203f6826 	beq	r4,zero,2010aec <_strtod_r+0xd78>
 2010d4c:	d8c00717 	ldw	r3,28(sp)
 2010d50:	00800434 	movhi	r2,16
 2010d54:	10bfffc4 	addi	r2,r2,-1
 2010d58:	1888703a 	and	r4,r3,r2
 2010d5c:	2080b926 	beq	r4,r2,2011044 <_strtod_r+0x12d0>
 2010d60:	d8800617 	ldw	r2,24(sp)
 2010d64:	1080004c 	andi	r2,r2,1
 2010d68:	10000c26 	beq	r2,zero,2010d9c <_strtod_r+0x1028>
 2010d6c:	df000617 	ldw	fp,24(sp)
 2010d70:	dd400717 	ldw	r21,28(sp)
 2010d74:	e009883a 	mov	r4,fp
 2010d78:	a80b883a 	mov	r5,r21
 2010d7c:	200f0d80 	call	200f0d8 <__ulp>
 2010d80:	e009883a 	mov	r4,fp
 2010d84:	a80b883a 	mov	r5,r21
 2010d88:	100d883a 	mov	r6,r2
 2010d8c:	180f883a 	mov	r7,r3
 2010d90:	2013bd40 	call	2013bd4 <__adddf3>
 2010d94:	d8800615 	stw	r2,24(sp)
 2010d98:	d8c00715 	stw	r3,28(sp)
 2010d9c:	a03fda1e 	bne	r20,zero,2010d08 <_strtod_r+0xf94>
 2010da0:	003ed706 	br	2010900 <_strtod_r+0xb8c>
 2010da4:	d8c00417 	ldw	r3,16(sp)
 2010da8:	00bfffc4 	movi	r2,-1
 2010dac:	18be841e 	bne	r3,r2,20107c0 <_strtod_r+0xa4c>
 2010db0:	00800884 	movi	r2,34
 2010db4:	80800015 	stw	r2,0(r16)
 2010db8:	009ffc34 	movhi	r2,32752
 2010dbc:	d8800715 	stw	r2,28(sp)
 2010dc0:	d8000615 	stw	zero,24(sp)
 2010dc4:	003ece06 	br	2010900 <_strtod_r+0xb8c>
 2010dc8:	00800884 	movi	r2,34
 2010dcc:	80800015 	stw	r2,0(r16)
 2010dd0:	00dffc34 	movhi	r3,32752
 2010dd4:	0005883a 	mov	r2,zero
 2010dd8:	003c9906 	br	2010040 <_strtod_r+0x2cc>
 2010ddc:	b03d7426 	beq	r22,zero,20103b0 <_strtod_r+0x63c>
 2010de0:	05adc83a 	sub	r22,zero,r22
 2010de4:	b08003cc 	andi	r2,r22,15
 2010de8:	10000b26 	beq	r2,zero,2010e18 <_strtod_r+0x10a4>
 2010dec:	100490fa 	slli	r2,r2,3
 2010df0:	00c08174 	movhi	r3,517
 2010df4:	18f7cf04 	addi	r3,r3,-8388
 2010df8:	d9000617 	ldw	r4,24(sp)
 2010dfc:	1885883a 	add	r2,r3,r2
 2010e00:	d9400717 	ldw	r5,28(sp)
 2010e04:	11800017 	ldw	r6,0(r2)
 2010e08:	11c00117 	ldw	r7,4(r2)
 2010e0c:	2013f6c0 	call	2013f6c <__divdf3>
 2010e10:	d8800615 	stw	r2,24(sp)
 2010e14:	d8c00715 	stw	r3,28(sp)
 2010e18:	b02dd13a 	srai	r22,r22,4
 2010e1c:	b03d6426 	beq	r22,zero,20103b0 <_strtod_r+0x63c>
 2010e20:	008007c4 	movi	r2,31
 2010e24:	15802816 	blt	r2,r22,2010ec8 <_strtod_r+0x1154>
 2010e28:	b080040c 	andi	r2,r22,16
 2010e2c:	1000ca1e 	bne	r2,zero,2011158 <_strtod_r+0x13e4>
 2010e30:	0029883a 	mov	r20,zero
 2010e34:	0580100e 	bge	zero,r22,2010e78 <_strtod_r+0x1104>
 2010e38:	d8800617 	ldw	r2,24(sp)
 2010e3c:	d8c00717 	ldw	r3,28(sp)
 2010e40:	07008174 	movhi	fp,517
 2010e44:	e7380804 	addi	fp,fp,-8160
 2010e48:	b180004c 	andi	r6,r22,1
 2010e4c:	30000526 	beq	r6,zero,2010e64 <_strtod_r+0x10f0>
 2010e50:	e1800017 	ldw	r6,0(fp)
 2010e54:	e1c00117 	ldw	r7,4(fp)
 2010e58:	1009883a 	mov	r4,r2
 2010e5c:	180b883a 	mov	r5,r3
 2010e60:	2013c880 	call	2013c88 <__muldf3>
 2010e64:	b02dd07a 	srai	r22,r22,1
 2010e68:	e7000204 	addi	fp,fp,8
 2010e6c:	b03ff61e 	bne	r22,zero,2010e48 <_strtod_r+0x10d4>
 2010e70:	d8800615 	stw	r2,24(sp)
 2010e74:	d8c00715 	stw	r3,28(sp)
 2010e78:	a0000d26 	beq	r20,zero,2010eb0 <_strtod_r+0x113c>
 2010e7c:	d8c00717 	ldw	r3,28(sp)
 2010e80:	01001ac4 	movi	r4,107
 2010e84:	189ffc2c 	andhi	r2,r3,32752
 2010e88:	1004d53a 	srli	r2,r2,20
 2010e8c:	2085c83a 	sub	r2,r4,r2
 2010e90:	0080070e 	bge	zero,r2,2010eb0 <_strtod_r+0x113c>
 2010e94:	010007c4 	movi	r4,31
 2010e98:	2080c00e 	bge	r4,r2,201119c <_strtod_r+0x1428>
 2010e9c:	d8000615 	stw	zero,24(sp)
 2010ea0:	01000d04 	movi	r4,52
 2010ea4:	2080c30e 	bge	r4,r2,20111b4 <_strtod_r+0x1440>
 2010ea8:	0080dc34 	movhi	r2,880
 2010eac:	d8800715 	stw	r2,28(sp)
 2010eb0:	d9000617 	ldw	r4,24(sp)
 2010eb4:	d9400717 	ldw	r5,28(sp)
 2010eb8:	000d883a 	mov	r6,zero
 2010ebc:	000f883a 	mov	r7,zero
 2010ec0:	20141200 	call	2014120 <__eqdf2>
 2010ec4:	103d3b1e 	bne	r2,zero,20103b4 <_strtod_r+0x640>
 2010ec8:	00800884 	movi	r2,34
 2010ecc:	80800015 	stw	r2,0(r16)
 2010ed0:	0007883a 	mov	r3,zero
 2010ed4:	0005883a 	mov	r2,zero
 2010ed8:	003c5906 	br	2010040 <_strtod_r+0x2cc>
 2010edc:	0007883a 	mov	r3,zero
 2010ee0:	00aff834 	movhi	r2,49120
 2010ee4:	002b883a 	mov	r21,zero
 2010ee8:	05cff834 	movhi	r23,16352
 2010eec:	003e5606 	br	2010848 <_strtod_r+0xad4>
 2010ef0:	011387c4 	movi	r4,19999
 2010ef4:	003d0506 	br	201030c <_strtod_r+0x598>
 2010ef8:	400d883a 	mov	r6,r8
 2010efc:	0029883a 	mov	r20,zero
 2010f00:	0025883a 	mov	r18,zero
 2010f04:	0023883a 	mov	r17,zero
 2010f08:	003c7206 	br	20100d4 <_strtod_r+0x360>
 2010f0c:	0029883a 	mov	r20,zero
 2010f10:	0025883a 	mov	r18,zero
 2010f14:	0023883a 	mov	r17,zero
 2010f18:	003bcd06 	br	200fe50 <_strtod_r+0xdc>
 2010f1c:	d9001017 	ldw	r4,64(sp)
 2010f20:	00c00944 	movi	r3,37
 2010f24:	1c47c83a 	sub	r3,r3,r17
 2010f28:	193d0d16 	blt	r3,r4,2010360 <_strtod_r+0x5ec>
 2010f2c:	1463c83a 	sub	r17,r2,r17
 2010f30:	880490fa 	slli	r2,r17,3
 2010f34:	04008174 	movhi	r16,517
 2010f38:	8437cf04 	addi	r16,r16,-8388
 2010f3c:	d9000617 	ldw	r4,24(sp)
 2010f40:	8085883a 	add	r2,r16,r2
 2010f44:	d9400717 	ldw	r5,28(sp)
 2010f48:	11800017 	ldw	r6,0(r2)
 2010f4c:	11c00117 	ldw	r7,4(r2)
 2010f50:	2013c880 	call	2013c88 <__muldf3>
 2010f54:	d9401017 	ldw	r5,64(sp)
 2010f58:	1009883a 	mov	r4,r2
 2010f5c:	2c4dc83a 	sub	r6,r5,r17
 2010f60:	300c90fa 	slli	r6,r6,3
 2010f64:	180b883a 	mov	r5,r3
 2010f68:	81a1883a 	add	r16,r16,r6
 2010f6c:	81800017 	ldw	r6,0(r16)
 2010f70:	81c00117 	ldw	r7,4(r16)
 2010f74:	2013c880 	call	2013c88 <__muldf3>
 2010f78:	003c3106 	br	2010040 <_strtod_r+0x2cc>
 2010f7c:	dd800c15 	stw	r22,48(sp)
 2010f80:	d8001215 	stw	zero,72(sp)
 2010f84:	003cf306 	br	2010354 <_strtod_r+0x5e0>
 2010f88:	d8c01017 	ldw	r3,64(sp)
 2010f8c:	00bffa84 	movi	r2,-22
 2010f90:	18bcf316 	blt	r3,r2,2010360 <_strtod_r+0x5ec>
 2010f94:	180490fa 	slli	r2,r3,3
 2010f98:	00c08174 	movhi	r3,517
 2010f9c:	18f7cf04 	addi	r3,r3,-8388
 2010fa0:	d9000617 	ldw	r4,24(sp)
 2010fa4:	1885c83a 	sub	r2,r3,r2
 2010fa8:	d9400717 	ldw	r5,28(sp)
 2010fac:	11800017 	ldw	r6,0(r2)
 2010fb0:	11c00117 	ldw	r7,4(r2)
 2010fb4:	2013f6c0 	call	2013f6c <__divdf3>
 2010fb8:	003c2106 	br	2010040 <_strtod_r+0x2cc>
 2010fbc:	00801a44 	movi	r2,105
 2010fc0:	38bc8026 	beq	r7,r2,20101c4 <_strtod_r+0x450>
 2010fc4:	00801b84 	movi	r2,110
 2010fc8:	38be8c1e 	bne	r7,r2,20109fc <_strtod_r+0xc88>
 2010fcc:	d8c00c17 	ldw	r3,48(sp)
 2010fd0:	01008174 	movhi	r4,517
 2010fd4:	21380704 	addi	r4,r4,-8164
 2010fd8:	01801004 	movi	r6,64
 2010fdc:	01c01684 	movi	r7,90
 2010fe0:	21400007 	ldb	r5,0(r4)
 2010fe4:	21000044 	addi	r4,r4,1
 2010fe8:	28003626 	beq	r5,zero,20110c4 <_strtod_r+0x1350>
 2010fec:	18c00044 	addi	r3,r3,1
 2010ff0:	18800007 	ldb	r2,0(r3)
 2010ff4:	3080020e 	bge	r6,r2,2011000 <_strtod_r+0x128c>
 2010ff8:	38800116 	blt	r7,r2,2011000 <_strtod_r+0x128c>
 2010ffc:	10800804 	addi	r2,r2,32
 2011000:	117ff726 	beq	r2,r5,2010fe0 <_strtod_r+0x126c>
 2011004:	003e7d06 	br	20109fc <_strtod_r+0xc88>
 2011008:	d8c00617 	ldw	r3,24(sp)
 201100c:	003ebe06 	br	2010b08 <_strtod_r+0xd94>
 2011010:	00800404 	movi	r2,16
 2011014:	12401f16 	blt	r2,r9,2011094 <_strtod_r+0x1320>
 2011018:	a50002a4 	muli	r20,r20,10
 201101c:	0007883a 	mov	r3,zero
 2011020:	a229883a 	add	r20,r20,r8
 2011024:	003c5b06 	br	2010194 <_strtod_r+0x420>
 2011028:	0007883a 	mov	r3,zero
 201102c:	003c3a06 	br	2010118 <_strtod_r+0x3a4>
 2011030:	0080d434 	movhi	r2,848
 2011034:	1887883a 	add	r3,r3,r2
 2011038:	d8c00715 	stw	r3,28(sp)
 201103c:	0029883a 	mov	r20,zero
 2011040:	003cdc06 	br	20103b4 <_strtod_r+0x640>
 2011044:	d8800617 	ldw	r2,24(sp)
 2011048:	a0001026 	beq	r20,zero,201108c <_strtod_r+0x1318>
 201104c:	191ffc2c 	andhi	r4,r3,32752
 2011050:	0141a834 	movhi	r5,1696
 2011054:	29000d36 	bltu	r5,r4,201108c <_strtod_r+0x1318>
 2011058:	2008d53a 	srli	r4,r4,20
 201105c:	01401ac4 	movi	r5,107
 2011060:	2909c83a 	sub	r4,r5,r4
 2011064:	017fffc4 	movi	r5,-1
 2011068:	2908983a 	sll	r4,r5,r4
 201106c:	113f3d1e 	bne	r2,r4,2010d64 <_strtod_r+0xff0>
 2011070:	18dffc2c 	andhi	r3,r3,32752
 2011074:	00800434 	movhi	r2,16
 2011078:	1885883a 	add	r2,r3,r2
 201107c:	d8800715 	stw	r2,28(sp)
 2011080:	d8000615 	stw	zero,24(sp)
 2011084:	a03f201e 	bne	r20,zero,2010d08 <_strtod_r+0xf94>
 2011088:	003e1d06 	br	2010900 <_strtod_r+0xb8c>
 201108c:	013fffc4 	movi	r4,-1
 2011090:	003ff606 	br	201106c <_strtod_r+0x12f8>
 2011094:	0007883a 	mov	r3,zero
 2011098:	003c3e06 	br	2010194 <_strtod_r+0x420>
 201109c:	00fffc34 	movhi	r3,65520
 20110a0:	10c5883a 	add	r2,r2,r3
 20110a4:	00c00434 	movhi	r3,16
 20110a8:	18ffffc4 	addi	r3,r3,-1
 20110ac:	10c4b03a 	or	r2,r2,r3
 20110b0:	d8800715 	stw	r2,28(sp)
 20110b4:	00bfffc4 	movi	r2,-1
 20110b8:	d8800615 	stw	r2,24(sp)
 20110bc:	a03f121e 	bne	r20,zero,2010d08 <_strtod_r+0xf94>
 20110c0:	003e0f06 	br	2010900 <_strtod_r+0xb8c>
 20110c4:	18800044 	addi	r2,r3,1
 20110c8:	d8800c15 	stw	r2,48(sp)
 20110cc:	18c00047 	ldb	r3,1(r3)
 20110d0:	00800a04 	movi	r2,40
 20110d4:	18802426 	beq	r3,r2,2011168 <_strtod_r+0x13f4>
 20110d8:	00bffe34 	movhi	r2,65528
 20110dc:	d8800715 	stw	r2,28(sp)
 20110e0:	d8000615 	stw	zero,24(sp)
 20110e4:	003c9b06 	br	2010354 <_strtod_r+0x5e0>
 20110e8:	1011883a 	mov	r8,r2
 20110ec:	d8800c15 	stw	r2,48(sp)
 20110f0:	01008174 	movhi	r4,517
 20110f4:	21380504 	addi	r4,r4,-8172
 20110f8:	01801004 	movi	r6,64
 20110fc:	01c01684 	movi	r7,90
 2011100:	21400007 	ldb	r5,0(r4)
 2011104:	10800044 	addi	r2,r2,1
 2011108:	21000044 	addi	r4,r4,1
 201110c:	28001426 	beq	r5,zero,2011160 <_strtod_r+0x13ec>
 2011110:	10c00007 	ldb	r3,0(r2)
 2011114:	30c0020e 	bge	r6,r3,2011120 <_strtod_r+0x13ac>
 2011118:	38c00116 	blt	r7,r3,2011120 <_strtod_r+0x13ac>
 201111c:	18c00804 	addi	r3,r3,32
 2011120:	197ff726 	beq	r3,r5,2011100 <_strtod_r+0x138c>
 2011124:	40800044 	addi	r2,r8,1
 2011128:	d8800c15 	stw	r2,48(sp)
 201112c:	009ffc34 	movhi	r2,32752
 2011130:	d8800715 	stw	r2,28(sp)
 2011134:	d8000615 	stw	zero,24(sp)
 2011138:	003c8606 	br	2010354 <_strtod_r+0x5e0>
 201113c:	00808174 	movhi	r2,517
 2011140:	10b7c504 	addi	r2,r2,-8428
 2011144:	002f883a 	mov	r23,zero
 2011148:	d8800e15 	stw	r2,56(sp)
 201114c:	003e4c06 	br	2010a80 <_strtod_r+0xd0c>
 2011150:	4805883a 	mov	r2,r9
 2011154:	003c0906 	br	201017c <_strtod_r+0x408>
 2011158:	05001a84 	movi	r20,106
 201115c:	003f3506 	br	2010e34 <_strtod_r+0x10c0>
 2011160:	d8800c15 	stw	r2,48(sp)
 2011164:	003ff106 	br	201112c <_strtod_r+0x13b8>
 2011168:	d9000c04 	addi	r4,sp,48
 201116c:	01408174 	movhi	r5,517
 2011170:	294a7a04 	addi	r5,r5,10728
 2011174:	d9800204 	addi	r6,sp,8
 2011178:	20128b80 	call	20128b8 <__hexnan>
 201117c:	00c00144 	movi	r3,5
 2011180:	10ffd51e 	bne	r2,r3,20110d8 <_strtod_r+0x1364>
 2011184:	d8800317 	ldw	r2,12(sp)
 2011188:	109ffc34 	orhi	r2,r2,32752
 201118c:	d8800715 	stw	r2,28(sp)
 2011190:	d8800217 	ldw	r2,8(sp)
 2011194:	d8800615 	stw	r2,24(sp)
 2011198:	003c6e06 	br	2010354 <_strtod_r+0x5e0>
 201119c:	00ffffc4 	movi	r3,-1
 20111a0:	1884983a 	sll	r2,r3,r2
 20111a4:	d8c00617 	ldw	r3,24(sp)
 20111a8:	1884703a 	and	r2,r3,r2
 20111ac:	d8800615 	stw	r2,24(sp)
 20111b0:	003f3f06 	br	2010eb0 <_strtod_r+0x113c>
 20111b4:	10bff804 	addi	r2,r2,-32
 20111b8:	013fffc4 	movi	r4,-1
 20111bc:	2084983a 	sll	r2,r4,r2
 20111c0:	10c6703a 	and	r3,r2,r3
 20111c4:	d8c00715 	stw	r3,28(sp)
 20111c8:	003f3906 	br	2010eb0 <_strtod_r+0x113c>

020111cc <strtod>:
 20111cc:	00c08174 	movhi	r3,517
 20111d0:	18d03604 	addi	r3,r3,16600
 20111d4:	2005883a 	mov	r2,r4
 20111d8:	19000017 	ldw	r4,0(r3)
 20111dc:	280d883a 	mov	r6,r5
 20111e0:	100b883a 	mov	r5,r2
 20111e4:	200fd741 	jmpi	200fd74 <_strtod_r>

020111e8 <strtof>:
 20111e8:	defffb04 	addi	sp,sp,-20
 20111ec:	dcc00315 	stw	r19,12(sp)
 20111f0:	04c08174 	movhi	r19,517
 20111f4:	9cd03604 	addi	r19,r19,16600
 20111f8:	2005883a 	mov	r2,r4
 20111fc:	99000017 	ldw	r4,0(r19)
 2011200:	280d883a 	mov	r6,r5
 2011204:	100b883a 	mov	r5,r2
 2011208:	dfc00415 	stw	ra,16(sp)
 201120c:	dc800215 	stw	r18,8(sp)
 2011210:	dc400115 	stw	r17,4(sp)
 2011214:	dc000015 	stw	r16,0(sp)
 2011218:	200fd740 	call	200fd74 <_strtod_r>
 201121c:	1009883a 	mov	r4,r2
 2011220:	180b883a 	mov	r5,r3
 2011224:	1025883a 	mov	r18,r2
 2011228:	1823883a 	mov	r17,r3
 201122c:	20145000 	call	2014500 <__truncdfsf2>
 2011230:	1009883a 	mov	r4,r2
 2011234:	000b883a 	mov	r5,zero
 2011238:	1021883a 	mov	r16,r2
 201123c:	201377c0 	call	201377c <__eqsf2>
 2011240:	1000111e 	bne	r2,zero,2011288 <strtof+0xa0>
 2011244:	9009883a 	mov	r4,r18
 2011248:	880b883a 	mov	r5,r17
 201124c:	000d883a 	mov	r6,zero
 2011250:	000f883a 	mov	r7,zero
 2011254:	201417c0 	call	201417c <__nedf2>
 2011258:	10000b26 	beq	r2,zero,2011288 <strtof+0xa0>
 201125c:	98800017 	ldw	r2,0(r19)
 2011260:	00c00884 	movi	r3,34
 2011264:	10c00015 	stw	r3,0(r2)
 2011268:	8005883a 	mov	r2,r16
 201126c:	dfc00417 	ldw	ra,16(sp)
 2011270:	dcc00317 	ldw	r19,12(sp)
 2011274:	dc800217 	ldw	r18,8(sp)
 2011278:	dc400117 	ldw	r17,4(sp)
 201127c:	dc000017 	ldw	r16,0(sp)
 2011280:	dec00504 	addi	sp,sp,20
 2011284:	f800283a 	ret
 2011288:	8009883a 	mov	r4,r16
 201128c:	015fe034 	movhi	r5,32640
 2011290:	297fffc4 	addi	r5,r5,-1
 2011294:	20137d00 	call	20137d0 <__gtsf2>
 2011298:	0080070e 	bge	zero,r2,20112b8 <strtof+0xd0>
 201129c:	9009883a 	mov	r4,r18
 20112a0:	880b883a 	mov	r5,r17
 20112a4:	01bfffc4 	movi	r6,-1
 20112a8:	01dffc34 	movhi	r7,32752
 20112ac:	39ffffc4 	addi	r7,r7,-1
 20112b0:	20141d80 	call	20141d8 <__gtdf2>
 20112b4:	00bfe90e 	bge	zero,r2,201125c <strtof+0x74>
 20112b8:	8009883a 	mov	r4,r16
 20112bc:	017fe034 	movhi	r5,65408
 20112c0:	297fffc4 	addi	r5,r5,-1
 20112c4:	201382c0 	call	201382c <__ltsf2>
 20112c8:	103fe70e 	bge	r2,zero,2011268 <strtof+0x80>
 20112cc:	9009883a 	mov	r4,r18
 20112d0:	880b883a 	mov	r5,r17
 20112d4:	01bfffc4 	movi	r6,-1
 20112d8:	01fffc34 	movhi	r7,65520
 20112dc:	39ffffc4 	addi	r7,r7,-1
 20112e0:	20142a00 	call	20142a0 <__ltdf2>
 20112e4:	103fdd0e 	bge	r2,zero,201125c <strtof+0x74>
 20112e8:	8005883a 	mov	r2,r16
 20112ec:	dfc00417 	ldw	ra,16(sp)
 20112f0:	dcc00317 	ldw	r19,12(sp)
 20112f4:	dc800217 	ldw	r18,8(sp)
 20112f8:	dc400117 	ldw	r17,4(sp)
 20112fc:	dc000017 	ldw	r16,0(sp)
 2011300:	dec00504 	addi	sp,sp,20
 2011304:	f800283a 	ret

02011308 <_strtoll_r>:
 2011308:	defff004 	addi	sp,sp,-64
 201130c:	00808174 	movhi	r2,517
 2011310:	10903404 	addi	r2,r2,16592
 2011314:	ddc00d15 	stw	r23,52(sp)
 2011318:	15c00017 	ldw	r23,0(r2)
 201131c:	df000e15 	stw	fp,56(sp)
 2011320:	dc000615 	stw	r16,24(sp)
 2011324:	dfc00f15 	stw	ra,60(sp)
 2011328:	dd800c15 	stw	r22,48(sp)
 201132c:	dd400b15 	stw	r21,44(sp)
 2011330:	dd000a15 	stw	r20,40(sp)
 2011334:	dcc00915 	stw	r19,36(sp)
 2011338:	dc800815 	stw	r18,32(sp)
 201133c:	dc400715 	stw	r17,28(sp)
 2011340:	d9400015 	stw	r5,0(sp)
 2011344:	d9000415 	stw	r4,16(sp)
 2011348:	d9800115 	stw	r6,4(sp)
 201134c:	3839883a 	mov	fp,r7
 2011350:	2821883a 	mov	r16,r5
 2011354:	82000007 	ldb	r8,0(r16)
 2011358:	84000044 	addi	r16,r16,1
 201135c:	ba05883a 	add	r2,r23,r8
 2011360:	10800003 	ldbu	r2,0(r2)
 2011364:	1080020c 	andi	r2,r2,8
 2011368:	10803fcc 	andi	r2,r2,255
 201136c:	1080201c 	xori	r2,r2,128
 2011370:	10bfe004 	addi	r2,r2,-128
 2011374:	103ff71e 	bne	r2,zero,2011354 <_strtoll_r+0x4c>
 2011378:	00800b44 	movi	r2,45
 201137c:	40807a26 	beq	r8,r2,2011568 <_strtoll_r+0x260>
 2011380:	00800ac4 	movi	r2,43
 2011384:	40808826 	beq	r8,r2,20115a8 <_strtoll_r+0x2a0>
 2011388:	d8000215 	stw	zero,8(sp)
 201138c:	e000061e 	bne	fp,zero,20113a8 <_strtoll_r+0xa0>
 2011390:	00800c04 	movi	r2,48
 2011394:	40808b26 	beq	r8,r2,20115c4 <_strtoll_r+0x2bc>
 2011398:	04800284 	movi	r18,10
 201139c:	0027883a 	mov	r19,zero
 20113a0:	9039883a 	mov	fp,r18
 20113a4:	00000406 	br	20113b8 <_strtoll_r+0xb0>
 20113a8:	00800404 	movi	r2,16
 20113ac:	e0809926 	beq	fp,r2,2011614 <_strtoll_r+0x30c>
 20113b0:	e027d7fa 	srai	r19,fp,31
 20113b4:	e025883a 	mov	r18,fp
 20113b8:	d9000217 	ldw	r4,8(sp)
 20113bc:	20006226 	beq	r4,zero,2011548 <_strtoll_r+0x240>
 20113c0:	002b883a 	mov	r21,zero
 20113c4:	04600034 	movhi	r17,32768
 20113c8:	a809883a 	mov	r4,r21
 20113cc:	880b883a 	mov	r5,r17
 20113d0:	900d883a 	mov	r6,r18
 20113d4:	980f883a 	mov	r7,r19
 20113d8:	da000515 	stw	r8,20(sp)
 20113dc:	20131f00 	call	20131f0 <__umoddi3>
 20113e0:	a809883a 	mov	r4,r21
 20113e4:	880b883a 	mov	r5,r17
 20113e8:	900d883a 	mov	r6,r18
 20113ec:	980f883a 	mov	r7,r19
 20113f0:	d8800315 	stw	r2,12(sp)
 20113f4:	2012c280 	call	2012c28 <__udivdi3>
 20113f8:	da000517 	ldw	r8,20(sp)
 20113fc:	182b883a 	mov	r21,r3
 2011400:	1023883a 	mov	r17,r2
 2011404:	ba0d883a 	add	r6,r23,r8
 2011408:	31800003 	ldbu	r6,0(r6)
 201140c:	0007883a 	mov	r3,zero
 2011410:	0009883a 	mov	r4,zero
 2011414:	3240010c 	andi	r9,r6,4
 2011418:	4a403fcc 	andi	r9,r9,255
 201141c:	4a40201c 	xori	r9,r9,128
 2011420:	4a7fe004 	addi	r9,r9,-128
 2011424:	000b883a 	mov	r5,zero
 2011428:	05bfffc4 	movi	r22,-1
 201142c:	48001026 	beq	r9,zero,2011470 <_strtoll_r+0x168>
 2011430:	453ff404 	addi	r20,r8,-48
 2011434:	a700150e 	bge	r20,fp,201148c <_strtoll_r+0x184>
 2011438:	1d800426 	beq	r3,r22,201144c <_strtoll_r+0x144>
 201143c:	a9400236 	bltu	r21,r5,2011448 <_strtoll_r+0x140>
 2011440:	2d402e1e 	bne	r5,r21,20114fc <_strtoll_r+0x1f4>
 2011444:	89002d2e 	bgeu	r17,r4,20114fc <_strtoll_r+0x1f4>
 2011448:	00ffffc4 	movi	r3,-1
 201144c:	82000007 	ldb	r8,0(r16)
 2011450:	84000044 	addi	r16,r16,1
 2011454:	ba0d883a 	add	r6,r23,r8
 2011458:	31800003 	ldbu	r6,0(r6)
 201145c:	3240010c 	andi	r9,r6,4
 2011460:	4a403fcc 	andi	r9,r9,255
 2011464:	4a40201c 	xori	r9,r9,128
 2011468:	4a7fe004 	addi	r9,r9,-128
 201146c:	483ff01e 	bne	r9,zero,2011430 <_strtoll_r+0x128>
 2011470:	308000cc 	andi	r2,r6,3
 2011474:	10000526 	beq	r2,zero,201148c <_strtoll_r+0x184>
 2011478:	3180004c 	andi	r6,r6,1
 201147c:	30002b26 	beq	r6,zero,201152c <_strtoll_r+0x224>
 2011480:	00800dc4 	movi	r2,55
 2011484:	40a9c83a 	sub	r20,r8,r2
 2011488:	a73feb16 	blt	r20,fp,2011438 <_strtoll_r+0x130>
 201148c:	00bfffc4 	movi	r2,-1
 2011490:	18803a26 	beq	r3,r2,201157c <_strtoll_r+0x274>
 2011494:	d8800217 	ldw	r2,8(sp)
 2011498:	10000426 	beq	r2,zero,20114ac <_strtoll_r+0x1a4>
 201149c:	0109c83a 	sub	r4,zero,r4
 20114a0:	2004c03a 	cmpne	r2,r4,zero
 20114a4:	014bc83a 	sub	r5,zero,r5
 20114a8:	288bc83a 	sub	r5,r5,r2
 20114ac:	d8800117 	ldw	r2,4(sp)
 20114b0:	10004f26 	beq	r2,zero,20115f0 <_strtoll_r+0x2e8>
 20114b4:	2005883a 	mov	r2,r4
 20114b8:	1800271e 	bne	r3,zero,2011558 <_strtoll_r+0x250>
 20114bc:	2807883a 	mov	r3,r5
 20114c0:	d9400017 	ldw	r5,0(sp)
 20114c4:	d9000117 	ldw	r4,4(sp)
 20114c8:	21400015 	stw	r5,0(r4)
 20114cc:	dfc00f17 	ldw	ra,60(sp)
 20114d0:	df000e17 	ldw	fp,56(sp)
 20114d4:	ddc00d17 	ldw	r23,52(sp)
 20114d8:	dd800c17 	ldw	r22,48(sp)
 20114dc:	dd400b17 	ldw	r21,44(sp)
 20114e0:	dd000a17 	ldw	r20,40(sp)
 20114e4:	dcc00917 	ldw	r19,36(sp)
 20114e8:	dc800817 	ldw	r18,32(sp)
 20114ec:	dc400717 	ldw	r17,28(sp)
 20114f0:	dc000617 	ldw	r16,24(sp)
 20114f4:	dec01004 	addi	sp,sp,64
 20114f8:	f800283a 	ret
 20114fc:	24400e26 	beq	r4,r17,2011538 <_strtoll_r+0x230>
 2011500:	900d883a 	mov	r6,r18
 2011504:	980f883a 	mov	r7,r19
 2011508:	2012b440 	call	2012b44 <__muldi3>
 201150c:	a00dd7fa 	srai	r6,r20,31
 2011510:	a085883a 	add	r2,r20,r2
 2011514:	1511803a 	cmpltu	r8,r2,r20
 2011518:	30c7883a 	add	r3,r6,r3
 201151c:	40cb883a 	add	r5,r8,r3
 2011520:	1009883a 	mov	r4,r2
 2011524:	00c00044 	movi	r3,1
 2011528:	003fc806 	br	201144c <_strtoll_r+0x144>
 201152c:	008015c4 	movi	r2,87
 2011530:	40a9c83a 	sub	r20,r8,r2
 2011534:	003fd406 	br	2011488 <_strtoll_r+0x180>
 2011538:	2d7ff11e 	bne	r5,r21,2011500 <_strtoll_r+0x1f8>
 201153c:	d8800317 	ldw	r2,12(sp)
 2011540:	153fc116 	blt	r2,r20,2011448 <_strtoll_r+0x140>
 2011544:	003fee06 	br	2011500 <_strtoll_r+0x1f8>
 2011548:	057fffc4 	movi	r21,-1
 201154c:	04600034 	movhi	r17,32768
 2011550:	8c7fffc4 	addi	r17,r17,-1
 2011554:	003f9c06 	br	20113c8 <_strtoll_r+0xc0>
 2011558:	2807883a 	mov	r3,r5
 201155c:	843fffc4 	addi	r16,r16,-1
 2011560:	dc000015 	stw	r16,0(sp)
 2011564:	003fd606 	br	20114c0 <_strtoll_r+0x1b8>
 2011568:	00800044 	movi	r2,1
 201156c:	82000007 	ldb	r8,0(r16)
 2011570:	d8800215 	stw	r2,8(sp)
 2011574:	80a1883a 	add	r16,r16,r2
 2011578:	003f8406 	br	201138c <_strtoll_r+0x84>
 201157c:	d9000217 	ldw	r4,8(sp)
 2011580:	20000d1e 	bne	r4,zero,20115b8 <_strtoll_r+0x2b0>
 2011584:	1805883a 	mov	r2,r3
 2011588:	00e00034 	movhi	r3,32768
 201158c:	18ffffc4 	addi	r3,r3,-1
 2011590:	d9400417 	ldw	r5,16(sp)
 2011594:	01000884 	movi	r4,34
 2011598:	29000015 	stw	r4,0(r5)
 201159c:	d9000117 	ldw	r4,4(sp)
 20115a0:	203fee1e 	bne	r4,zero,201155c <_strtoll_r+0x254>
 20115a4:	003fc906 	br	20114cc <_strtoll_r+0x1c4>
 20115a8:	82000007 	ldb	r8,0(r16)
 20115ac:	d8000215 	stw	zero,8(sp)
 20115b0:	84000044 	addi	r16,r16,1
 20115b4:	003f7506 	br	201138c <_strtoll_r+0x84>
 20115b8:	0005883a 	mov	r2,zero
 20115bc:	00e00034 	movhi	r3,32768
 20115c0:	003ff306 	br	2011590 <_strtoll_r+0x288>
 20115c4:	80800007 	ldb	r2,0(r16)
 20115c8:	00c01e04 	movi	r3,120
 20115cc:	10c00b26 	beq	r2,r3,20115fc <_strtoll_r+0x2f4>
 20115d0:	00c01604 	movi	r3,88
 20115d4:	10c00926 	beq	r2,r3,20115fc <_strtoll_r+0x2f4>
 20115d8:	e000131e 	bne	fp,zero,2011628 <_strtoll_r+0x320>
 20115dc:	04800204 	movi	r18,8
 20115e0:	0027883a 	mov	r19,zero
 20115e4:	02000c04 	movi	r8,48
 20115e8:	9039883a 	mov	fp,r18
 20115ec:	003f7206 	br	20113b8 <_strtoll_r+0xb0>
 20115f0:	2005883a 	mov	r2,r4
 20115f4:	2807883a 	mov	r3,r5
 20115f8:	003fb406 	br	20114cc <_strtoll_r+0x1c4>
 20115fc:	04800404 	movi	r18,16
 2011600:	82000047 	ldb	r8,1(r16)
 2011604:	0027883a 	mov	r19,zero
 2011608:	84000084 	addi	r16,r16,2
 201160c:	9039883a 	mov	fp,r18
 2011610:	003f6906 	br	20113b8 <_strtoll_r+0xb0>
 2011614:	00800c04 	movi	r2,48
 2011618:	40bfea26 	beq	r8,r2,20115c4 <_strtoll_r+0x2bc>
 201161c:	e025883a 	mov	r18,fp
 2011620:	0027883a 	mov	r19,zero
 2011624:	003f6406 	br	20113b8 <_strtoll_r+0xb0>
 2011628:	e025883a 	mov	r18,fp
 201162c:	e027d7fa 	srai	r19,fp,31
 2011630:	02000c04 	movi	r8,48
 2011634:	003f6006 	br	20113b8 <_strtoll_r+0xb0>

02011638 <_strtoul_r>:
 2011638:	defff604 	addi	sp,sp,-40
 201163c:	00808174 	movhi	r2,517
 2011640:	10903404 	addi	r2,r2,16592
 2011644:	dc800315 	stw	r18,12(sp)
 2011648:	14800017 	ldw	r18,0(r2)
 201164c:	dd800715 	stw	r22,28(sp)
 2011650:	dd400615 	stw	r21,24(sp)
 2011654:	dcc00415 	stw	r19,16(sp)
 2011658:	dc000115 	stw	r16,4(sp)
 201165c:	dfc00915 	stw	ra,36(sp)
 2011660:	ddc00815 	stw	r23,32(sp)
 2011664:	dd000515 	stw	r20,20(sp)
 2011668:	dc400215 	stw	r17,8(sp)
 201166c:	282b883a 	mov	r21,r5
 2011670:	202d883a 	mov	r22,r4
 2011674:	3827883a 	mov	r19,r7
 2011678:	2821883a 	mov	r16,r5
 201167c:	84400007 	ldb	r17,0(r16)
 2011680:	84000044 	addi	r16,r16,1
 2011684:	9445883a 	add	r2,r18,r17
 2011688:	10800003 	ldbu	r2,0(r2)
 201168c:	1080020c 	andi	r2,r2,8
 2011690:	10803fcc 	andi	r2,r2,255
 2011694:	1080201c 	xori	r2,r2,128
 2011698:	10bfe004 	addi	r2,r2,-128
 201169c:	103ff71e 	bne	r2,zero,201167c <_strtoul_r+0x44>
 20116a0:	00800b44 	movi	r2,45
 20116a4:	88805926 	beq	r17,r2,201180c <_strtoul_r+0x1d4>
 20116a8:	00800ac4 	movi	r2,43
 20116ac:	88805b26 	beq	r17,r2,201181c <_strtoul_r+0x1e4>
 20116b0:	002f883a 	mov	r23,zero
 20116b4:	9800081e 	bne	r19,zero,20116d8 <_strtoul_r+0xa0>
 20116b8:	00800c04 	movi	r2,48
 20116bc:	88805d26 	beq	r17,r2,2011834 <_strtoul_r+0x1fc>
 20116c0:	04c00284 	movi	r19,10
 20116c4:	01400144 	movi	r5,5
 20116c8:	050666b4 	movhi	r20,6554
 20116cc:	a5266644 	addi	r20,r20,-26215
 20116d0:	9809883a 	mov	r4,r19
 20116d4:	00000d06 	br	201170c <_strtoul_r+0xd4>
 20116d8:	00800404 	movi	r2,16
 20116dc:	98805326 	beq	r19,r2,201182c <_strtoul_r+0x1f4>
 20116e0:	013fffc4 	movi	r4,-1
 20116e4:	980b883a 	mov	r5,r19
 20116e8:	d9800015 	stw	r6,0(sp)
 20116ec:	201479c0 	call	201479c <__udivsi3>
 20116f0:	013fffc4 	movi	r4,-1
 20116f4:	980b883a 	mov	r5,r19
 20116f8:	1029883a 	mov	r20,r2
 20116fc:	20147a40 	call	20147a4 <__umodsi3>
 2011700:	d9800017 	ldw	r6,0(sp)
 2011704:	100b883a 	mov	r5,r2
 2011708:	9809883a 	mov	r4,r19
 201170c:	9447883a 	add	r3,r18,r17
 2011710:	18c00003 	ldbu	r3,0(r3)
 2011714:	0013883a 	mov	r9,zero
 2011718:	0005883a 	mov	r2,zero
 201171c:	1a00010c 	andi	r8,r3,4
 2011720:	42003fcc 	andi	r8,r8,255
 2011724:	4200201c 	xori	r8,r8,128
 2011728:	423fe004 	addi	r8,r8,-128
 201172c:	02bfffc4 	movi	r10,-1
 2011730:	40001126 	beq	r8,zero,2011778 <_strtoul_r+0x140>
 2011734:	8c7ff404 	addi	r17,r17,-48
 2011738:	8cc0160e 	bge	r17,r19,2011794 <_strtoul_r+0x15c>
 201173c:	4a800526 	beq	r9,r10,2011754 <_strtoul_r+0x11c>
 2011740:	a0802736 	bltu	r20,r2,20117e0 <_strtoul_r+0x1a8>
 2011744:	15002526 	beq	r2,r20,20117dc <_strtoul_r+0x1a4>
 2011748:	1107383a 	mul	r3,r2,r4
 201174c:	02400044 	movi	r9,1
 2011750:	88c5883a 	add	r2,r17,r3
 2011754:	84400007 	ldb	r17,0(r16)
 2011758:	84000044 	addi	r16,r16,1
 201175c:	9447883a 	add	r3,r18,r17
 2011760:	18c00003 	ldbu	r3,0(r3)
 2011764:	1a00010c 	andi	r8,r3,4
 2011768:	42003fcc 	andi	r8,r8,255
 201176c:	4200201c 	xori	r8,r8,128
 2011770:	423fe004 	addi	r8,r8,-128
 2011774:	403fef1e 	bne	r8,zero,2011734 <_strtoul_r+0xfc>
 2011778:	19c000cc 	andi	r7,r3,3
 201177c:	38000526 	beq	r7,zero,2011794 <_strtoul_r+0x15c>
 2011780:	18c0004c 	andi	r3,r3,1
 2011784:	18001826 	beq	r3,zero,20117e8 <_strtoul_r+0x1b0>
 2011788:	00c00dc4 	movi	r3,55
 201178c:	88e3c83a 	sub	r17,r17,r3
 2011790:	8cffea16 	blt	r17,r19,201173c <_strtoul_r+0x104>
 2011794:	00ffffc4 	movi	r3,-1
 2011798:	48c01626 	beq	r9,r3,20117f4 <_strtoul_r+0x1bc>
 201179c:	b8000126 	beq	r23,zero,20117a4 <_strtoul_r+0x16c>
 20117a0:	0085c83a 	sub	r2,zero,r2
 20117a4:	30000226 	beq	r6,zero,20117b0 <_strtoul_r+0x178>
 20117a8:	4800161e 	bne	r9,zero,2011804 <_strtoul_r+0x1cc>
 20117ac:	35400015 	stw	r21,0(r6)
 20117b0:	dfc00917 	ldw	ra,36(sp)
 20117b4:	ddc00817 	ldw	r23,32(sp)
 20117b8:	dd800717 	ldw	r22,28(sp)
 20117bc:	dd400617 	ldw	r21,24(sp)
 20117c0:	dd000517 	ldw	r20,20(sp)
 20117c4:	dcc00417 	ldw	r19,16(sp)
 20117c8:	dc800317 	ldw	r18,12(sp)
 20117cc:	dc400217 	ldw	r17,8(sp)
 20117d0:	dc000117 	ldw	r16,4(sp)
 20117d4:	dec00a04 	addi	sp,sp,40
 20117d8:	f800283a 	ret
 20117dc:	2c7fda0e 	bge	r5,r17,2011748 <_strtoul_r+0x110>
 20117e0:	027fffc4 	movi	r9,-1
 20117e4:	003fdb06 	br	2011754 <_strtoul_r+0x11c>
 20117e8:	00c015c4 	movi	r3,87
 20117ec:	88e3c83a 	sub	r17,r17,r3
 20117f0:	003fe706 	br	2011790 <_strtoul_r+0x158>
 20117f4:	00800884 	movi	r2,34
 20117f8:	b0800015 	stw	r2,0(r22)
 20117fc:	4805883a 	mov	r2,r9
 2011800:	303feb26 	beq	r6,zero,20117b0 <_strtoul_r+0x178>
 2011804:	857fffc4 	addi	r21,r16,-1
 2011808:	003fe806 	br	20117ac <_strtoul_r+0x174>
 201180c:	05c00044 	movi	r23,1
 2011810:	84400007 	ldb	r17,0(r16)
 2011814:	85e1883a 	add	r16,r16,r23
 2011818:	003fa606 	br	20116b4 <_strtoul_r+0x7c>
 201181c:	84400007 	ldb	r17,0(r16)
 2011820:	002f883a 	mov	r23,zero
 2011824:	84000044 	addi	r16,r16,1
 2011828:	003fa206 	br	20116b4 <_strtoul_r+0x7c>
 201182c:	00800c04 	movi	r2,48
 2011830:	88bfab1e 	bne	r17,r2,20116e0 <_strtoul_r+0xa8>
 2011834:	80800007 	ldb	r2,0(r16)
 2011838:	00c01e04 	movi	r3,120
 201183c:	10c00a26 	beq	r2,r3,2011868 <_strtoul_r+0x230>
 2011840:	00c01604 	movi	r3,88
 2011844:	10c00826 	beq	r2,r3,2011868 <_strtoul_r+0x230>
 2011848:	98000f1e 	bne	r19,zero,2011888 <_strtoul_r+0x250>
 201184c:	01000204 	movi	r4,8
 2011850:	014001c4 	movi	r5,7
 2011854:	05080034 	movhi	r20,8192
 2011858:	a53fffc4 	addi	r20,r20,-1
 201185c:	04400c04 	movi	r17,48
 2011860:	2027883a 	mov	r19,r4
 2011864:	003fa906 	br	201170c <_strtoul_r+0xd4>
 2011868:	01000404 	movi	r4,16
 201186c:	84400047 	ldb	r17,1(r16)
 2011870:	014003c4 	movi	r5,15
 2011874:	84000084 	addi	r16,r16,2
 2011878:	05040034 	movhi	r20,4096
 201187c:	a53fffc4 	addi	r20,r20,-1
 2011880:	2027883a 	mov	r19,r4
 2011884:	003fa106 	br	201170c <_strtoul_r+0xd4>
 2011888:	013fffc4 	movi	r4,-1
 201188c:	980b883a 	mov	r5,r19
 2011890:	d9800015 	stw	r6,0(sp)
 2011894:	201479c0 	call	201479c <__udivsi3>
 2011898:	013fffc4 	movi	r4,-1
 201189c:	980b883a 	mov	r5,r19
 20118a0:	1029883a 	mov	r20,r2
 20118a4:	20147a40 	call	20147a4 <__umodsi3>
 20118a8:	100b883a 	mov	r5,r2
 20118ac:	9809883a 	mov	r4,r19
 20118b0:	04400c04 	movi	r17,48
 20118b4:	d9800017 	ldw	r6,0(sp)
 20118b8:	003f9406 	br	201170c <_strtoul_r+0xd4>

020118bc <strtoul>:
 20118bc:	00808174 	movhi	r2,517
 20118c0:	10903604 	addi	r2,r2,16600
 20118c4:	2007883a 	mov	r3,r4
 20118c8:	11000017 	ldw	r4,0(r2)
 20118cc:	2805883a 	mov	r2,r5
 20118d0:	300f883a 	mov	r7,r6
 20118d4:	180b883a 	mov	r5,r3
 20118d8:	100d883a 	mov	r6,r2
 20118dc:	20116381 	jmpi	2011638 <_strtoul_r>

020118e0 <_strtoull_r>:
 20118e0:	defff004 	addi	sp,sp,-64
 20118e4:	00808174 	movhi	r2,517
 20118e8:	10903404 	addi	r2,r2,16592
 20118ec:	dd800c15 	stw	r22,48(sp)
 20118f0:	15800017 	ldw	r22,0(r2)
 20118f4:	df000e15 	stw	fp,56(sp)
 20118f8:	dc000615 	stw	r16,24(sp)
 20118fc:	dfc00f15 	stw	ra,60(sp)
 2011900:	ddc00d15 	stw	r23,52(sp)
 2011904:	dd400b15 	stw	r21,44(sp)
 2011908:	dd000a15 	stw	r20,40(sp)
 201190c:	dcc00915 	stw	r19,36(sp)
 2011910:	dc800815 	stw	r18,32(sp)
 2011914:	dc400715 	stw	r17,28(sp)
 2011918:	d9400015 	stw	r5,0(sp)
 201191c:	d9000415 	stw	r4,16(sp)
 2011920:	d9800115 	stw	r6,4(sp)
 2011924:	3839883a 	mov	fp,r7
 2011928:	2821883a 	mov	r16,r5
 201192c:	82000007 	ldb	r8,0(r16)
 2011930:	84000044 	addi	r16,r16,1
 2011934:	b205883a 	add	r2,r22,r8
 2011938:	10800003 	ldbu	r2,0(r2)
 201193c:	1080020c 	andi	r2,r2,8
 2011940:	10803fcc 	andi	r2,r2,255
 2011944:	1080201c 	xori	r2,r2,128
 2011948:	10bfe004 	addi	r2,r2,-128
 201194c:	103ff71e 	bne	r2,zero,201192c <_strtoull_r+0x4c>
 2011950:	00800b44 	movi	r2,45
 2011954:	40807e26 	beq	r8,r2,2011b50 <_strtoull_r+0x270>
 2011958:	00800ac4 	movi	r2,43
 201195c:	40808126 	beq	r8,r2,2011b64 <_strtoull_r+0x284>
 2011960:	d8000315 	stw	zero,12(sp)
 2011964:	e0000c1e 	bne	fp,zero,2011998 <_strtoull_r+0xb8>
 2011968:	00800c04 	movi	r2,48
 201196c:	40808126 	beq	r8,r2,2011b74 <_strtoull_r+0x294>
 2011970:	04c00284 	movi	r19,10
 2011974:	00800144 	movi	r2,5
 2011978:	d8800215 	stw	r2,8(sp)
 201197c:	046666b4 	movhi	r17,39322
 2011980:	8c666644 	addi	r17,r17,-26215
 2011984:	05c666b4 	movhi	r23,6554
 2011988:	bde66644 	addi	r23,r23,-26215
 201198c:	0025883a 	mov	r18,zero
 2011990:	9839883a 	mov	fp,r19
 2011994:	00001306 	br	20119e4 <_strtoull_r+0x104>
 2011998:	00800404 	movi	r2,16
 201199c:	e0809026 	beq	fp,r2,2011be0 <_strtoull_r+0x300>
 20119a0:	e025d7fa 	srai	r18,fp,31
 20119a4:	013fffc4 	movi	r4,-1
 20119a8:	200b883a 	mov	r5,r4
 20119ac:	e00d883a 	mov	r6,fp
 20119b0:	900f883a 	mov	r7,r18
 20119b4:	da000515 	stw	r8,20(sp)
 20119b8:	2012c280 	call	2012c28 <__udivdi3>
 20119bc:	013fffc4 	movi	r4,-1
 20119c0:	200b883a 	mov	r5,r4
 20119c4:	e00d883a 	mov	r6,fp
 20119c8:	900f883a 	mov	r7,r18
 20119cc:	1023883a 	mov	r17,r2
 20119d0:	182f883a 	mov	r23,r3
 20119d4:	20131f00 	call	20131f0 <__umoddi3>
 20119d8:	da000517 	ldw	r8,20(sp)
 20119dc:	d8800215 	stw	r2,8(sp)
 20119e0:	e027883a 	mov	r19,fp
 20119e4:	b20d883a 	add	r6,r22,r8
 20119e8:	32400003 	ldbu	r9,0(r6)
 20119ec:	0007883a 	mov	r3,zero
 20119f0:	0009883a 	mov	r4,zero
 20119f4:	4a80010c 	andi	r10,r9,4
 20119f8:	52803fcc 	andi	r10,r10,255
 20119fc:	5280201c 	xori	r10,r10,128
 2011a00:	52bfe004 	addi	r10,r10,-128
 2011a04:	000b883a 	mov	r5,zero
 2011a08:	057fffc4 	movi	r21,-1
 2011a0c:	50001026 	beq	r10,zero,2011a50 <_strtoull_r+0x170>
 2011a10:	453ff404 	addi	r20,r8,-48
 2011a14:	a700150e 	bge	r20,fp,2011a6c <_strtoull_r+0x18c>
 2011a18:	1d400426 	beq	r3,r21,2011a2c <_strtoull_r+0x14c>
 2011a1c:	b9400236 	bltu	r23,r5,2011a28 <_strtoull_r+0x148>
 2011a20:	2dc0301e 	bne	r5,r23,2011ae4 <_strtoull_r+0x204>
 2011a24:	89002f2e 	bgeu	r17,r4,2011ae4 <_strtoull_r+0x204>
 2011a28:	00ffffc4 	movi	r3,-1
 2011a2c:	82000007 	ldb	r8,0(r16)
 2011a30:	84000044 	addi	r16,r16,1
 2011a34:	b20d883a 	add	r6,r22,r8
 2011a38:	32400003 	ldbu	r9,0(r6)
 2011a3c:	4a80010c 	andi	r10,r9,4
 2011a40:	52803fcc 	andi	r10,r10,255
 2011a44:	5280201c 	xori	r10,r10,128
 2011a48:	52bfe004 	addi	r10,r10,-128
 2011a4c:	503ff01e 	bne	r10,zero,2011a10 <_strtoull_r+0x130>
 2011a50:	488000cc 	andi	r2,r9,3
 2011a54:	10000526 	beq	r2,zero,2011a6c <_strtoull_r+0x18c>
 2011a58:	4a40004c 	andi	r9,r9,1
 2011a5c:	48002d26 	beq	r9,zero,2011b14 <_strtoull_r+0x234>
 2011a60:	00800dc4 	movi	r2,55
 2011a64:	40a9c83a 	sub	r20,r8,r2
 2011a68:	a73feb16 	blt	r20,fp,2011a18 <_strtoull_r+0x138>
 2011a6c:	00bfffc4 	movi	r2,-1
 2011a70:	18802f26 	beq	r3,r2,2011b30 <_strtoull_r+0x250>
 2011a74:	d8800317 	ldw	r2,12(sp)
 2011a78:	10000426 	beq	r2,zero,2011a8c <_strtoull_r+0x1ac>
 2011a7c:	0109c83a 	sub	r4,zero,r4
 2011a80:	2004c03a 	cmpne	r2,r4,zero
 2011a84:	014bc83a 	sub	r5,zero,r5
 2011a88:	288bc83a 	sub	r5,r5,r2
 2011a8c:	d8800117 	ldw	r2,4(sp)
 2011a90:	10000626 	beq	r2,zero,2011aac <_strtoull_r+0x1cc>
 2011a94:	18000226 	beq	r3,zero,2011aa0 <_strtoull_r+0x1c0>
 2011a98:	843fffc4 	addi	r16,r16,-1
 2011a9c:	dc000015 	stw	r16,0(sp)
 2011aa0:	d8800017 	ldw	r2,0(sp)
 2011aa4:	d8c00117 	ldw	r3,4(sp)
 2011aa8:	18800015 	stw	r2,0(r3)
 2011aac:	2005883a 	mov	r2,r4
 2011ab0:	2807883a 	mov	r3,r5
 2011ab4:	dfc00f17 	ldw	ra,60(sp)
 2011ab8:	df000e17 	ldw	fp,56(sp)
 2011abc:	ddc00d17 	ldw	r23,52(sp)
 2011ac0:	dd800c17 	ldw	r22,48(sp)
 2011ac4:	dd400b17 	ldw	r21,44(sp)
 2011ac8:	dd000a17 	ldw	r20,40(sp)
 2011acc:	dcc00917 	ldw	r19,36(sp)
 2011ad0:	dc800817 	ldw	r18,32(sp)
 2011ad4:	dc400717 	ldw	r17,28(sp)
 2011ad8:	dc000617 	ldw	r16,24(sp)
 2011adc:	dec01004 	addi	sp,sp,64
 2011ae0:	f800283a 	ret
 2011ae4:	24400e26 	beq	r4,r17,2011b20 <_strtoull_r+0x240>
 2011ae8:	980d883a 	mov	r6,r19
 2011aec:	900f883a 	mov	r7,r18
 2011af0:	2012b440 	call	2012b44 <__muldi3>
 2011af4:	a00dd7fa 	srai	r6,r20,31
 2011af8:	a085883a 	add	r2,r20,r2
 2011afc:	1511803a 	cmpltu	r8,r2,r20
 2011b00:	30c7883a 	add	r3,r6,r3
 2011b04:	40cb883a 	add	r5,r8,r3
 2011b08:	1009883a 	mov	r4,r2
 2011b0c:	00c00044 	movi	r3,1
 2011b10:	003fc606 	br	2011a2c <_strtoull_r+0x14c>
 2011b14:	008015c4 	movi	r2,87
 2011b18:	40a9c83a 	sub	r20,r8,r2
 2011b1c:	003fd206 	br	2011a68 <_strtoull_r+0x188>
 2011b20:	2dfff11e 	bne	r5,r23,2011ae8 <_strtoull_r+0x208>
 2011b24:	d8800217 	ldw	r2,8(sp)
 2011b28:	153fbf16 	blt	r2,r20,2011a28 <_strtoull_r+0x148>
 2011b2c:	003fee06 	br	2011ae8 <_strtoull_r+0x208>
 2011b30:	d9000417 	ldw	r4,16(sp)
 2011b34:	00800884 	movi	r2,34
 2011b38:	180b883a 	mov	r5,r3
 2011b3c:	20800015 	stw	r2,0(r4)
 2011b40:	d8800117 	ldw	r2,4(sp)
 2011b44:	1809883a 	mov	r4,r3
 2011b48:	103fd31e 	bne	r2,zero,2011a98 <_strtoull_r+0x1b8>
 2011b4c:	003fd706 	br	2011aac <_strtoull_r+0x1cc>
 2011b50:	00800044 	movi	r2,1
 2011b54:	82000007 	ldb	r8,0(r16)
 2011b58:	d8800315 	stw	r2,12(sp)
 2011b5c:	80a1883a 	add	r16,r16,r2
 2011b60:	003f8006 	br	2011964 <_strtoull_r+0x84>
 2011b64:	82000007 	ldb	r8,0(r16)
 2011b68:	d8000315 	stw	zero,12(sp)
 2011b6c:	84000044 	addi	r16,r16,1
 2011b70:	003f7c06 	br	2011964 <_strtoull_r+0x84>
 2011b74:	80800007 	ldb	r2,0(r16)
 2011b78:	00c01e04 	movi	r3,120
 2011b7c:	10c00d26 	beq	r2,r3,2011bb4 <_strtoull_r+0x2d4>
 2011b80:	00c01604 	movi	r3,88
 2011b84:	10c00b26 	beq	r2,r3,2011bb4 <_strtoull_r+0x2d4>
 2011b88:	e000291e 	bne	fp,zero,2011c30 <_strtoull_r+0x350>
 2011b8c:	04c00204 	movi	r19,8
 2011b90:	008001c4 	movi	r2,7
 2011b94:	d8800215 	stw	r2,8(sp)
 2011b98:	047fffc4 	movi	r17,-1
 2011b9c:	05c80034 	movhi	r23,8192
 2011ba0:	bdffffc4 	addi	r23,r23,-1
 2011ba4:	0025883a 	mov	r18,zero
 2011ba8:	02000c04 	movi	r8,48
 2011bac:	9839883a 	mov	fp,r19
 2011bb0:	003f8c06 	br	20119e4 <_strtoull_r+0x104>
 2011bb4:	04c00404 	movi	r19,16
 2011bb8:	008003c4 	movi	r2,15
 2011bbc:	82000047 	ldb	r8,1(r16)
 2011bc0:	d8800215 	stw	r2,8(sp)
 2011bc4:	84000084 	addi	r16,r16,2
 2011bc8:	047fffc4 	movi	r17,-1
 2011bcc:	05c40034 	movhi	r23,4096
 2011bd0:	bdffffc4 	addi	r23,r23,-1
 2011bd4:	0025883a 	mov	r18,zero
 2011bd8:	9839883a 	mov	fp,r19
 2011bdc:	003f8106 	br	20119e4 <_strtoull_r+0x104>
 2011be0:	00800c04 	movi	r2,48
 2011be4:	40bfe326 	beq	r8,r2,2011b74 <_strtoull_r+0x294>
 2011be8:	013fffc4 	movi	r4,-1
 2011bec:	200b883a 	mov	r5,r4
 2011bf0:	e00d883a 	mov	r6,fp
 2011bf4:	000f883a 	mov	r7,zero
 2011bf8:	da000515 	stw	r8,20(sp)
 2011bfc:	2012c280 	call	2012c28 <__udivdi3>
 2011c00:	013fffc4 	movi	r4,-1
 2011c04:	200b883a 	mov	r5,r4
 2011c08:	e00d883a 	mov	r6,fp
 2011c0c:	000f883a 	mov	r7,zero
 2011c10:	1023883a 	mov	r17,r2
 2011c14:	182f883a 	mov	r23,r3
 2011c18:	20131f00 	call	20131f0 <__umoddi3>
 2011c1c:	d8800215 	stw	r2,8(sp)
 2011c20:	e027883a 	mov	r19,fp
 2011c24:	0025883a 	mov	r18,zero
 2011c28:	da000517 	ldw	r8,20(sp)
 2011c2c:	003f6d06 	br	20119e4 <_strtoull_r+0x104>
 2011c30:	e025d7fa 	srai	r18,fp,31
 2011c34:	013fffc4 	movi	r4,-1
 2011c38:	200b883a 	mov	r5,r4
 2011c3c:	e00d883a 	mov	r6,fp
 2011c40:	900f883a 	mov	r7,r18
 2011c44:	2012c280 	call	2012c28 <__udivdi3>
 2011c48:	013fffc4 	movi	r4,-1
 2011c4c:	200b883a 	mov	r5,r4
 2011c50:	e00d883a 	mov	r6,fp
 2011c54:	900f883a 	mov	r7,r18
 2011c58:	1023883a 	mov	r17,r2
 2011c5c:	182f883a 	mov	r23,r3
 2011c60:	20131f00 	call	20131f0 <__umoddi3>
 2011c64:	d8800215 	stw	r2,8(sp)
 2011c68:	e027883a 	mov	r19,fp
 2011c6c:	02000c04 	movi	r8,48
 2011c70:	003f5c06 	br	20119e4 <_strtoull_r+0x104>

02011c74 <__submore>:
 2011c74:	defffa04 	addi	sp,sp,-24
 2011c78:	dc000015 	stw	r16,0(sp)
 2011c7c:	2821883a 	mov	r16,r5
 2011c80:	29400c17 	ldw	r5,48(r5)
 2011c84:	dfc00515 	stw	ra,20(sp)
 2011c88:	dd000415 	stw	r20,16(sp)
 2011c8c:	dcc00315 	stw	r19,12(sp)
 2011c90:	dc800215 	stw	r18,8(sp)
 2011c94:	dc400115 	stw	r17,4(sp)
 2011c98:	80801004 	addi	r2,r16,64
 2011c9c:	28801726 	beq	r5,r2,2011cfc <__submore+0x88>
 2011ca0:	84400d17 	ldw	r17,52(r16)
 2011ca4:	8c67883a 	add	r19,r17,r17
 2011ca8:	980d883a 	mov	r6,r19
 2011cac:	200f6480 	call	200f648 <_realloc_r>
 2011cb0:	1025883a 	mov	r18,r2
 2011cb4:	10002926 	beq	r2,zero,2011d5c <__submore+0xe8>
 2011cb8:	1469883a 	add	r20,r2,r17
 2011cbc:	a009883a 	mov	r4,r20
 2011cc0:	100b883a 	mov	r5,r2
 2011cc4:	880d883a 	mov	r6,r17
 2011cc8:	200660c0 	call	200660c <memcpy>
 2011ccc:	0005883a 	mov	r2,zero
 2011cd0:	85000015 	stw	r20,0(r16)
 2011cd4:	84800c15 	stw	r18,48(r16)
 2011cd8:	84c00d15 	stw	r19,52(r16)
 2011cdc:	dfc00517 	ldw	ra,20(sp)
 2011ce0:	dd000417 	ldw	r20,16(sp)
 2011ce4:	dcc00317 	ldw	r19,12(sp)
 2011ce8:	dc800217 	ldw	r18,8(sp)
 2011cec:	dc400117 	ldw	r17,4(sp)
 2011cf0:	dc000017 	ldw	r16,0(sp)
 2011cf4:	dec00604 	addi	sp,sp,24
 2011cf8:	f800283a 	ret
 2011cfc:	04410004 	movi	r17,1024
 2011d00:	880b883a 	mov	r5,r17
 2011d04:	2005e880 	call	2005e88 <_malloc_r>
 2011d08:	1007883a 	mov	r3,r2
 2011d0c:	10001326 	beq	r2,zero,2011d5c <__submore+0xe8>
 2011d10:	80801083 	ldbu	r2,66(r16)
 2011d14:	80c00c15 	stw	r3,48(r16)
 2011d18:	84400d15 	stw	r17,52(r16)
 2011d1c:	1880ffc5 	stb	r2,1023(r3)
 2011d20:	81401043 	ldbu	r5,65(r16)
 2011d24:	1900ff44 	addi	r4,r3,1021
 2011d28:	0005883a 	mov	r2,zero
 2011d2c:	1940ff85 	stb	r5,1022(r3)
 2011d30:	81401003 	ldbu	r5,64(r16)
 2011d34:	1940ff45 	stb	r5,1021(r3)
 2011d38:	81000015 	stw	r4,0(r16)
 2011d3c:	dfc00517 	ldw	ra,20(sp)
 2011d40:	dd000417 	ldw	r20,16(sp)
 2011d44:	dcc00317 	ldw	r19,12(sp)
 2011d48:	dc800217 	ldw	r18,8(sp)
 2011d4c:	dc400117 	ldw	r17,4(sp)
 2011d50:	dc000017 	ldw	r16,0(sp)
 2011d54:	dec00604 	addi	sp,sp,24
 2011d58:	f800283a 	ret
 2011d5c:	00bfffc4 	movi	r2,-1
 2011d60:	003fde06 	br	2011cdc <__submore+0x68>

02011d64 <_ungetc_r>:
 2011d64:	defffc04 	addi	sp,sp,-16
 2011d68:	dc800215 	stw	r18,8(sp)
 2011d6c:	dc400115 	stw	r17,4(sp)
 2011d70:	dc000015 	stw	r16,0(sp)
 2011d74:	dfc00315 	stw	ra,12(sp)
 2011d78:	00bfffc4 	movi	r2,-1
 2011d7c:	2825883a 	mov	r18,r5
 2011d80:	2023883a 	mov	r17,r4
 2011d84:	3021883a 	mov	r16,r6
 2011d88:	28803026 	beq	r5,r2,2011e4c <_ungetc_r+0xe8>
 2011d8c:	20000226 	beq	r4,zero,2011d98 <_ungetc_r+0x34>
 2011d90:	20800e17 	ldw	r2,56(r4)
 2011d94:	10002f26 	beq	r2,zero,2011e54 <_ungetc_r+0xf0>
 2011d98:	80c0030b 	ldhu	r3,12(r16)
 2011d9c:	00bff7c4 	movi	r2,-33
 2011da0:	1900010c 	andi	r4,r3,4
 2011da4:	213fffcc 	andi	r4,r4,65535
 2011da8:	1884703a 	and	r2,r3,r2
 2011dac:	2120001c 	xori	r4,r4,32768
 2011db0:	8080030d 	sth	r2,12(r16)
 2011db4:	21200004 	addi	r4,r4,-32768
 2011db8:	20000c1e 	bne	r4,zero,2011dec <_ungetc_r+0x88>
 2011dbc:	1900040c 	andi	r4,r3,16
 2011dc0:	213fffcc 	andi	r4,r4,65535
 2011dc4:	2120001c 	xori	r4,r4,32768
 2011dc8:	21200004 	addi	r4,r4,-32768
 2011dcc:	20001f26 	beq	r4,zero,2011e4c <_ungetc_r+0xe8>
 2011dd0:	18c0020c 	andi	r3,r3,8
 2011dd4:	18ffffcc 	andi	r3,r3,65535
 2011dd8:	18e0001c 	xori	r3,r3,32768
 2011ddc:	18e00004 	addi	r3,r3,-32768
 2011de0:	1800371e 	bne	r3,zero,2011ec0 <_ungetc_r+0x15c>
 2011de4:	10800114 	ori	r2,r2,4
 2011de8:	8080030d 	sth	r2,12(r16)
 2011dec:	80800c17 	ldw	r2,48(r16)
 2011df0:	94803fcc 	andi	r18,r18,255
 2011df4:	10001926 	beq	r2,zero,2011e5c <_ungetc_r+0xf8>
 2011df8:	80c00117 	ldw	r3,4(r16)
 2011dfc:	80800d17 	ldw	r2,52(r16)
 2011e00:	18800e0e 	bge	r3,r2,2011e3c <_ungetc_r+0xd8>
 2011e04:	80800017 	ldw	r2,0(r16)
 2011e08:	10ffffc4 	addi	r3,r2,-1
 2011e0c:	80c00015 	stw	r3,0(r16)
 2011e10:	14bfffc5 	stb	r18,-1(r2)
 2011e14:	80800117 	ldw	r2,4(r16)
 2011e18:	10800044 	addi	r2,r2,1
 2011e1c:	80800115 	stw	r2,4(r16)
 2011e20:	9005883a 	mov	r2,r18
 2011e24:	dfc00317 	ldw	ra,12(sp)
 2011e28:	dc800217 	ldw	r18,8(sp)
 2011e2c:	dc400117 	ldw	r17,4(sp)
 2011e30:	dc000017 	ldw	r16,0(sp)
 2011e34:	dec00404 	addi	sp,sp,16
 2011e38:	f800283a 	ret
 2011e3c:	8809883a 	mov	r4,r17
 2011e40:	800b883a 	mov	r5,r16
 2011e44:	2011c740 	call	2011c74 <__submore>
 2011e48:	103fee26 	beq	r2,zero,2011e04 <_ungetc_r+0xa0>
 2011e4c:	04bfffc4 	movi	r18,-1
 2011e50:	003ff306 	br	2011e20 <_ungetc_r+0xbc>
 2011e54:	200492c0 	call	200492c <__sinit>
 2011e58:	003fcf06 	br	2011d98 <_ungetc_r+0x34>
 2011e5c:	80c00417 	ldw	r3,16(r16)
 2011e60:	80800017 	ldw	r2,0(r16)
 2011e64:	18000326 	beq	r3,zero,2011e74 <_ungetc_r+0x110>
 2011e68:	1880022e 	bgeu	r3,r2,2011e74 <_ungetc_r+0x110>
 2011e6c:	10ffffc3 	ldbu	r3,-1(r2)
 2011e70:	1c801d26 	beq	r3,r18,2011ee8 <_ungetc_r+0x184>
 2011e74:	81400117 	ldw	r5,4(r16)
 2011e78:	80800e15 	stw	r2,56(r16)
 2011e7c:	008000c4 	movi	r2,3
 2011e80:	80800d15 	stw	r2,52(r16)
 2011e84:	00800044 	movi	r2,1
 2011e88:	81001004 	addi	r4,r16,64
 2011e8c:	80c01084 	addi	r3,r16,66
 2011e90:	80800115 	stw	r2,4(r16)
 2011e94:	9005883a 	mov	r2,r18
 2011e98:	81400f15 	stw	r5,60(r16)
 2011e9c:	81000c15 	stw	r4,48(r16)
 2011ea0:	84801085 	stb	r18,66(r16)
 2011ea4:	80c00015 	stw	r3,0(r16)
 2011ea8:	dfc00317 	ldw	ra,12(sp)
 2011eac:	dc800217 	ldw	r18,8(sp)
 2011eb0:	dc400117 	ldw	r17,4(sp)
 2011eb4:	dc000017 	ldw	r16,0(sp)
 2011eb8:	dec00404 	addi	sp,sp,16
 2011ebc:	f800283a 	ret
 2011ec0:	8809883a 	mov	r4,r17
 2011ec4:	800b883a 	mov	r5,r16
 2011ec8:	200463c0 	call	200463c <_fflush_r>
 2011ecc:	103fdf1e 	bne	r2,zero,2011e4c <_ungetc_r+0xe8>
 2011ed0:	8080030b 	ldhu	r2,12(r16)
 2011ed4:	00fffdc4 	movi	r3,-9
 2011ed8:	80000215 	stw	zero,8(r16)
 2011edc:	1884703a 	and	r2,r3,r2
 2011ee0:	80000615 	stw	zero,24(r16)
 2011ee4:	003fbf06 	br	2011de4 <_ungetc_r+0x80>
 2011ee8:	80c00117 	ldw	r3,4(r16)
 2011eec:	10bfffc4 	addi	r2,r2,-1
 2011ef0:	80800015 	stw	r2,0(r16)
 2011ef4:	18800044 	addi	r2,r3,1
 2011ef8:	80800115 	stw	r2,4(r16)
 2011efc:	003fc806 	br	2011e20 <_ungetc_r+0xbc>

02011f00 <ungetc>:
 2011f00:	00c08174 	movhi	r3,517
 2011f04:	18d03604 	addi	r3,r3,16600
 2011f08:	2005883a 	mov	r2,r4
 2011f0c:	19000017 	ldw	r4,0(r3)
 2011f10:	280d883a 	mov	r6,r5
 2011f14:	100b883a 	mov	r5,r2
 2011f18:	2011d641 	jmpi	2011d64 <_ungetc_r>

02011f1c <_calloc_r>:
 2011f1c:	314b383a 	mul	r5,r6,r5
 2011f20:	defffe04 	addi	sp,sp,-8
 2011f24:	dc000015 	stw	r16,0(sp)
 2011f28:	dfc00115 	stw	ra,4(sp)
 2011f2c:	2005e880 	call	2005e88 <_malloc_r>
 2011f30:	1021883a 	mov	r16,r2
 2011f34:	10000c26 	beq	r2,zero,2011f68 <_calloc_r+0x4c>
 2011f38:	11bfff17 	ldw	r6,-4(r2)
 2011f3c:	00ffff04 	movi	r3,-4
 2011f40:	00800904 	movi	r2,36
 2011f44:	30cc703a 	and	r6,r6,r3
 2011f48:	30cd883a 	add	r6,r6,r3
 2011f4c:	11801436 	bltu	r2,r6,2011fa0 <_calloc_r+0x84>
 2011f50:	00c004c4 	movi	r3,19
 2011f54:	19800936 	bltu	r3,r6,2011f7c <_calloc_r+0x60>
 2011f58:	8005883a 	mov	r2,r16
 2011f5c:	10000015 	stw	zero,0(r2)
 2011f60:	10000115 	stw	zero,4(r2)
 2011f64:	10000215 	stw	zero,8(r2)
 2011f68:	8005883a 	mov	r2,r16
 2011f6c:	dfc00117 	ldw	ra,4(sp)
 2011f70:	dc000017 	ldw	r16,0(sp)
 2011f74:	dec00204 	addi	sp,sp,8
 2011f78:	f800283a 	ret
 2011f7c:	80000015 	stw	zero,0(r16)
 2011f80:	80000115 	stw	zero,4(r16)
 2011f84:	00c006c4 	movi	r3,27
 2011f88:	19800d2e 	bgeu	r3,r6,2011fc0 <_calloc_r+0xa4>
 2011f8c:	80000215 	stw	zero,8(r16)
 2011f90:	80000315 	stw	zero,12(r16)
 2011f94:	30800c26 	beq	r6,r2,2011fc8 <_calloc_r+0xac>
 2011f98:	80800404 	addi	r2,r16,16
 2011f9c:	003fef06 	br	2011f5c <_calloc_r+0x40>
 2011fa0:	8009883a 	mov	r4,r16
 2011fa4:	000b883a 	mov	r5,zero
 2011fa8:	200682c0 	call	200682c <memset>
 2011fac:	8005883a 	mov	r2,r16
 2011fb0:	dfc00117 	ldw	ra,4(sp)
 2011fb4:	dc000017 	ldw	r16,0(sp)
 2011fb8:	dec00204 	addi	sp,sp,8
 2011fbc:	f800283a 	ret
 2011fc0:	80800204 	addi	r2,r16,8
 2011fc4:	003fe506 	br	2011f5c <_calloc_r+0x40>
 2011fc8:	80000415 	stw	zero,16(r16)
 2011fcc:	80000515 	stw	zero,20(r16)
 2011fd0:	80800604 	addi	r2,r16,24
 2011fd4:	003fe106 	br	2011f5c <_calloc_r+0x40>

02011fd8 <rshift>:
 2011fd8:	2805d17a 	srai	r2,r5,5
 2011fdc:	20c00417 	ldw	r3,16(r4)
 2011fe0:	22800504 	addi	r10,r4,20
 2011fe4:	10c0270e 	bge	r2,r3,2012084 <rshift+0xac>
 2011fe8:	19800144 	addi	r6,r3,5
 2011fec:	12c00144 	addi	r11,r2,5
 2011ff0:	318d883a 	add	r6,r6,r6
 2011ff4:	5ad7883a 	add	r11,r11,r11
 2011ff8:	318d883a 	add	r6,r6,r6
 2011ffc:	5ad7883a 	add	r11,r11,r11
 2012000:	294007cc 	andi	r5,r5,31
 2012004:	218d883a 	add	r6,r4,r6
 2012008:	22d7883a 	add	r11,r4,r11
 201200c:	28002026 	beq	r5,zero,2012090 <rshift+0xb8>
 2012010:	59c00017 	ldw	r7,0(r11)
 2012014:	02400804 	movi	r9,32
 2012018:	58800104 	addi	r2,r11,4
 201201c:	4953c83a 	sub	r9,r9,r5
 2012020:	394ed83a 	srl	r7,r7,r5
 2012024:	11802e2e 	bgeu	r2,r6,20120e0 <rshift+0x108>
 2012028:	5007883a 	mov	r3,r10
 201202c:	12000017 	ldw	r8,0(r2)
 2012030:	18c00104 	addi	r3,r3,4
 2012034:	10800104 	addi	r2,r2,4
 2012038:	4250983a 	sll	r8,r8,r9
 201203c:	3a0eb03a 	or	r7,r7,r8
 2012040:	19ffff15 	stw	r7,-4(r3)
 2012044:	11ffff17 	ldw	r7,-4(r2)
 2012048:	394ed83a 	srl	r7,r7,r5
 201204c:	11bff736 	bltu	r2,r6,201202c <rshift+0x54>
 2012050:	32c5c83a 	sub	r2,r6,r11
 2012054:	10bffec4 	addi	r2,r2,-5
 2012058:	1004d0ba 	srli	r2,r2,2
 201205c:	10800184 	addi	r2,r2,6
 2012060:	1085883a 	add	r2,r2,r2
 2012064:	1085883a 	add	r2,r2,r2
 2012068:	2085883a 	add	r2,r4,r2
 201206c:	11c00015 	stw	r7,0(r2)
 2012070:	38001626 	beq	r7,zero,20120cc <rshift+0xf4>
 2012074:	10800104 	addi	r2,r2,4
 2012078:	1295c83a 	sub	r10,r2,r10
 201207c:	5015d0ba 	srai	r10,r10,2
 2012080:	00001406 	br	20120d4 <rshift+0xfc>
 2012084:	20000415 	stw	zero,16(r4)
 2012088:	20000515 	stw	zero,20(r4)
 201208c:	f800283a 	ret
 2012090:	59bffc2e 	bgeu	r11,r6,2012084 <rshift+0xac>
 2012094:	5007883a 	mov	r3,r10
 2012098:	5805883a 	mov	r2,r11
 201209c:	11400017 	ldw	r5,0(r2)
 20120a0:	18c00104 	addi	r3,r3,4
 20120a4:	10800104 	addi	r2,r2,4
 20120a8:	197fff15 	stw	r5,-4(r3)
 20120ac:	11bffb36 	bltu	r2,r6,201209c <rshift+0xc4>
 20120b0:	02c4303a 	nor	r2,zero,r11
 20120b4:	1185883a 	add	r2,r2,r6
 20120b8:	1004d0ba 	srli	r2,r2,2
 20120bc:	10800184 	addi	r2,r2,6
 20120c0:	1085883a 	add	r2,r2,r2
 20120c4:	1085883a 	add	r2,r2,r2
 20120c8:	2085883a 	add	r2,r4,r2
 20120cc:	1295c83a 	sub	r10,r2,r10
 20120d0:	5015d0ba 	srai	r10,r10,2
 20120d4:	22800415 	stw	r10,16(r4)
 20120d8:	503feb26 	beq	r10,zero,2012088 <rshift+0xb0>
 20120dc:	f800283a 	ret
 20120e0:	5005883a 	mov	r2,r10
 20120e4:	003fe106 	br	201206c <rshift+0x94>

020120e8 <__hexdig_init>:
 20120e8:	01408174 	movhi	r5,517
 20120ec:	29781644 	addi	r5,r5,-8103
 20120f0:	01000404 	movi	r4,16
 20120f4:	00c00c04 	movi	r3,48
 20120f8:	00809934 	movhi	r2,612
 20120fc:	10a7a304 	addi	r2,r2,-24948
 2012100:	29800003 	ldbu	r6,0(r5)
 2012104:	10c7883a 	add	r3,r2,r3
 2012108:	19000005 	stb	r4,0(r3)
 201210c:	29400044 	addi	r5,r5,1
 2012110:	3007883a 	mov	r3,r6
 2012114:	21000044 	addi	r4,r4,1
 2012118:	303ff91e 	bne	r6,zero,2012100 <__hexdig_init+0x18>
 201211c:	01408174 	movhi	r5,517
 2012120:	29781444 	addi	r5,r5,-8111
 2012124:	01000684 	movi	r4,26
 2012128:	00c01844 	movi	r3,97
 201212c:	29800003 	ldbu	r6,0(r5)
 2012130:	10c7883a 	add	r3,r2,r3
 2012134:	19000005 	stb	r4,0(r3)
 2012138:	29400044 	addi	r5,r5,1
 201213c:	3007883a 	mov	r3,r6
 2012140:	21000044 	addi	r4,r4,1
 2012144:	303ff91e 	bne	r6,zero,201212c <__hexdig_init+0x44>
 2012148:	01408174 	movhi	r5,517
 201214c:	29781244 	addi	r5,r5,-8119
 2012150:	01000684 	movi	r4,26
 2012154:	00c01044 	movi	r3,65
 2012158:	29800003 	ldbu	r6,0(r5)
 201215c:	10c7883a 	add	r3,r2,r3
 2012160:	19000005 	stb	r4,0(r3)
 2012164:	29400044 	addi	r5,r5,1
 2012168:	3007883a 	mov	r3,r6
 201216c:	21000044 	addi	r4,r4,1
 2012170:	303ff91e 	bne	r6,zero,2012158 <__hexdig_init+0x70>
 2012174:	f800283a 	ret

02012178 <__gethex>:
 2012178:	defff504 	addi	sp,sp,-44
 201217c:	dd800715 	stw	r22,28(sp)
 2012180:	dcc00415 	stw	r19,16(sp)
 2012184:	dc800315 	stw	r18,12(sp)
 2012188:	dc400215 	stw	r17,8(sp)
 201218c:	dfc00a15 	stw	ra,40(sp)
 2012190:	df000915 	stw	fp,36(sp)
 2012194:	ddc00815 	stw	r23,32(sp)
 2012198:	dd400615 	stw	r21,24(sp)
 201219c:	dd000515 	stw	r20,20(sp)
 20121a0:	dc000115 	stw	r16,4(sp)
 20121a4:	05809934 	movhi	r22,612
 20121a8:	b5a7a304 	addi	r22,r22,-24948
 20121ac:	b0800c03 	ldbu	r2,48(r22)
 20121b0:	2025883a 	mov	r18,r4
 20121b4:	3023883a 	mov	r17,r6
 20121b8:	3827883a 	mov	r19,r7
 20121bc:	1000b126 	beq	r2,zero,2012484 <__gethex+0x30c>
 20121c0:	29000017 	ldw	r4,0(r5)
 20121c4:	00800c04 	movi	r2,48
 20121c8:	20c00083 	ldbu	r3,2(r4)
 20121cc:	25000084 	addi	r20,r4,2
 20121d0:	1881521e 	bne	r3,r2,201271c <__gethex+0x5a4>
 20121d4:	01bfff84 	movi	r6,-2
 20121d8:	208000c4 	addi	r2,r4,3
 20121dc:	310dc83a 	sub	r6,r6,r4
 20121e0:	1809883a 	mov	r4,r3
 20121e4:	308f883a 	add	r7,r6,r2
 20121e8:	1029883a 	mov	r20,r2
 20121ec:	10800044 	addi	r2,r2,1
 20121f0:	10ffffc3 	ldbu	r3,-1(r2)
 20121f4:	193ffb26 	beq	r3,r4,20121e4 <__gethex+0x6c>
 20121f8:	b0c5883a 	add	r2,r22,r3
 20121fc:	10800003 	ldbu	r2,0(r2)
 2012200:	01809934 	movhi	r6,612
 2012204:	31a7a304 	addi	r6,r6,-24948
 2012208:	10002a26 	beq	r2,zero,20122b4 <__gethex+0x13c>
 201220c:	a0800003 	ldbu	r2,0(r20)
 2012210:	0009883a 	mov	r4,zero
 2012214:	308d883a 	add	r6,r6,r2
 2012218:	30c00003 	ldbu	r3,0(r6)
 201221c:	18015b26 	beq	r3,zero,201278c <__gethex+0x614>
 2012220:	a021883a 	mov	r16,r20
 2012224:	84000044 	addi	r16,r16,1
 2012228:	80800003 	ldbu	r2,0(r16)
 201222c:	b087883a 	add	r3,r22,r2
 2012230:	18c00003 	ldbu	r3,0(r3)
 2012234:	183ffb1e 	bne	r3,zero,2012224 <__gethex+0xac>
 2012238:	0011883a 	mov	r8,zero
 201223c:	00c00b84 	movi	r3,46
 2012240:	10c0e826 	beq	r2,r3,20125e4 <__gethex+0x46c>
 2012244:	80800003 	ldbu	r2,0(r16)
 2012248:	20013626 	beq	r4,zero,2012724 <__gethex+0x5ac>
 201224c:	8109c83a 	sub	r4,r16,r4
 2012250:	2109883a 	add	r4,r4,r4
 2012254:	2109883a 	add	r4,r4,r4
 2012258:	012fc83a 	sub	r23,zero,r4
 201225c:	00c01404 	movi	r3,80
 2012260:	10c01c26 	beq	r2,r3,20122d4 <__gethex+0x15c>
 2012264:	00c01c04 	movi	r3,112
 2012268:	10c01a26 	beq	r2,r3,20122d4 <__gethex+0x15c>
 201226c:	8005883a 	mov	r2,r16
 2012270:	28800015 	stw	r2,0(r5)
 2012274:	40003926 	beq	r8,zero,201235c <__gethex+0x1e4>
 2012278:	3800fa1e 	bne	r7,zero,2012664 <__gethex+0x4ec>
 201227c:	04000184 	movi	r16,6
 2012280:	8005883a 	mov	r2,r16
 2012284:	dfc00a17 	ldw	ra,40(sp)
 2012288:	df000917 	ldw	fp,36(sp)
 201228c:	ddc00817 	ldw	r23,32(sp)
 2012290:	dd800717 	ldw	r22,28(sp)
 2012294:	dd400617 	ldw	r21,24(sp)
 2012298:	dd000517 	ldw	r20,20(sp)
 201229c:	dcc00417 	ldw	r19,16(sp)
 20122a0:	dc800317 	ldw	r18,12(sp)
 20122a4:	dc400217 	ldw	r17,8(sp)
 20122a8:	dc000117 	ldw	r16,4(sp)
 20122ac:	dec00b04 	addi	sp,sp,44
 20122b0:	f800283a 	ret
 20122b4:	00800b84 	movi	r2,46
 20122b8:	1880cd26 	beq	r3,r2,20125f0 <__gethex+0x478>
 20122bc:	a0800003 	ldbu	r2,0(r20)
 20122c0:	00c01404 	movi	r3,80
 20122c4:	a021883a 	mov	r16,r20
 20122c8:	002f883a 	mov	r23,zero
 20122cc:	02000044 	movi	r8,1
 20122d0:	10ffe41e 	bne	r2,r3,2012264 <__gethex+0xec>
 20122d4:	80c00043 	ldbu	r3,1(r16)
 20122d8:	00800ac4 	movi	r2,43
 20122dc:	1880e726 	beq	r3,r2,201267c <__gethex+0x504>
 20122e0:	00800b44 	movi	r2,45
 20122e4:	1880e126 	beq	r3,r2,201266c <__gethex+0x4f4>
 20122e8:	80800044 	addi	r2,r16,1
 20122ec:	0015883a 	mov	r10,zero
 20122f0:	b0c7883a 	add	r3,r22,r3
 20122f4:	19000003 	ldbu	r4,0(r3)
 20122f8:	203fdc26 	beq	r4,zero,201226c <__gethex+0xf4>
 20122fc:	02400644 	movi	r9,25
 2012300:	493fda16 	blt	r9,r4,201226c <__gethex+0xf4>
 2012304:	10c00043 	ldbu	r3,1(r2)
 2012308:	01809934 	movhi	r6,612
 201230c:	31a7a304 	addi	r6,r6,-24948
 2012310:	213ffc04 	addi	r4,r4,-16
 2012314:	30c7883a 	add	r3,r6,r3
 2012318:	18c00003 	ldbu	r3,0(r3)
 201231c:	10800044 	addi	r2,r2,1
 2012320:	18000926 	beq	r3,zero,2012348 <__gethex+0x1d0>
 2012324:	48c00816 	blt	r9,r3,2012348 <__gethex+0x1d0>
 2012328:	10800044 	addi	r2,r2,1
 201232c:	11800003 	ldbu	r6,0(r2)
 2012330:	210002a4 	muli	r4,r4,10
 2012334:	b18d883a 	add	r6,r22,r6
 2012338:	20c9883a 	add	r4,r4,r3
 201233c:	30c00003 	ldbu	r3,0(r6)
 2012340:	213ffc04 	addi	r4,r4,-16
 2012344:	183ff71e 	bne	r3,zero,2012324 <__gethex+0x1ac>
 2012348:	50000126 	beq	r10,zero,2012350 <__gethex+0x1d8>
 201234c:	0109c83a 	sub	r4,zero,r4
 2012350:	28800015 	stw	r2,0(r5)
 2012354:	b92f883a 	add	r23,r23,r4
 2012358:	403fc71e 	bne	r8,zero,2012278 <__gethex+0x100>
 201235c:	8505c83a 	sub	r2,r16,r20
 2012360:	10bfffc4 	addi	r2,r2,-1
 2012364:	00c001c4 	movi	r3,7
 2012368:	000b883a 	mov	r5,zero
 201236c:	1880030e 	bge	r3,r2,201237c <__gethex+0x204>
 2012370:	1005d07a 	srai	r2,r2,1
 2012374:	29400044 	addi	r5,r5,1
 2012378:	18bffd16 	blt	r3,r2,2012370 <__gethex+0x1f8>
 201237c:	9009883a 	mov	r4,r18
 2012380:	200e6340 	call	200e634 <_Balloc>
 2012384:	1039883a 	mov	fp,r2
 2012388:	15400504 	addi	r21,r2,20
 201238c:	a4001b2e 	bgeu	r20,r16,20123fc <__gethex+0x284>
 2012390:	843fffc4 	addi	r16,r16,-1
 2012394:	a53fffc4 	addi	r20,r20,-1
 2012398:	a805883a 	mov	r2,r21
 201239c:	0009883a 	mov	r4,zero
 20123a0:	0007883a 	mov	r3,zero
 20123a4:	02000b84 	movi	r8,46
 20123a8:	01400804 	movi	r5,32
 20123ac:	00000806 	br	20123d0 <__gethex+0x258>
 20123b0:	18c00104 	addi	r3,r3,4
 20123b4:	b18d883a 	add	r6,r22,r6
 20123b8:	31800003 	ldbu	r6,0(r6)
 20123bc:	318003cc 	andi	r6,r6,15
 20123c0:	31ce983a 	sll	r7,r6,r7
 20123c4:	21c8b03a 	or	r4,r4,r7
 20123c8:	843fffc4 	addi	r16,r16,-1
 20123cc:	85000d26 	beq	r16,r20,2012404 <__gethex+0x28c>
 20123d0:	81800003 	ldbu	r6,0(r16)
 20123d4:	180f883a 	mov	r7,r3
 20123d8:	323ffb26 	beq	r6,r8,20123c8 <__gethex+0x250>
 20123dc:	197ff41e 	bne	r3,r5,20123b0 <__gethex+0x238>
 20123e0:	11000015 	stw	r4,0(r2)
 20123e4:	81800003 	ldbu	r6,0(r16)
 20123e8:	0009883a 	mov	r4,zero
 20123ec:	000f883a 	mov	r7,zero
 20123f0:	10800104 	addi	r2,r2,4
 20123f4:	00c00104 	movi	r3,4
 20123f8:	003fee06 	br	20123b4 <__gethex+0x23c>
 20123fc:	a805883a 	mov	r2,r21
 2012400:	0009883a 	mov	r4,zero
 2012404:	10c00104 	addi	r3,r2,4
 2012408:	1d47c83a 	sub	r3,r3,r21
 201240c:	1807d0ba 	srai	r3,r3,2
 2012410:	11000015 	stw	r4,0(r2)
 2012414:	1820917a 	slli	r16,r3,5
 2012418:	e0c00415 	stw	r3,16(fp)
 201241c:	200e91c0 	call	200e91c <__hi0bits>
 2012420:	8d000017 	ldw	r20,0(r17)
 2012424:	8085c83a 	sub	r2,r16,r2
 2012428:	a0809616 	blt	r20,r2,2012684 <__gethex+0x50c>
 201242c:	1500b116 	blt	r2,r20,20126f4 <__gethex+0x57c>
 2012430:	002d883a 	mov	r22,zero
 2012434:	88c00217 	ldw	r3,8(r17)
 2012438:	1dc06316 	blt	r3,r23,20125c8 <__gethex+0x450>
 201243c:	88800117 	ldw	r2,4(r17)
 2012440:	b8807f0e 	bge	r23,r2,2012640 <__gethex+0x4c8>
 2012444:	15efc83a 	sub	r23,r2,r23
 2012448:	bd001216 	blt	r23,r20,2012494 <__gethex+0x31c>
 201244c:	88c00317 	ldw	r3,12(r17)
 2012450:	01000084 	movi	r4,2
 2012454:	1900c326 	beq	r3,r4,2012764 <__gethex+0x5ec>
 2012458:	010000c4 	movi	r4,3
 201245c:	1900eb26 	beq	r3,r4,201280c <__gethex+0x694>
 2012460:	01000044 	movi	r4,1
 2012464:	1900e126 	beq	r3,r4,20127ec <__gethex+0x674>
 2012468:	9009883a 	mov	r4,r18
 201246c:	e00b883a 	mov	r5,fp
 2012470:	200e6dc0 	call	200e6dc <_Bfree>
 2012474:	d8c00b17 	ldw	r3,44(sp)
 2012478:	04001404 	movi	r16,80
 201247c:	18000015 	stw	zero,0(r3)
 2012480:	003f7f06 	br	2012280 <__gethex+0x108>
 2012484:	d9400015 	stw	r5,0(sp)
 2012488:	20120e80 	call	20120e8 <__hexdig_init>
 201248c:	d9400017 	ldw	r5,0(sp)
 2012490:	003f4b06 	br	20121c0 <__gethex+0x48>
 2012494:	bc3fffc4 	addi	r16,r23,-1
 2012498:	b000a926 	beq	r22,zero,2012740 <__gethex+0x5c8>
 201249c:	05800044 	movi	r22,1
 20124a0:	8005d17a 	srai	r2,r16,5
 20124a4:	00c00044 	movi	r3,1
 20124a8:	840007cc 	andi	r16,r16,31
 20124ac:	1085883a 	add	r2,r2,r2
 20124b0:	1085883a 	add	r2,r2,r2
 20124b4:	a885883a 	add	r2,r21,r2
 20124b8:	1c06983a 	sll	r3,r3,r16
 20124bc:	10800017 	ldw	r2,0(r2)
 20124c0:	1884703a 	and	r2,r3,r2
 20124c4:	10000126 	beq	r2,zero,20124cc <__gethex+0x354>
 20124c8:	b5800094 	ori	r22,r22,2
 20124cc:	b80b883a 	mov	r5,r23
 20124d0:	e009883a 	mov	r4,fp
 20124d4:	2011fd80 	call	2011fd8 <rshift>
 20124d8:	a5e9c83a 	sub	r20,r20,r23
 20124dc:	8dc00117 	ldw	r23,4(r17)
 20124e0:	04000084 	movi	r16,2
 20124e4:	b0005b26 	beq	r22,zero,2012654 <__gethex+0x4dc>
 20124e8:	88800317 	ldw	r2,12(r17)
 20124ec:	00c00084 	movi	r3,2
 20124f0:	10c0ad26 	beq	r2,r3,20127a8 <__gethex+0x630>
 20124f4:	00c000c4 	movi	r3,3
 20124f8:	10c05326 	beq	r2,r3,2012648 <__gethex+0x4d0>
 20124fc:	00c00044 	movi	r3,1
 2012500:	10c0531e 	bne	r2,r3,2012650 <__gethex+0x4d8>
 2012504:	b080008c 	andi	r2,r22,2
 2012508:	10005126 	beq	r2,zero,2012650 <__gethex+0x4d8>
 201250c:	a8800017 	ldw	r2,0(r21)
 2012510:	b084b03a 	or	r2,r22,r2
 2012514:	10c4703a 	and	r2,r2,r3
 2012518:	10004d26 	beq	r2,zero,2012650 <__gethex+0x4d8>
 201251c:	e5800417 	ldw	r22,16(fp)
 2012520:	00ffffc4 	movi	r3,-1
 2012524:	b1000144 	addi	r4,r22,5
 2012528:	2109883a 	add	r4,r4,r4
 201252c:	2109883a 	add	r4,r4,r4
 2012530:	e109883a 	add	r4,fp,r4
 2012534:	a8800017 	ldw	r2,0(r21)
 2012538:	10c0b71e 	bne	r2,r3,2012818 <__gethex+0x6a0>
 201253c:	a8000015 	stw	zero,0(r21)
 2012540:	ad400104 	addi	r21,r21,4
 2012544:	a93ffb36 	bltu	r21,r4,2012534 <__gethex+0x3bc>
 2012548:	e0800217 	ldw	r2,8(fp)
 201254c:	b080ba0e 	bge	r22,r2,2012838 <__gethex+0x6c0>
 2012550:	b005883a 	mov	r2,r22
 2012554:	10c00144 	addi	r3,r2,5
 2012558:	18c7883a 	add	r3,r3,r3
 201255c:	18c7883a 	add	r3,r3,r3
 2012560:	e0c7883a 	add	r3,fp,r3
 2012564:	10800044 	addi	r2,r2,1
 2012568:	01000044 	movi	r4,1
 201256c:	19000015 	stw	r4,0(r3)
 2012570:	e0800415 	stw	r2,16(fp)
 2012574:	00800084 	movi	r2,2
 2012578:	8080aa26 	beq	r16,r2,2012824 <__gethex+0x6ac>
 201257c:	e0800417 	ldw	r2,16(fp)
 2012580:	b0800b16 	blt	r22,r2,20125b0 <__gethex+0x438>
 2012584:	a50007cc 	andi	r20,r20,31
 2012588:	a0008326 	beq	r20,zero,2012798 <__gethex+0x620>
 201258c:	b5800104 	addi	r22,r22,4
 2012590:	b5ad883a 	add	r22,r22,r22
 2012594:	b5ad883a 	add	r22,r22,r22
 2012598:	e585883a 	add	r2,fp,r22
 201259c:	11000017 	ldw	r4,0(r2)
 20125a0:	200e91c0 	call	200e91c <__hi0bits>
 20125a4:	00c00804 	movi	r3,32
 20125a8:	1d29c83a 	sub	r20,r3,r20
 20125ac:	15007a0e 	bge	r2,r20,2012798 <__gethex+0x620>
 20125b0:	e009883a 	mov	r4,fp
 20125b4:	01400044 	movi	r5,1
 20125b8:	2011fd80 	call	2011fd8 <rshift>
 20125bc:	88800217 	ldw	r2,8(r17)
 20125c0:	bdc00044 	addi	r23,r23,1
 20125c4:	15c0740e 	bge	r2,r23,2012798 <__gethex+0x620>
 20125c8:	9009883a 	mov	r4,r18
 20125cc:	e00b883a 	mov	r5,fp
 20125d0:	200e6dc0 	call	200e6dc <_Bfree>
 20125d4:	d8800b17 	ldw	r2,44(sp)
 20125d8:	040028c4 	movi	r16,163
 20125dc:	10000015 	stw	zero,0(r2)
 20125e0:	003f2706 	br	2012280 <__gethex+0x108>
 20125e4:	20007526 	beq	r4,zero,20127bc <__gethex+0x644>
 20125e8:	80800003 	ldbu	r2,0(r16)
 20125ec:	003f1706 	br	201224c <__gethex+0xd4>
 20125f0:	a0800043 	ldbu	r2,1(r20)
 20125f4:	a4000044 	addi	r16,r20,1
 20125f8:	308d883a 	add	r6,r6,r2
 20125fc:	30c00003 	ldbu	r3,0(r6)
 2012600:	18004c26 	beq	r3,zero,2012734 <__gethex+0x5bc>
 2012604:	00c00c04 	movi	r3,48
 2012608:	8029883a 	mov	r20,r16
 201260c:	10c0521e 	bne	r2,r3,2012758 <__gethex+0x5e0>
 2012610:	1007883a 	mov	r3,r2
 2012614:	a5000044 	addi	r20,r20,1
 2012618:	a0800003 	ldbu	r2,0(r20)
 201261c:	10fffd26 	beq	r2,r3,2012614 <__gethex+0x49c>
 2012620:	b087883a 	add	r3,r22,r2
 2012624:	18c00003 	ldbu	r3,0(r3)
 2012628:	18004b1e 	bne	r3,zero,2012758 <__gethex+0x5e0>
 201262c:	02000044 	movi	r8,1
 2012630:	8009883a 	mov	r4,r16
 2012634:	400f883a 	mov	r7,r8
 2012638:	a021883a 	mov	r16,r20
 201263c:	003eff06 	br	201223c <__gethex+0xc4>
 2012640:	04000044 	movi	r16,1
 2012644:	003fa706 	br	20124e4 <__gethex+0x36c>
 2012648:	d8800c17 	ldw	r2,48(sp)
 201264c:	103fb31e 	bne	r2,zero,201251c <__gethex+0x3a4>
 2012650:	84000414 	ori	r16,r16,16
 2012654:	d8800b17 	ldw	r2,44(sp)
 2012658:	17000015 	stw	fp,0(r2)
 201265c:	9dc00015 	stw	r23,0(r19)
 2012660:	003f0706 	br	2012280 <__gethex+0x108>
 2012664:	0021883a 	mov	r16,zero
 2012668:	003f0506 	br	2012280 <__gethex+0x108>
 201266c:	02800044 	movi	r10,1
 2012670:	80c00083 	ldbu	r3,2(r16)
 2012674:	80800084 	addi	r2,r16,2
 2012678:	003f1d06 	br	20122f0 <__gethex+0x178>
 201267c:	0015883a 	mov	r10,zero
 2012680:	003ffb06 	br	2012670 <__gethex+0x4f8>
 2012684:	1521c83a 	sub	r16,r2,r20
 2012688:	e009883a 	mov	r4,fp
 201268c:	800b883a 	mov	r5,r16
 2012690:	200f5580 	call	200f558 <__any_on>
 2012694:	10002526 	beq	r2,zero,201272c <__gethex+0x5b4>
 2012698:	80bfffc4 	addi	r2,r16,-1
 201269c:	1007d17a 	srai	r3,r2,5
 20126a0:	110007cc 	andi	r4,r2,31
 20126a4:	05800044 	movi	r22,1
 20126a8:	18c00144 	addi	r3,r3,5
 20126ac:	18c7883a 	add	r3,r3,r3
 20126b0:	18c7883a 	add	r3,r3,r3
 20126b4:	e0c7883a 	add	r3,fp,r3
 20126b8:	b108983a 	sll	r4,r22,r4
 20126bc:	18c00017 	ldw	r3,0(r3)
 20126c0:	20c6703a 	and	r3,r4,r3
 20126c4:	18000626 	beq	r3,zero,20126e0 <__gethex+0x568>
 20126c8:	b080350e 	bge	r22,r2,20127a0 <__gethex+0x628>
 20126cc:	e009883a 	mov	r4,fp
 20126d0:	817fff84 	addi	r5,r16,-2
 20126d4:	200f5580 	call	200f558 <__any_on>
 20126d8:	10003126 	beq	r2,zero,20127a0 <__gethex+0x628>
 20126dc:	058000c4 	movi	r22,3
 20126e0:	e009883a 	mov	r4,fp
 20126e4:	800b883a 	mov	r5,r16
 20126e8:	2011fd80 	call	2011fd8 <rshift>
 20126ec:	bc2f883a 	add	r23,r23,r16
 20126f0:	003f5006 	br	2012434 <__gethex+0x2bc>
 20126f4:	a0a1c83a 	sub	r16,r20,r2
 20126f8:	e00b883a 	mov	r5,fp
 20126fc:	9009883a 	mov	r4,r18
 2012700:	800d883a 	mov	r6,r16
 2012704:	200ed7c0 	call	200ed7c <__lshift>
 2012708:	1039883a 	mov	fp,r2
 201270c:	bc2fc83a 	sub	r23,r23,r16
 2012710:	15400504 	addi	r21,r2,20
 2012714:	002d883a 	mov	r22,zero
 2012718:	003f4606 	br	2012434 <__gethex+0x2bc>
 201271c:	000f883a 	mov	r7,zero
 2012720:	003eb506 	br	20121f8 <__gethex+0x80>
 2012724:	002f883a 	mov	r23,zero
 2012728:	003ecc06 	br	201225c <__gethex+0xe4>
 201272c:	002d883a 	mov	r22,zero
 2012730:	003feb06 	br	20126e0 <__gethex+0x568>
 2012734:	002f883a 	mov	r23,zero
 2012738:	02000044 	movi	r8,1
 201273c:	003ec706 	br	201225c <__gethex+0xe4>
 2012740:	043f570e 	bge	zero,r16,20124a0 <__gethex+0x328>
 2012744:	e009883a 	mov	r4,fp
 2012748:	800b883a 	mov	r5,r16
 201274c:	200f5580 	call	200f558 <__any_on>
 2012750:	102d883a 	mov	r22,r2
 2012754:	003f5206 	br	20124a0 <__gethex+0x328>
 2012758:	8009883a 	mov	r4,r16
 201275c:	01c00044 	movi	r7,1
 2012760:	003eaf06 	br	2012220 <__gethex+0xa8>
 2012764:	d8c00c17 	ldw	r3,48(sp)
 2012768:	183f3f1e 	bne	r3,zero,2012468 <__gethex+0x2f0>
 201276c:	98800015 	stw	r2,0(r19)
 2012770:	00800044 	movi	r2,1
 2012774:	e0800415 	stw	r2,16(fp)
 2012778:	a8800015 	stw	r2,0(r21)
 201277c:	d8800b17 	ldw	r2,44(sp)
 2012780:	04001884 	movi	r16,98
 2012784:	17000015 	stw	fp,0(r2)
 2012788:	003ebd06 	br	2012280 <__gethex+0x108>
 201278c:	a021883a 	mov	r16,r20
 2012790:	0011883a 	mov	r8,zero
 2012794:	003ea906 	br	201223c <__gethex+0xc4>
 2012798:	04000844 	movi	r16,33
 201279c:	003fad06 	br	2012654 <__gethex+0x4dc>
 20127a0:	05800084 	movi	r22,2
 20127a4:	003fce06 	br	20126e0 <__gethex+0x568>
 20127a8:	d8c00c17 	ldw	r3,48(sp)
 20127ac:	00800044 	movi	r2,1
 20127b0:	10c5c83a 	sub	r2,r2,r3
 20127b4:	103fa626 	beq	r2,zero,2012650 <__gethex+0x4d8>
 20127b8:	003f5806 	br	201251c <__gethex+0x3a4>
 20127bc:	80800043 	ldbu	r2,1(r16)
 20127c0:	81000044 	addi	r4,r16,1
 20127c4:	2021883a 	mov	r16,r4
 20127c8:	b087883a 	add	r3,r22,r2
 20127cc:	18c00003 	ldbu	r3,0(r3)
 20127d0:	183e9d26 	beq	r3,zero,2012248 <__gethex+0xd0>
 20127d4:	84000044 	addi	r16,r16,1
 20127d8:	80800003 	ldbu	r2,0(r16)
 20127dc:	b087883a 	add	r3,r22,r2
 20127e0:	18c00003 	ldbu	r3,0(r3)
 20127e4:	183ffb1e 	bne	r3,zero,20127d4 <__gethex+0x65c>
 20127e8:	003e9706 	br	2012248 <__gethex+0xd0>
 20127ec:	bd3f1e1e 	bne	r23,r20,2012468 <__gethex+0x2f0>
 20127f0:	1d3fde0e 	bge	r3,r20,201276c <__gethex+0x5f4>
 20127f4:	e009883a 	mov	r4,fp
 20127f8:	a17fffc4 	addi	r5,r20,-1
 20127fc:	200f5580 	call	200f558 <__any_on>
 2012800:	103f1926 	beq	r2,zero,2012468 <__gethex+0x2f0>
 2012804:	88800117 	ldw	r2,4(r17)
 2012808:	003fd806 	br	201276c <__gethex+0x5f4>
 201280c:	d8c00c17 	ldw	r3,48(sp)
 2012810:	183f1526 	beq	r3,zero,2012468 <__gethex+0x2f0>
 2012814:	003fd506 	br	201276c <__gethex+0x5f4>
 2012818:	10800044 	addi	r2,r2,1
 201281c:	a8800015 	stw	r2,0(r21)
 2012820:	003f5406 	br	2012574 <__gethex+0x3fc>
 2012824:	88800017 	ldw	r2,0(r17)
 2012828:	10bfffc4 	addi	r2,r2,-1
 201282c:	15001426 	beq	r2,r20,2012880 <__gethex+0x708>
 2012830:	04000884 	movi	r16,34
 2012834:	003f8706 	br	2012654 <__gethex+0x4dc>
 2012838:	e1400117 	ldw	r5,4(fp)
 201283c:	9009883a 	mov	r4,r18
 2012840:	29400044 	addi	r5,r5,1
 2012844:	200e6340 	call	200e634 <_Balloc>
 2012848:	e1800417 	ldw	r6,16(fp)
 201284c:	e1400304 	addi	r5,fp,12
 2012850:	11000304 	addi	r4,r2,12
 2012854:	31800084 	addi	r6,r6,2
 2012858:	318d883a 	add	r6,r6,r6
 201285c:	318d883a 	add	r6,r6,r6
 2012860:	102b883a 	mov	r21,r2
 2012864:	200660c0 	call	200660c <memcpy>
 2012868:	e00b883a 	mov	r5,fp
 201286c:	9009883a 	mov	r4,r18
 2012870:	200e6dc0 	call	200e6dc <_Bfree>
 2012874:	a839883a 	mov	fp,r21
 2012878:	a8800417 	ldw	r2,16(r21)
 201287c:	003f3506 	br	2012554 <__gethex+0x3dc>
 2012880:	a005d17a 	srai	r2,r20,5
 2012884:	04000044 	movi	r16,1
 2012888:	a50007cc 	andi	r20,r20,31
 201288c:	10800144 	addi	r2,r2,5
 2012890:	1085883a 	add	r2,r2,r2
 2012894:	1085883a 	add	r2,r2,r2
 2012898:	e085883a 	add	r2,fp,r2
 201289c:	10800017 	ldw	r2,0(r2)
 20128a0:	8520983a 	sll	r16,r16,r20
 20128a4:	80a0703a 	and	r16,r16,r2
 20128a8:	8020c03a 	cmpne	r16,r16,zero
 20128ac:	00800884 	movi	r2,34
 20128b0:	1421c83a 	sub	r16,r2,r16
 20128b4:	003f6706 	br	2012654 <__gethex+0x4dc>

020128b8 <__hexnan>:
 20128b8:	defff604 	addi	sp,sp,-40
 20128bc:	dc000315 	stw	r16,12(sp)
 20128c0:	04009934 	movhi	r16,612
 20128c4:	8427a304 	addi	r16,r16,-24948
 20128c8:	80800c03 	ldbu	r2,48(r16)
 20128cc:	dfc00915 	stw	ra,36(sp)
 20128d0:	dd400815 	stw	r21,32(sp)
 20128d4:	dd000715 	stw	r20,28(sp)
 20128d8:	dcc00615 	stw	r19,24(sp)
 20128dc:	dc800515 	stw	r18,20(sp)
 20128e0:	dc400415 	stw	r17,16(sp)
 20128e4:	10006c26 	beq	r2,zero,2012a98 <__hexnan+0x1e0>
 20128e8:	2d000017 	ldw	r20,0(r5)
 20128ec:	a025d17a 	srai	r18,r20,5
 20128f0:	a50007cc 	andi	r20,r20,31
 20128f4:	94a5883a 	add	r18,r18,r18
 20128f8:	94a5883a 	add	r18,r18,r18
 20128fc:	34a5883a 	add	r18,r6,r18
 2012900:	a0000126 	beq	r20,zero,2012908 <__hexnan+0x50>
 2012904:	94800104 	addi	r18,r18,4
 2012908:	20c00017 	ldw	r3,0(r4)
 201290c:	903fff15 	stw	zero,-4(r18)
 2012910:	947fff04 	addi	r17,r18,-4
 2012914:	18800043 	ldbu	r2,1(r3)
 2012918:	8817883a 	mov	r11,r17
 201291c:	880b883a 	mov	r5,r17
 2012920:	0011883a 	mov	r8,zero
 2012924:	001b883a 	mov	r13,zero
 2012928:	0015883a 	mov	r10,zero
 201292c:	03c00204 	movi	r15,8
 2012930:	03800804 	movi	r14,32
 2012934:	04c001c4 	movi	r19,7
 2012938:	10001b26 	beq	r2,zero,20129a8 <__hexnan+0xf0>
 201293c:	808f883a 	add	r7,r16,r2
 2012940:	39c00003 	ldbu	r7,0(r7)
 2012944:	3a403fcc 	andi	r9,r7,255
 2012948:	4800301e 	bne	r9,zero,2012a0c <__hexnan+0x154>
 201294c:	70804636 	bltu	r14,r2,2012a68 <__hexnan+0x1b0>
 2012950:	6a80120e 	bge	r13,r10,201299c <__hexnan+0xe4>
 2012954:	2ac00f2e 	bgeu	r5,r11,2012994 <__hexnan+0xdc>
 2012958:	9a000e16 	blt	r19,r8,2012994 <__hexnan+0xdc>
 201295c:	7a11c83a 	sub	r8,r15,r8
 2012960:	4211883a 	add	r8,r8,r8
 2012964:	29c00017 	ldw	r7,0(r5)
 2012968:	4211883a 	add	r8,r8,r8
 201296c:	722bc83a 	sub	r21,r14,r8
 2012970:	2805883a 	mov	r2,r5
 2012974:	12400117 	ldw	r9,4(r2)
 2012978:	10800104 	addi	r2,r2,4
 201297c:	4d58983a 	sll	r12,r9,r21
 2012980:	3b18b03a 	or	r12,r7,r12
 2012984:	4a0ed83a 	srl	r7,r9,r8
 2012988:	133fff15 	stw	r12,-4(r2)
 201298c:	11c00015 	stw	r7,0(r2)
 2012990:	12fff836 	bltu	r2,r11,2012974 <__hexnan+0xbc>
 2012994:	31402d36 	bltu	r6,r5,2012a4c <__hexnan+0x194>
 2012998:	02000204 	movi	r8,8
 201299c:	18c00044 	addi	r3,r3,1
 20129a0:	18800043 	ldbu	r2,1(r3)
 20129a4:	103fe51e 	bne	r2,zero,201293c <__hexnan+0x84>
 20129a8:	50003126 	beq	r10,zero,2012a70 <__hexnan+0x1b8>
 20129ac:	2ac0022e 	bgeu	r5,r11,20129b8 <__hexnan+0x100>
 20129b0:	008001c4 	movi	r2,7
 20129b4:	1200520e 	bge	r2,r8,2012b00 <__hexnan+0x248>
 20129b8:	31403f2e 	bgeu	r6,r5,2012ab8 <__hexnan+0x200>
 20129bc:	3005883a 	mov	r2,r6
 20129c0:	28c00017 	ldw	r3,0(r5)
 20129c4:	10800104 	addi	r2,r2,4
 20129c8:	29400104 	addi	r5,r5,4
 20129cc:	10ffff15 	stw	r3,-4(r2)
 20129d0:	897ffb2e 	bgeu	r17,r5,20129c0 <__hexnan+0x108>
 20129d4:	10000015 	stw	zero,0(r2)
 20129d8:	10800104 	addi	r2,r2,4
 20129dc:	88bffd2e 	bgeu	r17,r2,20129d4 <__hexnan+0x11c>
 20129e0:	90bfff17 	ldw	r2,-4(r18)
 20129e4:	1000071e 	bne	r2,zero,2012a04 <__hexnan+0x14c>
 20129e8:	34403c26 	beq	r6,r17,2012adc <__hexnan+0x224>
 20129ec:	8805883a 	mov	r2,r17
 20129f0:	00000106 	br	20129f8 <__hexnan+0x140>
 20129f4:	30803a26 	beq	r6,r2,2012ae0 <__hexnan+0x228>
 20129f8:	10bfff04 	addi	r2,r2,-4
 20129fc:	10c00017 	ldw	r3,0(r2)
 2012a00:	183ffc26 	beq	r3,zero,20129f4 <__hexnan+0x13c>
 2012a04:	00800144 	movi	r2,5
 2012a08:	00001a06 	br	2012a74 <__hexnan+0x1bc>
 2012a0c:	42000044 	addi	r8,r8,1
 2012a10:	52800044 	addi	r10,r10,1
 2012a14:	7a000716 	blt	r15,r8,2012a34 <__hexnan+0x17c>
 2012a18:	28800017 	ldw	r2,0(r5)
 2012a1c:	1004913a 	slli	r2,r2,4
 2012a20:	39c003cc 	andi	r7,r7,15
 2012a24:	11ceb03a 	or	r7,r2,r7
 2012a28:	29c00015 	stw	r7,0(r5)
 2012a2c:	18c00044 	addi	r3,r3,1
 2012a30:	003fdb06 	br	20129a0 <__hexnan+0xe8>
 2012a34:	317fd92e 	bgeu	r6,r5,201299c <__hexnan+0xe4>
 2012a38:	283fff15 	stw	zero,-4(r5)
 2012a3c:	0005883a 	mov	r2,zero
 2012a40:	297fff04 	addi	r5,r5,-4
 2012a44:	02000044 	movi	r8,1
 2012a48:	003ff506 	br	2012a20 <__hexnan+0x168>
 2012a4c:	283fff15 	stw	zero,-4(r5)
 2012a50:	297fff04 	addi	r5,r5,-4
 2012a54:	501b883a 	mov	r13,r10
 2012a58:	2817883a 	mov	r11,r5
 2012a5c:	0011883a 	mov	r8,zero
 2012a60:	18c00044 	addi	r3,r3,1
 2012a64:	003fce06 	br	20129a0 <__hexnan+0xe8>
 2012a68:	01c00a44 	movi	r7,41
 2012a6c:	11c02026 	beq	r2,r7,2012af0 <__hexnan+0x238>
 2012a70:	00800104 	movi	r2,4
 2012a74:	dfc00917 	ldw	ra,36(sp)
 2012a78:	dd400817 	ldw	r21,32(sp)
 2012a7c:	dd000717 	ldw	r20,28(sp)
 2012a80:	dcc00617 	ldw	r19,24(sp)
 2012a84:	dc800517 	ldw	r18,20(sp)
 2012a88:	dc400417 	ldw	r17,16(sp)
 2012a8c:	dc000317 	ldw	r16,12(sp)
 2012a90:	dec00a04 	addi	sp,sp,40
 2012a94:	f800283a 	ret
 2012a98:	d9000015 	stw	r4,0(sp)
 2012a9c:	d9400115 	stw	r5,4(sp)
 2012aa0:	d9800215 	stw	r6,8(sp)
 2012aa4:	20120e80 	call	20120e8 <__hexdig_init>
 2012aa8:	d9800217 	ldw	r6,8(sp)
 2012aac:	d9400117 	ldw	r5,4(sp)
 2012ab0:	d9000017 	ldw	r4,0(sp)
 2012ab4:	003f8c06 	br	20128e8 <__hexnan+0x30>
 2012ab8:	a03fc926 	beq	r20,zero,20129e0 <__hexnan+0x128>
 2012abc:	00800804 	movi	r2,32
 2012ac0:	1529c83a 	sub	r20,r2,r20
 2012ac4:	00ffffc4 	movi	r3,-1
 2012ac8:	90bfff17 	ldw	r2,-4(r18)
 2012acc:	1d06d83a 	srl	r3,r3,r20
 2012ad0:	1884703a 	and	r2,r3,r2
 2012ad4:	90bfff15 	stw	r2,-4(r18)
 2012ad8:	003fc206 	br	20129e4 <__hexnan+0x12c>
 2012adc:	3005883a 	mov	r2,r6
 2012ae0:	00c00044 	movi	r3,1
 2012ae4:	10c00015 	stw	r3,0(r2)
 2012ae8:	00800144 	movi	r2,5
 2012aec:	003fe106 	br	2012a74 <__hexnan+0x1bc>
 2012af0:	503fdf26 	beq	r10,zero,2012a70 <__hexnan+0x1b8>
 2012af4:	18c00084 	addi	r3,r3,2
 2012af8:	20c00015 	stw	r3,0(r4)
 2012afc:	003fab06 	br	20129ac <__hexnan+0xf4>
 2012b00:	00800204 	movi	r2,8
 2012b04:	1211c83a 	sub	r8,r2,r8
 2012b08:	4211883a 	add	r8,r8,r8
 2012b0c:	28c00017 	ldw	r3,0(r5)
 2012b10:	4211883a 	add	r8,r8,r8
 2012b14:	02400804 	movi	r9,32
 2012b18:	4a13c83a 	sub	r9,r9,r8
 2012b1c:	2805883a 	mov	r2,r5
 2012b20:	11000117 	ldw	r4,4(r2)
 2012b24:	10800104 	addi	r2,r2,4
 2012b28:	224e983a 	sll	r7,r4,r9
 2012b2c:	19ceb03a 	or	r7,r3,r7
 2012b30:	2206d83a 	srl	r3,r4,r8
 2012b34:	11ffff15 	stw	r7,-4(r2)
 2012b38:	10c00015 	stw	r3,0(r2)
 2012b3c:	12fff836 	bltu	r2,r11,2012b20 <__hexnan+0x268>
 2012b40:	003f9d06 	br	20129b8 <__hexnan+0x100>

02012b44 <__muldi3>:
 2012b44:	20bfffcc 	andi	r2,r4,65535
 2012b48:	2010d43a 	srli	r8,r4,16
 2012b4c:	30ffffcc 	andi	r3,r6,65535
 2012b50:	3014d43a 	srli	r10,r6,16
 2012b54:	1893383a 	mul	r9,r3,r2
 2012b58:	1a07383a 	mul	r3,r3,r8
 2012b5c:	5085383a 	mul	r2,r10,r2
 2012b60:	4816d43a 	srli	r11,r9,16
 2012b64:	5211383a 	mul	r8,r10,r8
 2012b68:	1885883a 	add	r2,r3,r2
 2012b6c:	12c5883a 	add	r2,r2,r11
 2012b70:	10c0022e 	bgeu	r2,r3,2012b7c <__muldi3+0x38>
 2012b74:	00c00074 	movhi	r3,1
 2012b78:	40d1883a 	add	r8,r8,r3
 2012b7c:	1014d43a 	srli	r10,r2,16
 2012b80:	21c9383a 	mul	r4,r4,r7
 2012b84:	314d383a 	mul	r6,r6,r5
 2012b88:	1004943a 	slli	r2,r2,16
 2012b8c:	4291883a 	add	r8,r8,r10
 2012b90:	4a7fffcc 	andi	r9,r9,65535
 2012b94:	2187883a 	add	r3,r4,r6
 2012b98:	1245883a 	add	r2,r2,r9
 2012b9c:	1a07883a 	add	r3,r3,r8
 2012ba0:	f800283a 	ret

02012ba4 <__fixunsdfsi>:
 2012ba4:	defffd04 	addi	sp,sp,-12
 2012ba8:	000d883a 	mov	r6,zero
 2012bac:	01d07834 	movhi	r7,16864
 2012bb0:	dc400115 	stw	r17,4(sp)
 2012bb4:	dc000015 	stw	r16,0(sp)
 2012bb8:	dfc00215 	stw	ra,8(sp)
 2012bbc:	2023883a 	mov	r17,r4
 2012bc0:	2821883a 	mov	r16,r5
 2012bc4:	201423c0 	call	201423c <__gedf2>
 2012bc8:	1000080e 	bge	r2,zero,2012bec <__fixunsdfsi+0x48>
 2012bcc:	8809883a 	mov	r4,r17
 2012bd0:	800b883a 	mov	r5,r16
 2012bd4:	201442c0 	call	201442c <__fixdfsi>
 2012bd8:	dfc00217 	ldw	ra,8(sp)
 2012bdc:	dc400117 	ldw	r17,4(sp)
 2012be0:	dc000017 	ldw	r16,0(sp)
 2012be4:	dec00304 	addi	sp,sp,12
 2012be8:	f800283a 	ret
 2012bec:	000d883a 	mov	r6,zero
 2012bf0:	01d07834 	movhi	r7,16864
 2012bf4:	8809883a 	mov	r4,r17
 2012bf8:	800b883a 	mov	r5,r16
 2012bfc:	2013c280 	call	2013c28 <__subdf3>
 2012c00:	180b883a 	mov	r5,r3
 2012c04:	1009883a 	mov	r4,r2
 2012c08:	201442c0 	call	201442c <__fixdfsi>
 2012c0c:	00e00034 	movhi	r3,32768
 2012c10:	10c5883a 	add	r2,r2,r3
 2012c14:	dfc00217 	ldw	ra,8(sp)
 2012c18:	dc400117 	ldw	r17,4(sp)
 2012c1c:	dc000017 	ldw	r16,0(sp)
 2012c20:	dec00304 	addi	sp,sp,12
 2012c24:	f800283a 	ret

02012c28 <__udivdi3>:
 2012c28:	defff504 	addi	sp,sp,-44
 2012c2c:	dd000515 	stw	r20,20(sp)
 2012c30:	dcc00415 	stw	r19,16(sp)
 2012c34:	dc800315 	stw	r18,12(sp)
 2012c38:	dc400215 	stw	r17,8(sp)
 2012c3c:	dc000115 	stw	r16,4(sp)
 2012c40:	dfc00a15 	stw	ra,40(sp)
 2012c44:	df000915 	stw	fp,36(sp)
 2012c48:	ddc00815 	stw	r23,32(sp)
 2012c4c:	dd800715 	stw	r22,28(sp)
 2012c50:	dd400615 	stw	r21,24(sp)
 2012c54:	2025883a 	mov	r18,r4
 2012c58:	2823883a 	mov	r17,r5
 2012c5c:	3021883a 	mov	r16,r6
 2012c60:	2027883a 	mov	r19,r4
 2012c64:	2829883a 	mov	r20,r5
 2012c68:	3800401e 	bne	r7,zero,2012d6c <__udivdi3+0x144>
 2012c6c:	2980602e 	bgeu	r5,r6,2012df0 <__udivdi3+0x1c8>
 2012c70:	00bfffd4 	movui	r2,65535
 2012c74:	1180aa36 	bltu	r2,r6,2012f20 <__udivdi3+0x2f8>
 2012c78:	00803fc4 	movi	r2,255
 2012c7c:	11814436 	bltu	r2,r6,2013190 <__udivdi3+0x568>
 2012c80:	0005883a 	mov	r2,zero
 2012c84:	0007883a 	mov	r3,zero
 2012c88:	3084d83a 	srl	r2,r6,r2
 2012c8c:	01008174 	movhi	r4,517
 2012c90:	21381e04 	addi	r4,r4,-8072
 2012c94:	2085883a 	add	r2,r4,r2
 2012c98:	10800003 	ldbu	r2,0(r2)
 2012c9c:	10c7883a 	add	r3,r2,r3
 2012ca0:	00800804 	movi	r2,32
 2012ca4:	10c5c83a 	sub	r2,r2,r3
 2012ca8:	10000526 	beq	r2,zero,2012cc0 <__udivdi3+0x98>
 2012cac:	88a2983a 	sll	r17,r17,r2
 2012cb0:	90c6d83a 	srl	r3,r18,r3
 2012cb4:	30a0983a 	sll	r16,r6,r2
 2012cb8:	90a6983a 	sll	r19,r18,r2
 2012cbc:	88e8b03a 	or	r20,r17,r3
 2012cc0:	8022d43a 	srli	r17,r16,16
 2012cc4:	a009883a 	mov	r4,r20
 2012cc8:	857fffcc 	andi	r21,r16,65535
 2012ccc:	880b883a 	mov	r5,r17
 2012cd0:	20147a40 	call	20147a4 <__umodsi3>
 2012cd4:	a009883a 	mov	r4,r20
 2012cd8:	880b883a 	mov	r5,r17
 2012cdc:	102d883a 	mov	r22,r2
 2012ce0:	201479c0 	call	201479c <__udivsi3>
 2012ce4:	b02c943a 	slli	r22,r22,16
 2012ce8:	9806d43a 	srli	r3,r19,16
 2012cec:	1549383a 	mul	r4,r2,r21
 2012cf0:	1025883a 	mov	r18,r2
 2012cf4:	b0c6b03a 	or	r3,r22,r3
 2012cf8:	1900052e 	bgeu	r3,r4,2012d10 <__udivdi3+0xe8>
 2012cfc:	1c07883a 	add	r3,r3,r16
 2012d00:	10bfffc4 	addi	r2,r2,-1
 2012d04:	1c000136 	bltu	r3,r16,2012d0c <__udivdi3+0xe4>
 2012d08:	19013636 	bltu	r3,r4,20131e4 <__udivdi3+0x5bc>
 2012d0c:	1025883a 	mov	r18,r2
 2012d10:	1929c83a 	sub	r20,r3,r4
 2012d14:	a009883a 	mov	r4,r20
 2012d18:	880b883a 	mov	r5,r17
 2012d1c:	20147a40 	call	20147a4 <__umodsi3>
 2012d20:	102d883a 	mov	r22,r2
 2012d24:	a009883a 	mov	r4,r20
 2012d28:	880b883a 	mov	r5,r17
 2012d2c:	201479c0 	call	201479c <__udivsi3>
 2012d30:	b02c943a 	slli	r22,r22,16
 2012d34:	156b383a 	mul	r21,r2,r21
 2012d38:	9cffffcc 	andi	r19,r19,65535
 2012d3c:	b4e6b03a 	or	r19,r22,r19
 2012d40:	1009883a 	mov	r4,r2
 2012d44:	9d40052e 	bgeu	r19,r21,2012d5c <__udivdi3+0x134>
 2012d48:	9c27883a 	add	r19,r19,r16
 2012d4c:	10bfffc4 	addi	r2,r2,-1
 2012d50:	9c00f736 	bltu	r19,r16,2013130 <__udivdi3+0x508>
 2012d54:	9d40f62e 	bgeu	r19,r21,2013130 <__udivdi3+0x508>
 2012d58:	213fff84 	addi	r4,r4,-2
 2012d5c:	9004943a 	slli	r2,r18,16
 2012d60:	0007883a 	mov	r3,zero
 2012d64:	2084b03a 	or	r2,r4,r2
 2012d68:	00001506 	br	2012dc0 <__udivdi3+0x198>
 2012d6c:	29c06536 	bltu	r5,r7,2012f04 <__udivdi3+0x2dc>
 2012d70:	00bfffd4 	movui	r2,65535
 2012d74:	11c0652e 	bgeu	r2,r7,2012f0c <__udivdi3+0x2e4>
 2012d78:	00804034 	movhi	r2,256
 2012d7c:	10bfffc4 	addi	r2,r2,-1
 2012d80:	11c0f736 	bltu	r2,r7,2013160 <__udivdi3+0x538>
 2012d84:	00c00404 	movi	r3,16
 2012d88:	180b883a 	mov	r5,r3
 2012d8c:	38c6d83a 	srl	r3,r7,r3
 2012d90:	01008174 	movhi	r4,517
 2012d94:	21381e04 	addi	r4,r4,-8072
 2012d98:	04000804 	movi	r16,32
 2012d9c:	20c7883a 	add	r3,r4,r3
 2012da0:	18800003 	ldbu	r2,0(r3)
 2012da4:	1145883a 	add	r2,r2,r5
 2012da8:	80a1c83a 	sub	r16,r16,r2
 2012dac:	8000691e 	bne	r16,zero,2012f54 <__udivdi3+0x32c>
 2012db0:	0007883a 	mov	r3,zero
 2012db4:	3c406536 	bltu	r7,r17,2012f4c <__udivdi3+0x324>
 2012db8:	9180642e 	bgeu	r18,r6,2012f4c <__udivdi3+0x324>
 2012dbc:	0005883a 	mov	r2,zero
 2012dc0:	dfc00a17 	ldw	ra,40(sp)
 2012dc4:	df000917 	ldw	fp,36(sp)
 2012dc8:	ddc00817 	ldw	r23,32(sp)
 2012dcc:	dd800717 	ldw	r22,28(sp)
 2012dd0:	dd400617 	ldw	r21,24(sp)
 2012dd4:	dd000517 	ldw	r20,20(sp)
 2012dd8:	dcc00417 	ldw	r19,16(sp)
 2012ddc:	dc800317 	ldw	r18,12(sp)
 2012de0:	dc400217 	ldw	r17,8(sp)
 2012de4:	dc000117 	ldw	r16,4(sp)
 2012de8:	dec00b04 	addi	sp,sp,44
 2012dec:	f800283a 	ret
 2012df0:	3000041e 	bne	r6,zero,2012e04 <__udivdi3+0x1dc>
 2012df4:	01000044 	movi	r4,1
 2012df8:	000b883a 	mov	r5,zero
 2012dfc:	201479c0 	call	201479c <__udivsi3>
 2012e00:	1021883a 	mov	r16,r2
 2012e04:	00bfffd4 	movui	r2,65535
 2012e08:	14004b2e 	bgeu	r2,r16,2012f38 <__udivdi3+0x310>
 2012e0c:	00804034 	movhi	r2,256
 2012e10:	10bfffc4 	addi	r2,r2,-1
 2012e14:	1400d836 	bltu	r2,r16,2013178 <__udivdi3+0x550>
 2012e18:	00800404 	movi	r2,16
 2012e1c:	1007883a 	mov	r3,r2
 2012e20:	8084d83a 	srl	r2,r16,r2
 2012e24:	01008174 	movhi	r4,517
 2012e28:	21381e04 	addi	r4,r4,-8072
 2012e2c:	2085883a 	add	r2,r4,r2
 2012e30:	10800003 	ldbu	r2,0(r2)
 2012e34:	10c7883a 	add	r3,r2,r3
 2012e38:	00800804 	movi	r2,32
 2012e3c:	10c5c83a 	sub	r2,r2,r3
 2012e40:	1000891e 	bne	r2,zero,2013068 <__udivdi3+0x440>
 2012e44:	8028d43a 	srli	r20,r16,16
 2012e48:	8c23c83a 	sub	r17,r17,r16
 2012e4c:	84bfffcc 	andi	r18,r16,65535
 2012e50:	00c00044 	movi	r3,1
 2012e54:	8809883a 	mov	r4,r17
 2012e58:	a00b883a 	mov	r5,r20
 2012e5c:	d8c00015 	stw	r3,0(sp)
 2012e60:	20147a40 	call	20147a4 <__umodsi3>
 2012e64:	8809883a 	mov	r4,r17
 2012e68:	a00b883a 	mov	r5,r20
 2012e6c:	102b883a 	mov	r21,r2
 2012e70:	201479c0 	call	201479c <__udivsi3>
 2012e74:	a82a943a 	slli	r21,r21,16
 2012e78:	9808d43a 	srli	r4,r19,16
 2012e7c:	148b383a 	mul	r5,r2,r18
 2012e80:	1023883a 	mov	r17,r2
 2012e84:	a908b03a 	or	r4,r21,r4
 2012e88:	d8c00017 	ldw	r3,0(sp)
 2012e8c:	2140052e 	bgeu	r4,r5,2012ea4 <__udivdi3+0x27c>
 2012e90:	2409883a 	add	r4,r4,r16
 2012e94:	10bfffc4 	addi	r2,r2,-1
 2012e98:	24000136 	bltu	r4,r16,2012ea0 <__udivdi3+0x278>
 2012e9c:	2140ce36 	bltu	r4,r5,20131d8 <__udivdi3+0x5b0>
 2012ea0:	1023883a 	mov	r17,r2
 2012ea4:	216bc83a 	sub	r21,r4,r5
 2012ea8:	a809883a 	mov	r4,r21
 2012eac:	a00b883a 	mov	r5,r20
 2012eb0:	d8c00015 	stw	r3,0(sp)
 2012eb4:	20147a40 	call	20147a4 <__umodsi3>
 2012eb8:	102d883a 	mov	r22,r2
 2012ebc:	a809883a 	mov	r4,r21
 2012ec0:	a00b883a 	mov	r5,r20
 2012ec4:	201479c0 	call	201479c <__udivsi3>
 2012ec8:	b02c943a 	slli	r22,r22,16
 2012ecc:	14a5383a 	mul	r18,r2,r18
 2012ed0:	9cffffcc 	andi	r19,r19,65535
 2012ed4:	b4e6b03a 	or	r19,r22,r19
 2012ed8:	1009883a 	mov	r4,r2
 2012edc:	d8c00017 	ldw	r3,0(sp)
 2012ee0:	9c80052e 	bgeu	r19,r18,2012ef8 <__udivdi3+0x2d0>
 2012ee4:	9c27883a 	add	r19,r19,r16
 2012ee8:	10bfffc4 	addi	r2,r2,-1
 2012eec:	9c009236 	bltu	r19,r16,2013138 <__udivdi3+0x510>
 2012ef0:	9c80912e 	bgeu	r19,r18,2013138 <__udivdi3+0x510>
 2012ef4:	213fff84 	addi	r4,r4,-2
 2012ef8:	8804943a 	slli	r2,r17,16
 2012efc:	2084b03a 	or	r2,r4,r2
 2012f00:	003faf06 	br	2012dc0 <__udivdi3+0x198>
 2012f04:	0007883a 	mov	r3,zero
 2012f08:	003fac06 	br	2012dbc <__udivdi3+0x194>
 2012f0c:	00803fc4 	movi	r2,255
 2012f10:	11c09636 	bltu	r2,r7,201316c <__udivdi3+0x544>
 2012f14:	0007883a 	mov	r3,zero
 2012f18:	000b883a 	mov	r5,zero
 2012f1c:	003f9b06 	br	2012d8c <__udivdi3+0x164>
 2012f20:	00804034 	movhi	r2,256
 2012f24:	10bfffc4 	addi	r2,r2,-1
 2012f28:	11809636 	bltu	r2,r6,2013184 <__udivdi3+0x55c>
 2012f2c:	00800404 	movi	r2,16
 2012f30:	1007883a 	mov	r3,r2
 2012f34:	003f5406 	br	2012c88 <__udivdi3+0x60>
 2012f38:	00803fc4 	movi	r2,255
 2012f3c:	14009736 	bltu	r2,r16,201319c <__udivdi3+0x574>
 2012f40:	0005883a 	mov	r2,zero
 2012f44:	0007883a 	mov	r3,zero
 2012f48:	003fb506 	br	2012e20 <__udivdi3+0x1f8>
 2012f4c:	00800044 	movi	r2,1
 2012f50:	003f9b06 	br	2012dc0 <__udivdi3+0x198>
 2012f54:	3086d83a 	srl	r3,r6,r2
 2012f58:	3c0e983a 	sll	r7,r7,r16
 2012f5c:	88aad83a 	srl	r21,r17,r2
 2012f60:	9084d83a 	srl	r2,r18,r2
 2012f64:	38e6b03a 	or	r19,r7,r3
 2012f68:	9828d43a 	srli	r20,r19,16
 2012f6c:	8c22983a 	sll	r17,r17,r16
 2012f70:	a809883a 	mov	r4,r21
 2012f74:	a00b883a 	mov	r5,r20
 2012f78:	342c983a 	sll	r22,r6,r16
 2012f7c:	88a2b03a 	or	r17,r17,r2
 2012f80:	20147a40 	call	20147a4 <__umodsi3>
 2012f84:	a809883a 	mov	r4,r21
 2012f88:	a00b883a 	mov	r5,r20
 2012f8c:	1039883a 	mov	fp,r2
 2012f90:	201479c0 	call	201479c <__udivsi3>
 2012f94:	102b883a 	mov	r21,r2
 2012f98:	9dffffcc 	andi	r23,r19,65535
 2012f9c:	e008943a 	slli	r4,fp,16
 2012fa0:	8804d43a 	srli	r2,r17,16
 2012fa4:	adcd383a 	mul	r6,r21,r23
 2012fa8:	2088b03a 	or	r4,r4,r2
 2012fac:	2180042e 	bgeu	r4,r6,2012fc0 <__udivdi3+0x398>
 2012fb0:	24c9883a 	add	r4,r4,r19
 2012fb4:	a8bfffc4 	addi	r2,r21,-1
 2012fb8:	24c07f2e 	bgeu	r4,r19,20131b8 <__udivdi3+0x590>
 2012fbc:	102b883a 	mov	r21,r2
 2012fc0:	21b9c83a 	sub	fp,r4,r6
 2012fc4:	e009883a 	mov	r4,fp
 2012fc8:	a00b883a 	mov	r5,r20
 2012fcc:	20147a40 	call	20147a4 <__umodsi3>
 2012fd0:	e009883a 	mov	r4,fp
 2012fd4:	a00b883a 	mov	r5,r20
 2012fd8:	d8800015 	stw	r2,0(sp)
 2012fdc:	201479c0 	call	201479c <__udivsi3>
 2012fe0:	d8c00017 	ldw	r3,0(sp)
 2012fe4:	15cb383a 	mul	r5,r2,r23
 2012fe8:	8c7fffcc 	andi	r17,r17,65535
 2012fec:	1806943a 	slli	r3,r3,16
 2012ff0:	1009883a 	mov	r4,r2
 2012ff4:	1c46b03a 	or	r3,r3,r17
 2012ff8:	1940042e 	bgeu	r3,r5,201300c <__udivdi3+0x3e4>
 2012ffc:	1cc7883a 	add	r3,r3,r19
 2013000:	10bfffc4 	addi	r2,r2,-1
 2013004:	1cc0682e 	bgeu	r3,r19,20131a8 <__udivdi3+0x580>
 2013008:	1009883a 	mov	r4,r2
 201300c:	a804943a 	slli	r2,r21,16
 2013010:	b1ffffcc 	andi	r7,r22,65535
 2013014:	b02cd43a 	srli	r22,r22,16
 2013018:	2084b03a 	or	r2,r4,r2
 201301c:	113fffcc 	andi	r4,r2,65535
 2013020:	100cd43a 	srli	r6,r2,16
 2013024:	21d1383a 	mul	r8,r4,r7
 2013028:	2589383a 	mul	r4,r4,r22
 201302c:	31cf383a 	mul	r7,r6,r7
 2013030:	4012d43a 	srli	r9,r8,16
 2013034:	1947c83a 	sub	r3,r3,r5
 2013038:	3909883a 	add	r4,r7,r4
 201303c:	2249883a 	add	r4,r4,r9
 2013040:	35ad383a 	mul	r22,r6,r22
 2013044:	21c0022e 	bgeu	r4,r7,2013050 <__udivdi3+0x428>
 2013048:	01400074 	movhi	r5,1
 201304c:	b16d883a 	add	r22,r22,r5
 2013050:	200ad43a 	srli	r5,r4,16
 2013054:	b16d883a 	add	r22,r22,r5
 2013058:	1d803e36 	bltu	r3,r22,2013154 <__udivdi3+0x52c>
 201305c:	1d803826 	beq	r3,r22,2013140 <__udivdi3+0x518>
 2013060:	0007883a 	mov	r3,zero
 2013064:	003f5606 	br	2012dc0 <__udivdi3+0x198>
 2013068:	80a0983a 	sll	r16,r16,r2
 201306c:	88ead83a 	srl	r21,r17,r3
 2013070:	90c6d83a 	srl	r3,r18,r3
 2013074:	8028d43a 	srli	r20,r16,16
 2013078:	88a2983a 	sll	r17,r17,r2
 201307c:	a809883a 	mov	r4,r21
 2013080:	a00b883a 	mov	r5,r20
 2013084:	88ecb03a 	or	r22,r17,r3
 2013088:	90a6983a 	sll	r19,r18,r2
 201308c:	20147a40 	call	20147a4 <__umodsi3>
 2013090:	a809883a 	mov	r4,r21
 2013094:	a00b883a 	mov	r5,r20
 2013098:	1023883a 	mov	r17,r2
 201309c:	201479c0 	call	201479c <__udivsi3>
 20130a0:	102b883a 	mov	r21,r2
 20130a4:	84bfffcc 	andi	r18,r16,65535
 20130a8:	8808943a 	slli	r4,r17,16
 20130ac:	b004d43a 	srli	r2,r22,16
 20130b0:	ac87383a 	mul	r3,r21,r18
 20130b4:	2088b03a 	or	r4,r4,r2
 20130b8:	20c0062e 	bgeu	r4,r3,20130d4 <__udivdi3+0x4ac>
 20130bc:	2409883a 	add	r4,r4,r16
 20130c0:	a8bfffc4 	addi	r2,r21,-1
 20130c4:	24004236 	bltu	r4,r16,20131d0 <__udivdi3+0x5a8>
 20130c8:	20c0412e 	bgeu	r4,r3,20131d0 <__udivdi3+0x5a8>
 20130cc:	ad7fff84 	addi	r21,r21,-2
 20130d0:	2409883a 	add	r4,r4,r16
 20130d4:	20efc83a 	sub	r23,r4,r3
 20130d8:	b809883a 	mov	r4,r23
 20130dc:	a00b883a 	mov	r5,r20
 20130e0:	20147a40 	call	20147a4 <__umodsi3>
 20130e4:	1023883a 	mov	r17,r2
 20130e8:	a00b883a 	mov	r5,r20
 20130ec:	b809883a 	mov	r4,r23
 20130f0:	201479c0 	call	201479c <__udivsi3>
 20130f4:	8822943a 	slli	r17,r17,16
 20130f8:	148b383a 	mul	r5,r2,r18
 20130fc:	b5bfffcc 	andi	r22,r22,65535
 2013100:	8da2b03a 	or	r17,r17,r22
 2013104:	8940062e 	bgeu	r17,r5,2013120 <__udivdi3+0x4f8>
 2013108:	8c23883a 	add	r17,r17,r16
 201310c:	10ffffc4 	addi	r3,r2,-1
 2013110:	8c002d36 	bltu	r17,r16,20131c8 <__udivdi3+0x5a0>
 2013114:	89402c2e 	bgeu	r17,r5,20131c8 <__udivdi3+0x5a0>
 2013118:	10bfff84 	addi	r2,r2,-2
 201311c:	8c23883a 	add	r17,r17,r16
 2013120:	a806943a 	slli	r3,r21,16
 2013124:	8963c83a 	sub	r17,r17,r5
 2013128:	10c6b03a 	or	r3,r2,r3
 201312c:	003f4906 	br	2012e54 <__udivdi3+0x22c>
 2013130:	1009883a 	mov	r4,r2
 2013134:	003f0906 	br	2012d5c <__udivdi3+0x134>
 2013138:	1009883a 	mov	r4,r2
 201313c:	003f6e06 	br	2012ef8 <__udivdi3+0x2d0>
 2013140:	2008943a 	slli	r4,r4,16
 2013144:	9420983a 	sll	r16,r18,r16
 2013148:	423fffcc 	andi	r8,r8,65535
 201314c:	2209883a 	add	r4,r4,r8
 2013150:	813fc32e 	bgeu	r16,r4,2013060 <__udivdi3+0x438>
 2013154:	10bfffc4 	addi	r2,r2,-1
 2013158:	0007883a 	mov	r3,zero
 201315c:	003f1806 	br	2012dc0 <__udivdi3+0x198>
 2013160:	00c00604 	movi	r3,24
 2013164:	180b883a 	mov	r5,r3
 2013168:	003f0806 	br	2012d8c <__udivdi3+0x164>
 201316c:	00c00204 	movi	r3,8
 2013170:	180b883a 	mov	r5,r3
 2013174:	003f0506 	br	2012d8c <__udivdi3+0x164>
 2013178:	00800604 	movi	r2,24
 201317c:	1007883a 	mov	r3,r2
 2013180:	003f2706 	br	2012e20 <__udivdi3+0x1f8>
 2013184:	00800604 	movi	r2,24
 2013188:	1007883a 	mov	r3,r2
 201318c:	003ebe06 	br	2012c88 <__udivdi3+0x60>
 2013190:	00800204 	movi	r2,8
 2013194:	1007883a 	mov	r3,r2
 2013198:	003ebb06 	br	2012c88 <__udivdi3+0x60>
 201319c:	00800204 	movi	r2,8
 20131a0:	1007883a 	mov	r3,r2
 20131a4:	003f1e06 	br	2012e20 <__udivdi3+0x1f8>
 20131a8:	197f972e 	bgeu	r3,r5,2013008 <__udivdi3+0x3e0>
 20131ac:	213fff84 	addi	r4,r4,-2
 20131b0:	1cc7883a 	add	r3,r3,r19
 20131b4:	003f9506 	br	201300c <__udivdi3+0x3e4>
 20131b8:	21bf802e 	bgeu	r4,r6,2012fbc <__udivdi3+0x394>
 20131bc:	ad7fff84 	addi	r21,r21,-2
 20131c0:	24c9883a 	add	r4,r4,r19
 20131c4:	003f7e06 	br	2012fc0 <__udivdi3+0x398>
 20131c8:	1805883a 	mov	r2,r3
 20131cc:	003fd406 	br	2013120 <__udivdi3+0x4f8>
 20131d0:	102b883a 	mov	r21,r2
 20131d4:	003fbf06 	br	20130d4 <__udivdi3+0x4ac>
 20131d8:	8c7fff84 	addi	r17,r17,-2
 20131dc:	2409883a 	add	r4,r4,r16
 20131e0:	003f3006 	br	2012ea4 <__udivdi3+0x27c>
 20131e4:	94bfff84 	addi	r18,r18,-2
 20131e8:	1c07883a 	add	r3,r3,r16
 20131ec:	003ec806 	br	2012d10 <__udivdi3+0xe8>

020131f0 <__umoddi3>:
 20131f0:	defff504 	addi	sp,sp,-44
 20131f4:	dd000515 	stw	r20,20(sp)
 20131f8:	dcc00415 	stw	r19,16(sp)
 20131fc:	dc800315 	stw	r18,12(sp)
 2013200:	dc400215 	stw	r17,8(sp)
 2013204:	dc000115 	stw	r16,4(sp)
 2013208:	dfc00a15 	stw	ra,40(sp)
 201320c:	df000915 	stw	fp,36(sp)
 2013210:	ddc00815 	stw	r23,32(sp)
 2013214:	dd800715 	stw	r22,28(sp)
 2013218:	dd400615 	stw	r21,24(sp)
 201321c:	2025883a 	mov	r18,r4
 2013220:	2823883a 	mov	r17,r5
 2013224:	3021883a 	mov	r16,r6
 2013228:	2027883a 	mov	r19,r4
 201322c:	2829883a 	mov	r20,r5
 2013230:	3800351e 	bne	r7,zero,2013308 <__umoddi3+0x118>
 2013234:	29804d2e 	bgeu	r5,r6,201336c <__umoddi3+0x17c>
 2013238:	00bfffd4 	movui	r2,65535
 201323c:	11809a36 	bltu	r2,r6,20134a8 <__umoddi3+0x2b8>
 2013240:	00803fc4 	movi	r2,255
 2013244:	11813936 	bltu	r2,r6,201372c <__umoddi3+0x53c>
 2013248:	0005883a 	mov	r2,zero
 201324c:	0009883a 	mov	r4,zero
 2013250:	3084d83a 	srl	r2,r6,r2
 2013254:	00c08174 	movhi	r3,517
 2013258:	18f81e04 	addi	r3,r3,-8072
 201325c:	05400804 	movi	r21,32
 2013260:	1885883a 	add	r2,r3,r2
 2013264:	10800003 	ldbu	r2,0(r2)
 2013268:	1109883a 	add	r4,r2,r4
 201326c:	a92bc83a 	sub	r21,r21,r4
 2013270:	a800ec26 	beq	r21,zero,2013624 <__umoddi3+0x434>
 2013274:	8d62983a 	sll	r17,r17,r21
 2013278:	9108d83a 	srl	r4,r18,r4
 201327c:	3560983a 	sll	r16,r6,r21
 2013280:	9566983a 	sll	r19,r18,r21
 2013284:	8928b03a 	or	r20,r17,r4
 2013288:	8022d43a 	srli	r17,r16,16
 201328c:	a009883a 	mov	r4,r20
 2013290:	84bfffcc 	andi	r18,r16,65535
 2013294:	880b883a 	mov	r5,r17
 2013298:	20147a40 	call	20147a4 <__umodsi3>
 201329c:	a009883a 	mov	r4,r20
 20132a0:	880b883a 	mov	r5,r17
 20132a4:	102d883a 	mov	r22,r2
 20132a8:	201479c0 	call	201479c <__udivsi3>
 20132ac:	b02c943a 	slli	r22,r22,16
 20132b0:	9806d43a 	srli	r3,r19,16
 20132b4:	1485383a 	mul	r2,r2,r18
 20132b8:	b0c6b03a 	or	r3,r22,r3
 20132bc:	1880042e 	bgeu	r3,r2,20132d0 <__umoddi3+0xe0>
 20132c0:	1c07883a 	add	r3,r3,r16
 20132c4:	1c000236 	bltu	r3,r16,20132d0 <__umoddi3+0xe0>
 20132c8:	1880012e 	bgeu	r3,r2,20132d0 <__umoddi3+0xe0>
 20132cc:	1c07883a 	add	r3,r3,r16
 20132d0:	18a9c83a 	sub	r20,r3,r2
 20132d4:	a009883a 	mov	r4,r20
 20132d8:	880b883a 	mov	r5,r17
 20132dc:	20147a40 	call	20147a4 <__umodsi3>
 20132e0:	102d883a 	mov	r22,r2
 20132e4:	a009883a 	mov	r4,r20
 20132e8:	880b883a 	mov	r5,r17
 20132ec:	201479c0 	call	201479c <__udivsi3>
 20132f0:	b02c943a 	slli	r22,r22,16
 20132f4:	1485383a 	mul	r2,r2,r18
 20132f8:	9cffffcc 	andi	r19,r19,65535
 20132fc:	b4e6b03a 	or	r19,r22,r19
 2013300:	9880522e 	bgeu	r19,r2,201344c <__umoddi3+0x25c>
 2013304:	00004d06 	br	201343c <__umoddi3+0x24c>
 2013308:	29c05436 	bltu	r5,r7,201345c <__umoddi3+0x26c>
 201330c:	00bfffd4 	movui	r2,65535
 2013310:	11c0602e 	bgeu	r2,r7,2013494 <__umoddi3+0x2a4>
 2013314:	00804034 	movhi	r2,256
 2013318:	10bfffc4 	addi	r2,r2,-1
 201331c:	11c0f736 	bltu	r2,r7,20136fc <__umoddi3+0x50c>
 2013320:	00c00404 	movi	r3,16
 2013324:	1827883a 	mov	r19,r3
 2013328:	38c6d83a 	srl	r3,r7,r3
 201332c:	01008174 	movhi	r4,517
 2013330:	21381e04 	addi	r4,r4,-8072
 2013334:	04000804 	movi	r16,32
 2013338:	20c7883a 	add	r3,r4,r3
 201333c:	18800003 	ldbu	r2,0(r3)
 2013340:	14e7883a 	add	r19,r2,r19
 2013344:	84e1c83a 	sub	r16,r16,r19
 2013348:	8000621e 	bne	r16,zero,20134d4 <__umoddi3+0x2e4>
 201334c:	3c400136 	bltu	r7,r17,2013354 <__umoddi3+0x164>
 2013350:	91810336 	bltu	r18,r6,2013760 <__umoddi3+0x570>
 2013354:	9185c83a 	sub	r2,r18,r6
 2013358:	89e3c83a 	sub	r17,r17,r7
 201335c:	90a5803a 	cmpltu	r18,r18,r2
 2013360:	8ca9c83a 	sub	r20,r17,r18
 2013364:	a007883a 	mov	r3,r20
 2013368:	00003e06 	br	2013464 <__umoddi3+0x274>
 201336c:	3000041e 	bne	r6,zero,2013380 <__umoddi3+0x190>
 2013370:	01000044 	movi	r4,1
 2013374:	000b883a 	mov	r5,zero
 2013378:	201479c0 	call	201479c <__udivsi3>
 201337c:	1021883a 	mov	r16,r2
 2013380:	00bfffd4 	movui	r2,65535
 2013384:	14004e2e 	bgeu	r2,r16,20134c0 <__umoddi3+0x2d0>
 2013388:	00804034 	movhi	r2,256
 201338c:	10bfffc4 	addi	r2,r2,-1
 2013390:	1400e336 	bltu	r2,r16,2013720 <__umoddi3+0x530>
 2013394:	00800404 	movi	r2,16
 2013398:	1007883a 	mov	r3,r2
 201339c:	8084d83a 	srl	r2,r16,r2
 20133a0:	01008174 	movhi	r4,517
 20133a4:	21381e04 	addi	r4,r4,-8072
 20133a8:	05400804 	movi	r21,32
 20133ac:	2085883a 	add	r2,r4,r2
 20133b0:	10800003 	ldbu	r2,0(r2)
 20133b4:	10c7883a 	add	r3,r2,r3
 20133b8:	a8ebc83a 	sub	r21,r21,r3
 20133bc:	a8009b1e 	bne	r21,zero,201362c <__umoddi3+0x43c>
 20133c0:	8028d43a 	srli	r20,r16,16
 20133c4:	8c23c83a 	sub	r17,r17,r16
 20133c8:	85bfffcc 	andi	r22,r16,65535
 20133cc:	8809883a 	mov	r4,r17
 20133d0:	a00b883a 	mov	r5,r20
 20133d4:	20147a40 	call	20147a4 <__umodsi3>
 20133d8:	8809883a 	mov	r4,r17
 20133dc:	a00b883a 	mov	r5,r20
 20133e0:	1025883a 	mov	r18,r2
 20133e4:	201479c0 	call	201479c <__udivsi3>
 20133e8:	9024943a 	slli	r18,r18,16
 20133ec:	9806d43a 	srli	r3,r19,16
 20133f0:	1585383a 	mul	r2,r2,r22
 20133f4:	90c6b03a 	or	r3,r18,r3
 20133f8:	1880032e 	bgeu	r3,r2,2013408 <__umoddi3+0x218>
 20133fc:	1c07883a 	add	r3,r3,r16
 2013400:	1c000136 	bltu	r3,r16,2013408 <__umoddi3+0x218>
 2013404:	1880d436 	bltu	r3,r2,2013758 <__umoddi3+0x568>
 2013408:	18a3c83a 	sub	r17,r3,r2
 201340c:	8809883a 	mov	r4,r17
 2013410:	a00b883a 	mov	r5,r20
 2013414:	20147a40 	call	20147a4 <__umodsi3>
 2013418:	1025883a 	mov	r18,r2
 201341c:	8809883a 	mov	r4,r17
 2013420:	a00b883a 	mov	r5,r20
 2013424:	201479c0 	call	201479c <__udivsi3>
 2013428:	9024943a 	slli	r18,r18,16
 201342c:	1585383a 	mul	r2,r2,r22
 2013430:	9cffffcc 	andi	r19,r19,65535
 2013434:	94e6b03a 	or	r19,r18,r19
 2013438:	9880042e 	bgeu	r19,r2,201344c <__umoddi3+0x25c>
 201343c:	9c27883a 	add	r19,r19,r16
 2013440:	9c000236 	bltu	r19,r16,201344c <__umoddi3+0x25c>
 2013444:	9880012e 	bgeu	r19,r2,201344c <__umoddi3+0x25c>
 2013448:	9c27883a 	add	r19,r19,r16
 201344c:	98a7c83a 	sub	r19,r19,r2
 2013450:	9d44d83a 	srl	r2,r19,r21
 2013454:	0007883a 	mov	r3,zero
 2013458:	00000206 	br	2013464 <__umoddi3+0x274>
 201345c:	2005883a 	mov	r2,r4
 2013460:	2807883a 	mov	r3,r5
 2013464:	dfc00a17 	ldw	ra,40(sp)
 2013468:	df000917 	ldw	fp,36(sp)
 201346c:	ddc00817 	ldw	r23,32(sp)
 2013470:	dd800717 	ldw	r22,28(sp)
 2013474:	dd400617 	ldw	r21,24(sp)
 2013478:	dd000517 	ldw	r20,20(sp)
 201347c:	dcc00417 	ldw	r19,16(sp)
 2013480:	dc800317 	ldw	r18,12(sp)
 2013484:	dc400217 	ldw	r17,8(sp)
 2013488:	dc000117 	ldw	r16,4(sp)
 201348c:	dec00b04 	addi	sp,sp,44
 2013490:	f800283a 	ret
 2013494:	00803fc4 	movi	r2,255
 2013498:	11c09536 	bltu	r2,r7,20136f0 <__umoddi3+0x500>
 201349c:	0007883a 	mov	r3,zero
 20134a0:	0027883a 	mov	r19,zero
 20134a4:	003fa006 	br	2013328 <__umoddi3+0x138>
 20134a8:	00804034 	movhi	r2,256
 20134ac:	10bfffc4 	addi	r2,r2,-1
 20134b0:	11809536 	bltu	r2,r6,2013708 <__umoddi3+0x518>
 20134b4:	00800404 	movi	r2,16
 20134b8:	1009883a 	mov	r4,r2
 20134bc:	003f6406 	br	2013250 <__umoddi3+0x60>
 20134c0:	00803fc4 	movi	r2,255
 20134c4:	14009336 	bltu	r2,r16,2013714 <__umoddi3+0x524>
 20134c8:	0005883a 	mov	r2,zero
 20134cc:	0007883a 	mov	r3,zero
 20134d0:	003fb206 	br	201339c <__umoddi3+0x1ac>
 20134d4:	34c4d83a 	srl	r2,r6,r19
 20134d8:	3c0e983a 	sll	r7,r7,r16
 20134dc:	8ceed83a 	srl	r23,r17,r19
 20134e0:	8c22983a 	sll	r17,r17,r16
 20134e4:	38a8b03a 	or	r20,r7,r2
 20134e8:	a02ad43a 	srli	r21,r20,16
 20134ec:	94c4d83a 	srl	r2,r18,r19
 20134f0:	b809883a 	mov	r4,r23
 20134f4:	a80b883a 	mov	r5,r21
 20134f8:	88a2b03a 	or	r17,r17,r2
 20134fc:	342c983a 	sll	r22,r6,r16
 2013500:	20147a40 	call	20147a4 <__umodsi3>
 2013504:	b809883a 	mov	r4,r23
 2013508:	a80b883a 	mov	r5,r21
 201350c:	d8800015 	stw	r2,0(sp)
 2013510:	201479c0 	call	201479c <__udivsi3>
 2013514:	d8c00017 	ldw	r3,0(sp)
 2013518:	102f883a 	mov	r23,r2
 201351c:	a73fffcc 	andi	fp,r20,65535
 2013520:	180a943a 	slli	r5,r3,16
 2013524:	8804d43a 	srli	r2,r17,16
 2013528:	bf09383a 	mul	r4,r23,fp
 201352c:	9424983a 	sll	r18,r18,r16
 2013530:	288ab03a 	or	r5,r5,r2
 2013534:	2900042e 	bgeu	r5,r4,2013548 <__umoddi3+0x358>
 2013538:	2d0b883a 	add	r5,r5,r20
 201353c:	b8bfffc4 	addi	r2,r23,-1
 2013540:	2d00812e 	bgeu	r5,r20,2013748 <__umoddi3+0x558>
 2013544:	102f883a 	mov	r23,r2
 2013548:	2907c83a 	sub	r3,r5,r4
 201354c:	1809883a 	mov	r4,r3
 2013550:	a80b883a 	mov	r5,r21
 2013554:	d8c00015 	stw	r3,0(sp)
 2013558:	20147a40 	call	20147a4 <__umodsi3>
 201355c:	d8c00017 	ldw	r3,0(sp)
 2013560:	a80b883a 	mov	r5,r21
 2013564:	d8800015 	stw	r2,0(sp)
 2013568:	1809883a 	mov	r4,r3
 201356c:	201479c0 	call	201479c <__udivsi3>
 2013570:	d9800017 	ldw	r6,0(sp)
 2013574:	8c7fffcc 	andi	r17,r17,65535
 2013578:	3008943a 	slli	r4,r6,16
 201357c:	170d383a 	mul	r6,r2,fp
 2013580:	2448b03a 	or	r4,r4,r17
 2013584:	2180042e 	bgeu	r4,r6,2013598 <__umoddi3+0x3a8>
 2013588:	2509883a 	add	r4,r4,r20
 201358c:	10ffffc4 	addi	r3,r2,-1
 2013590:	2500692e 	bgeu	r4,r20,2013738 <__umoddi3+0x548>
 2013594:	1805883a 	mov	r2,r3
 2013598:	b82e943a 	slli	r23,r23,16
 201359c:	b010d43a 	srli	r8,r22,16
 20135a0:	b1ffffcc 	andi	r7,r22,65535
 20135a4:	15eeb03a 	or	r23,r2,r23
 20135a8:	b8bfffcc 	andi	r2,r23,65535
 20135ac:	b82ed43a 	srli	r23,r23,16
 20135b0:	11c7383a 	mul	r3,r2,r7
 20135b4:	1205383a 	mul	r2,r2,r8
 20135b8:	b9cf383a 	mul	r7,r23,r7
 20135bc:	400b883a 	mov	r5,r8
 20135c0:	1810d43a 	srli	r8,r3,16
 20135c4:	3885883a 	add	r2,r7,r2
 20135c8:	2189c83a 	sub	r4,r4,r6
 20135cc:	1205883a 	add	r2,r2,r8
 20135d0:	b94b383a 	mul	r5,r23,r5
 20135d4:	11c0022e 	bgeu	r2,r7,20135e0 <__umoddi3+0x3f0>
 20135d8:	01800074 	movhi	r6,1
 20135dc:	298b883a 	add	r5,r5,r6
 20135e0:	100cd43a 	srli	r6,r2,16
 20135e4:	1004943a 	slli	r2,r2,16
 20135e8:	18ffffcc 	andi	r3,r3,65535
 20135ec:	298b883a 	add	r5,r5,r6
 20135f0:	10c5883a 	add	r2,r2,r3
 20135f4:	21403836 	bltu	r4,r5,20136d8 <__umoddi3+0x4e8>
 20135f8:	21405c26 	beq	r4,r5,201376c <__umoddi3+0x57c>
 20135fc:	2147c83a 	sub	r3,r4,r5
 2013600:	102d883a 	mov	r22,r2
 2013604:	95adc83a 	sub	r22,r18,r22
 2013608:	95a5803a 	cmpltu	r18,r18,r22
 201360c:	1c87c83a 	sub	r3,r3,r18
 2013610:	1cc4983a 	sll	r2,r3,r19
 2013614:	b42cd83a 	srl	r22,r22,r16
 2013618:	1c06d83a 	srl	r3,r3,r16
 201361c:	1584b03a 	or	r2,r2,r22
 2013620:	003f9006 	br	2013464 <__umoddi3+0x274>
 2013624:	002b883a 	mov	r21,zero
 2013628:	003f1706 	br	2013288 <__umoddi3+0x98>
 201362c:	8560983a 	sll	r16,r16,r21
 2013630:	88e6d83a 	srl	r19,r17,r3
 2013634:	90c6d83a 	srl	r3,r18,r3
 2013638:	8028d43a 	srli	r20,r16,16
 201363c:	8d62983a 	sll	r17,r17,r21
 2013640:	9809883a 	mov	r4,r19
 2013644:	a00b883a 	mov	r5,r20
 2013648:	88eeb03a 	or	r23,r17,r3
 201364c:	20147a40 	call	20147a4 <__umodsi3>
 2013650:	9809883a 	mov	r4,r19
 2013654:	a00b883a 	mov	r5,r20
 2013658:	1023883a 	mov	r17,r2
 201365c:	201479c0 	call	201479c <__udivsi3>
 2013660:	85bfffcc 	andi	r22,r16,65535
 2013664:	880a943a 	slli	r5,r17,16
 2013668:	b806d43a 	srli	r3,r23,16
 201366c:	1585383a 	mul	r2,r2,r22
 2013670:	9566983a 	sll	r19,r18,r21
 2013674:	28cab03a 	or	r5,r5,r3
 2013678:	2880042e 	bgeu	r5,r2,201368c <__umoddi3+0x49c>
 201367c:	2c0b883a 	add	r5,r5,r16
 2013680:	2c000236 	bltu	r5,r16,201368c <__umoddi3+0x49c>
 2013684:	2880012e 	bgeu	r5,r2,201368c <__umoddi3+0x49c>
 2013688:	2c0b883a 	add	r5,r5,r16
 201368c:	28a5c83a 	sub	r18,r5,r2
 2013690:	9009883a 	mov	r4,r18
 2013694:	a00b883a 	mov	r5,r20
 2013698:	20147a40 	call	20147a4 <__umodsi3>
 201369c:	1023883a 	mov	r17,r2
 20136a0:	9009883a 	mov	r4,r18
 20136a4:	a00b883a 	mov	r5,r20
 20136a8:	201479c0 	call	201479c <__udivsi3>
 20136ac:	8822943a 	slli	r17,r17,16
 20136b0:	1585383a 	mul	r2,r2,r22
 20136b4:	bdffffcc 	andi	r23,r23,65535
 20136b8:	8de2b03a 	or	r17,r17,r23
 20136bc:	8880042e 	bgeu	r17,r2,20136d0 <__umoddi3+0x4e0>
 20136c0:	8c23883a 	add	r17,r17,r16
 20136c4:	8c000236 	bltu	r17,r16,20136d0 <__umoddi3+0x4e0>
 20136c8:	8880012e 	bgeu	r17,r2,20136d0 <__umoddi3+0x4e0>
 20136cc:	8c23883a 	add	r17,r17,r16
 20136d0:	88a3c83a 	sub	r17,r17,r2
 20136d4:	003f3d06 	br	20133cc <__umoddi3+0x1dc>
 20136d8:	15adc83a 	sub	r22,r2,r22
 20136dc:	2d07c83a 	sub	r3,r5,r20
 20136e0:	1585803a 	cmpltu	r2,r2,r22
 20136e4:	1887c83a 	sub	r3,r3,r2
 20136e8:	20c7c83a 	sub	r3,r4,r3
 20136ec:	003fc506 	br	2013604 <__umoddi3+0x414>
 20136f0:	00c00204 	movi	r3,8
 20136f4:	1827883a 	mov	r19,r3
 20136f8:	003f0b06 	br	2013328 <__umoddi3+0x138>
 20136fc:	00c00604 	movi	r3,24
 2013700:	1827883a 	mov	r19,r3
 2013704:	003f0806 	br	2013328 <__umoddi3+0x138>
 2013708:	00800604 	movi	r2,24
 201370c:	1009883a 	mov	r4,r2
 2013710:	003ecf06 	br	2013250 <__umoddi3+0x60>
 2013714:	00800204 	movi	r2,8
 2013718:	1007883a 	mov	r3,r2
 201371c:	003f1f06 	br	201339c <__umoddi3+0x1ac>
 2013720:	00800604 	movi	r2,24
 2013724:	1007883a 	mov	r3,r2
 2013728:	003f1c06 	br	201339c <__umoddi3+0x1ac>
 201372c:	00800204 	movi	r2,8
 2013730:	1009883a 	mov	r4,r2
 2013734:	003ec606 	br	2013250 <__umoddi3+0x60>
 2013738:	21bf962e 	bgeu	r4,r6,2013594 <__umoddi3+0x3a4>
 201373c:	10bfff84 	addi	r2,r2,-2
 2013740:	2509883a 	add	r4,r4,r20
 2013744:	003f9406 	br	2013598 <__umoddi3+0x3a8>
 2013748:	293f7e2e 	bgeu	r5,r4,2013544 <__umoddi3+0x354>
 201374c:	bdffff84 	addi	r23,r23,-2
 2013750:	2d0b883a 	add	r5,r5,r20
 2013754:	003f7c06 	br	2013548 <__umoddi3+0x358>
 2013758:	1c07883a 	add	r3,r3,r16
 201375c:	003f2a06 	br	2013408 <__umoddi3+0x218>
 2013760:	9005883a 	mov	r2,r18
 2013764:	a007883a 	mov	r3,r20
 2013768:	003f3e06 	br	2013464 <__umoddi3+0x274>
 201376c:	90bfda36 	bltu	r18,r2,20136d8 <__umoddi3+0x4e8>
 2013770:	102d883a 	mov	r22,r2
 2013774:	0007883a 	mov	r3,zero
 2013778:	003fa206 	br	2013604 <__umoddi3+0x414>

0201377c <__eqsf2>:
 201377c:	defff504 	addi	sp,sp,-44
 2013780:	d9000915 	stw	r4,36(sp)
 2013784:	d9400815 	stw	r5,32(sp)
 2013788:	d9000904 	addi	r4,sp,36
 201378c:	d9400404 	addi	r5,sp,16
 2013790:	dfc00a15 	stw	ra,40(sp)
 2013794:	20148580 	call	2014858 <__unpack_f>
 2013798:	d9000804 	addi	r4,sp,32
 201379c:	d80b883a 	mov	r5,sp
 20137a0:	20148580 	call	2014858 <__unpack_f>
 20137a4:	d8c00417 	ldw	r3,16(sp)
 20137a8:	00800044 	movi	r2,1
 20137ac:	10c0052e 	bgeu	r2,r3,20137c4 <__eqsf2+0x48>
 20137b0:	d8c00017 	ldw	r3,0(sp)
 20137b4:	10c0032e 	bgeu	r2,r3,20137c4 <__eqsf2+0x48>
 20137b8:	d9000404 	addi	r4,sp,16
 20137bc:	d80b883a 	mov	r5,sp
 20137c0:	20149200 	call	2014920 <__fpcmp_parts_f>
 20137c4:	dfc00a17 	ldw	ra,40(sp)
 20137c8:	dec00b04 	addi	sp,sp,44
 20137cc:	f800283a 	ret

020137d0 <__gtsf2>:
 20137d0:	defff504 	addi	sp,sp,-44
 20137d4:	d9000915 	stw	r4,36(sp)
 20137d8:	d9400815 	stw	r5,32(sp)
 20137dc:	d9000904 	addi	r4,sp,36
 20137e0:	d9400404 	addi	r5,sp,16
 20137e4:	dfc00a15 	stw	ra,40(sp)
 20137e8:	20148580 	call	2014858 <__unpack_f>
 20137ec:	d9000804 	addi	r4,sp,32
 20137f0:	d80b883a 	mov	r5,sp
 20137f4:	20148580 	call	2014858 <__unpack_f>
 20137f8:	d8c00417 	ldw	r3,16(sp)
 20137fc:	00800044 	movi	r2,1
 2013800:	10c0082e 	bgeu	r2,r3,2013824 <__gtsf2+0x54>
 2013804:	d8c00017 	ldw	r3,0(sp)
 2013808:	10c0062e 	bgeu	r2,r3,2013824 <__gtsf2+0x54>
 201380c:	d9000404 	addi	r4,sp,16
 2013810:	d80b883a 	mov	r5,sp
 2013814:	20149200 	call	2014920 <__fpcmp_parts_f>
 2013818:	dfc00a17 	ldw	ra,40(sp)
 201381c:	dec00b04 	addi	sp,sp,44
 2013820:	f800283a 	ret
 2013824:	00bfffc4 	movi	r2,-1
 2013828:	003ffb06 	br	2013818 <__gtsf2+0x48>

0201382c <__ltsf2>:
 201382c:	defff504 	addi	sp,sp,-44
 2013830:	d9000915 	stw	r4,36(sp)
 2013834:	d9400815 	stw	r5,32(sp)
 2013838:	d9000904 	addi	r4,sp,36
 201383c:	d9400404 	addi	r5,sp,16
 2013840:	dfc00a15 	stw	ra,40(sp)
 2013844:	20148580 	call	2014858 <__unpack_f>
 2013848:	d9000804 	addi	r4,sp,32
 201384c:	d80b883a 	mov	r5,sp
 2013850:	20148580 	call	2014858 <__unpack_f>
 2013854:	d8c00417 	ldw	r3,16(sp)
 2013858:	00800044 	movi	r2,1
 201385c:	10c0052e 	bgeu	r2,r3,2013874 <__ltsf2+0x48>
 2013860:	d8c00017 	ldw	r3,0(sp)
 2013864:	10c0032e 	bgeu	r2,r3,2013874 <__ltsf2+0x48>
 2013868:	d9000404 	addi	r4,sp,16
 201386c:	d80b883a 	mov	r5,sp
 2013870:	20149200 	call	2014920 <__fpcmp_parts_f>
 2013874:	dfc00a17 	ldw	ra,40(sp)
 2013878:	dec00b04 	addi	sp,sp,44
 201387c:	f800283a 	ret

02013880 <_fpadd_parts>:
 2013880:	2005883a 	mov	r2,r4
 2013884:	21000017 	ldw	r4,0(r4)
 2013888:	01c00044 	movi	r7,1
 201388c:	3900622e 	bgeu	r7,r4,2013a18 <_fpadd_parts+0x198>
 2013890:	28c00017 	ldw	r3,0(r5)
 2013894:	38c05f2e 	bgeu	r7,r3,2013a14 <_fpadd_parts+0x194>
 2013898:	01c00104 	movi	r7,4
 201389c:	21c0c626 	beq	r4,r7,2013bb8 <_fpadd_parts+0x338>
 20138a0:	19c05c26 	beq	r3,r7,2013a14 <_fpadd_parts+0x194>
 20138a4:	01c00084 	movi	r7,2
 20138a8:	19c06b26 	beq	r3,r7,2013a58 <_fpadd_parts+0x1d8>
 20138ac:	21c05926 	beq	r4,r7,2013a14 <_fpadd_parts+0x194>
 20138b0:	11c00217 	ldw	r7,8(r2)
 20138b4:	2ac00217 	ldw	r11,8(r5)
 20138b8:	13000317 	ldw	r12,12(r2)
 20138bc:	13400417 	ldw	r13,16(r2)
 20138c0:	3ac9c83a 	sub	r4,r7,r11
 20138c4:	2a000317 	ldw	r8,12(r5)
 20138c8:	2a400417 	ldw	r9,16(r5)
 20138cc:	2015883a 	mov	r10,r4
 20138d0:	20007516 	blt	r4,zero,2013aa8 <_fpadd_parts+0x228>
 20138d4:	00c00fc4 	movi	r3,63
 20138d8:	1a805016 	blt	r3,r10,2013a1c <_fpadd_parts+0x19c>
 20138dc:	0100870e 	bge	zero,r4,2013afc <_fpadd_parts+0x27c>
 20138e0:	50fff804 	addi	r3,r10,-32
 20138e4:	18009916 	blt	r3,zero,2013b4c <_fpadd_parts+0x2cc>
 20138e8:	48d6d83a 	srl	r11,r9,r3
 20138ec:	001d883a 	mov	r14,zero
 20138f0:	18009e16 	blt	r3,zero,2013b6c <_fpadd_parts+0x2ec>
 20138f4:	01000044 	movi	r4,1
 20138f8:	20c6983a 	sll	r3,r4,r3
 20138fc:	0015883a 	mov	r10,zero
 2013900:	513fffc4 	addi	r4,r10,-1
 2013904:	2295403a 	cmpgeu	r10,r4,r10
 2013908:	1a87c83a 	sub	r3,r3,r10
 201390c:	1a52703a 	and	r9,r3,r9
 2013910:	2210703a 	and	r8,r4,r8
 2013914:	4250b03a 	or	r8,r8,r9
 2013918:	4010c03a 	cmpne	r8,r8,zero
 201391c:	42d0b03a 	or	r8,r8,r11
 2013920:	7013883a 	mov	r9,r14
 2013924:	11000117 	ldw	r4,4(r2)
 2013928:	28800117 	ldw	r2,4(r5)
 201392c:	20804126 	beq	r4,r2,2013a34 <_fpadd_parts+0x1b4>
 2013930:	20006326 	beq	r4,zero,2013ac0 <_fpadd_parts+0x240>
 2013934:	4305c83a 	sub	r2,r8,r12
 2013938:	4091803a 	cmpltu	r8,r8,r2
 201393c:	4b47c83a 	sub	r3,r9,r13
 2013940:	1a07c83a 	sub	r3,r3,r8
 2013944:	18006316 	blt	r3,zero,2013ad4 <_fpadd_parts+0x254>
 2013948:	30000115 	stw	zero,4(r6)
 201394c:	31c00215 	stw	r7,8(r6)
 2013950:	30800315 	stw	r2,12(r6)
 2013954:	30c00415 	stw	r3,16(r6)
 2013958:	11ffffc4 	addi	r7,r2,-1
 201395c:	388b403a 	cmpgeu	r5,r7,r2
 2013960:	194bc83a 	sub	r5,r3,r5
 2013964:	01040034 	movhi	r4,4096
 2013968:	213fffc4 	addi	r4,r4,-1
 201396c:	21401736 	bltu	r4,r5,20139cc <_fpadd_parts+0x14c>
 2013970:	29008226 	beq	r5,r4,2013b7c <_fpadd_parts+0x2fc>
 2013974:	31400217 	ldw	r5,8(r6)
 2013978:	02840034 	movhi	r10,4096
 201397c:	52bfffc4 	addi	r10,r10,-1
 2013980:	033fff84 	movi	r12,-2
 2013984:	297fffc4 	addi	r5,r5,-1
 2013988:	00000106 	br	2013990 <_fpadd_parts+0x110>
 201398c:	3a804a26 	beq	r7,r10,2013ab8 <_fpadd_parts+0x238>
 2013990:	1089883a 	add	r4,r2,r2
 2013994:	2091803a 	cmpltu	r8,r4,r2
 2013998:	18c7883a 	add	r3,r3,r3
 201399c:	227fffc4 	addi	r9,r4,-1
 20139a0:	40d1883a 	add	r8,r8,r3
 20139a4:	490f403a 	cmpgeu	r7,r9,r4
 20139a8:	41cfc83a 	sub	r7,r8,r7
 20139ac:	2817883a 	mov	r11,r5
 20139b0:	2005883a 	mov	r2,r4
 20139b4:	4007883a 	mov	r3,r8
 20139b8:	297fffc4 	addi	r5,r5,-1
 20139bc:	51fff32e 	bgeu	r10,r7,201398c <_fpadd_parts+0x10c>
 20139c0:	31000315 	stw	r4,12(r6)
 20139c4:	32000415 	stw	r8,16(r6)
 20139c8:	32c00215 	stw	r11,8(r6)
 20139cc:	010000c4 	movi	r4,3
 20139d0:	31000015 	stw	r4,0(r6)
 20139d4:	01080034 	movhi	r4,8192
 20139d8:	213fffc4 	addi	r4,r4,-1
 20139dc:	20c00b2e 	bgeu	r4,r3,2013a0c <_fpadd_parts+0x18c>
 20139e0:	180e97fa 	slli	r7,r3,31
 20139e4:	1008d07a 	srli	r4,r2,1
 20139e8:	31400217 	ldw	r5,8(r6)
 20139ec:	1806d07a 	srli	r3,r3,1
 20139f0:	1080004c 	andi	r2,r2,1
 20139f4:	3908b03a 	or	r4,r7,r4
 20139f8:	1108b03a 	or	r4,r2,r4
 20139fc:	29400044 	addi	r5,r5,1
 2013a00:	31000315 	stw	r4,12(r6)
 2013a04:	30c00415 	stw	r3,16(r6)
 2013a08:	31400215 	stw	r5,8(r6)
 2013a0c:	3005883a 	mov	r2,r6
 2013a10:	f800283a 	ret
 2013a14:	2805883a 	mov	r2,r5
 2013a18:	f800283a 	ret
 2013a1c:	59c01e0e 	bge	r11,r7,2013a98 <_fpadd_parts+0x218>
 2013a20:	11000117 	ldw	r4,4(r2)
 2013a24:	28800117 	ldw	r2,4(r5)
 2013a28:	0011883a 	mov	r8,zero
 2013a2c:	0013883a 	mov	r9,zero
 2013a30:	20bfbf1e 	bne	r4,r2,2013930 <_fpadd_parts+0xb0>
 2013a34:	4305883a 	add	r2,r8,r12
 2013a38:	1207803a 	cmpltu	r3,r2,r8
 2013a3c:	4b53883a 	add	r9,r9,r13
 2013a40:	1a47883a 	add	r3,r3,r9
 2013a44:	31000115 	stw	r4,4(r6)
 2013a48:	31c00215 	stw	r7,8(r6)
 2013a4c:	30800315 	stw	r2,12(r6)
 2013a50:	30c00415 	stw	r3,16(r6)
 2013a54:	003fdd06 	br	20139cc <_fpadd_parts+0x14c>
 2013a58:	20ffef1e 	bne	r4,r3,2013a18 <_fpadd_parts+0x198>
 2013a5c:	31000015 	stw	r4,0(r6)
 2013a60:	10c00117 	ldw	r3,4(r2)
 2013a64:	30c00115 	stw	r3,4(r6)
 2013a68:	10c00217 	ldw	r3,8(r2)
 2013a6c:	11000117 	ldw	r4,4(r2)
 2013a70:	29400117 	ldw	r5,4(r5)
 2013a74:	30c00215 	stw	r3,8(r6)
 2013a78:	10c00317 	ldw	r3,12(r2)
 2013a7c:	2908703a 	and	r4,r5,r4
 2013a80:	30c00315 	stw	r3,12(r6)
 2013a84:	10c00417 	ldw	r3,16(r2)
 2013a88:	31000115 	stw	r4,4(r6)
 2013a8c:	3005883a 	mov	r2,r6
 2013a90:	30c00415 	stw	r3,16(r6)
 2013a94:	f800283a 	ret
 2013a98:	580f883a 	mov	r7,r11
 2013a9c:	0019883a 	mov	r12,zero
 2013aa0:	001b883a 	mov	r13,zero
 2013aa4:	003f9f06 	br	2013924 <_fpadd_parts+0xa4>
 2013aa8:	0115c83a 	sub	r10,zero,r4
 2013aac:	00c00fc4 	movi	r3,63
 2013ab0:	1abfda16 	blt	r3,r10,2013a1c <_fpadd_parts+0x19c>
 2013ab4:	003f8906 	br	20138dc <_fpadd_parts+0x5c>
 2013ab8:	627fb52e 	bgeu	r12,r9,2013990 <_fpadd_parts+0x110>
 2013abc:	003fc006 	br	20139c0 <_fpadd_parts+0x140>
 2013ac0:	6205c83a 	sub	r2,r12,r8
 2013ac4:	6099803a 	cmpltu	r12,r12,r2
 2013ac8:	6a47c83a 	sub	r3,r13,r9
 2013acc:	1b07c83a 	sub	r3,r3,r12
 2013ad0:	183f9d0e 	bge	r3,zero,2013948 <_fpadd_parts+0xc8>
 2013ad4:	0085c83a 	sub	r2,zero,r2
 2013ad8:	1008c03a 	cmpne	r4,r2,zero
 2013adc:	00c7c83a 	sub	r3,zero,r3
 2013ae0:	1907c83a 	sub	r3,r3,r4
 2013ae4:	01000044 	movi	r4,1
 2013ae8:	31000115 	stw	r4,4(r6)
 2013aec:	31c00215 	stw	r7,8(r6)
 2013af0:	30800315 	stw	r2,12(r6)
 2013af4:	30c00415 	stw	r3,16(r6)
 2013af8:	003f9706 	br	2013958 <_fpadd_parts+0xd8>
 2013afc:	203f8926 	beq	r4,zero,2013924 <_fpadd_parts+0xa4>
 2013b00:	50fff804 	addi	r3,r10,-32
 2013b04:	3a8f883a 	add	r7,r7,r10
 2013b08:	18002316 	blt	r3,zero,2013b98 <_fpadd_parts+0x318>
 2013b0c:	68d6d83a 	srl	r11,r13,r3
 2013b10:	001d883a 	mov	r14,zero
 2013b14:	18001c16 	blt	r3,zero,2013b88 <_fpadd_parts+0x308>
 2013b18:	01000044 	movi	r4,1
 2013b1c:	20c6983a 	sll	r3,r4,r3
 2013b20:	0015883a 	mov	r10,zero
 2013b24:	513fffc4 	addi	r4,r10,-1
 2013b28:	2295403a 	cmpgeu	r10,r4,r10
 2013b2c:	1a87c83a 	sub	r3,r3,r10
 2013b30:	1b5a703a 	and	r13,r3,r13
 2013b34:	2318703a 	and	r12,r4,r12
 2013b38:	6358b03a 	or	r12,r12,r13
 2013b3c:	6018c03a 	cmpne	r12,r12,zero
 2013b40:	62d8b03a 	or	r12,r12,r11
 2013b44:	701b883a 	mov	r13,r14
 2013b48:	003f7606 	br	2013924 <_fpadd_parts+0xa4>
 2013b4c:	4808907a 	slli	r4,r9,1
 2013b50:	02c007c4 	movi	r11,31
 2013b54:	5a97c83a 	sub	r11,r11,r10
 2013b58:	22c8983a 	sll	r4,r4,r11
 2013b5c:	4296d83a 	srl	r11,r8,r10
 2013b60:	4a9cd83a 	srl	r14,r9,r10
 2013b64:	22d6b03a 	or	r11,r4,r11
 2013b68:	003f6106 	br	20138f0 <_fpadd_parts+0x70>
 2013b6c:	00c00044 	movi	r3,1
 2013b70:	1a94983a 	sll	r10,r3,r10
 2013b74:	0007883a 	mov	r3,zero
 2013b78:	003f6106 	br	2013900 <_fpadd_parts+0x80>
 2013b7c:	013fff84 	movi	r4,-2
 2013b80:	21ff7c2e 	bgeu	r4,r7,2013974 <_fpadd_parts+0xf4>
 2013b84:	003f9106 	br	20139cc <_fpadd_parts+0x14c>
 2013b88:	00c00044 	movi	r3,1
 2013b8c:	1a94983a 	sll	r10,r3,r10
 2013b90:	0007883a 	mov	r3,zero
 2013b94:	003fe306 	br	2013b24 <_fpadd_parts+0x2a4>
 2013b98:	6816907a 	slli	r11,r13,1
 2013b9c:	010007c4 	movi	r4,31
 2013ba0:	2289c83a 	sub	r4,r4,r10
 2013ba4:	5908983a 	sll	r4,r11,r4
 2013ba8:	6296d83a 	srl	r11,r12,r10
 2013bac:	6a9cd83a 	srl	r14,r13,r10
 2013bb0:	22d6b03a 	or	r11,r4,r11
 2013bb4:	003fd706 	br	2013b14 <_fpadd_parts+0x294>
 2013bb8:	193f971e 	bne	r3,r4,2013a18 <_fpadd_parts+0x198>
 2013bbc:	11000117 	ldw	r4,4(r2)
 2013bc0:	28c00117 	ldw	r3,4(r5)
 2013bc4:	20ff9426 	beq	r4,r3,2013a18 <_fpadd_parts+0x198>
 2013bc8:	00808174 	movhi	r2,517
 2013bcc:	10b81904 	addi	r2,r2,-8092
 2013bd0:	f800283a 	ret

02013bd4 <__adddf3>:
 2013bd4:	deffec04 	addi	sp,sp,-80
 2013bd8:	d9001115 	stw	r4,68(sp)
 2013bdc:	d9401215 	stw	r5,72(sp)
 2013be0:	d9001104 	addi	r4,sp,68
 2013be4:	d9400a04 	addi	r5,sp,40
 2013be8:	dfc01315 	stw	ra,76(sp)
 2013bec:	d9c01015 	stw	r7,64(sp)
 2013bf0:	d9800f15 	stw	r6,60(sp)
 2013bf4:	2014c2c0 	call	2014c2c <__unpack_d>
 2013bf8:	d9000f04 	addi	r4,sp,60
 2013bfc:	d9400504 	addi	r5,sp,20
 2013c00:	2014c2c0 	call	2014c2c <__unpack_d>
 2013c04:	d9000a04 	addi	r4,sp,40
 2013c08:	d9400504 	addi	r5,sp,20
 2013c0c:	d80d883a 	mov	r6,sp
 2013c10:	20138800 	call	2013880 <_fpadd_parts>
 2013c14:	1009883a 	mov	r4,r2
 2013c18:	2014a080 	call	2014a08 <__pack_d>
 2013c1c:	dfc01317 	ldw	ra,76(sp)
 2013c20:	dec01404 	addi	sp,sp,80
 2013c24:	f800283a 	ret

02013c28 <__subdf3>:
 2013c28:	deffec04 	addi	sp,sp,-80
 2013c2c:	d9001115 	stw	r4,68(sp)
 2013c30:	d9401215 	stw	r5,72(sp)
 2013c34:	d9001104 	addi	r4,sp,68
 2013c38:	d9400a04 	addi	r5,sp,40
 2013c3c:	dfc01315 	stw	ra,76(sp)
 2013c40:	d9c01015 	stw	r7,64(sp)
 2013c44:	d9800f15 	stw	r6,60(sp)
 2013c48:	2014c2c0 	call	2014c2c <__unpack_d>
 2013c4c:	d9000f04 	addi	r4,sp,60
 2013c50:	d9400504 	addi	r5,sp,20
 2013c54:	2014c2c0 	call	2014c2c <__unpack_d>
 2013c58:	d8800617 	ldw	r2,24(sp)
 2013c5c:	d9000a04 	addi	r4,sp,40
 2013c60:	d9400504 	addi	r5,sp,20
 2013c64:	d80d883a 	mov	r6,sp
 2013c68:	1080005c 	xori	r2,r2,1
 2013c6c:	d8800615 	stw	r2,24(sp)
 2013c70:	20138800 	call	2013880 <_fpadd_parts>
 2013c74:	1009883a 	mov	r4,r2
 2013c78:	2014a080 	call	2014a08 <__pack_d>
 2013c7c:	dfc01317 	ldw	ra,76(sp)
 2013c80:	dec01404 	addi	sp,sp,80
 2013c84:	f800283a 	ret

02013c88 <__muldf3>:
 2013c88:	deffe404 	addi	sp,sp,-112
 2013c8c:	d9001115 	stw	r4,68(sp)
 2013c90:	d9401215 	stw	r5,72(sp)
 2013c94:	d9001104 	addi	r4,sp,68
 2013c98:	d9400a04 	addi	r5,sp,40
 2013c9c:	dfc01b15 	stw	ra,108(sp)
 2013ca0:	d9800f15 	stw	r6,60(sp)
 2013ca4:	d9c01015 	stw	r7,64(sp)
 2013ca8:	ddc01a15 	stw	r23,104(sp)
 2013cac:	dd801915 	stw	r22,100(sp)
 2013cb0:	dd401815 	stw	r21,96(sp)
 2013cb4:	dd001715 	stw	r20,92(sp)
 2013cb8:	dcc01615 	stw	r19,88(sp)
 2013cbc:	dc801515 	stw	r18,84(sp)
 2013cc0:	dc401415 	stw	r17,80(sp)
 2013cc4:	dc001315 	stw	r16,76(sp)
 2013cc8:	2014c2c0 	call	2014c2c <__unpack_d>
 2013ccc:	d9000f04 	addi	r4,sp,60
 2013cd0:	d9400504 	addi	r5,sp,20
 2013cd4:	2014c2c0 	call	2014c2c <__unpack_d>
 2013cd8:	d8c00a17 	ldw	r3,40(sp)
 2013cdc:	00800044 	movi	r2,1
 2013ce0:	10c01136 	bltu	r2,r3,2013d28 <__muldf3+0xa0>
 2013ce4:	d8c00b17 	ldw	r3,44(sp)
 2013ce8:	d8800617 	ldw	r2,24(sp)
 2013cec:	d9000a04 	addi	r4,sp,40
 2013cf0:	1884c03a 	cmpne	r2,r3,r2
 2013cf4:	d8800b15 	stw	r2,44(sp)
 2013cf8:	2014a080 	call	2014a08 <__pack_d>
 2013cfc:	dfc01b17 	ldw	ra,108(sp)
 2013d00:	ddc01a17 	ldw	r23,104(sp)
 2013d04:	dd801917 	ldw	r22,100(sp)
 2013d08:	dd401817 	ldw	r21,96(sp)
 2013d0c:	dd001717 	ldw	r20,92(sp)
 2013d10:	dcc01617 	ldw	r19,88(sp)
 2013d14:	dc801517 	ldw	r18,84(sp)
 2013d18:	dc401417 	ldw	r17,80(sp)
 2013d1c:	dc001317 	ldw	r16,76(sp)
 2013d20:	dec01c04 	addi	sp,sp,112
 2013d24:	f800283a 	ret
 2013d28:	d9000517 	ldw	r4,20(sp)
 2013d2c:	11000636 	bltu	r2,r4,2013d48 <__muldf3+0xc0>
 2013d30:	d8800617 	ldw	r2,24(sp)
 2013d34:	d8c00b17 	ldw	r3,44(sp)
 2013d38:	d9000504 	addi	r4,sp,20
 2013d3c:	1884c03a 	cmpne	r2,r3,r2
 2013d40:	d8800615 	stw	r2,24(sp)
 2013d44:	003fec06 	br	2013cf8 <__muldf3+0x70>
 2013d48:	00800104 	movi	r2,4
 2013d4c:	1880051e 	bne	r3,r2,2013d64 <__muldf3+0xdc>
 2013d50:	00800084 	movi	r2,2
 2013d54:	20bfe31e 	bne	r4,r2,2013ce4 <__muldf3+0x5c>
 2013d58:	01008174 	movhi	r4,517
 2013d5c:	21381904 	addi	r4,r4,-8092
 2013d60:	003fe506 	br	2013cf8 <__muldf3+0x70>
 2013d64:	2080031e 	bne	r4,r2,2013d74 <__muldf3+0xec>
 2013d68:	00800084 	movi	r2,2
 2013d6c:	18bffa26 	beq	r3,r2,2013d58 <__muldf3+0xd0>
 2013d70:	003fef06 	br	2013d30 <__muldf3+0xa8>
 2013d74:	00800084 	movi	r2,2
 2013d78:	18bfda26 	beq	r3,r2,2013ce4 <__muldf3+0x5c>
 2013d7c:	20bfec26 	beq	r4,r2,2013d30 <__muldf3+0xa8>
 2013d80:	dc000d17 	ldw	r16,52(sp)
 2013d84:	dd000817 	ldw	r20,32(sp)
 2013d88:	dc800917 	ldw	r18,36(sp)
 2013d8c:	8009883a 	mov	r4,r16
 2013d90:	000b883a 	mov	r5,zero
 2013d94:	a00d883a 	mov	r6,r20
 2013d98:	000f883a 	mov	r7,zero
 2013d9c:	2012b440 	call	2012b44 <__muldi3>
 2013da0:	dc400e17 	ldw	r17,56(sp)
 2013da4:	9009883a 	mov	r4,r18
 2013da8:	800d883a 	mov	r6,r16
 2013dac:	000b883a 	mov	r5,zero
 2013db0:	000f883a 	mov	r7,zero
 2013db4:	102f883a 	mov	r23,r2
 2013db8:	1827883a 	mov	r19,r3
 2013dbc:	2012b440 	call	2012b44 <__muldi3>
 2013dc0:	900d883a 	mov	r6,r18
 2013dc4:	8809883a 	mov	r4,r17
 2013dc8:	000b883a 	mov	r5,zero
 2013dcc:	000f883a 	mov	r7,zero
 2013dd0:	102b883a 	mov	r21,r2
 2013dd4:	1821883a 	mov	r16,r3
 2013dd8:	2012b440 	call	2012b44 <__muldi3>
 2013ddc:	8809883a 	mov	r4,r17
 2013de0:	000b883a 	mov	r5,zero
 2013de4:	a00d883a 	mov	r6,r20
 2013de8:	000f883a 	mov	r7,zero
 2013dec:	102d883a 	mov	r22,r2
 2013df0:	1825883a 	mov	r18,r3
 2013df4:	2012b440 	call	2012b44 <__muldi3>
 2013df8:	154b883a 	add	r5,r2,r21
 2013dfc:	2889803a 	cmpltu	r4,r5,r2
 2013e00:	1c07883a 	add	r3,r3,r16
 2013e04:	20c9883a 	add	r4,r4,r3
 2013e08:	24004b36 	bltu	r4,r16,2013f38 <__muldf3+0x2b0>
 2013e0c:	8100011e 	bne	r16,r4,2013e14 <__muldf3+0x18c>
 2013e10:	2d404936 	bltu	r5,r21,2013f38 <__muldf3+0x2b0>
 2013e14:	0011883a 	mov	r8,zero
 2013e18:	0007883a 	mov	r3,zero
 2013e1c:	2ccb883a 	add	r5,r5,r19
 2013e20:	b80d883a 	mov	r6,r23
 2013e24:	2cc0012e 	bgeu	r5,r19,2013e2c <__muldf3+0x1a4>
 2013e28:	02000044 	movi	r8,1
 2013e2c:	258f883a 	add	r7,r4,r22
 2013e30:	3909803a 	cmpltu	r4,r7,r4
 2013e34:	da400c17 	ldw	r9,48(sp)
 2013e38:	2489883a 	add	r4,r4,r18
 2013e3c:	d8800717 	ldw	r2,28(sp)
 2013e40:	20c9883a 	add	r4,r4,r3
 2013e44:	da800b17 	ldw	r10,44(sp)
 2013e48:	d8c00617 	ldw	r3,24(sp)
 2013e4c:	3a11883a 	add	r8,r7,r8
 2013e50:	4885883a 	add	r2,r9,r2
 2013e54:	50c6c03a 	cmpne	r3,r10,r3
 2013e58:	41cf803a 	cmpltu	r7,r8,r7
 2013e5c:	12400104 	addi	r9,r2,4
 2013e60:	d8c00115 	stw	r3,4(sp)
 2013e64:	3909883a 	add	r4,r7,r4
 2013e68:	da400215 	stw	r9,8(sp)
 2013e6c:	03480034 	movhi	r13,8192
 2013e70:	6b7fffc4 	addi	r13,r13,-1
 2013e74:	4007883a 	mov	r3,r8
 2013e78:	6900102e 	bgeu	r13,r4,2013ebc <__muldf3+0x234>
 2013e7c:	10800144 	addi	r2,r2,5
 2013e80:	180ed07a 	srli	r7,r3,1
 2013e84:	18c0004c 	andi	r3,r3,1
 2013e88:	201097fa 	slli	r8,r4,31
 2013e8c:	281697fa 	slli	r11,r5,31
 2013e90:	2008d07a 	srli	r4,r4,1
 2013e94:	3014d07a 	srli	r10,r6,1
 2013e98:	2812d07a 	srli	r9,r5,1
 2013e9c:	1019883a 	mov	r12,r2
 2013ea0:	18000226 	beq	r3,zero,2013eac <__muldf3+0x224>
 2013ea4:	5a8cb03a 	or	r6,r11,r10
 2013ea8:	49600034 	orhi	r5,r9,32768
 2013eac:	41c6b03a 	or	r3,r8,r7
 2013eb0:	10800044 	addi	r2,r2,1
 2013eb4:	693ff236 	bltu	r13,r4,2013e80 <__muldf3+0x1f8>
 2013eb8:	db000215 	stw	r12,8(sp)
 2013ebc:	03440034 	movhi	r13,4096
 2013ec0:	6b7fffc4 	addi	r13,r13,-1
 2013ec4:	69001336 	bltu	r13,r4,2013f14 <__muldf3+0x28c>
 2013ec8:	d8800217 	ldw	r2,8(sp)
 2013ecc:	10bfffc4 	addi	r2,r2,-1
 2013ed0:	18d3883a 	add	r9,r3,r3
 2013ed4:	48c7803a 	cmpltu	r3,r9,r3
 2013ed8:	2109883a 	add	r4,r4,r4
 2013edc:	190f883a 	add	r7,r3,r4
 2013ee0:	3191883a 	add	r8,r6,r6
 2013ee4:	4197803a 	cmpltu	r11,r8,r6
 2013ee8:	2955883a 	add	r10,r5,r5
 2013eec:	1019883a 	mov	r12,r2
 2013ef0:	4807883a 	mov	r3,r9
 2013ef4:	3809883a 	mov	r4,r7
 2013ef8:	2800010e 	bge	r5,zero,2013f00 <__muldf3+0x278>
 2013efc:	48c00054 	ori	r3,r9,1
 2013f00:	400d883a 	mov	r6,r8
 2013f04:	5a8b883a 	add	r5,r11,r10
 2013f08:	10bfffc4 	addi	r2,r2,-1
 2013f0c:	69fff02e 	bgeu	r13,r7,2013ed0 <__muldf3+0x248>
 2013f10:	db000215 	stw	r12,8(sp)
 2013f14:	18803fcc 	andi	r2,r3,255
 2013f18:	01c02004 	movi	r7,128
 2013f1c:	11c00926 	beq	r2,r7,2013f44 <__muldf3+0x2bc>
 2013f20:	008000c4 	movi	r2,3
 2013f24:	d9000415 	stw	r4,16(sp)
 2013f28:	d8c00315 	stw	r3,12(sp)
 2013f2c:	d8800015 	stw	r2,0(sp)
 2013f30:	d809883a 	mov	r4,sp
 2013f34:	003f7006 	br	2013cf8 <__muldf3+0x70>
 2013f38:	0011883a 	mov	r8,zero
 2013f3c:	00c00044 	movi	r3,1
 2013f40:	003fb606 	br	2013e1c <__muldf3+0x194>
 2013f44:	19c0400c 	andi	r7,r3,256
 2013f48:	383ff51e 	bne	r7,zero,2013f20 <__muldf3+0x298>
 2013f4c:	314ab03a 	or	r5,r6,r5
 2013f50:	283ff326 	beq	r5,zero,2013f20 <__muldf3+0x298>
 2013f54:	1885883a 	add	r2,r3,r2
 2013f58:	10cb803a 	cmpltu	r5,r2,r3
 2013f5c:	00ffc004 	movi	r3,-256
 2013f60:	10c6703a 	and	r3,r2,r3
 2013f64:	2909883a 	add	r4,r5,r4
 2013f68:	003fed06 	br	2013f20 <__muldf3+0x298>

02013f6c <__divdf3>:
 2013f6c:	defff104 	addi	sp,sp,-60
 2013f70:	d9000c15 	stw	r4,48(sp)
 2013f74:	d9400d15 	stw	r5,52(sp)
 2013f78:	d9000c04 	addi	r4,sp,48
 2013f7c:	d9400504 	addi	r5,sp,20
 2013f80:	dfc00e15 	stw	ra,56(sp)
 2013f84:	d9800a15 	stw	r6,40(sp)
 2013f88:	d9c00b15 	stw	r7,44(sp)
 2013f8c:	2014c2c0 	call	2014c2c <__unpack_d>
 2013f90:	d9000a04 	addi	r4,sp,40
 2013f94:	d80b883a 	mov	r5,sp
 2013f98:	2014c2c0 	call	2014c2c <__unpack_d>
 2013f9c:	d8c00517 	ldw	r3,20(sp)
 2013fa0:	00800044 	movi	r2,1
 2013fa4:	10c00536 	bltu	r2,r3,2013fbc <__divdf3+0x50>
 2013fa8:	d9000504 	addi	r4,sp,20
 2013fac:	2014a080 	call	2014a08 <__pack_d>
 2013fb0:	dfc00e17 	ldw	ra,56(sp)
 2013fb4:	dec00f04 	addi	sp,sp,60
 2013fb8:	f800283a 	ret
 2013fbc:	d9000017 	ldw	r4,0(sp)
 2013fc0:	11000536 	bltu	r2,r4,2013fd8 <__divdf3+0x6c>
 2013fc4:	d809883a 	mov	r4,sp
 2013fc8:	2014a080 	call	2014a08 <__pack_d>
 2013fcc:	dfc00e17 	ldw	ra,56(sp)
 2013fd0:	dec00f04 	addi	sp,sp,60
 2013fd4:	f800283a 	ret
 2013fd8:	d9800617 	ldw	r6,24(sp)
 2013fdc:	d9400117 	ldw	r5,4(sp)
 2013fe0:	00800104 	movi	r2,4
 2013fe4:	314af03a 	xor	r5,r6,r5
 2013fe8:	d9400615 	stw	r5,24(sp)
 2013fec:	18800226 	beq	r3,r2,2013ff8 <__divdf3+0x8c>
 2013ff0:	01400084 	movi	r5,2
 2013ff4:	1940041e 	bne	r3,r5,2014008 <__divdf3+0x9c>
 2013ff8:	193feb1e 	bne	r3,r4,2013fa8 <__divdf3+0x3c>
 2013ffc:	01008174 	movhi	r4,517
 2014000:	21381904 	addi	r4,r4,-8092
 2014004:	003fe906 	br	2013fac <__divdf3+0x40>
 2014008:	20803326 	beq	r4,r2,20140d8 <__divdf3+0x16c>
 201400c:	21403726 	beq	r4,r5,20140ec <__divdf3+0x180>
 2014010:	d8800217 	ldw	r2,8(sp)
 2014014:	d9000717 	ldw	r4,28(sp)
 2014018:	d8c00917 	ldw	r3,36(sp)
 201401c:	da000417 	ldw	r8,16(sp)
 2014020:	2089c83a 	sub	r4,r4,r2
 2014024:	d9000715 	stw	r4,28(sp)
 2014028:	d8800817 	ldw	r2,32(sp)
 201402c:	dbc00317 	ldw	r15,12(sp)
 2014030:	1a000236 	bltu	r3,r8,201403c <__divdf3+0xd0>
 2014034:	40c0081e 	bne	r8,r3,2014058 <__divdf3+0xec>
 2014038:	13c0072e 	bgeu	r2,r15,2014058 <__divdf3+0xec>
 201403c:	108b883a 	add	r5,r2,r2
 2014040:	288d803a 	cmpltu	r6,r5,r2
 2014044:	18c7883a 	add	r3,r3,r3
 2014048:	213fffc4 	addi	r4,r4,-1
 201404c:	2805883a 	mov	r2,r5
 2014050:	30c7883a 	add	r3,r6,r3
 2014054:	d9000715 	stw	r4,28(sp)
 2014058:	01400f44 	movi	r5,61
 201405c:	000f883a 	mov	r7,zero
 2014060:	01040034 	movhi	r4,4096
 2014064:	0019883a 	mov	r12,zero
 2014068:	001b883a 	mov	r13,zero
 201406c:	201697fa 	slli	r11,r4,31
 2014070:	3814d07a 	srli	r10,r7,1
 2014074:	297fffc4 	addi	r5,r5,-1
 2014078:	1a000936 	bltu	r3,r8,20140a0 <__divdf3+0x134>
 201407c:	13cdc83a 	sub	r6,r2,r15
 2014080:	1193803a 	cmpltu	r9,r2,r6
 2014084:	1a1dc83a 	sub	r14,r3,r8
 2014088:	40c0011e 	bne	r8,r3,2014090 <__divdf3+0x124>
 201408c:	13c00436 	bltu	r2,r15,20140a0 <__divdf3+0x134>
 2014090:	3005883a 	mov	r2,r6
 2014094:	7247c83a 	sub	r3,r14,r9
 2014098:	61d8b03a 	or	r12,r12,r7
 201409c:	691ab03a 	or	r13,r13,r4
 20140a0:	108d883a 	add	r6,r2,r2
 20140a4:	3093803a 	cmpltu	r9,r6,r2
 20140a8:	18c7883a 	add	r3,r3,r3
 20140ac:	5a8eb03a 	or	r7,r11,r10
 20140b0:	2008d07a 	srli	r4,r4,1
 20140b4:	3005883a 	mov	r2,r6
 20140b8:	48c7883a 	add	r3,r9,r3
 20140bc:	283feb1e 	bne	r5,zero,201406c <__divdf3+0x100>
 20140c0:	61003fcc 	andi	r4,r12,255
 20140c4:	01402004 	movi	r5,128
 20140c8:	21400b26 	beq	r4,r5,20140f8 <__divdf3+0x18c>
 20140cc:	db000815 	stw	r12,32(sp)
 20140d0:	db400915 	stw	r13,36(sp)
 20140d4:	003fb406 	br	2013fa8 <__divdf3+0x3c>
 20140d8:	d8000815 	stw	zero,32(sp)
 20140dc:	d8000915 	stw	zero,36(sp)
 20140e0:	d8000715 	stw	zero,28(sp)
 20140e4:	d9000504 	addi	r4,sp,20
 20140e8:	003fb006 	br	2013fac <__divdf3+0x40>
 20140ec:	d8800515 	stw	r2,20(sp)
 20140f0:	d9000504 	addi	r4,sp,20
 20140f4:	003fad06 	br	2013fac <__divdf3+0x40>
 20140f8:	6140400c 	andi	r5,r12,256
 20140fc:	283ff31e 	bne	r5,zero,20140cc <__divdf3+0x160>
 2014100:	30c4b03a 	or	r2,r6,r3
 2014104:	103ff126 	beq	r2,zero,20140cc <__divdf3+0x160>
 2014108:	6109883a 	add	r4,r12,r4
 201410c:	2305803a 	cmpltu	r2,r4,r12
 2014110:	033fc004 	movi	r12,-256
 2014114:	2318703a 	and	r12,r4,r12
 2014118:	135b883a 	add	r13,r2,r13
 201411c:	003feb06 	br	20140cc <__divdf3+0x160>

02014120 <__eqdf2>:
 2014120:	defff104 	addi	sp,sp,-60
 2014124:	d9000c15 	stw	r4,48(sp)
 2014128:	d9400d15 	stw	r5,52(sp)
 201412c:	d9000c04 	addi	r4,sp,48
 2014130:	d9400504 	addi	r5,sp,20
 2014134:	dfc00e15 	stw	ra,56(sp)
 2014138:	d9800a15 	stw	r6,40(sp)
 201413c:	d9c00b15 	stw	r7,44(sp)
 2014140:	2014c2c0 	call	2014c2c <__unpack_d>
 2014144:	d9000a04 	addi	r4,sp,40
 2014148:	d80b883a 	mov	r5,sp
 201414c:	2014c2c0 	call	2014c2c <__unpack_d>
 2014150:	d8c00517 	ldw	r3,20(sp)
 2014154:	00800044 	movi	r2,1
 2014158:	10c0052e 	bgeu	r2,r3,2014170 <__eqdf2+0x50>
 201415c:	d8c00017 	ldw	r3,0(sp)
 2014160:	10c0032e 	bgeu	r2,r3,2014170 <__eqdf2+0x50>
 2014164:	d9000504 	addi	r4,sp,20
 2014168:	d80b883a 	mov	r5,sp
 201416c:	2014d300 	call	2014d30 <__fpcmp_parts_d>
 2014170:	dfc00e17 	ldw	ra,56(sp)
 2014174:	dec00f04 	addi	sp,sp,60
 2014178:	f800283a 	ret

0201417c <__nedf2>:
 201417c:	defff104 	addi	sp,sp,-60
 2014180:	d9000c15 	stw	r4,48(sp)
 2014184:	d9400d15 	stw	r5,52(sp)
 2014188:	d9000c04 	addi	r4,sp,48
 201418c:	d9400504 	addi	r5,sp,20
 2014190:	dfc00e15 	stw	ra,56(sp)
 2014194:	d9800a15 	stw	r6,40(sp)
 2014198:	d9c00b15 	stw	r7,44(sp)
 201419c:	2014c2c0 	call	2014c2c <__unpack_d>
 20141a0:	d9000a04 	addi	r4,sp,40
 20141a4:	d80b883a 	mov	r5,sp
 20141a8:	2014c2c0 	call	2014c2c <__unpack_d>
 20141ac:	d8c00517 	ldw	r3,20(sp)
 20141b0:	00800044 	movi	r2,1
 20141b4:	10c0052e 	bgeu	r2,r3,20141cc <__nedf2+0x50>
 20141b8:	d8c00017 	ldw	r3,0(sp)
 20141bc:	10c0032e 	bgeu	r2,r3,20141cc <__nedf2+0x50>
 20141c0:	d9000504 	addi	r4,sp,20
 20141c4:	d80b883a 	mov	r5,sp
 20141c8:	2014d300 	call	2014d30 <__fpcmp_parts_d>
 20141cc:	dfc00e17 	ldw	ra,56(sp)
 20141d0:	dec00f04 	addi	sp,sp,60
 20141d4:	f800283a 	ret

020141d8 <__gtdf2>:
 20141d8:	defff104 	addi	sp,sp,-60
 20141dc:	d9000c15 	stw	r4,48(sp)
 20141e0:	d9400d15 	stw	r5,52(sp)
 20141e4:	d9000c04 	addi	r4,sp,48
 20141e8:	d9400504 	addi	r5,sp,20
 20141ec:	dfc00e15 	stw	ra,56(sp)
 20141f0:	d9800a15 	stw	r6,40(sp)
 20141f4:	d9c00b15 	stw	r7,44(sp)
 20141f8:	2014c2c0 	call	2014c2c <__unpack_d>
 20141fc:	d9000a04 	addi	r4,sp,40
 2014200:	d80b883a 	mov	r5,sp
 2014204:	2014c2c0 	call	2014c2c <__unpack_d>
 2014208:	d8c00517 	ldw	r3,20(sp)
 201420c:	00800044 	movi	r2,1
 2014210:	10c0082e 	bgeu	r2,r3,2014234 <__gtdf2+0x5c>
 2014214:	d8c00017 	ldw	r3,0(sp)
 2014218:	10c0062e 	bgeu	r2,r3,2014234 <__gtdf2+0x5c>
 201421c:	d9000504 	addi	r4,sp,20
 2014220:	d80b883a 	mov	r5,sp
 2014224:	2014d300 	call	2014d30 <__fpcmp_parts_d>
 2014228:	dfc00e17 	ldw	ra,56(sp)
 201422c:	dec00f04 	addi	sp,sp,60
 2014230:	f800283a 	ret
 2014234:	00bfffc4 	movi	r2,-1
 2014238:	003ffb06 	br	2014228 <__gtdf2+0x50>

0201423c <__gedf2>:
 201423c:	defff104 	addi	sp,sp,-60
 2014240:	d9000c15 	stw	r4,48(sp)
 2014244:	d9400d15 	stw	r5,52(sp)
 2014248:	d9000c04 	addi	r4,sp,48
 201424c:	d9400504 	addi	r5,sp,20
 2014250:	dfc00e15 	stw	ra,56(sp)
 2014254:	d9800a15 	stw	r6,40(sp)
 2014258:	d9c00b15 	stw	r7,44(sp)
 201425c:	2014c2c0 	call	2014c2c <__unpack_d>
 2014260:	d9000a04 	addi	r4,sp,40
 2014264:	d80b883a 	mov	r5,sp
 2014268:	2014c2c0 	call	2014c2c <__unpack_d>
 201426c:	d8c00517 	ldw	r3,20(sp)
 2014270:	00800044 	movi	r2,1
 2014274:	10c0082e 	bgeu	r2,r3,2014298 <__gedf2+0x5c>
 2014278:	d8c00017 	ldw	r3,0(sp)
 201427c:	10c0062e 	bgeu	r2,r3,2014298 <__gedf2+0x5c>
 2014280:	d9000504 	addi	r4,sp,20
 2014284:	d80b883a 	mov	r5,sp
 2014288:	2014d300 	call	2014d30 <__fpcmp_parts_d>
 201428c:	dfc00e17 	ldw	ra,56(sp)
 2014290:	dec00f04 	addi	sp,sp,60
 2014294:	f800283a 	ret
 2014298:	00bfffc4 	movi	r2,-1
 201429c:	003ffb06 	br	201428c <__gedf2+0x50>

020142a0 <__ltdf2>:
 20142a0:	defff104 	addi	sp,sp,-60
 20142a4:	d9000c15 	stw	r4,48(sp)
 20142a8:	d9400d15 	stw	r5,52(sp)
 20142ac:	d9000c04 	addi	r4,sp,48
 20142b0:	d9400504 	addi	r5,sp,20
 20142b4:	dfc00e15 	stw	ra,56(sp)
 20142b8:	d9800a15 	stw	r6,40(sp)
 20142bc:	d9c00b15 	stw	r7,44(sp)
 20142c0:	2014c2c0 	call	2014c2c <__unpack_d>
 20142c4:	d9000a04 	addi	r4,sp,40
 20142c8:	d80b883a 	mov	r5,sp
 20142cc:	2014c2c0 	call	2014c2c <__unpack_d>
 20142d0:	d8c00517 	ldw	r3,20(sp)
 20142d4:	00800044 	movi	r2,1
 20142d8:	10c0052e 	bgeu	r2,r3,20142f0 <__ltdf2+0x50>
 20142dc:	d8c00017 	ldw	r3,0(sp)
 20142e0:	10c0032e 	bgeu	r2,r3,20142f0 <__ltdf2+0x50>
 20142e4:	d9000504 	addi	r4,sp,20
 20142e8:	d80b883a 	mov	r5,sp
 20142ec:	2014d300 	call	2014d30 <__fpcmp_parts_d>
 20142f0:	dfc00e17 	ldw	ra,56(sp)
 20142f4:	dec00f04 	addi	sp,sp,60
 20142f8:	f800283a 	ret

020142fc <__ledf2>:
 20142fc:	defff104 	addi	sp,sp,-60
 2014300:	d9000c15 	stw	r4,48(sp)
 2014304:	d9400d15 	stw	r5,52(sp)
 2014308:	d9000c04 	addi	r4,sp,48
 201430c:	d9400504 	addi	r5,sp,20
 2014310:	dfc00e15 	stw	ra,56(sp)
 2014314:	d9800a15 	stw	r6,40(sp)
 2014318:	d9c00b15 	stw	r7,44(sp)
 201431c:	2014c2c0 	call	2014c2c <__unpack_d>
 2014320:	d9000a04 	addi	r4,sp,40
 2014324:	d80b883a 	mov	r5,sp
 2014328:	2014c2c0 	call	2014c2c <__unpack_d>
 201432c:	d8c00517 	ldw	r3,20(sp)
 2014330:	00800044 	movi	r2,1
 2014334:	10c0052e 	bgeu	r2,r3,201434c <__ledf2+0x50>
 2014338:	d8c00017 	ldw	r3,0(sp)
 201433c:	10c0032e 	bgeu	r2,r3,201434c <__ledf2+0x50>
 2014340:	d9000504 	addi	r4,sp,20
 2014344:	d80b883a 	mov	r5,sp
 2014348:	2014d300 	call	2014d30 <__fpcmp_parts_d>
 201434c:	dfc00e17 	ldw	ra,56(sp)
 2014350:	dec00f04 	addi	sp,sp,60
 2014354:	f800283a 	ret

02014358 <__floatsidf>:
 2014358:	2004d7fa 	srli	r2,r4,31
 201435c:	defff904 	addi	sp,sp,-28
 2014360:	00c000c4 	movi	r3,3
 2014364:	dfc00615 	stw	ra,24(sp)
 2014368:	dc000515 	stw	r16,20(sp)
 201436c:	d8c00015 	stw	r3,0(sp)
 2014370:	d8800115 	stw	r2,4(sp)
 2014374:	2000081e 	bne	r4,zero,2014398 <__floatsidf+0x40>
 2014378:	00800084 	movi	r2,2
 201437c:	d8800015 	stw	r2,0(sp)
 2014380:	d809883a 	mov	r4,sp
 2014384:	2014a080 	call	2014a08 <__pack_d>
 2014388:	dfc00617 	ldw	ra,24(sp)
 201438c:	dc000517 	ldw	r16,20(sp)
 2014390:	dec00704 	addi	sp,sp,28
 2014394:	f800283a 	ret
 2014398:	00c00f04 	movi	r3,60
 201439c:	d8c00215 	stw	r3,8(sp)
 20143a0:	10000f1e 	bne	r2,zero,20143e0 <__floatsidf+0x88>
 20143a4:	2021883a 	mov	r16,r4
 20143a8:	8009883a 	mov	r4,r16
 20143ac:	20147ac0 	call	20147ac <__clzsi2>
 20143b0:	11000744 	addi	r4,r2,29
 20143b4:	0100110e 	bge	zero,r4,20143fc <__floatsidf+0xa4>
 20143b8:	10ffff44 	addi	r3,r2,-3
 20143bc:	18001216 	blt	r3,zero,2014408 <__floatsidf+0xb0>
 20143c0:	80c6983a 	sll	r3,r16,r3
 20143c4:	0009883a 	mov	r4,zero
 20143c8:	014007c4 	movi	r5,31
 20143cc:	2885c83a 	sub	r2,r5,r2
 20143d0:	d9000315 	stw	r4,12(sp)
 20143d4:	d8c00415 	stw	r3,16(sp)
 20143d8:	d8800215 	stw	r2,8(sp)
 20143dc:	003fe806 	br	2014380 <__floatsidf+0x28>
 20143e0:	00a00034 	movhi	r2,32768
 20143e4:	20800e26 	beq	r4,r2,2014420 <__floatsidf+0xc8>
 20143e8:	0121c83a 	sub	r16,zero,r4
 20143ec:	8009883a 	mov	r4,r16
 20143f0:	20147ac0 	call	20147ac <__clzsi2>
 20143f4:	11000744 	addi	r4,r2,29
 20143f8:	013fef16 	blt	zero,r4,20143b8 <__floatsidf+0x60>
 20143fc:	dc000315 	stw	r16,12(sp)
 2014400:	d8000415 	stw	zero,16(sp)
 2014404:	003fde06 	br	2014380 <__floatsidf+0x28>
 2014408:	800ad07a 	srli	r5,r16,1
 201440c:	00c007c4 	movi	r3,31
 2014410:	1907c83a 	sub	r3,r3,r4
 2014414:	28c6d83a 	srl	r3,r5,r3
 2014418:	8108983a 	sll	r4,r16,r4
 201441c:	003fea06 	br	20143c8 <__floatsidf+0x70>
 2014420:	0005883a 	mov	r2,zero
 2014424:	00f07834 	movhi	r3,49632
 2014428:	003fd706 	br	2014388 <__floatsidf+0x30>

0201442c <__fixdfsi>:
 201442c:	defff804 	addi	sp,sp,-32
 2014430:	d9000515 	stw	r4,20(sp)
 2014434:	d9400615 	stw	r5,24(sp)
 2014438:	d9000504 	addi	r4,sp,20
 201443c:	d80b883a 	mov	r5,sp
 2014440:	dfc00715 	stw	ra,28(sp)
 2014444:	2014c2c0 	call	2014c2c <__unpack_d>
 2014448:	d8800017 	ldw	r2,0(sp)
 201444c:	00c00084 	movi	r3,2
 2014450:	10c01c26 	beq	r2,r3,20144c4 <__fixdfsi+0x98>
 2014454:	00c00044 	movi	r3,1
 2014458:	18801a2e 	bgeu	r3,r2,20144c4 <__fixdfsi+0x98>
 201445c:	00c00104 	movi	r3,4
 2014460:	10c01126 	beq	r2,r3,20144a8 <__fixdfsi+0x7c>
 2014464:	d8800217 	ldw	r2,8(sp)
 2014468:	10001616 	blt	r2,zero,20144c4 <__fixdfsi+0x98>
 201446c:	00c00784 	movi	r3,30
 2014470:	18800d16 	blt	r3,r2,20144a8 <__fixdfsi+0x7c>
 2014474:	00c00f04 	movi	r3,60
 2014478:	1885c83a 	sub	r2,r3,r2
 201447c:	10fff804 	addi	r3,r2,-32
 2014480:	d9400317 	ldw	r5,12(sp)
 2014484:	d9000417 	ldw	r4,16(sp)
 2014488:	18001616 	blt	r3,zero,20144e4 <__fixdfsi+0xb8>
 201448c:	20c4d83a 	srl	r2,r4,r3
 2014490:	d8c00117 	ldw	r3,4(sp)
 2014494:	18000126 	beq	r3,zero,201449c <__fixdfsi+0x70>
 2014498:	0085c83a 	sub	r2,zero,r2
 201449c:	dfc00717 	ldw	ra,28(sp)
 20144a0:	dec00804 	addi	sp,sp,32
 20144a4:	f800283a 	ret
 20144a8:	d8800117 	ldw	r2,4(sp)
 20144ac:	1000091e 	bne	r2,zero,20144d4 <__fixdfsi+0xa8>
 20144b0:	00a00034 	movhi	r2,32768
 20144b4:	10bfffc4 	addi	r2,r2,-1
 20144b8:	dfc00717 	ldw	ra,28(sp)
 20144bc:	dec00804 	addi	sp,sp,32
 20144c0:	f800283a 	ret
 20144c4:	0005883a 	mov	r2,zero
 20144c8:	dfc00717 	ldw	ra,28(sp)
 20144cc:	dec00804 	addi	sp,sp,32
 20144d0:	f800283a 	ret
 20144d4:	00a00034 	movhi	r2,32768
 20144d8:	dfc00717 	ldw	ra,28(sp)
 20144dc:	dec00804 	addi	sp,sp,32
 20144e0:	f800283a 	ret
 20144e4:	2008907a 	slli	r4,r4,1
 20144e8:	018007c4 	movi	r6,31
 20144ec:	308dc83a 	sub	r6,r6,r2
 20144f0:	2188983a 	sll	r4,r4,r6
 20144f4:	2884d83a 	srl	r2,r5,r2
 20144f8:	2084b03a 	or	r2,r4,r2
 20144fc:	003fe406 	br	2014490 <__fixdfsi+0x64>

02014500 <__truncdfsf2>:
 2014500:	defff804 	addi	sp,sp,-32
 2014504:	d9000515 	stw	r4,20(sp)
 2014508:	d9400615 	stw	r5,24(sp)
 201450c:	d9000504 	addi	r4,sp,20
 2014510:	d80b883a 	mov	r5,sp
 2014514:	dfc00715 	stw	ra,28(sp)
 2014518:	2014c2c0 	call	2014c2c <__unpack_d>
 201451c:	d8800317 	ldw	r2,12(sp)
 2014520:	d8c00417 	ldw	r3,16(sp)
 2014524:	01100034 	movhi	r4,16384
 2014528:	213fffc4 	addi	r4,r4,-1
 201452c:	100ed7ba 	srli	r7,r2,30
 2014530:	180690ba 	slli	r3,r3,2
 2014534:	1104703a 	and	r2,r2,r4
 2014538:	19ceb03a 	or	r7,r3,r7
 201453c:	10000126 	beq	r2,zero,2014544 <__truncdfsf2+0x44>
 2014540:	39c00054 	ori	r7,r7,1
 2014544:	d9000017 	ldw	r4,0(sp)
 2014548:	d9400117 	ldw	r5,4(sp)
 201454c:	d9800217 	ldw	r6,8(sp)
 2014550:	20149dc0 	call	20149dc <__make_fp>
 2014554:	dfc00717 	ldw	ra,28(sp)
 2014558:	dec00804 	addi	sp,sp,32
 201455c:	f800283a 	ret

02014560 <__floatunsidf>:
 2014560:	defff904 	addi	sp,sp,-28
 2014564:	dc000515 	stw	r16,20(sp)
 2014568:	dfc00615 	stw	ra,24(sp)
 201456c:	d8000115 	stw	zero,4(sp)
 2014570:	2021883a 	mov	r16,r4
 2014574:	20001726 	beq	r4,zero,20145d4 <__floatunsidf+0x74>
 2014578:	008000c4 	movi	r2,3
 201457c:	d8800015 	stw	r2,0(sp)
 2014580:	00800f04 	movi	r2,60
 2014584:	d8800215 	stw	r2,8(sp)
 2014588:	20147ac0 	call	20147ac <__clzsi2>
 201458c:	10c00744 	addi	r3,r2,29
 2014590:	18001816 	blt	r3,zero,20145f4 <__floatunsidf+0x94>
 2014594:	18002d26 	beq	r3,zero,201464c <__floatunsidf+0xec>
 2014598:	113fff44 	addi	r4,r2,-3
 201459c:	20002e16 	blt	r4,zero,2014658 <__floatunsidf+0xf8>
 20145a0:	8108983a 	sll	r4,r16,r4
 20145a4:	0021883a 	mov	r16,zero
 20145a8:	014007c4 	movi	r5,31
 20145ac:	2885c83a 	sub	r2,r5,r2
 20145b0:	dc000315 	stw	r16,12(sp)
 20145b4:	d9000415 	stw	r4,16(sp)
 20145b8:	d8800215 	stw	r2,8(sp)
 20145bc:	d809883a 	mov	r4,sp
 20145c0:	2014a080 	call	2014a08 <__pack_d>
 20145c4:	dfc00617 	ldw	ra,24(sp)
 20145c8:	dc000517 	ldw	r16,20(sp)
 20145cc:	dec00704 	addi	sp,sp,28
 20145d0:	f800283a 	ret
 20145d4:	00800084 	movi	r2,2
 20145d8:	d809883a 	mov	r4,sp
 20145dc:	d8800015 	stw	r2,0(sp)
 20145e0:	2014a080 	call	2014a08 <__pack_d>
 20145e4:	dfc00617 	ldw	ra,24(sp)
 20145e8:	dc000517 	ldw	r16,20(sp)
 20145ec:	dec00704 	addi	sp,sp,28
 20145f0:	f800283a 	ret
 20145f4:	00c7c83a 	sub	r3,zero,r3
 20145f8:	193ff804 	addi	r4,r3,-32
 20145fc:	20001c16 	blt	r4,zero,2014670 <__floatunsidf+0x110>
 2014600:	000b883a 	mov	r5,zero
 2014604:	2009d7fa 	srai	r4,r4,31
 2014608:	80c6d83a 	srl	r3,r16,r3
 201460c:	297fffc4 	addi	r5,r5,-1
 2014610:	2c20703a 	and	r16,r5,r16
 2014614:	8020c03a 	cmpne	r16,r16,zero
 2014618:	1906703a 	and	r3,r3,r4
 201461c:	010007c4 	movi	r4,31
 2014620:	80c6b03a 	or	r3,r16,r3
 2014624:	2085c83a 	sub	r2,r4,r2
 2014628:	d809883a 	mov	r4,sp
 201462c:	d8c00315 	stw	r3,12(sp)
 2014630:	d8000415 	stw	zero,16(sp)
 2014634:	d8800215 	stw	r2,8(sp)
 2014638:	2014a080 	call	2014a08 <__pack_d>
 201463c:	dfc00617 	ldw	ra,24(sp)
 2014640:	dc000517 	ldw	r16,20(sp)
 2014644:	dec00704 	addi	sp,sp,28
 2014648:	f800283a 	ret
 201464c:	dc000315 	stw	r16,12(sp)
 2014650:	d8000415 	stw	zero,16(sp)
 2014654:	003fd906 	br	20145bc <__floatunsidf+0x5c>
 2014658:	800ad07a 	srli	r5,r16,1
 201465c:	010007c4 	movi	r4,31
 2014660:	20c9c83a 	sub	r4,r4,r3
 2014664:	2908d83a 	srl	r4,r5,r4
 2014668:	80e0983a 	sll	r16,r16,r3
 201466c:	003fce06 	br	20145a8 <__floatunsidf+0x48>
 2014670:	01400044 	movi	r5,1
 2014674:	28ca983a 	sll	r5,r5,r3
 2014678:	003fe206 	br	2014604 <__floatunsidf+0xa4>

0201467c <udivmodsi4>:
 201467c:	2005883a 	mov	r2,r4
 2014680:	2900182e 	bgeu	r5,r4,20146e4 <udivmodsi4+0x68>
 2014684:	28001716 	blt	r5,zero,20146e4 <udivmodsi4+0x68>
 2014688:	01000804 	movi	r4,32
 201468c:	00c00044 	movi	r3,1
 2014690:	00000206 	br	201469c <udivmodsi4+0x20>
 2014694:	20001126 	beq	r4,zero,20146dc <udivmodsi4+0x60>
 2014698:	28000516 	blt	r5,zero,20146b0 <udivmodsi4+0x34>
 201469c:	294b883a 	add	r5,r5,r5
 20146a0:	213fffc4 	addi	r4,r4,-1
 20146a4:	18c7883a 	add	r3,r3,r3
 20146a8:	28bffa36 	bltu	r5,r2,2014694 <udivmodsi4+0x18>
 20146ac:	18000b26 	beq	r3,zero,20146dc <udivmodsi4+0x60>
 20146b0:	0009883a 	mov	r4,zero
 20146b4:	11400236 	bltu	r2,r5,20146c0 <udivmodsi4+0x44>
 20146b8:	1145c83a 	sub	r2,r2,r5
 20146bc:	20c8b03a 	or	r4,r4,r3
 20146c0:	1806d07a 	srli	r3,r3,1
 20146c4:	280ad07a 	srli	r5,r5,1
 20146c8:	183ffa1e 	bne	r3,zero,20146b4 <udivmodsi4+0x38>
 20146cc:	3000021e 	bne	r6,zero,20146d8 <udivmodsi4+0x5c>
 20146d0:	2005883a 	mov	r2,r4
 20146d4:	f800283a 	ret
 20146d8:	f800283a 	ret
 20146dc:	0009883a 	mov	r4,zero
 20146e0:	003ffa06 	br	20146cc <udivmodsi4+0x50>
 20146e4:	00c00044 	movi	r3,1
 20146e8:	0009883a 	mov	r4,zero
 20146ec:	003ff106 	br	20146b4 <udivmodsi4+0x38>

020146f0 <__divsi3>:
 20146f0:	defffe04 	addi	sp,sp,-8
 20146f4:	dfc00115 	stw	ra,4(sp)
 20146f8:	dc000015 	stw	r16,0(sp)
 20146fc:	20000a16 	blt	r4,zero,2014728 <__divsi3+0x38>
 2014700:	0021883a 	mov	r16,zero
 2014704:	28000b16 	blt	r5,zero,2014734 <__divsi3+0x44>
 2014708:	000d883a 	mov	r6,zero
 201470c:	201467c0 	call	201467c <udivmodsi4>
 2014710:	80000126 	beq	r16,zero,2014718 <__divsi3+0x28>
 2014714:	0085c83a 	sub	r2,zero,r2
 2014718:	dfc00117 	ldw	ra,4(sp)
 201471c:	dc000017 	ldw	r16,0(sp)
 2014720:	dec00204 	addi	sp,sp,8
 2014724:	f800283a 	ret
 2014728:	0109c83a 	sub	r4,zero,r4
 201472c:	04000044 	movi	r16,1
 2014730:	283ff50e 	bge	r5,zero,2014708 <__divsi3+0x18>
 2014734:	014bc83a 	sub	r5,zero,r5
 2014738:	8400005c 	xori	r16,r16,1
 201473c:	003ff206 	br	2014708 <__divsi3+0x18>

02014740 <__modsi3>:
 2014740:	deffff04 	addi	sp,sp,-4
 2014744:	dfc00015 	stw	ra,0(sp)
 2014748:	20000516 	blt	r4,zero,2014760 <__modsi3+0x20>
 201474c:	28000c16 	blt	r5,zero,2014780 <__modsi3+0x40>
 2014750:	01800044 	movi	r6,1
 2014754:	dfc00017 	ldw	ra,0(sp)
 2014758:	dec00104 	addi	sp,sp,4
 201475c:	201467c1 	jmpi	201467c <udivmodsi4>
 2014760:	0109c83a 	sub	r4,zero,r4
 2014764:	28000b16 	blt	r5,zero,2014794 <__modsi3+0x54>
 2014768:	01800044 	movi	r6,1
 201476c:	201467c0 	call	201467c <udivmodsi4>
 2014770:	0085c83a 	sub	r2,zero,r2
 2014774:	dfc00017 	ldw	ra,0(sp)
 2014778:	dec00104 	addi	sp,sp,4
 201477c:	f800283a 	ret
 2014780:	014bc83a 	sub	r5,zero,r5
 2014784:	01800044 	movi	r6,1
 2014788:	dfc00017 	ldw	ra,0(sp)
 201478c:	dec00104 	addi	sp,sp,4
 2014790:	201467c1 	jmpi	201467c <udivmodsi4>
 2014794:	014bc83a 	sub	r5,zero,r5
 2014798:	003ff306 	br	2014768 <__modsi3+0x28>

0201479c <__udivsi3>:
 201479c:	000d883a 	mov	r6,zero
 20147a0:	201467c1 	jmpi	201467c <udivmodsi4>

020147a4 <__umodsi3>:
 20147a4:	01800044 	movi	r6,1
 20147a8:	201467c1 	jmpi	201467c <udivmodsi4>

020147ac <__clzsi2>:
 20147ac:	00bfffd4 	movui	r2,65535
 20147b0:	11000b36 	bltu	r2,r4,20147e0 <__clzsi2+0x34>
 20147b4:	00803fc4 	movi	r2,255
 20147b8:	11001e2e 	bgeu	r2,r4,2014834 <__clzsi2+0x88>
 20147bc:	00c00204 	movi	r3,8
 20147c0:	20c8d83a 	srl	r4,r4,r3
 20147c4:	00c08174 	movhi	r3,517
 20147c8:	18f81e04 	addi	r3,r3,-8072
 20147cc:	00800604 	movi	r2,24
 20147d0:	1909883a 	add	r4,r3,r4
 20147d4:	20c00003 	ldbu	r3,0(r4)
 20147d8:	10c5c83a 	sub	r2,r2,r3
 20147dc:	f800283a 	ret
 20147e0:	00804034 	movhi	r2,256
 20147e4:	10bfffc4 	addi	r2,r2,-1
 20147e8:	11000936 	bltu	r2,r4,2014810 <__clzsi2+0x64>
 20147ec:	00800404 	movi	r2,16
 20147f0:	1007883a 	mov	r3,r2
 20147f4:	20c8d83a 	srl	r4,r4,r3
 20147f8:	00c08174 	movhi	r3,517
 20147fc:	18f81e04 	addi	r3,r3,-8072
 2014800:	1909883a 	add	r4,r3,r4
 2014804:	20c00003 	ldbu	r3,0(r4)
 2014808:	10c5c83a 	sub	r2,r2,r3
 201480c:	f800283a 	ret
 2014810:	00c00604 	movi	r3,24
 2014814:	20c8d83a 	srl	r4,r4,r3
 2014818:	00c08174 	movhi	r3,517
 201481c:	18f81e04 	addi	r3,r3,-8072
 2014820:	00800204 	movi	r2,8
 2014824:	1909883a 	add	r4,r3,r4
 2014828:	20c00003 	ldbu	r3,0(r4)
 201482c:	10c5c83a 	sub	r2,r2,r3
 2014830:	f800283a 	ret
 2014834:	0007883a 	mov	r3,zero
 2014838:	20c8d83a 	srl	r4,r4,r3
 201483c:	00c08174 	movhi	r3,517
 2014840:	18f81e04 	addi	r3,r3,-8072
 2014844:	00800804 	movi	r2,32
 2014848:	1909883a 	add	r4,r3,r4
 201484c:	20c00003 	ldbu	r3,0(r4)
 2014850:	10c5c83a 	sub	r2,r2,r3
 2014854:	f800283a 	ret

02014858 <__unpack_f>:
 2014858:	20c00017 	ldw	r3,0(r4)
 201485c:	00802034 	movhi	r2,128
 2014860:	10bfffc4 	addi	r2,r2,-1
 2014864:	1808d5fa 	srli	r4,r3,23
 2014868:	180cd7fa 	srli	r6,r3,31
 201486c:	1884703a 	and	r2,r3,r2
 2014870:	21003fcc 	andi	r4,r4,255
 2014874:	29800115 	stw	r6,4(r5)
 2014878:	2000111e 	bne	r4,zero,20148c0 <__unpack_f+0x68>
 201487c:	10001a26 	beq	r2,zero,20148e8 <__unpack_f+0x90>
 2014880:	00ffe084 	movi	r3,-126
 2014884:	100491fa 	slli	r2,r2,7
 2014888:	28c00215 	stw	r3,8(r5)
 201488c:	00c000c4 	movi	r3,3
 2014890:	28c00015 	stw	r3,0(r5)
 2014894:	01900034 	movhi	r6,16384
 2014898:	31bfffc4 	addi	r6,r6,-1
 201489c:	30801036 	bltu	r6,r2,20148e0 <__unpack_f+0x88>
 20148a0:	00ffe044 	movi	r3,-127
 20148a4:	1085883a 	add	r2,r2,r2
 20148a8:	1809883a 	mov	r4,r3
 20148ac:	18ffffc4 	addi	r3,r3,-1
 20148b0:	30bffc2e 	bgeu	r6,r2,20148a4 <__unpack_f+0x4c>
 20148b4:	29000215 	stw	r4,8(r5)
 20148b8:	28800315 	stw	r2,12(r5)
 20148bc:	f800283a 	ret
 20148c0:	01803fc4 	movi	r6,255
 20148c4:	21800b26 	beq	r4,r6,20148f4 <__unpack_f+0x9c>
 20148c8:	100491fa 	slli	r2,r2,7
 20148cc:	213fe044 	addi	r4,r4,-127
 20148d0:	00c000c4 	movi	r3,3
 20148d4:	10900034 	orhi	r2,r2,16384
 20148d8:	29000215 	stw	r4,8(r5)
 20148dc:	28c00015 	stw	r3,0(r5)
 20148e0:	28800315 	stw	r2,12(r5)
 20148e4:	f800283a 	ret
 20148e8:	00800084 	movi	r2,2
 20148ec:	28800015 	stw	r2,0(r5)
 20148f0:	f800283a 	ret
 20148f4:	10000526 	beq	r2,zero,201490c <__unpack_f+0xb4>
 20148f8:	18c0042c 	andhi	r3,r3,16
 20148fc:	18000626 	beq	r3,zero,2014918 <__unpack_f+0xc0>
 2014900:	00c00044 	movi	r3,1
 2014904:	28c00015 	stw	r3,0(r5)
 2014908:	003ff506 	br	20148e0 <__unpack_f+0x88>
 201490c:	00800104 	movi	r2,4
 2014910:	28800015 	stw	r2,0(r5)
 2014914:	f800283a 	ret
 2014918:	28000015 	stw	zero,0(r5)
 201491c:	003ff006 	br	20148e0 <__unpack_f+0x88>

02014920 <__fpcmp_parts_f>:
 2014920:	20c00017 	ldw	r3,0(r4)
 2014924:	00800044 	movi	r2,1
 2014928:	10c0172e 	bgeu	r2,r3,2014988 <__fpcmp_parts_f+0x68>
 201492c:	29800017 	ldw	r6,0(r5)
 2014930:	1180152e 	bgeu	r2,r6,2014988 <__fpcmp_parts_f+0x68>
 2014934:	01c00104 	movi	r7,4
 2014938:	19c02326 	beq	r3,r7,20149c8 <__fpcmp_parts_f+0xa8>
 201493c:	31c00926 	beq	r6,r7,2014964 <__fpcmp_parts_f+0x44>
 2014940:	01c00084 	movi	r7,2
 2014944:	19c00626 	beq	r3,r7,2014960 <__fpcmp_parts_f+0x40>
 2014948:	31c01126 	beq	r6,r7,2014990 <__fpcmp_parts_f+0x70>
 201494c:	20c00117 	ldw	r3,4(r4)
 2014950:	29800117 	ldw	r6,4(r5)
 2014954:	19801226 	beq	r3,r6,20149a0 <__fpcmp_parts_f+0x80>
 2014958:	1800041e 	bne	r3,zero,201496c <__fpcmp_parts_f+0x4c>
 201495c:	f800283a 	ret
 2014960:	30c01526 	beq	r6,r3,20149b8 <__fpcmp_parts_f+0x98>
 2014964:	28800117 	ldw	r2,4(r5)
 2014968:	1000071e 	bne	r2,zero,2014988 <__fpcmp_parts_f+0x68>
 201496c:	00bfffc4 	movi	r2,-1
 2014970:	f800283a 	ret
 2014974:	39801216 	blt	r7,r6,20149c0 <__fpcmp_parts_f+0xa0>
 2014978:	21000317 	ldw	r4,12(r4)
 201497c:	28800317 	ldw	r2,12(r5)
 2014980:	11000c2e 	bgeu	r2,r4,20149b4 <__fpcmp_parts_f+0x94>
 2014984:	183ff91e 	bne	r3,zero,201496c <__fpcmp_parts_f+0x4c>
 2014988:	00800044 	movi	r2,1
 201498c:	f800283a 	ret
 2014990:	20800117 	ldw	r2,4(r4)
 2014994:	103ff51e 	bne	r2,zero,201496c <__fpcmp_parts_f+0x4c>
 2014998:	00800044 	movi	r2,1
 201499c:	f800283a 	ret
 20149a0:	21c00217 	ldw	r7,8(r4)
 20149a4:	29800217 	ldw	r6,8(r5)
 20149a8:	31fff20e 	bge	r6,r7,2014974 <__fpcmp_parts_f+0x54>
 20149ac:	183fef1e 	bne	r3,zero,201496c <__fpcmp_parts_f+0x4c>
 20149b0:	f800283a 	ret
 20149b4:	20800236 	bltu	r4,r2,20149c0 <__fpcmp_parts_f+0xa0>
 20149b8:	0005883a 	mov	r2,zero
 20149bc:	f800283a 	ret
 20149c0:	183fea26 	beq	r3,zero,201496c <__fpcmp_parts_f+0x4c>
 20149c4:	003ff006 	br	2014988 <__fpcmp_parts_f+0x68>
 20149c8:	30fff11e 	bne	r6,r3,2014990 <__fpcmp_parts_f+0x70>
 20149cc:	28c00117 	ldw	r3,4(r5)
 20149d0:	20800117 	ldw	r2,4(r4)
 20149d4:	1885c83a 	sub	r2,r3,r2
 20149d8:	f800283a 	ret

020149dc <__make_fp>:
 20149dc:	defffb04 	addi	sp,sp,-20
 20149e0:	d9000015 	stw	r4,0(sp)
 20149e4:	d809883a 	mov	r4,sp
 20149e8:	dfc00415 	stw	ra,16(sp)
 20149ec:	d9400115 	stw	r5,4(sp)
 20149f0:	d9800215 	stw	r6,8(sp)
 20149f4:	d9c00315 	stw	r7,12(sp)
 20149f8:	2014e880 	call	2014e88 <__pack_f>
 20149fc:	dfc00417 	ldw	ra,16(sp)
 2014a00:	dec00504 	addi	sp,sp,20
 2014a04:	f800283a 	ret

02014a08 <__pack_d>:
 2014a08:	20800017 	ldw	r2,0(r4)
 2014a0c:	defff804 	addi	sp,sp,-32
 2014a10:	dcc00315 	stw	r19,12(sp)
 2014a14:	dc800215 	stw	r18,8(sp)
 2014a18:	dfc00715 	stw	ra,28(sp)
 2014a1c:	dd800615 	stw	r22,24(sp)
 2014a20:	dd400515 	stw	r21,20(sp)
 2014a24:	dd000415 	stw	r20,16(sp)
 2014a28:	dc400115 	stw	r17,4(sp)
 2014a2c:	dc000015 	stw	r16,0(sp)
 2014a30:	04800044 	movi	r18,1
 2014a34:	24400317 	ldw	r17,12(r4)
 2014a38:	24000417 	ldw	r16,16(r4)
 2014a3c:	24c00117 	ldw	r19,4(r4)
 2014a40:	9080422e 	bgeu	r18,r2,2014b4c <__pack_d+0x144>
 2014a44:	00c00104 	movi	r3,4
 2014a48:	10c03c26 	beq	r2,r3,2014b3c <__pack_d+0x134>
 2014a4c:	00c00084 	movi	r3,2
 2014a50:	10c01926 	beq	r2,r3,2014ab8 <__pack_d+0xb0>
 2014a54:	8c04b03a 	or	r2,r17,r16
 2014a58:	10001726 	beq	r2,zero,2014ab8 <__pack_d+0xb0>
 2014a5c:	21000217 	ldw	r4,8(r4)
 2014a60:	00bf0084 	movi	r2,-1022
 2014a64:	20804016 	blt	r4,r2,2014b68 <__pack_d+0x160>
 2014a68:	0080ffc4 	movi	r2,1023
 2014a6c:	11003316 	blt	r2,r4,2014b3c <__pack_d+0x134>
 2014a70:	88803fcc 	andi	r2,r17,255
 2014a74:	00c02004 	movi	r3,128
 2014a78:	10c02926 	beq	r2,r3,2014b20 <__pack_d+0x118>
 2014a7c:	88801fc4 	addi	r2,r17,127
 2014a80:	1463803a 	cmpltu	r17,r2,r17
 2014a84:	8c21883a 	add	r16,r17,r16
 2014a88:	1023883a 	mov	r17,r2
 2014a8c:	00880034 	movhi	r2,8192
 2014a90:	10bfffc4 	addi	r2,r2,-1
 2014a94:	14001c36 	bltu	r2,r16,2014b08 <__pack_d+0x100>
 2014a98:	2100ffc4 	addi	r4,r4,1023
 2014a9c:	8006963a 	slli	r3,r16,24
 2014aa0:	8804d23a 	srli	r2,r17,8
 2014aa4:	8020913a 	slli	r16,r16,4
 2014aa8:	2101ffcc 	andi	r4,r4,2047
 2014aac:	1884b03a 	or	r2,r3,r2
 2014ab0:	8020d33a 	srli	r16,r16,12
 2014ab4:	00000306 	br	2014ac4 <__pack_d+0xbc>
 2014ab8:	0009883a 	mov	r4,zero
 2014abc:	0005883a 	mov	r2,zero
 2014ac0:	0021883a 	mov	r16,zero
 2014ac4:	2008953a 	slli	r4,r4,20
 2014ac8:	982697fa 	slli	r19,r19,31
 2014acc:	00c00434 	movhi	r3,16
 2014ad0:	18ffffc4 	addi	r3,r3,-1
 2014ad4:	80e0703a 	and	r16,r16,r3
 2014ad8:	8106b03a 	or	r3,r16,r4
 2014adc:	1cc6b03a 	or	r3,r3,r19
 2014ae0:	dfc00717 	ldw	ra,28(sp)
 2014ae4:	dd800617 	ldw	r22,24(sp)
 2014ae8:	dd400517 	ldw	r21,20(sp)
 2014aec:	dd000417 	ldw	r20,16(sp)
 2014af0:	dcc00317 	ldw	r19,12(sp)
 2014af4:	dc800217 	ldw	r18,8(sp)
 2014af8:	dc400117 	ldw	r17,4(sp)
 2014afc:	dc000017 	ldw	r16,0(sp)
 2014b00:	dec00804 	addi	sp,sp,32
 2014b04:	f800283a 	ret
 2014b08:	800697fa 	slli	r3,r16,31
 2014b0c:	8804d07a 	srli	r2,r17,1
 2014b10:	21010004 	addi	r4,r4,1024
 2014b14:	8020d07a 	srli	r16,r16,1
 2014b18:	18a2b03a 	or	r17,r3,r2
 2014b1c:	003fdf06 	br	2014a9c <__pack_d+0x94>
 2014b20:	88c0400c 	andi	r3,r17,256
 2014b24:	183fd926 	beq	r3,zero,2014a8c <__pack_d+0x84>
 2014b28:	8885883a 	add	r2,r17,r2
 2014b2c:	1463803a 	cmpltu	r17,r2,r17
 2014b30:	8c21883a 	add	r16,r17,r16
 2014b34:	1023883a 	mov	r17,r2
 2014b38:	003fd406 	br	2014a8c <__pack_d+0x84>
 2014b3c:	0101ffc4 	movi	r4,2047
 2014b40:	0005883a 	mov	r2,zero
 2014b44:	0021883a 	mov	r16,zero
 2014b48:	003fde06 	br	2014ac4 <__pack_d+0xbc>
 2014b4c:	84000234 	orhi	r16,r16,8
 2014b50:	00c00434 	movhi	r3,16
 2014b54:	18ffffc4 	addi	r3,r3,-1
 2014b58:	8805883a 	mov	r2,r17
 2014b5c:	80e0703a 	and	r16,r16,r3
 2014b60:	0101ffc4 	movi	r4,2047
 2014b64:	003fd706 	br	2014ac4 <__pack_d+0xbc>
 2014b68:	1129c83a 	sub	r20,r2,r4
 2014b6c:	00800e04 	movi	r2,56
 2014b70:	15002716 	blt	r2,r20,2014c10 <__pack_d+0x208>
 2014b74:	800b883a 	mov	r5,r16
 2014b78:	a00d883a 	mov	r6,r20
 2014b7c:	8809883a 	mov	r4,r17
 2014b80:	2014e000 	call	2014e00 <__lshrdi3>
 2014b84:	9009883a 	mov	r4,r18
 2014b88:	000b883a 	mov	r5,zero
 2014b8c:	a00d883a 	mov	r6,r20
 2014b90:	102d883a 	mov	r22,r2
 2014b94:	182b883a 	mov	r21,r3
 2014b98:	2014e440 	call	2014e44 <__ashldi3>
 2014b9c:	1009003a 	cmpeq	r4,r2,zero
 2014ba0:	1907c83a 	sub	r3,r3,r4
 2014ba4:	10bfffc4 	addi	r2,r2,-1
 2014ba8:	1c20703a 	and	r16,r3,r16
 2014bac:	1444703a 	and	r2,r2,r17
 2014bb0:	1404b03a 	or	r2,r2,r16
 2014bb4:	1004c03a 	cmpne	r2,r2,zero
 2014bb8:	1584b03a 	or	r2,r2,r22
 2014bbc:	11003fcc 	andi	r4,r2,255
 2014bc0:	01402004 	movi	r5,128
 2014bc4:	a807883a 	mov	r3,r21
 2014bc8:	2140131e 	bne	r4,r5,2014c18 <__pack_d+0x210>
 2014bcc:	1140400c 	andi	r5,r2,256
 2014bd0:	28000426 	beq	r5,zero,2014be4 <__pack_d+0x1dc>
 2014bd4:	1109883a 	add	r4,r2,r4
 2014bd8:	2085803a 	cmpltu	r2,r4,r2
 2014bdc:	1547883a 	add	r3,r2,r21
 2014be0:	2005883a 	mov	r2,r4
 2014be4:	1808963a 	slli	r4,r3,24
 2014be8:	1004d23a 	srli	r2,r2,8
 2014bec:	1820913a 	slli	r16,r3,4
 2014bf0:	01440034 	movhi	r5,4096
 2014bf4:	297fffc4 	addi	r5,r5,-1
 2014bf8:	2084b03a 	or	r2,r4,r2
 2014bfc:	8020d33a 	srli	r16,r16,12
 2014c00:	01000044 	movi	r4,1
 2014c04:	28ffaf36 	bltu	r5,r3,2014ac4 <__pack_d+0xbc>
 2014c08:	0009883a 	mov	r4,zero
 2014c0c:	003fad06 	br	2014ac4 <__pack_d+0xbc>
 2014c10:	0005883a 	mov	r2,zero
 2014c14:	0007883a 	mov	r3,zero
 2014c18:	11001fc4 	addi	r4,r2,127
 2014c1c:	2085803a 	cmpltu	r2,r4,r2
 2014c20:	10c7883a 	add	r3,r2,r3
 2014c24:	2005883a 	mov	r2,r4
 2014c28:	003fee06 	br	2014be4 <__pack_d+0x1dc>

02014c2c <__unpack_d>:
 2014c2c:	21800117 	ldw	r6,4(r4)
 2014c30:	20c00017 	ldw	r3,0(r4)
 2014c34:	3004d7fa 	srli	r2,r6,31
 2014c38:	3008d53a 	srli	r4,r6,20
 2014c3c:	28800115 	stw	r2,4(r5)
 2014c40:	2101ffcc 	andi	r4,r4,2047
 2014c44:	00800434 	movhi	r2,16
 2014c48:	10bfffc4 	addi	r2,r2,-1
 2014c4c:	3084703a 	and	r2,r6,r2
 2014c50:	20001a1e 	bne	r4,zero,2014cbc <__unpack_d+0x90>
 2014c54:	1888b03a 	or	r4,r3,r2
 2014c58:	20002626 	beq	r4,zero,2014cf4 <__unpack_d+0xc8>
 2014c5c:	1808d63a 	srli	r4,r3,24
 2014c60:	1004923a 	slli	r2,r2,8
 2014c64:	01bf0084 	movi	r6,-1022
 2014c68:	29800215 	stw	r6,8(r5)
 2014c6c:	2084b03a 	or	r2,r4,r2
 2014c70:	010000c4 	movi	r4,3
 2014c74:	29000015 	stw	r4,0(r5)
 2014c78:	02040034 	movhi	r8,4096
 2014c7c:	423fffc4 	addi	r8,r8,-1
 2014c80:	1806923a 	slli	r3,r3,8
 2014c84:	40801836 	bltu	r8,r2,2014ce8 <__unpack_d+0xbc>
 2014c88:	013f0044 	movi	r4,-1023
 2014c8c:	18cd883a 	add	r6,r3,r3
 2014c90:	30c7803a 	cmpltu	r3,r6,r3
 2014c94:	1085883a 	add	r2,r2,r2
 2014c98:	1885883a 	add	r2,r3,r2
 2014c9c:	200f883a 	mov	r7,r4
 2014ca0:	3007883a 	mov	r3,r6
 2014ca4:	213fffc4 	addi	r4,r4,-1
 2014ca8:	40bff82e 	bgeu	r8,r2,2014c8c <__unpack_d+0x60>
 2014cac:	29c00215 	stw	r7,8(r5)
 2014cb0:	28c00315 	stw	r3,12(r5)
 2014cb4:	28800415 	stw	r2,16(r5)
 2014cb8:	f800283a 	ret
 2014cbc:	01c1ffc4 	movi	r7,2047
 2014cc0:	21c00f26 	beq	r4,r7,2014d00 <__unpack_d+0xd4>
 2014cc4:	180cd63a 	srli	r6,r3,24
 2014cc8:	1004923a 	slli	r2,r2,8
 2014ccc:	213f0044 	addi	r4,r4,-1023
 2014cd0:	1806923a 	slli	r3,r3,8
 2014cd4:	3084b03a 	or	r2,r6,r2
 2014cd8:	29000215 	stw	r4,8(r5)
 2014cdc:	010000c4 	movi	r4,3
 2014ce0:	10840034 	orhi	r2,r2,4096
 2014ce4:	29000015 	stw	r4,0(r5)
 2014ce8:	28c00315 	stw	r3,12(r5)
 2014cec:	28800415 	stw	r2,16(r5)
 2014cf0:	f800283a 	ret
 2014cf4:	00800084 	movi	r2,2
 2014cf8:	28800015 	stw	r2,0(r5)
 2014cfc:	f800283a 	ret
 2014d00:	1888b03a 	or	r4,r3,r2
 2014d04:	20000526 	beq	r4,zero,2014d1c <__unpack_d+0xf0>
 2014d08:	3180022c 	andhi	r6,r6,8
 2014d0c:	30000626 	beq	r6,zero,2014d28 <__unpack_d+0xfc>
 2014d10:	01000044 	movi	r4,1
 2014d14:	29000015 	stw	r4,0(r5)
 2014d18:	003ff306 	br	2014ce8 <__unpack_d+0xbc>
 2014d1c:	00800104 	movi	r2,4
 2014d20:	28800015 	stw	r2,0(r5)
 2014d24:	f800283a 	ret
 2014d28:	28000015 	stw	zero,0(r5)
 2014d2c:	003fee06 	br	2014ce8 <__unpack_d+0xbc>

02014d30 <__fpcmp_parts_d>:
 2014d30:	20c00017 	ldw	r3,0(r4)
 2014d34:	00800044 	movi	r2,1
 2014d38:	10c0142e 	bgeu	r2,r3,2014d8c <__fpcmp_parts_d+0x5c>
 2014d3c:	29800017 	ldw	r6,0(r5)
 2014d40:	1180122e 	bgeu	r2,r6,2014d8c <__fpcmp_parts_d+0x5c>
 2014d44:	01c00104 	movi	r7,4
 2014d48:	19c02826 	beq	r3,r7,2014dec <__fpcmp_parts_d+0xbc>
 2014d4c:	31c00926 	beq	r6,r7,2014d74 <__fpcmp_parts_d+0x44>
 2014d50:	01c00084 	movi	r7,2
 2014d54:	19c00626 	beq	r3,r7,2014d70 <__fpcmp_parts_d+0x40>
 2014d58:	31c00a26 	beq	r6,r7,2014d84 <__fpcmp_parts_d+0x54>
 2014d5c:	20c00117 	ldw	r3,4(r4)
 2014d60:	29800117 	ldw	r6,4(r5)
 2014d64:	19800b26 	beq	r3,r6,2014d94 <__fpcmp_parts_d+0x64>
 2014d68:	1800041e 	bne	r3,zero,2014d7c <__fpcmp_parts_d+0x4c>
 2014d6c:	f800283a 	ret
 2014d70:	30c01a26 	beq	r6,r3,2014ddc <__fpcmp_parts_d+0xac>
 2014d74:	28800117 	ldw	r2,4(r5)
 2014d78:	1000041e 	bne	r2,zero,2014d8c <__fpcmp_parts_d+0x5c>
 2014d7c:	00bfffc4 	movi	r2,-1
 2014d80:	f800283a 	ret
 2014d84:	20800117 	ldw	r2,4(r4)
 2014d88:	103ffc1e 	bne	r2,zero,2014d7c <__fpcmp_parts_d+0x4c>
 2014d8c:	00800044 	movi	r2,1
 2014d90:	f800283a 	ret
 2014d94:	21c00217 	ldw	r7,8(r4)
 2014d98:	29800217 	ldw	r6,8(r5)
 2014d9c:	31c0020e 	bge	r6,r7,2014da8 <__fpcmp_parts_d+0x78>
 2014da0:	183ff61e 	bne	r3,zero,2014d7c <__fpcmp_parts_d+0x4c>
 2014da4:	f800283a 	ret
 2014da8:	39800a16 	blt	r7,r6,2014dd4 <__fpcmp_parts_d+0xa4>
 2014dac:	20800417 	ldw	r2,16(r4)
 2014db0:	29800417 	ldw	r6,16(r5)
 2014db4:	21c00317 	ldw	r7,12(r4)
 2014db8:	29000317 	ldw	r4,12(r5)
 2014dbc:	30800936 	bltu	r6,r2,2014de4 <__fpcmp_parts_d+0xb4>
 2014dc0:	1180011e 	bne	r2,r6,2014dc8 <__fpcmp_parts_d+0x98>
 2014dc4:	21c00736 	bltu	r4,r7,2014de4 <__fpcmp_parts_d+0xb4>
 2014dc8:	11800236 	bltu	r2,r6,2014dd4 <__fpcmp_parts_d+0xa4>
 2014dcc:	3080031e 	bne	r6,r2,2014ddc <__fpcmp_parts_d+0xac>
 2014dd0:	3900022e 	bgeu	r7,r4,2014ddc <__fpcmp_parts_d+0xac>
 2014dd4:	183fe926 	beq	r3,zero,2014d7c <__fpcmp_parts_d+0x4c>
 2014dd8:	003fec06 	br	2014d8c <__fpcmp_parts_d+0x5c>
 2014ddc:	0005883a 	mov	r2,zero
 2014de0:	f800283a 	ret
 2014de4:	183fe926 	beq	r3,zero,2014d8c <__fpcmp_parts_d+0x5c>
 2014de8:	003fe406 	br	2014d7c <__fpcmp_parts_d+0x4c>
 2014dec:	30ffe51e 	bne	r6,r3,2014d84 <__fpcmp_parts_d+0x54>
 2014df0:	28c00117 	ldw	r3,4(r5)
 2014df4:	20800117 	ldw	r2,4(r4)
 2014df8:	1885c83a 	sub	r2,r3,r2
 2014dfc:	f800283a 	ret

02014e00 <__lshrdi3>:
 2014e00:	2005883a 	mov	r2,r4
 2014e04:	2807883a 	mov	r3,r5
 2014e08:	30000826 	beq	r6,zero,2014e2c <__lshrdi3+0x2c>
 2014e0c:	01000804 	movi	r4,32
 2014e10:	2189c83a 	sub	r4,r4,r6
 2014e14:	0100060e 	bge	zero,r4,2014e30 <__lshrdi3+0x30>
 2014e18:	1184d83a 	srl	r2,r2,r6
 2014e1c:	2908983a 	sll	r4,r5,r4
 2014e20:	298cd83a 	srl	r6,r5,r6
 2014e24:	2084b03a 	or	r2,r4,r2
 2014e28:	3007883a 	mov	r3,r6
 2014e2c:	f800283a 	ret
 2014e30:	0105c83a 	sub	r2,zero,r4
 2014e34:	000d883a 	mov	r6,zero
 2014e38:	2884d83a 	srl	r2,r5,r2
 2014e3c:	3007883a 	mov	r3,r6
 2014e40:	003ffa06 	br	2014e2c <__lshrdi3+0x2c>

02014e44 <__ashldi3>:
 2014e44:	2005883a 	mov	r2,r4
 2014e48:	2807883a 	mov	r3,r5
 2014e4c:	30000826 	beq	r6,zero,2014e70 <__ashldi3+0x2c>
 2014e50:	01000804 	movi	r4,32
 2014e54:	2189c83a 	sub	r4,r4,r6
 2014e58:	0100060e 	bge	zero,r4,2014e74 <__ashldi3+0x30>
 2014e5c:	1108d83a 	srl	r4,r2,r4
 2014e60:	2986983a 	sll	r3,r5,r6
 2014e64:	118c983a 	sll	r6,r2,r6
 2014e68:	20c6b03a 	or	r3,r4,r3
 2014e6c:	3005883a 	mov	r2,r6
 2014e70:	f800283a 	ret
 2014e74:	0107c83a 	sub	r3,zero,r4
 2014e78:	000d883a 	mov	r6,zero
 2014e7c:	10c6983a 	sll	r3,r2,r3
 2014e80:	3005883a 	mov	r2,r6
 2014e84:	003ffa06 	br	2014e70 <__ashldi3+0x2c>

02014e88 <__pack_f>:
 2014e88:	21400017 	ldw	r5,0(r4)
 2014e8c:	01800044 	movi	r6,1
 2014e90:	20c00317 	ldw	r3,12(r4)
 2014e94:	21c00117 	ldw	r7,4(r4)
 2014e98:	3140282e 	bgeu	r6,r5,2014f3c <__pack_f+0xb4>
 2014e9c:	00800104 	movi	r2,4
 2014ea0:	28802326 	beq	r5,r2,2014f30 <__pack_f+0xa8>
 2014ea4:	00800084 	movi	r2,2
 2014ea8:	28800f26 	beq	r5,r2,2014ee8 <__pack_f+0x60>
 2014eac:	18000e26 	beq	r3,zero,2014ee8 <__pack_f+0x60>
 2014eb0:	21000217 	ldw	r4,8(r4)
 2014eb4:	00bfe084 	movi	r2,-126
 2014eb8:	20802616 	blt	r4,r2,2014f54 <__pack_f+0xcc>
 2014ebc:	00801fc4 	movi	r2,127
 2014ec0:	11001b16 	blt	r2,r4,2014f30 <__pack_f+0xa8>
 2014ec4:	188a703a 	and	r5,r3,r2
 2014ec8:	00801004 	movi	r2,64
 2014ecc:	28801126 	beq	r5,r2,2014f14 <__pack_f+0x8c>
 2014ed0:	18c00fc4 	addi	r3,r3,63
 2014ed4:	18001316 	blt	r3,zero,2014f24 <__pack_f+0x9c>
 2014ed8:	21001fc4 	addi	r4,r4,127
 2014edc:	180690ba 	slli	r3,r3,2
 2014ee0:	1806d27a 	srli	r3,r3,9
 2014ee4:	00000206 	br	2014ef0 <__pack_f+0x68>
 2014ee8:	0009883a 	mov	r4,zero
 2014eec:	0007883a 	mov	r3,zero
 2014ef0:	21003fcc 	andi	r4,r4,255
 2014ef4:	200895fa 	slli	r4,r4,23
 2014ef8:	380a97fa 	slli	r5,r7,31
 2014efc:	00802034 	movhi	r2,128
 2014f00:	10bfffc4 	addi	r2,r2,-1
 2014f04:	1886703a 	and	r3,r3,r2
 2014f08:	1904b03a 	or	r2,r3,r4
 2014f0c:	1144b03a 	or	r2,r2,r5
 2014f10:	f800283a 	ret
 2014f14:	1880200c 	andi	r2,r3,128
 2014f18:	103fee26 	beq	r2,zero,2014ed4 <__pack_f+0x4c>
 2014f1c:	18c01004 	addi	r3,r3,64
 2014f20:	183fed0e 	bge	r3,zero,2014ed8 <__pack_f+0x50>
 2014f24:	1806d07a 	srli	r3,r3,1
 2014f28:	21002004 	addi	r4,r4,128
 2014f2c:	003feb06 	br	2014edc <__pack_f+0x54>
 2014f30:	013fffc4 	movi	r4,-1
 2014f34:	0007883a 	mov	r3,zero
 2014f38:	003fed06 	br	2014ef0 <__pack_f+0x68>
 2014f3c:	18c00434 	orhi	r3,r3,16
 2014f40:	00802034 	movhi	r2,128
 2014f44:	10bfffc4 	addi	r2,r2,-1
 2014f48:	1886703a 	and	r3,r3,r2
 2014f4c:	013fffc4 	movi	r4,-1
 2014f50:	003fe706 	br	2014ef0 <__pack_f+0x68>
 2014f54:	1105c83a 	sub	r2,r2,r4
 2014f58:	01000644 	movi	r4,25
 2014f5c:	20801216 	blt	r4,r2,2014fa8 <__pack_f+0x120>
 2014f60:	3088983a 	sll	r4,r6,r2
 2014f64:	1884d83a 	srl	r2,r3,r2
 2014f68:	213fffc4 	addi	r4,r4,-1
 2014f6c:	20c6703a 	and	r3,r4,r3
 2014f70:	1806c03a 	cmpne	r3,r3,zero
 2014f74:	1884b03a 	or	r2,r3,r2
 2014f78:	11001fcc 	andi	r4,r2,127
 2014f7c:	00c01004 	movi	r3,64
 2014f80:	20c00a1e 	bne	r4,r3,2014fac <__pack_f+0x124>
 2014f84:	10c0200c 	andi	r3,r2,128
 2014f88:	18000126 	beq	r3,zero,2014f90 <__pack_f+0x108>
 2014f8c:	10801004 	addi	r2,r2,64
 2014f90:	100690ba 	slli	r3,r2,2
 2014f94:	01100034 	movhi	r4,16384
 2014f98:	1105403a 	cmpgeu	r2,r2,r4
 2014f9c:	1806d27a 	srli	r3,r3,9
 2014fa0:	1009883a 	mov	r4,r2
 2014fa4:	003fd206 	br	2014ef0 <__pack_f+0x68>
 2014fa8:	0005883a 	mov	r2,zero
 2014fac:	10800fc4 	addi	r2,r2,63
 2014fb0:	003ff706 	br	2014f90 <__pack_f+0x108>

02014fb4 <alt_dcache_flush>:
 *
 * Any dirty lines in the data cache are written back to memory.
 */

void alt_dcache_flush (void* start, alt_u32 len)
{
 2014fb4:	defffb04 	addi	sp,sp,-20
 2014fb8:	df000415 	stw	fp,16(sp)
 2014fbc:	df000404 	addi	fp,sp,16
 2014fc0:	e13ffe15 	stw	r4,-8(fp)
 2014fc4:	e17fff15 	stw	r5,-4(fp)
  {
    len = NIOS2_DCACHE_SIZE;
  }
  #endif

  end = ((char*) start) + len; 
 2014fc8:	e0fffe17 	ldw	r3,-8(fp)
 2014fcc:	e0bfff17 	ldw	r2,-4(fp)
 2014fd0:	1885883a 	add	r2,r3,r2
 2014fd4:	e0bffd15 	stw	r2,-12(fp)

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 2014fd8:	e0bffe17 	ldw	r2,-8(fp)
 2014fdc:	e0bffc15 	stw	r2,-16(fp)
 2014fe0:	00000506 	br	2014ff8 <alt_dcache_flush+0x44>
  { 
    ALT_FLUSH_DATA(i); 
 2014fe4:	e0bffc17 	ldw	r2,-16(fp)
 2014fe8:	1000001b 	flushda	0(r2)
  }
  #endif

  end = ((char*) start) + len; 

  for (i = start; i < end; i+= NIOS2_DCACHE_LINE_SIZE)
 2014fec:	e0bffc17 	ldw	r2,-16(fp)
 2014ff0:	10800804 	addi	r2,r2,32
 2014ff4:	e0bffc15 	stw	r2,-16(fp)
 2014ff8:	e0fffc17 	ldw	r3,-16(fp)
 2014ffc:	e0bffd17 	ldw	r2,-12(fp)
 2015000:	18bff836 	bltu	r3,r2,2014fe4 <alt_dcache_flush+0x30>
   * For an unaligned flush request, we've got one more line left.
   * Note that this is dependent on NIOS2_DCACHE_LINE_SIZE to be a 
   * multiple of 2 (which it always is).
   */

  if (((alt_u32) start) & (NIOS2_DCACHE_LINE_SIZE - 1))
 2015004:	e0bffe17 	ldw	r2,-8(fp)
 2015008:	108007cc 	andi	r2,r2,31
 201500c:	10000226 	beq	r2,zero,2015018 <alt_dcache_flush+0x64>
  {
    ALT_FLUSH_DATA(i);
 2015010:	e0bffc17 	ldw	r2,-16(fp)
 2015014:	1000001b 	flushda	0(r2)
  }

#endif /* NIOS2_DCACHE_SIZE > 0 */
}
 2015018:	e037883a 	mov	sp,fp
 201501c:	df000017 	ldw	fp,0(sp)
 2015020:	dec00104 	addi	sp,sp,4
 2015024:	f800283a 	ret

02015028 <alt_flash_open_dev>:
#include "priv/alt_file.h"

ALT_LLIST_HEAD(alt_flash_dev_list);

alt_flash_fd* alt_flash_open_dev(const char* name)
{
 2015028:	defffc04 	addi	sp,sp,-16
 201502c:	dfc00315 	stw	ra,12(sp)
 2015030:	df000215 	stw	fp,8(sp)
 2015034:	df000204 	addi	fp,sp,8
 2015038:	e13fff15 	stw	r4,-4(fp)
  alt_flash_dev* dev = (alt_flash_dev*)alt_find_dev(name, &alt_flash_dev_list);
 201503c:	e13fff17 	ldw	r4,-4(fp)
 2015040:	d1601004 	addi	r5,gp,-32704
 2015044:	20370780 	call	2037078 <alt_find_dev>
 2015048:	e0bffe15 	stw	r2,-8(fp)

  if ((dev) && dev->open)
 201504c:	e0bffe17 	ldw	r2,-8(fp)
 2015050:	10000926 	beq	r2,zero,2015078 <alt_flash_open_dev+0x50>
 2015054:	e0bffe17 	ldw	r2,-8(fp)
 2015058:	10800317 	ldw	r2,12(r2)
 201505c:	10000626 	beq	r2,zero,2015078 <alt_flash_open_dev+0x50>
  {
    return dev->open(dev, name);
 2015060:	e0bffe17 	ldw	r2,-8(fp)
 2015064:	10800317 	ldw	r2,12(r2)
 2015068:	e13ffe17 	ldw	r4,-8(fp)
 201506c:	e17fff17 	ldw	r5,-4(fp)
 2015070:	103ee83a 	callr	r2
 2015074:	00000106 	br	201507c <alt_flash_open_dev+0x54>
  }

  return dev;
 2015078:	e0bffe17 	ldw	r2,-8(fp)
}
 201507c:	e037883a 	mov	sp,fp
 2015080:	dfc00117 	ldw	ra,4(sp)
 2015084:	df000017 	ldw	fp,0(sp)
 2015088:	dec00204 	addi	sp,sp,8
 201508c:	f800283a 	ret

02015090 <alt_flash_close_dev>:

void alt_flash_close_dev(alt_flash_fd* fd)
{
 2015090:	defffd04 	addi	sp,sp,-12
 2015094:	dfc00215 	stw	ra,8(sp)
 2015098:	df000115 	stw	fp,4(sp)
 201509c:	df000104 	addi	fp,sp,4
 20150a0:	e13fff15 	stw	r4,-4(fp)
  if (fd && fd->close)
 20150a4:	e0bfff17 	ldw	r2,-4(fp)
 20150a8:	10000726 	beq	r2,zero,20150c8 <alt_flash_close_dev+0x38>
 20150ac:	e0bfff17 	ldw	r2,-4(fp)
 20150b0:	10800417 	ldw	r2,16(r2)
 20150b4:	10000426 	beq	r2,zero,20150c8 <alt_flash_close_dev+0x38>
  {
    fd->close(fd);
 20150b8:	e0bfff17 	ldw	r2,-4(fp)
 20150bc:	10800417 	ldw	r2,16(r2)
 20150c0:	e13fff17 	ldw	r4,-4(fp)
 20150c4:	103ee83a 	callr	r2
  }
  return;
 20150c8:	0001883a 	nop
}
 20150cc:	e037883a 	mov	sp,fp
 20150d0:	dfc00117 	ldw	ra,4(sp)
 20150d4:	df000017 	ldw	fp,0(sp)
 20150d8:	dec00204 	addi	sp,sp,8
 20150dc:	f800283a 	ret

020150e0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20150e0:	defffe04 	addi	sp,sp,-8
 20150e4:	dfc00115 	stw	ra,4(sp)
 20150e8:	df000015 	stw	fp,0(sp)
 20150ec:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20150f0:	00808174 	movhi	r2,517
 20150f4:	10907704 	addi	r2,r2,16860
 20150f8:	10800017 	ldw	r2,0(r2)
 20150fc:	10000526 	beq	r2,zero,2015114 <alt_get_errno+0x34>
 2015100:	00808174 	movhi	r2,517
 2015104:	10907704 	addi	r2,r2,16860
 2015108:	10800017 	ldw	r2,0(r2)
 201510c:	103ee83a 	callr	r2
 2015110:	00000206 	br	201511c <alt_get_errno+0x3c>
 2015114:	00808174 	movhi	r2,517
 2015118:	10908b04 	addi	r2,r2,16940
}
 201511c:	e037883a 	mov	sp,fp
 2015120:	dfc00117 	ldw	ra,4(sp)
 2015124:	df000017 	ldw	fp,0(sp)
 2015128:	dec00204 	addi	sp,sp,8
 201512c:	f800283a 	ret

02015130 <fstat>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_FSTAT (int file, struct stat *st)
{
 2015130:	defffb04 	addi	sp,sp,-20
 2015134:	dfc00415 	stw	ra,16(sp)
 2015138:	df000315 	stw	fp,12(sp)
 201513c:	df000304 	addi	fp,sp,12
 2015140:	e13ffe15 	stw	r4,-8(fp)
 2015144:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2015148:	e0bffe17 	ldw	r2,-8(fp)
 201514c:	10000616 	blt	r2,zero,2015168 <fstat+0x38>
 2015150:	e0bffe17 	ldw	r2,-8(fp)
 2015154:	10c00324 	muli	r3,r2,12
 2015158:	00808174 	movhi	r2,517
 201515c:	108f1e04 	addi	r2,r2,15480
 2015160:	1885883a 	add	r2,r3,r2
 2015164:	00000106 	br	201516c <fstat+0x3c>
 2015168:	0005883a 	mov	r2,zero
 201516c:	e0bffd15 	stw	r2,-12(fp)
  
  if (fd)
 2015170:	e0bffd17 	ldw	r2,-12(fp)
 2015174:	10001026 	beq	r2,zero,20151b8 <fstat+0x88>
  {
    /* Call the drivers fstat() function to fill out the "st" structure. */

    if (fd->dev->fstat)
 2015178:	e0bffd17 	ldw	r2,-12(fp)
 201517c:	10800017 	ldw	r2,0(r2)
 2015180:	10800817 	ldw	r2,32(r2)
 2015184:	10000726 	beq	r2,zero,20151a4 <fstat+0x74>
    {
      return fd->dev->fstat(fd, st);
 2015188:	e0bffd17 	ldw	r2,-12(fp)
 201518c:	10800017 	ldw	r2,0(r2)
 2015190:	10800817 	ldw	r2,32(r2)
 2015194:	e13ffd17 	ldw	r4,-12(fp)
 2015198:	e17fff17 	ldw	r5,-4(fp)
 201519c:	103ee83a 	callr	r2
 20151a0:	00000906 	br	20151c8 <fstat+0x98>
     * device.
     */
 
    else
    {
      st->st_mode = _IFCHR;
 20151a4:	e0bfff17 	ldw	r2,-4(fp)
 20151a8:	00c80004 	movi	r3,8192
 20151ac:	10c00115 	stw	r3,4(r2)
      return 0;
 20151b0:	0005883a 	mov	r2,zero
 20151b4:	00000406 	br	20151c8 <fstat+0x98>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 20151b8:	20150e00 	call	20150e0 <alt_get_errno>
 20151bc:	00c01444 	movi	r3,81
 20151c0:	10c00015 	stw	r3,0(r2)
    return -1;
 20151c4:	00bfffc4 	movi	r2,-1
  }
}
 20151c8:	e037883a 	mov	sp,fp
 20151cc:	dfc00117 	ldw	ra,4(sp)
 20151d0:	df000017 	ldw	fp,0(sp)
 20151d4:	dec00204 	addi	sp,sp,8
 20151d8:	f800283a 	ret

020151dc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20151dc:	defffe04 	addi	sp,sp,-8
 20151e0:	dfc00115 	stw	ra,4(sp)
 20151e4:	df000015 	stw	fp,0(sp)
 20151e8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20151ec:	00808174 	movhi	r2,517
 20151f0:	10907704 	addi	r2,r2,16860
 20151f4:	10800017 	ldw	r2,0(r2)
 20151f8:	10000526 	beq	r2,zero,2015210 <alt_get_errno+0x34>
 20151fc:	00808174 	movhi	r2,517
 2015200:	10907704 	addi	r2,r2,16860
 2015204:	10800017 	ldw	r2,0(r2)
 2015208:	103ee83a 	callr	r2
 201520c:	00000206 	br	2015218 <alt_get_errno+0x3c>
 2015210:	00808174 	movhi	r2,517
 2015214:	10908b04 	addi	r2,r2,16940
}
 2015218:	e037883a 	mov	sp,fp
 201521c:	dfc00117 	ldw	ra,4(sp)
 2015220:	df000017 	ldw	fp,0(sp)
 2015224:	dec00204 	addi	sp,sp,8
 2015228:	f800283a 	ret

0201522c <isatty>:
 *
 * ALT_ISATTY is mapped onto the isatty() system call in alt_syscall.h
 */
 
int ALT_ISATTY (int file)
{
 201522c:	deffed04 	addi	sp,sp,-76
 2015230:	dfc01215 	stw	ra,72(sp)
 2015234:	df001115 	stw	fp,68(sp)
 2015238:	df001104 	addi	fp,sp,68
 201523c:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2015240:	e0bfff17 	ldw	r2,-4(fp)
 2015244:	10000616 	blt	r2,zero,2015260 <isatty+0x34>
 2015248:	e0bfff17 	ldw	r2,-4(fp)
 201524c:	10c00324 	muli	r3,r2,12
 2015250:	00808174 	movhi	r2,517
 2015254:	108f1e04 	addi	r2,r2,15480
 2015258:	1885883a 	add	r2,r3,r2
 201525c:	00000106 	br	2015264 <isatty+0x38>
 2015260:	0005883a 	mov	r2,zero
 2015264:	e0bfef15 	stw	r2,-68(fp)
  
  if (fd)
 2015268:	e0bfef17 	ldw	r2,-68(fp)
 201526c:	10000e26 	beq	r2,zero,20152a8 <isatty+0x7c>
    /*
     * If a device driver does not provide an fstat() function, then it is 
     * treated as a terminal device by default.
     */

    if (!fd->dev->fstat)
 2015270:	e0bfef17 	ldw	r2,-68(fp)
 2015274:	10800017 	ldw	r2,0(r2)
 2015278:	10800817 	ldw	r2,32(r2)
 201527c:	1000021e 	bne	r2,zero,2015288 <isatty+0x5c>
    {
      return 1;
 2015280:	00800044 	movi	r2,1
 2015284:	00000c06 	br	20152b8 <isatty+0x8c>
     * this is called so that the device can identify itself.
     */ 

    else
    {
      fstat (file, &stat);
 2015288:	e0bff004 	addi	r2,fp,-64
 201528c:	e13fff17 	ldw	r4,-4(fp)
 2015290:	100b883a 	mov	r5,r2
 2015294:	20151300 	call	2015130 <fstat>
      return (stat.st_mode == _IFCHR) ? 1 : 0;
 2015298:	e0bff117 	ldw	r2,-60(fp)
 201529c:	10880020 	cmpeqi	r2,r2,8192
 20152a0:	10803fcc 	andi	r2,r2,255
 20152a4:	00000406 	br	20152b8 <isatty+0x8c>
    }
  }
  else
  {
    ALT_ERRNO = EBADFD;
 20152a8:	20151dc0 	call	20151dc <alt_get_errno>
 20152ac:	00c01444 	movi	r3,81
 20152b0:	10c00015 	stw	r3,0(r2)
    return 0;
 20152b4:	0005883a 	mov	r2,zero
  }
}
 20152b8:	e037883a 	mov	sp,fp
 20152bc:	dfc00117 	ldw	ra,4(sp)
 20152c0:	df000017 	ldw	fp,0(sp)
 20152c4:	dec00204 	addi	sp,sp,8
 20152c8:	f800283a 	ret

020152cc <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20152cc:	defffe04 	addi	sp,sp,-8
 20152d0:	dfc00115 	stw	ra,4(sp)
 20152d4:	df000015 	stw	fp,0(sp)
 20152d8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20152dc:	00808174 	movhi	r2,517
 20152e0:	10907704 	addi	r2,r2,16860
 20152e4:	10800017 	ldw	r2,0(r2)
 20152e8:	10000526 	beq	r2,zero,2015300 <alt_get_errno+0x34>
 20152ec:	00808174 	movhi	r2,517
 20152f0:	10907704 	addi	r2,r2,16860
 20152f4:	10800017 	ldw	r2,0(r2)
 20152f8:	103ee83a 	callr	r2
 20152fc:	00000206 	br	2015308 <alt_get_errno+0x3c>
 2015300:	00808174 	movhi	r2,517
 2015304:	10908b04 	addi	r2,r2,16940
}
 2015308:	e037883a 	mov	sp,fp
 201530c:	dfc00117 	ldw	ra,4(sp)
 2015310:	df000017 	ldw	fp,0(sp)
 2015314:	dec00204 	addi	sp,sp,8
 2015318:	f800283a 	ret

0201531c <lseek>:
 * ALT_LSEEK is mapped onto the lseek() system call in alt_syscall.h
 *
 */

off_t ALT_LSEEK (int file, off_t ptr, int dir)
{
 201531c:	defff904 	addi	sp,sp,-28
 2015320:	dfc00615 	stw	ra,24(sp)
 2015324:	df000515 	stw	fp,20(sp)
 2015328:	df000504 	addi	fp,sp,20
 201532c:	e13ffd15 	stw	r4,-12(fp)
 2015330:	e17ffe15 	stw	r5,-8(fp)
 2015334:	e1bfff15 	stw	r6,-4(fp)
  alt_fd* fd;
  off_t   rc = 0; 
 2015338:	e03ffb15 	stw	zero,-20(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 201533c:	e0bffd17 	ldw	r2,-12(fp)
 2015340:	10000616 	blt	r2,zero,201535c <lseek+0x40>
 2015344:	e0bffd17 	ldw	r2,-12(fp)
 2015348:	10c00324 	muli	r3,r2,12
 201534c:	00808174 	movhi	r2,517
 2015350:	108f1e04 	addi	r2,r2,15480
 2015354:	1885883a 	add	r2,r3,r2
 2015358:	00000106 	br	2015360 <lseek+0x44>
 201535c:	0005883a 	mov	r2,zero
 2015360:	e0bffc15 	stw	r2,-16(fp)
  
  if (fd) 
 2015364:	e0bffc17 	ldw	r2,-16(fp)
 2015368:	10001026 	beq	r2,zero,20153ac <lseek+0x90>
    /*
     * If the device driver provides an implementation of the lseek() function,
     * then call that to process the request.
     */
 
    if (fd->dev->lseek)
 201536c:	e0bffc17 	ldw	r2,-16(fp)
 2015370:	10800017 	ldw	r2,0(r2)
 2015374:	10800717 	ldw	r2,28(r2)
 2015378:	10000926 	beq	r2,zero,20153a0 <lseek+0x84>
    {
      rc = fd->dev->lseek(fd, ptr, dir);
 201537c:	e0bffc17 	ldw	r2,-16(fp)
 2015380:	10800017 	ldw	r2,0(r2)
 2015384:	10800717 	ldw	r2,28(r2)
 2015388:	e13ffc17 	ldw	r4,-16(fp)
 201538c:	e17ffe17 	ldw	r5,-8(fp)
 2015390:	e1bfff17 	ldw	r6,-4(fp)
 2015394:	103ee83a 	callr	r2
 2015398:	e0bffb15 	stw	r2,-20(fp)
 201539c:	00000506 	br	20153b4 <lseek+0x98>
     * Otherwise return an error.
     */

    else
    {
      rc = -ENOTSUP;
 20153a0:	00bfde84 	movi	r2,-134
 20153a4:	e0bffb15 	stw	r2,-20(fp)
 20153a8:	00000206 	br	20153b4 <lseek+0x98>
    }
  }
  else  
  {
    rc = -EBADFD;
 20153ac:	00bfebc4 	movi	r2,-81
 20153b0:	e0bffb15 	stw	r2,-20(fp)
  }

  if (rc < 0)
 20153b4:	e0bffb17 	ldw	r2,-20(fp)
 20153b8:	1000060e 	bge	r2,zero,20153d4 <lseek+0xb8>
  {
    ALT_ERRNO = -rc;
 20153bc:	20152cc0 	call	20152cc <alt_get_errno>
 20153c0:	e0fffb17 	ldw	r3,-20(fp)
 20153c4:	00c7c83a 	sub	r3,zero,r3
 20153c8:	10c00015 	stw	r3,0(r2)
    rc = -1;
 20153cc:	00bfffc4 	movi	r2,-1
 20153d0:	e0bffb15 	stw	r2,-20(fp)
  }

  return rc;
 20153d4:	e0bffb17 	ldw	r2,-20(fp)
}
 20153d8:	e037883a 	mov	sp,fp
 20153dc:	dfc00117 	ldw	ra,4(sp)
 20153e0:	df000017 	ldw	fp,0(sp)
 20153e4:	dec00204 	addi	sp,sp,8
 20153e8:	f800283a 	ret

020153ec <alt_main>:
 * devices/filesystems/components in the system; and call the entry point for
 * the users application, i.e. main().
 */

void alt_main (void)
{
 20153ec:	defffb04 	addi	sp,sp,-20
 20153f0:	dfc00415 	stw	ra,16(sp)
 20153f4:	df000315 	stw	fp,12(sp)
 20153f8:	df000304 	addi	fp,sp,12
#endif

  /* ALT LOG - please see HAL/sys/alt_log_printf.h for details */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Entering alt_main, calling alt_irq_init.\r\n");
  /* Initialize the interrupt controller. */
  alt_irq_init (NULL);
 20153fc:	0009883a 	mov	r4,zero
 2015400:	201e6700 	call	201e670 <alt_irq_init>

  /* Initialize the operating system */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done alt_irq_init, calling alt_os_init.\r\n");
  ALT_OS_INIT();
 2015404:	20165740 	call	2016574 <OSInit>
 2015408:	01000044 	movi	r4,1
 201540c:	201bca80 	call	201bca8 <OSSemCreate>
 2015410:	00c08174 	movhi	r3,517
 2015414:	18d09804 	addi	r3,r3,16992
 2015418:	18800015 	stw	r2,0(r3)
 201541c:	01000044 	movi	r4,1
 2015420:	201bca80 	call	201bca8 <OSSemCreate>
 2015424:	00c08174 	movhi	r3,517
 2015428:	18d09a04 	addi	r3,r3,17000
 201542c:	18800015 	stw	r2,0(r3)
 2015430:	00808174 	movhi	r2,517
 2015434:	1090d704 	addi	r2,r2,17244
 2015438:	e0bffe15 	stw	r2,-8(fp)
 201543c:	00800044 	movi	r2,1
 2015440:	e0bfff0d 	sth	r2,-4(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 2015444:	e0bfff0b 	ldhu	r2,-4(fp)
 2015448:	1009883a 	mov	r4,r2
 201544c:	201bca80 	call	201bca8 <OSSemCreate>
 2015450:	e0fffe17 	ldw	r3,-8(fp)
 2015454:	18800015 	stw	r2,0(r3)
  return *sem ? 0 : -1;
 2015458:	0001883a 	nop
  ALT_LOG_PRINT_BOOT("[alt_main.c] Done OS Init, calling alt_sem_create.\r\n");
  ALT_SEM_CREATE (&alt_fd_list_lock, 1);

  /* Initialize the device drivers/software components. */
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling alt_sys_init.\r\n");
  alt_sys_init();
 201545c:	201e6a40 	call	201e6a4 <alt_sys_init>
   * devices be present (not equal to /dev/null) and if direct drivers
   * aren't being used.
   */

    ALT_LOG_PRINT_BOOT("[alt_main.c] Redirecting IO.\r\n");
    alt_io_redirect(ALT_STDOUT, ALT_STDIN, ALT_STDERR);
 2015460:	01008174 	movhi	r4,517
 2015464:	21385e04 	addi	r4,r4,-7816
 2015468:	01408174 	movhi	r5,517
 201546c:	29785e04 	addi	r5,r5,-7816
 2015470:	01808174 	movhi	r6,517
 2015474:	31b85e04 	addi	r6,r6,-7816
 2015478:	20377240 	call	2037724 <alt_io_redirect>
  /* 
   * Call the C++ constructors 
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling C++ constructors.\r\n");
  _do_ctors ();
 201547c:	2036fc00 	call	2036fc0 <_do_ctors>
   * redefined as _exit()). This is in the interest of reducing code footprint,
   * in that the atexit() overhead is removed when it's not needed.
   */

  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling atexit.\r\n");
  atexit (_do_dtors);
 2015480:	010080f4 	movhi	r4,515
 2015484:	211c0704 	addi	r4,r4,28700
 2015488:	204bcdc0 	call	204bcdc <atexit>
  ALT_LOG_PRINT_BOOT("[alt_main.c] Calling main.\r\n");

#ifdef ALT_NO_EXIT
  main (alt_argc, alt_argv, alt_envp);
#else
  result = main (alt_argc, alt_argv, alt_envp);
 201548c:	d1206817 	ldw	r4,-32352(gp)
 2015490:	d0e06917 	ldw	r3,-32348(gp)
 2015494:	d0a06a17 	ldw	r2,-32344(gp)
 2015498:	180b883a 	mov	r5,r3
 201549c:	100d883a 	mov	r6,r2
 20154a0:	200424c0 	call	200424c <main>
 20154a4:	e0bffd15 	stw	r2,-12(fp)
  close(STDOUT_FILENO);
 20154a8:	01000044 	movi	r4,1
 20154ac:	20237680 	call	2023768 <close>
  exit (result);
 20154b0:	e13ffd17 	ldw	r4,-12(fp)
 20154b4:	204bd0c0 	call	204bd0c <exit>

020154b8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20154b8:	defffe04 	addi	sp,sp,-8
 20154bc:	dfc00115 	stw	ra,4(sp)
 20154c0:	df000015 	stw	fp,0(sp)
 20154c4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20154c8:	00808174 	movhi	r2,517
 20154cc:	10907704 	addi	r2,r2,16860
 20154d0:	10800017 	ldw	r2,0(r2)
 20154d4:	10000526 	beq	r2,zero,20154ec <alt_get_errno+0x34>
 20154d8:	00808174 	movhi	r2,517
 20154dc:	10907704 	addi	r2,r2,16860
 20154e0:	10800017 	ldw	r2,0(r2)
 20154e4:	103ee83a 	callr	r2
 20154e8:	00000206 	br	20154f4 <alt_get_errno+0x3c>
 20154ec:	00808174 	movhi	r2,517
 20154f0:	10908b04 	addi	r2,r2,16940
}
 20154f4:	e037883a 	mov	sp,fp
 20154f8:	dfc00117 	ldw	ra,4(sp)
 20154fc:	df000017 	ldw	fp,0(sp)
 2015500:	dec00204 	addi	sp,sp,8
 2015504:	f800283a 	ret

02015508 <alt_file_locked>:
 * performed for devices. Filesystems are required to handle the ioctl() call
 * themselves, and report the error from the filesystems open() function. 
 */ 

static int alt_file_locked (alt_fd* fd)
{
 2015508:	defffd04 	addi	sp,sp,-12
 201550c:	df000215 	stw	fp,8(sp)
 2015510:	df000204 	addi	fp,sp,8
 2015514:	e13fff15 	stw	r4,-4(fp)

  /*
   * Mark the file descriptor as belonging to a device.
   */

  fd->fd_flags |= ALT_FD_DEV;
 2015518:	e0bfff17 	ldw	r2,-4(fp)
 201551c:	10800217 	ldw	r2,8(r2)
 2015520:	10d00034 	orhi	r3,r2,16384
 2015524:	e0bfff17 	ldw	r2,-4(fp)
 2015528:	10c00215 	stw	r3,8(r2)
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 201552c:	e03ffe15 	stw	zero,-8(fp)
 2015530:	00001d06 	br	20155a8 <alt_file_locked+0xa0>
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2015534:	00c08174 	movhi	r3,517
 2015538:	18cf1e04 	addi	r3,r3,15480
 201553c:	e0bffe17 	ldw	r2,-8(fp)
 2015540:	10800324 	muli	r2,r2,12
 2015544:	1885883a 	add	r2,r3,r2
 2015548:	10c00017 	ldw	r3,0(r2)
 201554c:	e0bfff17 	ldw	r2,-4(fp)
 2015550:	10800017 	ldw	r2,0(r2)
 2015554:	1880111e 	bne	r3,r2,201559c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 2015558:	00c08174 	movhi	r3,517
 201555c:	18cf1e04 	addi	r3,r3,15480
 2015560:	e0bffe17 	ldw	r2,-8(fp)
 2015564:	10800324 	muli	r2,r2,12
 2015568:	1885883a 	add	r2,r3,r2
 201556c:	10800204 	addi	r2,r2,8
 2015570:	10800017 	ldw	r2,0(r2)
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
 2015574:	1000090e 	bge	r2,zero,201559c <alt_file_locked+0x94>
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
        (&alt_fd_list[i] != fd))
 2015578:	e0bffe17 	ldw	r2,-8(fp)
 201557c:	10c00324 	muli	r3,r2,12
 2015580:	00808174 	movhi	r2,517
 2015584:	108f1e04 	addi	r2,r2,15480
 2015588:	1887883a 	add	r3,r3,r2
   */

  for (i = 0; i <= alt_max_fd; i++)
  {
    if ((alt_fd_list[i].dev == fd->dev) &&
        (alt_fd_list[i].fd_flags & ALT_FD_EXCL) &&
 201558c:	e0bfff17 	ldw	r2,-4(fp)
 2015590:	18800226 	beq	r3,r2,201559c <alt_file_locked+0x94>
        (&alt_fd_list[i] != fd))
    {
      return -EACCES;
 2015594:	00bffcc4 	movi	r2,-13
 2015598:	00000a06 	br	20155c4 <alt_file_locked+0xbc>
  /*
   * Loop through all current file descriptors searching for one that's locked
   * for exclusive access. If a match is found, generate an error.
   */

  for (i = 0; i <= alt_max_fd; i++)
 201559c:	e0bffe17 	ldw	r2,-8(fp)
 20155a0:	10800044 	addi	r2,r2,1
 20155a4:	e0bffe15 	stw	r2,-8(fp)
 20155a8:	00808174 	movhi	r2,517
 20155ac:	10907604 	addi	r2,r2,16856
 20155b0:	10800017 	ldw	r2,0(r2)
 20155b4:	1007883a 	mov	r3,r2
 20155b8:	e0bffe17 	ldw	r2,-8(fp)
 20155bc:	18bfdd2e 	bgeu	r3,r2,2015534 <alt_file_locked+0x2c>
    }
  }
  
  /* The device is not locked */
 
  return 0;
 20155c0:	0005883a 	mov	r2,zero
}
 20155c4:	e037883a 	mov	sp,fp
 20155c8:	df000017 	ldw	fp,0(sp)
 20155cc:	dec00104 	addi	sp,sp,4
 20155d0:	f800283a 	ret

020155d4 <open>:
 *
 * ALT_OPEN is mapped onto the open() system call in alt_syscall.h
 */
 
int ALT_OPEN (const char* file, int flags, int mode)
{ 
 20155d4:	defff604 	addi	sp,sp,-40
 20155d8:	dfc00915 	stw	ra,36(sp)
 20155dc:	df000815 	stw	fp,32(sp)
 20155e0:	df000804 	addi	fp,sp,32
 20155e4:	e13ffd15 	stw	r4,-12(fp)
 20155e8:	e17ffe15 	stw	r5,-8(fp)
 20155ec:	e1bfff15 	stw	r6,-4(fp)
  alt_dev* dev;
  alt_fd*  fd;
  int index  = -1;
 20155f0:	00bfffc4 	movi	r2,-1
 20155f4:	e0bff915 	stw	r2,-28(fp)
  int status = -ENODEV;
 20155f8:	00bffb44 	movi	r2,-19
 20155fc:	e0bffa15 	stw	r2,-24(fp)
  int isafs = 0;
 2015600:	e03ffb15 	stw	zero,-20(fp)
  /* 
   * Check the device list, to see if a device with a matching name is 
   * registered.
   */
  
  if (!(dev = alt_find_dev (file, &alt_dev_list)))
 2015604:	e13ffd17 	ldw	r4,-12(fp)
 2015608:	01408174 	movhi	r5,517
 201560c:	29507404 	addi	r5,r5,16848
 2015610:	20370780 	call	2037078 <alt_find_dev>
 2015614:	e0bff815 	stw	r2,-32(fp)
 2015618:	e0bff817 	ldw	r2,-32(fp)
 201561c:	1000051e 	bne	r2,zero,2015634 <open+0x60>
  {
    /* No matching device, so try the filesystem list */

    dev   = alt_find_file (file);
 2015620:	e13ffd17 	ldw	r4,-12(fp)
 2015624:	20371080 	call	2037108 <alt_find_file>
 2015628:	e0bff815 	stw	r2,-32(fp)
    isafs = 1;
 201562c:	00800044 	movi	r2,1
 2015630:	e0bffb15 	stw	r2,-20(fp)

  /* 
   * If a matching device or filesystem is found, allocate a file descriptor. 
   */

  if (dev)
 2015634:	e0bff817 	ldw	r2,-32(fp)
 2015638:	10002926 	beq	r2,zero,20156e0 <open+0x10c>
  {
    if ((index = alt_get_fd (dev)) < 0)
 201563c:	e13ff817 	ldw	r4,-32(fp)
 2015640:	20372a00 	call	20372a0 <alt_get_fd>
 2015644:	e0bff915 	stw	r2,-28(fp)
 2015648:	e0bff917 	ldw	r2,-28(fp)
 201564c:	1000030e 	bge	r2,zero,201565c <open+0x88>
    {
      status = index;
 2015650:	e0bff917 	ldw	r2,-28(fp)
 2015654:	e0bffa15 	stw	r2,-24(fp)
 2015658:	00002306 	br	20156e8 <open+0x114>
    }
    else
    {
      fd = &alt_fd_list[index];
 201565c:	e0bff917 	ldw	r2,-28(fp)
 2015660:	10c00324 	muli	r3,r2,12
 2015664:	00808174 	movhi	r2,517
 2015668:	108f1e04 	addi	r2,r2,15480
 201566c:	1885883a 	add	r2,r3,r2
 2015670:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags = (flags & ~ALT_FD_FLAGS_MASK);
 2015674:	e0fffe17 	ldw	r3,-8(fp)
 2015678:	00900034 	movhi	r2,16384
 201567c:	10bfffc4 	addi	r2,r2,-1
 2015680:	1886703a 	and	r3,r3,r2
 2015684:	e0bffc17 	ldw	r2,-16(fp)
 2015688:	10c00215 	stw	r3,8(r2)
      
      /* If this is a device, ensure it isn't already locked */

      if (isafs || ((status = alt_file_locked (fd)) >= 0))
 201568c:	e0bffb17 	ldw	r2,-20(fp)
 2015690:	1000051e 	bne	r2,zero,20156a8 <open+0xd4>
 2015694:	e13ffc17 	ldw	r4,-16(fp)
 2015698:	20155080 	call	2015508 <alt_file_locked>
 201569c:	e0bffa15 	stw	r2,-24(fp)
 20156a0:	e0bffa17 	ldw	r2,-24(fp)
 20156a4:	10001016 	blt	r2,zero,20156e8 <open+0x114>
        /* 
         * If the device or filesystem provides an open() callback function,
         * call it now to perform any device/filesystem specific operations.
         */
    
        status = (dev->open) ? dev->open(fd, file, flags, mode): 0;
 20156a8:	e0bff817 	ldw	r2,-32(fp)
 20156ac:	10800317 	ldw	r2,12(r2)
 20156b0:	10000826 	beq	r2,zero,20156d4 <open+0x100>
 20156b4:	e0bff817 	ldw	r2,-32(fp)
 20156b8:	10800317 	ldw	r2,12(r2)
 20156bc:	e13ffc17 	ldw	r4,-16(fp)
 20156c0:	e17ffd17 	ldw	r5,-12(fp)
 20156c4:	e1bffe17 	ldw	r6,-8(fp)
 20156c8:	e1ffff17 	ldw	r7,-4(fp)
 20156cc:	103ee83a 	callr	r2
 20156d0:	00000106 	br	20156d8 <open+0x104>
 20156d4:	0005883a 	mov	r2,zero
 20156d8:	e0bffa15 	stw	r2,-24(fp)
 20156dc:	00000206 	br	20156e8 <open+0x114>
      }
    }
  }
  else
  {
    status = -ENODEV;
 20156e0:	00bffb44 	movi	r2,-19
 20156e4:	e0bffa15 	stw	r2,-24(fp)
  }

  /* Allocation failed, so clean up and return an error */ 

  if (status < 0)
 20156e8:	e0bffa17 	ldw	r2,-24(fp)
 20156ec:	1000080e 	bge	r2,zero,2015710 <open+0x13c>
  {
    alt_release_fd (index);  
 20156f0:	e13ff917 	ldw	r4,-28(fp)
 20156f4:	20157280 	call	2015728 <alt_release_fd>
    ALT_ERRNO = -status;
 20156f8:	20154b80 	call	20154b8 <alt_get_errno>
 20156fc:	e0fffa17 	ldw	r3,-24(fp)
 2015700:	00c7c83a 	sub	r3,zero,r3
 2015704:	10c00015 	stw	r3,0(r2)
    return -1;
 2015708:	00bfffc4 	movi	r2,-1
 201570c:	00000106 	br	2015714 <open+0x140>
  }
  
  /* return the reference upon success */

  return index;
 2015710:	e0bff917 	ldw	r2,-28(fp)
}
 2015714:	e037883a 	mov	sp,fp
 2015718:	dfc00117 	ldw	ra,4(sp)
 201571c:	df000017 	ldw	fp,0(sp)
 2015720:	dec00204 	addi	sp,sp,8
 2015724:	f800283a 	ret

02015728 <alt_release_fd>:
 * File descriptors correcponding to standard in, standard out and standard 
 * error cannont be released backed to the pool. They are always reserved.
 */

void alt_release_fd (int fd)
{
 2015728:	defffe04 	addi	sp,sp,-8
 201572c:	df000115 	stw	fp,4(sp)
 2015730:	df000104 	addi	fp,sp,4
 2015734:	e13fff15 	stw	r4,-4(fp)
  if (fd > 2)
 2015738:	e0bfff17 	ldw	r2,-4(fp)
 201573c:	108000d0 	cmplti	r2,r2,3
 2015740:	10000d1e 	bne	r2,zero,2015778 <alt_release_fd+0x50>
  {
    alt_fd_list[fd].fd_flags = 0;
 2015744:	00c08174 	movhi	r3,517
 2015748:	18cf1e04 	addi	r3,r3,15480
 201574c:	e0bfff17 	ldw	r2,-4(fp)
 2015750:	10800324 	muli	r2,r2,12
 2015754:	1885883a 	add	r2,r3,r2
 2015758:	10800204 	addi	r2,r2,8
 201575c:	10000015 	stw	zero,0(r2)
    alt_fd_list[fd].dev      = 0;
 2015760:	00c08174 	movhi	r3,517
 2015764:	18cf1e04 	addi	r3,r3,15480
 2015768:	e0bfff17 	ldw	r2,-4(fp)
 201576c:	10800324 	muli	r2,r2,12
 2015770:	1885883a 	add	r2,r3,r2
 2015774:	10000015 	stw	zero,0(r2)
  }
}
 2015778:	e037883a 	mov	sp,fp
 201577c:	df000017 	ldw	fp,0(sp)
 2015780:	dec00104 	addi	sp,sp,4
 2015784:	f800283a 	ret

02015788 <sbrk>:
#endif
 
caddr_t ALT_SBRK (int incr) __attribute__ ((no_instrument_function ));

caddr_t ALT_SBRK (int incr)
{ 
 2015788:	defff904 	addi	sp,sp,-28
 201578c:	df000615 	stw	fp,24(sp)
 2015790:	df000604 	addi	fp,sp,24
 2015794:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015798:	0005303a 	rdctl	r2,status
 201579c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20157a0:	e0fffc17 	ldw	r3,-16(fp)
 20157a4:	00bfff84 	movi	r2,-2
 20157a8:	1884703a 	and	r2,r3,r2
 20157ac:	1001703a 	wrctl	status,r2
  
  return context;
 20157b0:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context context;
  char *prev_heap_end; 

  context = alt_irq_disable_all();
 20157b4:	e0bffa15 	stw	r2,-24(fp)

  /* Always return data aligned on a word boundary */
  heap_end = (char *)(((unsigned int)heap_end + 3) & ~3);
 20157b8:	d0a01217 	ldw	r2,-32696(gp)
 20157bc:	10c000c4 	addi	r3,r2,3
 20157c0:	00bfff04 	movi	r2,-4
 20157c4:	1884703a 	and	r2,r3,r2
 20157c8:	d0a01215 	stw	r2,-32696(gp)
  if (((heap_end + incr) - __alt_heap_start) > ALT_MAX_HEAP_BYTES) {
    alt_irq_enable_all(context);
    return (caddr_t)-1;
  }
#else
  if ((heap_end + incr) > __alt_heap_limit) {
 20157cc:	d0e01217 	ldw	r3,-32696(gp)
 20157d0:	e0bfff17 	ldw	r2,-4(fp)
 20157d4:	1885883a 	add	r2,r3,r2
 20157d8:	00c10034 	movhi	r3,1024
 20157dc:	18c00004 	addi	r3,r3,0
 20157e0:	1880062e 	bgeu	r3,r2,20157fc <sbrk+0x74>
 20157e4:	e0bffa17 	ldw	r2,-24(fp)
 20157e8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20157ec:	e0bffd17 	ldw	r2,-12(fp)
 20157f0:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
    return (caddr_t)-1;
 20157f4:	00bfffc4 	movi	r2,-1
 20157f8:	00000b06 	br	2015828 <sbrk+0xa0>
  }
#endif

  prev_heap_end = heap_end; 
 20157fc:	d0a01217 	ldw	r2,-32696(gp)
 2015800:	e0bffb15 	stw	r2,-20(fp)
  heap_end += incr; 
 2015804:	d0e01217 	ldw	r3,-32696(gp)
 2015808:	e0bfff17 	ldw	r2,-4(fp)
 201580c:	1885883a 	add	r2,r3,r2
 2015810:	d0a01215 	stw	r2,-32696(gp)
 2015814:	e0bffa17 	ldw	r2,-24(fp)
 2015818:	e0bffe15 	stw	r2,-8(fp)
 201581c:	e0bffe17 	ldw	r2,-8(fp)
 2015820:	1001703a 	wrctl	status,r2

#endif

  alt_irq_enable_all(context);

  return (caddr_t) prev_heap_end; 
 2015824:	e0bffb17 	ldw	r2,-20(fp)
} 
 2015828:	e037883a 	mov	sp,fp
 201582c:	df000017 	ldw	fp,0(sp)
 2015830:	dec00104 	addi	sp,sp,4
 2015834:	f800283a 	ret

02015838 <alt_alarm_stop>:
 * alarms. Alternatively an alarm can unregister itself by returning zero when 
 * the alarm executes.
 */

void alt_alarm_stop (alt_alarm* alarm)
{
 2015838:	defffa04 	addi	sp,sp,-24
 201583c:	df000515 	stw	fp,20(sp)
 2015840:	df000504 	addi	fp,sp,20
 2015844:	e13fff15 	stw	r4,-4(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015848:	0005303a 	rdctl	r2,status
 201584c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2015850:	e0fffc17 	ldw	r3,-16(fp)
 2015854:	00bfff84 	movi	r2,-2
 2015858:	1884703a 	and	r2,r3,r2
 201585c:	1001703a 	wrctl	status,r2
  
  return context;
 2015860:	e0bffc17 	ldw	r2,-16(fp)
  alt_irq_context irq_context;

  irq_context = alt_irq_disable_all();
 2015864:	e0bffb15 	stw	r2,-20(fp)
  alt_llist_remove (&alarm->llist);
 2015868:	e0bfff17 	ldw	r2,-4(fp)
 201586c:	e0bffd15 	stw	r2,-12(fp)
 * input argument is the element to remove.
 */
     
static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_remove(alt_llist* entry)
{
  entry->next->previous = entry->previous;
 2015870:	e0bffd17 	ldw	r2,-12(fp)
 2015874:	10800017 	ldw	r2,0(r2)
 2015878:	e0fffd17 	ldw	r3,-12(fp)
 201587c:	18c00117 	ldw	r3,4(r3)
 2015880:	10c00115 	stw	r3,4(r2)
  entry->previous->next = entry->next;
 2015884:	e0bffd17 	ldw	r2,-12(fp)
 2015888:	10800117 	ldw	r2,4(r2)
 201588c:	e0fffd17 	ldw	r3,-12(fp)
 2015890:	18c00017 	ldw	r3,0(r3)
 2015894:	10c00015 	stw	r3,0(r2)
  /* 
   * Set the entry to point to itself, so that any further calls to
   * alt_llist_remove() are harmless.
   */

  entry->previous = entry;
 2015898:	e0bffd17 	ldw	r2,-12(fp)
 201589c:	e0fffd17 	ldw	r3,-12(fp)
 20158a0:	10c00115 	stw	r3,4(r2)
  entry->next     = entry;
 20158a4:	e0bffd17 	ldw	r2,-12(fp)
 20158a8:	e0fffd17 	ldw	r3,-12(fp)
 20158ac:	10c00015 	stw	r3,0(r2)
 20158b0:	e0bffb17 	ldw	r2,-20(fp)
 20158b4:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20158b8:	e0bffe17 	ldw	r2,-8(fp)
 20158bc:	1001703a 	wrctl	status,r2
  alt_irq_enable_all (irq_context);
}
 20158c0:	e037883a 	mov	sp,fp
 20158c4:	df000017 	ldw	fp,0(sp)
 20158c8:	dec00104 	addi	sp,sp,4
 20158cc:	f800283a 	ret

020158d0 <alt_tick>:
 * 
 * alt_tick() is expected to run at interrupt level.
 */

void alt_tick (void)
{
 20158d0:	defffb04 	addi	sp,sp,-20
 20158d4:	dfc00415 	stw	ra,16(sp)
 20158d8:	df000315 	stw	fp,12(sp)
 20158dc:	df000304 	addi	fp,sp,12
  alt_alarm* next;
  alt_alarm* alarm = (alt_alarm*) alt_alarm_list.next;
 20158e0:	d0a01317 	ldw	r2,-32692(gp)
 20158e4:	e0bffd15 	stw	r2,-12(fp)

  alt_u32    next_callback;

  /* update the tick counter */

  _alt_nticks++;
 20158e8:	d0a06c17 	ldw	r2,-32336(gp)
 20158ec:	10800044 	addi	r2,r2,1
 20158f0:	d0a06c15 	stw	r2,-32336(gp)

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 20158f4:	00002e06 	br	20159b0 <alt_tick+0xe0>
  {
    next = (alt_alarm*) alarm->llist.next;
 20158f8:	e0bffd17 	ldw	r2,-12(fp)
 20158fc:	10800017 	ldw	r2,0(r2)
 2015900:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Upon the tick-counter rolling over it is safe to clear the 
     * roll-over flag; once the flag is cleared this (or subsequnt)
     * tick events are enabled to generate an alarm event. 
     */
    if ((alarm->rollover) && (_alt_nticks == 0))
 2015904:	e0bffd17 	ldw	r2,-12(fp)
 2015908:	10800403 	ldbu	r2,16(r2)
 201590c:	10803fcc 	andi	r2,r2,255
 2015910:	10000426 	beq	r2,zero,2015924 <alt_tick+0x54>
 2015914:	d0a06c17 	ldw	r2,-32336(gp)
 2015918:	1000021e 	bne	r2,zero,2015924 <alt_tick+0x54>
    {
      alarm->rollover = 0;
 201591c:	e0bffd17 	ldw	r2,-12(fp)
 2015920:	10000405 	stb	zero,16(r2)
    }
    
    /* if the alarm period has expired, make the callback */    
    if ((alarm->time <= _alt_nticks) && (alarm->rollover == 0))
 2015924:	e0bffd17 	ldw	r2,-12(fp)
 2015928:	10800217 	ldw	r2,8(r2)
 201592c:	d0e06c17 	ldw	r3,-32336(gp)
 2015930:	18801d36 	bltu	r3,r2,20159a8 <alt_tick+0xd8>
 2015934:	e0bffd17 	ldw	r2,-12(fp)
 2015938:	10800403 	ldbu	r2,16(r2)
 201593c:	10803fcc 	andi	r2,r2,255
 2015940:	1000191e 	bne	r2,zero,20159a8 <alt_tick+0xd8>
    {
      next_callback = alarm->callback (alarm->context);
 2015944:	e0bffd17 	ldw	r2,-12(fp)
 2015948:	10c00317 	ldw	r3,12(r2)
 201594c:	e0bffd17 	ldw	r2,-12(fp)
 2015950:	10800517 	ldw	r2,20(r2)
 2015954:	1009883a 	mov	r4,r2
 2015958:	183ee83a 	callr	r3
 201595c:	e0bfff15 	stw	r2,-4(fp)

      /* deactivate the alarm if the return value is zero */

      if (next_callback == 0)
 2015960:	e0bfff17 	ldw	r2,-4(fp)
 2015964:	1000031e 	bne	r2,zero,2015974 <alt_tick+0xa4>
      {
        alt_alarm_stop (alarm);
 2015968:	e13ffd17 	ldw	r4,-12(fp)
 201596c:	20158380 	call	2015838 <alt_alarm_stop>
 2015970:	00000d06 	br	20159a8 <alt_tick+0xd8>
      }
      else
      {
        alarm->time += next_callback;
 2015974:	e0bffd17 	ldw	r2,-12(fp)
 2015978:	10c00217 	ldw	r3,8(r2)
 201597c:	e0bfff17 	ldw	r2,-4(fp)
 2015980:	1887883a 	add	r3,r3,r2
 2015984:	e0bffd17 	ldw	r2,-12(fp)
 2015988:	10c00215 	stw	r3,8(r2)
        /* 
         * If the desired alarm time causes a roll-over, set the rollover
         * flag. This will prevent the subsequent tick event from causing
         * an alarm too early.
         */
        if(alarm->time < _alt_nticks)
 201598c:	e0bffd17 	ldw	r2,-12(fp)
 2015990:	10c00217 	ldw	r3,8(r2)
 2015994:	d0a06c17 	ldw	r2,-32336(gp)
 2015998:	1880032e 	bgeu	r3,r2,20159a8 <alt_tick+0xd8>
        {
          alarm->rollover = 1;
 201599c:	e0bffd17 	ldw	r2,-12(fp)
 20159a0:	00c00044 	movi	r3,1
 20159a4:	10c00405 	stb	r3,16(r2)
        }
      }
    }
    alarm = next;
 20159a8:	e0bffe17 	ldw	r2,-8(fp)
 20159ac:	e0bffd15 	stw	r2,-12(fp)

  _alt_nticks++;

  /* process the registered callbacks */

  while (alarm != (alt_alarm*) &alt_alarm_list)
 20159b0:	e0fffd17 	ldw	r3,-12(fp)
 20159b4:	d0a01304 	addi	r2,gp,-32692
 20159b8:	18bfcf1e 	bne	r3,r2,20158f8 <alt_tick+0x28>

  /* 
   * Update the operating system specific timer facilities.
   */

  ALT_OS_TIME_TICK();
 20159bc:	20169b00 	call	20169b0 <OSTimeTick>
}
 20159c0:	e037883a 	mov	sp,fp
 20159c4:	dfc00117 	ldw	ra,4(sp)
 20159c8:	df000017 	ldw	fp,0(sp)
 20159cc:	dec00204 	addi	sp,sp,8
 20159d0:	f800283a 	ret

020159d4 <__env_lock>:
/*
 *
 */

void __env_lock ( struct _reent *_r )
{
 20159d4:	deffdf04 	addi	sp,sp,-132
 20159d8:	dfc02015 	stw	ra,128(sp)
 20159dc:	df001f15 	stw	fp,124(sp)
 20159e0:	df001f04 	addi	fp,sp,124
 20159e4:	e13fff15 	stw	r4,-4(fp)
  INT8U err;
  int id;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 20159e8:	e0bfe204 	addi	r2,fp,-120
 20159ec:	01003fc4 	movi	r4,255
 20159f0:	100b883a 	mov	r5,r2
 20159f4:	201de700 	call	201de70 <OSTaskQuery>
 20159f8:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 20159fc:	e0bffe83 	ldbu	r2,-6(fp)
 2015a00:	10803fcc 	andi	r2,r2,255
 2015a04:	10001c1e 	bne	r2,zero,2015a78 <__env_lock+0xa4>
    return;

  id = tcb.OSTCBPrio;
 2015a08:	e0bfee83 	ldbu	r2,-70(fp)
 2015a0c:	10803fcc 	andi	r2,r2,255
 2015a10:	e0bfe115 	stw	r2,-124(fp)
   
  /* see if we own the environment already */

  OSSemQuery( alt_envsem, &semdata );
 2015a14:	d0e06e17 	ldw	r3,-32328(gp)
 2015a18:	e0bffd04 	addi	r2,fp,-12
 2015a1c:	1809883a 	mov	r4,r3
 2015a20:	100b883a 	mov	r5,r2
 2015a24:	201c5080 	call	201c508 <OSSemQuery>
  if( semdata.OSEventGrp && id == lockid ) 
 2015a28:	e0bffe43 	ldbu	r2,-7(fp)
 2015a2c:	10803fcc 	andi	r2,r2,255
 2015a30:	10000726 	beq	r2,zero,2015a50 <__env_lock+0x7c>
 2015a34:	d0a01517 	ldw	r2,-32684(gp)
 2015a38:	e0ffe117 	ldw	r3,-124(fp)
 2015a3c:	1880041e 	bne	r3,r2,2015a50 <__env_lock+0x7c>
  {
    /* we do; just count the recursion */

    locks++;
 2015a40:	d0a06d17 	ldw	r2,-32332(gp)
 2015a44:	10800044 	addi	r2,r2,1
 2015a48:	d0a06d15 	stw	r2,-32332(gp)
 2015a4c:	00000a06 	br	2015a78 <__env_lock+0xa4>
  }
  else 
  {
    /* wait on the other task to yield, then claim ownership */

    OSSemPend( alt_envsem, 0, &err );
 2015a50:	d0e06e17 	ldw	r3,-32328(gp)
 2015a54:	e0bffe84 	addi	r2,fp,-6
 2015a58:	1809883a 	mov	r4,r3
 2015a5c:	000b883a 	mov	r5,zero
 2015a60:	100d883a 	mov	r6,r2
 2015a64:	201c0180 	call	201c018 <OSSemPend>
    locks  = 1;
 2015a68:	00800044 	movi	r2,1
 2015a6c:	d0a06d15 	stw	r2,-32332(gp)
    lockid = id;
 2015a70:	e0bfe117 	ldw	r2,-124(fp)
 2015a74:	d0a01515 	stw	r2,-32684(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 2015a78:	e037883a 	mov	sp,fp
 2015a7c:	dfc00117 	ldw	ra,4(sp)
 2015a80:	df000017 	ldw	fp,0(sp)
 2015a84:	dec00204 	addi	sp,sp,8
 2015a88:	f800283a 	ret

02015a8c <__env_unlock>:
/*
 *
 */

void __env_unlock ( struct _reent *_r )
{
 2015a8c:	defffd04 	addi	sp,sp,-12
 2015a90:	dfc00215 	stw	ra,8(sp)
 2015a94:	df000115 	stw	fp,4(sp)
 2015a98:	df000104 	addi	fp,sp,4
 2015a9c:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
 2015aa0:	d0a06d17 	ldw	r2,-32332(gp)
 2015aa4:	10000b26 	beq	r2,zero,2015ad4 <__env_unlock+0x48>
   /* 
    * release the environment once the number of locks == the number 
    * of unlocks 
    */

  if( (--locks) == 0 ) 
 2015aa8:	d0a06d17 	ldw	r2,-32332(gp)
 2015aac:	10bfffc4 	addi	r2,r2,-1
 2015ab0:	d0a06d15 	stw	r2,-32332(gp)
 2015ab4:	d0a06d17 	ldw	r2,-32332(gp)
 2015ab8:	1000071e 	bne	r2,zero,2015ad8 <__env_unlock+0x4c>
  {
    lockid = -1;
 2015abc:	00bfffc4 	movi	r2,-1
 2015ac0:	d0a01515 	stw	r2,-32684(gp)
    OSSemPost( alt_envsem );
 2015ac4:	d0a06e17 	ldw	r2,-32328(gp)
 2015ac8:	1009883a 	mov	r4,r2
 2015acc:	201c3f80 	call	201c3f8 <OSSemPost>
 2015ad0:	00000106 	br	2015ad8 <__env_unlock+0x4c>

void __env_unlock ( struct _reent *_r )
{
#if OS_THREAD_SAFE_NEWLIB
  if (locks == 0)
    return;
 2015ad4:	0001883a 	nop
  {
    lockid = -1;
    OSSemPost( alt_envsem );
  }
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 2015ad8:	e037883a 	mov	sp,fp
 2015adc:	dfc00117 	ldw	ra,4(sp)
 2015ae0:	df000017 	ldw	fp,0(sp)
 2015ae4:	dec00204 	addi	sp,sp,8
 2015ae8:	f800283a 	ret

02015aec <__malloc_lock>:
/*
 *
 */

void __malloc_lock ( struct _reent *_r )
{
 2015aec:	deffdb04 	addi	sp,sp,-148
 2015af0:	dfc02415 	stw	ra,144(sp)
 2015af4:	df002315 	stw	fp,140(sp)
 2015af8:	df002304 	addi	fp,sp,140
 2015afc:	e13fff15 	stw	r4,-4(fp)
  OS_TCB tcb;
  OS_SEM_DATA semdata;
  INT8U err;
  int id;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2015b00:	e03fdd15 	stw	zero,-140(fp)
#endif  
  
  if (OSRunning != OS_TRUE)
 2015b04:	00808174 	movhi	r2,517
 2015b08:	10909b44 	addi	r2,r2,17005
 2015b0c:	10800003 	ldbu	r2,0(r2)
 2015b10:	10803fcc 	andi	r2,r2,255
 2015b14:	10800058 	cmpnei	r2,r2,1
 2015b18:	1000341e 	bne	r2,zero,2015bec <__malloc_lock+0x100>
      return;

  /* use our priority as a task id */

  err = OSTaskQuery( OS_PRIO_SELF, &tcb );
 2015b1c:	e0bfe204 	addi	r2,fp,-120
 2015b20:	01003fc4 	movi	r4,255
 2015b24:	100b883a 	mov	r5,r2
 2015b28:	201de700 	call	201de70 <OSTaskQuery>
 2015b2c:	e0bffe85 	stb	r2,-6(fp)
  if (err != OS_NO_ERR)
 2015b30:	e0bffe83 	ldbu	r2,-6(fp)
 2015b34:	10803fcc 	andi	r2,r2,255
 2015b38:	10002c1e 	bne	r2,zero,2015bec <__malloc_lock+0x100>
    return;

  id = tcb.OSTCBPrio;
 2015b3c:	e0bfee83 	ldbu	r2,-70(fp)
 2015b40:	10803fcc 	andi	r2,r2,255
 2015b44:	e0bfde15 	stw	r2,-136(fp)
   
  /* see if we own the heap already */

  OSSemQuery( alt_heapsem, &semdata );
 2015b48:	d0e07017 	ldw	r3,-32320(gp)
 2015b4c:	e0bffd04 	addi	r2,fp,-12
 2015b50:	1809883a 	mov	r4,r3
 2015b54:	100b883a 	mov	r5,r2
 2015b58:	201c5080 	call	201c508 <OSSemQuery>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015b5c:	0005303a 	rdctl	r2,status
 2015b60:	e0bfdf15 	stw	r2,-132(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2015b64:	e0ffdf17 	ldw	r3,-132(fp)
 2015b68:	00bfff84 	movi	r2,-2
 2015b6c:	1884703a 	and	r2,r3,r2
 2015b70:	1001703a 	wrctl	status,r2
  
  return context;
 2015b74:	e0bfdf17 	ldw	r2,-132(fp)
  
  OS_ENTER_CRITICAL();
 2015b78:	e0bfdd15 	stw	r2,-140(fp)

  if( !semdata.OSCnt && id == lockid ) 
 2015b7c:	e0bffd0b 	ldhu	r2,-12(fp)
 2015b80:	10bfffcc 	andi	r2,r2,65535
 2015b84:	10000b1e 	bne	r2,zero,2015bb4 <__malloc_lock+0xc8>
 2015b88:	d0a01617 	ldw	r2,-32680(gp)
 2015b8c:	e0ffde17 	ldw	r3,-136(fp)
 2015b90:	1880081e 	bne	r3,r2,2015bb4 <__malloc_lock+0xc8>
  {
    /* we do; just count the recursion */
    locks++;
 2015b94:	d0a06f17 	ldw	r2,-32324(gp)
 2015b98:	10800044 	addi	r2,r2,1
 2015b9c:	d0a06f15 	stw	r2,-32324(gp)
 2015ba0:	e0bfdd17 	ldw	r2,-140(fp)
 2015ba4:	e0bfe015 	stw	r2,-128(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015ba8:	e0bfe017 	ldw	r2,-128(fp)
 2015bac:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
 2015bb0:	00000e06 	br	2015bec <__malloc_lock+0x100>
 2015bb4:	e0bfdd17 	ldw	r2,-140(fp)
 2015bb8:	e0bfe115 	stw	r2,-124(fp)
 2015bbc:	e0bfe117 	ldw	r2,-124(fp)
 2015bc0:	1001703a 	wrctl	status,r2
  else 
  {
    /* wait on the other task to yield the heap, then claim ownership of it */
    OS_EXIT_CRITICAL();

    OSSemPend( alt_heapsem, 0, &err );
 2015bc4:	d0e07017 	ldw	r3,-32320(gp)
 2015bc8:	e0bffe84 	addi	r2,fp,-6
 2015bcc:	1809883a 	mov	r4,r3
 2015bd0:	000b883a 	mov	r5,zero
 2015bd4:	100d883a 	mov	r6,r2
 2015bd8:	201c0180 	call	201c018 <OSSemPend>
    locks  = 1;
 2015bdc:	00800044 	movi	r2,1
 2015be0:	d0a06f15 	stw	r2,-32324(gp)
    lockid = id;
 2015be4:	e0bfde17 	ldw	r2,-136(fp)
 2015be8:	d0a01615 	stw	r2,-32680(gp)
  }

#endif /* OS_THREAD_SAFE_NEWLIB */
  return;
}
 2015bec:	e037883a 	mov	sp,fp
 2015bf0:	dfc00117 	ldw	ra,4(sp)
 2015bf4:	df000017 	ldw	fp,0(sp)
 2015bf8:	dec00204 	addi	sp,sp,8
 2015bfc:	f800283a 	ret

02015c00 <__malloc_unlock>:
/*
 *
 */

void __malloc_unlock ( struct _reent *_r )
{
 2015c00:	defff804 	addi	sp,sp,-32
 2015c04:	dfc00715 	stw	ra,28(sp)
 2015c08:	df000615 	stw	fp,24(sp)
 2015c0c:	df000604 	addi	fp,sp,24
 2015c10:	e13fff15 	stw	r4,-4(fp)
#if OS_THREAD_SAFE_NEWLIB

#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2015c14:	e03ffa15 	stw	zero,-24(fp)
#endif 

  if (OSRunning != OS_TRUE)
 2015c18:	00808174 	movhi	r2,517
 2015c1c:	10909b44 	addi	r2,r2,17005
 2015c20:	10800003 	ldbu	r2,0(r2)
 2015c24:	10803fcc 	andi	r2,r2,255
 2015c28:	10800060 	cmpeqi	r2,r2,1
 2015c2c:	10002326 	beq	r2,zero,2015cbc <__malloc_unlock+0xbc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015c30:	0005303a 	rdctl	r2,status
 2015c34:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2015c38:	e0fffb17 	ldw	r3,-20(fp)
 2015c3c:	00bfff84 	movi	r2,-2
 2015c40:	1884703a 	and	r2,r3,r2
 2015c44:	1001703a 	wrctl	status,r2
  
  return context;
 2015c48:	e0bffb17 	ldw	r2,-20(fp)
      return;

  OS_ENTER_CRITICAL();
 2015c4c:	e0bffa15 	stw	r2,-24(fp)
  if (locks == 0)
 2015c50:	d0a06f17 	ldw	r2,-32324(gp)
 2015c54:	1000051e 	bne	r2,zero,2015c6c <__malloc_unlock+0x6c>
 2015c58:	e0bffa17 	ldw	r2,-24(fp)
 2015c5c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015c60:	e0bffc17 	ldw	r2,-16(fp)
 2015c64:	1001703a 	wrctl	status,r2
  {
      OS_EXIT_CRITICAL();
      return;
 2015c68:	00001506 	br	2015cc0 <__malloc_unlock+0xc0>
  }

  /* release the heap once the number of locks == the number of unlocks */
  if( (--locks) == 0 ) 
 2015c6c:	d0a06f17 	ldw	r2,-32324(gp)
 2015c70:	10bfffc4 	addi	r2,r2,-1
 2015c74:	d0a06f15 	stw	r2,-32324(gp)
 2015c78:	d0a06f17 	ldw	r2,-32324(gp)
 2015c7c:	10000a1e 	bne	r2,zero,2015ca8 <__malloc_unlock+0xa8>
  {
    lockid = -1;
 2015c80:	00bfffc4 	movi	r2,-1
 2015c84:	d0a01615 	stw	r2,-32680(gp)
 2015c88:	e0bffa17 	ldw	r2,-24(fp)
 2015c8c:	e0bffd15 	stw	r2,-12(fp)
 2015c90:	e0bffd17 	ldw	r2,-12(fp)
 2015c94:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSSemPost( alt_heapsem );
 2015c98:	d0a07017 	ldw	r2,-32320(gp)
 2015c9c:	1009883a 	mov	r4,r2
 2015ca0:	201c3f80 	call	201c3f8 <OSSemPost>
 2015ca4:	00000606 	br	2015cc0 <__malloc_unlock+0xc0>
 2015ca8:	e0bffa17 	ldw	r2,-24(fp)
 2015cac:	e0bffe15 	stw	r2,-8(fp)
 2015cb0:	e0bffe17 	ldw	r2,-8(fp)
 2015cb4:	1001703a 	wrctl	status,r2
 2015cb8:	00000106 	br	2015cc0 <__malloc_unlock+0xc0>
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
#endif 

  if (OSRunning != OS_TRUE)
      return;
 2015cbc:	0001883a 	nop
  {
      OS_EXIT_CRITICAL();
  }
  
#endif /* OS_THREAD_SAFE_NEWLIB */
}
 2015cc0:	e037883a 	mov	sp,fp
 2015cc4:	dfc00117 	ldw	ra,4(sp)
 2015cc8:	df000017 	ldw	fp,0(sp)
 2015ccc:	dec00204 	addi	sp,sp,8
 2015cd0:	f800283a 	ret

02015cd4 <OSEventNameGet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
INT8U  OSEventNameGet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 2015cd4:	defff704 	addi	sp,sp,-36
 2015cd8:	dfc00815 	stw	ra,32(sp)
 2015cdc:	df000715 	stw	fp,28(sp)
 2015ce0:	df000704 	addi	fp,sp,28
 2015ce4:	e13ffd15 	stw	r4,-12(fp)
 2015ce8:	e17ffe15 	stw	r5,-8(fp)
 2015cec:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2015cf0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2015cf4:	e0bfff17 	ldw	r2,-4(fp)
 2015cf8:	1000021e 	bne	r2,zero,2015d04 <OSEventNameGet+0x30>
        return (0);
 2015cfc:	0005883a 	mov	r2,zero
 2015d00:	00003706 	br	2015de0 <OSEventNameGet+0x10c>
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 2015d04:	e0bffd17 	ldw	r2,-12(fp)
 2015d08:	1000051e 	bne	r2,zero,2015d20 <OSEventNameGet+0x4c>
        *perr = OS_ERR_PEVENT_NULL;
 2015d0c:	e0bfff17 	ldw	r2,-4(fp)
 2015d10:	00c00104 	movi	r3,4
 2015d14:	10c00005 	stb	r3,0(r2)
        return (0);
 2015d18:	0005883a 	mov	r2,zero
 2015d1c:	00003006 	br	2015de0 <OSEventNameGet+0x10c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 2015d20:	e0bffe17 	ldw	r2,-8(fp)
 2015d24:	1000051e 	bne	r2,zero,2015d3c <OSEventNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 2015d28:	e0bfff17 	ldw	r2,-4(fp)
 2015d2c:	00c00304 	movi	r3,12
 2015d30:	10c00005 	stb	r3,0(r2)
        return (0);
 2015d34:	0005883a 	mov	r2,zero
 2015d38:	00002906 	br	2015de0 <OSEventNameGet+0x10c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2015d3c:	d0a07f03 	ldbu	r2,-32260(gp)
 2015d40:	10803fcc 	andi	r2,r2,255
 2015d44:	10000526 	beq	r2,zero,2015d5c <OSEventNameGet+0x88>
        *perr  = OS_ERR_NAME_GET_ISR;
 2015d48:	e0bfff17 	ldw	r2,-4(fp)
 2015d4c:	00c00444 	movi	r3,17
 2015d50:	10c00005 	stb	r3,0(r2)
        return (0);
 2015d54:	0005883a 	mov	r2,zero
 2015d58:	00002106 	br	2015de0 <OSEventNameGet+0x10c>
    }
    switch (pevent->OSEventType) {
 2015d5c:	e0bffd17 	ldw	r2,-12(fp)
 2015d60:	10800003 	ldbu	r2,0(r2)
 2015d64:	10803fcc 	andi	r2,r2,255
 2015d68:	10bfffc4 	addi	r2,r2,-1
 2015d6c:	10800128 	cmpgeui	r2,r2,4
 2015d70:	1000171e 	bne	r2,zero,2015dd0 <OSEventNameGet+0xfc>
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 2015d74:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015d78:	0005303a 	rdctl	r2,status
 2015d7c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2015d80:	e0fffb17 	ldw	r3,-20(fp)
 2015d84:	00bfff84 	movi	r2,-2
 2015d88:	1884703a 	and	r2,r3,r2
 2015d8c:	1001703a 	wrctl	status,r2
  
  return context;
 2015d90:	e0bffb17 	ldw	r2,-20(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return (0);
    }
    OS_ENTER_CRITICAL();
 2015d94:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
 2015d98:	e0bffd17 	ldw	r2,-12(fp)
 2015d9c:	10800384 	addi	r2,r2,14
 2015da0:	e13ffe17 	ldw	r4,-8(fp)
 2015da4:	100b883a 	mov	r5,r2
 2015da8:	20177640 	call	2017764 <OS_StrCopy>
 2015dac:	e0bffa05 	stb	r2,-24(fp)
 2015db0:	e0bff917 	ldw	r2,-28(fp)
 2015db4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015db8:	e0bffc17 	ldw	r2,-16(fp)
 2015dbc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2015dc0:	e0bfff17 	ldw	r2,-4(fp)
 2015dc4:	10000005 	stb	zero,0(r2)
    return (len);
 2015dc8:	e0bffa03 	ldbu	r2,-24(fp)
 2015dcc:	00000406 	br	2015de0 <OSEventNameGet+0x10c>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 2015dd0:	e0bfff17 	ldw	r2,-4(fp)
 2015dd4:	00c00044 	movi	r3,1
 2015dd8:	10c00005 	stb	r3,0(r2)
             return (0);
 2015ddc:	0005883a 	mov	r2,zero
    OS_ENTER_CRITICAL();
    len   = OS_StrCopy(pname, pevent->OSEventName);   /* Copy name from OS_EVENT                       */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return (len);
}
 2015de0:	e037883a 	mov	sp,fp
 2015de4:	dfc00117 	ldw	ra,4(sp)
 2015de8:	df000017 	ldw	fp,0(sp)
 2015dec:	dec00204 	addi	sp,sp,8
 2015df0:	f800283a 	ret

02015df4 <OSEventNameSet>:
*********************************************************************************************************
*/

#if (OS_EVENT_EN) && (OS_EVENT_NAME_SIZE > 1)
void  OSEventNameSet (OS_EVENT *pevent, INT8U *pname, INT8U *perr)
{
 2015df4:	defff604 	addi	sp,sp,-40
 2015df8:	dfc00915 	stw	ra,36(sp)
 2015dfc:	df000815 	stw	fp,32(sp)
 2015e00:	df000804 	addi	fp,sp,32
 2015e04:	e13ffd15 	stw	r4,-12(fp)
 2015e08:	e17ffe15 	stw	r5,-8(fp)
 2015e0c:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2015e10:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2015e14:	e0bfff17 	ldw	r2,-4(fp)
 2015e18:	10004126 	beq	r2,zero,2015f20 <OSEventNameSet+0x12c>
        return;
    }
    if (pevent == (OS_EVENT *)0) {               /* Is 'pevent' a NULL pointer?                        */
 2015e1c:	e0bffd17 	ldw	r2,-12(fp)
 2015e20:	1000041e 	bne	r2,zero,2015e34 <OSEventNameSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 2015e24:	e0bfff17 	ldw	r2,-4(fp)
 2015e28:	00c00104 	movi	r3,4
 2015e2c:	10c00005 	stb	r3,0(r2)
        return;
 2015e30:	00003c06 	br	2015f24 <OSEventNameSet+0x130>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 2015e34:	e0bffe17 	ldw	r2,-8(fp)
 2015e38:	1000041e 	bne	r2,zero,2015e4c <OSEventNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 2015e3c:	e0bfff17 	ldw	r2,-4(fp)
 2015e40:	00c00304 	movi	r3,12
 2015e44:	10c00005 	stb	r3,0(r2)
        return;
 2015e48:	00003606 	br	2015f24 <OSEventNameSet+0x130>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2015e4c:	d0a07f03 	ldbu	r2,-32260(gp)
 2015e50:	10803fcc 	andi	r2,r2,255
 2015e54:	10000426 	beq	r2,zero,2015e68 <OSEventNameSet+0x74>
        *perr = OS_ERR_NAME_SET_ISR;
 2015e58:	e0bfff17 	ldw	r2,-4(fp)
 2015e5c:	00c00484 	movi	r3,18
 2015e60:	10c00005 	stb	r3,0(r2)
        return;
 2015e64:	00002f06 	br	2015f24 <OSEventNameSet+0x130>
    }
    switch (pevent->OSEventType) {
 2015e68:	e0bffd17 	ldw	r2,-12(fp)
 2015e6c:	10800003 	ldbu	r2,0(r2)
 2015e70:	10803fcc 	andi	r2,r2,255
 2015e74:	10bfffc4 	addi	r2,r2,-1
 2015e78:	10800128 	cmpgeui	r2,r2,4
 2015e7c:	1000101e 	bne	r2,zero,2015ec0 <OSEventNameSet+0xcc>
        case OS_EVENT_TYPE_SEM:
        case OS_EVENT_TYPE_MUTEX:
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;
 2015e80:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2015e84:	0005303a 	rdctl	r2,status
 2015e88:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2015e8c:	e0fffa17 	ldw	r3,-24(fp)
 2015e90:	00bfff84 	movi	r2,-2
 2015e94:	1884703a 	and	r2,r3,r2
 2015e98:	1001703a 	wrctl	status,r2
  
  return context;
 2015e9c:	e0bffa17 	ldw	r2,-24(fp)

        default:
             *perr = OS_ERR_EVENT_TYPE;
             return;
    }
    OS_ENTER_CRITICAL();
 2015ea0:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
 2015ea4:	e13ffe17 	ldw	r4,-8(fp)
 2015ea8:	20177e00 	call	20177e0 <OS_StrLen>
 2015eac:	e0bff905 	stb	r2,-28(fp)
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
 2015eb0:	e0bff903 	ldbu	r2,-28(fp)
 2015eb4:	10800830 	cmpltui	r2,r2,32
 2015eb8:	10000d1e 	bne	r2,zero,2015ef0 <OSEventNameSet+0xfc>
 2015ebc:	00000406 	br	2015ed0 <OSEventNameSet+0xdc>
        case OS_EVENT_TYPE_MBOX:
        case OS_EVENT_TYPE_Q:
             break;

        default:
             *perr = OS_ERR_EVENT_TYPE;
 2015ec0:	e0bfff17 	ldw	r2,-4(fp)
 2015ec4:	00c00044 	movi	r3,1
 2015ec8:	10c00005 	stb	r3,0(r2)
             return;
 2015ecc:	00001506 	br	2015f24 <OSEventNameSet+0x130>
 2015ed0:	e0bff817 	ldw	r2,-32(fp)
 2015ed4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2015ed8:	e0bffb17 	ldw	r2,-20(fp)
 2015edc:	1001703a 	wrctl	status,r2
    }
    OS_ENTER_CRITICAL();
    len = OS_StrLen(pname);                           /* Can we fit the string in the storage area?    */
    if (len > (OS_EVENT_NAME_SIZE - 1)) {             /* No                                            */
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_NAME_TOO_LONG;
 2015ee0:	e0bfff17 	ldw	r2,-4(fp)
 2015ee4:	00c002c4 	movi	r3,11
 2015ee8:	10c00005 	stb	r3,0(r2)
        return;
 2015eec:	00000d06 	br	2015f24 <OSEventNameSet+0x130>
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
 2015ef0:	e0bffd17 	ldw	r2,-12(fp)
 2015ef4:	10800384 	addi	r2,r2,14
 2015ef8:	1009883a 	mov	r4,r2
 2015efc:	e17ffe17 	ldw	r5,-8(fp)
 2015f00:	20177640 	call	2017764 <OS_StrCopy>
 2015f04:	e0bff817 	ldw	r2,-32(fp)
 2015f08:	e0bffc15 	stw	r2,-16(fp)
 2015f0c:	e0bffc17 	ldw	r2,-16(fp)
 2015f10:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2015f14:	e0bfff17 	ldw	r2,-4(fp)
 2015f18:	10000005 	stb	zero,0(r2)
 2015f1c:	00000106 	br	2015f24 <OSEventNameSet+0x130>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 2015f20:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pevent->OSEventName, pname);     /* Yes, copy name to the event control block     */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 2015f24:	e037883a 	mov	sp,fp
 2015f28:	dfc00117 	ldw	ra,4(sp)
 2015f2c:	df000017 	ldw	fp,0(sp)
 2015f30:	dec00204 	addi	sp,sp,8
 2015f34:	f800283a 	ret

02015f38 <OSEventPendMulti>:
*********************************************************************************************************
*/
/*$PAGE*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
INT16U  OSEventPendMulti (OS_EVENT **pevents_pend, OS_EVENT **pevents_rdy, void **pmsgs_rdy, INT16U timeout, INT8U *perr)
{
 2015f38:	deffed04 	addi	sp,sp,-76
 2015f3c:	dfc01215 	stw	ra,72(sp)
 2015f40:	df001115 	stw	fp,68(sp)
 2015f44:	df001104 	addi	fp,sp,68
 2015f48:	e13ffc15 	stw	r4,-16(fp)
 2015f4c:	e17ffd15 	stw	r5,-12(fp)
 2015f50:	e1bffe15 	stw	r6,-8(fp)
 2015f54:	3805883a 	mov	r2,r7
 2015f58:	e0bfff0d 	sth	r2,-4(fp)
#endif
    BOOLEAN     events_rdy;
    INT16U      events_rdy_nbr;
    INT8U       events_stat;
#if (OS_CRITICAL_METHOD == 3)                           /* Allocate storage for CPU status register    */
    OS_CPU_SR   cpu_sr = 0;
 2015f5c:	e03ff315 	stw	zero,-52(fp)
#endif



#if (OS_ARG_CHK_EN > 0)
    if (perr == (INT8U *)0) {                           /* Validate 'perr'                             */
 2015f60:	e0800217 	ldw	r2,8(fp)
 2015f64:	1000021e 	bne	r2,zero,2015f70 <OSEventPendMulti+0x38>
        return (0);
 2015f68:	0005883a 	mov	r2,zero
 2015f6c:	00017c06 	br	2016560 <OSEventPendMulti+0x628>
    }
    if (pevents_pend == (OS_EVENT **)0) {               /* Validate 'pevents_pend'                     */
 2015f70:	e0bffc17 	ldw	r2,-16(fp)
 2015f74:	1000051e 	bne	r2,zero,2015f8c <OSEventPendMulti+0x54>
       *perr =  OS_ERR_PEVENT_NULL;
 2015f78:	e0800217 	ldw	r2,8(fp)
 2015f7c:	00c00104 	movi	r3,4
 2015f80:	10c00005 	stb	r3,0(r2)
        return (0);
 2015f84:	0005883a 	mov	r2,zero
 2015f88:	00017506 	br	2016560 <OSEventPendMulti+0x628>
    }
    if (pevents_rdy  == (OS_EVENT **)0) {               /* Validate 'pevents_rdy'                      */
 2015f8c:	e0bffd17 	ldw	r2,-12(fp)
 2015f90:	1000051e 	bne	r2,zero,2015fa8 <OSEventPendMulti+0x70>
       *perr =  OS_ERR_PEVENT_NULL;
 2015f94:	e0800217 	ldw	r2,8(fp)
 2015f98:	00c00104 	movi	r3,4
 2015f9c:	10c00005 	stb	r3,0(r2)
        return (0);
 2015fa0:	0005883a 	mov	r2,zero
 2015fa4:	00016e06 	br	2016560 <OSEventPendMulti+0x628>
    }
    if (pmsgs_rdy == (void **)0) {                      /* Validate 'pmsgs_rdy'                        */
 2015fa8:	e0bffe17 	ldw	r2,-8(fp)
 2015fac:	1000051e 	bne	r2,zero,2015fc4 <OSEventPendMulti+0x8c>
       *perr =  OS_ERR_PEVENT_NULL;
 2015fb0:	e0800217 	ldw	r2,8(fp)
 2015fb4:	00c00104 	movi	r3,4
 2015fb8:	10c00005 	stb	r3,0(r2)
        return (0);
 2015fbc:	0005883a 	mov	r2,zero
 2015fc0:	00016706 	br	2016560 <OSEventPendMulti+0x628>
    }
#endif

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */
 2015fc4:	e0bffd17 	ldw	r2,-12(fp)
 2015fc8:	10000015 	stw	zero,0(r2)

    pevents     =  pevents_pend;
 2015fcc:	e0bffc17 	ldw	r2,-16(fp)
 2015fd0:	e0bfef15 	stw	r2,-68(fp)
    pevent      = *pevents;
 2015fd4:	e0bfef17 	ldw	r2,-68(fp)
 2015fd8:	10800017 	ldw	r2,0(r2)
 2015fdc:	e0bff015 	stw	r2,-64(fp)
    while  (pevent != (OS_EVENT *)0) {
 2015fe0:	00001906 	br	2016048 <OSEventPendMulti+0x110>
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
 2015fe4:	e0bff017 	ldw	r2,-64(fp)
 2015fe8:	10800003 	ldbu	r2,0(r2)
 2015fec:	10803fcc 	andi	r2,r2,255
 2015ff0:	10c000a0 	cmpeqi	r3,r2,2
 2015ff4:	1800091e 	bne	r3,zero,201601c <OSEventPendMulti+0xe4>
 2015ff8:	10c000e0 	cmpeqi	r3,r2,3
 2015ffc:	1800091e 	bne	r3,zero,2016024 <OSEventPendMulti+0xec>
 2016000:	10800060 	cmpeqi	r2,r2,1
 2016004:	1000091e 	bne	r2,zero,201602c <OSEventPendMulti+0xf4>
#endif

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
 2016008:	e0800217 	ldw	r2,8(fp)
 201600c:	00c00044 	movi	r3,1
 2016010:	10c00005 	stb	r3,0(r2)
                 return (0);
 2016014:	0005883a 	mov	r2,zero
 2016018:	00015106 	br	2016560 <OSEventPendMulti+0x628>
            case OS_EVENT_TYPE_MBOX:
                 break;
#endif
#if ((OS_Q_EN   > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 break;
 201601c:	0001883a 	nop
 2016020:	00000306 	br	2016030 <OSEventPendMulti+0xf8>
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
        switch (pevent->OSEventType) {                  /* Validate event block types                  */
#if (OS_SEM_EN  > 0)
            case OS_EVENT_TYPE_SEM:
                 break;
 2016024:	0001883a 	nop
 2016028:	00000106 	br	2016030 <OSEventPendMulti+0xf8>
#endif
#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 break;
 201602c:	0001883a 	nop
            case OS_EVENT_TYPE_FLAG:
            default:           
                *perr = OS_ERR_EVENT_TYPE;
                 return (0);
        }
        pevents++;
 2016030:	e0bfef17 	ldw	r2,-68(fp)
 2016034:	10800104 	addi	r2,r2,4
 2016038:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 201603c:	e0bfef17 	ldw	r2,-68(fp)
 2016040:	10800017 	ldw	r2,0(r2)
 2016044:	e0bff015 	stw	r2,-64(fp)

   *pevents_rdy = (OS_EVENT *)0;                        /* Init array to NULL in case of errors        */

    pevents     =  pevents_pend;
    pevent      = *pevents;
    while  (pevent != (OS_EVENT *)0) {
 2016048:	e0bff017 	ldw	r2,-64(fp)
 201604c:	103fe51e 	bne	r2,zero,2015fe4 <OSEventPendMulti+0xac>
        }
        pevents++;
        pevent = *pevents;
    }

    if (OSIntNesting  > 0) {                            /* See if called from ISR ...                  */
 2016050:	d0a07f03 	ldbu	r2,-32260(gp)
 2016054:	10803fcc 	andi	r2,r2,255
 2016058:	10000526 	beq	r2,zero,2016070 <OSEventPendMulti+0x138>
       *perr =  OS_ERR_PEND_ISR;                        /* ... can't PEND from an ISR                  */
 201605c:	e0800217 	ldw	r2,8(fp)
 2016060:	00c00084 	movi	r3,2
 2016064:	10c00005 	stb	r3,0(r2)
        return (0);
 2016068:	0005883a 	mov	r2,zero
 201606c:	00013c06 	br	2016560 <OSEventPendMulti+0x628>
    }
    if (OSLockNesting > 0) {                            /* See if called with scheduler locked ...     */
 2016070:	d0a07103 	ldbu	r2,-32316(gp)
 2016074:	10803fcc 	andi	r2,r2,255
 2016078:	10000526 	beq	r2,zero,2016090 <OSEventPendMulti+0x158>
       *perr =  OS_ERR_PEND_LOCKED;                     /* ... can't PEND when locked                  */
 201607c:	e0800217 	ldw	r2,8(fp)
 2016080:	00c00344 	movi	r3,13
 2016084:	10c00005 	stb	r3,0(r2)
        return (0);
 2016088:	0005883a 	mov	r2,zero
 201608c:	00013406 	br	2016560 <OSEventPendMulti+0x628>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016090:	0005303a 	rdctl	r2,status
 2016094:	e0bff515 	stw	r2,-44(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016098:	e0fff517 	ldw	r3,-44(fp)
 201609c:	00bfff84 	movi	r2,-2
 20160a0:	1884703a 	and	r2,r3,r2
 20160a4:	1001703a 	wrctl	status,r2
  
  return context;
 20160a8:	e0bff517 	ldw	r2,-44(fp)
    }

/*$PAGE*/
    OS_ENTER_CRITICAL();
 20160ac:	e0bff315 	stw	r2,-52(fp)
    events_rdy     =  OS_FALSE;
 20160b0:	e03ff105 	stb	zero,-60(fp)
    events_rdy_nbr =  0;
 20160b4:	e03ff18d 	sth	zero,-58(fp)
    events_stat    =  OS_STAT_RDY;
 20160b8:	e03ff205 	stb	zero,-56(fp)
    pevents        =  pevents_pend;
 20160bc:	e0bffc17 	ldw	r2,-16(fp)
 20160c0:	e0bfef15 	stw	r2,-68(fp)
    pevent         = *pevents;
 20160c4:	e0bfef17 	ldw	r2,-68(fp)
 20160c8:	10800017 	ldw	r2,0(r2)
 20160cc:	e0bff015 	stw	r2,-64(fp)
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 20160d0:	00008706 	br	20162f0 <OSEventPendMulti+0x3b8>
        switch (pevent->OSEventType) {
 20160d4:	e0bff017 	ldw	r2,-64(fp)
 20160d8:	10800003 	ldbu	r2,0(r2)
 20160dc:	10803fcc 	andi	r2,r2,255
 20160e0:	10c000a0 	cmpeqi	r3,r2,2
 20160e4:	1800401e 	bne	r3,zero,20161e8 <OSEventPendMulti+0x2b0>
 20160e8:	10c000e0 	cmpeqi	r3,r2,3
 20160ec:	1800031e 	bne	r3,zero,20160fc <OSEventPendMulti+0x1c4>
 20160f0:	10800060 	cmpeqi	r2,r2,1
 20160f4:	1000201e 	bne	r2,zero,2016178 <OSEventPendMulti+0x240>
 20160f8:	00006c06 	br	20162ac <OSEventPendMulti+0x374>
#if (OS_SEM_EN > 0)
            case OS_EVENT_TYPE_SEM:
                 if (pevent->OSEventCnt > 0) {          /* If semaphore count > 0, resource available; */
 20160fc:	e0bff017 	ldw	r2,-64(fp)
 2016100:	1080020b 	ldhu	r2,8(r2)
 2016104:	10bfffcc 	andi	r2,r2,65535
 2016108:	10001726 	beq	r2,zero,2016168 <OSEventPendMulti+0x230>
                     pevent->OSEventCnt--;              /* ... decrement semaphore,                ... */
 201610c:	e0bff017 	ldw	r2,-64(fp)
 2016110:	1080020b 	ldhu	r2,8(r2)
 2016114:	10bfffc4 	addi	r2,r2,-1
 2016118:	1007883a 	mov	r3,r2
 201611c:	e0bff017 	ldw	r2,-64(fp)
 2016120:	10c0020d 	sth	r3,8(r2)
                    *pevents_rdy++ =  pevent;           /* ... and return available semaphore event    */
 2016124:	e0bffd17 	ldw	r2,-12(fp)
 2016128:	e0fff017 	ldw	r3,-64(fp)
 201612c:	10c00015 	stw	r3,0(r2)
 2016130:	e0bffd17 	ldw	r2,-12(fp)
 2016134:	10800104 	addi	r2,r2,4
 2016138:	e0bffd15 	stw	r2,-12(fp)
                      events_rdy   =  OS_TRUE;
 201613c:	00800044 	movi	r2,1
 2016140:	e0bff105 	stb	r2,-60(fp)
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
 2016144:	e0bffe17 	ldw	r2,-8(fp)
 2016148:	10000015 	stw	zero,0(r2)
 201614c:	e0bffe17 	ldw	r2,-8(fp)
 2016150:	10800104 	addi	r2,r2,4
 2016154:	e0bffe15 	stw	r2,-8(fp)
                      events_rdy_nbr++;
 2016158:	e0bff18b 	ldhu	r2,-58(fp)
 201615c:	10800044 	addi	r2,r2,1
 2016160:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
                 }
                 break;
 2016164:	00005c06 	br	20162d8 <OSEventPendMulti+0x3a0>
                      events_rdy   =  OS_TRUE;
                    *pmsgs_rdy++   = (void *)0;         /* NO message returned  for semaphores         */
                      events_rdy_nbr++;

                 } else {
                      events_stat |=  OS_STAT_SEM;      /* Configure multi-pend for semaphore events   */
 2016168:	e0bff203 	ldbu	r2,-56(fp)
 201616c:	10800054 	ori	r2,r2,1
 2016170:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 2016174:	00005806 	br	20162d8 <OSEventPendMulti+0x3a0>
#endif

#if (OS_MBOX_EN > 0)
            case OS_EVENT_TYPE_MBOX:
                 if (pevent->OSEventPtr != (void *)0) { /* If mailbox NOT empty;                   ... */
 2016178:	e0bff017 	ldw	r2,-64(fp)
 201617c:	10800117 	ldw	r2,4(r2)
 2016180:	10001526 	beq	r2,zero,20161d8 <OSEventPendMulti+0x2a0>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++         = (void *)pevent->OSEventPtr;
 2016184:	e0bff017 	ldw	r2,-64(fp)
 2016188:	10c00117 	ldw	r3,4(r2)
 201618c:	e0bffe17 	ldw	r2,-8(fp)
 2016190:	10c00015 	stw	r3,0(r2)
 2016194:	e0bffe17 	ldw	r2,-8(fp)
 2016198:	10800104 	addi	r2,r2,4
 201619c:	e0bffe15 	stw	r2,-8(fp)
                     pevent->OSEventPtr  = (void *)0;
 20161a0:	e0bff017 	ldw	r2,-64(fp)
 20161a4:	10000115 	stw	zero,4(r2)
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
 20161a8:	e0bffd17 	ldw	r2,-12(fp)
 20161ac:	e0fff017 	ldw	r3,-64(fp)
 20161b0:	10c00015 	stw	r3,0(r2)
 20161b4:	e0bffd17 	ldw	r2,-12(fp)
 20161b8:	10800104 	addi	r2,r2,4
 20161bc:	e0bffd15 	stw	r2,-12(fp)
                      events_rdy         =  OS_TRUE;
 20161c0:	00800044 	movi	r2,1
 20161c4:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 20161c8:	e0bff18b 	ldhu	r2,-58(fp)
 20161cc:	10800044 	addi	r2,r2,1
 20161d0:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
                 }
                 break;
 20161d4:	00004006 	br	20162d8 <OSEventPendMulti+0x3a0>
                    *pevents_rdy++       =  pevent;     /* ... and return available mailbox event      */
                      events_rdy         =  OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_MBOX;      /* Configure multi-pend for mailbox events     */
 20161d8:	e0bff203 	ldbu	r2,-56(fp)
 20161dc:	10800094 	ori	r2,r2,2
 20161e0:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 20161e4:	00003c06 	br	20162d8 <OSEventPendMulti+0x3a0>
#endif

#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
            case OS_EVENT_TYPE_Q:
                 pq = (OS_Q *)pevent->OSEventPtr;
 20161e8:	e0bff017 	ldw	r2,-64(fp)
 20161ec:	10800117 	ldw	r2,4(r2)
 20161f0:	e0bff415 	stw	r2,-48(fp)
                 if (pq->OSQEntries > 0) {              /* If queue NOT empty;                     ... */
 20161f4:	e0bff417 	ldw	r2,-48(fp)
 20161f8:	1080058b 	ldhu	r2,22(r2)
 20161fc:	10bfffcc 	andi	r2,r2,65535
 2016200:	10002626 	beq	r2,zero,201629c <OSEventPendMulti+0x364>
                                                        /* ... return available message,           ... */
                    *pmsgs_rdy++ = (void *)*pq->OSQOut++;
 2016204:	e0bff417 	ldw	r2,-48(fp)
 2016208:	10800417 	ldw	r2,16(r2)
 201620c:	11000017 	ldw	r4,0(r2)
 2016210:	e0fffe17 	ldw	r3,-8(fp)
 2016214:	19000015 	stw	r4,0(r3)
 2016218:	e0fffe17 	ldw	r3,-8(fp)
 201621c:	18c00104 	addi	r3,r3,4
 2016220:	e0fffe15 	stw	r3,-8(fp)
 2016224:	10c00104 	addi	r3,r2,4
 2016228:	e0bff417 	ldw	r2,-48(fp)
 201622c:	10c00415 	stw	r3,16(r2)
                     if (pq->OSQOut == pq->OSQEnd) {    /* If OUT ptr at queue end, ...                */
 2016230:	e0bff417 	ldw	r2,-48(fp)
 2016234:	10c00417 	ldw	r3,16(r2)
 2016238:	e0bff417 	ldw	r2,-48(fp)
 201623c:	10800217 	ldw	r2,8(r2)
 2016240:	1880041e 	bne	r3,r2,2016254 <OSEventPendMulti+0x31c>
                         pq->OSQOut  = pq->OSQStart;    /* ... wrap   to queue start                   */
 2016244:	e0bff417 	ldw	r2,-48(fp)
 2016248:	10c00117 	ldw	r3,4(r2)
 201624c:	e0bff417 	ldw	r2,-48(fp)
 2016250:	10c00415 	stw	r3,16(r2)
                     }
                     pq->OSQEntries--;                  /* Update number of queue entries              */
 2016254:	e0bff417 	ldw	r2,-48(fp)
 2016258:	1080058b 	ldhu	r2,22(r2)
 201625c:	10bfffc4 	addi	r2,r2,-1
 2016260:	1007883a 	mov	r3,r2
 2016264:	e0bff417 	ldw	r2,-48(fp)
 2016268:	10c0058d 	sth	r3,22(r2)
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
 201626c:	e0bffd17 	ldw	r2,-12(fp)
 2016270:	e0fff017 	ldw	r3,-64(fp)
 2016274:	10c00015 	stw	r3,0(r2)
 2016278:	e0bffd17 	ldw	r2,-12(fp)
 201627c:	10800104 	addi	r2,r2,4
 2016280:	e0bffd15 	stw	r2,-12(fp)
                      events_rdy   = OS_TRUE;
 2016284:	00800044 	movi	r2,1
 2016288:	e0bff105 	stb	r2,-60(fp)
                      events_rdy_nbr++;
 201628c:	e0bff18b 	ldhu	r2,-58(fp)
 2016290:	10800044 	addi	r2,r2,1
 2016294:	e0bff18d 	sth	r2,-58(fp)

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
                 }
                 break;
 2016298:	00000f06 	br	20162d8 <OSEventPendMulti+0x3a0>
                    *pevents_rdy++ = pevent;            /* ... and return available queue event        */
                      events_rdy   = OS_TRUE;
                      events_rdy_nbr++;

                 } else {
                      events_stat |= OS_STAT_Q;         /* Configure multi-pend for queue events       */
 201629c:	e0bff203 	ldbu	r2,-56(fp)
 20162a0:	10800114 	ori	r2,r2,4
 20162a4:	e0bff205 	stb	r2,-56(fp)
                 }
                 break;
 20162a8:	00000b06 	br	20162d8 <OSEventPendMulti+0x3a0>
 20162ac:	e0bff317 	ldw	r2,-52(fp)
 20162b0:	e0bff615 	stw	r2,-40(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20162b4:	e0bff617 	ldw	r2,-40(fp)
 20162b8:	1001703a 	wrctl	status,r2

            case OS_EVENT_TYPE_MUTEX:                                            
            case OS_EVENT_TYPE_FLAG:
            default:           
                 OS_EXIT_CRITICAL();
                *pevents_rdy = (OS_EVENT *)0;           /* NULL terminate return event array           */
 20162bc:	e0bffd17 	ldw	r2,-12(fp)
 20162c0:	10000015 	stw	zero,0(r2)
                *perr        =  OS_ERR_EVENT_TYPE;
 20162c4:	e0800217 	ldw	r2,8(fp)
 20162c8:	00c00044 	movi	r3,1
 20162cc:	10c00005 	stb	r3,0(r2)
                 return (events_rdy_nbr);
 20162d0:	e0bff18b 	ldhu	r2,-58(fp)
 20162d4:	0000a206 	br	2016560 <OSEventPendMulti+0x628>
        }
        pevents++;
 20162d8:	e0bfef17 	ldw	r2,-68(fp)
 20162dc:	10800104 	addi	r2,r2,4
 20162e0:	e0bfef15 	stw	r2,-68(fp)
        pevent = *pevents;
 20162e4:	e0bfef17 	ldw	r2,-68(fp)
 20162e8:	10800017 	ldw	r2,0(r2)
 20162ec:	e0bff015 	stw	r2,-64(fp)
    events_rdy     =  OS_FALSE;
    events_rdy_nbr =  0;
    events_stat    =  OS_STAT_RDY;
    pevents        =  pevents_pend;
    pevent         = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* See if any events already available         */
 20162f0:	e0bff017 	ldw	r2,-64(fp)
 20162f4:	103f771e 	bne	r2,zero,20160d4 <OSEventPendMulti+0x19c>
        }
        pevents++;
        pevent = *pevents;
    }

    if ( events_rdy == OS_TRUE) {                       /* Return any events already available         */
 20162f8:	e0bff103 	ldbu	r2,-60(fp)
 20162fc:	10800058 	cmpnei	r2,r2,1
 2016300:	10000a1e 	bne	r2,zero,201632c <OSEventPendMulti+0x3f4>
       *pevents_rdy = (OS_EVENT *)0;                    /* NULL terminate return event array           */
 2016304:	e0bffd17 	ldw	r2,-12(fp)
 2016308:	10000015 	stw	zero,0(r2)
 201630c:	e0bff317 	ldw	r2,-52(fp)
 2016310:	e0bff715 	stw	r2,-36(fp)
 2016314:	e0bff717 	ldw	r2,-36(fp)
 2016318:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
       *perr        =  OS_ERR_NONE;
 201631c:	e0800217 	ldw	r2,8(fp)
 2016320:	10000005 	stb	zero,0(r2)
        return (events_rdy_nbr);
 2016324:	e0bff18b 	ldhu	r2,-58(fp)
 2016328:	00008d06 	br	2016560 <OSEventPendMulti+0x628>
    }
/*$PAGE*/
                                                        /* Otherwise, must wait until any event occurs */
    OSTCBCur->OSTCBStat     |= events_stat  |           /* Resource not available, ...                 */
 201632c:	d0a08017 	ldw	r2,-32256(gp)
 2016330:	d0e08017 	ldw	r3,-32256(gp)
 2016334:	19000c03 	ldbu	r4,48(r3)
 2016338:	e0fff203 	ldbu	r3,-56(fp)
 201633c:	20c6b03a 	or	r3,r4,r3
 2016340:	1809883a 	mov	r4,r3
 2016344:	00ffe004 	movi	r3,-128
 2016348:	20c6b03a 	or	r3,r4,r3
 201634c:	10c00c05 	stb	r3,48(r2)
                               OS_STAT_MULTI;           /* ... pend on multiple events                 */
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2016350:	d0a08017 	ldw	r2,-32256(gp)
 2016354:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;                 /* Store pend timeout in TCB                   */
 2016358:	d0a08017 	ldw	r2,-32256(gp)
 201635c:	e0ffff0b 	ldhu	r3,-4(fp)
 2016360:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWaitMulti(pevents_pend);                /* Suspend task until events or timeout occurs */
 2016364:	e13ffc17 	ldw	r4,-16(fp)
 2016368:	2016eac0 	call	2016eac <OS_EventTaskWaitMulti>
 201636c:	e0bff317 	ldw	r2,-52(fp)
 2016370:	e0bff815 	stw	r2,-32(fp)
 2016374:	e0bff817 	ldw	r2,-32(fp)
 2016378:	1001703a 	wrctl	status,r2

    OS_EXIT_CRITICAL();
    OS_Sched();                                         /* Find next highest priority task ready       */
 201637c:	20176280 	call	2017628 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016380:	0005303a 	rdctl	r2,status
 2016384:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016388:	e0fff917 	ldw	r3,-28(fp)
 201638c:	00bfff84 	movi	r2,-2
 2016390:	1884703a 	and	r2,r3,r2
 2016394:	1001703a 	wrctl	status,r2
  
  return context;
 2016398:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 201639c:	e0bff315 	stw	r2,-52(fp)

    switch (OSTCBCur->OSTCBStatPend) {                  /* Handle event posted, aborted, or timed-out  */
 20163a0:	d0a08017 	ldw	r2,-32256(gp)
 20163a4:	10800c43 	ldbu	r2,49(r2)
 20163a8:	10803fcc 	andi	r2,r2,255
 20163ac:	10000226 	beq	r2,zero,20163b8 <OSEventPendMulti+0x480>
 20163b0:	108000a0 	cmpeqi	r2,r2,2
 20163b4:	10001926 	beq	r2,zero,201641c <OSEventPendMulti+0x4e4>
        case OS_STAT_PEND_OK:
        case OS_STAT_PEND_ABORT:
             pevent = OSTCBCur->OSTCBEventPtr;
 20163b8:	d0a08017 	ldw	r2,-32256(gp)
 20163bc:	10800717 	ldw	r2,28(r2)
 20163c0:	e0bff015 	stw	r2,-64(fp)
             if (pevent != (OS_EVENT *)0) {             /* If task event ptr != NULL, ...              */
 20163c4:	e0bff017 	ldw	r2,-64(fp)
 20163c8:	10000c26 	beq	r2,zero,20163fc <OSEventPendMulti+0x4c4>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
 20163cc:	e0bffd17 	ldw	r2,-12(fp)
 20163d0:	e0fff017 	ldw	r3,-64(fp)
 20163d4:	10c00015 	stw	r3,0(r2)
 20163d8:	e0bffd17 	ldw	r2,-12(fp)
 20163dc:	10800104 	addi	r2,r2,4
 20163e0:	e0bffd15 	stw	r2,-12(fp)
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
 20163e4:	e0bffd17 	ldw	r2,-12(fp)
 20163e8:	10000015 	stw	zero,0(r2)
                  events_rdy_nbr++;
 20163ec:	e0bff18b 	ldhu	r2,-58(fp)
 20163f0:	10800044 	addi	r2,r2,1
 20163f4:	e0bff18d 	sth	r2,-58(fp)

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
             }
			 break;
 20163f8:	00000d06 	br	2016430 <OSEventPendMulti+0x4f8>
                *pevents_rdy++ =  pevent;               /* ... return available event ...              */
                *pevents_rdy   = (OS_EVENT *)0;         /* ... & NULL terminate return event array     */
                  events_rdy_nbr++;

             } else {                                   /* Else NO event available, handle as timeout  */
                 OSTCBCur->OSTCBStatPend = OS_STAT_PEND_TO;
 20163fc:	d0a08017 	ldw	r2,-32256(gp)
 2016400:	00c00044 	movi	r3,1
 2016404:	10c00c45 	stb	r3,49(r2)
                 OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 2016408:	d0a08017 	ldw	r2,-32256(gp)
 201640c:	1009883a 	mov	r4,r2
 2016410:	e17ffc17 	ldw	r5,-16(fp)
 2016414:	20170a40 	call	20170a4 <OS_EventTaskRemoveMulti>
             }
			 break;
 2016418:	00000506 	br	2016430 <OSEventPendMulti+0x4f8>

        case OS_STAT_PEND_TO:
        default:                                        /* ... remove task from events' wait lists     */
             OS_EventTaskRemoveMulti(OSTCBCur, pevents_pend);
 201641c:	d0a08017 	ldw	r2,-32256(gp)
 2016420:	1009883a 	mov	r4,r2
 2016424:	e17ffc17 	ldw	r5,-16(fp)
 2016428:	20170a40 	call	20170a4 <OS_EventTaskRemoveMulti>
             break;
 201642c:	0001883a 	nop
    }

    switch (OSTCBCur->OSTCBStatPend) {
 2016430:	d0a08017 	ldw	r2,-32256(gp)
 2016434:	10800c43 	ldbu	r2,49(r2)
 2016438:	10803fcc 	andi	r2,r2,255
 201643c:	10000326 	beq	r2,zero,201644c <OSEventPendMulti+0x514>
 2016440:	108000a0 	cmpeqi	r2,r2,2
 2016444:	1000251e 	bne	r2,zero,20164dc <OSEventPendMulti+0x5a4>
 2016448:	00002d06 	br	2016500 <OSEventPendMulti+0x5c8>
        case OS_STAT_PEND_OK:
             switch (pevent->OSEventType) {             /* Return event's message                      */
 201644c:	e0bff017 	ldw	r2,-64(fp)
 2016450:	10800003 	ldbu	r2,0(r2)
 2016454:	10803fcc 	andi	r2,r2,255
 2016458:	0080120e 	bge	zero,r2,20164a4 <OSEventPendMulti+0x56c>
 201645c:	10c000d0 	cmplti	r3,r2,3
 2016460:	1800081e 	bne	r3,zero,2016484 <OSEventPendMulti+0x54c>
 2016464:	108000e0 	cmpeqi	r2,r2,3
 2016468:	10000e26 	beq	r2,zero,20164a4 <OSEventPendMulti+0x56c>
#if (OS_SEM_EN > 0)
                 case OS_EVENT_TYPE_SEM:
                     *pmsgs_rdy++ = (void *)0;          /* NO message returned for semaphores          */
 201646c:	e0bffe17 	ldw	r2,-8(fp)
 2016470:	10000015 	stw	zero,0(r2)
 2016474:	e0bffe17 	ldw	r2,-8(fp)
 2016478:	10800104 	addi	r2,r2,4
 201647c:	e0bffe15 	stw	r2,-8(fp)
                      break;
 2016480:	00001306 	br	20164d0 <OSEventPendMulti+0x598>

#if ((OS_MBOX_EN > 0) ||                 \
    ((OS_Q_EN    > 0) && (OS_MAX_QS > 0)))
                 case OS_EVENT_TYPE_MBOX:
                 case OS_EVENT_TYPE_Q:
                     *pmsgs_rdy++ = (void *)OSTCBCur->OSTCBMsg;     /* Return received message         */
 2016484:	d0a08017 	ldw	r2,-32256(gp)
 2016488:	10c00917 	ldw	r3,36(r2)
 201648c:	e0bffe17 	ldw	r2,-8(fp)
 2016490:	10c00015 	stw	r3,0(r2)
 2016494:	e0bffe17 	ldw	r2,-8(fp)
 2016498:	10800104 	addi	r2,r2,4
 201649c:	e0bffe15 	stw	r2,-8(fp)
                      break;
 20164a0:	00000b06 	br	20164d0 <OSEventPendMulti+0x598>
 20164a4:	e0bff317 	ldw	r2,-52(fp)
 20164a8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20164ac:	e0bffa17 	ldw	r2,-24(fp)
 20164b0:	1001703a 	wrctl	status,r2

                 case OS_EVENT_TYPE_MUTEX:                                       
                 case OS_EVENT_TYPE_FLAG:
                 default:           
                      OS_EXIT_CRITICAL();
                     *pevents_rdy = (OS_EVENT *)0;      /* NULL terminate return event array           */
 20164b4:	e0bffd17 	ldw	r2,-12(fp)
 20164b8:	10000015 	stw	zero,0(r2)
                     *perr        =  OS_ERR_EVENT_TYPE;
 20164bc:	e0800217 	ldw	r2,8(fp)
 20164c0:	00c00044 	movi	r3,1
 20164c4:	10c00005 	stb	r3,0(r2)
                      return (events_rdy_nbr);
 20164c8:	e0bff18b 	ldhu	r2,-58(fp)
 20164cc:	00002406 	br	2016560 <OSEventPendMulti+0x628>
             }
            *perr = OS_ERR_NONE;
 20164d0:	e0800217 	ldw	r2,8(fp)
 20164d4:	10000005 	stb	zero,0(r2)
             break;
 20164d8:	00001206 	br	2016524 <OSEventPendMulti+0x5ec>

        case OS_STAT_PEND_ABORT:
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for abort               */
 20164dc:	e0bffe17 	ldw	r2,-8(fp)
 20164e0:	10000015 	stw	zero,0(r2)
 20164e4:	e0bffe17 	ldw	r2,-8(fp)
 20164e8:	10800104 	addi	r2,r2,4
 20164ec:	e0bffe15 	stw	r2,-8(fp)
            *perr        =  OS_ERR_PEND_ABORT;          /* Indicate that event  aborted                */
 20164f0:	e0800217 	ldw	r2,8(fp)
 20164f4:	00c00384 	movi	r3,14
 20164f8:	10c00005 	stb	r3,0(r2)
             break;
 20164fc:	00000906 	br	2016524 <OSEventPendMulti+0x5ec>
                                                        
        case OS_STAT_PEND_TO:                                                
        default:        
            *pmsgs_rdy++ = (void *)0;                   /* NO message returned for timeout             */
 2016500:	e0bffe17 	ldw	r2,-8(fp)
 2016504:	10000015 	stw	zero,0(r2)
 2016508:	e0bffe17 	ldw	r2,-8(fp)
 201650c:	10800104 	addi	r2,r2,4
 2016510:	e0bffe15 	stw	r2,-8(fp)
            *perr        =  OS_ERR_TIMEOUT;             /* Indicate that events timed out              */
 2016514:	e0800217 	ldw	r2,8(fp)
 2016518:	00c00284 	movi	r3,10
 201651c:	10c00005 	stb	r3,0(r2)
             break;
 2016520:	0001883a 	nop
    }

    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;        /* Set   task  status to ready                 */
 2016524:	d0a08017 	ldw	r2,-32256(gp)
 2016528:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;    /* Clear pend  status                          */
 201652c:	d0a08017 	ldw	r2,-32256(gp)
 2016530:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;      /* Clear event pointers                        */
 2016534:	d0a08017 	ldw	r2,-32256(gp)
 2016538:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 201653c:	d0a08017 	ldw	r2,-32256(gp)
 2016540:	10000815 	stw	zero,32(r2)
    OSTCBCur->OSTCBMsg           = (void      *)0;      /* Clear task  message                         */
 2016544:	d0a08017 	ldw	r2,-32256(gp)
 2016548:	10000915 	stw	zero,36(r2)
 201654c:	e0bff317 	ldw	r2,-52(fp)
 2016550:	e0bffb15 	stw	r2,-20(fp)
 2016554:	e0bffb17 	ldw	r2,-20(fp)
 2016558:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();

    return (events_rdy_nbr);
 201655c:	e0bff18b 	ldhu	r2,-58(fp)
}
 2016560:	e037883a 	mov	sp,fp
 2016564:	dfc00117 	ldw	ra,4(sp)
 2016568:	df000017 	ldw	fp,0(sp)
 201656c:	dec00204 	addi	sp,sp,8
 2016570:	f800283a 	ret

02016574 <OSInit>:
* Returns    : none
*********************************************************************************************************
*/

void  OSInit (void)
{
 2016574:	defffe04 	addi	sp,sp,-8
 2016578:	dfc00115 	stw	ra,4(sp)
 201657c:	df000015 	stw	fp,0(sp)
 2016580:	d839883a 	mov	fp,sp
    OSInitHookBegin();                                           /* Call port specific initialization code   */
 2016584:	2037f680 	call	2037f68 <OSInitHookBegin>

    OS_InitMisc();                                               /* Initialize miscellaneous variables       */
 2016588:	20172e00 	call	20172e0 <OS_InitMisc>

    OS_InitRdyList();                                            /* Initialize the Ready List                */
 201658c:	20173240 	call	2017324 <OS_InitRdyList>

    OS_InitTCBList();                                            /* Initialize the free list of OS_TCBs      */
 2016590:	20174880 	call	2017488 <OS_InitTCBList>

    OS_InitEventList();                                          /* Initialize the free list of OS_EVENTs    */
 2016594:	20172040 	call	2017204 <OS_InitEventList>

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FlagInit();                                               /* Initialize the event flag structures     */
 2016598:	201941c0 	call	201941c <OS_FlagInit>
#endif

#if (OS_MEM_EN > 0) && (OS_MAX_MEM_PART > 0)
    OS_MemInit();                                                /* Initialize the memory manager            */
 201659c:	201a9040 	call	201a904 <OS_MemInit>
#endif

#if (OS_Q_EN > 0) && (OS_MAX_QS > 0)
    OS_QInit();                                                  /* Initialize the message queue structures  */
 20165a0:	201bb4c0 	call	201bb4c <OS_QInit>
#endif

    OS_InitTaskIdle();                                           /* Create the Idle Task                     */
 20165a4:	20173900 	call	2017390 <OS_InitTaskIdle>
#if OS_TASK_STAT_EN > 0
    OS_InitTaskStat();                                           /* Create the Statistic Task                */
 20165a8:	201740c0 	call	201740c <OS_InitTaskStat>

#if OS_TMR_EN > 0
    OSTmr_Init();                                                /* Initialize the Timer Manager             */
#endif

    OSInitHookEnd();                                             /* Call port specific init. code            */
 20165ac:	2037f840 	call	2037f84 <OSInitHookEnd>

#if OS_DEBUG_EN > 0
    OSDebugInit();
 20165b0:	2017cec0 	call	2017cec <OSDebugInit>
#endif
}
 20165b4:	e037883a 	mov	sp,fp
 20165b8:	dfc00117 	ldw	ra,4(sp)
 20165bc:	df000017 	ldw	fp,0(sp)
 20165c0:	dec00204 	addi	sp,sp,8
 20165c4:	f800283a 	ret

020165c8 <OSIntEnter>:
*              5) You are allowed to nest interrupts up to 255 levels deep.
*********************************************************************************************************
*/

void  OSIntEnter (void)
{
 20165c8:	defffc04 	addi	sp,sp,-16
 20165cc:	df000315 	stw	fp,12(sp)
 20165d0:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 20165d4:	e03ffd15 	stw	zero,-12(fp)
#endif

    if (OSRunning == OS_TRUE) {
 20165d8:	d0a07143 	ldbu	r2,-32315(gp)
 20165dc:	10803fcc 	andi	r2,r2,255
 20165e0:	10800058 	cmpnei	r2,r2,1
 20165e4:	1000131e 	bne	r2,zero,2016634 <OSIntEnter+0x6c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20165e8:	0005303a 	rdctl	r2,status
 20165ec:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20165f0:	e0fffe17 	ldw	r3,-8(fp)
 20165f4:	00bfff84 	movi	r2,-2
 20165f8:	1884703a 	and	r2,r3,r2
 20165fc:	1001703a 	wrctl	status,r2
  
  return context;
 2016600:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 2016604:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting < 255u) {
 2016608:	d0a07f03 	ldbu	r2,-32260(gp)
 201660c:	10803fcc 	andi	r2,r2,255
 2016610:	10803fe0 	cmpeqi	r2,r2,255
 2016614:	1000031e 	bne	r2,zero,2016624 <OSIntEnter+0x5c>
            OSIntNesting++;                      /* Increment ISR nesting level                        */
 2016618:	d0a07f03 	ldbu	r2,-32260(gp)
 201661c:	10800044 	addi	r2,r2,1
 2016620:	d0a07f05 	stb	r2,-32260(gp)
 2016624:	e0bffd17 	ldw	r2,-12(fp)
 2016628:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201662c:	e0bfff17 	ldw	r2,-4(fp)
 2016630:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
    }
}
 2016634:	e037883a 	mov	sp,fp
 2016638:	df000017 	ldw	fp,0(sp)
 201663c:	dec00104 	addi	sp,sp,4
 2016640:	f800283a 	ret

02016644 <OSIntExit>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OSIntExit (void)
{
 2016644:	defffb04 	addi	sp,sp,-20
 2016648:	dfc00415 	stw	ra,16(sp)
 201664c:	df000315 	stw	fp,12(sp)
 2016650:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2016654:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {
 2016658:	d0a07143 	ldbu	r2,-32315(gp)
 201665c:	10803fcc 	andi	r2,r2,255
 2016660:	10800058 	cmpnei	r2,r2,1
 2016664:	10002f1e 	bne	r2,zero,2016724 <OSIntExit+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016668:	0005303a 	rdctl	r2,status
 201666c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016670:	e0fffe17 	ldw	r3,-8(fp)
 2016674:	00bfff84 	movi	r2,-2
 2016678:	1884703a 	and	r2,r3,r2
 201667c:	1001703a 	wrctl	status,r2
  
  return context;
 2016680:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 2016684:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting > 0) {                            /* Prevent OSIntNesting from wrapping       */
 2016688:	d0a07f03 	ldbu	r2,-32260(gp)
 201668c:	10803fcc 	andi	r2,r2,255
 2016690:	10000326 	beq	r2,zero,20166a0 <OSIntExit+0x5c>
            OSIntNesting--;
 2016694:	d0a07f03 	ldbu	r2,-32260(gp)
 2016698:	10bfffc4 	addi	r2,r2,-1
 201669c:	d0a07f05 	stb	r2,-32260(gp)
        }
        if (OSIntNesting == 0) {                           /* Reschedule only if all ISRs complete ... */
 20166a0:	d0a07f03 	ldbu	r2,-32260(gp)
 20166a4:	10803fcc 	andi	r2,r2,255
 20166a8:	10001a1e 	bne	r2,zero,2016714 <OSIntExit+0xd0>
            if (OSLockNesting == 0) {                      /* ... and not locked.                      */
 20166ac:	d0a07103 	ldbu	r2,-32316(gp)
 20166b0:	10803fcc 	andi	r2,r2,255
 20166b4:	1000171e 	bne	r2,zero,2016714 <OSIntExit+0xd0>
                OS_SchedNew();
 20166b8:	20176f40 	call	20176f4 <OS_SchedNew>
                if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy */
 20166bc:	d0e07303 	ldbu	r3,-32308(gp)
 20166c0:	d0a07343 	ldbu	r2,-32307(gp)
 20166c4:	18c03fcc 	andi	r3,r3,255
 20166c8:	10803fcc 	andi	r2,r2,255
 20166cc:	18801126 	beq	r3,r2,2016714 <OSIntExit+0xd0>
                    OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy];
 20166d0:	d0a07303 	ldbu	r2,-32308(gp)
 20166d4:	10803fcc 	andi	r2,r2,255
 20166d8:	00c09934 	movhi	r3,612
 20166dc:	18f45704 	addi	r3,r3,-11940
 20166e0:	1085883a 	add	r2,r2,r2
 20166e4:	1085883a 	add	r2,r2,r2
 20166e8:	1885883a 	add	r2,r3,r2
 20166ec:	10800017 	ldw	r2,0(r2)
 20166f0:	d0a07b15 	stw	r2,-32276(gp)
#if OS_TASK_PROFILE_EN > 0
                    OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task  */
 20166f4:	d0a07b17 	ldw	r2,-32276(gp)
 20166f8:	10c00e17 	ldw	r3,56(r2)
 20166fc:	18c00044 	addi	r3,r3,1
 2016700:	10c00e15 	stw	r3,56(r2)
#endif
                    OSCtxSwCtr++;                          /* Keep track of the number of ctx switches */
 2016704:	d0a07617 	ldw	r2,-32296(gp)
 2016708:	10800044 	addi	r2,r2,1
 201670c:	d0a07615 	stw	r2,-32296(gp)
                    OSIntCtxSw();                          /* Perform interrupt level ctx switch       */
 2016710:	2037b040 	call	2037b04 <OSCtxSw>
 2016714:	e0bffd17 	ldw	r2,-12(fp)
 2016718:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201671c:	e0bfff17 	ldw	r2,-4(fp)
 2016720:	1001703a 	wrctl	status,r2
                }
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 2016724:	e037883a 	mov	sp,fp
 2016728:	dfc00117 	ldw	ra,4(sp)
 201672c:	df000017 	ldw	fp,0(sp)
 2016730:	dec00204 	addi	sp,sp,8
 2016734:	f800283a 	ret

02016738 <OSSchedLock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedLock (void)
{
 2016738:	defffc04 	addi	sp,sp,-16
 201673c:	df000315 	stw	fp,12(sp)
 2016740:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2016744:	e03ffd15 	stw	zero,-12(fp)
#endif



    if (OSRunning == OS_TRUE) {                  /* Make sure multitasking is running                  */
 2016748:	d0a07143 	ldbu	r2,-32315(gp)
 201674c:	10803fcc 	andi	r2,r2,255
 2016750:	10800058 	cmpnei	r2,r2,1
 2016754:	1000161e 	bne	r2,zero,20167b0 <OSSchedLock+0x78>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016758:	0005303a 	rdctl	r2,status
 201675c:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016760:	e0fffe17 	ldw	r3,-8(fp)
 2016764:	00bfff84 	movi	r2,-2
 2016768:	1884703a 	and	r2,r3,r2
 201676c:	1001703a 	wrctl	status,r2
  
  return context;
 2016770:	e0bffe17 	ldw	r2,-8(fp)
        OS_ENTER_CRITICAL();
 2016774:	e0bffd15 	stw	r2,-12(fp)
        if (OSIntNesting == 0) {                 /* Can't call from an ISR                             */
 2016778:	d0a07f03 	ldbu	r2,-32260(gp)
 201677c:	10803fcc 	andi	r2,r2,255
 2016780:	1000071e 	bne	r2,zero,20167a0 <OSSchedLock+0x68>
            if (OSLockNesting < 255u) {          /* Prevent OSLockNesting from wrapping back to 0      */
 2016784:	d0a07103 	ldbu	r2,-32316(gp)
 2016788:	10803fcc 	andi	r2,r2,255
 201678c:	10803fe0 	cmpeqi	r2,r2,255
 2016790:	1000031e 	bne	r2,zero,20167a0 <OSSchedLock+0x68>
                OSLockNesting++;                 /* Increment lock nesting level                       */
 2016794:	d0a07103 	ldbu	r2,-32316(gp)
 2016798:	10800044 	addi	r2,r2,1
 201679c:	d0a07105 	stb	r2,-32316(gp)
 20167a0:	e0bffd17 	ldw	r2,-12(fp)
 20167a4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20167a8:	e0bfff17 	ldw	r2,-4(fp)
 20167ac:	1001703a 	wrctl	status,r2
            }
        }
        OS_EXIT_CRITICAL();
    }
}
 20167b0:	e037883a 	mov	sp,fp
 20167b4:	df000017 	ldw	fp,0(sp)
 20167b8:	dec00104 	addi	sp,sp,4
 20167bc:	f800283a 	ret

020167c0 <OSSchedUnlock>:
*********************************************************************************************************
*/

#if OS_SCHED_LOCK_EN > 0
void  OSSchedUnlock (void)
{
 20167c0:	defff804 	addi	sp,sp,-32
 20167c4:	dfc00715 	stw	ra,28(sp)
 20167c8:	df000615 	stw	fp,24(sp)
 20167cc:	df000604 	addi	fp,sp,24
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 20167d0:	e03ffa15 	stw	zero,-24(fp)
#endif



    if (OSRunning == OS_TRUE) {                            /* Make sure multitasking is running        */
 20167d4:	d0a07143 	ldbu	r2,-32315(gp)
 20167d8:	10803fcc 	andi	r2,r2,255
 20167dc:	10800058 	cmpnei	r2,r2,1
 20167e0:	1000281e 	bne	r2,zero,2016884 <OSSchedUnlock+0xc4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20167e4:	0005303a 	rdctl	r2,status
 20167e8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20167ec:	e0fffb17 	ldw	r3,-20(fp)
 20167f0:	00bfff84 	movi	r2,-2
 20167f4:	1884703a 	and	r2,r3,r2
 20167f8:	1001703a 	wrctl	status,r2
  
  return context;
 20167fc:	e0bffb17 	ldw	r2,-20(fp)
        OS_ENTER_CRITICAL();
 2016800:	e0bffa15 	stw	r2,-24(fp)
        if (OSLockNesting > 0) {                           /* Do not decrement if already 0            */
 2016804:	d0a07103 	ldbu	r2,-32316(gp)
 2016808:	10803fcc 	andi	r2,r2,255
 201680c:	10001926 	beq	r2,zero,2016874 <OSSchedUnlock+0xb4>
            OSLockNesting--;                               /* Decrement lock nesting level             */
 2016810:	d0a07103 	ldbu	r2,-32316(gp)
 2016814:	10bfffc4 	addi	r2,r2,-1
 2016818:	d0a07105 	stb	r2,-32316(gp)
            if (OSLockNesting == 0) {                      /* See if scheduler is enabled and ...      */
 201681c:	d0a07103 	ldbu	r2,-32316(gp)
 2016820:	10803fcc 	andi	r2,r2,255
 2016824:	10000e1e 	bne	r2,zero,2016860 <OSSchedUnlock+0xa0>
                if (OSIntNesting == 0) {                   /* ... not in an ISR                        */
 2016828:	d0a07f03 	ldbu	r2,-32260(gp)
 201682c:	10803fcc 	andi	r2,r2,255
 2016830:	1000061e 	bne	r2,zero,201684c <OSSchedUnlock+0x8c>
 2016834:	e0bffa17 	ldw	r2,-24(fp)
 2016838:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201683c:	e0bffc17 	ldw	r2,-16(fp)
 2016840:	1001703a 	wrctl	status,r2
                    OS_EXIT_CRITICAL();
                    OS_Sched();                            /* See if a HPT is ready                    */
 2016844:	20176280 	call	2017628 <OS_Sched>
 2016848:	00000e06 	br	2016884 <OSSchedUnlock+0xc4>
 201684c:	e0bffa17 	ldw	r2,-24(fp)
 2016850:	e0bffd15 	stw	r2,-12(fp)
 2016854:	e0bffd17 	ldw	r2,-12(fp)
 2016858:	1001703a 	wrctl	status,r2
 201685c:	00000906 	br	2016884 <OSSchedUnlock+0xc4>
 2016860:	e0bffa17 	ldw	r2,-24(fp)
 2016864:	e0bffe15 	stw	r2,-8(fp)
 2016868:	e0bffe17 	ldw	r2,-8(fp)
 201686c:	1001703a 	wrctl	status,r2
 2016870:	00000406 	br	2016884 <OSSchedUnlock+0xc4>
 2016874:	e0bffa17 	ldw	r2,-24(fp)
 2016878:	e0bfff15 	stw	r2,-4(fp)
 201687c:	e0bfff17 	ldw	r2,-4(fp)
 2016880:	1001703a 	wrctl	status,r2
            }
        } else {
            OS_EXIT_CRITICAL();
        }
    }
}
 2016884:	e037883a 	mov	sp,fp
 2016888:	dfc00117 	ldw	ra,4(sp)
 201688c:	df000017 	ldw	fp,0(sp)
 2016890:	dec00204 	addi	sp,sp,8
 2016894:	f800283a 	ret

02016898 <OSStart>:
*                 d_ Execute the task.
*********************************************************************************************************
*/

void  OSStart (void)
{
 2016898:	defffe04 	addi	sp,sp,-8
 201689c:	dfc00115 	stw	ra,4(sp)
 20168a0:	df000015 	stw	fp,0(sp)
 20168a4:	d839883a 	mov	fp,sp
    if (OSRunning == OS_FALSE) {
 20168a8:	d0a07143 	ldbu	r2,-32315(gp)
 20168ac:	10803fcc 	andi	r2,r2,255
 20168b0:	10000f1e 	bne	r2,zero,20168f0 <OSStart+0x58>
        OS_SchedNew();                               /* Find highest priority's task priority number   */
 20168b4:	20176f40 	call	20176f4 <OS_SchedNew>
        OSPrioCur     = OSPrioHighRdy;
 20168b8:	d0a07303 	ldbu	r2,-32308(gp)
 20168bc:	d0a07345 	stb	r2,-32307(gp)
        OSTCBHighRdy  = OSTCBPrioTbl[OSPrioHighRdy]; /* Point to highest priority task ready to run    */
 20168c0:	d0a07303 	ldbu	r2,-32308(gp)
 20168c4:	10803fcc 	andi	r2,r2,255
 20168c8:	00c09934 	movhi	r3,612
 20168cc:	18f45704 	addi	r3,r3,-11940
 20168d0:	1085883a 	add	r2,r2,r2
 20168d4:	1085883a 	add	r2,r2,r2
 20168d8:	1885883a 	add	r2,r3,r2
 20168dc:	10800017 	ldw	r2,0(r2)
 20168e0:	d0a07b15 	stw	r2,-32276(gp)
        OSTCBCur      = OSTCBHighRdy;
 20168e4:	d0a07b17 	ldw	r2,-32276(gp)
 20168e8:	d0a08015 	stw	r2,-32256(gp)
        OSStartHighRdy();                            /* Execute target specific code to start task     */
 20168ec:	2037b900 	call	2037b90 <OSStartHighRdy>
    }
}
 20168f0:	e037883a 	mov	sp,fp
 20168f4:	dfc00117 	ldw	ra,4(sp)
 20168f8:	df000017 	ldw	fp,0(sp)
 20168fc:	dec00204 	addi	sp,sp,8
 2016900:	f800283a 	ret

02016904 <OSStatInit>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OSStatInit (void)
{
 2016904:	defff904 	addi	sp,sp,-28
 2016908:	dfc00615 	stw	ra,24(sp)
 201690c:	df000515 	stw	fp,20(sp)
 2016910:	df000504 	addi	fp,sp,20
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2016914:	e03ffb15 	stw	zero,-20(fp)
#endif



    OSTimeDly(2);                                /* Synchronize with clock tick                        */
 2016918:	01000084 	movi	r4,2
 201691c:	201e00c0 	call	201e00c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016920:	0005303a 	rdctl	r2,status
 2016924:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016928:	e0fffc17 	ldw	r3,-16(fp)
 201692c:	00bfff84 	movi	r2,-2
 2016930:	1884703a 	and	r2,r3,r2
 2016934:	1001703a 	wrctl	status,r2
  
  return context;
 2016938:	e0bffc17 	ldw	r2,-16(fp)
    OS_ENTER_CRITICAL();
 201693c:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtr    = 0L;                           /* Clear idle counter                                 */
 2016940:	d0207215 	stw	zero,-32312(gp)
 2016944:	e0bffb17 	ldw	r2,-20(fp)
 2016948:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201694c:	e0bffd17 	ldw	r2,-12(fp)
 2016950:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OSTimeDly(OS_TICKS_PER_SEC / 10);            /* Determine MAX. idle counter value for 1/10 second  */
 2016954:	01000284 	movi	r4,10
 2016958:	201e00c0 	call	201e00c <OSTimeDly>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201695c:	0005303a 	rdctl	r2,status
 2016960:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016964:	e0fffe17 	ldw	r3,-8(fp)
 2016968:	00bfff84 	movi	r2,-2
 201696c:	1884703a 	and	r2,r3,r2
 2016970:	1001703a 	wrctl	status,r2
  
  return context;
 2016974:	e0bffe17 	ldw	r2,-8(fp)
    OS_ENTER_CRITICAL();
 2016978:	e0bffb15 	stw	r2,-20(fp)
    OSIdleCtrMax = OSIdleCtr;                    /* Store maximum idle counter count in 1/10 second    */
 201697c:	d0a07217 	ldw	r2,-32312(gp)
 2016980:	d0a07715 	stw	r2,-32292(gp)
    OSStatRdy    = OS_TRUE;
 2016984:	00800044 	movi	r2,1
 2016988:	d0a08305 	stb	r2,-32244(gp)
 201698c:	e0bffb17 	ldw	r2,-20(fp)
 2016990:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016994:	e0bfff17 	ldw	r2,-4(fp)
 2016998:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 201699c:	e037883a 	mov	sp,fp
 20169a0:	dfc00117 	ldw	ra,4(sp)
 20169a4:	df000017 	ldw	fp,0(sp)
 20169a8:	dec00204 	addi	sp,sp,8
 20169ac:	f800283a 	ret

020169b0 <OSTimeTick>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeTick (void)
{
 20169b0:	defff704 	addi	sp,sp,-36
 20169b4:	dfc00815 	stw	ra,32(sp)
 20169b8:	df000715 	stw	fp,28(sp)
 20169bc:	df000704 	addi	fp,sp,28
    OS_TCB    *ptcb;
#if OS_TICK_STEP_EN > 0
    BOOLEAN    step;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 20169c0:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_TIME_TICK_HOOK_EN > 0
    OSTimeTickHook();                                      /* Call user definable hook                     */
 20169c4:	2037f400 	call	2037f40 <OSTimeTickHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20169c8:	0005303a 	rdctl	r2,status
 20169cc:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20169d0:	e0fffc17 	ldw	r3,-16(fp)
 20169d4:	00bfff84 	movi	r2,-2
 20169d8:	1884703a 	and	r2,r3,r2
 20169dc:	1001703a 	wrctl	status,r2
  
  return context;
 20169e0:	e0bffc17 	ldw	r2,-16(fp)
#endif
#if OS_TIME_GET_SET_EN > 0
    OS_ENTER_CRITICAL();                                   /* Update the 32-bit tick counter               */
 20169e4:	e0bffb15 	stw	r2,-20(fp)
    OSTime++;
 20169e8:	d0a08117 	ldw	r2,-32252(gp)
 20169ec:	10800044 	addi	r2,r2,1
 20169f0:	d0a08115 	stw	r2,-32252(gp)
 20169f4:	e0bffb17 	ldw	r2,-20(fp)
 20169f8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20169fc:	e0bffd17 	ldw	r2,-12(fp)
 2016a00:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#endif
    if (OSRunning == OS_TRUE) {
 2016a04:	d0a07143 	ldbu	r2,-32315(gp)
 2016a08:	10803fcc 	andi	r2,r2,255
 2016a0c:	10800058 	cmpnei	r2,r2,1
 2016a10:	10006a1e 	bne	r2,zero,2016bbc <OSTimeTick+0x20c>
#if OS_TICK_STEP_EN > 0
        switch (OSTickStepState) {                         /* Determine whether we need to process a tick  */
 2016a14:	d0a07503 	ldbu	r2,-32300(gp)
 2016a18:	10803fcc 	andi	r2,r2,255
 2016a1c:	10c00060 	cmpeqi	r3,r2,1
 2016a20:	1800061e 	bne	r3,zero,2016a3c <OSTimeTick+0x8c>
 2016a24:	10c000a0 	cmpeqi	r3,r2,2
 2016a28:	1800061e 	bne	r3,zero,2016a44 <OSTimeTick+0x94>
 2016a2c:	10000a1e 	bne	r2,zero,2016a58 <OSTimeTick+0xa8>
            case OS_TICK_STEP_DIS:                         /* Yes, stepping is disabled                    */
                 step = OS_TRUE;
 2016a30:	00800044 	movi	r2,1
 2016a34:	e0bffa05 	stb	r2,-24(fp)
                 break;
 2016a38:	00000b06 	br	2016a68 <OSTimeTick+0xb8>

            case OS_TICK_STEP_WAIT:                        /* No,  waiting for uC/OS-View to set ...       */
                 step = OS_FALSE;                          /*      .. OSTickStepState to OS_TICK_STEP_ONCE */
 2016a3c:	e03ffa05 	stb	zero,-24(fp)
                 break;
 2016a40:	00000906 	br	2016a68 <OSTimeTick+0xb8>

            case OS_TICK_STEP_ONCE:                        /* Yes, process tick once and wait for next ... */
                 step            = OS_TRUE;                /*      ... step command from uC/OS-View        */
 2016a44:	00800044 	movi	r2,1
 2016a48:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_WAIT;
 2016a4c:	00800044 	movi	r2,1
 2016a50:	d0a07505 	stb	r2,-32300(gp)
                 break;
 2016a54:	00000406 	br	2016a68 <OSTimeTick+0xb8>

            default:                                       /* Invalid case, correct situation              */
                 step            = OS_TRUE;
 2016a58:	00800044 	movi	r2,1
 2016a5c:	e0bffa05 	stb	r2,-24(fp)
                 OSTickStepState = OS_TICK_STEP_DIS;
 2016a60:	d0207505 	stb	zero,-32300(gp)
                 break;
 2016a64:	0001883a 	nop
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
 2016a68:	e0bffa03 	ldbu	r2,-24(fp)
 2016a6c:	10005226 	beq	r2,zero,2016bb8 <OSTimeTick+0x208>
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
 2016a70:	d0a07417 	ldw	r2,-32304(gp)
 2016a74:	e0bff915 	stw	r2,-28(fp)
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 2016a78:	00004906 	br	2016ba0 <OSTimeTick+0x1f0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2016a7c:	0005303a 	rdctl	r2,status
 2016a80:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2016a84:	e0fffe17 	ldw	r3,-8(fp)
 2016a88:	00bfff84 	movi	r2,-2
 2016a8c:	1884703a 	and	r2,r3,r2
 2016a90:	1001703a 	wrctl	status,r2
  
  return context;
 2016a94:	e0bffe17 	ldw	r2,-8(fp)
            OS_ENTER_CRITICAL();
 2016a98:	e0bffb15 	stw	r2,-20(fp)
            if (ptcb->OSTCBDly != 0) {                     /* No, Delayed or waiting for event with TO     */
 2016a9c:	e0bff917 	ldw	r2,-28(fp)
 2016aa0:	10800b8b 	ldhu	r2,46(r2)
 2016aa4:	10bfffcc 	andi	r2,r2,65535
 2016aa8:	10003626 	beq	r2,zero,2016b84 <OSTimeTick+0x1d4>
                if (--ptcb->OSTCBDly == 0) {               /* Decrement nbr of ticks to end of delay       */
 2016aac:	e0bff917 	ldw	r2,-28(fp)
 2016ab0:	10800b8b 	ldhu	r2,46(r2)
 2016ab4:	10bfffc4 	addi	r2,r2,-1
 2016ab8:	1007883a 	mov	r3,r2
 2016abc:	e0bff917 	ldw	r2,-28(fp)
 2016ac0:	10c00b8d 	sth	r3,46(r2)
 2016ac4:	e0bff917 	ldw	r2,-28(fp)
 2016ac8:	10800b8b 	ldhu	r2,46(r2)
 2016acc:	10bfffcc 	andi	r2,r2,65535
 2016ad0:	10002c1e 	bne	r2,zero,2016b84 <OSTimeTick+0x1d4>
                                                           /* Check for timeout                            */
                    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 2016ad4:	e0bff917 	ldw	r2,-28(fp)
 2016ad8:	10800c03 	ldbu	r2,48(r2)
 2016adc:	10803fcc 	andi	r2,r2,255
 2016ae0:	10800dcc 	andi	r2,r2,55
 2016ae4:	10000b26 	beq	r2,zero,2016b14 <OSTimeTick+0x164>
                        ptcb->OSTCBStat  &= ~(INT8U)OS_STAT_PEND_ANY;          /* Yes, Clear status flag   */
 2016ae8:	e0bff917 	ldw	r2,-28(fp)
 2016aec:	10c00c03 	ldbu	r3,48(r2)
 2016af0:	00bff204 	movi	r2,-56
 2016af4:	1884703a 	and	r2,r3,r2
 2016af8:	1007883a 	mov	r3,r2
 2016afc:	e0bff917 	ldw	r2,-28(fp)
 2016b00:	10c00c05 	stb	r3,48(r2)
                        ptcb->OSTCBStatPend = OS_STAT_PEND_TO;                 /* Indicate PEND timeout    */
 2016b04:	e0bff917 	ldw	r2,-28(fp)
 2016b08:	00c00044 	movi	r3,1
 2016b0c:	10c00c45 	stb	r3,49(r2)
 2016b10:	00000206 	br	2016b1c <OSTimeTick+0x16c>
                    } else {
                        ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 2016b14:	e0bff917 	ldw	r2,-28(fp)
 2016b18:	10000c45 	stb	zero,49(r2)
                    }

                    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?       */
 2016b1c:	e0bff917 	ldw	r2,-28(fp)
 2016b20:	10800c03 	ldbu	r2,48(r2)
 2016b24:	10803fcc 	andi	r2,r2,255
 2016b28:	1080020c 	andi	r2,r2,8
 2016b2c:	1000151e 	bne	r2,zero,2016b84 <OSTimeTick+0x1d4>
                        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready          */
 2016b30:	e0bff917 	ldw	r2,-28(fp)
 2016b34:	10c00d83 	ldbu	r3,54(r2)
 2016b38:	d0a07d03 	ldbu	r2,-32268(gp)
 2016b3c:	1884b03a 	or	r2,r3,r2
 2016b40:	d0a07d05 	stb	r2,-32268(gp)
                        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 2016b44:	e0bff917 	ldw	r2,-28(fp)
 2016b48:	10800d03 	ldbu	r2,52(r2)
 2016b4c:	11003fcc 	andi	r4,r2,255
 2016b50:	e0bff917 	ldw	r2,-28(fp)
 2016b54:	10800d03 	ldbu	r2,52(r2)
 2016b58:	10c03fcc 	andi	r3,r2,255
 2016b5c:	d0a07d44 	addi	r2,gp,-32267
 2016b60:	1885883a 	add	r2,r3,r2
 2016b64:	10c00003 	ldbu	r3,0(r2)
 2016b68:	e0bff917 	ldw	r2,-28(fp)
 2016b6c:	10800d43 	ldbu	r2,53(r2)
 2016b70:	1884b03a 	or	r2,r3,r2
 2016b74:	1007883a 	mov	r3,r2
 2016b78:	d0a07d44 	addi	r2,gp,-32267
 2016b7c:	2085883a 	add	r2,r4,r2
 2016b80:	10c00005 	stb	r3,0(r2)
                    }
                }
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
 2016b84:	e0bff917 	ldw	r2,-28(fp)
 2016b88:	10800517 	ldw	r2,20(r2)
 2016b8c:	e0bff915 	stw	r2,-28(fp)
 2016b90:	e0bffb17 	ldw	r2,-20(fp)
 2016b94:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2016b98:	e0bfff17 	ldw	r2,-4(fp)
 2016b9c:	1001703a 	wrctl	status,r2
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
        }
#endif
        ptcb = OSTCBList;                                  /* Point at first TCB in TCB list               */
        while (ptcb->OSTCBPrio != OS_TASK_IDLE_PRIO) {     /* Go through all TCBs in TCB list              */
 2016ba0:	e0bff917 	ldw	r2,-28(fp)
 2016ba4:	10800c83 	ldbu	r2,50(r2)
 2016ba8:	10803fcc 	andi	r2,r2,255
 2016bac:	10800518 	cmpnei	r2,r2,20
 2016bb0:	103fb21e 	bne	r2,zero,2016a7c <OSTimeTick+0xcc>
 2016bb4:	00000106 	br	2016bbc <OSTimeTick+0x20c>
                 step            = OS_TRUE;
                 OSTickStepState = OS_TICK_STEP_DIS;
                 break;
        }
        if (step == OS_FALSE) {                            /* Return if waiting for step command           */
            return;
 2016bb8:	0001883a 	nop
            }
            ptcb = ptcb->OSTCBNext;                        /* Point at next TCB in TCB list                */
            OS_EXIT_CRITICAL();
        }
    }
}
 2016bbc:	e037883a 	mov	sp,fp
 2016bc0:	dfc00117 	ldw	ra,4(sp)
 2016bc4:	df000017 	ldw	fp,0(sp)
 2016bc8:	dec00204 	addi	sp,sp,8
 2016bcc:	f800283a 	ret

02016bd0 <OSVersion>:
* Returns    : the version number of uC/OS-II multiplied by 100.
*********************************************************************************************************
*/

INT16U  OSVersion (void)
{
 2016bd0:	deffff04 	addi	sp,sp,-4
 2016bd4:	df000015 	stw	fp,0(sp)
 2016bd8:	d839883a 	mov	fp,sp
    return (OS_VERSION);
 2016bdc:	00804784 	movi	r2,286
}
 2016be0:	e037883a 	mov	sp,fp
 2016be4:	df000017 	ldw	fp,0(sp)
 2016be8:	dec00104 	addi	sp,sp,4
 2016bec:	f800283a 	ret

02016bf0 <OS_Dummy>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
void  OS_Dummy (void)
{
 2016bf0:	deffff04 	addi	sp,sp,-4
 2016bf4:	df000015 	stw	fp,0(sp)
 2016bf8:	d839883a 	mov	fp,sp
}
 2016bfc:	e037883a 	mov	sp,fp
 2016c00:	df000017 	ldw	fp,0(sp)
 2016c04:	dec00104 	addi	sp,sp,4
 2016c08:	f800283a 	ret

02016c0c <OS_EventTaskRdy>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
INT8U  OS_EventTaskRdy (OS_EVENT *pevent, void *pmsg, INT8U msk, INT8U pend_stat)
{
 2016c0c:	defff804 	addi	sp,sp,-32
 2016c10:	dfc00715 	stw	ra,28(sp)
 2016c14:	df000615 	stw	fp,24(sp)
 2016c18:	df000604 	addi	fp,sp,24
 2016c1c:	e13ffc15 	stw	r4,-16(fp)
 2016c20:	e17ffd15 	stw	r5,-12(fp)
 2016c24:	3007883a 	mov	r3,r6
 2016c28:	3805883a 	mov	r2,r7
 2016c2c:	e0fffe05 	stb	r3,-8(fp)
 2016c30:	e0bfff05 	stb	r2,-4(fp)
    INT16U  *ptbl;
#endif


#if OS_LOWEST_PRIO <= 63
    y    = OSUnMapTbl[pevent->OSEventGrp];              /* Find HPT waiting for message                */
 2016c34:	e0bffc17 	ldw	r2,-16(fp)
 2016c38:	10800283 	ldbu	r2,10(r2)
 2016c3c:	10803fcc 	andi	r2,r2,255
 2016c40:	00c08174 	movhi	r3,517
 2016c44:	18f86204 	addi	r3,r3,-7800
 2016c48:	1885883a 	add	r2,r3,r2
 2016c4c:	10800003 	ldbu	r2,0(r2)
 2016c50:	e0bffa05 	stb	r2,-24(fp)
    x    = OSUnMapTbl[pevent->OSEventTbl[y]];
 2016c54:	e0bffa03 	ldbu	r2,-24(fp)
 2016c58:	e0fffc17 	ldw	r3,-16(fp)
 2016c5c:	1885883a 	add	r2,r3,r2
 2016c60:	10800204 	addi	r2,r2,8
 2016c64:	108000c3 	ldbu	r2,3(r2)
 2016c68:	10803fcc 	andi	r2,r2,255
 2016c6c:	00c08174 	movhi	r3,517
 2016c70:	18f86204 	addi	r3,r3,-7800
 2016c74:	1885883a 	add	r2,r3,r2
 2016c78:	10800003 	ldbu	r2,0(r2)
 2016c7c:	e0bffa45 	stb	r2,-23(fp)
    prio = (INT8U)((y << 3) + x);                       /* Find priority of task getting the msg       */
 2016c80:	e0bffa03 	ldbu	r2,-24(fp)
 2016c84:	100490fa 	slli	r2,r2,3
 2016c88:	1007883a 	mov	r3,r2
 2016c8c:	e0bffa43 	ldbu	r2,-23(fp)
 2016c90:	1885883a 	add	r2,r3,r2
 2016c94:	e0bffa85 	stb	r2,-22(fp)
        x = OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8;
    }
    prio = (INT8U)((y << 4) + x);                       /* Find priority of task getting the msg       */
#endif

    ptcb                  =  OSTCBPrioTbl[prio];        /* Point to this task's OS_TCB                 */
 2016c98:	e0bffa83 	ldbu	r2,-22(fp)
 2016c9c:	00c09934 	movhi	r3,612
 2016ca0:	18f45704 	addi	r3,r3,-11940
 2016ca4:	1085883a 	add	r2,r2,r2
 2016ca8:	1085883a 	add	r2,r2,r2
 2016cac:	1885883a 	add	r2,r3,r2
 2016cb0:	10800017 	ldw	r2,0(r2)
 2016cb4:	e0bffb15 	stw	r2,-20(fp)
    ptcb->OSTCBDly        =  0;                         /* Prevent OSTimeTick() from readying task     */
 2016cb8:	e0bffb17 	ldw	r2,-20(fp)
 2016cbc:	10000b8d 	sth	zero,46(r2)
#if ((OS_Q_EN > 0) && (OS_MAX_QS > 0)) || (OS_MBOX_EN > 0)
    ptcb->OSTCBMsg        =  pmsg;                      /* Send message directly to waiting task       */
 2016cc0:	e0bffb17 	ldw	r2,-20(fp)
 2016cc4:	e0fffd17 	ldw	r3,-12(fp)
 2016cc8:	10c00915 	stw	r3,36(r2)
#else
    pmsg                  =  pmsg;                      /* Prevent compiler warning if not used        */
#endif
    ptcb->OSTCBStat      &= ~msk;                       /* Clear bit associated with event type        */
 2016ccc:	e0bffb17 	ldw	r2,-20(fp)
 2016cd0:	10800c03 	ldbu	r2,48(r2)
 2016cd4:	1007883a 	mov	r3,r2
 2016cd8:	e0bffe03 	ldbu	r2,-8(fp)
 2016cdc:	0084303a 	nor	r2,zero,r2
 2016ce0:	1884703a 	and	r2,r3,r2
 2016ce4:	1007883a 	mov	r3,r2
 2016ce8:	e0bffb17 	ldw	r2,-20(fp)
 2016cec:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend   =  pend_stat;                 /* Set pend status of post or abort            */
 2016cf0:	e0bffb17 	ldw	r2,-20(fp)
 2016cf4:	e0ffff03 	ldbu	r3,-4(fp)
 2016cf8:	10c00c45 	stb	r3,49(r2)
                                                        /* See if task is ready (could be susp'd)      */
    if ((ptcb->OSTCBStat &   OS_STAT_SUSPEND) == OS_STAT_RDY) {
 2016cfc:	e0bffb17 	ldw	r2,-20(fp)
 2016d00:	10800c03 	ldbu	r2,48(r2)
 2016d04:	10803fcc 	andi	r2,r2,255
 2016d08:	1080020c 	andi	r2,r2,8
 2016d0c:	1000111e 	bne	r2,zero,2016d54 <OS_EventTaskRdy+0x148>
        OSRdyGrp         |=  ptcb->OSTCBBitY;           /* Put task in the ready to run list           */
 2016d10:	e0bffb17 	ldw	r2,-20(fp)
 2016d14:	10c00d83 	ldbu	r3,54(r2)
 2016d18:	d0a07d03 	ldbu	r2,-32268(gp)
 2016d1c:	1884b03a 	or	r2,r3,r2
 2016d20:	d0a07d05 	stb	r2,-32268(gp)
        OSRdyTbl[y]      |=  ptcb->OSTCBBitX;
 2016d24:	e13ffa03 	ldbu	r4,-24(fp)
 2016d28:	e0fffa03 	ldbu	r3,-24(fp)
 2016d2c:	d0a07d44 	addi	r2,gp,-32267
 2016d30:	1885883a 	add	r2,r3,r2
 2016d34:	10c00003 	ldbu	r3,0(r2)
 2016d38:	e0bffb17 	ldw	r2,-20(fp)
 2016d3c:	10800d43 	ldbu	r2,53(r2)
 2016d40:	1884b03a 	or	r2,r3,r2
 2016d44:	1007883a 	mov	r3,r2
 2016d48:	d0a07d44 	addi	r2,gp,-32267
 2016d4c:	2085883a 	add	r2,r4,r2
 2016d50:	10c00005 	stb	r3,0(r2)
    }

    OS_EventTaskRemove(ptcb, pevent);                   /* Remove this task from event   wait list     */
 2016d54:	e13ffb17 	ldw	r4,-20(fp)
 2016d58:	e17ffc17 	ldw	r5,-16(fp)
 2016d5c:	2016ff40 	call	2016ff4 <OS_EventTaskRemove>
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from events' wait lists    */
 2016d60:	e0bffb17 	ldw	r2,-20(fp)
 2016d64:	10800817 	ldw	r2,32(r2)
 2016d68:	10000826 	beq	r2,zero,2016d8c <OS_EventTaskRdy+0x180>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 2016d6c:	e0bffb17 	ldw	r2,-20(fp)
 2016d70:	10800817 	ldw	r2,32(r2)
 2016d74:	e13ffb17 	ldw	r4,-20(fp)
 2016d78:	100b883a 	mov	r5,r2
 2016d7c:	20170a40 	call	20170a4 <OS_EventTaskRemoveMulti>
        ptcb->OSTCBEventPtr       = (OS_EVENT  *)pevent;/* Return event as first multi-pend event ready*/
 2016d80:	e0bffb17 	ldw	r2,-20(fp)
 2016d84:	e0fffc17 	ldw	r3,-16(fp)
 2016d88:	10c00715 	stw	r3,28(r2)
    }
#endif

    return (prio);
 2016d8c:	e0bffa83 	ldbu	r2,-22(fp)
}
 2016d90:	e037883a 	mov	sp,fp
 2016d94:	dfc00117 	ldw	ra,4(sp)
 2016d98:	df000017 	ldw	fp,0(sp)
 2016d9c:	dec00204 	addi	sp,sp,8
 2016da0:	f800283a 	ret

02016da4 <OS_EventTaskWait>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskWait (OS_EVENT *pevent)
{
 2016da4:	defffd04 	addi	sp,sp,-12
 2016da8:	df000215 	stw	fp,8(sp)
 2016dac:	df000204 	addi	fp,sp,8
 2016db0:	e13fff15 	stw	r4,-4(fp)
    INT8U  y;


    OSTCBCur->OSTCBEventPtr               = pevent;                 /* Store ptr to ECB in TCB         */
 2016db4:	d0a08017 	ldw	r2,-32256(gp)
 2016db8:	e0ffff17 	ldw	r3,-4(fp)
 2016dbc:	10c00715 	stw	r3,28(r2)

    pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;    /* Put task in waiting list        */
 2016dc0:	d0a08017 	ldw	r2,-32256(gp)
 2016dc4:	10800d03 	ldbu	r2,52(r2)
 2016dc8:	10803fcc 	andi	r2,r2,255
 2016dcc:	d0e08017 	ldw	r3,-32256(gp)
 2016dd0:	18c00d03 	ldbu	r3,52(r3)
 2016dd4:	18c03fcc 	andi	r3,r3,255
 2016dd8:	e13fff17 	ldw	r4,-4(fp)
 2016ddc:	20c7883a 	add	r3,r4,r3
 2016de0:	18c00204 	addi	r3,r3,8
 2016de4:	190000c3 	ldbu	r4,3(r3)
 2016de8:	d0e08017 	ldw	r3,-32256(gp)
 2016dec:	18c00d43 	ldbu	r3,53(r3)
 2016df0:	20c6b03a 	or	r3,r4,r3
 2016df4:	e13fff17 	ldw	r4,-4(fp)
 2016df8:	2085883a 	add	r2,r4,r2
 2016dfc:	10800204 	addi	r2,r2,8
 2016e00:	10c000c5 	stb	r3,3(r2)
    pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 2016e04:	e0bfff17 	ldw	r2,-4(fp)
 2016e08:	10c00283 	ldbu	r3,10(r2)
 2016e0c:	d0a08017 	ldw	r2,-32256(gp)
 2016e10:	10800d83 	ldbu	r2,54(r2)
 2016e14:	1884b03a 	or	r2,r3,r2
 2016e18:	1007883a 	mov	r3,r2
 2016e1c:	e0bfff17 	ldw	r2,-4(fp)
 2016e20:	10c00285 	stb	r3,10(r2)

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 2016e24:	d0a08017 	ldw	r2,-32256(gp)
 2016e28:	10800d03 	ldbu	r2,52(r2)
 2016e2c:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 2016e30:	e13ffe03 	ldbu	r4,-8(fp)
 2016e34:	e0fffe03 	ldbu	r3,-8(fp)
 2016e38:	d0a07d44 	addi	r2,gp,-32267
 2016e3c:	1885883a 	add	r2,r3,r2
 2016e40:	10800003 	ldbu	r2,0(r2)
 2016e44:	1007883a 	mov	r3,r2
 2016e48:	d0a08017 	ldw	r2,-32256(gp)
 2016e4c:	10800d43 	ldbu	r2,53(r2)
 2016e50:	0084303a 	nor	r2,zero,r2
 2016e54:	1884703a 	and	r2,r3,r2
 2016e58:	1007883a 	mov	r3,r2
 2016e5c:	d0a07d44 	addi	r2,gp,-32267
 2016e60:	2085883a 	add	r2,r4,r2
 2016e64:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 2016e68:	e0fffe03 	ldbu	r3,-8(fp)
 2016e6c:	d0a07d44 	addi	r2,gp,-32267
 2016e70:	1885883a 	add	r2,r3,r2
 2016e74:	10800003 	ldbu	r2,0(r2)
 2016e78:	10803fcc 	andi	r2,r2,255
 2016e7c:	1000071e 	bne	r2,zero,2016e9c <OS_EventTaskWait+0xf8>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 2016e80:	d0a08017 	ldw	r2,-32256(gp)
 2016e84:	10800d83 	ldbu	r2,54(r2)
 2016e88:	0084303a 	nor	r2,zero,r2
 2016e8c:	1007883a 	mov	r3,r2
 2016e90:	d0a07d03 	ldbu	r2,-32268(gp)
 2016e94:	1884703a 	and	r2,r3,r2
 2016e98:	d0a07d05 	stb	r2,-32268(gp)
    }
}
 2016e9c:	e037883a 	mov	sp,fp
 2016ea0:	df000017 	ldw	fp,0(sp)
 2016ea4:	dec00104 	addi	sp,sp,4
 2016ea8:	f800283a 	ret

02016eac <OS_EventTaskWaitMulti>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskWaitMulti (OS_EVENT **pevents_wait)
{
 2016eac:	defffb04 	addi	sp,sp,-20
 2016eb0:	df000415 	stw	fp,16(sp)
 2016eb4:	df000404 	addi	fp,sp,16
 2016eb8:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT **pevents;
    OS_EVENT  *pevent;
    INT8U      y;


    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
 2016ebc:	d0a08017 	ldw	r2,-32256(gp)
 2016ec0:	10000715 	stw	zero,28(r2)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */
 2016ec4:	d0a08017 	ldw	r2,-32256(gp)
 2016ec8:	e0ffff17 	ldw	r3,-4(fp)
 2016ecc:	10c00815 	stw	r3,32(r2)

    pevents =  pevents_wait;
 2016ed0:	e0bfff17 	ldw	r2,-4(fp)
 2016ed4:	e0bffc15 	stw	r2,-16(fp)
    pevent  = *pevents;
 2016ed8:	e0bffc17 	ldw	r2,-16(fp)
 2016edc:	10800017 	ldw	r2,0(r2)
 2016ee0:	e0bffd15 	stw	r2,-12(fp)
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 2016ee4:	00001f06 	br	2016f64 <OS_EventTaskWaitMulti+0xb8>
        pevent->OSEventTbl[OSTCBCur->OSTCBY] |= OSTCBCur->OSTCBBitX;
 2016ee8:	d0a08017 	ldw	r2,-32256(gp)
 2016eec:	10800d03 	ldbu	r2,52(r2)
 2016ef0:	10803fcc 	andi	r2,r2,255
 2016ef4:	d0e08017 	ldw	r3,-32256(gp)
 2016ef8:	18c00d03 	ldbu	r3,52(r3)
 2016efc:	18c03fcc 	andi	r3,r3,255
 2016f00:	e13ffd17 	ldw	r4,-12(fp)
 2016f04:	20c7883a 	add	r3,r4,r3
 2016f08:	18c00204 	addi	r3,r3,8
 2016f0c:	190000c3 	ldbu	r4,3(r3)
 2016f10:	d0e08017 	ldw	r3,-32256(gp)
 2016f14:	18c00d43 	ldbu	r3,53(r3)
 2016f18:	20c6b03a 	or	r3,r4,r3
 2016f1c:	e13ffd17 	ldw	r4,-12(fp)
 2016f20:	2085883a 	add	r2,r4,r2
 2016f24:	10800204 	addi	r2,r2,8
 2016f28:	10c000c5 	stb	r3,3(r2)
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
 2016f2c:	e0bffd17 	ldw	r2,-12(fp)
 2016f30:	10c00283 	ldbu	r3,10(r2)
 2016f34:	d0a08017 	ldw	r2,-32256(gp)
 2016f38:	10800d83 	ldbu	r2,54(r2)
 2016f3c:	1884b03a 	or	r2,r3,r2
 2016f40:	1007883a 	mov	r3,r2
 2016f44:	e0bffd17 	ldw	r2,-12(fp)
 2016f48:	10c00285 	stb	r3,10(r2)
        pevents++;
 2016f4c:	e0bffc17 	ldw	r2,-16(fp)
 2016f50:	10800104 	addi	r2,r2,4
 2016f54:	e0bffc15 	stw	r2,-16(fp)
        pevent = *pevents;
 2016f58:	e0bffc17 	ldw	r2,-16(fp)
 2016f5c:	10800017 	ldw	r2,0(r2)
 2016f60:	e0bffd15 	stw	r2,-12(fp)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)pevents_wait;       /* Store ptr to ECBs in TCB        */

    pevents =  pevents_wait;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                               /* Put task in waiting lists       */
 2016f64:	e0bffd17 	ldw	r2,-12(fp)
 2016f68:	103fdf1e 	bne	r2,zero,2016ee8 <OS_EventTaskWaitMulti+0x3c>
        pevent->OSEventGrp                   |= OSTCBCur->OSTCBBitY;
        pevents++;
        pevent = *pevents;
    }

    y             =  OSTCBCur->OSTCBY;            /* Task no longer ready                              */
 2016f6c:	d0a08017 	ldw	r2,-32256(gp)
 2016f70:	10800d03 	ldbu	r2,52(r2)
 2016f74:	e0bffe05 	stb	r2,-8(fp)
    OSRdyTbl[y]  &= ~OSTCBCur->OSTCBBitX;
 2016f78:	e13ffe03 	ldbu	r4,-8(fp)
 2016f7c:	e0fffe03 	ldbu	r3,-8(fp)
 2016f80:	d0a07d44 	addi	r2,gp,-32267
 2016f84:	1885883a 	add	r2,r3,r2
 2016f88:	10800003 	ldbu	r2,0(r2)
 2016f8c:	1007883a 	mov	r3,r2
 2016f90:	d0a08017 	ldw	r2,-32256(gp)
 2016f94:	10800d43 	ldbu	r2,53(r2)
 2016f98:	0084303a 	nor	r2,zero,r2
 2016f9c:	1884703a 	and	r2,r3,r2
 2016fa0:	1007883a 	mov	r3,r2
 2016fa4:	d0a07d44 	addi	r2,gp,-32267
 2016fa8:	2085883a 	add	r2,r4,r2
 2016fac:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 2016fb0:	e0fffe03 	ldbu	r3,-8(fp)
 2016fb4:	d0a07d44 	addi	r2,gp,-32267
 2016fb8:	1885883a 	add	r2,r3,r2
 2016fbc:	10800003 	ldbu	r2,0(r2)
 2016fc0:	10803fcc 	andi	r2,r2,255
 2016fc4:	1000071e 	bne	r2,zero,2016fe4 <OS_EventTaskWaitMulti+0x138>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;         /* Clear event grp bit if this was only task pending */
 2016fc8:	d0a08017 	ldw	r2,-32256(gp)
 2016fcc:	10800d83 	ldbu	r2,54(r2)
 2016fd0:	0084303a 	nor	r2,zero,r2
 2016fd4:	1007883a 	mov	r3,r2
 2016fd8:	d0a07d03 	ldbu	r2,-32268(gp)
 2016fdc:	1884703a 	and	r2,r3,r2
 2016fe0:	d0a07d05 	stb	r2,-32268(gp)
    }
}
 2016fe4:	e037883a 	mov	sp,fp
 2016fe8:	df000017 	ldw	fp,0(sp)
 2016fec:	dec00104 	addi	sp,sp,4
 2016ff0:	f800283a 	ret

02016ff4 <OS_EventTaskRemove>:
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventTaskRemove (OS_TCB   *ptcb,
                          OS_EVENT *pevent)
{
 2016ff4:	defffc04 	addi	sp,sp,-16
 2016ff8:	df000315 	stw	fp,12(sp)
 2016ffc:	df000304 	addi	fp,sp,12
 2017000:	e13ffe15 	stw	r4,-8(fp)
 2017004:	e17fff15 	stw	r5,-4(fp)
    INT8U  y;


    y                       =  ptcb->OSTCBY;
 2017008:	e0bffe17 	ldw	r2,-8(fp)
 201700c:	10800d03 	ldbu	r2,52(r2)
 2017010:	e0bffd05 	stb	r2,-12(fp)
    pevent->OSEventTbl[y]  &= ~ptcb->OSTCBBitX;         /* Remove task from wait list                  */
 2017014:	e0bffd03 	ldbu	r2,-12(fp)
 2017018:	e0fffd03 	ldbu	r3,-12(fp)
 201701c:	e13fff17 	ldw	r4,-4(fp)
 2017020:	20c7883a 	add	r3,r4,r3
 2017024:	18c00204 	addi	r3,r3,8
 2017028:	18c000c3 	ldbu	r3,3(r3)
 201702c:	1809883a 	mov	r4,r3
 2017030:	e0fffe17 	ldw	r3,-8(fp)
 2017034:	18c00d43 	ldbu	r3,53(r3)
 2017038:	00c6303a 	nor	r3,zero,r3
 201703c:	20c6703a 	and	r3,r4,r3
 2017040:	e13fff17 	ldw	r4,-4(fp)
 2017044:	2085883a 	add	r2,r4,r2
 2017048:	10800204 	addi	r2,r2,8
 201704c:	10c000c5 	stb	r3,3(r2)
    if (pevent->OSEventTbl[y] == 0) {
 2017050:	e0bffd03 	ldbu	r2,-12(fp)
 2017054:	e0ffff17 	ldw	r3,-4(fp)
 2017058:	1885883a 	add	r2,r3,r2
 201705c:	10800204 	addi	r2,r2,8
 2017060:	108000c3 	ldbu	r2,3(r2)
 2017064:	10803fcc 	andi	r2,r2,255
 2017068:	10000a1e 	bne	r2,zero,2017094 <OS_EventTaskRemove+0xa0>
        pevent->OSEventGrp &= ~ptcb->OSTCBBitY;
 201706c:	e0bfff17 	ldw	r2,-4(fp)
 2017070:	10800283 	ldbu	r2,10(r2)
 2017074:	1007883a 	mov	r3,r2
 2017078:	e0bffe17 	ldw	r2,-8(fp)
 201707c:	10800d83 	ldbu	r2,54(r2)
 2017080:	0084303a 	nor	r2,zero,r2
 2017084:	1884703a 	and	r2,r3,r2
 2017088:	1007883a 	mov	r3,r2
 201708c:	e0bfff17 	ldw	r2,-4(fp)
 2017090:	10c00285 	stb	r3,10(r2)
    }
}
 2017094:	e037883a 	mov	sp,fp
 2017098:	df000017 	ldw	fp,0(sp)
 201709c:	dec00104 	addi	sp,sp,4
 20170a0:	f800283a 	ret

020170a4 <OS_EventTaskRemoveMulti>:
*********************************************************************************************************
*/
#if ((OS_EVENT_EN) && (OS_EVENT_MULTI_EN > 0))
void  OS_EventTaskRemoveMulti (OS_TCB    *ptcb,
                               OS_EVENT **pevents_multi)
{
 20170a4:	defffa04 	addi	sp,sp,-24
 20170a8:	df000515 	stw	fp,20(sp)
 20170ac:	df000504 	addi	fp,sp,20
 20170b0:	e13ffe15 	stw	r4,-8(fp)
 20170b4:	e17fff15 	stw	r5,-4(fp)
    INT16U     bity;
    INT16U     bitx;
#endif


    y       =  ptcb->OSTCBY;
 20170b8:	e0bffe17 	ldw	r2,-8(fp)
 20170bc:	10800d03 	ldbu	r2,52(r2)
 20170c0:	e0bffd05 	stb	r2,-12(fp)
    bity    =  ptcb->OSTCBBitY;
 20170c4:	e0bffe17 	ldw	r2,-8(fp)
 20170c8:	10800d83 	ldbu	r2,54(r2)
 20170cc:	e0bffd45 	stb	r2,-11(fp)
    bitx    =  ptcb->OSTCBBitX;
 20170d0:	e0bffe17 	ldw	r2,-8(fp)
 20170d4:	10800d43 	ldbu	r2,53(r2)
 20170d8:	e0bffd85 	stb	r2,-10(fp)
    pevents =  pevents_multi;
 20170dc:	e0bfff17 	ldw	r2,-4(fp)
 20170e0:	e0bffb15 	stw	r2,-20(fp)
    pevent  = *pevents;
 20170e4:	e0bffb17 	ldw	r2,-20(fp)
 20170e8:	10800017 	ldw	r2,0(r2)
 20170ec:	e0bffc15 	stw	r2,-16(fp)
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 20170f0:	00002406 	br	2017184 <OS_EventTaskRemoveMulti+0xe0>
        pevent->OSEventTbl[y]  &= ~bitx;
 20170f4:	e0bffd03 	ldbu	r2,-12(fp)
 20170f8:	e0fffd03 	ldbu	r3,-12(fp)
 20170fc:	e13ffc17 	ldw	r4,-16(fp)
 2017100:	20c7883a 	add	r3,r4,r3
 2017104:	18c00204 	addi	r3,r3,8
 2017108:	18c000c3 	ldbu	r3,3(r3)
 201710c:	1809883a 	mov	r4,r3
 2017110:	e0fffd83 	ldbu	r3,-10(fp)
 2017114:	00c6303a 	nor	r3,zero,r3
 2017118:	20c6703a 	and	r3,r4,r3
 201711c:	e13ffc17 	ldw	r4,-16(fp)
 2017120:	2085883a 	add	r2,r4,r2
 2017124:	10800204 	addi	r2,r2,8
 2017128:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y] == 0) {
 201712c:	e0bffd03 	ldbu	r2,-12(fp)
 2017130:	e0fffc17 	ldw	r3,-16(fp)
 2017134:	1885883a 	add	r2,r3,r2
 2017138:	10800204 	addi	r2,r2,8
 201713c:	108000c3 	ldbu	r2,3(r2)
 2017140:	10803fcc 	andi	r2,r2,255
 2017144:	1000091e 	bne	r2,zero,201716c <OS_EventTaskRemoveMulti+0xc8>
            pevent->OSEventGrp &= ~bity;
 2017148:	e0bffc17 	ldw	r2,-16(fp)
 201714c:	10800283 	ldbu	r2,10(r2)
 2017150:	1007883a 	mov	r3,r2
 2017154:	e0bffd43 	ldbu	r2,-11(fp)
 2017158:	0084303a 	nor	r2,zero,r2
 201715c:	1884703a 	and	r2,r3,r2
 2017160:	1007883a 	mov	r3,r2
 2017164:	e0bffc17 	ldw	r2,-16(fp)
 2017168:	10c00285 	stb	r3,10(r2)
        }
        pevents++;
 201716c:	e0bffb17 	ldw	r2,-20(fp)
 2017170:	10800104 	addi	r2,r2,4
 2017174:	e0bffb15 	stw	r2,-20(fp)
        pevent = *pevents;
 2017178:	e0bffb17 	ldw	r2,-20(fp)
 201717c:	10800017 	ldw	r2,0(r2)
 2017180:	e0bffc15 	stw	r2,-16(fp)
    y       =  ptcb->OSTCBY;
    bity    =  ptcb->OSTCBBitY;
    bitx    =  ptcb->OSTCBBitX;
    pevents =  pevents_multi;
    pevent  = *pevents;
    while (pevent != (OS_EVENT *)0) {                   /* Remove task from all events' wait lists     */
 2017184:	e0bffc17 	ldw	r2,-16(fp)
 2017188:	103fda1e 	bne	r2,zero,20170f4 <OS_EventTaskRemoveMulti+0x50>
            pevent->OSEventGrp &= ~bity;
        }
        pevents++;
        pevent = *pevents;
    }
}
 201718c:	e037883a 	mov	sp,fp
 2017190:	df000017 	ldw	fp,0(sp)
 2017194:	dec00104 	addi	sp,sp,4
 2017198:	f800283a 	ret

0201719c <OS_EventWaitListInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/
#if (OS_EVENT_EN)
void  OS_EventWaitListInit (OS_EVENT *pevent)
{
 201719c:	defffc04 	addi	sp,sp,-16
 20171a0:	df000315 	stw	fp,12(sp)
 20171a4:	df000304 	addi	fp,sp,12
 20171a8:	e13fff15 	stw	r4,-4(fp)
    INT16U *ptbl;
#endif
    INT8U   i;


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
 20171ac:	e0bfff17 	ldw	r2,-4(fp)
 20171b0:	10000285 	stb	zero,10(r2)
    ptbl               = &pevent->OSEventTbl[0];
 20171b4:	e0bfff17 	ldw	r2,-4(fp)
 20171b8:	108002c4 	addi	r2,r2,11
 20171bc:	e0bffd15 	stw	r2,-12(fp)

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 20171c0:	e03ffe05 	stb	zero,-8(fp)
 20171c4:	00000806 	br	20171e8 <OS_EventWaitListInit+0x4c>
        *ptbl++ = 0;
 20171c8:	e0bffd17 	ldw	r2,-12(fp)
 20171cc:	10000005 	stb	zero,0(r2)
 20171d0:	e0bffd17 	ldw	r2,-12(fp)
 20171d4:	10800044 	addi	r2,r2,1
 20171d8:	e0bffd15 	stw	r2,-12(fp)


    pevent->OSEventGrp = 0;                      /* No task waiting on event                           */
    ptbl               = &pevent->OSEventTbl[0];

    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 20171dc:	e0bffe03 	ldbu	r2,-8(fp)
 20171e0:	10800044 	addi	r2,r2,1
 20171e4:	e0bffe05 	stb	r2,-8(fp)
 20171e8:	e0bffe03 	ldbu	r2,-8(fp)
 20171ec:	108000f0 	cmpltui	r2,r2,3
 20171f0:	103ff51e 	bne	r2,zero,20171c8 <OS_EventWaitListInit+0x2c>
        *ptbl++ = 0;
    }
}
 20171f4:	e037883a 	mov	sp,fp
 20171f8:	df000017 	ldw	fp,0(sp)
 20171fc:	dec00104 	addi	sp,sp,4
 2017200:	f800283a 	ret

02017204 <OS_InitEventList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitEventList (void)
{
 2017204:	defffb04 	addi	sp,sp,-20
 2017208:	dfc00415 	stw	ra,16(sp)
 201720c:	df000315 	stw	fp,12(sp)
 2017210:	df000304 	addi	fp,sp,12
    INT16U     i;
    OS_EVENT  *pevent1;
    OS_EVENT  *pevent2;


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
 2017214:	01009934 	movhi	r4,612
 2017218:	21304304 	addi	r4,r4,-16116
 201721c:	0142d004 	movi	r5,2880
 2017220:	20175680 	call	2017568 <OS_MemClr>
    pevent1 = &OSEventTbl[0];
 2017224:	00809934 	movhi	r2,612
 2017228:	10b04304 	addi	r2,r2,-16116
 201722c:	e0bffe15 	stw	r2,-8(fp)
    pevent2 = &OSEventTbl[1];
 2017230:	00809934 	movhi	r2,612
 2017234:	10b04f04 	addi	r2,r2,-16068
 2017238:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 201723c:	e03ffd0d 	sth	zero,-12(fp)
 2017240:	00001306 	br	2017290 <OS_InitEventList+0x8c>
        pevent1->OSEventType    = OS_EVENT_TYPE_UNUSED;
 2017244:	e0bffe17 	ldw	r2,-8(fp)
 2017248:	10000005 	stb	zero,0(r2)
        pevent1->OSEventPtr     = pevent2;
 201724c:	e0bffe17 	ldw	r2,-8(fp)
 2017250:	e0ffff17 	ldw	r3,-4(fp)
 2017254:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent1->OSEventName[0] = '?';                      /* Unknown name                            */
 2017258:	e0bffe17 	ldw	r2,-8(fp)
 201725c:	00c00fc4 	movi	r3,63
 2017260:	10c00385 	stb	r3,14(r2)
        pevent1->OSEventName[1] = OS_ASCII_NUL;
 2017264:	e0bffe17 	ldw	r2,-8(fp)
 2017268:	100003c5 	stb	zero,15(r2)
#endif
        pevent1++;
 201726c:	e0bffe17 	ldw	r2,-8(fp)
 2017270:	10800c04 	addi	r2,r2,48
 2017274:	e0bffe15 	stw	r2,-8(fp)
        pevent2++;
 2017278:	e0bfff17 	ldw	r2,-4(fp)
 201727c:	10800c04 	addi	r2,r2,48
 2017280:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSEventTbl[0], sizeof(OSEventTbl)); /* Clear the event table                   */
    pevent1 = &OSEventTbl[0];
    pevent2 = &OSEventTbl[1];
    for (i = 0; i < (OS_MAX_EVENTS - 1); i++) {             /* Init. list of free EVENT control blocks */
 2017284:	e0bffd0b 	ldhu	r2,-12(fp)
 2017288:	10800044 	addi	r2,r2,1
 201728c:	e0bffd0d 	sth	r2,-12(fp)
 2017290:	e0bffd0b 	ldhu	r2,-12(fp)
 2017294:	10800ef0 	cmpltui	r2,r2,59
 2017298:	103fea1e 	bne	r2,zero,2017244 <OS_InitEventList+0x40>
        pevent1->OSEventName[1] = OS_ASCII_NUL;
#endif
        pevent1++;
        pevent2++;
    }
    pevent1->OSEventType            = OS_EVENT_TYPE_UNUSED;
 201729c:	e0bffe17 	ldw	r2,-8(fp)
 20172a0:	10000005 	stb	zero,0(r2)
    pevent1->OSEventPtr             = (OS_EVENT *)0;
 20172a4:	e0bffe17 	ldw	r2,-8(fp)
 20172a8:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
    pevent1->OSEventName[0]         = '?';
 20172ac:	e0bffe17 	ldw	r2,-8(fp)
 20172b0:	00c00fc4 	movi	r3,63
 20172b4:	10c00385 	stb	r3,14(r2)
    pevent1->OSEventName[1]         = OS_ASCII_NUL;
 20172b8:	e0bffe17 	ldw	r2,-8(fp)
 20172bc:	100003c5 	stb	zero,15(r2)
#endif
    OSEventFreeList                 = &OSEventTbl[0];
 20172c0:	00809934 	movhi	r2,612
 20172c4:	10b04304 	addi	r2,r2,-16116
 20172c8:	d0a07e15 	stw	r2,-32264(gp)
    OSEventFreeList->OSEventName[0] = '?';                  /* Unknown name                            */
    OSEventFreeList->OSEventName[1] = OS_ASCII_NUL;
#endif
#endif
#endif
}
 20172cc:	e037883a 	mov	sp,fp
 20172d0:	dfc00117 	ldw	ra,4(sp)
 20172d4:	df000017 	ldw	fp,0(sp)
 20172d8:	dec00204 	addi	sp,sp,8
 20172dc:	f800283a 	ret

020172e0 <OS_InitMisc>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitMisc (void)
{
 20172e0:	deffff04 	addi	sp,sp,-4
 20172e4:	df000015 	stw	fp,0(sp)
 20172e8:	d839883a 	mov	fp,sp
#if OS_TIME_GET_SET_EN > 0
    OSTime        = 0L;                                    /* Clear the 32-bit system clock            */
 20172ec:	d0208115 	stw	zero,-32252(gp)
#endif

    OSIntNesting  = 0;                                     /* Clear the interrupt nesting counter      */
 20172f0:	d0207f05 	stb	zero,-32260(gp)
    OSLockNesting = 0;                                     /* Clear the scheduling lock counter        */
 20172f4:	d0207105 	stb	zero,-32316(gp)

    OSTaskCtr     = 0;                                     /* Clear the number of tasks                */
 20172f8:	d0207945 	stb	zero,-32283(gp)

    OSRunning     = OS_FALSE;                              /* Indicate that multitasking not started   */
 20172fc:	d0207145 	stb	zero,-32315(gp)

    OSCtxSwCtr    = 0;                                     /* Clear the context switch counter         */
 2017300:	d0207615 	stw	zero,-32296(gp)
    OSIdleCtr     = 0L;                                    /* Clear the 32-bit idle counter            */
 2017304:	d0207215 	stw	zero,-32312(gp)

#if OS_TASK_STAT_EN > 0
    OSIdleCtrRun  = 0L;
 2017308:	d0208415 	stw	zero,-32240(gp)
    OSIdleCtrMax  = 0L;
 201730c:	d0207715 	stw	zero,-32292(gp)
    OSStatRdy     = OS_FALSE;                              /* Statistic task is not ready              */
 2017310:	d0208305 	stb	zero,-32244(gp)
#endif
}
 2017314:	e037883a 	mov	sp,fp
 2017318:	df000017 	ldw	fp,0(sp)
 201731c:	dec00104 	addi	sp,sp,4
 2017320:	f800283a 	ret

02017324 <OS_InitRdyList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitRdyList (void)
{
 2017324:	defffd04 	addi	sp,sp,-12
 2017328:	df000215 	stw	fp,8(sp)
 201732c:	df000204 	addi	fp,sp,8
#else
    INT16U  *prdytbl;
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
 2017330:	d0207d05 	stb	zero,-32268(gp)
    prdytbl       = &OSRdyTbl[0];
 2017334:	d0a07d44 	addi	r2,gp,-32267
 2017338:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 201733c:	e03ffe05 	stb	zero,-8(fp)
 2017340:	00000806 	br	2017364 <OS_InitRdyList+0x40>
        *prdytbl++ = 0;
 2017344:	e0bfff17 	ldw	r2,-4(fp)
 2017348:	10000005 	stb	zero,0(r2)
 201734c:	e0bfff17 	ldw	r2,-4(fp)
 2017350:	10800044 	addi	r2,r2,1
 2017354:	e0bfff15 	stw	r2,-4(fp)
#endif


    OSRdyGrp      = 0;                                     /* Clear the ready list                     */
    prdytbl       = &OSRdyTbl[0];
    for (i = 0; i < OS_RDY_TBL_SIZE; i++) {
 2017358:	e0bffe03 	ldbu	r2,-8(fp)
 201735c:	10800044 	addi	r2,r2,1
 2017360:	e0bffe05 	stb	r2,-8(fp)
 2017364:	e0bffe03 	ldbu	r2,-8(fp)
 2017368:	108000f0 	cmpltui	r2,r2,3
 201736c:	103ff51e 	bne	r2,zero,2017344 <OS_InitRdyList+0x20>
        *prdytbl++ = 0;
    }

    OSPrioCur     = 0;
 2017370:	d0207345 	stb	zero,-32307(gp)
    OSPrioHighRdy = 0;
 2017374:	d0207305 	stb	zero,-32308(gp)

    OSTCBHighRdy  = (OS_TCB *)0;
 2017378:	d0207b15 	stw	zero,-32276(gp)
    OSTCBCur      = (OS_TCB *)0;
 201737c:	d0208015 	stw	zero,-32256(gp)
}
 2017380:	e037883a 	mov	sp,fp
 2017384:	df000017 	ldw	fp,0(sp)
 2017388:	dec00104 	addi	sp,sp,4
 201738c:	f800283a 	ret

02017390 <OS_InitTaskIdle>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTaskIdle (void)
{
 2017390:	defff804 	addi	sp,sp,-32
 2017394:	dfc00715 	stw	ra,28(sp)
 2017398:	df000615 	stw	fp,24(sp)
 201739c:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskIdle,
 20173a0:	00bfffd4 	movui	r2,65535
 20173a4:	d8800015 	stw	r2,0(sp)
 20173a8:	00809934 	movhi	r2,612
 20173ac:	10ae4304 	addi	r2,r2,-18164
 20173b0:	d8800115 	stw	r2,4(sp)
 20173b4:	00808004 	movi	r2,512
 20173b8:	d8800215 	stw	r2,8(sp)
 20173bc:	d8000315 	stw	zero,12(sp)
 20173c0:	008000c4 	movi	r2,3
 20173c4:	d8800415 	stw	r2,16(sp)
 20173c8:	01008074 	movhi	r4,513
 20173cc:	211e0d04 	addi	r4,r4,30772
 20173d0:	000b883a 	mov	r5,zero
 20173d4:	01809934 	movhi	r6,612
 20173d8:	31b04204 	addi	r6,r6,-16120
 20173dc:	01c00504 	movi	r7,20
 20173e0:	201ce040 	call	201ce04 <OSTaskCreateExt>
                       OS_TASK_IDLE_PRIO);
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"uC/OS-II Idle", &err);
 20173e4:	01000504 	movi	r4,20
 20173e8:	01408174 	movhi	r5,517
 20173ec:	2978a204 	addi	r5,r5,-7544
 20173f0:	e1bfff04 	addi	r6,fp,-4
 20173f4:	201d6d40 	call	201d6d4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_IDLE_PRIO, (INT8U *)"OS-Idle", &err);
#endif
#endif
}
 20173f8:	e037883a 	mov	sp,fp
 20173fc:	dfc00117 	ldw	ra,4(sp)
 2017400:	df000017 	ldw	fp,0(sp)
 2017404:	dec00204 	addi	sp,sp,8
 2017408:	f800283a 	ret

0201740c <OS_InitTaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
static  void  OS_InitTaskStat (void)
{
 201740c:	defff804 	addi	sp,sp,-32
 2017410:	dfc00715 	stw	ra,28(sp)
 2017414:	df000615 	stw	fp,24(sp)
 2017418:	df000604 	addi	fp,sp,24
#endif


#if OS_TASK_CREATE_EXT_EN > 0
    #if OS_STK_GROWTH == 1
    (void)OSTaskCreateExt(OS_TaskStat,
 201741c:	00bfff94 	movui	r2,65534
 2017420:	d8800015 	stw	r2,0(sp)
 2017424:	00809934 	movhi	r2,612
 2017428:	10abcb04 	addi	r2,r2,-20692
 201742c:	d8800115 	stw	r2,4(sp)
 2017430:	00808004 	movi	r2,512
 2017434:	d8800215 	stw	r2,8(sp)
 2017438:	d8000315 	stw	zero,12(sp)
 201743c:	008000c4 	movi	r2,3
 2017440:	d8800415 	stw	r2,16(sp)
 2017444:	01008074 	movhi	r4,513
 2017448:	211e2404 	addi	r4,r4,30864
 201744c:	000b883a 	mov	r5,zero
 2017450:	01809934 	movhi	r6,612
 2017454:	31adca04 	addi	r6,r6,-18648
 2017458:	01c004c4 	movi	r7,19
 201745c:	201ce040 	call	201ce04 <OSTaskCreateExt>
                       OS_TASK_STAT_PRIO);                             /* One higher than the idle task  */
    #endif
#endif

#if OS_TASK_NAME_SIZE > 14
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"uC/OS-II Stat", &err);
 2017460:	010004c4 	movi	r4,19
 2017464:	01408174 	movhi	r5,517
 2017468:	2978a604 	addi	r5,r5,-7528
 201746c:	e1bfff04 	addi	r6,fp,-4
 2017470:	201d6d40 	call	201d6d4 <OSTaskNameSet>
#else
#if OS_TASK_NAME_SIZE > 7
    OSTaskNameSet(OS_TASK_STAT_PRIO, (INT8U *)"OS-Stat", &err);
#endif
#endif
}
 2017474:	e037883a 	mov	sp,fp
 2017478:	dfc00117 	ldw	ra,4(sp)
 201747c:	df000017 	ldw	fp,0(sp)
 2017480:	dec00204 	addi	sp,sp,8
 2017484:	f800283a 	ret

02017488 <OS_InitTCBList>:
* Returns    : none
*********************************************************************************************************
*/

static  void  OS_InitTCBList (void)
{
 2017488:	defffb04 	addi	sp,sp,-20
 201748c:	dfc00415 	stw	ra,16(sp)
 2017490:	df000315 	stw	fp,12(sp)
 2017494:	df000304 	addi	fp,sp,12
    INT8U    i;
    OS_TCB  *ptcb1;
    OS_TCB  *ptcb2;


    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
 2017498:	01009934 	movhi	r4,612
 201749c:	21331304 	addi	r4,r4,-13236
 20174a0:	01414404 	movi	r5,1296
 20174a4:	20175680 	call	2017568 <OS_MemClr>
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
 20174a8:	01009934 	movhi	r4,612
 20174ac:	21345704 	addi	r4,r4,-11940
 20174b0:	01401504 	movi	r5,84
 20174b4:	20175680 	call	2017568 <OS_MemClr>
    ptcb1 = &OSTCBTbl[0];
 20174b8:	00809934 	movhi	r2,612
 20174bc:	10b31304 	addi	r2,r2,-13236
 20174c0:	e0bffe15 	stw	r2,-8(fp)
    ptcb2 = &OSTCBTbl[1];
 20174c4:	00809934 	movhi	r2,612
 20174c8:	10b32e04 	addi	r2,r2,-13128
 20174cc:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 20174d0:	e03ffd05 	stb	zero,-12(fp)
 20174d4:	00001106 	br	201751c <OS_InitTCBList+0x94>
        ptcb1->OSTCBNext = ptcb2;
 20174d8:	e0bffe17 	ldw	r2,-8(fp)
 20174dc:	e0ffff17 	ldw	r3,-4(fp)
 20174e0:	10c00515 	stw	r3,20(r2)
#if OS_TASK_NAME_SIZE > 1
        ptcb1->OSTCBTaskName[0] = '?';                           /* Unknown name                       */
 20174e4:	e0bffe17 	ldw	r2,-8(fp)
 20174e8:	00c00fc4 	movi	r3,63
 20174ec:	10c01305 	stb	r3,76(r2)
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 20174f0:	e0bffe17 	ldw	r2,-8(fp)
 20174f4:	10001345 	stb	zero,77(r2)
#endif
        ptcb1++;
 20174f8:	e0bffe17 	ldw	r2,-8(fp)
 20174fc:	10801b04 	addi	r2,r2,108
 2017500:	e0bffe15 	stw	r2,-8(fp)
        ptcb2++;
 2017504:	e0bfff17 	ldw	r2,-4(fp)
 2017508:	10801b04 	addi	r2,r2,108
 201750c:	e0bfff15 	stw	r2,-4(fp)

    OS_MemClr((INT8U *)&OSTCBTbl[0],     sizeof(OSTCBTbl));      /* Clear all the TCBs                 */
    OS_MemClr((INT8U *)&OSTCBPrioTbl[0], sizeof(OSTCBPrioTbl));  /* Clear the priority table           */
    ptcb1 = &OSTCBTbl[0];
    ptcb2 = &OSTCBTbl[1];
    for (i = 0; i < (OS_MAX_TASKS + OS_N_SYS_TASKS - 1); i++) {  /* Init. list of free TCBs            */
 2017510:	e0bffd03 	ldbu	r2,-12(fp)
 2017514:	10800044 	addi	r2,r2,1
 2017518:	e0bffd05 	stb	r2,-12(fp)
 201751c:	e0bffd03 	ldbu	r2,-12(fp)
 2017520:	108002f0 	cmpltui	r2,r2,11
 2017524:	103fec1e 	bne	r2,zero,20174d8 <OS_InitTCBList+0x50>
        ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
#endif
        ptcb1++;
        ptcb2++;
    }
    ptcb1->OSTCBNext = (OS_TCB *)0;                              /* Last OS_TCB                        */
 2017528:	e0bffe17 	ldw	r2,-8(fp)
 201752c:	10000515 	stw	zero,20(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb1->OSTCBTaskName[0] = '?';                               /* Unknown name                       */
 2017530:	e0bffe17 	ldw	r2,-8(fp)
 2017534:	00c00fc4 	movi	r3,63
 2017538:	10c01305 	stb	r3,76(r2)
    ptcb1->OSTCBTaskName[1] = OS_ASCII_NUL;
 201753c:	e0bffe17 	ldw	r2,-8(fp)
 2017540:	10001345 	stb	zero,77(r2)
#endif
    OSTCBList               = (OS_TCB *)0;                       /* TCB lists initializations          */
 2017544:	d0207415 	stw	zero,-32304(gp)
    OSTCBFreeList           = &OSTCBTbl[0];
 2017548:	00809934 	movhi	r2,612
 201754c:	10b31304 	addi	r2,r2,-13236
 2017550:	d0a07815 	stw	r2,-32288(gp)
}
 2017554:	e037883a 	mov	sp,fp
 2017558:	dfc00117 	ldw	ra,4(sp)
 201755c:	df000017 	ldw	fp,0(sp)
 2017560:	dec00204 	addi	sp,sp,8
 2017564:	f800283a 	ret

02017568 <OS_MemClr>:
*                 of the alignment of the destination.
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
 2017568:	defffd04 	addi	sp,sp,-12
 201756c:	df000215 	stw	fp,8(sp)
 2017570:	df000204 	addi	fp,sp,8
 2017574:	e13ffe15 	stw	r4,-8(fp)
 2017578:	2805883a 	mov	r2,r5
 201757c:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 2017580:	00000806 	br	20175a4 <OS_MemClr+0x3c>
        *pdest++ = (INT8U)0;
 2017584:	e0bffe17 	ldw	r2,-8(fp)
 2017588:	10000005 	stb	zero,0(r2)
 201758c:	e0bffe17 	ldw	r2,-8(fp)
 2017590:	10800044 	addi	r2,r2,1
 2017594:	e0bffe15 	stw	r2,-8(fp)
        size--;
 2017598:	e0bfff0b 	ldhu	r2,-4(fp)
 201759c:	10bfffc4 	addi	r2,r2,-1
 20175a0:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemClr (INT8U *pdest, INT16U size)
{
    while (size > 0) {
 20175a4:	e0bfff0b 	ldhu	r2,-4(fp)
 20175a8:	103ff61e 	bne	r2,zero,2017584 <OS_MemClr+0x1c>
        *pdest++ = (INT8U)0;
        size--;
    }
}
 20175ac:	e037883a 	mov	sp,fp
 20175b0:	df000017 	ldw	fp,0(sp)
 20175b4:	dec00104 	addi	sp,sp,4
 20175b8:	f800283a 	ret

020175bc <OS_MemCopy>:
*                 of the alignment of the source and destination.
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
 20175bc:	defffc04 	addi	sp,sp,-16
 20175c0:	df000315 	stw	fp,12(sp)
 20175c4:	df000304 	addi	fp,sp,12
 20175c8:	e13ffd15 	stw	r4,-12(fp)
 20175cc:	e17ffe15 	stw	r5,-8(fp)
 20175d0:	3005883a 	mov	r2,r6
 20175d4:	e0bfff0d 	sth	r2,-4(fp)
    while (size > 0) {
 20175d8:	00000d06 	br	2017610 <OS_MemCopy+0x54>
        *pdest++ = *psrc++;
 20175dc:	e0bffe17 	ldw	r2,-8(fp)
 20175e0:	10c00003 	ldbu	r3,0(r2)
 20175e4:	e0bffd17 	ldw	r2,-12(fp)
 20175e8:	10c00005 	stb	r3,0(r2)
 20175ec:	e0bffd17 	ldw	r2,-12(fp)
 20175f0:	10800044 	addi	r2,r2,1
 20175f4:	e0bffd15 	stw	r2,-12(fp)
 20175f8:	e0bffe17 	ldw	r2,-8(fp)
 20175fc:	10800044 	addi	r2,r2,1
 2017600:	e0bffe15 	stw	r2,-8(fp)
        size--;
 2017604:	e0bfff0b 	ldhu	r2,-4(fp)
 2017608:	10bfffc4 	addi	r2,r2,-1
 201760c:	e0bfff0d 	sth	r2,-4(fp)
*********************************************************************************************************
*/

void  OS_MemCopy (INT8U *pdest, INT8U *psrc, INT16U size)
{
    while (size > 0) {
 2017610:	e0bfff0b 	ldhu	r2,-4(fp)
 2017614:	103ff11e 	bne	r2,zero,20175dc <OS_MemCopy+0x20>
        *pdest++ = *psrc++;
        size--;
    }
}
 2017618:	e037883a 	mov	sp,fp
 201761c:	df000017 	ldw	fp,0(sp)
 2017620:	dec00104 	addi	sp,sp,4
 2017624:	f800283a 	ret

02017628 <OS_Sched>:
*              2) Rescheduling is prevented when the scheduler is locked (see OS_SchedLock())
*********************************************************************************************************
*/

void  OS_Sched (void)
{
 2017628:	defffb04 	addi	sp,sp,-20
 201762c:	dfc00415 	stw	ra,16(sp)
 2017630:	df000315 	stw	fp,12(sp)
 2017634:	df000304 	addi	fp,sp,12
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 2017638:	e03ffd15 	stw	zero,-12(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201763c:	0005303a 	rdctl	r2,status
 2017640:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017644:	e0fffe17 	ldw	r3,-8(fp)
 2017648:	00bfff84 	movi	r2,-2
 201764c:	1884703a 	and	r2,r3,r2
 2017650:	1001703a 	wrctl	status,r2
  
  return context;
 2017654:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 2017658:	e0bffd15 	stw	r2,-12(fp)
    if (OSIntNesting == 0) {                           /* Schedule only if all ISRs done and ...       */
 201765c:	d0a07f03 	ldbu	r2,-32260(gp)
 2017660:	10803fcc 	andi	r2,r2,255
 2017664:	10001a1e 	bne	r2,zero,20176d0 <OS_Sched+0xa8>
        if (OSLockNesting == 0) {                      /* ... scheduler is not locked                  */
 2017668:	d0a07103 	ldbu	r2,-32316(gp)
 201766c:	10803fcc 	andi	r2,r2,255
 2017670:	1000171e 	bne	r2,zero,20176d0 <OS_Sched+0xa8>
            OS_SchedNew();
 2017674:	20176f40 	call	20176f4 <OS_SchedNew>
            if (OSPrioHighRdy != OSPrioCur) {          /* No Ctx Sw if current task is highest rdy     */
 2017678:	d0e07303 	ldbu	r3,-32308(gp)
 201767c:	d0a07343 	ldbu	r2,-32307(gp)
 2017680:	18c03fcc 	andi	r3,r3,255
 2017684:	10803fcc 	andi	r2,r2,255
 2017688:	18801126 	beq	r3,r2,20176d0 <OS_Sched+0xa8>
                OSTCBHighRdy = OSTCBPrioTbl[OSPrioHighRdy];
 201768c:	d0a07303 	ldbu	r2,-32308(gp)
 2017690:	10803fcc 	andi	r2,r2,255
 2017694:	00c09934 	movhi	r3,612
 2017698:	18f45704 	addi	r3,r3,-11940
 201769c:	1085883a 	add	r2,r2,r2
 20176a0:	1085883a 	add	r2,r2,r2
 20176a4:	1885883a 	add	r2,r3,r2
 20176a8:	10800017 	ldw	r2,0(r2)
 20176ac:	d0a07b15 	stw	r2,-32276(gp)
#if OS_TASK_PROFILE_EN > 0
                OSTCBHighRdy->OSTCBCtxSwCtr++;         /* Inc. # of context switches to this task      */
 20176b0:	d0a07b17 	ldw	r2,-32276(gp)
 20176b4:	10c00e17 	ldw	r3,56(r2)
 20176b8:	18c00044 	addi	r3,r3,1
 20176bc:	10c00e15 	stw	r3,56(r2)
#endif
                OSCtxSwCtr++;                          /* Increment context switch counter             */
 20176c0:	d0a07617 	ldw	r2,-32296(gp)
 20176c4:	10800044 	addi	r2,r2,1
 20176c8:	d0a07615 	stw	r2,-32296(gp)
                OS_TASK_SW();                          /* Perform a context switch                     */
 20176cc:	2037b040 	call	2037b04 <OSCtxSw>
 20176d0:	e0bffd17 	ldw	r2,-12(fp)
 20176d4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20176d8:	e0bfff17 	ldw	r2,-4(fp)
 20176dc:	1001703a 	wrctl	status,r2
            }
        }
    }
    OS_EXIT_CRITICAL();
}
 20176e0:	e037883a 	mov	sp,fp
 20176e4:	dfc00117 	ldw	ra,4(sp)
 20176e8:	df000017 	ldw	fp,0(sp)
 20176ec:	dec00204 	addi	sp,sp,8
 20176f0:	f800283a 	ret

020176f4 <OS_SchedNew>:
*              2) Interrupts are assumed to be disabled when this function is called.
*********************************************************************************************************
*/

static  void  OS_SchedNew (void)
{
 20176f4:	defffe04 	addi	sp,sp,-8
 20176f8:	df000115 	stw	fp,4(sp)
 20176fc:	df000104 	addi	fp,sp,4
#if OS_LOWEST_PRIO <= 63                         /* See if we support up to 64 tasks                   */
    INT8U   y;


    y             = OSUnMapTbl[OSRdyGrp];
 2017700:	d0a07d03 	ldbu	r2,-32268(gp)
 2017704:	10803fcc 	andi	r2,r2,255
 2017708:	00c08174 	movhi	r3,517
 201770c:	18f86204 	addi	r3,r3,-7800
 2017710:	1885883a 	add	r2,r3,r2
 2017714:	10800003 	ldbu	r2,0(r2)
 2017718:	e0bfff05 	stb	r2,-4(fp)
    OSPrioHighRdy = (INT8U)((y << 3) + OSUnMapTbl[OSRdyTbl[y]]);
 201771c:	e0bfff03 	ldbu	r2,-4(fp)
 2017720:	100490fa 	slli	r2,r2,3
 2017724:	1007883a 	mov	r3,r2
 2017728:	e13fff03 	ldbu	r4,-4(fp)
 201772c:	d0a07d44 	addi	r2,gp,-32267
 2017730:	2085883a 	add	r2,r4,r2
 2017734:	10800003 	ldbu	r2,0(r2)
 2017738:	10803fcc 	andi	r2,r2,255
 201773c:	01008174 	movhi	r4,517
 2017740:	21386204 	addi	r4,r4,-7800
 2017744:	2085883a 	add	r2,r4,r2
 2017748:	10800003 	ldbu	r2,0(r2)
 201774c:	1885883a 	add	r2,r3,r2
 2017750:	d0a07305 	stb	r2,-32308(gp)
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl & 0xFF)]);
    } else {
        OSPrioHighRdy = (INT8U)((y << 4) + OSUnMapTbl[(*ptbl >> 8) & 0xFF] + 8);
    }
#endif
}
 2017754:	e037883a 	mov	sp,fp
 2017758:	df000017 	ldw	fp,0(sp)
 201775c:	dec00104 	addi	sp,sp,4
 2017760:	f800283a 	ret

02017764 <OS_StrCopy>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrCopy (INT8U *pdest, INT8U *psrc)
{
 2017764:	defffc04 	addi	sp,sp,-16
 2017768:	df000315 	stw	fp,12(sp)
 201776c:	df000304 	addi	fp,sp,12
 2017770:	e13ffe15 	stw	r4,-8(fp)
 2017774:	e17fff15 	stw	r5,-4(fp)
    INT8U  len;


    len = 0;
 2017778:	e03ffd05 	stb	zero,-12(fp)
    while (*psrc != OS_ASCII_NUL) {
 201777c:	00000d06 	br	20177b4 <OS_StrCopy+0x50>
        *pdest++ = *psrc++;
 2017780:	e0bfff17 	ldw	r2,-4(fp)
 2017784:	10c00003 	ldbu	r3,0(r2)
 2017788:	e0bffe17 	ldw	r2,-8(fp)
 201778c:	10c00005 	stb	r3,0(r2)
 2017790:	e0bffe17 	ldw	r2,-8(fp)
 2017794:	10800044 	addi	r2,r2,1
 2017798:	e0bffe15 	stw	r2,-8(fp)
 201779c:	e0bfff17 	ldw	r2,-4(fp)
 20177a0:	10800044 	addi	r2,r2,1
 20177a4:	e0bfff15 	stw	r2,-4(fp)
        len++;
 20177a8:	e0bffd03 	ldbu	r2,-12(fp)
 20177ac:	10800044 	addi	r2,r2,1
 20177b0:	e0bffd05 	stb	r2,-12(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 20177b4:	e0bfff17 	ldw	r2,-4(fp)
 20177b8:	10800003 	ldbu	r2,0(r2)
 20177bc:	10803fcc 	andi	r2,r2,255
 20177c0:	103fef1e 	bne	r2,zero,2017780 <OS_StrCopy+0x1c>
        *pdest++ = *psrc++;
        len++;
    }
    *pdest = OS_ASCII_NUL;
 20177c4:	e0bffe17 	ldw	r2,-8(fp)
 20177c8:	10000005 	stb	zero,0(r2)
    return (len);
 20177cc:	e0bffd03 	ldbu	r2,-12(fp)
}
 20177d0:	e037883a 	mov	sp,fp
 20177d4:	df000017 	ldw	fp,0(sp)
 20177d8:	dec00104 	addi	sp,sp,4
 20177dc:	f800283a 	ret

020177e0 <OS_StrLen>:
*********************************************************************************************************
*/

#if (OS_EVENT_NAME_SIZE > 1) || (OS_FLAG_NAME_SIZE > 1) || (OS_MEM_NAME_SIZE > 1) || (OS_TASK_NAME_SIZE > 1) || (OS_TMR_CFG_NAME_SIZE > 1)
INT8U  OS_StrLen (INT8U *psrc)
{
 20177e0:	defffd04 	addi	sp,sp,-12
 20177e4:	df000215 	stw	fp,8(sp)
 20177e8:	df000204 	addi	fp,sp,8
 20177ec:	e13fff15 	stw	r4,-4(fp)
    INT8U  len;


    len = 0;
 20177f0:	e03ffe05 	stb	zero,-8(fp)
    while (*psrc != OS_ASCII_NUL) {
 20177f4:	00000606 	br	2017810 <OS_StrLen+0x30>
        psrc++;
 20177f8:	e0bfff17 	ldw	r2,-4(fp)
 20177fc:	10800044 	addi	r2,r2,1
 2017800:	e0bfff15 	stw	r2,-4(fp)
        len++;
 2017804:	e0bffe03 	ldbu	r2,-8(fp)
 2017808:	10800044 	addi	r2,r2,1
 201780c:	e0bffe05 	stb	r2,-8(fp)
{
    INT8U  len;


    len = 0;
    while (*psrc != OS_ASCII_NUL) {
 2017810:	e0bfff17 	ldw	r2,-4(fp)
 2017814:	10800003 	ldbu	r2,0(r2)
 2017818:	10803fcc 	andi	r2,r2,255
 201781c:	103ff61e 	bne	r2,zero,20177f8 <OS_StrLen+0x18>
        psrc++;
        len++;
    }
    return (len);
 2017820:	e0bffe03 	ldbu	r2,-8(fp)
}
 2017824:	e037883a 	mov	sp,fp
 2017828:	df000017 	ldw	fp,0(sp)
 201782c:	dec00104 	addi	sp,sp,4
 2017830:	f800283a 	ret

02017834 <OS_TaskIdle>:
*                 power.
*********************************************************************************************************
*/

void  OS_TaskIdle (void *p_arg)
{
 2017834:	defffa04 	addi	sp,sp,-24
 2017838:	dfc00515 	stw	ra,20(sp)
 201783c:	df000415 	stw	fp,16(sp)
 2017840:	df000404 	addi	fp,sp,16
 2017844:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2017848:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201784c:	0005303a 	rdctl	r2,status
 2017850:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017854:	e0fffd17 	ldw	r3,-12(fp)
 2017858:	00bfff84 	movi	r2,-2
 201785c:	1884703a 	and	r2,r3,r2
 2017860:	1001703a 	wrctl	status,r2
  
  return context;
 2017864:	e0bffd17 	ldw	r2,-12(fp)



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    for (;;) {
        OS_ENTER_CRITICAL();
 2017868:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtr++;
 201786c:	d0a07217 	ldw	r2,-32312(gp)
 2017870:	10800044 	addi	r2,r2,1
 2017874:	d0a07215 	stw	r2,-32312(gp)
 2017878:	e0bffc17 	ldw	r2,-16(fp)
 201787c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017880:	e0bffe17 	ldw	r2,-8(fp)
 2017884:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSTaskIdleHook();                        /* Call user definable HOOK                           */
 2017888:	2037fa00 	call	2037fa0 <OSTaskIdleHook>
    }
 201788c:	003fef06 	br	201784c <OS_TaskIdle+0x18>

02017890 <OS_TaskStat>:
*********************************************************************************************************
*/

#if OS_TASK_STAT_EN > 0
void  OS_TaskStat (void *p_arg)
{
 2017890:	defffa04 	addi	sp,sp,-24
 2017894:	dfc00515 	stw	ra,20(sp)
 2017898:	df000415 	stw	fp,16(sp)
 201789c:	df000404 	addi	fp,sp,16
 20178a0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 20178a4:	e03ffc15 	stw	zero,-16(fp)
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 20178a8:	00000206 	br	20178b4 <OS_TaskStat+0x24>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
 20178ac:	01000504 	movi	r4,20
 20178b0:	201e00c0 	call	201e00c <OSTimeDly>
#endif



    (void)p_arg;                                 /* Prevent compiler warning for not using 'p_arg'     */
    while (OSStatRdy == OS_FALSE) {
 20178b4:	d0a08303 	ldbu	r2,-32244(gp)
 20178b8:	10803fcc 	andi	r2,r2,255
 20178bc:	103ffb26 	beq	r2,zero,20178ac <OS_TaskStat+0x1c>
        OSTimeDly(2 * OS_TICKS_PER_SEC / 10);    /* Wait until statistic task is ready                 */
    }
    OSIdleCtrMax /= 100L;
 20178c0:	d0e07717 	ldw	r3,-32292(gp)
 20178c4:	00801904 	movi	r2,100
 20178c8:	1885203a 	divu	r2,r3,r2
 20178cc:	d0a07715 	stw	r2,-32292(gp)
    if (OSIdleCtrMax == 0L) {
 20178d0:	d0a07717 	ldw	r2,-32292(gp)
 20178d4:	1000031e 	bne	r2,zero,20178e4 <OS_TaskStat+0x54>
        OSCPUUsage = 0;
 20178d8:	d0207905 	stb	zero,-32284(gp)
        (void)OSTaskSuspend(OS_PRIO_SELF);
 20178dc:	01003fc4 	movi	r4,255
 20178e0:	201dc600 	call	201dc60 <OSTaskSuspend>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20178e4:	0005303a 	rdctl	r2,status
 20178e8:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20178ec:	e0fffd17 	ldw	r3,-12(fp)
 20178f0:	00bfff84 	movi	r2,-2
 20178f4:	1884703a 	and	r2,r3,r2
 20178f8:	1001703a 	wrctl	status,r2
  
  return context;
 20178fc:	e0bffd17 	ldw	r2,-12(fp)
    }
    for (;;) {
        OS_ENTER_CRITICAL();
 2017900:	e0bffc15 	stw	r2,-16(fp)
        OSIdleCtrRun = OSIdleCtr;                /* Obtain the of the idle counter for the past second */
 2017904:	d0a07217 	ldw	r2,-32312(gp)
 2017908:	d0a08415 	stw	r2,-32240(gp)
        OSIdleCtr    = 0L;                       /* Reset the idle counter for the next second         */
 201790c:	d0207215 	stw	zero,-32312(gp)
 2017910:	e0bffc17 	ldw	r2,-16(fp)
 2017914:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017918:	e0bffe17 	ldw	r2,-8(fp)
 201791c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OSCPUUsage   = (INT8U)(100L - OSIdleCtrRun / OSIdleCtrMax);
 2017920:	d0e08417 	ldw	r3,-32240(gp)
 2017924:	d0a07717 	ldw	r2,-32292(gp)
 2017928:	1885203a 	divu	r2,r3,r2
 201792c:	00c01904 	movi	r3,100
 2017930:	1885c83a 	sub	r2,r3,r2
 2017934:	d0a07905 	stb	r2,-32284(gp)
        OSTaskStatHook();                        /* Invoke user definable hook                         */
 2017938:	2037f240 	call	2037f24 <OSTaskStatHook>
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
        OS_TaskStatStkChk();                     /* Check the stacks for each task                     */
 201793c:	201794c0 	call	201794c <OS_TaskStatStkChk>
#endif
        OSTimeDly(OS_TICKS_PER_SEC / 10);        /* Accumulate OSIdleCtr for the next 1/10 second      */
 2017940:	01000284 	movi	r4,10
 2017944:	201e00c0 	call	201e00c <OSTimeDly>
    }
 2017948:	003fe606 	br	20178e4 <OS_TaskStat+0x54>

0201794c <OS_TaskStatStkChk>:
*********************************************************************************************************
*/

#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStatStkChk (void)
{
 201794c:	defffa04 	addi	sp,sp,-24
 2017950:	dfc00515 	stw	ra,20(sp)
 2017954:	df000415 	stw	fp,16(sp)
 2017958:	df000404 	addi	fp,sp,16
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 201795c:	e03ffc05 	stb	zero,-16(fp)
 2017960:	00002406 	br	20179f4 <OS_TaskStatStkChk+0xa8>
        err = OSTaskStkChk(prio, &stk_data);
 2017964:	e0fffc03 	ldbu	r3,-16(fp)
 2017968:	e0bffe04 	addi	r2,fp,-8
 201796c:	1809883a 	mov	r4,r3
 2017970:	100b883a 	mov	r5,r2
 2017974:	201da8c0 	call	201da8c <OSTaskStkChk>
 2017978:	e0bffc45 	stb	r2,-15(fp)
        if (err == OS_ERR_NONE) {
 201797c:	e0bffc43 	ldbu	r2,-15(fp)
 2017980:	1000191e 	bne	r2,zero,20179e8 <OS_TaskStatStkChk+0x9c>
            ptcb = OSTCBPrioTbl[prio];
 2017984:	e0bffc03 	ldbu	r2,-16(fp)
 2017988:	00c09934 	movhi	r3,612
 201798c:	18f45704 	addi	r3,r3,-11940
 2017990:	1085883a 	add	r2,r2,r2
 2017994:	1085883a 	add	r2,r2,r2
 2017998:	1885883a 	add	r2,r3,r2
 201799c:	10800017 	ldw	r2,0(r2)
 20179a0:	e0bffd15 	stw	r2,-12(fp)
            if (ptcb != (OS_TCB *)0) {                               /* Make sure task 'ptcb' is ...   */
 20179a4:	e0bffd17 	ldw	r2,-12(fp)
 20179a8:	10000f26 	beq	r2,zero,20179e8 <OS_TaskStatStkChk+0x9c>
                if (ptcb != OS_TCB_RESERVED) {                       /* ... still valid.               */
 20179ac:	e0bffd17 	ldw	r2,-12(fp)
 20179b0:	10800060 	cmpeqi	r2,r2,1
 20179b4:	10000c1e 	bne	r2,zero,20179e8 <OS_TaskStatStkChk+0x9c>
#if OS_TASK_PROFILE_EN > 0
                    #if OS_STK_GROWTH == 1
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom + ptcb->OSTCBStkSize;
 20179b8:	e0bffd17 	ldw	r2,-12(fp)
 20179bc:	10c00217 	ldw	r3,8(r2)
 20179c0:	e0bffd17 	ldw	r2,-12(fp)
 20179c4:	10800317 	ldw	r2,12(r2)
 20179c8:	1085883a 	add	r2,r2,r2
 20179cc:	1085883a 	add	r2,r2,r2
 20179d0:	1887883a 	add	r3,r3,r2
 20179d4:	e0bffd17 	ldw	r2,-12(fp)
 20179d8:	10c01115 	stw	r3,68(r2)
                    #else
                    ptcb->OSTCBStkBase = ptcb->OSTCBStkBottom - ptcb->OSTCBStkSize;
                    #endif
                    ptcb->OSTCBStkUsed = stk_data.OSUsed;            /* Store the number of bytes used */
 20179dc:	e0ffff17 	ldw	r3,-4(fp)
 20179e0:	e0bffd17 	ldw	r2,-12(fp)
 20179e4:	10c01215 	stw	r3,72(r2)
    OS_STK_DATA  stk_data;
    INT8U        err;
    INT8U        prio;


    for (prio = 0; prio <= OS_TASK_IDLE_PRIO; prio++) {
 20179e8:	e0bffc03 	ldbu	r2,-16(fp)
 20179ec:	10800044 	addi	r2,r2,1
 20179f0:	e0bffc05 	stb	r2,-16(fp)
 20179f4:	e0bffc03 	ldbu	r2,-16(fp)
 20179f8:	10800570 	cmpltui	r2,r2,21
 20179fc:	103fd91e 	bne	r2,zero,2017964 <OS_TaskStatStkChk+0x18>
#endif
                }
            }
        }
    }
}
 2017a00:	e037883a 	mov	sp,fp
 2017a04:	dfc00117 	ldw	ra,4(sp)
 2017a08:	df000017 	ldw	fp,0(sp)
 2017a0c:	dec00204 	addi	sp,sp,8
 2017a10:	f800283a 	ret

02017a14 <OS_TCBInit>:
* Note       : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

INT8U  OS_TCBInit (INT8U prio, OS_STK *ptos, OS_STK *pbos, INT16U id, INT32U stk_size, void *pext, INT16U opt)
{
 2017a14:	defff204 	addi	sp,sp,-56
 2017a18:	dfc00d15 	stw	ra,52(sp)
 2017a1c:	df000c15 	stw	fp,48(sp)
 2017a20:	df000c04 	addi	fp,sp,48
 2017a24:	2007883a 	mov	r3,r4
 2017a28:	e17ffc15 	stw	r5,-16(fp)
 2017a2c:	e1bffd15 	stw	r6,-12(fp)
 2017a30:	3805883a 	mov	r2,r7
 2017a34:	e1000417 	ldw	r4,16(fp)
 2017a38:	e0fffb05 	stb	r3,-20(fp)
 2017a3c:	e0bffe0d 	sth	r2,-8(fp)
 2017a40:	e13fff0d 	sth	r4,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2017a44:	e03ff415 	stw	zero,-48(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017a48:	0005303a 	rdctl	r2,status
 2017a4c:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017a50:	e0fff617 	ldw	r3,-40(fp)
 2017a54:	00bfff84 	movi	r2,-2
 2017a58:	1884703a 	and	r2,r3,r2
 2017a5c:	1001703a 	wrctl	status,r2
  
  return context;
 2017a60:	e0bff617 	ldw	r2,-40(fp)
#endif



    OS_ENTER_CRITICAL();
 2017a64:	e0bff415 	stw	r2,-48(fp)
    ptcb = OSTCBFreeList;                                  /* Get a free TCB from the free TCB list    */
 2017a68:	d0a07817 	ldw	r2,-32288(gp)
 2017a6c:	e0bff515 	stw	r2,-44(fp)
    if (ptcb != (OS_TCB *)0) {
 2017a70:	e0bff517 	ldw	r2,-44(fp)
 2017a74:	10009326 	beq	r2,zero,2017cc4 <OS_TCBInit+0x2b0>
        OSTCBFreeList            = ptcb->OSTCBNext;        /* Update pointer to free TCB list          */
 2017a78:	e0bff517 	ldw	r2,-44(fp)
 2017a7c:	10800517 	ldw	r2,20(r2)
 2017a80:	d0a07815 	stw	r2,-32288(gp)
 2017a84:	e0bff417 	ldw	r2,-48(fp)
 2017a88:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017a8c:	e0bff717 	ldw	r2,-36(fp)
 2017a90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        ptcb->OSTCBStkPtr        = ptos;                   /* Load Stack pointer in TCB                */
 2017a94:	e0bff517 	ldw	r2,-44(fp)
 2017a98:	e0fffc17 	ldw	r3,-16(fp)
 2017a9c:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBPrio          = prio;                   /* Load task priority into TCB              */
 2017aa0:	e0bff517 	ldw	r2,-44(fp)
 2017aa4:	e0fffb03 	ldbu	r3,-20(fp)
 2017aa8:	10c00c85 	stb	r3,50(r2)
        ptcb->OSTCBStat          = OS_STAT_RDY;            /* Task is ready to run                     */
 2017aac:	e0bff517 	ldw	r2,-44(fp)
 2017ab0:	10000c05 	stb	zero,48(r2)
        ptcb->OSTCBStatPend      = OS_STAT_PEND_OK;        /* Clear pend status                        */
 2017ab4:	e0bff517 	ldw	r2,-44(fp)
 2017ab8:	10000c45 	stb	zero,49(r2)
        ptcb->OSTCBDly           = 0;                      /* Task is not delayed                      */
 2017abc:	e0bff517 	ldw	r2,-44(fp)
 2017ac0:	10000b8d 	sth	zero,46(r2)

#if OS_TASK_CREATE_EXT_EN > 0
        ptcb->OSTCBExtPtr        = pext;                   /* Store pointer to TCB extension           */
 2017ac4:	e0bff517 	ldw	r2,-44(fp)
 2017ac8:	e0c00317 	ldw	r3,12(fp)
 2017acc:	10c00115 	stw	r3,4(r2)
        ptcb->OSTCBStkSize       = stk_size;               /* Store stack size                         */
 2017ad0:	e0bff517 	ldw	r2,-44(fp)
 2017ad4:	e0c00217 	ldw	r3,8(fp)
 2017ad8:	10c00315 	stw	r3,12(r2)
        ptcb->OSTCBStkBottom     = pbos;                   /* Store pointer to bottom of stack         */
 2017adc:	e0bff517 	ldw	r2,-44(fp)
 2017ae0:	e0fffd17 	ldw	r3,-12(fp)
 2017ae4:	10c00215 	stw	r3,8(r2)
        ptcb->OSTCBOpt           = opt;                    /* Store task options                       */
 2017ae8:	e0bff517 	ldw	r2,-44(fp)
 2017aec:	e0ffff0b 	ldhu	r3,-4(fp)
 2017af0:	10c0040d 	sth	r3,16(r2)
        ptcb->OSTCBId            = id;                     /* Store task ID                            */
 2017af4:	e0bff517 	ldw	r2,-44(fp)
 2017af8:	e0fffe0b 	ldhu	r3,-8(fp)
 2017afc:	10c0048d 	sth	r3,18(r2)
        opt                      = opt;
        id                       = id;
#endif

#if OS_TASK_DEL_EN > 0
        ptcb->OSTCBDelReq        = OS_ERR_NONE;
 2017b00:	e0bff517 	ldw	r2,-44(fp)
 2017b04:	10000dc5 	stb	zero,55(r2)
#endif

#if OS_LOWEST_PRIO <= 63
        ptcb->OSTCBY             = (INT8U)(prio >> 3);          /* Pre-compute X, Y, BitX and BitY     */
 2017b08:	e0bffb03 	ldbu	r2,-20(fp)
 2017b0c:	1004d0fa 	srli	r2,r2,3
 2017b10:	1007883a 	mov	r3,r2
 2017b14:	e0bff517 	ldw	r2,-44(fp)
 2017b18:	10c00d05 	stb	r3,52(r2)
        ptcb->OSTCBX             = (INT8U)(prio & 0x07);
 2017b1c:	e0bffb03 	ldbu	r2,-20(fp)
 2017b20:	108001cc 	andi	r2,r2,7
 2017b24:	1007883a 	mov	r3,r2
 2017b28:	e0bff517 	ldw	r2,-44(fp)
 2017b2c:	10c00cc5 	stb	r3,51(r2)
        ptcb->OSTCBBitY          = (INT8U)(1 << ptcb->OSTCBY);
 2017b30:	e0bff517 	ldw	r2,-44(fp)
 2017b34:	10800d03 	ldbu	r2,52(r2)
 2017b38:	10803fcc 	andi	r2,r2,255
 2017b3c:	00c00044 	movi	r3,1
 2017b40:	1884983a 	sll	r2,r3,r2
 2017b44:	1007883a 	mov	r3,r2
 2017b48:	e0bff517 	ldw	r2,-44(fp)
 2017b4c:	10c00d85 	stb	r3,54(r2)
        ptcb->OSTCBBitX          = (INT8U)(1 << ptcb->OSTCBX);
 2017b50:	e0bff517 	ldw	r2,-44(fp)
 2017b54:	10800cc3 	ldbu	r2,51(r2)
 2017b58:	10803fcc 	andi	r2,r2,255
 2017b5c:	00c00044 	movi	r3,1
 2017b60:	1884983a 	sll	r2,r3,r2
 2017b64:	1007883a 	mov	r3,r2
 2017b68:	e0bff517 	ldw	r2,-44(fp)
 2017b6c:	10c00d45 	stb	r3,53(r2)
        ptcb->OSTCBBitY          = (INT16U)(1 << ptcb->OSTCBY);
        ptcb->OSTCBBitX          = (INT16U)(1 << ptcb->OSTCBX);
#endif

#if (OS_EVENT_EN)
        ptcb->OSTCBEventPtr      = (OS_EVENT  *)0;         /* Task is not pending on an  event         */
 2017b70:	e0bff517 	ldw	r2,-44(fp)
 2017b74:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
        ptcb->OSTCBEventMultiPtr = (OS_EVENT **)0;         /* Task is not pending on any events        */
 2017b78:	e0bff517 	ldw	r2,-44(fp)
 2017b7c:	10000815 	stw	zero,32(r2)
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0) && (OS_TASK_DEL_EN > 0)
        ptcb->OSTCBFlagNode  = (OS_FLAG_NODE *)0;          /* Task is not pending on an event flag     */
 2017b80:	e0bff517 	ldw	r2,-44(fp)
 2017b84:	10000a15 	stw	zero,40(r2)
#endif

#if (OS_MBOX_EN > 0) || ((OS_Q_EN > 0) && (OS_MAX_QS > 0))
        ptcb->OSTCBMsg       = (void *)0;                  /* No message received                      */
 2017b88:	e0bff517 	ldw	r2,-44(fp)
 2017b8c:	10000915 	stw	zero,36(r2)
#endif

#if OS_TASK_PROFILE_EN > 0
        ptcb->OSTCBCtxSwCtr    = 0L;                       /* Initialize profiling variables           */
 2017b90:	e0bff517 	ldw	r2,-44(fp)
 2017b94:	10000e15 	stw	zero,56(r2)
        ptcb->OSTCBCyclesStart = 0L;
 2017b98:	e0bff517 	ldw	r2,-44(fp)
 2017b9c:	10001015 	stw	zero,64(r2)
        ptcb->OSTCBCyclesTot   = 0L;
 2017ba0:	e0bff517 	ldw	r2,-44(fp)
 2017ba4:	10000f15 	stw	zero,60(r2)
        ptcb->OSTCBStkBase     = (OS_STK *)0;
 2017ba8:	e0bff517 	ldw	r2,-44(fp)
 2017bac:	10001115 	stw	zero,68(r2)
        ptcb->OSTCBStkUsed     = 0L;
 2017bb0:	e0bff517 	ldw	r2,-44(fp)
 2017bb4:	10001215 	stw	zero,72(r2)
#endif

#if OS_TASK_NAME_SIZE > 1
        ptcb->OSTCBTaskName[0] = '?';                      /* Unknown name at task creation            */
 2017bb8:	e0bff517 	ldw	r2,-44(fp)
 2017bbc:	00c00fc4 	movi	r3,63
 2017bc0:	10c01305 	stb	r3,76(r2)
        ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 2017bc4:	e0bff517 	ldw	r2,-44(fp)
 2017bc8:	10001345 	stb	zero,77(r2)
#endif

        OSTCBInitHook(ptcb);
 2017bcc:	e13ff517 	ldw	r4,-44(fp)
 2017bd0:	2037fbc0 	call	2037fbc <OSTCBInitHook>

        OSTaskCreateHook(ptcb);                            /* Call user defined hook                   */
 2017bd4:	e13ff517 	ldw	r4,-44(fp)
 2017bd8:	2037ec80 	call	2037ec8 <OSTaskCreateHook>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017bdc:	0005303a 	rdctl	r2,status
 2017be0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017be4:	e0fff817 	ldw	r3,-32(fp)
 2017be8:	00bfff84 	movi	r2,-2
 2017bec:	1884703a 	and	r2,r3,r2
 2017bf0:	1001703a 	wrctl	status,r2
  
  return context;
 2017bf4:	e0bff817 	ldw	r2,-32(fp)

        OS_ENTER_CRITICAL();
 2017bf8:	e0bff415 	stw	r2,-48(fp)
        OSTCBPrioTbl[prio] = ptcb;
 2017bfc:	e0bffb03 	ldbu	r2,-20(fp)
 2017c00:	00c09934 	movhi	r3,612
 2017c04:	18f45704 	addi	r3,r3,-11940
 2017c08:	1085883a 	add	r2,r2,r2
 2017c0c:	1085883a 	add	r2,r2,r2
 2017c10:	1885883a 	add	r2,r3,r2
 2017c14:	e0fff517 	ldw	r3,-44(fp)
 2017c18:	10c00015 	stw	r3,0(r2)
        ptcb->OSTCBNext    = OSTCBList;                    /* Link into TCB chain                      */
 2017c1c:	d0e07417 	ldw	r3,-32304(gp)
 2017c20:	e0bff517 	ldw	r2,-44(fp)
 2017c24:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBPrev    = (OS_TCB *)0;
 2017c28:	e0bff517 	ldw	r2,-44(fp)
 2017c2c:	10000615 	stw	zero,24(r2)
        if (OSTCBList != (OS_TCB *)0) {
 2017c30:	d0a07417 	ldw	r2,-32304(gp)
 2017c34:	10000326 	beq	r2,zero,2017c44 <OS_TCBInit+0x230>
            OSTCBList->OSTCBPrev = ptcb;
 2017c38:	d0a07417 	ldw	r2,-32304(gp)
 2017c3c:	e0fff517 	ldw	r3,-44(fp)
 2017c40:	10c00615 	stw	r3,24(r2)
        }
        OSTCBList               = ptcb;
 2017c44:	e0bff517 	ldw	r2,-44(fp)
 2017c48:	d0a07415 	stw	r2,-32304(gp)
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Make task ready to run                   */
 2017c4c:	e0bff517 	ldw	r2,-44(fp)
 2017c50:	10c00d83 	ldbu	r3,54(r2)
 2017c54:	d0a07d03 	ldbu	r2,-32268(gp)
 2017c58:	1884b03a 	or	r2,r3,r2
 2017c5c:	d0a07d05 	stb	r2,-32268(gp)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 2017c60:	e0bff517 	ldw	r2,-44(fp)
 2017c64:	10800d03 	ldbu	r2,52(r2)
 2017c68:	11003fcc 	andi	r4,r2,255
 2017c6c:	e0bff517 	ldw	r2,-44(fp)
 2017c70:	10800d03 	ldbu	r2,52(r2)
 2017c74:	10c03fcc 	andi	r3,r2,255
 2017c78:	d0a07d44 	addi	r2,gp,-32267
 2017c7c:	1885883a 	add	r2,r3,r2
 2017c80:	10c00003 	ldbu	r3,0(r2)
 2017c84:	e0bff517 	ldw	r2,-44(fp)
 2017c88:	10800d43 	ldbu	r2,53(r2)
 2017c8c:	1884b03a 	or	r2,r3,r2
 2017c90:	1007883a 	mov	r3,r2
 2017c94:	d0a07d44 	addi	r2,gp,-32267
 2017c98:	2085883a 	add	r2,r4,r2
 2017c9c:	10c00005 	stb	r3,0(r2)
        OSTaskCtr++;                                       /* Increment the #tasks counter             */
 2017ca0:	d0a07943 	ldbu	r2,-32283(gp)
 2017ca4:	10800044 	addi	r2,r2,1
 2017ca8:	d0a07945 	stb	r2,-32283(gp)
 2017cac:	e0bff417 	ldw	r2,-48(fp)
 2017cb0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017cb4:	e0bff917 	ldw	r2,-28(fp)
 2017cb8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 2017cbc:	0005883a 	mov	r2,zero
 2017cc0:	00000506 	br	2017cd8 <OS_TCBInit+0x2c4>
 2017cc4:	e0bff417 	ldw	r2,-48(fp)
 2017cc8:	e0bffa15 	stw	r2,-24(fp)
 2017ccc:	e0bffa17 	ldw	r2,-24(fp)
 2017cd0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NO_MORE_TCB);
 2017cd4:	00801084 	movi	r2,66
}
 2017cd8:	e037883a 	mov	sp,fp
 2017cdc:	dfc00117 	ldw	ra,4(sp)
 2017ce0:	df000017 	ldw	fp,0(sp)
 2017ce4:	dec00204 	addi	sp,sp,8
 2017ce8:	f800283a 	ret

02017cec <OSDebugInit>:
*********************************************************************************************************
*/

#if OS_DEBUG_EN > 0
void  OSDebugInit (void)
{
 2017cec:	defffe04 	addi	sp,sp,-8
 2017cf0:	df000115 	stw	fp,4(sp)
 2017cf4:	df000104 	addi	fp,sp,4
    void  *ptemp;

    
    ptemp = (void *)&OSDebugEn;
 2017cf8:	d0a01704 	addi	r2,gp,-32676
 2017cfc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEndiannessTest;
 2017d00:	d0a01804 	addi	r2,gp,-32672
 2017d04:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSEventMax;
 2017d08:	d0a01984 	addi	r2,gp,-32666
 2017d0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventNameSize;
 2017d10:	d0a01a04 	addi	r2,gp,-32664
 2017d14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventEn;
 2017d18:	d0a01904 	addi	r2,gp,-32668
 2017d1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventSize;
 2017d20:	d0a01a84 	addi	r2,gp,-32662
 2017d24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventTblSize;
 2017d28:	d0a01b04 	addi	r2,gp,-32660
 2017d2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSEventMultiEn;
 2017d30:	d0a01b84 	addi	r2,gp,-32658
 2017d34:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSFlagEn;
 2017d38:	d0a01c04 	addi	r2,gp,-32656
 2017d3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagGrpSize;
 2017d40:	d0a01c84 	addi	r2,gp,-32654
 2017d44:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNodeSize;
 2017d48:	d0a01d04 	addi	r2,gp,-32652
 2017d4c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagWidth;
 2017d50:	d0a01d84 	addi	r2,gp,-32650
 2017d54:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagMax;
 2017d58:	d0a01e04 	addi	r2,gp,-32648
 2017d5c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSFlagNameSize;
 2017d60:	d0a01e84 	addi	r2,gp,-32646
 2017d64:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSLowestPrio;
 2017d68:	d0a01f04 	addi	r2,gp,-32644
 2017d6c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMboxEn;
 2017d70:	d0a01f84 	addi	r2,gp,-32642
 2017d74:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMemEn;
 2017d78:	d0a02004 	addi	r2,gp,-32640
 2017d7c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemMax;
 2017d80:	d0a02084 	addi	r2,gp,-32638
 2017d84:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemNameSize;
 2017d88:	d0a02104 	addi	r2,gp,-32636
 2017d8c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemSize;
 2017d90:	d0a02184 	addi	r2,gp,-32634
 2017d94:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSMemTblSize;
 2017d98:	d0a02204 	addi	r2,gp,-32632
 2017d9c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSMutexEn;
 2017da0:	d0a02284 	addi	r2,gp,-32630
 2017da4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSPtrSize;
 2017da8:	d0a02304 	addi	r2,gp,-32628
 2017dac:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSQEn;
 2017db0:	d0a02384 	addi	r2,gp,-32626
 2017db4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQMax;
 2017db8:	d0a02404 	addi	r2,gp,-32624
 2017dbc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSQSize;
 2017dc0:	d0a02484 	addi	r2,gp,-32622
 2017dc4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSRdyTblSize;
 2017dc8:	d0a02504 	addi	r2,gp,-32620
 2017dcc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSSemEn;
 2017dd0:	d0a02584 	addi	r2,gp,-32618
 2017dd4:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSStkWidth;
 2017dd8:	d0a02604 	addi	r2,gp,-32616
 2017ddc:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTaskCreateEn;
 2017de0:	d0a02684 	addi	r2,gp,-32614
 2017de4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskCreateExtEn;
 2017de8:	d0a02704 	addi	r2,gp,-32612
 2017dec:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskDelEn;
 2017df0:	d0a02784 	addi	r2,gp,-32610
 2017df4:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskIdleStkSize;
 2017df8:	d0a02804 	addi	r2,gp,-32608
 2017dfc:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskProfileEn;
 2017e00:	d0a02884 	addi	r2,gp,-32606
 2017e04:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskMax;
 2017e08:	d0a02904 	addi	r2,gp,-32604
 2017e0c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskNameSize;
 2017e10:	d0a02984 	addi	r2,gp,-32602
 2017e14:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatEn;
 2017e18:	d0a02a04 	addi	r2,gp,-32600
 2017e1c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkSize;
 2017e20:	d0a02a84 	addi	r2,gp,-32598
 2017e24:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskStatStkChkEn;
 2017e28:	d0a02b04 	addi	r2,gp,-32596
 2017e2c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTaskSwHookEn;
 2017e30:	d0a02b84 	addi	r2,gp,-32594
 2017e34:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTCBPrioTblMax;
 2017e38:	d0a02c04 	addi	r2,gp,-32592
 2017e3c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTCBSize;
 2017e40:	d0a02c84 	addi	r2,gp,-32590
 2017e44:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTicksPerSec;
 2017e48:	d0a02d04 	addi	r2,gp,-32588
 2017e4c:	e0bfff15 	stw	r2,-4(fp)
    ptemp = (void *)&OSTimeTickHookEn;
 2017e50:	d0a02d84 	addi	r2,gp,-32586
 2017e54:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSTmrWheelSize;
    ptemp = (void *)&OSTmrWheelTblSize;
#endif

    ptemp = (void *)&OSVersionNbr;
 2017e58:	d0a02e04 	addi	r2,gp,-32584
 2017e5c:	e0bfff15 	stw	r2,-4(fp)

    ptemp = (void *)&OSDataSize;
 2017e60:	d0a03304 	addi	r2,gp,-32564
 2017e64:	e0bfff15 	stw	r2,-4(fp)

    ptemp = ptemp;                             /* Prevent compiler warning for 'ptemp' not being used! */
}
 2017e68:	e037883a 	mov	sp,fp
 2017e6c:	df000017 	ldw	fp,0(sp)
 2017e70:	dec00104 	addi	sp,sp,4
 2017e74:	f800283a 	ret

02017e78 <OSFlagAccept>:
*********************************************************************************************************
*/

#if OS_FLAG_ACCEPT_EN > 0
OS_FLAGS  OSFlagAccept (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT8U *perr)
{
 2017e78:	defff204 	addi	sp,sp,-56
 2017e7c:	df000d15 	stw	fp,52(sp)
 2017e80:	df000d04 	addi	fp,sp,52
 2017e84:	e13ffc15 	stw	r4,-16(fp)
 2017e88:	2807883a 	mov	r3,r5
 2017e8c:	3005883a 	mov	r2,r6
 2017e90:	e1ffff15 	stw	r7,-4(fp)
 2017e94:	e0fffd0d 	sth	r3,-12(fp)
 2017e98:	e0bffe05 	stb	r2,-8(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 2017e9c:	e03ff415 	stw	zero,-48(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2017ea0:	e0bfff17 	ldw	r2,-4(fp)
 2017ea4:	1000021e 	bne	r2,zero,2017eb0 <OSFlagAccept+0x38>
        return ((OS_FLAGS)0);
 2017ea8:	0005883a 	mov	r2,zero
 2017eac:	0000b006 	br	2018170 <OSFlagAccept+0x2f8>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 2017eb0:	e0bffc17 	ldw	r2,-16(fp)
 2017eb4:	1000051e 	bne	r2,zero,2017ecc <OSFlagAccept+0x54>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2017eb8:	e0bfff17 	ldw	r2,-4(fp)
 2017ebc:	00c01b84 	movi	r3,110
 2017ec0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2017ec4:	0005883a 	mov	r2,zero
 2017ec8:	0000a906 	br	2018170 <OSFlagAccept+0x2f8>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 2017ecc:	e0bffc17 	ldw	r2,-16(fp)
 2017ed0:	10800003 	ldbu	r2,0(r2)
 2017ed4:	10803fcc 	andi	r2,r2,255
 2017ed8:	10800160 	cmpeqi	r2,r2,5
 2017edc:	1000051e 	bne	r2,zero,2017ef4 <OSFlagAccept+0x7c>
        *perr = OS_ERR_EVENT_TYPE;
 2017ee0:	e0bfff17 	ldw	r2,-4(fp)
 2017ee4:	00c00044 	movi	r3,1
 2017ee8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2017eec:	0005883a 	mov	r2,zero
 2017ef0:	00009f06 	br	2018170 <OSFlagAccept+0x2f8>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 2017ef4:	e0fffe03 	ldbu	r3,-8(fp)
 2017ef8:	00bfe004 	movi	r2,-128
 2017efc:	1884703a 	and	r2,r3,r2
 2017f00:	e0bff505 	stb	r2,-44(fp)
    if (result != (INT8U)0) {                              /* See if we need to consume the flags      */
 2017f04:	e0bff503 	ldbu	r2,-44(fp)
 2017f08:	10000626 	beq	r2,zero,2017f24 <OSFlagAccept+0xac>
        wait_type &= ~OS_FLAG_CONSUME;
 2017f0c:	e0bffe03 	ldbu	r2,-8(fp)
 2017f10:	10801fcc 	andi	r2,r2,127
 2017f14:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 2017f18:	00800044 	movi	r2,1
 2017f1c:	e0bff385 	stb	r2,-50(fp)
 2017f20:	00000106 	br	2017f28 <OSFlagAccept+0xb0>
    } else {
        consume    = OS_FALSE;
 2017f24:	e03ff385 	stb	zero,-50(fp)
    }
/*$PAGE*/
    *perr = OS_ERR_NONE;                                   /* Assume NO error until proven otherwise.  */
 2017f28:	e0bfff17 	ldw	r2,-4(fp)
 2017f2c:	10000005 	stb	zero,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2017f30:	0005303a 	rdctl	r2,status
 2017f34:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2017f38:	e0fff617 	ldw	r3,-40(fp)
 2017f3c:	00bfff84 	movi	r2,-2
 2017f40:	1884703a 	and	r2,r3,r2
 2017f44:	1001703a 	wrctl	status,r2
  
  return context;
 2017f48:	e0bff617 	ldw	r2,-40(fp)
    OS_ENTER_CRITICAL();
 2017f4c:	e0bff415 	stw	r2,-48(fp)
    switch (wait_type) {
 2017f50:	e0bffe03 	ldbu	r2,-8(fp)
 2017f54:	10c00060 	cmpeqi	r3,r2,1
 2017f58:	18005f1e 	bne	r3,zero,20180d8 <OSFlagAccept+0x260>
 2017f5c:	10c00088 	cmpgei	r3,r2,2
 2017f60:	1800021e 	bne	r3,zero,2017f6c <OSFlagAccept+0xf4>
 2017f64:	10003f26 	beq	r2,zero,2018064 <OSFlagAccept+0x1ec>
 2017f68:	00007706 	br	2018148 <OSFlagAccept+0x2d0>
 2017f6c:	10c000a0 	cmpeqi	r3,r2,2
 2017f70:	1800031e 	bne	r3,zero,2017f80 <OSFlagAccept+0x108>
 2017f74:	108000e0 	cmpeqi	r2,r2,3
 2017f78:	10001e1e 	bne	r2,zero,2017ff4 <OSFlagAccept+0x17c>
 2017f7c:	00007206 	br	2018148 <OSFlagAccept+0x2d0>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 2017f80:	e0bffc17 	ldw	r2,-16(fp)
 2017f84:	10c0020b 	ldhu	r3,8(r2)
 2017f88:	e0bffd0b 	ldhu	r2,-12(fp)
 2017f8c:	1884703a 	and	r2,r3,r2
 2017f90:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2017f94:	e0fff30b 	ldhu	r3,-52(fp)
 2017f98:	e0bffd0b 	ldhu	r2,-12(fp)
 2017f9c:	18800d1e 	bne	r3,r2,2017fd4 <OSFlagAccept+0x15c>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2017fa0:	e0bff383 	ldbu	r2,-50(fp)
 2017fa4:	10800058 	cmpnei	r2,r2,1
 2017fa8:	10000d1e 	bne	r2,zero,2017fe0 <OSFlagAccept+0x168>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 2017fac:	e0bffc17 	ldw	r2,-16(fp)
 2017fb0:	1080020b 	ldhu	r2,8(r2)
 2017fb4:	1007883a 	mov	r3,r2
 2017fb8:	e0bff30b 	ldhu	r2,-52(fp)
 2017fbc:	0084303a 	nor	r2,zero,r2
 2017fc0:	1884703a 	and	r2,r3,r2
 2017fc4:	1007883a 	mov	r3,r2
 2017fc8:	e0bffc17 	ldw	r2,-16(fp)
 2017fcc:	10c0020d 	sth	r3,8(r2)
 2017fd0:	00000306 	br	2017fe0 <OSFlagAccept+0x168>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2017fd4:	e0bfff17 	ldw	r2,-4(fp)
 2017fd8:	00c01c04 	movi	r3,112
 2017fdc:	10c00005 	stb	r3,0(r2)
 2017fe0:	e0bff417 	ldw	r2,-48(fp)
 2017fe4:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2017fe8:	e0bff717 	ldw	r2,-36(fp)
 2017fec:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2017ff0:	00005e06 	br	201816c <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);     /* Extract only the bits we want   */
 2017ff4:	e0bffc17 	ldw	r2,-16(fp)
 2017ff8:	10c0020b 	ldhu	r3,8(r2)
 2017ffc:	e0bffd0b 	ldhu	r2,-12(fp)
 2018000:	1884703a 	and	r2,r3,r2
 2018004:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 2018008:	e0bff30b 	ldhu	r2,-52(fp)
 201800c:	10000d26 	beq	r2,zero,2018044 <OSFlagAccept+0x1cc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2018010:	e0bff383 	ldbu	r2,-50(fp)
 2018014:	10800058 	cmpnei	r2,r2,1
 2018018:	10000d1e 	bne	r2,zero,2018050 <OSFlagAccept+0x1d8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 201801c:	e0bffc17 	ldw	r2,-16(fp)
 2018020:	1080020b 	ldhu	r2,8(r2)
 2018024:	1007883a 	mov	r3,r2
 2018028:	e0bff30b 	ldhu	r2,-52(fp)
 201802c:	0084303a 	nor	r2,zero,r2
 2018030:	1884703a 	and	r2,r3,r2
 2018034:	1007883a 	mov	r3,r2
 2018038:	e0bffc17 	ldw	r2,-16(fp)
 201803c:	10c0020d 	sth	r3,8(r2)
 2018040:	00000306 	br	2018050 <OSFlagAccept+0x1d8>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2018044:	e0bfff17 	ldw	r2,-4(fp)
 2018048:	00c01c04 	movi	r3,112
 201804c:	10c00005 	stb	r3,0(r2)
 2018050:	e0bff417 	ldw	r2,-48(fp)
 2018054:	e0bff815 	stw	r2,-32(fp)
 2018058:	e0bff817 	ldw	r2,-32(fp)
 201805c:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2018060:	00004206 	br	201816c <OSFlagAccept+0x2f4>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 2018064:	e0bffc17 	ldw	r2,-16(fp)
 2018068:	1080020b 	ldhu	r2,8(r2)
 201806c:	0084303a 	nor	r2,zero,r2
 2018070:	1007883a 	mov	r3,r2
 2018074:	e0bffd0b 	ldhu	r2,-12(fp)
 2018078:	1884703a 	and	r2,r3,r2
 201807c:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2018080:	e0fff30b 	ldhu	r3,-52(fp)
 2018084:	e0bffd0b 	ldhu	r2,-12(fp)
 2018088:	18800b1e 	bne	r3,r2,20180b8 <OSFlagAccept+0x240>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 201808c:	e0bff383 	ldbu	r2,-50(fp)
 2018090:	10800058 	cmpnei	r2,r2,1
 2018094:	10000b1e 	bne	r2,zero,20180c4 <OSFlagAccept+0x24c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 2018098:	e0bffc17 	ldw	r2,-16(fp)
 201809c:	10c0020b 	ldhu	r3,8(r2)
 20180a0:	e0bff30b 	ldhu	r2,-52(fp)
 20180a4:	1884b03a 	or	r2,r3,r2
 20180a8:	1007883a 	mov	r3,r2
 20180ac:	e0bffc17 	ldw	r2,-16(fp)
 20180b0:	10c0020d 	sth	r3,8(r2)
 20180b4:	00000306 	br	20180c4 <OSFlagAccept+0x24c>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 20180b8:	e0bfff17 	ldw	r2,-4(fp)
 20180bc:	00c01c04 	movi	r3,112
 20180c0:	10c00005 	stb	r3,0(r2)
 20180c4:	e0bff417 	ldw	r2,-48(fp)
 20180c8:	e0bff915 	stw	r2,-28(fp)
 20180cc:	e0bff917 	ldw	r2,-28(fp)
 20180d0:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 20180d4:	00002506 	br	201816c <OSFlagAccept+0x2f4>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 20180d8:	e0bffc17 	ldw	r2,-16(fp)
 20180dc:	1080020b 	ldhu	r2,8(r2)
 20180e0:	0084303a 	nor	r2,zero,r2
 20180e4:	1007883a 	mov	r3,r2
 20180e8:	e0bffd0b 	ldhu	r2,-12(fp)
 20180ec:	1884703a 	and	r2,r3,r2
 20180f0:	e0bff30d 	sth	r2,-52(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 20180f4:	e0bff30b 	ldhu	r2,-52(fp)
 20180f8:	10000b26 	beq	r2,zero,2018128 <OSFlagAccept+0x2b0>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 20180fc:	e0bff383 	ldbu	r2,-50(fp)
 2018100:	10800058 	cmpnei	r2,r2,1
 2018104:	10000b1e 	bne	r2,zero,2018134 <OSFlagAccept+0x2bc>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 2018108:	e0bffc17 	ldw	r2,-16(fp)
 201810c:	10c0020b 	ldhu	r3,8(r2)
 2018110:	e0bff30b 	ldhu	r2,-52(fp)
 2018114:	1884b03a 	or	r2,r3,r2
 2018118:	1007883a 	mov	r3,r2
 201811c:	e0bffc17 	ldw	r2,-16(fp)
 2018120:	10c0020d 	sth	r3,8(r2)
 2018124:	00000306 	br	2018134 <OSFlagAccept+0x2bc>
                 }
             } else {
                 *perr = OS_ERR_FLAG_NOT_RDY;
 2018128:	e0bfff17 	ldw	r2,-4(fp)
 201812c:	00c01c04 	movi	r3,112
 2018130:	10c00005 	stb	r3,0(r2)
 2018134:	e0bff417 	ldw	r2,-48(fp)
 2018138:	e0bffa15 	stw	r2,-24(fp)
 201813c:	e0bffa17 	ldw	r2,-24(fp)
 2018140:	1001703a 	wrctl	status,r2
             }
             OS_EXIT_CRITICAL();
             break;
 2018144:	00000906 	br	201816c <OSFlagAccept+0x2f4>
 2018148:	e0bff417 	ldw	r2,-48(fp)
 201814c:	e0bffb15 	stw	r2,-20(fp)
 2018150:	e0bffb17 	ldw	r2,-20(fp)
 2018154:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 2018158:	e03ff30d 	sth	zero,-52(fp)
             *perr     = OS_ERR_FLAG_WAIT_TYPE;
 201815c:	e0bfff17 	ldw	r2,-4(fp)
 2018160:	00c01bc4 	movi	r3,111
 2018164:	10c00005 	stb	r3,0(r2)
             break;
 2018168:	0001883a 	nop
    }
    return (flags_rdy);
 201816c:	e0bff30b 	ldhu	r2,-52(fp)
}
 2018170:	e037883a 	mov	sp,fp
 2018174:	df000017 	ldw	fp,0(sp)
 2018178:	dec00104 	addi	sp,sp,4
 201817c:	f800283a 	ret

02018180 <OSFlagCreate>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAG_GRP  *OSFlagCreate (OS_FLAGS flags, INT8U *perr)
{
 2018180:	defff804 	addi	sp,sp,-32
 2018184:	df000715 	stw	fp,28(sp)
 2018188:	df000704 	addi	fp,sp,28
 201818c:	2005883a 	mov	r2,r4
 2018190:	e17fff15 	stw	r5,-4(fp)
 2018194:	e0bffe0d 	sth	r2,-8(fp)
    OS_FLAG_GRP *pgrp;
#if OS_CRITICAL_METHOD == 3                         /* Allocate storage for CPU status register        */
    OS_CPU_SR    cpu_sr = 0;
 2018198:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                       /* Validate 'perr'                                 */
 201819c:	e0bfff17 	ldw	r2,-4(fp)
 20181a0:	1000021e 	bne	r2,zero,20181ac <OSFlagCreate+0x2c>
        return ((OS_FLAG_GRP *)0);
 20181a4:	0005883a 	mov	r2,zero
 20181a8:	00003b06 	br	2018298 <OSFlagCreate+0x118>
    }
#endif
    if (OSIntNesting > 0) {                         /* See if called from ISR ...                      */
 20181ac:	00808174 	movhi	r2,517
 20181b0:	1090a904 	addi	r2,r2,17060
 20181b4:	10800003 	ldbu	r2,0(r2)
 20181b8:	10803fcc 	andi	r2,r2,255
 20181bc:	10000526 	beq	r2,zero,20181d4 <OSFlagCreate+0x54>
        *perr = OS_ERR_CREATE_ISR;                  /* ... can't CREATE from an ISR                    */
 20181c0:	e0bfff17 	ldw	r2,-4(fp)
 20181c4:	00c00404 	movi	r3,16
 20181c8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAG_GRP *)0);
 20181cc:	0005883a 	mov	r2,zero
 20181d0:	00003106 	br	2018298 <OSFlagCreate+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20181d4:	0005303a 	rdctl	r2,status
 20181d8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20181dc:	e0fffb17 	ldw	r3,-20(fp)
 20181e0:	00bfff84 	movi	r2,-2
 20181e4:	1884703a 	and	r2,r3,r2
 20181e8:	1001703a 	wrctl	status,r2
  
  return context;
 20181ec:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 20181f0:	e0bff915 	stw	r2,-28(fp)
    pgrp = OSFlagFreeList;                          /* Get next free event flag                        */
 20181f4:	00808174 	movhi	r2,517
 20181f8:	1090ac04 	addi	r2,r2,17072
 20181fc:	10800017 	ldw	r2,0(r2)
 2018200:	e0bffa15 	stw	r2,-24(fp)
    if (pgrp != (OS_FLAG_GRP *)0) {                 /* See if we have event flag groups available      */
 2018204:	e0bffa17 	ldw	r2,-24(fp)
 2018208:	10001b26 	beq	r2,zero,2018278 <OSFlagCreate+0xf8>
                                                    /* Adjust free list                                */
        OSFlagFreeList       = (OS_FLAG_GRP *)OSFlagFreeList->OSFlagWaitList;
 201820c:	00808174 	movhi	r2,517
 2018210:	1090ac04 	addi	r2,r2,17072
 2018214:	10800017 	ldw	r2,0(r2)
 2018218:	10c00117 	ldw	r3,4(r2)
 201821c:	00808174 	movhi	r2,517
 2018220:	1090ac04 	addi	r2,r2,17072
 2018224:	10c00015 	stw	r3,0(r2)
        pgrp->OSFlagType     = OS_EVENT_TYPE_FLAG;  /* Set to event flag group type                    */
 2018228:	e0bffa17 	ldw	r2,-24(fp)
 201822c:	00c00144 	movi	r3,5
 2018230:	10c00005 	stb	r3,0(r2)
        pgrp->OSFlagFlags    = flags;               /* Set to desired initial value                    */
 2018234:	e0bffa17 	ldw	r2,-24(fp)
 2018238:	e0fffe0b 	ldhu	r3,-8(fp)
 201823c:	10c0020d 	sth	r3,8(r2)
        pgrp->OSFlagWaitList = (void *)0;           /* Clear list of tasks waiting on flags            */
 2018240:	e0bffa17 	ldw	r2,-24(fp)
 2018244:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp->OSFlagName[0]  = '?';
 2018248:	e0bffa17 	ldw	r2,-24(fp)
 201824c:	00c00fc4 	movi	r3,63
 2018250:	10c00285 	stb	r3,10(r2)
        pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 2018254:	e0bffa17 	ldw	r2,-24(fp)
 2018258:	100002c5 	stb	zero,11(r2)
 201825c:	e0bff917 	ldw	r2,-28(fp)
 2018260:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018264:	e0bffc17 	ldw	r2,-16(fp)
 2018268:	1001703a 	wrctl	status,r2
#endif
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_NONE;
 201826c:	e0bfff17 	ldw	r2,-4(fp)
 2018270:	10000005 	stb	zero,0(r2)
 2018274:	00000706 	br	2018294 <OSFlagCreate+0x114>
 2018278:	e0bff917 	ldw	r2,-28(fp)
 201827c:	e0bffd15 	stw	r2,-12(fp)
 2018280:	e0bffd17 	ldw	r2,-12(fp)
 2018284:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();
        *perr                = OS_ERR_FLAG_GRP_DEPLETED;
 2018288:	e0bfff17 	ldw	r2,-4(fp)
 201828c:	00c01c84 	movi	r3,114
 2018290:	10c00005 	stb	r3,0(r2)
    }
    return (pgrp);                                  /* Return pointer to event flag group              */
 2018294:	e0bffa17 	ldw	r2,-24(fp)
}
 2018298:	e037883a 	mov	sp,fp
 201829c:	df000017 	ldw	fp,0(sp)
 20182a0:	dec00104 	addi	sp,sp,4
 20182a4:	f800283a 	ret

020182a8 <OSFlagDel>:
*********************************************************************************************************
*/

#if OS_FLAG_DEL_EN > 0
OS_FLAG_GRP  *OSFlagDel (OS_FLAG_GRP *pgrp, INT8U opt, INT8U *perr)
{
 20182a8:	defff204 	addi	sp,sp,-56
 20182ac:	dfc00d15 	stw	ra,52(sp)
 20182b0:	df000c15 	stw	fp,48(sp)
 20182b4:	df000c04 	addi	fp,sp,48
 20182b8:	e13ffd15 	stw	r4,-12(fp)
 20182bc:	2805883a 	mov	r2,r5
 20182c0:	e1bfff15 	stw	r6,-4(fp)
 20182c4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       tasks_waiting;
    OS_FLAG_NODE *pnode;
    OS_FLAG_GRP  *pgrp_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 20182c8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 20182cc:	e0bfff17 	ldw	r2,-4(fp)
 20182d0:	1000021e 	bne	r2,zero,20182dc <OSFlagDel+0x34>
        return (pgrp);
 20182d4:	e0bffd17 	ldw	r2,-12(fp)
 20182d8:	00008a06 	br	2018504 <OSFlagDel+0x25c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 20182dc:	e0bffd17 	ldw	r2,-12(fp)
 20182e0:	1000051e 	bne	r2,zero,20182f8 <OSFlagDel+0x50>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 20182e4:	e0bfff17 	ldw	r2,-4(fp)
 20182e8:	00c01b84 	movi	r3,110
 20182ec:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 20182f0:	e0bffd17 	ldw	r2,-12(fp)
 20182f4:	00008306 	br	2018504 <OSFlagDel+0x25c>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 20182f8:	00808174 	movhi	r2,517
 20182fc:	1090a904 	addi	r2,r2,17060
 2018300:	10800003 	ldbu	r2,0(r2)
 2018304:	10803fcc 	andi	r2,r2,255
 2018308:	10000526 	beq	r2,zero,2018320 <OSFlagDel+0x78>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 201830c:	e0bfff17 	ldw	r2,-4(fp)
 2018310:	00c003c4 	movi	r3,15
 2018314:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 2018318:	e0bffd17 	ldw	r2,-12(fp)
 201831c:	00007906 	br	2018504 <OSFlagDel+0x25c>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event group type                */
 2018320:	e0bffd17 	ldw	r2,-12(fp)
 2018324:	10800003 	ldbu	r2,0(r2)
 2018328:	10803fcc 	andi	r2,r2,255
 201832c:	10800160 	cmpeqi	r2,r2,5
 2018330:	1000051e 	bne	r2,zero,2018348 <OSFlagDel+0xa0>
        *perr = OS_ERR_EVENT_TYPE;
 2018334:	e0bfff17 	ldw	r2,-4(fp)
 2018338:	00c00044 	movi	r3,1
 201833c:	10c00005 	stb	r3,0(r2)
        return (pgrp);
 2018340:	e0bffd17 	ldw	r2,-12(fp)
 2018344:	00006f06 	br	2018504 <OSFlagDel+0x25c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018348:	0005303a 	rdctl	r2,status
 201834c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018350:	e0fff817 	ldw	r3,-32(fp)
 2018354:	00bfff84 	movi	r2,-2
 2018358:	1884703a 	and	r2,r3,r2
 201835c:	1001703a 	wrctl	status,r2
  
  return context;
 2018360:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 2018364:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagWaitList != (void *)0) {               /* See if any tasks waiting on event flags  */
 2018368:	e0bffd17 	ldw	r2,-12(fp)
 201836c:	10800117 	ldw	r2,4(r2)
 2018370:	10000326 	beq	r2,zero,2018380 <OSFlagDel+0xd8>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 2018374:	00800044 	movi	r2,1
 2018378:	e0bff405 	stb	r2,-48(fp)
 201837c:	00000106 	br	2018384 <OSFlagDel+0xdc>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 2018380:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 2018384:	e0bffe03 	ldbu	r2,-8(fp)
 2018388:	10000326 	beq	r2,zero,2018398 <OSFlagDel+0xf0>
 201838c:	10800060 	cmpeqi	r2,r2,1
 2018390:	1000271e 	bne	r2,zero,2018430 <OSFlagDel+0x188>
 2018394:	00005006 	br	20184d8 <OSFlagDel+0x230>
        case OS_DEL_NO_PEND:                               /* Delete group if no task waiting          */
             if (tasks_waiting == OS_FALSE) {
 2018398:	e0bff403 	ldbu	r2,-48(fp)
 201839c:	10001a1e 	bne	r2,zero,2018408 <OSFlagDel+0x160>
#if OS_FLAG_NAME_SIZE > 1
                 pgrp->OSFlagName[0]  = '?';               /* Unknown name                             */
 20183a0:	e0bffd17 	ldw	r2,-12(fp)
 20183a4:	00c00fc4 	movi	r3,63
 20183a8:	10c00285 	stb	r3,10(r2)
                 pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 20183ac:	e0bffd17 	ldw	r2,-12(fp)
 20183b0:	100002c5 	stb	zero,11(r2)
#endif
                 pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 20183b4:	e0bffd17 	ldw	r2,-12(fp)
 20183b8:	10000005 	stb	zero,0(r2)
                 pgrp->OSFlagWaitList = (void *)OSFlagFreeList; /* Return group to free list           */
 20183bc:	00808174 	movhi	r2,517
 20183c0:	1090ac04 	addi	r2,r2,17072
 20183c4:	10c00017 	ldw	r3,0(r2)
 20183c8:	e0bffd17 	ldw	r2,-12(fp)
 20183cc:	10c00115 	stw	r3,4(r2)
                 pgrp->OSFlagFlags    = (OS_FLAGS)0;
 20183d0:	e0bffd17 	ldw	r2,-12(fp)
 20183d4:	1000020d 	sth	zero,8(r2)
                 OSFlagFreeList       = pgrp;
 20183d8:	00808174 	movhi	r2,517
 20183dc:	1090ac04 	addi	r2,r2,17072
 20183e0:	e0fffd17 	ldw	r3,-12(fp)
 20183e4:	10c00015 	stw	r3,0(r2)
 20183e8:	e0bff717 	ldw	r2,-36(fp)
 20183ec:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20183f0:	e0bff917 	ldw	r2,-28(fp)
 20183f4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
 20183f8:	e0bfff17 	ldw	r2,-4(fp)
 20183fc:	10000005 	stb	zero,0(r2)
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
 2018400:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
                 pgrp_return          = pgrp;
             }
             break;
 2018404:	00003e06 	br	2018500 <OSFlagDel+0x258>
 2018408:	e0bff717 	ldw	r2,-36(fp)
 201840c:	e0bffa15 	stw	r2,-24(fp)
 2018410:	e0bffa17 	ldw	r2,-24(fp)
 2018414:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_NONE;
                 pgrp_return          = (OS_FLAG_GRP *)0;  /* Event Flag Group has been deleted        */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                = OS_ERR_TASK_WAITING;
 2018418:	e0bfff17 	ldw	r2,-4(fp)
 201841c:	00c01244 	movi	r3,73
 2018420:	10c00005 	stb	r3,0(r2)
                 pgrp_return          = pgrp;
 2018424:	e0bffd17 	ldw	r2,-12(fp)
 2018428:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 201842c:	00003406 	br	2018500 <OSFlagDel+0x258>

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2018430:	e0bffd17 	ldw	r2,-12(fp)
 2018434:	10800117 	ldw	r2,4(r2)
 2018438:	e0bff515 	stw	r2,-44(fp)
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 201843c:	00000606 	br	2018458 <OSFlagDel+0x1b0>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
 2018440:	e13ff517 	ldw	r4,-44(fp)
 2018444:	000b883a 	mov	r5,zero
 2018448:	20195000 	call	2019500 <OS_FlagTaskRdy>
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 201844c:	e0bff517 	ldw	r2,-44(fp)
 2018450:	10800017 	ldw	r2,0(r2)
 2018454:	e0bff515 	stw	r2,-44(fp)
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the event flag group       */
             pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
             while (pnode != (OS_FLAG_NODE *)0) {          /* Ready ALL tasks waiting for flags        */
 2018458:	e0bff517 	ldw	r2,-44(fp)
 201845c:	103ff81e 	bne	r2,zero,2018440 <OSFlagDel+0x198>
                 (void)OS_FlagTaskRdy(pnode, (OS_FLAGS)0);
                 pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
             }
#if OS_FLAG_NAME_SIZE > 1
             pgrp->OSFlagName[0]  = '?';                   /* Unknown name                             */
 2018460:	e0bffd17 	ldw	r2,-12(fp)
 2018464:	00c00fc4 	movi	r3,63
 2018468:	10c00285 	stb	r3,10(r2)
             pgrp->OSFlagName[1]  = OS_ASCII_NUL;
 201846c:	e0bffd17 	ldw	r2,-12(fp)
 2018470:	100002c5 	stb	zero,11(r2)
#endif
             pgrp->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 2018474:	e0bffd17 	ldw	r2,-12(fp)
 2018478:	10000005 	stb	zero,0(r2)
             pgrp->OSFlagWaitList = (void *)OSFlagFreeList;/* Return group to free list                */
 201847c:	00808174 	movhi	r2,517
 2018480:	1090ac04 	addi	r2,r2,17072
 2018484:	10c00017 	ldw	r3,0(r2)
 2018488:	e0bffd17 	ldw	r2,-12(fp)
 201848c:	10c00115 	stw	r3,4(r2)
             pgrp->OSFlagFlags    = (OS_FLAGS)0;
 2018490:	e0bffd17 	ldw	r2,-12(fp)
 2018494:	1000020d 	sth	zero,8(r2)
             OSFlagFreeList       = pgrp;
 2018498:	00808174 	movhi	r2,517
 201849c:	1090ac04 	addi	r2,r2,17072
 20184a0:	e0fffd17 	ldw	r3,-12(fp)
 20184a4:	10c00015 	stw	r3,0(r2)
 20184a8:	e0bff717 	ldw	r2,-36(fp)
 20184ac:	e0bffb15 	stw	r2,-20(fp)
 20184b0:	e0bffb17 	ldw	r2,-20(fp)
 20184b4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 20184b8:	e0bff403 	ldbu	r2,-48(fp)
 20184bc:	10800058 	cmpnei	r2,r2,1
 20184c0:	1000011e 	bne	r2,zero,20184c8 <OSFlagDel+0x220>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 20184c4:	20176280 	call	2017628 <OS_Sched>
             }
             *perr = OS_ERR_NONE;
 20184c8:	e0bfff17 	ldw	r2,-4(fp)
 20184cc:	10000005 	stb	zero,0(r2)
             pgrp_return          = (OS_FLAG_GRP *)0;      /* Event Flag Group has been deleted        */
 20184d0:	e03ff615 	stw	zero,-40(fp)
             break;
 20184d4:	00000a06 	br	2018500 <OSFlagDel+0x258>
 20184d8:	e0bff717 	ldw	r2,-36(fp)
 20184dc:	e0bffc15 	stw	r2,-16(fp)
 20184e0:	e0bffc17 	ldw	r2,-16(fp)
 20184e4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                = OS_ERR_INVALID_OPT;
 20184e8:	e0bfff17 	ldw	r2,-4(fp)
 20184ec:	00c001c4 	movi	r3,7
 20184f0:	10c00005 	stb	r3,0(r2)
             pgrp_return          = pgrp;
 20184f4:	e0bffd17 	ldw	r2,-12(fp)
 20184f8:	e0bff615 	stw	r2,-40(fp)
             break;
 20184fc:	0001883a 	nop
    }
    return (pgrp_return);
 2018500:	e0bff617 	ldw	r2,-40(fp)
}
 2018504:	e037883a 	mov	sp,fp
 2018508:	dfc00117 	ldw	ra,4(sp)
 201850c:	df000017 	ldw	fp,0(sp)
 2018510:	dec00204 	addi	sp,sp,8
 2018514:	f800283a 	ret

02018518 <OSFlagNameGet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
INT8U  OSFlagNameGet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 2018518:	defff604 	addi	sp,sp,-40
 201851c:	dfc00915 	stw	ra,36(sp)
 2018520:	df000815 	stw	fp,32(sp)
 2018524:	df000804 	addi	fp,sp,32
 2018528:	e13ffd15 	stw	r4,-12(fp)
 201852c:	e17ffe15 	stw	r5,-8(fp)
 2018530:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2018534:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2018538:	e0bfff17 	ldw	r2,-4(fp)
 201853c:	1000021e 	bne	r2,zero,2018548 <OSFlagNameGet+0x30>
        return (0);
 2018540:	0005883a 	mov	r2,zero
 2018544:	00003b06 	br	2018634 <OSFlagNameGet+0x11c>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 2018548:	e0bffd17 	ldw	r2,-12(fp)
 201854c:	1000051e 	bne	r2,zero,2018564 <OSFlagNameGet+0x4c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2018550:	e0bfff17 	ldw	r2,-4(fp)
 2018554:	00c01b84 	movi	r3,110
 2018558:	10c00005 	stb	r3,0(r2)
        return (0);
 201855c:	0005883a 	mov	r2,zero
 2018560:	00003406 	br	2018634 <OSFlagNameGet+0x11c>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 2018564:	e0bffe17 	ldw	r2,-8(fp)
 2018568:	1000051e 	bne	r2,zero,2018580 <OSFlagNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 201856c:	e0bfff17 	ldw	r2,-4(fp)
 2018570:	00c00304 	movi	r3,12
 2018574:	10c00005 	stb	r3,0(r2)
        return (0);
 2018578:	0005883a 	mov	r2,zero
 201857c:	00002d06 	br	2018634 <OSFlagNameGet+0x11c>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 2018580:	00808174 	movhi	r2,517
 2018584:	1090a904 	addi	r2,r2,17060
 2018588:	10800003 	ldbu	r2,0(r2)
 201858c:	10803fcc 	andi	r2,r2,255
 2018590:	10000526 	beq	r2,zero,20185a8 <OSFlagNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
 2018594:	e0bfff17 	ldw	r2,-4(fp)
 2018598:	00c00444 	movi	r3,17
 201859c:	10c00005 	stb	r3,0(r2)
        return (0);
 20185a0:	0005883a 	mov	r2,zero
 20185a4:	00002306 	br	2018634 <OSFlagNameGet+0x11c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20185a8:	0005303a 	rdctl	r2,status
 20185ac:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20185b0:	e0fffa17 	ldw	r3,-24(fp)
 20185b4:	00bfff84 	movi	r2,-2
 20185b8:	1884703a 	and	r2,r3,r2
 20185bc:	1001703a 	wrctl	status,r2
  
  return context;
 20185c0:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 20185c4:	e0bff815 	stw	r2,-32(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 20185c8:	e0bffd17 	ldw	r2,-12(fp)
 20185cc:	10800003 	ldbu	r2,0(r2)
 20185d0:	10803fcc 	andi	r2,r2,255
 20185d4:	10800160 	cmpeqi	r2,r2,5
 20185d8:	1000091e 	bne	r2,zero,2018600 <OSFlagNameGet+0xe8>
 20185dc:	e0bff817 	ldw	r2,-32(fp)
 20185e0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20185e4:	e0bffb17 	ldw	r2,-20(fp)
 20185e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 20185ec:	e0bfff17 	ldw	r2,-4(fp)
 20185f0:	00c00044 	movi	r3,1
 20185f4:	10c00005 	stb	r3,0(r2)
        return (0);
 20185f8:	0005883a 	mov	r2,zero
 20185fc:	00000d06 	br	2018634 <OSFlagNameGet+0x11c>
    }
    len   = OS_StrCopy(pname, pgrp->OSFlagName); /* Copy name from OS_FLAG_GRP                         */
 2018600:	e0bffd17 	ldw	r2,-12(fp)
 2018604:	10800284 	addi	r2,r2,10
 2018608:	e13ffe17 	ldw	r4,-8(fp)
 201860c:	100b883a 	mov	r5,r2
 2018610:	20177640 	call	2017764 <OS_StrCopy>
 2018614:	e0bff905 	stb	r2,-28(fp)
 2018618:	e0bff817 	ldw	r2,-32(fp)
 201861c:	e0bffc15 	stw	r2,-16(fp)
 2018620:	e0bffc17 	ldw	r2,-16(fp)
 2018624:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2018628:	e0bfff17 	ldw	r2,-4(fp)
 201862c:	10000005 	stb	zero,0(r2)
    return (len);
 2018630:	e0bff903 	ldbu	r2,-28(fp)
}
 2018634:	e037883a 	mov	sp,fp
 2018638:	dfc00117 	ldw	ra,4(sp)
 201863c:	df000017 	ldw	fp,0(sp)
 2018640:	dec00204 	addi	sp,sp,8
 2018644:	f800283a 	ret

02018648 <OSFlagNameSet>:
*********************************************************************************************************
*/

#if OS_FLAG_NAME_SIZE > 1
void  OSFlagNameSet (OS_FLAG_GRP *pgrp, INT8U *pname, INT8U *perr)
{
 2018648:	defff504 	addi	sp,sp,-44
 201864c:	dfc00a15 	stw	ra,40(sp)
 2018650:	df000915 	stw	fp,36(sp)
 2018654:	df000904 	addi	fp,sp,36
 2018658:	e13ffd15 	stw	r4,-12(fp)
 201865c:	e17ffe15 	stw	r5,-8(fp)
 2018660:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2018664:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 2018668:	e0bfff17 	ldw	r2,-4(fp)
 201866c:	10004526 	beq	r2,zero,2018784 <OSFlagNameSet+0x13c>
        return;
    }
    if (pgrp == (OS_FLAG_GRP *)0) {              /* Is 'pgrp' a NULL pointer?                          */
 2018670:	e0bffd17 	ldw	r2,-12(fp)
 2018674:	1000041e 	bne	r2,zero,2018688 <OSFlagNameSet+0x40>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2018678:	e0bfff17 	ldw	r2,-4(fp)
 201867c:	00c01b84 	movi	r3,110
 2018680:	10c00005 	stb	r3,0(r2)
        return;
 2018684:	00004006 	br	2018788 <OSFlagNameSet+0x140>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 2018688:	e0bffe17 	ldw	r2,-8(fp)
 201868c:	1000041e 	bne	r2,zero,20186a0 <OSFlagNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 2018690:	e0bfff17 	ldw	r2,-4(fp)
 2018694:	00c00304 	movi	r3,12
 2018698:	10c00005 	stb	r3,0(r2)
        return;
 201869c:	00003a06 	br	2018788 <OSFlagNameSet+0x140>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 20186a0:	00808174 	movhi	r2,517
 20186a4:	1090a904 	addi	r2,r2,17060
 20186a8:	10800003 	ldbu	r2,0(r2)
 20186ac:	10803fcc 	andi	r2,r2,255
 20186b0:	10000426 	beq	r2,zero,20186c4 <OSFlagNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
 20186b4:	e0bfff17 	ldw	r2,-4(fp)
 20186b8:	00c00484 	movi	r3,18
 20186bc:	10c00005 	stb	r3,0(r2)
        return;
 20186c0:	00003106 	br	2018788 <OSFlagNameSet+0x140>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20186c4:	0005303a 	rdctl	r2,status
 20186c8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20186cc:	e0fff917 	ldw	r3,-28(fp)
 20186d0:	00bfff84 	movi	r2,-2
 20186d4:	1884703a 	and	r2,r3,r2
 20186d8:	1001703a 	wrctl	status,r2
  
  return context;
 20186dc:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 20186e0:	e0bff715 	stw	r2,-36(fp)
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {
 20186e4:	e0bffd17 	ldw	r2,-12(fp)
 20186e8:	10800003 	ldbu	r2,0(r2)
 20186ec:	10803fcc 	andi	r2,r2,255
 20186f0:	10800160 	cmpeqi	r2,r2,5
 20186f4:	1000081e 	bne	r2,zero,2018718 <OSFlagNameSet+0xd0>
 20186f8:	e0bff717 	ldw	r2,-36(fp)
 20186fc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018700:	e0bffa17 	ldw	r2,-24(fp)
 2018704:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_EVENT_TYPE;
 2018708:	e0bfff17 	ldw	r2,-4(fp)
 201870c:	00c00044 	movi	r3,1
 2018710:	10c00005 	stb	r3,0(r2)
        return;
 2018714:	00001c06 	br	2018788 <OSFlagNameSet+0x140>
    }
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 2018718:	e13ffe17 	ldw	r4,-8(fp)
 201871c:	20177e00 	call	20177e0 <OS_StrLen>
 2018720:	e0bff805 	stb	r2,-32(fp)
    if (len > (OS_FLAG_NAME_SIZE - 1)) {         /* No                                                 */
 2018724:	e0bff803 	ldbu	r2,-32(fp)
 2018728:	10800830 	cmpltui	r2,r2,32
 201872c:	1000081e 	bne	r2,zero,2018750 <OSFlagNameSet+0x108>
 2018730:	e0bff717 	ldw	r2,-36(fp)
 2018734:	e0bffb15 	stw	r2,-20(fp)
 2018738:	e0bffb17 	ldw	r2,-20(fp)
 201873c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_FLAG_NAME_TOO_LONG;
 2018740:	e0bfff17 	ldw	r2,-4(fp)
 2018744:	00c01cc4 	movi	r3,115
 2018748:	10c00005 	stb	r3,0(r2)
        return;
 201874c:	00000e06 	br	2018788 <OSFlagNameSet+0x140>
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
 2018750:	e0bffd17 	ldw	r2,-12(fp)
 2018754:	10800284 	addi	r2,r2,10
 2018758:	1009883a 	mov	r4,r2
 201875c:	e17ffe17 	ldw	r5,-8(fp)
 2018760:	20177640 	call	2017764 <OS_StrCopy>
 2018764:	e0bff717 	ldw	r2,-36(fp)
 2018768:	e0bffc15 	stw	r2,-16(fp)
 201876c:	e0bffc17 	ldw	r2,-16(fp)
 2018770:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2018774:	e0bfff17 	ldw	r2,-4(fp)
 2018778:	10000005 	stb	zero,0(r2)
    return;
 201877c:	0001883a 	nop
 2018780:	00000106 	br	2018788 <OSFlagNameSet+0x140>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 2018784:	0001883a 	nop
    }
    (void)OS_StrCopy(pgrp->OSFlagName, pname);   /* Yes, copy name from OS_FLAG_GRP                    */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
    return;
}
 2018788:	e037883a 	mov	sp,fp
 201878c:	dfc00117 	ldw	ra,4(sp)
 2018790:	df000017 	ldw	fp,0(sp)
 2018794:	dec00204 	addi	sp,sp,8
 2018798:	f800283a 	ret

0201879c <OSFlagPend>:
*                 event flags.
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPend (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U wait_type, INT16U timeout, INT8U *perr)
{
 201879c:	deffe204 	addi	sp,sp,-120
 20187a0:	dfc01d15 	stw	ra,116(sp)
 20187a4:	df001c15 	stw	fp,112(sp)
 20187a8:	df001c04 	addi	fp,sp,112
 20187ac:	e13ffc15 	stw	r4,-16(fp)
 20187b0:	2809883a 	mov	r4,r5
 20187b4:	3007883a 	mov	r3,r6
 20187b8:	3805883a 	mov	r2,r7
 20187bc:	e13ffd0d 	sth	r4,-12(fp)
 20187c0:	e0fffe05 	stb	r3,-8(fp)
 20187c4:	e0bfff0d 	sth	r2,-4(fp)
    OS_FLAGS      flags_rdy;
    INT8U         result;
    INT8U         pend_stat;
    BOOLEAN       consume;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 20187c8:	e03fe615 	stw	zero,-104(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 20187cc:	e0800217 	ldw	r2,8(fp)
 20187d0:	1000021e 	bne	r2,zero,20187dc <OSFlagPend+0x40>
        return ((OS_FLAGS)0);
 20187d4:	0005883a 	mov	r2,zero
 20187d8:	00016b06 	br	2018d88 <OSFlagPend+0x5ec>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                        /* Validate 'pgrp'                          */
 20187dc:	e0bffc17 	ldw	r2,-16(fp)
 20187e0:	1000051e 	bne	r2,zero,20187f8 <OSFlagPend+0x5c>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 20187e4:	e0800217 	ldw	r2,8(fp)
 20187e8:	00c01b84 	movi	r3,110
 20187ec:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 20187f0:	0005883a 	mov	r2,zero
 20187f4:	00016406 	br	2018d88 <OSFlagPend+0x5ec>
    }
#endif
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 20187f8:	00808174 	movhi	r2,517
 20187fc:	1090a904 	addi	r2,r2,17060
 2018800:	10800003 	ldbu	r2,0(r2)
 2018804:	10803fcc 	andi	r2,r2,255
 2018808:	10000526 	beq	r2,zero,2018820 <OSFlagPend+0x84>
        *perr = OS_ERR_PEND_ISR;                           /* ... can't PEND from an ISR               */
 201880c:	e0800217 	ldw	r2,8(fp)
 2018810:	00c00084 	movi	r3,2
 2018814:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2018818:	0005883a 	mov	r2,zero
 201881c:	00015a06 	br	2018d88 <OSFlagPend+0x5ec>
    }
    if (OSLockNesting > 0) {                               /* See if called with scheduler locked ...  */
 2018820:	00808174 	movhi	r2,517
 2018824:	10909b04 	addi	r2,r2,17004
 2018828:	10800003 	ldbu	r2,0(r2)
 201882c:	10803fcc 	andi	r2,r2,255
 2018830:	10000526 	beq	r2,zero,2018848 <OSFlagPend+0xac>
        *perr = OS_ERR_PEND_LOCKED;                        /* ... can't PEND when locked               */
 2018834:	e0800217 	ldw	r2,8(fp)
 2018838:	00c00344 	movi	r3,13
 201883c:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2018840:	0005883a 	mov	r2,zero
 2018844:	00015006 	br	2018d88 <OSFlagPend+0x5ec>
    }
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {          /* Validate event block type                */
 2018848:	e0bffc17 	ldw	r2,-16(fp)
 201884c:	10800003 	ldbu	r2,0(r2)
 2018850:	10803fcc 	andi	r2,r2,255
 2018854:	10800160 	cmpeqi	r2,r2,5
 2018858:	1000051e 	bne	r2,zero,2018870 <OSFlagPend+0xd4>
        *perr = OS_ERR_EVENT_TYPE;
 201885c:	e0800217 	ldw	r2,8(fp)
 2018860:	00c00044 	movi	r3,1
 2018864:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2018868:	0005883a 	mov	r2,zero
 201886c:	00014606 	br	2018d88 <OSFlagPend+0x5ec>
    }
    result = (INT8U)(wait_type & OS_FLAG_CONSUME);
 2018870:	e0fffe03 	ldbu	r3,-8(fp)
 2018874:	00bfe004 	movi	r2,-128
 2018878:	1884703a 	and	r2,r3,r2
 201887c:	e0bfe705 	stb	r2,-100(fp)
    if (result != (INT8U)0) {                             /* See if we need to consume the flags      */
 2018880:	e0bfe703 	ldbu	r2,-100(fp)
 2018884:	10000626 	beq	r2,zero,20188a0 <OSFlagPend+0x104>
        wait_type &= ~(INT8U)OS_FLAG_CONSUME;
 2018888:	e0bffe03 	ldbu	r2,-8(fp)
 201888c:	10801fcc 	andi	r2,r2,127
 2018890:	e0bffe05 	stb	r2,-8(fp)
        consume    = OS_TRUE;
 2018894:	00800044 	movi	r2,1
 2018898:	e0bfe505 	stb	r2,-108(fp)
 201889c:	00000106 	br	20188a4 <OSFlagPend+0x108>
    } else {
        consume    = OS_FALSE;
 20188a0:	e03fe505 	stb	zero,-108(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20188a4:	0005303a 	rdctl	r2,status
 20188a8:	e0bfe915 	stw	r2,-92(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20188ac:	e0ffe917 	ldw	r3,-92(fp)
 20188b0:	00bfff84 	movi	r2,-2
 20188b4:	1884703a 	and	r2,r3,r2
 20188b8:	1001703a 	wrctl	status,r2
  
  return context;
 20188bc:	e0bfe917 	ldw	r2,-92(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 20188c0:	e0bfe615 	stw	r2,-104(fp)
    switch (wait_type) {
 20188c4:	e0bffe03 	ldbu	r2,-8(fp)
 20188c8:	10c00060 	cmpeqi	r3,r2,1
 20188cc:	1800951e 	bne	r3,zero,2018b24 <OSFlagPend+0x388>
 20188d0:	10c00088 	cmpgei	r3,r2,2
 20188d4:	1800021e 	bne	r3,zero,20188e0 <OSFlagPend+0x144>
 20188d8:	10006326 	beq	r2,zero,2018a68 <OSFlagPend+0x2cc>
 20188dc:	0000bf06 	br	2018bdc <OSFlagPend+0x440>
 20188e0:	10c000a0 	cmpeqi	r3,r2,2
 20188e4:	1800031e 	bne	r3,zero,20188f4 <OSFlagPend+0x158>
 20188e8:	108000e0 	cmpeqi	r2,r2,3
 20188ec:	1000301e 	bne	r2,zero,20189b0 <OSFlagPend+0x214>
 20188f0:	0000ba06 	br	2018bdc <OSFlagPend+0x440>
        case OS_FLAG_WAIT_SET_ALL:                         /* See if all required flags are set        */
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);   /* Extract only the bits we want     */
 20188f4:	e0bffc17 	ldw	r2,-16(fp)
 20188f8:	10c0020b 	ldhu	r3,8(r2)
 20188fc:	e0bffd0b 	ldhu	r2,-12(fp)
 2018900:	1884703a 	and	r2,r3,r2
 2018904:	e0bfe78d 	sth	r2,-98(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2018908:	e0ffe78b 	ldhu	r3,-98(fp)
 201890c:	e0bffd0b 	ldhu	r2,-12(fp)
 2018910:	1880191e 	bne	r3,r2,2018978 <OSFlagPend+0x1dc>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2018914:	e0bfe503 	ldbu	r2,-108(fp)
 2018918:	10800058 	cmpnei	r2,r2,1
 201891c:	1000091e 	bne	r2,zero,2018944 <OSFlagPend+0x1a8>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we wanted      */
 2018920:	e0bffc17 	ldw	r2,-16(fp)
 2018924:	1080020b 	ldhu	r2,8(r2)
 2018928:	1007883a 	mov	r3,r2
 201892c:	e0bfe78b 	ldhu	r2,-98(fp)
 2018930:	0084303a 	nor	r2,zero,r2
 2018934:	1884703a 	and	r2,r3,r2
 2018938:	1007883a 	mov	r3,r2
 201893c:	e0bffc17 	ldw	r2,-16(fp)
 2018940:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 2018944:	00808174 	movhi	r2,517
 2018948:	1090aa04 	addi	r2,r2,17064
 201894c:	10800017 	ldw	r2,0(r2)
 2018950:	e0ffe78b 	ldhu	r3,-98(fp)
 2018954:	10c00b0d 	sth	r3,44(r2)
 2018958:	e0bfe617 	ldw	r2,-104(fp)
 201895c:	e0bfea15 	stw	r2,-88(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018960:	e0bfea17 	ldw	r2,-88(fp)
 2018964:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 2018968:	e0800217 	ldw	r2,8(fp)
 201896c:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 2018970:	e0bfe78b 	ldhu	r2,-98(fp)
 2018974:	00010406 	br	2018d88 <OSFlagPend+0x5ec>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2018978:	e0fffd0b 	ldhu	r3,-12(fp)
 201897c:	e0bffe03 	ldbu	r2,-8(fp)
 2018980:	e13fff0b 	ldhu	r4,-4(fp)
 2018984:	e17ff704 	addi	r5,fp,-36
 2018988:	d9000015 	stw	r4,0(sp)
 201898c:	e13ffc17 	ldw	r4,-16(fp)
 2018990:	180d883a 	mov	r6,r3
 2018994:	100f883a 	mov	r7,r2
 2018998:	201925c0 	call	201925c <OS_FlagBlock>
 201899c:	e0bfe617 	ldw	r2,-104(fp)
 20189a0:	e0bfeb15 	stw	r2,-84(fp)
 20189a4:	e0bfeb17 	ldw	r2,-84(fp)
 20189a8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 20189ac:	00009506 	br	2018c04 <OSFlagPend+0x468>

        case OS_FLAG_WAIT_SET_ANY:
             flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & flags);    /* Extract only the bits we want    */
 20189b0:	e0bffc17 	ldw	r2,-16(fp)
 20189b4:	10c0020b 	ldhu	r3,8(r2)
 20189b8:	e0bffd0b 	ldhu	r2,-12(fp)
 20189bc:	1884703a 	and	r2,r3,r2
 20189c0:	e0bfe78d 	sth	r2,-98(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag set                      */
 20189c4:	e0bfe78b 	ldhu	r2,-98(fp)
 20189c8:	10001926 	beq	r2,zero,2018a30 <OSFlagPend+0x294>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 20189cc:	e0bfe503 	ldbu	r2,-108(fp)
 20189d0:	10800058 	cmpnei	r2,r2,1
 20189d4:	1000091e 	bne	r2,zero,20189fc <OSFlagPend+0x260>
                     pgrp->OSFlagFlags &= ~flags_rdy;      /* Clear ONLY the flags that we got         */
 20189d8:	e0bffc17 	ldw	r2,-16(fp)
 20189dc:	1080020b 	ldhu	r2,8(r2)
 20189e0:	1007883a 	mov	r3,r2
 20189e4:	e0bfe78b 	ldhu	r2,-98(fp)
 20189e8:	0084303a 	nor	r2,zero,r2
 20189ec:	1884703a 	and	r2,r3,r2
 20189f0:	1007883a 	mov	r3,r2
 20189f4:	e0bffc17 	ldw	r2,-16(fp)
 20189f8:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 20189fc:	00808174 	movhi	r2,517
 2018a00:	1090aa04 	addi	r2,r2,17064
 2018a04:	10800017 	ldw	r2,0(r2)
 2018a08:	e0ffe78b 	ldhu	r3,-98(fp)
 2018a0c:	10c00b0d 	sth	r3,44(r2)
 2018a10:	e0bfe617 	ldw	r2,-104(fp)
 2018a14:	e0bfec15 	stw	r2,-80(fp)
 2018a18:	e0bfec17 	ldw	r2,-80(fp)
 2018a1c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 2018a20:	e0800217 	ldw	r2,8(fp)
 2018a24:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 2018a28:	e0bfe78b 	ldhu	r2,-98(fp)
 2018a2c:	0000d606 	br	2018d88 <OSFlagPend+0x5ec>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2018a30:	e0fffd0b 	ldhu	r3,-12(fp)
 2018a34:	e0bffe03 	ldbu	r2,-8(fp)
 2018a38:	e13fff0b 	ldhu	r4,-4(fp)
 2018a3c:	e17ff704 	addi	r5,fp,-36
 2018a40:	d9000015 	stw	r4,0(sp)
 2018a44:	e13ffc17 	ldw	r4,-16(fp)
 2018a48:	180d883a 	mov	r6,r3
 2018a4c:	100f883a 	mov	r7,r2
 2018a50:	201925c0 	call	201925c <OS_FlagBlock>
 2018a54:	e0bfe617 	ldw	r2,-104(fp)
 2018a58:	e0bfed15 	stw	r2,-76(fp)
 2018a5c:	e0bfed17 	ldw	r2,-76(fp)
 2018a60:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 2018a64:	00006706 	br	2018c04 <OSFlagPend+0x468>

#if OS_FLAG_WAIT_CLR_EN > 0
        case OS_FLAG_WAIT_CLR_ALL:                         /* See if all required flags are cleared    */
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags);  /* Extract only the bits we want     */
 2018a68:	e0bffc17 	ldw	r2,-16(fp)
 2018a6c:	1080020b 	ldhu	r2,8(r2)
 2018a70:	0084303a 	nor	r2,zero,r2
 2018a74:	1007883a 	mov	r3,r2
 2018a78:	e0bffd0b 	ldhu	r2,-12(fp)
 2018a7c:	1884703a 	and	r2,r3,r2
 2018a80:	e0bfe78d 	sth	r2,-98(fp)
             if (flags_rdy == flags) {                     /* Must match ALL the bits that we want     */
 2018a84:	e0ffe78b 	ldhu	r3,-98(fp)
 2018a88:	e0bffd0b 	ldhu	r2,-12(fp)
 2018a8c:	1880171e 	bne	r3,r2,2018aec <OSFlagPend+0x350>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2018a90:	e0bfe503 	ldbu	r2,-108(fp)
 2018a94:	10800058 	cmpnei	r2,r2,1
 2018a98:	1000071e 	bne	r2,zero,2018ab8 <OSFlagPend+0x31c>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we wanted        */
 2018a9c:	e0bffc17 	ldw	r2,-16(fp)
 2018aa0:	10c0020b 	ldhu	r3,8(r2)
 2018aa4:	e0bfe78b 	ldhu	r2,-98(fp)
 2018aa8:	1884b03a 	or	r2,r3,r2
 2018aac:	1007883a 	mov	r3,r2
 2018ab0:	e0bffc17 	ldw	r2,-16(fp)
 2018ab4:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 2018ab8:	00808174 	movhi	r2,517
 2018abc:	1090aa04 	addi	r2,r2,17064
 2018ac0:	10800017 	ldw	r2,0(r2)
 2018ac4:	e0ffe78b 	ldhu	r3,-98(fp)
 2018ac8:	10c00b0d 	sth	r3,44(r2)
 2018acc:	e0bfe617 	ldw	r2,-104(fp)
 2018ad0:	e0bfee15 	stw	r2,-72(fp)
 2018ad4:	e0bfee17 	ldw	r2,-72(fp)
 2018ad8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 2018adc:	e0800217 	ldw	r2,8(fp)
 2018ae0:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 2018ae4:	e0bfe78b 	ldhu	r2,-98(fp)
 2018ae8:	0000a706 	br	2018d88 <OSFlagPend+0x5ec>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2018aec:	e0fffd0b 	ldhu	r3,-12(fp)
 2018af0:	e0bffe03 	ldbu	r2,-8(fp)
 2018af4:	e13fff0b 	ldhu	r4,-4(fp)
 2018af8:	e17ff704 	addi	r5,fp,-36
 2018afc:	d9000015 	stw	r4,0(sp)
 2018b00:	e13ffc17 	ldw	r4,-16(fp)
 2018b04:	180d883a 	mov	r6,r3
 2018b08:	100f883a 	mov	r7,r2
 2018b0c:	201925c0 	call	201925c <OS_FlagBlock>
 2018b10:	e0bfe617 	ldw	r2,-104(fp)
 2018b14:	e0bfef15 	stw	r2,-68(fp)
 2018b18:	e0bfef17 	ldw	r2,-68(fp)
 2018b1c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 2018b20:	00003806 	br	2018c04 <OSFlagPend+0x468>

        case OS_FLAG_WAIT_CLR_ANY:
             flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & flags); /* Extract only the bits we want      */
 2018b24:	e0bffc17 	ldw	r2,-16(fp)
 2018b28:	1080020b 	ldhu	r2,8(r2)
 2018b2c:	0084303a 	nor	r2,zero,r2
 2018b30:	1007883a 	mov	r3,r2
 2018b34:	e0bffd0b 	ldhu	r2,-12(fp)
 2018b38:	1884703a 	and	r2,r3,r2
 2018b3c:	e0bfe78d 	sth	r2,-98(fp)
             if (flags_rdy != (OS_FLAGS)0) {               /* See if any flag cleared                  */
 2018b40:	e0bfe78b 	ldhu	r2,-98(fp)
 2018b44:	10001726 	beq	r2,zero,2018ba4 <OSFlagPend+0x408>
                 if (consume == OS_TRUE) {                 /* See if we need to consume the flags      */
 2018b48:	e0bfe503 	ldbu	r2,-108(fp)
 2018b4c:	10800058 	cmpnei	r2,r2,1
 2018b50:	1000071e 	bne	r2,zero,2018b70 <OSFlagPend+0x3d4>
                     pgrp->OSFlagFlags |= flags_rdy;       /* Set ONLY the flags that we got           */
 2018b54:	e0bffc17 	ldw	r2,-16(fp)
 2018b58:	10c0020b 	ldhu	r3,8(r2)
 2018b5c:	e0bfe78b 	ldhu	r2,-98(fp)
 2018b60:	1884b03a 	or	r2,r3,r2
 2018b64:	1007883a 	mov	r3,r2
 2018b68:	e0bffc17 	ldw	r2,-16(fp)
 2018b6c:	10c0020d 	sth	r3,8(r2)
                 }
                 OSTCBCur->OSTCBFlagsRdy = flags_rdy;      /* Save flags that were ready               */
 2018b70:	00808174 	movhi	r2,517
 2018b74:	1090aa04 	addi	r2,r2,17064
 2018b78:	10800017 	ldw	r2,0(r2)
 2018b7c:	e0ffe78b 	ldhu	r3,-98(fp)
 2018b80:	10c00b0d 	sth	r3,44(r2)
 2018b84:	e0bfe617 	ldw	r2,-104(fp)
 2018b88:	e0bff015 	stw	r2,-64(fp)
 2018b8c:	e0bff017 	ldw	r2,-64(fp)
 2018b90:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();                       /* Yes, condition met, return to caller     */
                 *perr                   = OS_ERR_NONE;
 2018b94:	e0800217 	ldw	r2,8(fp)
 2018b98:	10000005 	stb	zero,0(r2)
                 return (flags_rdy);
 2018b9c:	e0bfe78b 	ldhu	r2,-98(fp)
 2018ba0:	00007906 	br	2018d88 <OSFlagPend+0x5ec>
             } else {                                      /* Block task until events occur or timeout */
                 OS_FlagBlock(pgrp, &node, flags, wait_type, timeout);
 2018ba4:	e0fffd0b 	ldhu	r3,-12(fp)
 2018ba8:	e0bffe03 	ldbu	r2,-8(fp)
 2018bac:	e13fff0b 	ldhu	r4,-4(fp)
 2018bb0:	e17ff704 	addi	r5,fp,-36
 2018bb4:	d9000015 	stw	r4,0(sp)
 2018bb8:	e13ffc17 	ldw	r4,-16(fp)
 2018bbc:	180d883a 	mov	r6,r3
 2018bc0:	100f883a 	mov	r7,r2
 2018bc4:	201925c0 	call	201925c <OS_FlagBlock>
 2018bc8:	e0bfe617 	ldw	r2,-104(fp)
 2018bcc:	e0bff115 	stw	r2,-60(fp)
 2018bd0:	e0bff117 	ldw	r2,-60(fp)
 2018bd4:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
             }
             break;
 2018bd8:	00000a06 	br	2018c04 <OSFlagPend+0x468>
 2018bdc:	e0bfe617 	ldw	r2,-104(fp)
 2018be0:	e0bff215 	stw	r2,-56(fp)
 2018be4:	e0bff217 	ldw	r2,-56(fp)
 2018be8:	1001703a 	wrctl	status,r2
#endif

        default:
             OS_EXIT_CRITICAL();
             flags_rdy = (OS_FLAGS)0;
 2018bec:	e03fe78d 	sth	zero,-98(fp)
             *perr      = OS_ERR_FLAG_WAIT_TYPE;
 2018bf0:	e0800217 	ldw	r2,8(fp)
 2018bf4:	00c01bc4 	movi	r3,111
 2018bf8:	10c00005 	stb	r3,0(r2)
             return (flags_rdy);
 2018bfc:	e0bfe78b 	ldhu	r2,-98(fp)
 2018c00:	00006106 	br	2018d88 <OSFlagPend+0x5ec>
    }
/*$PAGE*/
    OS_Sched();                                            /* Find next HPT ready to run               */
 2018c04:	20176280 	call	2017628 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018c08:	0005303a 	rdctl	r2,status
 2018c0c:	e0bff315 	stw	r2,-52(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018c10:	e0fff317 	ldw	r3,-52(fp)
 2018c14:	00bfff84 	movi	r2,-2
 2018c18:	1884703a 	and	r2,r3,r2
 2018c1c:	1001703a 	wrctl	status,r2
  
  return context;
 2018c20:	e0bff317 	ldw	r2,-52(fp)
    OS_ENTER_CRITICAL();
 2018c24:	e0bfe615 	stw	r2,-104(fp)
    if (OSTCBCur->OSTCBStatPend != OS_STAT_PEND_OK) {      /* Have we timed-out or aborted?            */
 2018c28:	00808174 	movhi	r2,517
 2018c2c:	1090aa04 	addi	r2,r2,17064
 2018c30:	10800017 	ldw	r2,0(r2)
 2018c34:	10800c43 	ldbu	r2,49(r2)
 2018c38:	10803fcc 	andi	r2,r2,255
 2018c3c:	10002226 	beq	r2,zero,2018cc8 <OSFlagPend+0x52c>
        pend_stat                = OSTCBCur->OSTCBStatPend;
 2018c40:	00808174 	movhi	r2,517
 2018c44:	1090aa04 	addi	r2,r2,17064
 2018c48:	10800017 	ldw	r2,0(r2)
 2018c4c:	10800c43 	ldbu	r2,49(r2)
 2018c50:	e0bfe805 	stb	r2,-96(fp)
        OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2018c54:	00808174 	movhi	r2,517
 2018c58:	1090aa04 	addi	r2,r2,17064
 2018c5c:	10800017 	ldw	r2,0(r2)
 2018c60:	10000c45 	stb	zero,49(r2)
        OS_FlagUnlink(&node);
 2018c64:	e0bff704 	addi	r2,fp,-36
 2018c68:	1009883a 	mov	r4,r2
 2018c6c:	201960c0 	call	201960c <OS_FlagUnlink>
        OSTCBCur->OSTCBStat      = OS_STAT_RDY;            /* Yes, make task ready-to-run              */
 2018c70:	00808174 	movhi	r2,517
 2018c74:	1090aa04 	addi	r2,r2,17064
 2018c78:	10800017 	ldw	r2,0(r2)
 2018c7c:	10000c05 	stb	zero,48(r2)
 2018c80:	e0bfe617 	ldw	r2,-104(fp)
 2018c84:	e0bff415 	stw	r2,-48(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018c88:	e0bff417 	ldw	r2,-48(fp)
 2018c8c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        flags_rdy                = (OS_FLAGS)0;
 2018c90:	e03fe78d 	sth	zero,-98(fp)
        switch (pend_stat) {
 2018c94:	e0bfe803 	ldbu	r2,-96(fp)
 2018c98:	108000a0 	cmpeqi	r2,r2,2
 2018c9c:	10000426 	beq	r2,zero,2018cb0 <OSFlagPend+0x514>
            case OS_STAT_PEND_ABORT:
                 *perr = OS_ERR_PEND_ABORT;                 /* Indicate that we aborted   waiting       */
 2018ca0:	e0800217 	ldw	r2,8(fp)
 2018ca4:	00c00384 	movi	r3,14
 2018ca8:	10c00005 	stb	r3,0(r2)
                 break;
 2018cac:	00000406 	br	2018cc0 <OSFlagPend+0x524>

            case OS_STAT_PEND_TO:
            default:
                 *perr = OS_ERR_TIMEOUT;                    /* Indicate that we timed-out waiting       */
 2018cb0:	e0800217 	ldw	r2,8(fp)
 2018cb4:	00c00284 	movi	r3,10
 2018cb8:	10c00005 	stb	r3,0(r2)
                 break;
 2018cbc:	0001883a 	nop
        }
        return (flags_rdy);
 2018cc0:	e0bfe78b 	ldhu	r2,-98(fp)
 2018cc4:	00003006 	br	2018d88 <OSFlagPend+0x5ec>
    }
    flags_rdy = OSTCBCur->OSTCBFlagsRdy;
 2018cc8:	00808174 	movhi	r2,517
 2018ccc:	1090aa04 	addi	r2,r2,17064
 2018cd0:	10800017 	ldw	r2,0(r2)
 2018cd4:	10800b0b 	ldhu	r2,44(r2)
 2018cd8:	e0bfe78d 	sth	r2,-98(fp)
    if (consume == OS_TRUE) {                              /* See if we need to consume the flags      */
 2018cdc:	e0bfe503 	ldbu	r2,-108(fp)
 2018ce0:	10800058 	cmpnei	r2,r2,1
 2018ce4:	1000211e 	bne	r2,zero,2018d6c <OSFlagPend+0x5d0>
        switch (wait_type) {
 2018ce8:	e0bffe03 	ldbu	r2,-8(fp)
 2018cec:	10001616 	blt	r2,zero,2018d48 <OSFlagPend+0x5ac>
 2018cf0:	10c00090 	cmplti	r3,r2,2
 2018cf4:	18000c1e 	bne	r3,zero,2018d28 <OSFlagPend+0x58c>
 2018cf8:	10800108 	cmpgei	r2,r2,4
 2018cfc:	1000121e 	bne	r2,zero,2018d48 <OSFlagPend+0x5ac>
            case OS_FLAG_WAIT_SET_ALL:
            case OS_FLAG_WAIT_SET_ANY:                     /* Clear ONLY the flags we got              */
                 pgrp->OSFlagFlags &= ~flags_rdy;
 2018d00:	e0bffc17 	ldw	r2,-16(fp)
 2018d04:	1080020b 	ldhu	r2,8(r2)
 2018d08:	1007883a 	mov	r3,r2
 2018d0c:	e0bfe78b 	ldhu	r2,-98(fp)
 2018d10:	0084303a 	nor	r2,zero,r2
 2018d14:	1884703a 	and	r2,r3,r2
 2018d18:	1007883a 	mov	r3,r2
 2018d1c:	e0bffc17 	ldw	r2,-16(fp)
 2018d20:	10c0020d 	sth	r3,8(r2)
                 break;
 2018d24:	00001106 	br	2018d6c <OSFlagPend+0x5d0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:
            case OS_FLAG_WAIT_CLR_ANY:                     /* Set   ONLY the flags we got              */
                 pgrp->OSFlagFlags |=  flags_rdy;
 2018d28:	e0bffc17 	ldw	r2,-16(fp)
 2018d2c:	10c0020b 	ldhu	r3,8(r2)
 2018d30:	e0bfe78b 	ldhu	r2,-98(fp)
 2018d34:	1884b03a 	or	r2,r3,r2
 2018d38:	1007883a 	mov	r3,r2
 2018d3c:	e0bffc17 	ldw	r2,-16(fp)
 2018d40:	10c0020d 	sth	r3,8(r2)
                 break;
 2018d44:	00000906 	br	2018d6c <OSFlagPend+0x5d0>
 2018d48:	e0bfe617 	ldw	r2,-104(fp)
 2018d4c:	e0bff515 	stw	r2,-44(fp)
 2018d50:	e0bff517 	ldw	r2,-44(fp)
 2018d54:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 2018d58:	e0800217 	ldw	r2,8(fp)
 2018d5c:	00c01bc4 	movi	r3,111
 2018d60:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 2018d64:	0005883a 	mov	r2,zero
 2018d68:	00000706 	br	2018d88 <OSFlagPend+0x5ec>
 2018d6c:	e0bfe617 	ldw	r2,-104(fp)
 2018d70:	e0bff615 	stw	r2,-40(fp)
 2018d74:	e0bff617 	ldw	r2,-40(fp)
 2018d78:	1001703a 	wrctl	status,r2
        }
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;                                   /* Event(s) must have occurred              */
 2018d7c:	e0800217 	ldw	r2,8(fp)
 2018d80:	10000005 	stb	zero,0(r2)
    return (flags_rdy);
 2018d84:	e0bfe78b 	ldhu	r2,-98(fp)
}
 2018d88:	e037883a 	mov	sp,fp
 2018d8c:	dfc00117 	ldw	ra,4(sp)
 2018d90:	df000017 	ldw	fp,0(sp)
 2018d94:	dec00204 	addi	sp,sp,8
 2018d98:	f800283a 	ret

02018d9c <OSFlagPendGetFlagsRdy>:
* Called from: Task ONLY
*********************************************************************************************************
*/

OS_FLAGS  OSFlagPendGetFlagsRdy (void)
{
 2018d9c:	defffb04 	addi	sp,sp,-20
 2018da0:	df000415 	stw	fp,16(sp)
 2018da4:	df000404 	addi	fp,sp,16
    OS_FLAGS      flags;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR     cpu_sr = 0;
 2018da8:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018dac:	0005303a 	rdctl	r2,status
 2018db0:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018db4:	e0fffe17 	ldw	r3,-8(fp)
 2018db8:	00bfff84 	movi	r2,-2
 2018dbc:	1884703a 	and	r2,r3,r2
 2018dc0:	1001703a 	wrctl	status,r2
  
  return context;
 2018dc4:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 2018dc8:	e0bffc15 	stw	r2,-16(fp)
    flags = OSTCBCur->OSTCBFlagsRdy;
 2018dcc:	00808174 	movhi	r2,517
 2018dd0:	1090aa04 	addi	r2,r2,17064
 2018dd4:	10800017 	ldw	r2,0(r2)
 2018dd8:	10800b0b 	ldhu	r2,44(r2)
 2018ddc:	e0bffd0d 	sth	r2,-12(fp)
 2018de0:	e0bffc17 	ldw	r2,-16(fp)
 2018de4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018de8:	e0bfff17 	ldw	r2,-4(fp)
 2018dec:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (flags);
 2018df0:	e0bffd0b 	ldhu	r2,-12(fp)
}
 2018df4:	e037883a 	mov	sp,fp
 2018df8:	df000017 	ldw	fp,0(sp)
 2018dfc:	dec00104 	addi	sp,sp,4
 2018e00:	f800283a 	ret

02018e04 <OSFlagPost>:
*              2) The amount of time interrupts are DISABLED depends on the number of tasks waiting on
*                 the event flag group.
*********************************************************************************************************
*/
OS_FLAGS  OSFlagPost (OS_FLAG_GRP *pgrp, OS_FLAGS flags, INT8U opt, INT8U *perr)
{
 2018e04:	deffef04 	addi	sp,sp,-68
 2018e08:	dfc01015 	stw	ra,64(sp)
 2018e0c:	df000f15 	stw	fp,60(sp)
 2018e10:	df000f04 	addi	fp,sp,60
 2018e14:	e13ffc15 	stw	r4,-16(fp)
 2018e18:	2807883a 	mov	r3,r5
 2018e1c:	3005883a 	mov	r2,r6
 2018e20:	e1ffff15 	stw	r7,-4(fp)
 2018e24:	e0fffd0d 	sth	r3,-12(fp)
 2018e28:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN       sched;
    OS_FLAGS      flags_cur;
    OS_FLAGS      flags_rdy;
    BOOLEAN       rdy;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR     cpu_sr = 0;
 2018e2c:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 2018e30:	e0bfff17 	ldw	r2,-4(fp)
 2018e34:	1000021e 	bne	r2,zero,2018e40 <OSFlagPost+0x3c>
        return ((OS_FLAGS)0);
 2018e38:	0005883a 	mov	r2,zero
 2018e3c:	0000d106 	br	2019184 <OSFlagPost+0x380>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {                  /* Validate 'pgrp'                                */
 2018e40:	e0bffc17 	ldw	r2,-16(fp)
 2018e44:	1000051e 	bne	r2,zero,2018e5c <OSFlagPost+0x58>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 2018e48:	e0bfff17 	ldw	r2,-4(fp)
 2018e4c:	00c01b84 	movi	r3,110
 2018e50:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2018e54:	0005883a 	mov	r2,zero
 2018e58:	0000ca06 	br	2019184 <OSFlagPost+0x380>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) {    /* Make sure we are pointing to an event flag grp */
 2018e5c:	e0bffc17 	ldw	r2,-16(fp)
 2018e60:	10800003 	ldbu	r2,0(r2)
 2018e64:	10803fcc 	andi	r2,r2,255
 2018e68:	10800160 	cmpeqi	r2,r2,5
 2018e6c:	1000051e 	bne	r2,zero,2018e84 <OSFlagPost+0x80>
        *perr = OS_ERR_EVENT_TYPE;
 2018e70:	e0bfff17 	ldw	r2,-4(fp)
 2018e74:	00c00044 	movi	r3,1
 2018e78:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 2018e7c:	0005883a 	mov	r2,zero
 2018e80:	0000c006 	br	2019184 <OSFlagPost+0x380>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2018e84:	0005303a 	rdctl	r2,status
 2018e88:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2018e8c:	e0fff617 	ldw	r3,-40(fp)
 2018e90:	00bfff84 	movi	r2,-2
 2018e94:	1884703a 	and	r2,r3,r2
 2018e98:	1001703a 	wrctl	status,r2
  
  return context;
 2018e9c:	e0bff617 	ldw	r2,-40(fp)
    }
/*$PAGE*/
    OS_ENTER_CRITICAL();
 2018ea0:	e0bff315 	stw	r2,-52(fp)
    switch (opt) {
 2018ea4:	e0bffe03 	ldbu	r2,-8(fp)
 2018ea8:	10000326 	beq	r2,zero,2018eb8 <OSFlagPost+0xb4>
 2018eac:	10800060 	cmpeqi	r2,r2,1
 2018eb0:	10000b1e 	bne	r2,zero,2018ee0 <OSFlagPost+0xdc>
 2018eb4:	00001206 	br	2018f00 <OSFlagPost+0xfc>
        case OS_FLAG_CLR:
             pgrp->OSFlagFlags &= ~flags;            /* Clear the flags specified in the group         */
 2018eb8:	e0bffc17 	ldw	r2,-16(fp)
 2018ebc:	1080020b 	ldhu	r2,8(r2)
 2018ec0:	1007883a 	mov	r3,r2
 2018ec4:	e0bffd0b 	ldhu	r2,-12(fp)
 2018ec8:	0084303a 	nor	r2,zero,r2
 2018ecc:	1884703a 	and	r2,r3,r2
 2018ed0:	1007883a 	mov	r3,r2
 2018ed4:	e0bffc17 	ldw	r2,-16(fp)
 2018ed8:	10c0020d 	sth	r3,8(r2)
             break;
 2018edc:	00001106 	br	2018f24 <OSFlagPost+0x120>

        case OS_FLAG_SET:
             pgrp->OSFlagFlags |=  flags;            /* Set   the flags specified in the group         */
 2018ee0:	e0bffc17 	ldw	r2,-16(fp)
 2018ee4:	10c0020b 	ldhu	r3,8(r2)
 2018ee8:	e0bffd0b 	ldhu	r2,-12(fp)
 2018eec:	1884b03a 	or	r2,r3,r2
 2018ef0:	1007883a 	mov	r3,r2
 2018ef4:	e0bffc17 	ldw	r2,-16(fp)
 2018ef8:	10c0020d 	sth	r3,8(r2)
             break;
 2018efc:	00000906 	br	2018f24 <OSFlagPost+0x120>
 2018f00:	e0bff317 	ldw	r2,-52(fp)
 2018f04:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2018f08:	e0bff717 	ldw	r2,-36(fp)
 2018f0c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();                     /* INVALID option                                 */
             *perr = OS_ERR_FLAG_INVALID_OPT;
 2018f10:	e0bfff17 	ldw	r2,-4(fp)
 2018f14:	00c01c44 	movi	r3,113
 2018f18:	10c00005 	stb	r3,0(r2)
             return ((OS_FLAGS)0);
 2018f1c:	0005883a 	mov	r2,zero
 2018f20:	00009806 	br	2019184 <OSFlagPost+0x380>
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
 2018f24:	e03ff205 	stb	zero,-56(fp)
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2018f28:	e0bffc17 	ldw	r2,-16(fp)
 2018f2c:	10800117 	ldw	r2,4(r2)
 2018f30:	e0bff115 	stw	r2,-60(fp)
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 2018f34:	00007706 	br	2019114 <OSFlagPost+0x310>
        switch (pnode->OSFlagNodeWaitType) {
 2018f38:	e0bff117 	ldw	r2,-60(fp)
 2018f3c:	10800483 	ldbu	r2,18(r2)
 2018f40:	10803fcc 	andi	r2,r2,255
 2018f44:	10c00060 	cmpeqi	r3,r2,1
 2018f48:	18004a1e 	bne	r3,zero,2019074 <OSFlagPost+0x270>
 2018f4c:	10c00088 	cmpgei	r3,r2,2
 2018f50:	1800021e 	bne	r3,zero,2018f5c <OSFlagPost+0x158>
 2018f54:	10002f26 	beq	r2,zero,2019014 <OSFlagPost+0x210>
 2018f58:	00005b06 	br	20190c8 <OSFlagPost+0x2c4>
 2018f5c:	10c000a0 	cmpeqi	r3,r2,2
 2018f60:	1800031e 	bne	r3,zero,2018f70 <OSFlagPost+0x16c>
 2018f64:	108000e0 	cmpeqi	r2,r2,3
 2018f68:	1000171e 	bne	r2,zero,2018fc8 <OSFlagPost+0x1c4>
 2018f6c:	00005606 	br	20190c8 <OSFlagPost+0x2c4>
            case OS_FLAG_WAIT_SET_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2018f70:	e0bffc17 	ldw	r2,-16(fp)
 2018f74:	10c0020b 	ldhu	r3,8(r2)
 2018f78:	e0bff117 	ldw	r2,-60(fp)
 2018f7c:	1080040b 	ldhu	r2,16(r2)
 2018f80:	1884703a 	and	r2,r3,r2
 2018f84:	e0bff40d 	sth	r2,-48(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 2018f88:	e0bff117 	ldw	r2,-60(fp)
 2018f8c:	1080040b 	ldhu	r2,16(r2)
 2018f90:	10ffffcc 	andi	r3,r2,65535
 2018f94:	e0bff40b 	ldhu	r2,-48(fp)
 2018f98:	1880541e 	bne	r3,r2,20190ec <OSFlagPost+0x2e8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2018f9c:	e0bff40b 	ldhu	r2,-48(fp)
 2018fa0:	e13ff117 	ldw	r4,-60(fp)
 2018fa4:	100b883a 	mov	r5,r2
 2018fa8:	20195000 	call	2019500 <OS_FlagTaskRdy>
 2018fac:	e0bff485 	stb	r2,-46(fp)
                     if (rdy == OS_TRUE) {
 2018fb0:	e0bff483 	ldbu	r2,-46(fp)
 2018fb4:	10800058 	cmpnei	r2,r2,1
 2018fb8:	10004c1e 	bne	r2,zero,20190ec <OSFlagPost+0x2e8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2018fbc:	00800044 	movi	r2,1
 2018fc0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2018fc4:	00004906 	br	20190ec <OSFlagPost+0x2e8>

            case OS_FLAG_WAIT_SET_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2018fc8:	e0bffc17 	ldw	r2,-16(fp)
 2018fcc:	10c0020b 	ldhu	r3,8(r2)
 2018fd0:	e0bff117 	ldw	r2,-60(fp)
 2018fd4:	1080040b 	ldhu	r2,16(r2)
 2018fd8:	1884703a 	and	r2,r3,r2
 2018fdc:	e0bff40d 	sth	r2,-48(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 2018fe0:	e0bff40b 	ldhu	r2,-48(fp)
 2018fe4:	10004326 	beq	r2,zero,20190f4 <OSFlagPost+0x2f0>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2018fe8:	e0bff40b 	ldhu	r2,-48(fp)
 2018fec:	e13ff117 	ldw	r4,-60(fp)
 2018ff0:	100b883a 	mov	r5,r2
 2018ff4:	20195000 	call	2019500 <OS_FlagTaskRdy>
 2018ff8:	e0bff485 	stb	r2,-46(fp)
                     if (rdy == OS_TRUE) {
 2018ffc:	e0bff483 	ldbu	r2,-46(fp)
 2019000:	10800058 	cmpnei	r2,r2,1
 2019004:	10003b1e 	bne	r2,zero,20190f4 <OSFlagPost+0x2f0>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2019008:	00800044 	movi	r2,1
 201900c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2019010:	00003806 	br	20190f4 <OSFlagPost+0x2f0>

#if OS_FLAG_WAIT_CLR_EN > 0
            case OS_FLAG_WAIT_CLR_ALL:               /* See if all req. flags are set for current node */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2019014:	e0bffc17 	ldw	r2,-16(fp)
 2019018:	1080020b 	ldhu	r2,8(r2)
 201901c:	0084303a 	nor	r2,zero,r2
 2019020:	1007883a 	mov	r3,r2
 2019024:	e0bff117 	ldw	r2,-60(fp)
 2019028:	1080040b 	ldhu	r2,16(r2)
 201902c:	1884703a 	and	r2,r3,r2
 2019030:	e0bff40d 	sth	r2,-48(fp)
                 if (flags_rdy == pnode->OSFlagNodeFlags) {
 2019034:	e0bff117 	ldw	r2,-60(fp)
 2019038:	1080040b 	ldhu	r2,16(r2)
 201903c:	10ffffcc 	andi	r3,r2,65535
 2019040:	e0bff40b 	ldhu	r2,-48(fp)
 2019044:	18802d1e 	bne	r3,r2,20190fc <OSFlagPost+0x2f8>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 2019048:	e0bff40b 	ldhu	r2,-48(fp)
 201904c:	e13ff117 	ldw	r4,-60(fp)
 2019050:	100b883a 	mov	r5,r2
 2019054:	20195000 	call	2019500 <OS_FlagTaskRdy>
 2019058:	e0bff485 	stb	r2,-46(fp)
                     if (rdy == OS_TRUE) {
 201905c:	e0bff483 	ldbu	r2,-46(fp)
 2019060:	10800058 	cmpnei	r2,r2,1
 2019064:	1000251e 	bne	r2,zero,20190fc <OSFlagPost+0x2f8>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 2019068:	00800044 	movi	r2,1
 201906c:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 2019070:	00002206 	br	20190fc <OSFlagPost+0x2f8>

            case OS_FLAG_WAIT_CLR_ANY:               /* See if any flag set                            */
                 flags_rdy = (OS_FLAGS)(~pgrp->OSFlagFlags & pnode->OSFlagNodeFlags);
 2019074:	e0bffc17 	ldw	r2,-16(fp)
 2019078:	1080020b 	ldhu	r2,8(r2)
 201907c:	0084303a 	nor	r2,zero,r2
 2019080:	1007883a 	mov	r3,r2
 2019084:	e0bff117 	ldw	r2,-60(fp)
 2019088:	1080040b 	ldhu	r2,16(r2)
 201908c:	1884703a 	and	r2,r3,r2
 2019090:	e0bff40d 	sth	r2,-48(fp)
                 if (flags_rdy != (OS_FLAGS)0) {
 2019094:	e0bff40b 	ldhu	r2,-48(fp)
 2019098:	10001a26 	beq	r2,zero,2019104 <OSFlagPost+0x300>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
 201909c:	e0bff40b 	ldhu	r2,-48(fp)
 20190a0:	e13ff117 	ldw	r4,-60(fp)
 20190a4:	100b883a 	mov	r5,r2
 20190a8:	20195000 	call	2019500 <OS_FlagTaskRdy>
 20190ac:	e0bff485 	stb	r2,-46(fp)
                     if (rdy == OS_TRUE) {
 20190b0:	e0bff483 	ldbu	r2,-46(fp)
 20190b4:	10800058 	cmpnei	r2,r2,1
 20190b8:	1000121e 	bne	r2,zero,2019104 <OSFlagPost+0x300>
                         sched = OS_TRUE;                     /* When done we will reschedule          */
 20190bc:	00800044 	movi	r2,1
 20190c0:	e0bff205 	stb	r2,-56(fp)
                     }
                 }
                 break;
 20190c4:	00000f06 	br	2019104 <OSFlagPost+0x300>
 20190c8:	e0bff317 	ldw	r2,-52(fp)
 20190cc:	e0bff815 	stw	r2,-32(fp)
 20190d0:	e0bff817 	ldw	r2,-32(fp)
 20190d4:	1001703a 	wrctl	status,r2
#endif
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
 20190d8:	e0bfff17 	ldw	r2,-4(fp)
 20190dc:	00c01bc4 	movi	r3,111
 20190e0:	10c00005 	stb	r3,0(r2)
                 return ((OS_FLAGS)0);
 20190e4:	0005883a 	mov	r2,zero
 20190e8:	00002606 	br	2019184 <OSFlagPost+0x380>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 20190ec:	0001883a 	nop
 20190f0:	00000506 	br	2019108 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 20190f4:	0001883a 	nop
 20190f8:	00000306 	br	2019108 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 20190fc:	0001883a 	nop
 2019100:	00000106 	br	2019108 <OSFlagPost+0x304>
                     rdy = OS_FlagTaskRdy(pnode, flags_rdy);  /* Make task RTR, event(s) Rx'd          */
                     if (rdy == OS_TRUE) {
                         sched = OS_TRUE;                     /* When done we will reschedule          */
                     }
                 }
                 break;
 2019104:	0001883a 	nop
            default:
                 OS_EXIT_CRITICAL();
                 *perr = OS_ERR_FLAG_WAIT_TYPE;
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
 2019108:	e0bff117 	ldw	r2,-60(fp)
 201910c:	10800017 	ldw	r2,0(r2)
 2019110:	e0bff115 	stw	r2,-60(fp)
             *perr = OS_ERR_FLAG_INVALID_OPT;
             return ((OS_FLAGS)0);
    }
    sched = OS_FALSE;                                /* Indicate that we don't need rescheduling       */
    pnode = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
    while (pnode != (OS_FLAG_NODE *)0) {             /* Go through all tasks waiting on event flag(s)  */
 2019114:	e0bff117 	ldw	r2,-60(fp)
 2019118:	103f871e 	bne	r2,zero,2018f38 <OSFlagPost+0x134>
 201911c:	e0bff317 	ldw	r2,-52(fp)
 2019120:	e0bff915 	stw	r2,-28(fp)
 2019124:	e0bff917 	ldw	r2,-28(fp)
 2019128:	1001703a 	wrctl	status,r2
                 return ((OS_FLAGS)0);
        }
        pnode = (OS_FLAG_NODE *)pnode->OSFlagNodeNext; /* Point to next task waiting for event flag(s) */
    }
    OS_EXIT_CRITICAL();
    if (sched == OS_TRUE) {
 201912c:	e0bff203 	ldbu	r2,-56(fp)
 2019130:	10800058 	cmpnei	r2,r2,1
 2019134:	1000011e 	bne	r2,zero,201913c <OSFlagPost+0x338>
        OS_Sched();
 2019138:	20176280 	call	2017628 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201913c:	0005303a 	rdctl	r2,status
 2019140:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019144:	e0fffa17 	ldw	r3,-24(fp)
 2019148:	00bfff84 	movi	r2,-2
 201914c:	1884703a 	and	r2,r3,r2
 2019150:	1001703a 	wrctl	status,r2
  
  return context;
 2019154:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 2019158:	e0bff315 	stw	r2,-52(fp)
    flags_cur = pgrp->OSFlagFlags;
 201915c:	e0bffc17 	ldw	r2,-16(fp)
 2019160:	1080020b 	ldhu	r2,8(r2)
 2019164:	e0bff50d 	sth	r2,-44(fp)
 2019168:	e0bff317 	ldw	r2,-52(fp)
 201916c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019170:	e0bffb17 	ldw	r2,-20(fp)
 2019174:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr     = OS_ERR_NONE;
 2019178:	e0bfff17 	ldw	r2,-4(fp)
 201917c:	10000005 	stb	zero,0(r2)
    return (flags_cur);
 2019180:	e0bff50b 	ldhu	r2,-44(fp)
}
 2019184:	e037883a 	mov	sp,fp
 2019188:	dfc00117 	ldw	ra,4(sp)
 201918c:	df000017 	ldw	fp,0(sp)
 2019190:	dec00204 	addi	sp,sp,8
 2019194:	f800283a 	ret

02019198 <OSFlagQuery>:
*********************************************************************************************************
*/

#if OS_FLAG_QUERY_EN > 0
OS_FLAGS  OSFlagQuery (OS_FLAG_GRP *pgrp, INT8U *perr)
{
 2019198:	defff904 	addi	sp,sp,-28
 201919c:	df000615 	stw	fp,24(sp)
 20191a0:	df000604 	addi	fp,sp,24
 20191a4:	e13ffe15 	stw	r4,-8(fp)
 20191a8:	e17fff15 	stw	r5,-4(fp)
    OS_FLAGS   flags;
#if OS_CRITICAL_METHOD == 3                       /* Allocate storage for CPU status register          */
    OS_CPU_SR  cpu_sr = 0;
 20191ac:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                     /* Validate 'perr'                                   */
 20191b0:	e0bfff17 	ldw	r2,-4(fp)
 20191b4:	1000021e 	bne	r2,zero,20191c0 <OSFlagQuery+0x28>
        return ((OS_FLAGS)0);
 20191b8:	0005883a 	mov	r2,zero
 20191bc:	00002306 	br	201924c <OSFlagQuery+0xb4>
    }
    if (pgrp == (OS_FLAG_GRP *)0) {               /* Validate 'pgrp'                                   */
 20191c0:	e0bffe17 	ldw	r2,-8(fp)
 20191c4:	1000051e 	bne	r2,zero,20191dc <OSFlagQuery+0x44>
        *perr = OS_ERR_FLAG_INVALID_PGRP;
 20191c8:	e0bfff17 	ldw	r2,-4(fp)
 20191cc:	00c01b84 	movi	r3,110
 20191d0:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 20191d4:	0005883a 	mov	r2,zero
 20191d8:	00001c06 	br	201924c <OSFlagQuery+0xb4>
    }
#endif
    if (pgrp->OSFlagType != OS_EVENT_TYPE_FLAG) { /* Validate event block type                         */
 20191dc:	e0bffe17 	ldw	r2,-8(fp)
 20191e0:	10800003 	ldbu	r2,0(r2)
 20191e4:	10803fcc 	andi	r2,r2,255
 20191e8:	10800160 	cmpeqi	r2,r2,5
 20191ec:	1000051e 	bne	r2,zero,2019204 <OSFlagQuery+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 20191f0:	e0bfff17 	ldw	r2,-4(fp)
 20191f4:	00c00044 	movi	r3,1
 20191f8:	10c00005 	stb	r3,0(r2)
        return ((OS_FLAGS)0);
 20191fc:	0005883a 	mov	r2,zero
 2019200:	00001206 	br	201924c <OSFlagQuery+0xb4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019204:	0005303a 	rdctl	r2,status
 2019208:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201920c:	e0fffc17 	ldw	r3,-16(fp)
 2019210:	00bfff84 	movi	r2,-2
 2019214:	1884703a 	and	r2,r3,r2
 2019218:	1001703a 	wrctl	status,r2
  
  return context;
 201921c:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 2019220:	e0bffa15 	stw	r2,-24(fp)
    flags = pgrp->OSFlagFlags;
 2019224:	e0bffe17 	ldw	r2,-8(fp)
 2019228:	1080020b 	ldhu	r2,8(r2)
 201922c:	e0bffb0d 	sth	r2,-20(fp)
 2019230:	e0bffa17 	ldw	r2,-24(fp)
 2019234:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019238:	e0bffd17 	ldw	r2,-12(fp)
 201923c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2019240:	e0bfff17 	ldw	r2,-4(fp)
 2019244:	10000005 	stb	zero,0(r2)
    return (flags);                               /* Return the current value of the event flags       */
 2019248:	e0bffb0b 	ldhu	r2,-20(fp)
}
 201924c:	e037883a 	mov	sp,fp
 2019250:	df000017 	ldw	fp,0(sp)
 2019254:	dec00104 	addi	sp,sp,4
 2019258:	f800283a 	ret

0201925c <OS_FlagBlock>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  void  OS_FlagBlock (OS_FLAG_GRP *pgrp, OS_FLAG_NODE *pnode, OS_FLAGS flags, INT8U wait_type, INT16U timeout)
{
 201925c:	defff804 	addi	sp,sp,-32
 2019260:	df000715 	stw	fp,28(sp)
 2019264:	df000704 	addi	fp,sp,28
 2019268:	e13ffb15 	stw	r4,-20(fp)
 201926c:	e17ffc15 	stw	r5,-16(fp)
 2019270:	3007883a 	mov	r3,r6
 2019274:	3805883a 	mov	r2,r7
 2019278:	e1000117 	ldw	r4,4(fp)
 201927c:	e0fffd0d 	sth	r3,-12(fp)
 2019280:	e0bffe05 	stb	r2,-8(fp)
 2019284:	e13fff0d 	sth	r4,-4(fp)
    OS_FLAG_NODE  *pnode_next;
    INT8U          y;


    OSTCBCur->OSTCBStat      |= OS_STAT_FLAG;
 2019288:	00808174 	movhi	r2,517
 201928c:	1090aa04 	addi	r2,r2,17064
 2019290:	10800017 	ldw	r2,0(r2)
 2019294:	00c08174 	movhi	r3,517
 2019298:	18d0aa04 	addi	r3,r3,17064
 201929c:	18c00017 	ldw	r3,0(r3)
 20192a0:	18c00c03 	ldbu	r3,48(r3)
 20192a4:	18c00814 	ori	r3,r3,32
 20192a8:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend   = OS_STAT_PEND_OK;
 20192ac:	00808174 	movhi	r2,517
 20192b0:	1090aa04 	addi	r2,r2,17064
 20192b4:	10800017 	ldw	r2,0(r2)
 20192b8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly        = timeout;              /* Store timeout in task's TCB                   */
 20192bc:	00808174 	movhi	r2,517
 20192c0:	1090aa04 	addi	r2,r2,17064
 20192c4:	10800017 	ldw	r2,0(r2)
 20192c8:	e0ffff0b 	ldhu	r3,-4(fp)
 20192cc:	10c00b8d 	sth	r3,46(r2)
#if OS_TASK_DEL_EN > 0
    OSTCBCur->OSTCBFlagNode   = pnode;                /* TCB to link to node                           */
 20192d0:	00808174 	movhi	r2,517
 20192d4:	1090aa04 	addi	r2,r2,17064
 20192d8:	10800017 	ldw	r2,0(r2)
 20192dc:	e0fffc17 	ldw	r3,-16(fp)
 20192e0:	10c00a15 	stw	r3,40(r2)
#endif
    pnode->OSFlagNodeFlags    = flags;                /* Save the flags that we need to wait for       */
 20192e4:	e0bffc17 	ldw	r2,-16(fp)
 20192e8:	e0fffd0b 	ldhu	r3,-12(fp)
 20192ec:	10c0040d 	sth	r3,16(r2)
    pnode->OSFlagNodeWaitType = wait_type;            /* Save the type of wait we are doing            */
 20192f0:	e0bffc17 	ldw	r2,-16(fp)
 20192f4:	e0fffe03 	ldbu	r3,-8(fp)
 20192f8:	10c00485 	stb	r3,18(r2)
    pnode->OSFlagNodeTCB      = (void *)OSTCBCur;     /* Link to task's TCB                            */
 20192fc:	00808174 	movhi	r2,517
 2019300:	1090aa04 	addi	r2,r2,17064
 2019304:	10c00017 	ldw	r3,0(r2)
 2019308:	e0bffc17 	ldw	r2,-16(fp)
 201930c:	10c00215 	stw	r3,8(r2)
    pnode->OSFlagNodeNext     = pgrp->OSFlagWaitList; /* Add node at beginning of event flag wait list */
 2019310:	e0bffb17 	ldw	r2,-20(fp)
 2019314:	10c00117 	ldw	r3,4(r2)
 2019318:	e0bffc17 	ldw	r2,-16(fp)
 201931c:	10c00015 	stw	r3,0(r2)
    pnode->OSFlagNodePrev     = (void *)0;
 2019320:	e0bffc17 	ldw	r2,-16(fp)
 2019324:	10000115 	stw	zero,4(r2)
    pnode->OSFlagNodeFlagGrp  = (void *)pgrp;         /* Link to Event Flag Group                      */
 2019328:	e0bffc17 	ldw	r2,-16(fp)
 201932c:	e0fffb17 	ldw	r3,-20(fp)
 2019330:	10c00315 	stw	r3,12(r2)
    pnode_next                = (OS_FLAG_NODE *)pgrp->OSFlagWaitList;
 2019334:	e0bffb17 	ldw	r2,-20(fp)
 2019338:	10800117 	ldw	r2,4(r2)
 201933c:	e0bff915 	stw	r2,-28(fp)
    if (pnode_next != (void *)0) {                    /* Is this the first NODE to insert?             */
 2019340:	e0bff917 	ldw	r2,-28(fp)
 2019344:	10000326 	beq	r2,zero,2019354 <OS_FlagBlock+0xf8>
        pnode_next->OSFlagNodePrev = pnode;           /* No, link in doubly linked list                */
 2019348:	e0bff917 	ldw	r2,-28(fp)
 201934c:	e0fffc17 	ldw	r3,-16(fp)
 2019350:	10c00115 	stw	r3,4(r2)
    }
    pgrp->OSFlagWaitList = (void *)pnode;
 2019354:	e0bffb17 	ldw	r2,-20(fp)
 2019358:	e0fffc17 	ldw	r3,-16(fp)
 201935c:	10c00115 	stw	r3,4(r2)

    y            =  OSTCBCur->OSTCBY;                 /* Suspend current task until flag(s) received   */
 2019360:	00808174 	movhi	r2,517
 2019364:	1090aa04 	addi	r2,r2,17064
 2019368:	10800017 	ldw	r2,0(r2)
 201936c:	10800d03 	ldbu	r2,52(r2)
 2019370:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 2019374:	e0bffa03 	ldbu	r2,-24(fp)
 2019378:	e0fffa03 	ldbu	r3,-24(fp)
 201937c:	01008174 	movhi	r4,517
 2019380:	2110a744 	addi	r4,r4,17053
 2019384:	20c7883a 	add	r3,r4,r3
 2019388:	18c00003 	ldbu	r3,0(r3)
 201938c:	1809883a 	mov	r4,r3
 2019390:	00c08174 	movhi	r3,517
 2019394:	18d0aa04 	addi	r3,r3,17064
 2019398:	18c00017 	ldw	r3,0(r3)
 201939c:	18c00d43 	ldbu	r3,53(r3)
 20193a0:	00c6303a 	nor	r3,zero,r3
 20193a4:	20c6703a 	and	r3,r4,r3
 20193a8:	01008174 	movhi	r4,517
 20193ac:	2110a744 	addi	r4,r4,17053
 20193b0:	2085883a 	add	r2,r4,r2
 20193b4:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0x00) {
 20193b8:	e0bffa03 	ldbu	r2,-24(fp)
 20193bc:	00c08174 	movhi	r3,517
 20193c0:	18d0a744 	addi	r3,r3,17053
 20193c4:	1885883a 	add	r2,r3,r2
 20193c8:	10800003 	ldbu	r2,0(r2)
 20193cc:	10803fcc 	andi	r2,r2,255
 20193d0:	10000e1e 	bne	r2,zero,201940c <OS_FlagBlock+0x1b0>
        OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 20193d4:	00808174 	movhi	r2,517
 20193d8:	1090aa04 	addi	r2,r2,17064
 20193dc:	10800017 	ldw	r2,0(r2)
 20193e0:	10800d83 	ldbu	r2,54(r2)
 20193e4:	0084303a 	nor	r2,zero,r2
 20193e8:	1007883a 	mov	r3,r2
 20193ec:	00808174 	movhi	r2,517
 20193f0:	1090a704 	addi	r2,r2,17052
 20193f4:	10800003 	ldbu	r2,0(r2)
 20193f8:	1884703a 	and	r2,r3,r2
 20193fc:	1007883a 	mov	r3,r2
 2019400:	00808174 	movhi	r2,517
 2019404:	1090a704 	addi	r2,r2,17052
 2019408:	10c00005 	stb	r3,0(r2)
    }
}
 201940c:	e037883a 	mov	sp,fp
 2019410:	df000017 	ldw	fp,0(sp)
 2019414:	dec00104 	addi	sp,sp,4
 2019418:	f800283a 	ret

0201941c <OS_FlagInit>:
* WARNING    : You MUST NOT call this function from your code.  This is an INTERNAL function to uC/OS-II.
*********************************************************************************************************
*/

void  OS_FlagInit (void)
{
 201941c:	defffb04 	addi	sp,sp,-20
 2019420:	dfc00415 	stw	ra,16(sp)
 2019424:	df000315 	stw	fp,12(sp)
 2019428:	df000304 	addi	fp,sp,12
    INT16U       i;
    OS_FLAG_GRP *pgrp1;
    OS_FLAG_GRP *pgrp2;


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
 201942c:	01009934 	movhi	r4,612
 2019430:	2127e304 	addi	r4,r4,-24692
 2019434:	0140dc04 	movi	r5,880
 2019438:	20175680 	call	2017568 <OS_MemClr>
    pgrp1 = &OSFlagTbl[0];
 201943c:	00809934 	movhi	r2,612
 2019440:	10a7e304 	addi	r2,r2,-24692
 2019444:	e0bffe15 	stw	r2,-8(fp)
    pgrp2 = &OSFlagTbl[1];
 2019448:	00809934 	movhi	r2,612
 201944c:	10a7ee04 	addi	r2,r2,-24648
 2019450:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 2019454:	e03ffd0d 	sth	zero,-12(fp)
 2019458:	00001306 	br	20194a8 <OS_FlagInit+0x8c>
        pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 201945c:	e0bffe17 	ldw	r2,-8(fp)
 2019460:	10000005 	stb	zero,0(r2)
        pgrp1->OSFlagWaitList = (void *)pgrp2;
 2019464:	e0bffe17 	ldw	r2,-8(fp)
 2019468:	e0ffff17 	ldw	r3,-4(fp)
 201946c:	10c00115 	stw	r3,4(r2)
#if OS_FLAG_NAME_SIZE > 1
        pgrp1->OSFlagName[0]  = '?';                                /* Unknown name                    */
 2019470:	e0bffe17 	ldw	r2,-8(fp)
 2019474:	00c00fc4 	movi	r3,63
 2019478:	10c00285 	stb	r3,10(r2)
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 201947c:	e0bffe17 	ldw	r2,-8(fp)
 2019480:	100002c5 	stb	zero,11(r2)
#endif
        pgrp1++;
 2019484:	e0bffe17 	ldw	r2,-8(fp)
 2019488:	10800b04 	addi	r2,r2,44
 201948c:	e0bffe15 	stw	r2,-8(fp)
        pgrp2++;
 2019490:	e0bfff17 	ldw	r2,-4(fp)
 2019494:	10800b04 	addi	r2,r2,44
 2019498:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSFlagTbl[0], sizeof(OSFlagTbl));           /* Clear the flag group table      */
    pgrp1 = &OSFlagTbl[0];
    pgrp2 = &OSFlagTbl[1];
    for (i = 0; i < (OS_MAX_FLAGS - 1); i++) {                      /* Init. list of free EVENT FLAGS  */
 201949c:	e0bffd0b 	ldhu	r2,-12(fp)
 20194a0:	10800044 	addi	r2,r2,1
 20194a4:	e0bffd0d 	sth	r2,-12(fp)
 20194a8:	e0bffd0b 	ldhu	r2,-12(fp)
 20194ac:	108004f0 	cmpltui	r2,r2,19
 20194b0:	103fea1e 	bne	r2,zero,201945c <OS_FlagInit+0x40>
        pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
#endif
        pgrp1++;
        pgrp2++;
    }
    pgrp1->OSFlagType     = OS_EVENT_TYPE_UNUSED;
 20194b4:	e0bffe17 	ldw	r2,-8(fp)
 20194b8:	10000005 	stb	zero,0(r2)
    pgrp1->OSFlagWaitList = (void *)0;
 20194bc:	e0bffe17 	ldw	r2,-8(fp)
 20194c0:	10000115 	stw	zero,4(r2)
#if OS_FLAG_NAME_SIZE > 1
    pgrp1->OSFlagName[0]  = '?';                                    /* Unknown name                    */
 20194c4:	e0bffe17 	ldw	r2,-8(fp)
 20194c8:	00c00fc4 	movi	r3,63
 20194cc:	10c00285 	stb	r3,10(r2)
    pgrp1->OSFlagName[1]  = OS_ASCII_NUL;
 20194d0:	e0bffe17 	ldw	r2,-8(fp)
 20194d4:	100002c5 	stb	zero,11(r2)
#endif
    OSFlagFreeList        = &OSFlagTbl[0];
 20194d8:	00808174 	movhi	r2,517
 20194dc:	1090ac04 	addi	r2,r2,17072
 20194e0:	00c09934 	movhi	r3,612
 20194e4:	18e7e304 	addi	r3,r3,-24692
 20194e8:	10c00015 	stw	r3,0(r2)
#endif
}
 20194ec:	e037883a 	mov	sp,fp
 20194f0:	dfc00117 	ldw	ra,4(sp)
 20194f4:	df000017 	ldw	fp,0(sp)
 20194f8:	dec00204 	addi	sp,sp,8
 20194fc:	f800283a 	ret

02019500 <OS_FlagTaskRdy>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

static  BOOLEAN  OS_FlagTaskRdy (OS_FLAG_NODE *pnode, OS_FLAGS flags_rdy)
{
 2019500:	defffa04 	addi	sp,sp,-24
 2019504:	dfc00515 	stw	ra,20(sp)
 2019508:	df000415 	stw	fp,16(sp)
 201950c:	df000404 	addi	fp,sp,16
 2019510:	e13ffe15 	stw	r4,-8(fp)
 2019514:	2805883a 	mov	r2,r5
 2019518:	e0bfff0d 	sth	r2,-4(fp)
    OS_TCB   *ptcb;
    BOOLEAN   sched;


    ptcb                 = (OS_TCB *)pnode->OSFlagNodeTCB; /* Point to TCB of waiting task             */
 201951c:	e0bffe17 	ldw	r2,-8(fp)
 2019520:	10800217 	ldw	r2,8(r2)
 2019524:	e0bffd15 	stw	r2,-12(fp)
    ptcb->OSTCBDly       = 0;
 2019528:	e0bffd17 	ldw	r2,-12(fp)
 201952c:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBFlagsRdy  = flags_rdy;
 2019530:	e0bffd17 	ldw	r2,-12(fp)
 2019534:	e0ffff0b 	ldhu	r3,-4(fp)
 2019538:	10c00b0d 	sth	r3,44(r2)
    ptcb->OSTCBStat     &= ~(INT8U)OS_STAT_FLAG;
 201953c:	e0bffd17 	ldw	r2,-12(fp)
 2019540:	10c00c03 	ldbu	r3,48(r2)
 2019544:	00bff7c4 	movi	r2,-33
 2019548:	1884703a 	and	r2,r3,r2
 201954c:	1007883a 	mov	r3,r2
 2019550:	e0bffd17 	ldw	r2,-12(fp)
 2019554:	10c00c05 	stb	r3,48(r2)
    ptcb->OSTCBStatPend  = OS_STAT_PEND_OK;
 2019558:	e0bffd17 	ldw	r2,-12(fp)
 201955c:	10000c45 	stb	zero,49(r2)
    if (ptcb->OSTCBStat == OS_STAT_RDY) {                  /* Task now ready?                          */
 2019560:	e0bffd17 	ldw	r2,-12(fp)
 2019564:	10800c03 	ldbu	r2,48(r2)
 2019568:	10803fcc 	andi	r2,r2,255
 201956c:	10001e1e 	bne	r2,zero,20195e8 <OS_FlagTaskRdy+0xe8>
        OSRdyGrp               |= ptcb->OSTCBBitY;         /* Put task into ready list                 */
 2019570:	e0bffd17 	ldw	r2,-12(fp)
 2019574:	10c00d83 	ldbu	r3,54(r2)
 2019578:	00808174 	movhi	r2,517
 201957c:	1090a704 	addi	r2,r2,17052
 2019580:	10800003 	ldbu	r2,0(r2)
 2019584:	1884b03a 	or	r2,r3,r2
 2019588:	1007883a 	mov	r3,r2
 201958c:	00808174 	movhi	r2,517
 2019590:	1090a704 	addi	r2,r2,17052
 2019594:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 2019598:	e0bffd17 	ldw	r2,-12(fp)
 201959c:	10800d03 	ldbu	r2,52(r2)
 20195a0:	10803fcc 	andi	r2,r2,255
 20195a4:	e0fffd17 	ldw	r3,-12(fp)
 20195a8:	18c00d03 	ldbu	r3,52(r3)
 20195ac:	18c03fcc 	andi	r3,r3,255
 20195b0:	01008174 	movhi	r4,517
 20195b4:	2110a744 	addi	r4,r4,17053
 20195b8:	20c7883a 	add	r3,r4,r3
 20195bc:	19000003 	ldbu	r4,0(r3)
 20195c0:	e0fffd17 	ldw	r3,-12(fp)
 20195c4:	18c00d43 	ldbu	r3,53(r3)
 20195c8:	20c6b03a 	or	r3,r4,r3
 20195cc:	01008174 	movhi	r4,517
 20195d0:	2110a744 	addi	r4,r4,17053
 20195d4:	2085883a 	add	r2,r4,r2
 20195d8:	10c00005 	stb	r3,0(r2)
        sched                   = OS_TRUE;
 20195dc:	00800044 	movi	r2,1
 20195e0:	e0bffc05 	stb	r2,-16(fp)
 20195e4:	00000106 	br	20195ec <OS_FlagTaskRdy+0xec>
    } else {
        sched                   = OS_FALSE;
 20195e8:	e03ffc05 	stb	zero,-16(fp)
    }
    OS_FlagUnlink(pnode);
 20195ec:	e13ffe17 	ldw	r4,-8(fp)
 20195f0:	201960c0 	call	201960c <OS_FlagUnlink>
    return (sched);
 20195f4:	e0bffc03 	ldbu	r2,-16(fp)
}
 20195f8:	e037883a 	mov	sp,fp
 20195fc:	dfc00117 	ldw	ra,4(sp)
 2019600:	df000017 	ldw	fp,0(sp)
 2019604:	dec00204 	addi	sp,sp,8
 2019608:	f800283a 	ret

0201960c <OS_FlagUnlink>:
*              2) This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_FlagUnlink (OS_FLAG_NODE *pnode)
{
 201960c:	defffa04 	addi	sp,sp,-24
 2019610:	df000515 	stw	fp,20(sp)
 2019614:	df000504 	addi	fp,sp,20
 2019618:	e13fff15 	stw	r4,-4(fp)
    OS_FLAG_GRP  *pgrp;
    OS_FLAG_NODE *pnode_prev;
    OS_FLAG_NODE *pnode_next;


    pnode_prev = (OS_FLAG_NODE *)pnode->OSFlagNodePrev;
 201961c:	e0bfff17 	ldw	r2,-4(fp)
 2019620:	10800117 	ldw	r2,4(r2)
 2019624:	e0bffb15 	stw	r2,-20(fp)
    pnode_next = (OS_FLAG_NODE *)pnode->OSFlagNodeNext;
 2019628:	e0bfff17 	ldw	r2,-4(fp)
 201962c:	10800017 	ldw	r2,0(r2)
 2019630:	e0bffc15 	stw	r2,-16(fp)
    if (pnode_prev == (OS_FLAG_NODE *)0) {                      /* Is it first node in wait list?      */
 2019634:	e0bffb17 	ldw	r2,-20(fp)
 2019638:	10000b1e 	bne	r2,zero,2019668 <OS_FlagUnlink+0x5c>
        pgrp                 = (OS_FLAG_GRP *)pnode->OSFlagNodeFlagGrp;
 201963c:	e0bfff17 	ldw	r2,-4(fp)
 2019640:	10800317 	ldw	r2,12(r2)
 2019644:	e0bffd15 	stw	r2,-12(fp)
        pgrp->OSFlagWaitList = (void *)pnode_next;              /*      Update list for new 1st node   */
 2019648:	e0bffd17 	ldw	r2,-12(fp)
 201964c:	e0fffc17 	ldw	r3,-16(fp)
 2019650:	10c00115 	stw	r3,4(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {
 2019654:	e0bffc17 	ldw	r2,-16(fp)
 2019658:	10000b26 	beq	r2,zero,2019688 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = (OS_FLAG_NODE *)0;     /*      Link new 1st node PREV to NULL */
 201965c:	e0bffc17 	ldw	r2,-16(fp)
 2019660:	10000115 	stw	zero,4(r2)
 2019664:	00000806 	br	2019688 <OS_FlagUnlink+0x7c>
        }
    } else {                                                    /* No,  A node somewhere in the list   */
        pnode_prev->OSFlagNodeNext = pnode_next;                /*      Link around the node to unlink */
 2019668:	e0bffb17 	ldw	r2,-20(fp)
 201966c:	e0fffc17 	ldw	r3,-16(fp)
 2019670:	10c00015 	stw	r3,0(r2)
        if (pnode_next != (OS_FLAG_NODE *)0) {                  /*      Was this the LAST node?        */
 2019674:	e0bffc17 	ldw	r2,-16(fp)
 2019678:	10000326 	beq	r2,zero,2019688 <OS_FlagUnlink+0x7c>
            pnode_next->OSFlagNodePrev = pnode_prev;            /*      No, Link around current node   */
 201967c:	e0bffc17 	ldw	r2,-16(fp)
 2019680:	e0fffb17 	ldw	r3,-20(fp)
 2019684:	10c00115 	stw	r3,4(r2)
        }
    }
#if OS_TASK_DEL_EN > 0
    ptcb                = (OS_TCB *)pnode->OSFlagNodeTCB;
 2019688:	e0bfff17 	ldw	r2,-4(fp)
 201968c:	10800217 	ldw	r2,8(r2)
 2019690:	e0bffe15 	stw	r2,-8(fp)
    ptcb->OSTCBFlagNode = (OS_FLAG_NODE *)0;
 2019694:	e0bffe17 	ldw	r2,-8(fp)
 2019698:	10000a15 	stw	zero,40(r2)
#endif
}
 201969c:	e037883a 	mov	sp,fp
 20196a0:	df000017 	ldw	fp,0(sp)
 20196a4:	dec00104 	addi	sp,sp,4
 20196a8:	f800283a 	ret

020196ac <OSMboxAccept>:
*********************************************************************************************************
*/

#if OS_MBOX_ACCEPT_EN > 0
void  *OSMboxAccept (OS_EVENT *pevent)
{
 20196ac:	defffa04 	addi	sp,sp,-24
 20196b0:	df000515 	stw	fp,20(sp)
 20196b4:	df000504 	addi	fp,sp,20
 20196b8:	e13fff15 	stw	r4,-4(fp)
    void      *pmsg;
#if OS_CRITICAL_METHOD == 3                               /* Allocate storage for CPU status register  */
    OS_CPU_SR  cpu_sr = 0;
 20196bc:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                        /* Validate 'pevent'                         */
 20196c0:	e0bfff17 	ldw	r2,-4(fp)
 20196c4:	1000021e 	bne	r2,zero,20196d0 <OSMboxAccept+0x24>
        return ((void *)0);
 20196c8:	0005883a 	mov	r2,zero
 20196cc:	00001906 	br	2019734 <OSMboxAccept+0x88>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {      /* Validate event block type                 */
 20196d0:	e0bfff17 	ldw	r2,-4(fp)
 20196d4:	10800003 	ldbu	r2,0(r2)
 20196d8:	10803fcc 	andi	r2,r2,255
 20196dc:	10800060 	cmpeqi	r2,r2,1
 20196e0:	1000021e 	bne	r2,zero,20196ec <OSMboxAccept+0x40>
        return ((void *)0);
 20196e4:	0005883a 	mov	r2,zero
 20196e8:	00001206 	br	2019734 <OSMboxAccept+0x88>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20196ec:	0005303a 	rdctl	r2,status
 20196f0:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20196f4:	e0fffd17 	ldw	r3,-12(fp)
 20196f8:	00bfff84 	movi	r2,-2
 20196fc:	1884703a 	and	r2,r3,r2
 2019700:	1001703a 	wrctl	status,r2
  
  return context;
 2019704:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2019708:	e0bffb15 	stw	r2,-20(fp)
    pmsg               = pevent->OSEventPtr;
 201970c:	e0bfff17 	ldw	r2,-4(fp)
 2019710:	10800117 	ldw	r2,4(r2)
 2019714:	e0bffc15 	stw	r2,-16(fp)
    pevent->OSEventPtr = (void *)0;                       /* Clear the mailbox                         */
 2019718:	e0bfff17 	ldw	r2,-4(fp)
 201971c:	10000115 	stw	zero,4(r2)
 2019720:	e0bffb17 	ldw	r2,-20(fp)
 2019724:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019728:	e0bffe17 	ldw	r2,-8(fp)
 201972c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                        /* Return the message received (or NULL)     */
 2019730:	e0bffc17 	ldw	r2,-16(fp)
}
 2019734:	e037883a 	mov	sp,fp
 2019738:	df000017 	ldw	fp,0(sp)
 201973c:	dec00104 	addi	sp,sp,4
 2019740:	f800283a 	ret

02019744 <OSMboxCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSMboxCreate (void *pmsg)
{
 2019744:	defff904 	addi	sp,sp,-28
 2019748:	dfc00615 	stw	ra,24(sp)
 201974c:	df000515 	stw	fp,20(sp)
 2019750:	df000504 	addi	fp,sp,20
 2019754:	e13fff15 	stw	r4,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 2019758:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 201975c:	00808174 	movhi	r2,517
 2019760:	1090a904 	addi	r2,r2,17060
 2019764:	10800003 	ldbu	r2,0(r2)
 2019768:	10803fcc 	andi	r2,r2,255
 201976c:	10000226 	beq	r2,zero,2019778 <OSMboxCreate+0x34>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 2019770:	0005883a 	mov	r2,zero
 2019774:	00002d06 	br	201982c <OSMboxCreate+0xe8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019778:	0005303a 	rdctl	r2,status
 201977c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019780:	e0fffd17 	ldw	r3,-12(fp)
 2019784:	00bfff84 	movi	r2,-2
 2019788:	1884703a 	and	r2,r3,r2
 201978c:	1001703a 	wrctl	status,r2
  
  return context;
 2019790:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 2019794:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 2019798:	00808174 	movhi	r2,517
 201979c:	1090a804 	addi	r2,r2,17056
 20197a0:	10800017 	ldw	r2,0(r2)
 20197a4:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 20197a8:	00808174 	movhi	r2,517
 20197ac:	1090a804 	addi	r2,r2,17056
 20197b0:	10800017 	ldw	r2,0(r2)
 20197b4:	10000726 	beq	r2,zero,20197d4 <OSMboxCreate+0x90>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 20197b8:	00808174 	movhi	r2,517
 20197bc:	1090a804 	addi	r2,r2,17056
 20197c0:	10800017 	ldw	r2,0(r2)
 20197c4:	10c00117 	ldw	r3,4(r2)
 20197c8:	00808174 	movhi	r2,517
 20197cc:	1090a804 	addi	r2,r2,17056
 20197d0:	10c00015 	stw	r3,0(r2)
 20197d4:	e0bffb17 	ldw	r2,-20(fp)
 20197d8:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20197dc:	e0bffe17 	ldw	r2,-8(fp)
 20197e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {
 20197e4:	e0bffc17 	ldw	r2,-16(fp)
 20197e8:	10000f26 	beq	r2,zero,2019828 <OSMboxCreate+0xe4>
        pevent->OSEventType    = OS_EVENT_TYPE_MBOX;
 20197ec:	e0bffc17 	ldw	r2,-16(fp)
 20197f0:	00c00044 	movi	r3,1
 20197f4:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = 0;
 20197f8:	e0bffc17 	ldw	r2,-16(fp)
 20197fc:	1000020d 	sth	zero,8(r2)
        pevent->OSEventPtr     = pmsg;           /* Deposit message in event control block             */
 2019800:	e0bffc17 	ldw	r2,-16(fp)
 2019804:	e0ffff17 	ldw	r3,-4(fp)
 2019808:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';
 201980c:	e0bffc17 	ldw	r2,-16(fp)
 2019810:	00c00fc4 	movi	r3,63
 2019814:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 2019818:	e0bffc17 	ldw	r2,-16(fp)
 201981c:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);
 2019820:	e13ffc17 	ldw	r4,-16(fp)
 2019824:	201719c0 	call	201719c <OS_EventWaitListInit>
    }
    return (pevent);                             /* Return pointer to event control block              */
 2019828:	e0bffc17 	ldw	r2,-16(fp)
}
 201982c:	e037883a 	mov	sp,fp
 2019830:	dfc00117 	ldw	ra,4(sp)
 2019834:	df000017 	ldw	fp,0(sp)
 2019838:	dec00204 	addi	sp,sp,8
 201983c:	f800283a 	ret

02019840 <OSMboxDel>:
*********************************************************************************************************
*/

#if OS_MBOX_DEL_EN > 0
OS_EVENT  *OSMboxDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 2019840:	defff304 	addi	sp,sp,-52
 2019844:	dfc00c15 	stw	ra,48(sp)
 2019848:	df000b15 	stw	fp,44(sp)
 201984c:	df000b04 	addi	fp,sp,44
 2019850:	e13ffd15 	stw	r4,-12(fp)
 2019854:	2805883a 	mov	r2,r5
 2019858:	e1bfff15 	stw	r6,-4(fp)
 201985c:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2019860:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2019864:	e0bfff17 	ldw	r2,-4(fp)
 2019868:	1000021e 	bne	r2,zero,2019874 <OSMboxDel+0x34>
        return (pevent);
 201986c:	e0bffd17 	ldw	r2,-12(fp)
 2019870:	00008a06 	br	2019a9c <OSMboxDel+0x25c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 2019874:	e0bffd17 	ldw	r2,-12(fp)
 2019878:	1000051e 	bne	r2,zero,2019890 <OSMboxDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201987c:	e0bfff17 	ldw	r2,-4(fp)
 2019880:	00c00104 	movi	r3,4
 2019884:	10c00005 	stb	r3,0(r2)
        return (pevent);
 2019888:	e0bffd17 	ldw	r2,-12(fp)
 201988c:	00008306 	br	2019a9c <OSMboxDel+0x25c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 2019890:	e0bffd17 	ldw	r2,-12(fp)
 2019894:	10800003 	ldbu	r2,0(r2)
 2019898:	10803fcc 	andi	r2,r2,255
 201989c:	10800060 	cmpeqi	r2,r2,1
 20198a0:	1000051e 	bne	r2,zero,20198b8 <OSMboxDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 20198a4:	e0bfff17 	ldw	r2,-4(fp)
 20198a8:	00c00044 	movi	r3,1
 20198ac:	10c00005 	stb	r3,0(r2)
        return (pevent);
 20198b0:	e0bffd17 	ldw	r2,-12(fp)
 20198b4:	00007906 	br	2019a9c <OSMboxDel+0x25c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 20198b8:	00808174 	movhi	r2,517
 20198bc:	1090a904 	addi	r2,r2,17060
 20198c0:	10800003 	ldbu	r2,0(r2)
 20198c4:	10803fcc 	andi	r2,r2,255
 20198c8:	10000526 	beq	r2,zero,20198e0 <OSMboxDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 20198cc:	e0bfff17 	ldw	r2,-4(fp)
 20198d0:	00c003c4 	movi	r3,15
 20198d4:	10c00005 	stb	r3,0(r2)
        return (pevent);
 20198d8:	e0bffd17 	ldw	r2,-12(fp)
 20198dc:	00006f06 	br	2019a9c <OSMboxDel+0x25c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20198e0:	0005303a 	rdctl	r2,status
 20198e4:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20198e8:	e0fff817 	ldw	r3,-32(fp)
 20198ec:	00bfff84 	movi	r2,-2
 20198f0:	1884703a 	and	r2,r3,r2
 20198f4:	1001703a 	wrctl	status,r2
  
  return context;
 20198f8:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 20198fc:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on mailbox      */
 2019900:	e0bffd17 	ldw	r2,-12(fp)
 2019904:	10800283 	ldbu	r2,10(r2)
 2019908:	10803fcc 	andi	r2,r2,255
 201990c:	10000326 	beq	r2,zero,201991c <OSMboxDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 2019910:	00800044 	movi	r2,1
 2019914:	e0bff505 	stb	r2,-44(fp)
 2019918:	00000106 	br	2019920 <OSMboxDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 201991c:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 2019920:	e0bffe03 	ldbu	r2,-8(fp)
 2019924:	10000326 	beq	r2,zero,2019934 <OSMboxDel+0xf4>
 2019928:	10800060 	cmpeqi	r2,r2,1
 201992c:	10002d1e 	bne	r2,zero,20199e4 <OSMboxDel+0x1a4>
 2019930:	00004f06 	br	2019a70 <OSMboxDel+0x230>
        case OS_DEL_NO_PEND:                               /* Delete mailbox only if no task waiting   */
             if (tasks_waiting == OS_FALSE) {
 2019934:	e0bff503 	ldbu	r2,-44(fp)
 2019938:	10001a1e 	bne	r2,zero,20199a4 <OSMboxDel+0x164>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 201993c:	e0bffd17 	ldw	r2,-12(fp)
 2019940:	00c00fc4 	movi	r3,63
 2019944:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 2019948:	e0bffd17 	ldw	r2,-12(fp)
 201994c:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType = OS_EVENT_TYPE_UNUSED;
 2019950:	e0bffd17 	ldw	r2,-12(fp)
 2019954:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr  = OSEventFreeList;    /* Return Event Control Block to free list  */
 2019958:	00808174 	movhi	r2,517
 201995c:	1090a804 	addi	r2,r2,17056
 2019960:	10c00017 	ldw	r3,0(r2)
 2019964:	e0bffd17 	ldw	r2,-12(fp)
 2019968:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt  = 0;
 201996c:	e0bffd17 	ldw	r2,-12(fp)
 2019970:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList     = pevent;             /* Get next free event control block        */
 2019974:	00808174 	movhi	r2,517
 2019978:	1090a804 	addi	r2,r2,17056
 201997c:	e0fffd17 	ldw	r3,-12(fp)
 2019980:	10c00015 	stw	r3,0(r2)
 2019984:	e0bff717 	ldw	r2,-36(fp)
 2019988:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201998c:	e0bff917 	ldw	r2,-28(fp)
 2019990:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
 2019994:	e0bfff17 	ldw	r2,-4(fp)
 2019998:	10000005 	stb	zero,0(r2)
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
 201999c:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
                 pevent_return       = pevent;
             }
             break;
 20199a0:	00003d06 	br	2019a98 <OSMboxDel+0x258>
 20199a4:	e0bff717 	ldw	r2,-36(fp)
 20199a8:	e0bffa15 	stw	r2,-24(fp)
 20199ac:	e0bffa17 	ldw	r2,-24(fp)
 20199b0:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_NONE;
                 pevent_return       = (OS_EVENT *)0;      /* Mailbox has been deleted                 */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr               = OS_ERR_TASK_WAITING;
 20199b4:	e0bfff17 	ldw	r2,-4(fp)
 20199b8:	00c01244 	movi	r3,73
 20199bc:	10c00005 	stb	r3,0(r2)
                 pevent_return       = pevent;
 20199c0:	e0bffd17 	ldw	r2,-12(fp)
 20199c4:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 20199c8:	00003306 	br	2019a98 <OSMboxDel+0x258>

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
 20199cc:	e13ffd17 	ldw	r4,-12(fp)
 20199d0:	000b883a 	mov	r5,zero
 20199d4:	01800084 	movi	r6,2
 20199d8:	000f883a 	mov	r7,zero
 20199dc:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 20199e0:	00000106 	br	20199e8 <OSMboxDel+0x1a8>
                 pevent_return       = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the mailbox                */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for mailbox      */
 20199e4:	0001883a 	nop
 20199e8:	e0bffd17 	ldw	r2,-12(fp)
 20199ec:	10800283 	ldbu	r2,10(r2)
 20199f0:	10803fcc 	andi	r2,r2,255
 20199f4:	103ff51e 	bne	r2,zero,20199cc <OSMboxDel+0x18c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 20199f8:	e0bffd17 	ldw	r2,-12(fp)
 20199fc:	00c00fc4 	movi	r3,63
 2019a00:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 2019a04:	e0bffd17 	ldw	r2,-12(fp)
 2019a08:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 2019a0c:	e0bffd17 	ldw	r2,-12(fp)
 2019a10:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 2019a14:	00808174 	movhi	r2,517
 2019a18:	1090a804 	addi	r2,r2,17056
 2019a1c:	10c00017 	ldw	r3,0(r2)
 2019a20:	e0bffd17 	ldw	r2,-12(fp)
 2019a24:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 2019a28:	e0bffd17 	ldw	r2,-12(fp)
 2019a2c:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 2019a30:	00808174 	movhi	r2,517
 2019a34:	1090a804 	addi	r2,r2,17056
 2019a38:	e0fffd17 	ldw	r3,-12(fp)
 2019a3c:	10c00015 	stw	r3,0(r2)
 2019a40:	e0bff717 	ldw	r2,-36(fp)
 2019a44:	e0bffb15 	stw	r2,-20(fp)
 2019a48:	e0bffb17 	ldw	r2,-20(fp)
 2019a4c:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 2019a50:	e0bff503 	ldbu	r2,-44(fp)
 2019a54:	10800058 	cmpnei	r2,r2,1
 2019a58:	1000011e 	bne	r2,zero,2019a60 <OSMboxDel+0x220>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 2019a5c:	20176280 	call	2017628 <OS_Sched>
             }
             *perr         = OS_ERR_NONE;
 2019a60:	e0bfff17 	ldw	r2,-4(fp)
 2019a64:	10000005 	stb	zero,0(r2)
             pevent_return = (OS_EVENT *)0;                /* Mailbox has been deleted                 */
 2019a68:	e03ff615 	stw	zero,-40(fp)
             break;
 2019a6c:	00000a06 	br	2019a98 <OSMboxDel+0x258>
 2019a70:	e0bff717 	ldw	r2,-36(fp)
 2019a74:	e0bffc15 	stw	r2,-16(fp)
 2019a78:	e0bffc17 	ldw	r2,-16(fp)
 2019a7c:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr         = OS_ERR_INVALID_OPT;
 2019a80:	e0bfff17 	ldw	r2,-4(fp)
 2019a84:	00c001c4 	movi	r3,7
 2019a88:	10c00005 	stb	r3,0(r2)
             pevent_return = pevent;
 2019a8c:	e0bffd17 	ldw	r2,-12(fp)
 2019a90:	e0bff615 	stw	r2,-40(fp)
             break;
 2019a94:	0001883a 	nop
    }
    return (pevent_return);
 2019a98:	e0bff617 	ldw	r2,-40(fp)
}
 2019a9c:	e037883a 	mov	sp,fp
 2019aa0:	dfc00117 	ldw	ra,4(sp)
 2019aa4:	df000017 	ldw	fp,0(sp)
 2019aa8:	dec00204 	addi	sp,sp,8
 2019aac:	f800283a 	ret

02019ab0 <OSMboxPend>:
*                            if you didn't pass the proper pointer to the event control block.
*********************************************************************************************************
*/
/*$PAGE*/
void  *OSMboxPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 2019ab0:	defff404 	addi	sp,sp,-48
 2019ab4:	dfc00b15 	stw	ra,44(sp)
 2019ab8:	df000a15 	stw	fp,40(sp)
 2019abc:	df000a04 	addi	fp,sp,40
 2019ac0:	e13ffd15 	stw	r4,-12(fp)
 2019ac4:	2805883a 	mov	r2,r5
 2019ac8:	e1bfff15 	stw	r6,-4(fp)
 2019acc:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 2019ad0:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 2019ad4:	e0bfff17 	ldw	r2,-4(fp)
 2019ad8:	1000021e 	bne	r2,zero,2019ae4 <OSMboxPend+0x34>
        return ((void *)0);
 2019adc:	0005883a 	mov	r2,zero
 2019ae0:	00009706 	br	2019d40 <OSMboxPend+0x290>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 2019ae4:	e0bffd17 	ldw	r2,-12(fp)
 2019ae8:	1000051e 	bne	r2,zero,2019b00 <OSMboxPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 2019aec:	e0bfff17 	ldw	r2,-4(fp)
 2019af0:	00c00104 	movi	r3,4
 2019af4:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019af8:	0005883a 	mov	r2,zero
 2019afc:	00009006 	br	2019d40 <OSMboxPend+0x290>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 2019b00:	e0bffd17 	ldw	r2,-12(fp)
 2019b04:	10800003 	ldbu	r2,0(r2)
 2019b08:	10803fcc 	andi	r2,r2,255
 2019b0c:	10800060 	cmpeqi	r2,r2,1
 2019b10:	1000051e 	bne	r2,zero,2019b28 <OSMboxPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 2019b14:	e0bfff17 	ldw	r2,-4(fp)
 2019b18:	00c00044 	movi	r3,1
 2019b1c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019b20:	0005883a 	mov	r2,zero
 2019b24:	00008606 	br	2019d40 <OSMboxPend+0x290>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 2019b28:	00808174 	movhi	r2,517
 2019b2c:	1090a904 	addi	r2,r2,17060
 2019b30:	10800003 	ldbu	r2,0(r2)
 2019b34:	10803fcc 	andi	r2,r2,255
 2019b38:	10000526 	beq	r2,zero,2019b50 <OSMboxPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 2019b3c:	e0bfff17 	ldw	r2,-4(fp)
 2019b40:	00c00084 	movi	r3,2
 2019b44:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019b48:	0005883a 	mov	r2,zero
 2019b4c:	00007c06 	br	2019d40 <OSMboxPend+0x290>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 2019b50:	00808174 	movhi	r2,517
 2019b54:	10909b04 	addi	r2,r2,17004
 2019b58:	10800003 	ldbu	r2,0(r2)
 2019b5c:	10803fcc 	andi	r2,r2,255
 2019b60:	10000526 	beq	r2,zero,2019b78 <OSMboxPend+0xc8>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 2019b64:	e0bfff17 	ldw	r2,-4(fp)
 2019b68:	00c00344 	movi	r3,13
 2019b6c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 2019b70:	0005883a 	mov	r2,zero
 2019b74:	00007206 	br	2019d40 <OSMboxPend+0x290>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019b78:	0005303a 	rdctl	r2,status
 2019b7c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019b80:	e0fff817 	ldw	r3,-32(fp)
 2019b84:	00bfff84 	movi	r2,-2
 2019b88:	1884703a 	and	r2,r3,r2
 2019b8c:	1001703a 	wrctl	status,r2
  
  return context;
 2019b90:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 2019b94:	e0bff715 	stw	r2,-36(fp)
    pmsg = pevent->OSEventPtr;
 2019b98:	e0bffd17 	ldw	r2,-12(fp)
 2019b9c:	10800117 	ldw	r2,4(r2)
 2019ba0:	e0bff615 	stw	r2,-40(fp)
    if (pmsg != (void *)0) {                          /* See if there is already a message             */
 2019ba4:	e0bff617 	ldw	r2,-40(fp)
 2019ba8:	10000a26 	beq	r2,zero,2019bd4 <OSMboxPend+0x124>
        pevent->OSEventPtr = (void *)0;               /* Clear the mailbox                             */
 2019bac:	e0bffd17 	ldw	r2,-12(fp)
 2019bb0:	10000115 	stw	zero,4(r2)
 2019bb4:	e0bff717 	ldw	r2,-36(fp)
 2019bb8:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019bbc:	e0bff917 	ldw	r2,-28(fp)
 2019bc0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 2019bc4:	e0bfff17 	ldw	r2,-4(fp)
 2019bc8:	10000005 	stb	zero,0(r2)
        return (pmsg);                                /* Return the message received (or NULL)         */
 2019bcc:	e0bff617 	ldw	r2,-40(fp)
 2019bd0:	00005b06 	br	2019d40 <OSMboxPend+0x290>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_MBOX;          /* Message not available, task will pend         */
 2019bd4:	00808174 	movhi	r2,517
 2019bd8:	1090aa04 	addi	r2,r2,17064
 2019bdc:	10800017 	ldw	r2,0(r2)
 2019be0:	00c08174 	movhi	r3,517
 2019be4:	18d0aa04 	addi	r3,r3,17064
 2019be8:	18c00017 	ldw	r3,0(r3)
 2019bec:	18c00c03 	ldbu	r3,48(r3)
 2019bf0:	18c00094 	ori	r3,r3,2
 2019bf4:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 2019bf8:	00808174 	movhi	r2,517
 2019bfc:	1090aa04 	addi	r2,r2,17064
 2019c00:	10800017 	ldw	r2,0(r2)
 2019c04:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Load timeout in TCB                           */
 2019c08:	00808174 	movhi	r2,517
 2019c0c:	1090aa04 	addi	r2,r2,17064
 2019c10:	10800017 	ldw	r2,0(r2)
 2019c14:	e0fffe0b 	ldhu	r3,-8(fp)
 2019c18:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 2019c1c:	e13ffd17 	ldw	r4,-12(fp)
 2019c20:	2016da40 	call	2016da4 <OS_EventTaskWait>
 2019c24:	e0bff717 	ldw	r2,-36(fp)
 2019c28:	e0bffa15 	stw	r2,-24(fp)
 2019c2c:	e0bffa17 	ldw	r2,-24(fp)
 2019c30:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready to run  */
 2019c34:	20176280 	call	2017628 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019c38:	0005303a 	rdctl	r2,status
 2019c3c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019c40:	e0fffb17 	ldw	r3,-20(fp)
 2019c44:	00bfff84 	movi	r2,-2
 2019c48:	1884703a 	and	r2,r3,r2
 2019c4c:	1001703a 	wrctl	status,r2
  
  return context;
 2019c50:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 2019c54:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 2019c58:	00808174 	movhi	r2,517
 2019c5c:	1090aa04 	addi	r2,r2,17064
 2019c60:	10800017 	ldw	r2,0(r2)
 2019c64:	10800c43 	ldbu	r2,49(r2)
 2019c68:	10803fcc 	andi	r2,r2,255
 2019c6c:	10000326 	beq	r2,zero,2019c7c <OSMboxPend+0x1cc>
 2019c70:	108000a0 	cmpeqi	r2,r2,2
 2019c74:	1000091e 	bne	r2,zero,2019c9c <OSMboxPend+0x1ec>
 2019c78:	00000d06 	br	2019cb0 <OSMboxPend+0x200>
        case OS_STAT_PEND_OK:
             pmsg =  OSTCBCur->OSTCBMsg;
 2019c7c:	00808174 	movhi	r2,517
 2019c80:	1090aa04 	addi	r2,r2,17064
 2019c84:	10800017 	ldw	r2,0(r2)
 2019c88:	10800917 	ldw	r2,36(r2)
 2019c8c:	e0bff615 	stw	r2,-40(fp)
            *perr =  OS_ERR_NONE;
 2019c90:	e0bfff17 	ldw	r2,-4(fp)
 2019c94:	10000005 	stb	zero,0(r2)
             break;
 2019c98:	00001006 	br	2019cdc <OSMboxPend+0x22c>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 2019c9c:	e03ff615 	stw	zero,-40(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 2019ca0:	e0bfff17 	ldw	r2,-4(fp)
 2019ca4:	00c00384 	movi	r3,14
 2019ca8:	10c00005 	stb	r3,0(r2)
             break;
 2019cac:	00000b06 	br	2019cdc <OSMboxPend+0x22c>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 2019cb0:	00808174 	movhi	r2,517
 2019cb4:	1090aa04 	addi	r2,r2,17064
 2019cb8:	10800017 	ldw	r2,0(r2)
 2019cbc:	1009883a 	mov	r4,r2
 2019cc0:	e17ffd17 	ldw	r5,-12(fp)
 2019cc4:	2016ff40 	call	2016ff4 <OS_EventTaskRemove>
             pmsg = (void *)0;
 2019cc8:	e03ff615 	stw	zero,-40(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 2019ccc:	e0bfff17 	ldw	r2,-4(fp)
 2019cd0:	00c00284 	movi	r3,10
 2019cd4:	10c00005 	stb	r3,0(r2)
             break;
 2019cd8:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 2019cdc:	00808174 	movhi	r2,517
 2019ce0:	1090aa04 	addi	r2,r2,17064
 2019ce4:	10800017 	ldw	r2,0(r2)
 2019ce8:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 2019cec:	00808174 	movhi	r2,517
 2019cf0:	1090aa04 	addi	r2,r2,17064
 2019cf4:	10800017 	ldw	r2,0(r2)
 2019cf8:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 2019cfc:	00808174 	movhi	r2,517
 2019d00:	1090aa04 	addi	r2,r2,17064
 2019d04:	10800017 	ldw	r2,0(r2)
 2019d08:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 2019d0c:	00808174 	movhi	r2,517
 2019d10:	1090aa04 	addi	r2,r2,17064
 2019d14:	10800017 	ldw	r2,0(r2)
 2019d18:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 2019d1c:	00808174 	movhi	r2,517
 2019d20:	1090aa04 	addi	r2,r2,17064
 2019d24:	10800017 	ldw	r2,0(r2)
 2019d28:	10000915 	stw	zero,36(r2)
 2019d2c:	e0bff717 	ldw	r2,-36(fp)
 2019d30:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019d34:	e0bffc17 	ldw	r2,-16(fp)
 2019d38:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 2019d3c:	e0bff617 	ldw	r2,-40(fp)
}
 2019d40:	e037883a 	mov	sp,fp
 2019d44:	dfc00117 	ldw	ra,4(sp)
 2019d48:	df000017 	ldw	fp,0(sp)
 2019d4c:	dec00204 	addi	sp,sp,8
 2019d50:	f800283a 	ret

02019d54 <OSMboxPendAbort>:
*********************************************************************************************************
*/

#if OS_MBOX_PEND_ABORT_EN > 0
INT8U  OSMboxPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 2019d54:	defff604 	addi	sp,sp,-40
 2019d58:	dfc00915 	stw	ra,36(sp)
 2019d5c:	df000815 	stw	fp,32(sp)
 2019d60:	df000804 	addi	fp,sp,32
 2019d64:	e13ffd15 	stw	r4,-12(fp)
 2019d68:	2805883a 	mov	r2,r5
 2019d6c:	e1bfff15 	stw	r6,-4(fp)
 2019d70:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 2019d74:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 2019d78:	e0bfff17 	ldw	r2,-4(fp)
 2019d7c:	1000021e 	bne	r2,zero,2019d88 <OSMboxPendAbort+0x34>
        return (0);
 2019d80:	0005883a 	mov	r2,zero
 2019d84:	00004b06 	br	2019eb4 <OSMboxPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 2019d88:	e0bffd17 	ldw	r2,-12(fp)
 2019d8c:	1000051e 	bne	r2,zero,2019da4 <OSMboxPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 2019d90:	e0bfff17 	ldw	r2,-4(fp)
 2019d94:	00c00104 	movi	r3,4
 2019d98:	10c00005 	stb	r3,0(r2)
        return (0);
 2019d9c:	0005883a 	mov	r2,zero
 2019da0:	00004406 	br	2019eb4 <OSMboxPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 2019da4:	e0bffd17 	ldw	r2,-12(fp)
 2019da8:	10800003 	ldbu	r2,0(r2)
 2019dac:	10803fcc 	andi	r2,r2,255
 2019db0:	10800060 	cmpeqi	r2,r2,1
 2019db4:	1000051e 	bne	r2,zero,2019dcc <OSMboxPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 2019db8:	e0bfff17 	ldw	r2,-4(fp)
 2019dbc:	00c00044 	movi	r3,1
 2019dc0:	10c00005 	stb	r3,0(r2)
        return (0);
 2019dc4:	0005883a 	mov	r2,zero
 2019dc8:	00003a06 	br	2019eb4 <OSMboxPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019dcc:	0005303a 	rdctl	r2,status
 2019dd0:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019dd4:	e0fffa17 	ldw	r3,-24(fp)
 2019dd8:	00bfff84 	movi	r2,-2
 2019ddc:	1884703a 	and	r2,r3,r2
 2019de0:	1001703a 	wrctl	status,r2
  
  return context;
 2019de4:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 2019de8:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on mailbox?      */
 2019dec:	e0bffd17 	ldw	r2,-12(fp)
 2019df0:	10800283 	ldbu	r2,10(r2)
 2019df4:	10803fcc 	andi	r2,r2,255
 2019df8:	10002726 	beq	r2,zero,2019e98 <OSMboxPendAbort+0x144>
        nbr_tasks = 0;
 2019dfc:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 2019e00:	e0bffe03 	ldbu	r2,-8(fp)
 2019e04:	10800060 	cmpeqi	r2,r2,1
 2019e08:	10000a1e 	bne	r2,zero,2019e34 <OSMboxPendAbort+0xe0>
 2019e0c:	00000f06 	br	2019e4c <OSMboxPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on mailbox  */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
 2019e10:	e13ffd17 	ldw	r4,-12(fp)
 2019e14:	000b883a 	mov	r5,zero
 2019e18:	01800084 	movi	r6,2
 2019e1c:	01c00084 	movi	r7,2
 2019e20:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
                     nbr_tasks++;
 2019e24:	e0bff803 	ldbu	r2,-32(fp)
 2019e28:	10800044 	addi	r2,r2,1
 2019e2c:	e0bff805 	stb	r2,-32(fp)
 2019e30:	00000106 	br	2019e38 <OSMboxPendAbort+0xe4>
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on mailbox?      */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on mailbox  */
 2019e34:	0001883a 	nop
 2019e38:	e0bffd17 	ldw	r2,-12(fp)
 2019e3c:	10800283 	ldbu	r2,10(r2)
 2019e40:	10803fcc 	andi	r2,r2,255
 2019e44:	103ff21e 	bne	r2,zero,2019e10 <OSMboxPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 2019e48:	00000906 	br	2019e70 <OSMboxPendAbort+0x11c>
             
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on mailbox  */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_MBOX, OS_STAT_PEND_ABORT);
 2019e4c:	e13ffd17 	ldw	r4,-12(fp)
 2019e50:	000b883a 	mov	r5,zero
 2019e54:	01800084 	movi	r6,2
 2019e58:	01c00084 	movi	r7,2
 2019e5c:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
                 nbr_tasks++;
 2019e60:	e0bff803 	ldbu	r2,-32(fp)
 2019e64:	10800044 	addi	r2,r2,1
 2019e68:	e0bff805 	stb	r2,-32(fp)
                 break;
 2019e6c:	0001883a 	nop
 2019e70:	e0bff917 	ldw	r2,-28(fp)
 2019e74:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019e78:	e0bffb17 	ldw	r2,-20(fp)
 2019e7c:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 2019e80:	20176280 	call	2017628 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 2019e84:	e0bfff17 	ldw	r2,-4(fp)
 2019e88:	00c00384 	movi	r3,14
 2019e8c:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 2019e90:	e0bff803 	ldbu	r2,-32(fp)
 2019e94:	00000706 	br	2019eb4 <OSMboxPendAbort+0x160>
 2019e98:	e0bff917 	ldw	r2,-28(fp)
 2019e9c:	e0bffc15 	stw	r2,-16(fp)
 2019ea0:	e0bffc17 	ldw	r2,-16(fp)
 2019ea4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 2019ea8:	e0bfff17 	ldw	r2,-4(fp)
 2019eac:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on mailbox              */
 2019eb0:	0005883a 	mov	r2,zero
}
 2019eb4:	e037883a 	mov	sp,fp
 2019eb8:	dfc00117 	ldw	ra,4(sp)
 2019ebc:	df000017 	ldw	fp,0(sp)
 2019ec0:	dec00204 	addi	sp,sp,8
 2019ec4:	f800283a 	ret

02019ec8 <OSMboxPost>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_EN > 0
INT8U  OSMboxPost (OS_EVENT *pevent, void *pmsg)
{
 2019ec8:	defff704 	addi	sp,sp,-36
 2019ecc:	dfc00815 	stw	ra,32(sp)
 2019ed0:	df000715 	stw	fp,28(sp)
 2019ed4:	df000704 	addi	fp,sp,28
 2019ed8:	e13ffe15 	stw	r4,-8(fp)
 2019edc:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 2019ee0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 2019ee4:	e0bffe17 	ldw	r2,-8(fp)
 2019ee8:	1000021e 	bne	r2,zero,2019ef4 <OSMboxPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 2019eec:	00800104 	movi	r2,4
 2019ef0:	00003406 	br	2019fc4 <OSMboxPost+0xfc>
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
 2019ef4:	e0bfff17 	ldw	r2,-4(fp)
 2019ef8:	1000021e 	bne	r2,zero,2019f04 <OSMboxPost+0x3c>
        return (OS_ERR_POST_NULL_PTR);
 2019efc:	008000c4 	movi	r2,3
 2019f00:	00003006 	br	2019fc4 <OSMboxPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 2019f04:	e0bffe17 	ldw	r2,-8(fp)
 2019f08:	10800003 	ldbu	r2,0(r2)
 2019f0c:	10803fcc 	andi	r2,r2,255
 2019f10:	10800060 	cmpeqi	r2,r2,1
 2019f14:	1000021e 	bne	r2,zero,2019f20 <OSMboxPost+0x58>
        return (OS_ERR_EVENT_TYPE);
 2019f18:	00800044 	movi	r2,1
 2019f1c:	00002906 	br	2019fc4 <OSMboxPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2019f20:	0005303a 	rdctl	r2,status
 2019f24:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2019f28:	e0fffa17 	ldw	r3,-24(fp)
 2019f2c:	00bfff84 	movi	r2,-2
 2019f30:	1884703a 	and	r2,r3,r2
 2019f34:	1001703a 	wrctl	status,r2
  
  return context;
 2019f38:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 2019f3c:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
 2019f40:	e0bffe17 	ldw	r2,-8(fp)
 2019f44:	10800283 	ldbu	r2,10(r2)
 2019f48:	10803fcc 	andi	r2,r2,255
 2019f4c:	10000c26 	beq	r2,zero,2019f80 <OSMboxPost+0xb8>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
 2019f50:	e13ffe17 	ldw	r4,-8(fp)
 2019f54:	e17fff17 	ldw	r5,-4(fp)
 2019f58:	01800084 	movi	r6,2
 2019f5c:	000f883a 	mov	r7,zero
 2019f60:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 2019f64:	e0bff917 	ldw	r2,-28(fp)
 2019f68:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2019f6c:	e0bffb17 	ldw	r2,-20(fp)
 2019f70:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 2019f74:	20176280 	call	2017628 <OS_Sched>
        return (OS_ERR_NONE);
 2019f78:	0005883a 	mov	r2,zero
 2019f7c:	00001106 	br	2019fc4 <OSMboxPost+0xfc>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
 2019f80:	e0bffe17 	ldw	r2,-8(fp)
 2019f84:	10800117 	ldw	r2,4(r2)
 2019f88:	10000626 	beq	r2,zero,2019fa4 <OSMboxPost+0xdc>
 2019f8c:	e0bff917 	ldw	r2,-28(fp)
 2019f90:	e0bffc15 	stw	r2,-16(fp)
 2019f94:	e0bffc17 	ldw	r2,-16(fp)
 2019f98:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MBOX_FULL);
 2019f9c:	00800504 	movi	r2,20
 2019fa0:	00000806 	br	2019fc4 <OSMboxPost+0xfc>
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
 2019fa4:	e0bffe17 	ldw	r2,-8(fp)
 2019fa8:	e0ffff17 	ldw	r3,-4(fp)
 2019fac:	10c00115 	stw	r3,4(r2)
 2019fb0:	e0bff917 	ldw	r2,-28(fp)
 2019fb4:	e0bffd15 	stw	r2,-12(fp)
 2019fb8:	e0bffd17 	ldw	r2,-12(fp)
 2019fbc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 2019fc0:	0005883a 	mov	r2,zero
}
 2019fc4:	e037883a 	mov	sp,fp
 2019fc8:	dfc00117 	ldw	ra,4(sp)
 2019fcc:	df000017 	ldw	fp,0(sp)
 2019fd0:	dec00204 	addi	sp,sp,8
 2019fd4:	f800283a 	ret

02019fd8 <OSMboxPostOpt>:
*********************************************************************************************************
*/

#if OS_MBOX_POST_OPT_EN > 0
INT8U  OSMboxPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 2019fd8:	defff604 	addi	sp,sp,-40
 2019fdc:	dfc00915 	stw	ra,36(sp)
 2019fe0:	df000815 	stw	fp,32(sp)
 2019fe4:	df000804 	addi	fp,sp,32
 2019fe8:	e13ffd15 	stw	r4,-12(fp)
 2019fec:	e17ffe15 	stw	r5,-8(fp)
 2019ff0:	3005883a 	mov	r2,r6
 2019ff4:	e0bfff05 	stb	r2,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 2019ff8:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 2019ffc:	e0bffd17 	ldw	r2,-12(fp)
 201a000:	1000021e 	bne	r2,zero,201a00c <OSMboxPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 201a004:	00800104 	movi	r2,4
 201a008:	00004506 	br	201a120 <OSMboxPostOpt+0x148>
    }
    if (pmsg == (void *)0) {                          /* Make sure we are not posting a NULL pointer   */
 201a00c:	e0bffe17 	ldw	r2,-8(fp)
 201a010:	1000021e 	bne	r2,zero,201a01c <OSMboxPostOpt+0x44>
        return (OS_ERR_POST_NULL_PTR);
 201a014:	008000c4 	movi	r2,3
 201a018:	00004106 	br	201a120 <OSMboxPostOpt+0x148>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {  /* Validate event block type                     */
 201a01c:	e0bffd17 	ldw	r2,-12(fp)
 201a020:	10800003 	ldbu	r2,0(r2)
 201a024:	10803fcc 	andi	r2,r2,255
 201a028:	10800060 	cmpeqi	r2,r2,1
 201a02c:	1000021e 	bne	r2,zero,201a038 <OSMboxPostOpt+0x60>
        return (OS_ERR_EVENT_TYPE);
 201a030:	00800044 	movi	r2,1
 201a034:	00003a06 	br	201a120 <OSMboxPostOpt+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a038:	0005303a 	rdctl	r2,status
 201a03c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a040:	e0fff917 	ldw	r3,-28(fp)
 201a044:	00bfff84 	movi	r2,-2
 201a048:	1884703a 	and	r2,r3,r2
 201a04c:	1001703a 	wrctl	status,r2
  
  return context;
 201a050:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 201a054:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
 201a058:	e0bffd17 	ldw	r2,-12(fp)
 201a05c:	10800283 	ldbu	r2,10(r2)
 201a060:	10803fcc 	andi	r2,r2,255
 201a064:	10001d26 	beq	r2,zero,201a0dc <OSMboxPostOpt+0x104>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 201a068:	e0bfff03 	ldbu	r2,-4(fp)
 201a06c:	1080004c 	andi	r2,r2,1
 201a070:	10000b26 	beq	r2,zero,201a0a0 <OSMboxPostOpt+0xc8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
 201a074:	00000506 	br	201a08c <OSMboxPostOpt+0xb4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
 201a078:	e13ffd17 	ldw	r4,-12(fp)
 201a07c:	e17ffe17 	ldw	r5,-8(fp)
 201a080:	01800084 	movi	r6,2
 201a084:	000f883a 	mov	r7,zero
 201a088:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on mailbox            */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on mailbox     */
 201a08c:	e0bffd17 	ldw	r2,-12(fp)
 201a090:	10800283 	ldbu	r2,10(r2)
 201a094:	10803fcc 	andi	r2,r2,255
 201a098:	103ff71e 	bne	r2,zero,201a078 <OSMboxPostOpt+0xa0>
 201a09c:	00000506 	br	201a0b4 <OSMboxPostOpt+0xdc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on mbox              */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_MBOX, OS_STAT_PEND_OK);
 201a0a0:	e13ffd17 	ldw	r4,-12(fp)
 201a0a4:	e17ffe17 	ldw	r5,-8(fp)
 201a0a8:	01800084 	movi	r6,2
 201a0ac:	000f883a 	mov	r7,zero
 201a0b0:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201a0b4:	e0bff817 	ldw	r2,-32(fp)
 201a0b8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a0bc:	e0bffa17 	ldw	r2,-24(fp)
 201a0c0:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 201a0c4:	e0bfff03 	ldbu	r2,-4(fp)
 201a0c8:	1080010c 	andi	r2,r2,4
 201a0cc:	1000011e 	bne	r2,zero,201a0d4 <OSMboxPostOpt+0xfc>
            OS_Sched();                               /* Find HPT ready to run                         */
 201a0d0:	20176280 	call	2017628 <OS_Sched>
        }
        return (OS_ERR_NONE);
 201a0d4:	0005883a 	mov	r2,zero
 201a0d8:	00001106 	br	201a120 <OSMboxPostOpt+0x148>
    }
    if (pevent->OSEventPtr != (void *)0) {            /* Make sure mailbox doesn't already have a msg  */
 201a0dc:	e0bffd17 	ldw	r2,-12(fp)
 201a0e0:	10800117 	ldw	r2,4(r2)
 201a0e4:	10000626 	beq	r2,zero,201a100 <OSMboxPostOpt+0x128>
 201a0e8:	e0bff817 	ldw	r2,-32(fp)
 201a0ec:	e0bffb15 	stw	r2,-20(fp)
 201a0f0:	e0bffb17 	ldw	r2,-20(fp)
 201a0f4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MBOX_FULL);
 201a0f8:	00800504 	movi	r2,20
 201a0fc:	00000806 	br	201a120 <OSMboxPostOpt+0x148>
    }
    pevent->OSEventPtr = pmsg;                        /* Place message in mailbox                      */
 201a100:	e0bffd17 	ldw	r2,-12(fp)
 201a104:	e0fffe17 	ldw	r3,-8(fp)
 201a108:	10c00115 	stw	r3,4(r2)
 201a10c:	e0bff817 	ldw	r2,-32(fp)
 201a110:	e0bffc15 	stw	r2,-16(fp)
 201a114:	e0bffc17 	ldw	r2,-16(fp)
 201a118:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201a11c:	0005883a 	mov	r2,zero
}
 201a120:	e037883a 	mov	sp,fp
 201a124:	dfc00117 	ldw	ra,4(sp)
 201a128:	df000017 	ldw	fp,0(sp)
 201a12c:	dec00204 	addi	sp,sp,8
 201a130:	f800283a 	ret

0201a134 <OSMboxQuery>:
*********************************************************************************************************
*/

#if OS_MBOX_QUERY_EN > 0
INT8U  OSMboxQuery (OS_EVENT *pevent, OS_MBOX_DATA *p_mbox_data)
{
 201a134:	defff704 	addi	sp,sp,-36
 201a138:	df000815 	stw	fp,32(sp)
 201a13c:	df000804 	addi	fp,sp,32
 201a140:	e13ffe15 	stw	r4,-8(fp)
 201a144:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201a148:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201a14c:	e0bffe17 	ldw	r2,-8(fp)
 201a150:	1000021e 	bne	r2,zero,201a15c <OSMboxQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 201a154:	00800104 	movi	r2,4
 201a158:	00003806 	br	201a23c <OSMboxQuery+0x108>
    }
    if (p_mbox_data == (OS_MBOX_DATA *)0) {                /* Validate 'p_mbox_data'                   */
 201a15c:	e0bfff17 	ldw	r2,-4(fp)
 201a160:	1000021e 	bne	r2,zero,201a16c <OSMboxQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 201a164:	00800244 	movi	r2,9
 201a168:	00003406 	br	201a23c <OSMboxQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_MBOX) {       /* Validate event block type                */
 201a16c:	e0bffe17 	ldw	r2,-8(fp)
 201a170:	10800003 	ldbu	r2,0(r2)
 201a174:	10803fcc 	andi	r2,r2,255
 201a178:	10800060 	cmpeqi	r2,r2,1
 201a17c:	1000021e 	bne	r2,zero,201a188 <OSMboxQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 201a180:	00800044 	movi	r2,1
 201a184:	00002d06 	br	201a23c <OSMboxQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a188:	0005303a 	rdctl	r2,status
 201a18c:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a190:	e0fffc17 	ldw	r3,-16(fp)
 201a194:	00bfff84 	movi	r2,-2
 201a198:	1884703a 	and	r2,r3,r2
 201a19c:	1001703a 	wrctl	status,r2
  
  return context;
 201a1a0:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201a1a4:	e0bffb15 	stw	r2,-20(fp)
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
 201a1a8:	e0bffe17 	ldw	r2,-8(fp)
 201a1ac:	10c00283 	ldbu	r3,10(r2)
 201a1b0:	e0bfff17 	ldw	r2,-4(fp)
 201a1b4:	10c001c5 	stb	r3,7(r2)
    psrc                    = &pevent->OSEventTbl[0];
 201a1b8:	e0bffe17 	ldw	r2,-8(fp)
 201a1bc:	108002c4 	addi	r2,r2,11
 201a1c0:	e0bff915 	stw	r2,-28(fp)
    pdest                   = &p_mbox_data->OSEventTbl[0];
 201a1c4:	e0bfff17 	ldw	r2,-4(fp)
 201a1c8:	10800104 	addi	r2,r2,4
 201a1cc:	e0bffa15 	stw	r2,-24(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201a1d0:	e03ff805 	stb	zero,-32(fp)
 201a1d4:	00000d06 	br	201a20c <OSMboxQuery+0xd8>
        *pdest++ = *psrc++;
 201a1d8:	e0bff917 	ldw	r2,-28(fp)
 201a1dc:	10c00003 	ldbu	r3,0(r2)
 201a1e0:	e0bffa17 	ldw	r2,-24(fp)
 201a1e4:	10c00005 	stb	r3,0(r2)
 201a1e8:	e0bffa17 	ldw	r2,-24(fp)
 201a1ec:	10800044 	addi	r2,r2,1
 201a1f0:	e0bffa15 	stw	r2,-24(fp)
 201a1f4:	e0bff917 	ldw	r2,-28(fp)
 201a1f8:	10800044 	addi	r2,r2,1
 201a1fc:	e0bff915 	stw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
    p_mbox_data->OSEventGrp = pevent->OSEventGrp;          /* Copy message mailbox wait list           */
    psrc                    = &pevent->OSEventTbl[0];
    pdest                   = &p_mbox_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201a200:	e0bff803 	ldbu	r2,-32(fp)
 201a204:	10800044 	addi	r2,r2,1
 201a208:	e0bff805 	stb	r2,-32(fp)
 201a20c:	e0bff803 	ldbu	r2,-32(fp)
 201a210:	108000f0 	cmpltui	r2,r2,3
 201a214:	103ff01e 	bne	r2,zero,201a1d8 <OSMboxQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_mbox_data->OSMsg = pevent->OSEventPtr;               /* Get message from mailbox                 */
 201a218:	e0bffe17 	ldw	r2,-8(fp)
 201a21c:	10c00117 	ldw	r3,4(r2)
 201a220:	e0bfff17 	ldw	r2,-4(fp)
 201a224:	10c00015 	stw	r3,0(r2)
 201a228:	e0bffb17 	ldw	r2,-20(fp)
 201a22c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a230:	e0bffd17 	ldw	r2,-12(fp)
 201a234:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201a238:	0005883a 	mov	r2,zero
}
 201a23c:	e037883a 	mov	sp,fp
 201a240:	df000017 	ldw	fp,0(sp)
 201a244:	dec00104 	addi	sp,sp,4
 201a248:	f800283a 	ret

0201a24c <OSMemCreate>:
*                              free partition is available.
*********************************************************************************************************
*/

OS_MEM  *OSMemCreate (void *addr, INT32U nblks, INT32U blksize, INT8U *perr)
{
 201a24c:	defff404 	addi	sp,sp,-48
 201a250:	df000b15 	stw	fp,44(sp)
 201a254:	df000b04 	addi	fp,sp,44
 201a258:	e13ffc15 	stw	r4,-16(fp)
 201a25c:	e17ffd15 	stw	r5,-12(fp)
 201a260:	e1bffe15 	stw	r6,-8(fp)
 201a264:	e1ffff15 	stw	r7,-4(fp)
    OS_MEM    *pmem;
    INT8U     *pblk;
    void     **plink;
    INT32U     i;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201a268:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0              
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201a26c:	e0bfff17 	ldw	r2,-4(fp)
 201a270:	1000021e 	bne	r2,zero,201a27c <OSMemCreate+0x30>
        return ((OS_MEM *)0);
 201a274:	0005883a 	mov	r2,zero
 201a278:	00006d06 	br	201a430 <OSMemCreate+0x1e4>
    }
    if (addr == (void *)0) {                          /* Must pass a valid address for the memory part.*/
 201a27c:	e0bffc17 	ldw	r2,-16(fp)
 201a280:	1000051e 	bne	r2,zero,201a298 <OSMemCreate+0x4c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 201a284:	e0bfff17 	ldw	r2,-4(fp)
 201a288:	00c01884 	movi	r3,98
 201a28c:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 201a290:	0005883a 	mov	r2,zero
 201a294:	00006606 	br	201a430 <OSMemCreate+0x1e4>
    }
    if (((INT32U)addr & (sizeof(void *) - 1)) != 0){  /* Must be pointer size aligned                  */
 201a298:	e0bffc17 	ldw	r2,-16(fp)
 201a29c:	108000cc 	andi	r2,r2,3
 201a2a0:	10000526 	beq	r2,zero,201a2b8 <OSMemCreate+0x6c>
        *perr = OS_ERR_MEM_INVALID_ADDR;
 201a2a4:	e0bfff17 	ldw	r2,-4(fp)
 201a2a8:	00c01884 	movi	r3,98
 201a2ac:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 201a2b0:	0005883a 	mov	r2,zero
 201a2b4:	00005e06 	br	201a430 <OSMemCreate+0x1e4>
    }
    if (nblks < 2) {                                  /* Must have at least 2 blocks per partition     */
 201a2b8:	e0bffd17 	ldw	r2,-12(fp)
 201a2bc:	108000a8 	cmpgeui	r2,r2,2
 201a2c0:	1000051e 	bne	r2,zero,201a2d8 <OSMemCreate+0x8c>
        *perr = OS_ERR_MEM_INVALID_BLKS;
 201a2c4:	e0bfff17 	ldw	r2,-4(fp)
 201a2c8:	00c016c4 	movi	r3,91
 201a2cc:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 201a2d0:	0005883a 	mov	r2,zero
 201a2d4:	00005606 	br	201a430 <OSMemCreate+0x1e4>
    }
    if (blksize < sizeof(void *)) {                   /* Must contain space for at least a pointer     */
 201a2d8:	e0bffe17 	ldw	r2,-8(fp)
 201a2dc:	10800128 	cmpgeui	r2,r2,4
 201a2e0:	1000051e 	bne	r2,zero,201a2f8 <OSMemCreate+0xac>
        *perr = OS_ERR_MEM_INVALID_SIZE;
 201a2e4:	e0bfff17 	ldw	r2,-4(fp)
 201a2e8:	00c01704 	movi	r3,92
 201a2ec:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 201a2f0:	0005883a 	mov	r2,zero
 201a2f4:	00004e06 	br	201a430 <OSMemCreate+0x1e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a2f8:	0005303a 	rdctl	r2,status
 201a2fc:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a300:	e0fffa17 	ldw	r3,-24(fp)
 201a304:	00bfff84 	movi	r2,-2
 201a308:	1884703a 	and	r2,r3,r2
 201a30c:	1001703a 	wrctl	status,r2
  
  return context;
 201a310:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201a314:	e0bff815 	stw	r2,-32(fp)
    pmem = OSMemFreeList;                             /* Get next free memory partition                */
 201a318:	00808174 	movhi	r2,517
 201a31c:	1090a404 	addi	r2,r2,17040
 201a320:	10800017 	ldw	r2,0(r2)
 201a324:	e0bff915 	stw	r2,-28(fp)
    if (OSMemFreeList != (OS_MEM *)0) {               /* See if pool of free partitions was empty      */
 201a328:	00808174 	movhi	r2,517
 201a32c:	1090a404 	addi	r2,r2,17040
 201a330:	10800017 	ldw	r2,0(r2)
 201a334:	10000726 	beq	r2,zero,201a354 <OSMemCreate+0x108>
        OSMemFreeList = (OS_MEM *)OSMemFreeList->OSMemFreeList;
 201a338:	00808174 	movhi	r2,517
 201a33c:	1090a404 	addi	r2,r2,17040
 201a340:	10800017 	ldw	r2,0(r2)
 201a344:	10c00117 	ldw	r3,4(r2)
 201a348:	00808174 	movhi	r2,517
 201a34c:	1090a404 	addi	r2,r2,17040
 201a350:	10c00015 	stw	r3,0(r2)
 201a354:	e0bff817 	ldw	r2,-32(fp)
 201a358:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a35c:	e0bffb17 	ldw	r2,-20(fp)
 201a360:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pmem == (OS_MEM *)0) {                        /* See if we have a memory partition             */
 201a364:	e0bff917 	ldw	r2,-28(fp)
 201a368:	1000051e 	bne	r2,zero,201a380 <OSMemCreate+0x134>
        *perr = OS_ERR_MEM_INVALID_PART;
 201a36c:	e0bfff17 	ldw	r2,-4(fp)
 201a370:	00c01684 	movi	r3,90
 201a374:	10c00005 	stb	r3,0(r2)
        return ((OS_MEM *)0);
 201a378:	0005883a 	mov	r2,zero
 201a37c:	00002c06 	br	201a430 <OSMemCreate+0x1e4>
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
 201a380:	e0bffc17 	ldw	r2,-16(fp)
 201a384:	e0bff615 	stw	r2,-40(fp)
    pblk  = (INT8U *)((INT32U)addr + blksize);
 201a388:	e0fffc17 	ldw	r3,-16(fp)
 201a38c:	e0bffe17 	ldw	r2,-8(fp)
 201a390:	1885883a 	add	r2,r3,r2
 201a394:	e0bff515 	stw	r2,-44(fp)
    for (i = 0; i < (nblks - 1); i++) {
 201a398:	e03ff715 	stw	zero,-36(fp)
 201a39c:	00000c06 	br	201a3d0 <OSMemCreate+0x184>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
 201a3a0:	e0bff617 	ldw	r2,-40(fp)
 201a3a4:	e0fff517 	ldw	r3,-44(fp)
 201a3a8:	10c00015 	stw	r3,0(r2)
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
 201a3ac:	e0bff517 	ldw	r2,-44(fp)
 201a3b0:	e0bff615 	stw	r2,-40(fp)
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
 201a3b4:	e0fff517 	ldw	r3,-44(fp)
 201a3b8:	e0bffe17 	ldw	r2,-8(fp)
 201a3bc:	1885883a 	add	r2,r3,r2
 201a3c0:	e0bff515 	stw	r2,-44(fp)
        *perr = OS_ERR_MEM_INVALID_PART;
        return ((OS_MEM *)0);
    }
    plink = (void **)addr;                            /* Create linked list of free memory blocks      */
    pblk  = (INT8U *)((INT32U)addr + blksize);
    for (i = 0; i < (nblks - 1); i++) {
 201a3c4:	e0bff717 	ldw	r2,-36(fp)
 201a3c8:	10800044 	addi	r2,r2,1
 201a3cc:	e0bff715 	stw	r2,-36(fp)
 201a3d0:	e0bffd17 	ldw	r2,-12(fp)
 201a3d4:	10bfffc4 	addi	r2,r2,-1
 201a3d8:	e0fff717 	ldw	r3,-36(fp)
 201a3dc:	18bff036 	bltu	r3,r2,201a3a0 <OSMemCreate+0x154>
       *plink = (void *)pblk;                         /* Save pointer to NEXT block in CURRENT block   */
        plink = (void **)pblk;                        /* Position to  NEXT      block                  */
        pblk  = (INT8U *)((INT32U)pblk + blksize);    /* Point to the FOLLOWING block                  */
    }
    *plink              = (void *)0;                  /* Last memory block points to NULL              */
 201a3e0:	e0bff617 	ldw	r2,-40(fp)
 201a3e4:	10000015 	stw	zero,0(r2)
    pmem->OSMemAddr     = addr;                       /* Store start address of memory partition       */
 201a3e8:	e0bff917 	ldw	r2,-28(fp)
 201a3ec:	e0fffc17 	ldw	r3,-16(fp)
 201a3f0:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = addr;                       /* Initialize pointer to pool of free blocks     */
 201a3f4:	e0bff917 	ldw	r2,-28(fp)
 201a3f8:	e0fffc17 	ldw	r3,-16(fp)
 201a3fc:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree    = nblks;                      /* Store number of free blocks in MCB            */
 201a400:	e0bff917 	ldw	r2,-28(fp)
 201a404:	e0fffd17 	ldw	r3,-12(fp)
 201a408:	10c00415 	stw	r3,16(r2)
    pmem->OSMemNBlks    = nblks;
 201a40c:	e0bff917 	ldw	r2,-28(fp)
 201a410:	e0fffd17 	ldw	r3,-12(fp)
 201a414:	10c00315 	stw	r3,12(r2)
    pmem->OSMemBlkSize  = blksize;                    /* Store block size of each memory blocks        */
 201a418:	e0bff917 	ldw	r2,-28(fp)
 201a41c:	e0fffe17 	ldw	r3,-8(fp)
 201a420:	10c00215 	stw	r3,8(r2)
    *perr               = OS_ERR_NONE;
 201a424:	e0bfff17 	ldw	r2,-4(fp)
 201a428:	10000005 	stb	zero,0(r2)
    return (pmem);
 201a42c:	e0bff917 	ldw	r2,-28(fp)
}
 201a430:	e037883a 	mov	sp,fp
 201a434:	df000017 	ldw	fp,0(sp)
 201a438:	dec00104 	addi	sp,sp,4
 201a43c:	f800283a 	ret

0201a440 <OSMemGet>:
*               A pointer to NULL if an error is detected
*********************************************************************************************************
*/

void  *OSMemGet (OS_MEM *pmem, INT8U *perr)
{
 201a440:	defff804 	addi	sp,sp,-32
 201a444:	df000715 	stw	fp,28(sp)
 201a448:	df000704 	addi	fp,sp,28
 201a44c:	e13ffe15 	stw	r4,-8(fp)
 201a450:	e17fff15 	stw	r5,-4(fp)
    void      *pblk;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201a454:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201a458:	e0bfff17 	ldw	r2,-4(fp)
 201a45c:	1000021e 	bne	r2,zero,201a468 <OSMemGet+0x28>
        return ((void *)0);
 201a460:	0005883a 	mov	r2,zero
 201a464:	00002e06 	br	201a520 <OSMemGet+0xe0>
    }
    if (pmem == (OS_MEM *)0) {                        /* Must point to a valid memory partition        */
 201a468:	e0bffe17 	ldw	r2,-8(fp)
 201a46c:	1000051e 	bne	r2,zero,201a484 <OSMemGet+0x44>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 201a470:	e0bfff17 	ldw	r2,-4(fp)
 201a474:	00c01804 	movi	r3,96
 201a478:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201a47c:	0005883a 	mov	r2,zero
 201a480:	00002706 	br	201a520 <OSMemGet+0xe0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a484:	0005303a 	rdctl	r2,status
 201a488:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a48c:	e0fffb17 	ldw	r3,-20(fp)
 201a490:	00bfff84 	movi	r2,-2
 201a494:	1884703a 	and	r2,r3,r2
 201a498:	1001703a 	wrctl	status,r2
  
  return context;
 201a49c:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201a4a0:	e0bff915 	stw	r2,-28(fp)
    if (pmem->OSMemNFree > 0) {                       /* See if there are any free memory blocks       */
 201a4a4:	e0bffe17 	ldw	r2,-8(fp)
 201a4a8:	10800417 	ldw	r2,16(r2)
 201a4ac:	10001426 	beq	r2,zero,201a500 <OSMemGet+0xc0>
        pblk                = pmem->OSMemFreeList;    /* Yes, point to next free memory block          */
 201a4b0:	e0bffe17 	ldw	r2,-8(fp)
 201a4b4:	10800117 	ldw	r2,4(r2)
 201a4b8:	e0bffa15 	stw	r2,-24(fp)
        pmem->OSMemFreeList = *(void **)pblk;         /*      Adjust pointer to new free list          */
 201a4bc:	e0bffa17 	ldw	r2,-24(fp)
 201a4c0:	10c00017 	ldw	r3,0(r2)
 201a4c4:	e0bffe17 	ldw	r2,-8(fp)
 201a4c8:	10c00115 	stw	r3,4(r2)
        pmem->OSMemNFree--;                           /*      One less memory block in this partition  */
 201a4cc:	e0bffe17 	ldw	r2,-8(fp)
 201a4d0:	10800417 	ldw	r2,16(r2)
 201a4d4:	10ffffc4 	addi	r3,r2,-1
 201a4d8:	e0bffe17 	ldw	r2,-8(fp)
 201a4dc:	10c00415 	stw	r3,16(r2)
 201a4e0:	e0bff917 	ldw	r2,-28(fp)
 201a4e4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a4e8:	e0bffc17 	ldw	r2,-16(fp)
 201a4ec:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;                          /*      No error                                 */
 201a4f0:	e0bfff17 	ldw	r2,-4(fp)
 201a4f4:	10000005 	stb	zero,0(r2)
        return (pblk);                                /*      Return memory block to caller            */
 201a4f8:	e0bffa17 	ldw	r2,-24(fp)
 201a4fc:	00000806 	br	201a520 <OSMemGet+0xe0>
 201a500:	e0bff917 	ldw	r2,-28(fp)
 201a504:	e0bffd15 	stw	r2,-12(fp)
 201a508:	e0bffd17 	ldw	r2,-12(fp)
 201a50c:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_MEM_NO_FREE_BLKS;                  /* No,  Notify caller of empty memory partition  */
 201a510:	e0bfff17 	ldw	r2,-4(fp)
 201a514:	00c01744 	movi	r3,93
 201a518:	10c00005 	stb	r3,0(r2)
    return ((void *)0);                               /*      Return NULL pointer to caller            */
 201a51c:	0005883a 	mov	r2,zero
}
 201a520:	e037883a 	mov	sp,fp
 201a524:	df000017 	ldw	fp,0(sp)
 201a528:	dec00104 	addi	sp,sp,4
 201a52c:	f800283a 	ret

0201a530 <OSMemNameGet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
INT8U  OSMemNameGet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 201a530:	defff704 	addi	sp,sp,-36
 201a534:	dfc00815 	stw	ra,32(sp)
 201a538:	df000715 	stw	fp,28(sp)
 201a53c:	df000704 	addi	fp,sp,28
 201a540:	e13ffd15 	stw	r4,-12(fp)
 201a544:	e17ffe15 	stw	r5,-8(fp)
 201a548:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201a54c:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 201a550:	e0bfff17 	ldw	r2,-4(fp)
 201a554:	1000021e 	bne	r2,zero,201a560 <OSMemNameGet+0x30>
        return (0);
 201a558:	0005883a 	mov	r2,zero
 201a55c:	00002d06 	br	201a614 <OSMemNameGet+0xe4>
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 201a560:	e0bffd17 	ldw	r2,-12(fp)
 201a564:	1000051e 	bne	r2,zero,201a57c <OSMemNameGet+0x4c>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 201a568:	e0bfff17 	ldw	r2,-4(fp)
 201a56c:	00c01804 	movi	r3,96
 201a570:	10c00005 	stb	r3,0(r2)
        return (0);
 201a574:	0005883a 	mov	r2,zero
 201a578:	00002606 	br	201a614 <OSMemNameGet+0xe4>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 201a57c:	e0bffe17 	ldw	r2,-8(fp)
 201a580:	1000051e 	bne	r2,zero,201a598 <OSMemNameGet+0x68>
        *perr = OS_ERR_PNAME_NULL;
 201a584:	e0bfff17 	ldw	r2,-4(fp)
 201a588:	00c00304 	movi	r3,12
 201a58c:	10c00005 	stb	r3,0(r2)
        return (0);
 201a590:	0005883a 	mov	r2,zero
 201a594:	00001f06 	br	201a614 <OSMemNameGet+0xe4>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 201a598:	00808174 	movhi	r2,517
 201a59c:	1090a904 	addi	r2,r2,17060
 201a5a0:	10800003 	ldbu	r2,0(r2)
 201a5a4:	10803fcc 	andi	r2,r2,255
 201a5a8:	10000526 	beq	r2,zero,201a5c0 <OSMemNameGet+0x90>
        *perr = OS_ERR_NAME_GET_ISR;
 201a5ac:	e0bfff17 	ldw	r2,-4(fp)
 201a5b0:	00c00444 	movi	r3,17
 201a5b4:	10c00005 	stb	r3,0(r2)
        return (0);
 201a5b8:	0005883a 	mov	r2,zero
 201a5bc:	00001506 	br	201a614 <OSMemNameGet+0xe4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a5c0:	0005303a 	rdctl	r2,status
 201a5c4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a5c8:	e0fffb17 	ldw	r3,-20(fp)
 201a5cc:	00bfff84 	movi	r2,-2
 201a5d0:	1884703a 	and	r2,r3,r2
 201a5d4:	1001703a 	wrctl	status,r2
  
  return context;
 201a5d8:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 201a5dc:	e0bff915 	stw	r2,-28(fp)
    len   = OS_StrCopy(pname, pmem->OSMemName);  /* Copy name from OS_MEM                              */
 201a5e0:	e0bffd17 	ldw	r2,-12(fp)
 201a5e4:	10800504 	addi	r2,r2,20
 201a5e8:	e13ffe17 	ldw	r4,-8(fp)
 201a5ec:	100b883a 	mov	r5,r2
 201a5f0:	20177640 	call	2017764 <OS_StrCopy>
 201a5f4:	e0bffa05 	stb	r2,-24(fp)
 201a5f8:	e0bff917 	ldw	r2,-28(fp)
 201a5fc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a600:	e0bffc17 	ldw	r2,-16(fp)
 201a604:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201a608:	e0bfff17 	ldw	r2,-4(fp)
 201a60c:	10000005 	stb	zero,0(r2)
    return (len);
 201a610:	e0bffa03 	ldbu	r2,-24(fp)
}
 201a614:	e037883a 	mov	sp,fp
 201a618:	dfc00117 	ldw	ra,4(sp)
 201a61c:	df000017 	ldw	fp,0(sp)
 201a620:	dec00204 	addi	sp,sp,8
 201a624:	f800283a 	ret

0201a628 <OSMemNameSet>:
*********************************************************************************************************
*/

#if OS_MEM_NAME_SIZE > 1
void  OSMemNameSet (OS_MEM *pmem, INT8U *pname, INT8U *perr)
{
 201a628:	defff604 	addi	sp,sp,-40
 201a62c:	dfc00915 	stw	ra,36(sp)
 201a630:	df000815 	stw	fp,32(sp)
 201a634:	df000804 	addi	fp,sp,32
 201a638:	e13ffd15 	stw	r4,-12(fp)
 201a63c:	e17ffe15 	stw	r5,-8(fp)
 201a640:	e1bfff15 	stw	r6,-4(fp)
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201a644:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 201a648:	e0bfff17 	ldw	r2,-4(fp)
 201a64c:	10003726 	beq	r2,zero,201a72c <OSMemNameSet+0x104>
        return;
    }
    if (pmem == (OS_MEM *)0) {                   /* Is 'pmem' a NULL pointer?                          */
 201a650:	e0bffd17 	ldw	r2,-12(fp)
 201a654:	1000041e 	bne	r2,zero,201a668 <OSMemNameSet+0x40>
        *perr = OS_ERR_MEM_INVALID_PMEM;
 201a658:	e0bfff17 	ldw	r2,-4(fp)
 201a65c:	00c01804 	movi	r3,96
 201a660:	10c00005 	stb	r3,0(r2)
        return;
 201a664:	00003206 	br	201a730 <OSMemNameSet+0x108>
    }
    if (pname == (INT8U *)0) {                   /* Is 'pname' a NULL pointer?                         */
 201a668:	e0bffe17 	ldw	r2,-8(fp)
 201a66c:	1000041e 	bne	r2,zero,201a680 <OSMemNameSet+0x58>
        *perr = OS_ERR_PNAME_NULL;
 201a670:	e0bfff17 	ldw	r2,-4(fp)
 201a674:	00c00304 	movi	r3,12
 201a678:	10c00005 	stb	r3,0(r2)
        return;
 201a67c:	00002c06 	br	201a730 <OSMemNameSet+0x108>
    }
#endif
    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 201a680:	00808174 	movhi	r2,517
 201a684:	1090a904 	addi	r2,r2,17060
 201a688:	10800003 	ldbu	r2,0(r2)
 201a68c:	10803fcc 	andi	r2,r2,255
 201a690:	10000426 	beq	r2,zero,201a6a4 <OSMemNameSet+0x7c>
        *perr = OS_ERR_NAME_SET_ISR;
 201a694:	e0bfff17 	ldw	r2,-4(fp)
 201a698:	00c00484 	movi	r3,18
 201a69c:	10c00005 	stb	r3,0(r2)
        return;
 201a6a0:	00002306 	br	201a730 <OSMemNameSet+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a6a4:	0005303a 	rdctl	r2,status
 201a6a8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a6ac:	e0fffa17 	ldw	r3,-24(fp)
 201a6b0:	00bfff84 	movi	r2,-2
 201a6b4:	1884703a 	and	r2,r3,r2
 201a6b8:	1001703a 	wrctl	status,r2
  
  return context;
 201a6bc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 201a6c0:	e0bff815 	stw	r2,-32(fp)
    len = OS_StrLen(pname);                      /* Can we fit the string in the storage area?         */
 201a6c4:	e13ffe17 	ldw	r4,-8(fp)
 201a6c8:	20177e00 	call	20177e0 <OS_StrLen>
 201a6cc:	e0bff905 	stb	r2,-28(fp)
    if (len > (OS_MEM_NAME_SIZE - 1)) {          /* No                                                 */
 201a6d0:	e0bff903 	ldbu	r2,-28(fp)
 201a6d4:	10800830 	cmpltui	r2,r2,32
 201a6d8:	1000081e 	bne	r2,zero,201a6fc <OSMemNameSet+0xd4>
 201a6dc:	e0bff817 	ldw	r2,-32(fp)
 201a6e0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a6e4:	e0bffb17 	ldw	r2,-20(fp)
 201a6e8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_MEM_NAME_TOO_LONG;
 201a6ec:	e0bfff17 	ldw	r2,-4(fp)
 201a6f0:	00c018c4 	movi	r3,99
 201a6f4:	10c00005 	stb	r3,0(r2)
        return;
 201a6f8:	00000d06 	br	201a730 <OSMemNameSet+0x108>
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
 201a6fc:	e0bffd17 	ldw	r2,-12(fp)
 201a700:	10800504 	addi	r2,r2,20
 201a704:	1009883a 	mov	r4,r2
 201a708:	e17ffe17 	ldw	r5,-8(fp)
 201a70c:	20177640 	call	2017764 <OS_StrCopy>
 201a710:	e0bff817 	ldw	r2,-32(fp)
 201a714:	e0bffc15 	stw	r2,-16(fp)
 201a718:	e0bffc17 	ldw	r2,-16(fp)
 201a71c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201a720:	e0bfff17 	ldw	r2,-4(fp)
 201a724:	10000005 	stb	zero,0(r2)
 201a728:	00000106 	br	201a730 <OSMemNameSet+0x108>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
        return;
 201a72c:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(pmem->OSMemName, pname);    /* Yes, copy name to the memory partition header      */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 201a730:	e037883a 	mov	sp,fp
 201a734:	dfc00117 	ldw	ra,4(sp)
 201a738:	df000017 	ldw	fp,0(sp)
 201a73c:	dec00204 	addi	sp,sp,8
 201a740:	f800283a 	ret

0201a744 <OSMemPut>:
*               OS_ERR_MEM_INVALID_PBLK  if you passed a NULL pointer for the block to release.
*********************************************************************************************************
*/

INT8U  OSMemPut (OS_MEM *pmem, void *pblk)
{
 201a744:	defff904 	addi	sp,sp,-28
 201a748:	df000615 	stw	fp,24(sp)
 201a74c:	df000604 	addi	fp,sp,24
 201a750:	e13ffe15 	stw	r4,-8(fp)
 201a754:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201a758:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 201a75c:	e0bffe17 	ldw	r2,-8(fp)
 201a760:	1000021e 	bne	r2,zero,201a76c <OSMemPut+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 201a764:	00801804 	movi	r2,96
 201a768:	00002806 	br	201a80c <OSMemPut+0xc8>
    }
    if (pblk == (void *)0) {                     /* Must release a valid block                         */
 201a76c:	e0bfff17 	ldw	r2,-4(fp)
 201a770:	1000021e 	bne	r2,zero,201a77c <OSMemPut+0x38>
        return (OS_ERR_MEM_INVALID_PBLK);
 201a774:	008017c4 	movi	r2,95
 201a778:	00002406 	br	201a80c <OSMemPut+0xc8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a77c:	0005303a 	rdctl	r2,status
 201a780:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a784:	e0fffb17 	ldw	r3,-20(fp)
 201a788:	00bfff84 	movi	r2,-2
 201a78c:	1884703a 	and	r2,r3,r2
 201a790:	1001703a 	wrctl	status,r2
  
  return context;
 201a794:	e0bffb17 	ldw	r2,-20(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201a798:	e0bffa15 	stw	r2,-24(fp)
    if (pmem->OSMemNFree >= pmem->OSMemNBlks) {  /* Make sure all blocks not already returned          */
 201a79c:	e0bffe17 	ldw	r2,-8(fp)
 201a7a0:	10c00417 	ldw	r3,16(r2)
 201a7a4:	e0bffe17 	ldw	r2,-8(fp)
 201a7a8:	10800317 	ldw	r2,12(r2)
 201a7ac:	18800636 	bltu	r3,r2,201a7c8 <OSMemPut+0x84>
 201a7b0:	e0bffa17 	ldw	r2,-24(fp)
 201a7b4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a7b8:	e0bffc17 	ldw	r2,-16(fp)
 201a7bc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_MEM_FULL);
 201a7c0:	00801784 	movi	r2,94
 201a7c4:	00001106 	br	201a80c <OSMemPut+0xc8>
    }
    *(void **)pblk      = pmem->OSMemFreeList;   /* Insert released block into free block list         */
 201a7c8:	e0bffe17 	ldw	r2,-8(fp)
 201a7cc:	10c00117 	ldw	r3,4(r2)
 201a7d0:	e0bfff17 	ldw	r2,-4(fp)
 201a7d4:	10c00015 	stw	r3,0(r2)
    pmem->OSMemFreeList = pblk;
 201a7d8:	e0bffe17 	ldw	r2,-8(fp)
 201a7dc:	e0ffff17 	ldw	r3,-4(fp)
 201a7e0:	10c00115 	stw	r3,4(r2)
    pmem->OSMemNFree++;                          /* One more memory block in this partition            */
 201a7e4:	e0bffe17 	ldw	r2,-8(fp)
 201a7e8:	10800417 	ldw	r2,16(r2)
 201a7ec:	10c00044 	addi	r3,r2,1
 201a7f0:	e0bffe17 	ldw	r2,-8(fp)
 201a7f4:	10c00415 	stw	r3,16(r2)
 201a7f8:	e0bffa17 	ldw	r2,-24(fp)
 201a7fc:	e0bffd15 	stw	r2,-12(fp)
 201a800:	e0bffd17 	ldw	r2,-12(fp)
 201a804:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);                        /* Notify caller that memory block was released       */
 201a808:	0005883a 	mov	r2,zero
}
 201a80c:	e037883a 	mov	sp,fp
 201a810:	df000017 	ldw	fp,0(sp)
 201a814:	dec00104 	addi	sp,sp,4
 201a818:	f800283a 	ret

0201a81c <OSMemQuery>:
*********************************************************************************************************
*/

#if OS_MEM_QUERY_EN > 0
INT8U  OSMemQuery (OS_MEM *pmem, OS_MEM_DATA *p_mem_data)
{
 201a81c:	defffa04 	addi	sp,sp,-24
 201a820:	df000515 	stw	fp,20(sp)
 201a824:	df000504 	addi	fp,sp,20
 201a828:	e13ffe15 	stw	r4,-8(fp)
 201a82c:	e17fff15 	stw	r5,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201a830:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pmem == (OS_MEM *)0) {                   /* Must point to a valid memory partition             */
 201a834:	e0bffe17 	ldw	r2,-8(fp)
 201a838:	1000021e 	bne	r2,zero,201a844 <OSMemQuery+0x28>
        return (OS_ERR_MEM_INVALID_PMEM);
 201a83c:	00801804 	movi	r2,96
 201a840:	00002c06 	br	201a8f4 <OSMemQuery+0xd8>
    }
    if (p_mem_data == (OS_MEM_DATA *)0) {        /* Must release a valid storage area for the data     */
 201a844:	e0bfff17 	ldw	r2,-4(fp)
 201a848:	1000021e 	bne	r2,zero,201a854 <OSMemQuery+0x38>
        return (OS_ERR_MEM_INVALID_PDATA);
 201a84c:	00801844 	movi	r2,97
 201a850:	00002806 	br	201a8f4 <OSMemQuery+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201a854:	0005303a 	rdctl	r2,status
 201a858:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201a85c:	e0fffc17 	ldw	r3,-16(fp)
 201a860:	00bfff84 	movi	r2,-2
 201a864:	1884703a 	and	r2,r3,r2
 201a868:	1001703a 	wrctl	status,r2
  
  return context;
 201a86c:	e0bffc17 	ldw	r2,-16(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201a870:	e0bffb15 	stw	r2,-20(fp)
    p_mem_data->OSAddr     = pmem->OSMemAddr;
 201a874:	e0bffe17 	ldw	r2,-8(fp)
 201a878:	10c00017 	ldw	r3,0(r2)
 201a87c:	e0bfff17 	ldw	r2,-4(fp)
 201a880:	10c00015 	stw	r3,0(r2)
    p_mem_data->OSFreeList = pmem->OSMemFreeList;
 201a884:	e0bffe17 	ldw	r2,-8(fp)
 201a888:	10c00117 	ldw	r3,4(r2)
 201a88c:	e0bfff17 	ldw	r2,-4(fp)
 201a890:	10c00115 	stw	r3,4(r2)
    p_mem_data->OSBlkSize  = pmem->OSMemBlkSize;
 201a894:	e0bffe17 	ldw	r2,-8(fp)
 201a898:	10c00217 	ldw	r3,8(r2)
 201a89c:	e0bfff17 	ldw	r2,-4(fp)
 201a8a0:	10c00215 	stw	r3,8(r2)
    p_mem_data->OSNBlks    = pmem->OSMemNBlks;
 201a8a4:	e0bffe17 	ldw	r2,-8(fp)
 201a8a8:	10c00317 	ldw	r3,12(r2)
 201a8ac:	e0bfff17 	ldw	r2,-4(fp)
 201a8b0:	10c00315 	stw	r3,12(r2)
    p_mem_data->OSNFree    = pmem->OSMemNFree;
 201a8b4:	e0bffe17 	ldw	r2,-8(fp)
 201a8b8:	10c00417 	ldw	r3,16(r2)
 201a8bc:	e0bfff17 	ldw	r2,-4(fp)
 201a8c0:	10c00415 	stw	r3,16(r2)
 201a8c4:	e0bffb17 	ldw	r2,-20(fp)
 201a8c8:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201a8cc:	e0bffd17 	ldw	r2,-12(fp)
 201a8d0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    p_mem_data->OSNUsed    = p_mem_data->OSNBlks - p_mem_data->OSNFree;
 201a8d4:	e0bfff17 	ldw	r2,-4(fp)
 201a8d8:	10c00317 	ldw	r3,12(r2)
 201a8dc:	e0bfff17 	ldw	r2,-4(fp)
 201a8e0:	10800417 	ldw	r2,16(r2)
 201a8e4:	1887c83a 	sub	r3,r3,r2
 201a8e8:	e0bfff17 	ldw	r2,-4(fp)
 201a8ec:	10c00515 	stw	r3,20(r2)
    return (OS_ERR_NONE);
 201a8f0:	0005883a 	mov	r2,zero
}
 201a8f4:	e037883a 	mov	sp,fp
 201a8f8:	df000017 	ldw	fp,0(sp)
 201a8fc:	dec00104 	addi	sp,sp,4
 201a900:	f800283a 	ret

0201a904 <OS_MemInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_MemInit (void)
{
 201a904:	defffc04 	addi	sp,sp,-16
 201a908:	dfc00315 	stw	ra,12(sp)
 201a90c:	df000215 	stw	fp,8(sp)
 201a910:	df000204 	addi	fp,sp,8
#if OS_MAX_MEM_PART >= 2
    OS_MEM  *pmem;
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
 201a914:	01009934 	movhi	r4,612
 201a918:	2128bf04 	addi	r4,r4,-23812
 201a91c:	01430c04 	movi	r5,3120
 201a920:	20175680 	call	2017568 <OS_MemClr>
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
 201a924:	00809934 	movhi	r2,612
 201a928:	10a8bf04 	addi	r2,r2,-23812
 201a92c:	e0bffe15 	stw	r2,-8(fp)
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 201a930:	e03fff0d 	sth	zero,-4(fp)
 201a934:	00001306 	br	201a984 <OS_MemInit+0x80>
        pmem->OSMemFreeList = (void *)&OSMemTbl[i+1];     /* Chain list of free partitions             */
 201a938:	e0bfff0b 	ldhu	r2,-4(fp)
 201a93c:	10800044 	addi	r2,r2,1
 201a940:	10c00d24 	muli	r3,r2,52
 201a944:	00809934 	movhi	r2,612
 201a948:	10a8bf04 	addi	r2,r2,-23812
 201a94c:	1887883a 	add	r3,r3,r2
 201a950:	e0bffe17 	ldw	r2,-8(fp)
 201a954:	10c00115 	stw	r3,4(r2)
#if OS_MEM_NAME_SIZE > 1
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
 201a958:	e0bffe17 	ldw	r2,-8(fp)
 201a95c:	00c00fc4 	movi	r3,63
 201a960:	10c00505 	stb	r3,20(r2)
        pmem->OSMemName[1]  = OS_ASCII_NUL;
 201a964:	e0bffe17 	ldw	r2,-8(fp)
 201a968:	10000545 	stb	zero,21(r2)
#endif
        pmem++;
 201a96c:	e0bffe17 	ldw	r2,-8(fp)
 201a970:	10800d04 	addi	r2,r2,52
 201a974:	e0bffe15 	stw	r2,-8(fp)
    INT16U   i;


    OS_MemClr((INT8U *)&OSMemTbl[0], sizeof(OSMemTbl));   /* Clear the memory partition table          */
    pmem = &OSMemTbl[0];                                  /* Point to memory control block (MCB)       */
    for (i = 0; i < (OS_MAX_MEM_PART - 1); i++) {         /* Init. list of free memory partitions      */
 201a978:	e0bfff0b 	ldhu	r2,-4(fp)
 201a97c:	10800044 	addi	r2,r2,1
 201a980:	e0bfff0d 	sth	r2,-4(fp)
 201a984:	e0bfff0b 	ldhu	r2,-4(fp)
 201a988:	10800ef0 	cmpltui	r2,r2,59
 201a98c:	103fea1e 	bne	r2,zero,201a938 <OS_MemInit+0x34>
        pmem->OSMemName[0]  = '?';                        /* Unknown name                              */
        pmem->OSMemName[1]  = OS_ASCII_NUL;
#endif
        pmem++;
    }
    pmem->OSMemFreeList = (void *)0;                      /* Initialize last node                      */
 201a990:	e0bffe17 	ldw	r2,-8(fp)
 201a994:	10000115 	stw	zero,4(r2)
#if OS_MEM_NAME_SIZE > 1
    pmem->OSMemName[0]  = '?';                            /* Unknown name                              */
 201a998:	e0bffe17 	ldw	r2,-8(fp)
 201a99c:	00c00fc4 	movi	r3,63
 201a9a0:	10c00505 	stb	r3,20(r2)
    pmem->OSMemName[1]  = OS_ASCII_NUL;
 201a9a4:	e0bffe17 	ldw	r2,-8(fp)
 201a9a8:	10000545 	stb	zero,21(r2)
#endif

    OSMemFreeList       = &OSMemTbl[0];                   /* Point to beginning of free list           */
 201a9ac:	00808174 	movhi	r2,517
 201a9b0:	1090a404 	addi	r2,r2,17040
 201a9b4:	00c09934 	movhi	r3,612
 201a9b8:	18e8bf04 	addi	r3,r3,-23812
 201a9bc:	10c00015 	stw	r3,0(r2)
#endif
}
 201a9c0:	e037883a 	mov	sp,fp
 201a9c4:	dfc00117 	ldw	ra,4(sp)
 201a9c8:	df000017 	ldw	fp,0(sp)
 201a9cc:	dec00204 	addi	sp,sp,8
 201a9d0:	f800283a 	ret

0201a9d4 <OSQAccept>:
*********************************************************************************************************
*/

#if OS_Q_ACCEPT_EN > 0
void  *OSQAccept (OS_EVENT *pevent, INT8U *perr)
{
 201a9d4:	defff804 	addi	sp,sp,-32
 201a9d8:	df000715 	stw	fp,28(sp)
 201a9dc:	df000704 	addi	fp,sp,28
 201a9e0:	e13ffe15 	stw	r4,-8(fp)
 201a9e4:	e17fff15 	stw	r5,-4(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201a9e8:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 201a9ec:	e0bfff17 	ldw	r2,-4(fp)
 201a9f0:	1000021e 	bne	r2,zero,201a9fc <OSQAccept+0x28>
        return ((void *)0);
 201a9f4:	0005883a 	mov	r2,zero
 201a9f8:	00004206 	br	201ab04 <OSQAccept+0x130>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 201a9fc:	e0bffe17 	ldw	r2,-8(fp)
 201aa00:	1000051e 	bne	r2,zero,201aa18 <OSQAccept+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 201aa04:	e0bfff17 	ldw	r2,-4(fp)
 201aa08:	00c00104 	movi	r3,4
 201aa0c:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201aa10:	0005883a 	mov	r2,zero
 201aa14:	00003b06 	br	201ab04 <OSQAccept+0x130>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 201aa18:	e0bffe17 	ldw	r2,-8(fp)
 201aa1c:	10800003 	ldbu	r2,0(r2)
 201aa20:	10803fcc 	andi	r2,r2,255
 201aa24:	108000a0 	cmpeqi	r2,r2,2
 201aa28:	1000051e 	bne	r2,zero,201aa40 <OSQAccept+0x6c>
        *perr = OS_ERR_EVENT_TYPE;
 201aa2c:	e0bfff17 	ldw	r2,-4(fp)
 201aa30:	00c00044 	movi	r3,1
 201aa34:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201aa38:	0005883a 	mov	r2,zero
 201aa3c:	00003106 	br	201ab04 <OSQAccept+0x130>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201aa40:	0005303a 	rdctl	r2,status
 201aa44:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201aa48:	e0fffc17 	ldw	r3,-16(fp)
 201aa4c:	00bfff84 	movi	r2,-2
 201aa50:	1884703a 	and	r2,r3,r2
 201aa54:	1001703a 	wrctl	status,r2
  
  return context;
 201aa58:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201aa5c:	e0bffa15 	stw	r2,-24(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 201aa60:	e0bffe17 	ldw	r2,-8(fp)
 201aa64:	10800117 	ldw	r2,4(r2)
 201aa68:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 201aa6c:	e0bffb17 	ldw	r2,-20(fp)
 201aa70:	1080058b 	ldhu	r2,22(r2)
 201aa74:	10bfffcc 	andi	r2,r2,65535
 201aa78:	10001926 	beq	r2,zero,201aae0 <OSQAccept+0x10c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 201aa7c:	e0bffb17 	ldw	r2,-20(fp)
 201aa80:	10800417 	ldw	r2,16(r2)
 201aa84:	10c00017 	ldw	r3,0(r2)
 201aa88:	e0fff915 	stw	r3,-28(fp)
 201aa8c:	10c00104 	addi	r3,r2,4
 201aa90:	e0bffb17 	ldw	r2,-20(fp)
 201aa94:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 201aa98:	e0bffb17 	ldw	r2,-20(fp)
 201aa9c:	1080058b 	ldhu	r2,22(r2)
 201aaa0:	10bfffc4 	addi	r2,r2,-1
 201aaa4:	1007883a 	mov	r3,r2
 201aaa8:	e0bffb17 	ldw	r2,-20(fp)
 201aaac:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 201aab0:	e0bffb17 	ldw	r2,-20(fp)
 201aab4:	10c00417 	ldw	r3,16(r2)
 201aab8:	e0bffb17 	ldw	r2,-20(fp)
 201aabc:	10800217 	ldw	r2,8(r2)
 201aac0:	1880041e 	bne	r3,r2,201aad4 <OSQAccept+0x100>
            pq->OSQOut = pq->OSQStart;
 201aac4:	e0bffb17 	ldw	r2,-20(fp)
 201aac8:	10c00117 	ldw	r3,4(r2)
 201aacc:	e0bffb17 	ldw	r2,-20(fp)
 201aad0:	10c00415 	stw	r3,16(r2)
        }
        *perr = OS_ERR_NONE;
 201aad4:	e0bfff17 	ldw	r2,-4(fp)
 201aad8:	10000005 	stb	zero,0(r2)
 201aadc:	00000406 	br	201aaf0 <OSQAccept+0x11c>
    } else {
        *perr = OS_ERR_Q_EMPTY;
 201aae0:	e0bfff17 	ldw	r2,-4(fp)
 201aae4:	00c007c4 	movi	r3,31
 201aae8:	10c00005 	stb	r3,0(r2)
        pmsg  = (void *)0;                       /* Queue is empty                                     */
 201aaec:	e03ff915 	stw	zero,-28(fp)
 201aaf0:	e0bffa17 	ldw	r2,-24(fp)
 201aaf4:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201aaf8:	e0bffd17 	ldw	r2,-12(fp)
 201aafc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (pmsg);                               /* Return message received (or NULL)                  */
 201ab00:	e0bff917 	ldw	r2,-28(fp)
}
 201ab04:	e037883a 	mov	sp,fp
 201ab08:	df000017 	ldw	fp,0(sp)
 201ab0c:	dec00104 	addi	sp,sp,4
 201ab10:	f800283a 	ret

0201ab14 <OSQCreate>:
*              == (OS_EVENT *)0  if no event control blocks were available or an error was detected
*********************************************************************************************************
*/

OS_EVENT  *OSQCreate (void **start, INT16U size)
{
 201ab14:	defff404 	addi	sp,sp,-48
 201ab18:	dfc00b15 	stw	ra,44(sp)
 201ab1c:	df000a15 	stw	fp,40(sp)
 201ab20:	df000a04 	addi	fp,sp,40
 201ab24:	e13ffe15 	stw	r4,-8(fp)
 201ab28:	2805883a 	mov	r2,r5
 201ab2c:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201ab30:	e03ff715 	stw	zero,-36(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 201ab34:	00808174 	movhi	r2,517
 201ab38:	1090a904 	addi	r2,r2,17060
 201ab3c:	10800003 	ldbu	r2,0(r2)
 201ab40:	10803fcc 	andi	r2,r2,255
 201ab44:	10000226 	beq	r2,zero,201ab50 <OSQCreate+0x3c>
        return ((OS_EVENT *)0);                  /* ... can't CREATE from an ISR                       */
 201ab48:	0005883a 	mov	r2,zero
 201ab4c:	00006a06 	br	201acf8 <OSQCreate+0x1e4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ab50:	0005303a 	rdctl	r2,status
 201ab54:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201ab58:	e0fff917 	ldw	r3,-28(fp)
 201ab5c:	00bfff84 	movi	r2,-2
 201ab60:	1884703a 	and	r2,r3,r2
 201ab64:	1001703a 	wrctl	status,r2
  
  return context;
 201ab68:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 201ab6c:	e0bff715 	stw	r2,-36(fp)
    pevent = OSEventFreeList;                    /* Get next free event control block                  */
 201ab70:	00808174 	movhi	r2,517
 201ab74:	1090a804 	addi	r2,r2,17056
 201ab78:	10800017 	ldw	r2,0(r2)
 201ab7c:	e0bff615 	stw	r2,-40(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {      /* See if pool of free ECB pool was empty             */
 201ab80:	00808174 	movhi	r2,517
 201ab84:	1090a804 	addi	r2,r2,17056
 201ab88:	10800017 	ldw	r2,0(r2)
 201ab8c:	10000726 	beq	r2,zero,201abac <OSQCreate+0x98>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 201ab90:	00808174 	movhi	r2,517
 201ab94:	1090a804 	addi	r2,r2,17056
 201ab98:	10800017 	ldw	r2,0(r2)
 201ab9c:	10c00117 	ldw	r3,4(r2)
 201aba0:	00808174 	movhi	r2,517
 201aba4:	1090a804 	addi	r2,r2,17056
 201aba8:	10c00015 	stw	r3,0(r2)
 201abac:	e0bff717 	ldw	r2,-36(fp)
 201abb0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201abb4:	e0bffa17 	ldw	r2,-24(fp)
 201abb8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {               /* See if we have an event control block              */
 201abbc:	e0bff617 	ldw	r2,-40(fp)
 201abc0:	10004c26 	beq	r2,zero,201acf4 <OSQCreate+0x1e0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201abc4:	0005303a 	rdctl	r2,status
 201abc8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201abcc:	e0fffb17 	ldw	r3,-20(fp)
 201abd0:	00bfff84 	movi	r2,-2
 201abd4:	1884703a 	and	r2,r3,r2
 201abd8:	1001703a 	wrctl	status,r2
  
  return context;
 201abdc:	e0bffb17 	ldw	r2,-20(fp)
        OS_ENTER_CRITICAL();
 201abe0:	e0bff715 	stw	r2,-36(fp)
        pq = OSQFreeList;                        /* Get a free queue control block                     */
 201abe4:	00808174 	movhi	r2,517
 201abe8:	1090a604 	addi	r2,r2,17048
 201abec:	10800017 	ldw	r2,0(r2)
 201abf0:	e0bff815 	stw	r2,-32(fp)
        if (pq != (OS_Q *)0) {                   /* Were we able to get a queue control block ?        */
 201abf4:	e0bff817 	ldw	r2,-32(fp)
 201abf8:	10003026 	beq	r2,zero,201acbc <OSQCreate+0x1a8>
            OSQFreeList            = OSQFreeList->OSQPtr; /* Yes, Adjust free list pointer to next free*/
 201abfc:	00808174 	movhi	r2,517
 201ac00:	1090a604 	addi	r2,r2,17048
 201ac04:	10800017 	ldw	r2,0(r2)
 201ac08:	10c00017 	ldw	r3,0(r2)
 201ac0c:	00808174 	movhi	r2,517
 201ac10:	1090a604 	addi	r2,r2,17048
 201ac14:	10c00015 	stw	r3,0(r2)
 201ac18:	e0bff717 	ldw	r2,-36(fp)
 201ac1c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ac20:	e0bffc17 	ldw	r2,-16(fp)
 201ac24:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pq->OSQStart           = start;               /*      Initialize the queue                 */
 201ac28:	e0bff817 	ldw	r2,-32(fp)
 201ac2c:	e0fffe17 	ldw	r3,-8(fp)
 201ac30:	10c00115 	stw	r3,4(r2)
            pq->OSQEnd             = &start[size];
 201ac34:	e0bfff0b 	ldhu	r2,-4(fp)
 201ac38:	1085883a 	add	r2,r2,r2
 201ac3c:	1085883a 	add	r2,r2,r2
 201ac40:	e0fffe17 	ldw	r3,-8(fp)
 201ac44:	1887883a 	add	r3,r3,r2
 201ac48:	e0bff817 	ldw	r2,-32(fp)
 201ac4c:	10c00215 	stw	r3,8(r2)
            pq->OSQIn              = start;
 201ac50:	e0bff817 	ldw	r2,-32(fp)
 201ac54:	e0fffe17 	ldw	r3,-8(fp)
 201ac58:	10c00315 	stw	r3,12(r2)
            pq->OSQOut             = start;
 201ac5c:	e0bff817 	ldw	r2,-32(fp)
 201ac60:	e0fffe17 	ldw	r3,-8(fp)
 201ac64:	10c00415 	stw	r3,16(r2)
            pq->OSQSize            = size;
 201ac68:	e0bff817 	ldw	r2,-32(fp)
 201ac6c:	e0ffff0b 	ldhu	r3,-4(fp)
 201ac70:	10c0050d 	sth	r3,20(r2)
            pq->OSQEntries         = 0;
 201ac74:	e0bff817 	ldw	r2,-32(fp)
 201ac78:	1000058d 	sth	zero,22(r2)
            pevent->OSEventType    = OS_EVENT_TYPE_Q;
 201ac7c:	e0bff617 	ldw	r2,-40(fp)
 201ac80:	00c00084 	movi	r3,2
 201ac84:	10c00005 	stb	r3,0(r2)
            pevent->OSEventCnt     = 0;
 201ac88:	e0bff617 	ldw	r2,-40(fp)
 201ac8c:	1000020d 	sth	zero,8(r2)
            pevent->OSEventPtr     = pq;
 201ac90:	e0bff617 	ldw	r2,-40(fp)
 201ac94:	e0fff817 	ldw	r3,-32(fp)
 201ac98:	10c00115 	stw	r3,4(r2)
#if OS_EVENT_NAME_SIZE > 1
            pevent->OSEventName[0] = '?';                  /* Unknown name                             */
 201ac9c:	e0bff617 	ldw	r2,-40(fp)
 201aca0:	00c00fc4 	movi	r3,63
 201aca4:	10c00385 	stb	r3,14(r2)
            pevent->OSEventName[1] = OS_ASCII_NUL;
 201aca8:	e0bff617 	ldw	r2,-40(fp)
 201acac:	100003c5 	stb	zero,15(r2)
#endif
            OS_EventWaitListInit(pevent);                 /*      Initalize the wait list              */
 201acb0:	e13ff617 	ldw	r4,-40(fp)
 201acb4:	201719c0 	call	201719c <OS_EventWaitListInit>
 201acb8:	00000e06 	br	201acf4 <OSQCreate+0x1e0>
        } else {
            pevent->OSEventPtr = (void *)OSEventFreeList; /* No,  Return event control block on error  */
 201acbc:	00808174 	movhi	r2,517
 201acc0:	1090a804 	addi	r2,r2,17056
 201acc4:	10c00017 	ldw	r3,0(r2)
 201acc8:	e0bff617 	ldw	r2,-40(fp)
 201accc:	10c00115 	stw	r3,4(r2)
            OSEventFreeList    = pevent;
 201acd0:	00808174 	movhi	r2,517
 201acd4:	1090a804 	addi	r2,r2,17056
 201acd8:	e0fff617 	ldw	r3,-40(fp)
 201acdc:	10c00015 	stw	r3,0(r2)
 201ace0:	e0bff717 	ldw	r2,-36(fp)
 201ace4:	e0bffd15 	stw	r2,-12(fp)
 201ace8:	e0bffd17 	ldw	r2,-12(fp)
 201acec:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
            pevent = (OS_EVENT *)0;
 201acf0:	e03ff615 	stw	zero,-40(fp)
        }
    }
    return (pevent);
 201acf4:	e0bff617 	ldw	r2,-40(fp)
}
 201acf8:	e037883a 	mov	sp,fp
 201acfc:	dfc00117 	ldw	ra,4(sp)
 201ad00:	df000017 	ldw	fp,0(sp)
 201ad04:	dec00204 	addi	sp,sp,8
 201ad08:	f800283a 	ret

0201ad0c <OSQDel>:
*********************************************************************************************************
*/

#if OS_Q_DEL_EN > 0
OS_EVENT  *OSQDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 201ad0c:	defff204 	addi	sp,sp,-56
 201ad10:	dfc00d15 	stw	ra,52(sp)
 201ad14:	df000c15 	stw	fp,48(sp)
 201ad18:	df000c04 	addi	fp,sp,48
 201ad1c:	e13ffd15 	stw	r4,-12(fp)
 201ad20:	2805883a 	mov	r2,r5
 201ad24:	e1bfff15 	stw	r6,-4(fp)
 201ad28:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201ad2c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 201ad30:	e0bfff17 	ldw	r2,-4(fp)
 201ad34:	1000021e 	bne	r2,zero,201ad40 <OSQDel+0x34>
        return (pevent);
 201ad38:	e0bffd17 	ldw	r2,-12(fp)
 201ad3c:	0000a206 	br	201afc8 <OSQDel+0x2bc>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201ad40:	e0bffd17 	ldw	r2,-12(fp)
 201ad44:	1000051e 	bne	r2,zero,201ad5c <OSQDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201ad48:	e0bfff17 	ldw	r2,-4(fp)
 201ad4c:	00c00104 	movi	r3,4
 201ad50:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201ad54:	e0bffd17 	ldw	r2,-12(fp)
 201ad58:	00009b06 	br	201afc8 <OSQDel+0x2bc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 201ad5c:	e0bffd17 	ldw	r2,-12(fp)
 201ad60:	10800003 	ldbu	r2,0(r2)
 201ad64:	10803fcc 	andi	r2,r2,255
 201ad68:	108000a0 	cmpeqi	r2,r2,2
 201ad6c:	1000051e 	bne	r2,zero,201ad84 <OSQDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201ad70:	e0bfff17 	ldw	r2,-4(fp)
 201ad74:	00c00044 	movi	r3,1
 201ad78:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201ad7c:	e0bffd17 	ldw	r2,-12(fp)
 201ad80:	00009106 	br	201afc8 <OSQDel+0x2bc>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 201ad84:	00808174 	movhi	r2,517
 201ad88:	1090a904 	addi	r2,r2,17060
 201ad8c:	10800003 	ldbu	r2,0(r2)
 201ad90:	10803fcc 	andi	r2,r2,255
 201ad94:	10000526 	beq	r2,zero,201adac <OSQDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                            /* ... can't DELETE from an ISR             */
 201ad98:	e0bfff17 	ldw	r2,-4(fp)
 201ad9c:	00c003c4 	movi	r3,15
 201ada0:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201ada4:	e0bffd17 	ldw	r2,-12(fp)
 201ada8:	00008706 	br	201afc8 <OSQDel+0x2bc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201adac:	0005303a 	rdctl	r2,status
 201adb0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201adb4:	e0fff817 	ldw	r3,-32(fp)
 201adb8:	00bfff84 	movi	r2,-2
 201adbc:	1884703a 	and	r2,r3,r2
 201adc0:	1001703a 	wrctl	status,r2
  
  return context;
 201adc4:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 201adc8:	e0bff615 	stw	r2,-40(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on queue        */
 201adcc:	e0bffd17 	ldw	r2,-12(fp)
 201add0:	10800283 	ldbu	r2,10(r2)
 201add4:	10803fcc 	andi	r2,r2,255
 201add8:	10000326 	beq	r2,zero,201ade8 <OSQDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 201addc:	00800044 	movi	r2,1
 201ade0:	e0bff405 	stb	r2,-48(fp)
 201ade4:	00000106 	br	201adec <OSQDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 201ade8:	e03ff405 	stb	zero,-48(fp)
    }
    switch (opt) {
 201adec:	e0bffe03 	ldbu	r2,-8(fp)
 201adf0:	10000326 	beq	r2,zero,201ae00 <OSQDel+0xf4>
 201adf4:	10800060 	cmpeqi	r2,r2,1
 201adf8:	1000391e 	bne	r2,zero,201aee0 <OSQDel+0x1d4>
 201adfc:	00006706 	br	201af9c <OSQDel+0x290>
        case OS_DEL_NO_PEND:                               /* Delete queue only if no task waiting     */
             if (tasks_waiting == OS_FALSE) {
 201ae00:	e0bff403 	ldbu	r2,-48(fp)
 201ae04:	1000261e 	bne	r2,zero,201aea0 <OSQDel+0x194>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 201ae08:	e0bffd17 	ldw	r2,-12(fp)
 201ae0c:	00c00fc4 	movi	r3,63
 201ae10:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 201ae14:	e0bffd17 	ldw	r2,-12(fp)
 201ae18:	100003c5 	stb	zero,15(r2)
#endif
                 pq                     = (OS_Q *)pevent->OSEventPtr;  /* Return OS_Q to free list     */
 201ae1c:	e0bffd17 	ldw	r2,-12(fp)
 201ae20:	10800117 	ldw	r2,4(r2)
 201ae24:	e0bff715 	stw	r2,-36(fp)
                 pq->OSQPtr             = OSQFreeList;
 201ae28:	00808174 	movhi	r2,517
 201ae2c:	1090a604 	addi	r2,r2,17048
 201ae30:	10c00017 	ldw	r3,0(r2)
 201ae34:	e0bff717 	ldw	r2,-36(fp)
 201ae38:	10c00015 	stw	r3,0(r2)
                 OSQFreeList            = pq;
 201ae3c:	00808174 	movhi	r2,517
 201ae40:	1090a604 	addi	r2,r2,17048
 201ae44:	e0fff717 	ldw	r3,-36(fp)
 201ae48:	10c00015 	stw	r3,0(r2)
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 201ae4c:	e0bffd17 	ldw	r2,-12(fp)
 201ae50:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 201ae54:	00808174 	movhi	r2,517
 201ae58:	1090a804 	addi	r2,r2,17056
 201ae5c:	10c00017 	ldw	r3,0(r2)
 201ae60:	e0bffd17 	ldw	r2,-12(fp)
 201ae64:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 201ae68:	e0bffd17 	ldw	r2,-12(fp)
 201ae6c:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 201ae70:	00808174 	movhi	r2,517
 201ae74:	1090a804 	addi	r2,r2,17056
 201ae78:	e0fffd17 	ldw	r3,-12(fp)
 201ae7c:	10c00015 	stw	r3,0(r2)
 201ae80:	e0bff617 	ldw	r2,-40(fp)
 201ae84:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ae88:	e0bff917 	ldw	r2,-28(fp)
 201ae8c:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 201ae90:	e0bfff17 	ldw	r2,-4(fp)
 201ae94:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
 201ae98:	e03ff515 	stw	zero,-44(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 201ae9c:	00004906 	br	201afc4 <OSQDel+0x2b8>
 201aea0:	e0bff617 	ldw	r2,-40(fp)
 201aea4:	e0bffa15 	stw	r2,-24(fp)
 201aea8:	e0bffa17 	ldw	r2,-24(fp)
 201aeac:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Queue has been deleted                   */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 201aeb0:	e0bfff17 	ldw	r2,-4(fp)
 201aeb4:	00c01244 	movi	r3,73
 201aeb8:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 201aebc:	e0bffd17 	ldw	r2,-12(fp)
 201aec0:	e0bff515 	stw	r2,-44(fp)
             }
             break;
 201aec4:	00003f06 	br	201afc4 <OSQDel+0x2b8>

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
 201aec8:	e13ffd17 	ldw	r4,-12(fp)
 201aecc:	000b883a 	mov	r5,zero
 201aed0:	01800104 	movi	r6,4
 201aed4:	000f883a 	mov	r7,zero
 201aed8:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201aedc:	00000106 	br	201aee4 <OSQDel+0x1d8>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the queue                  */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for queue        */
 201aee0:	0001883a 	nop
 201aee4:	e0bffd17 	ldw	r2,-12(fp)
 201aee8:	10800283 	ldbu	r2,10(r2)
 201aeec:	10803fcc 	andi	r2,r2,255
 201aef0:	103ff51e 	bne	r2,zero,201aec8 <OSQDel+0x1bc>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 201aef4:	e0bffd17 	ldw	r2,-12(fp)
 201aef8:	00c00fc4 	movi	r3,63
 201aefc:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 201af00:	e0bffd17 	ldw	r2,-12(fp)
 201af04:	100003c5 	stb	zero,15(r2)
#endif
             pq                     = (OS_Q *)pevent->OSEventPtr;   /* Return OS_Q to free list        */
 201af08:	e0bffd17 	ldw	r2,-12(fp)
 201af0c:	10800117 	ldw	r2,4(r2)
 201af10:	e0bff715 	stw	r2,-36(fp)
             pq->OSQPtr             = OSQFreeList;
 201af14:	00808174 	movhi	r2,517
 201af18:	1090a604 	addi	r2,r2,17048
 201af1c:	10c00017 	ldw	r3,0(r2)
 201af20:	e0bff717 	ldw	r2,-36(fp)
 201af24:	10c00015 	stw	r3,0(r2)
             OSQFreeList            = pq;
 201af28:	00808174 	movhi	r2,517
 201af2c:	1090a604 	addi	r2,r2,17048
 201af30:	e0fff717 	ldw	r3,-36(fp)
 201af34:	10c00015 	stw	r3,0(r2)
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 201af38:	e0bffd17 	ldw	r2,-12(fp)
 201af3c:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 201af40:	00808174 	movhi	r2,517
 201af44:	1090a804 	addi	r2,r2,17056
 201af48:	10c00017 	ldw	r3,0(r2)
 201af4c:	e0bffd17 	ldw	r2,-12(fp)
 201af50:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 201af54:	e0bffd17 	ldw	r2,-12(fp)
 201af58:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 201af5c:	00808174 	movhi	r2,517
 201af60:	1090a804 	addi	r2,r2,17056
 201af64:	e0fffd17 	ldw	r3,-12(fp)
 201af68:	10c00015 	stw	r3,0(r2)
 201af6c:	e0bff617 	ldw	r2,-40(fp)
 201af70:	e0bffb15 	stw	r2,-20(fp)
 201af74:	e0bffb17 	ldw	r2,-20(fp)
 201af78:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 201af7c:	e0bff403 	ldbu	r2,-48(fp)
 201af80:	10800058 	cmpnei	r2,r2,1
 201af84:	1000011e 	bne	r2,zero,201af8c <OSQDel+0x280>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 201af88:	20176280 	call	2017628 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 201af8c:	e0bfff17 	ldw	r2,-4(fp)
 201af90:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Queue has been deleted                   */
 201af94:	e03ff515 	stw	zero,-44(fp)
             break;
 201af98:	00000a06 	br	201afc4 <OSQDel+0x2b8>
 201af9c:	e0bff617 	ldw	r2,-40(fp)
 201afa0:	e0bffc15 	stw	r2,-16(fp)
 201afa4:	e0bffc17 	ldw	r2,-16(fp)
 201afa8:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 201afac:	e0bfff17 	ldw	r2,-4(fp)
 201afb0:	00c001c4 	movi	r3,7
 201afb4:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 201afb8:	e0bffd17 	ldw	r2,-12(fp)
 201afbc:	e0bff515 	stw	r2,-44(fp)
             break;
 201afc0:	0001883a 	nop
    }
    return (pevent_return);
 201afc4:	e0bff517 	ldw	r2,-44(fp)
}
 201afc8:	e037883a 	mov	sp,fp
 201afcc:	dfc00117 	ldw	ra,4(sp)
 201afd0:	df000017 	ldw	fp,0(sp)
 201afd4:	dec00204 	addi	sp,sp,8
 201afd8:	f800283a 	ret

0201afdc <OSQFlush>:
*********************************************************************************************************
*/

#if OS_Q_FLUSH_EN > 0
INT8U  OSQFlush (OS_EVENT *pevent)
{
 201afdc:	defffa04 	addi	sp,sp,-24
 201afe0:	df000515 	stw	fp,20(sp)
 201afe4:	df000504 	addi	fp,sp,20
 201afe8:	e13fff15 	stw	r4,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201afec:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201aff0:	e0bfff17 	ldw	r2,-4(fp)
 201aff4:	1000021e 	bne	r2,zero,201b000 <OSQFlush+0x24>
        return (OS_ERR_PEVENT_NULL);
 201aff8:	00800104 	movi	r2,4
 201affc:	00002106 	br	201b084 <OSQFlush+0xa8>
    }
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 201b000:	e0bfff17 	ldw	r2,-4(fp)
 201b004:	10800003 	ldbu	r2,0(r2)
 201b008:	10803fcc 	andi	r2,r2,255
 201b00c:	108000a0 	cmpeqi	r2,r2,2
 201b010:	1000021e 	bne	r2,zero,201b01c <OSQFlush+0x40>
        return (OS_ERR_EVENT_TYPE);
 201b014:	00800044 	movi	r2,1
 201b018:	00001a06 	br	201b084 <OSQFlush+0xa8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b01c:	0005303a 	rdctl	r2,status
 201b020:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b024:	e0fffd17 	ldw	r3,-12(fp)
 201b028:	00bfff84 	movi	r2,-2
 201b02c:	1884703a 	and	r2,r3,r2
 201b030:	1001703a 	wrctl	status,r2
  
  return context;
 201b034:	e0bffd17 	ldw	r2,-12(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201b038:	e0bffb15 	stw	r2,-20(fp)
    pq             = (OS_Q *)pevent->OSEventPtr;      /* Point to queue storage structure              */
 201b03c:	e0bfff17 	ldw	r2,-4(fp)
 201b040:	10800117 	ldw	r2,4(r2)
 201b044:	e0bffc15 	stw	r2,-16(fp)
    pq->OSQIn      = pq->OSQStart;
 201b048:	e0bffc17 	ldw	r2,-16(fp)
 201b04c:	10c00117 	ldw	r3,4(r2)
 201b050:	e0bffc17 	ldw	r2,-16(fp)
 201b054:	10c00315 	stw	r3,12(r2)
    pq->OSQOut     = pq->OSQStart;
 201b058:	e0bffc17 	ldw	r2,-16(fp)
 201b05c:	10c00117 	ldw	r3,4(r2)
 201b060:	e0bffc17 	ldw	r2,-16(fp)
 201b064:	10c00415 	stw	r3,16(r2)
    pq->OSQEntries = 0;
 201b068:	e0bffc17 	ldw	r2,-16(fp)
 201b06c:	1000058d 	sth	zero,22(r2)
 201b070:	e0bffb17 	ldw	r2,-20(fp)
 201b074:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b078:	e0bffe17 	ldw	r2,-8(fp)
 201b07c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201b080:	0005883a 	mov	r2,zero
}
 201b084:	e037883a 	mov	sp,fp
 201b088:	df000017 	ldw	fp,0(sp)
 201b08c:	dec00104 	addi	sp,sp,4
 201b090:	f800283a 	ret

0201b094 <OSQPend>:
* Note(s)    : As of V2.60, this function allows you to receive NULL pointer messages.
*********************************************************************************************************
*/

void  *OSQPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 201b094:	defff304 	addi	sp,sp,-52
 201b098:	dfc00c15 	stw	ra,48(sp)
 201b09c:	df000b15 	stw	fp,44(sp)
 201b0a0:	df000b04 	addi	fp,sp,44
 201b0a4:	e13ffd15 	stw	r4,-12(fp)
 201b0a8:	2805883a 	mov	r2,r5
 201b0ac:	e1bfff15 	stw	r6,-4(fp)
 201b0b0:	e0bffe0d 	sth	r2,-8(fp)
    void      *pmsg;
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201b0b4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                    /* Validate 'perr'                                    */
 201b0b8:	e0bfff17 	ldw	r2,-4(fp)
 201b0bc:	1000021e 	bne	r2,zero,201b0c8 <OSQPend+0x34>
        return ((void *)0);
 201b0c0:	0005883a 	mov	r2,zero
 201b0c4:	0000ad06 	br	201b37c <OSQPend+0x2e8>
    }
    if (pevent == (OS_EVENT *)0) {               /* Validate 'pevent'                                  */
 201b0c8:	e0bffd17 	ldw	r2,-12(fp)
 201b0cc:	1000051e 	bne	r2,zero,201b0e4 <OSQPend+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201b0d0:	e0bfff17 	ldw	r2,-4(fp)
 201b0d4:	00c00104 	movi	r3,4
 201b0d8:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201b0dc:	0005883a 	mov	r2,zero
 201b0e0:	0000a606 	br	201b37c <OSQPend+0x2e8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {/* Validate event block type                          */
 201b0e4:	e0bffd17 	ldw	r2,-12(fp)
 201b0e8:	10800003 	ldbu	r2,0(r2)
 201b0ec:	10803fcc 	andi	r2,r2,255
 201b0f0:	108000a0 	cmpeqi	r2,r2,2
 201b0f4:	1000051e 	bne	r2,zero,201b10c <OSQPend+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201b0f8:	e0bfff17 	ldw	r2,-4(fp)
 201b0fc:	00c00044 	movi	r3,1
 201b100:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201b104:	0005883a 	mov	r2,zero
 201b108:	00009c06 	br	201b37c <OSQPend+0x2e8>
    }
    if (OSIntNesting > 0) {                      /* See if called from ISR ...                         */
 201b10c:	00808174 	movhi	r2,517
 201b110:	1090a904 	addi	r2,r2,17060
 201b114:	10800003 	ldbu	r2,0(r2)
 201b118:	10803fcc 	andi	r2,r2,255
 201b11c:	10000526 	beq	r2,zero,201b134 <OSQPend+0xa0>
        *perr = OS_ERR_PEND_ISR;                 /* ... can't PEND from an ISR                         */
 201b120:	e0bfff17 	ldw	r2,-4(fp)
 201b124:	00c00084 	movi	r3,2
 201b128:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201b12c:	0005883a 	mov	r2,zero
 201b130:	00009206 	br	201b37c <OSQPend+0x2e8>
    }
    if (OSLockNesting > 0) {                     /* See if called with scheduler locked ...            */
 201b134:	00808174 	movhi	r2,517
 201b138:	10909b04 	addi	r2,r2,17004
 201b13c:	10800003 	ldbu	r2,0(r2)
 201b140:	10803fcc 	andi	r2,r2,255
 201b144:	10000526 	beq	r2,zero,201b15c <OSQPend+0xc8>
        *perr = OS_ERR_PEND_LOCKED;              /* ... can't PEND when locked                         */
 201b148:	e0bfff17 	ldw	r2,-4(fp)
 201b14c:	00c00344 	movi	r3,13
 201b150:	10c00005 	stb	r3,0(r2)
        return ((void *)0);
 201b154:	0005883a 	mov	r2,zero
 201b158:	00008806 	br	201b37c <OSQPend+0x2e8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b15c:	0005303a 	rdctl	r2,status
 201b160:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b164:	e0fff817 	ldw	r3,-32(fp)
 201b168:	00bfff84 	movi	r2,-2
 201b16c:	1884703a 	and	r2,r3,r2
 201b170:	1001703a 	wrctl	status,r2
  
  return context;
 201b174:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 201b178:	e0bff615 	stw	r2,-40(fp)
    pq = (OS_Q *)pevent->OSEventPtr;             /* Point at queue control block                       */
 201b17c:	e0bffd17 	ldw	r2,-12(fp)
 201b180:	10800117 	ldw	r2,4(r2)
 201b184:	e0bff715 	stw	r2,-36(fp)
    if (pq->OSQEntries > 0) {                    /* See if any messages in the queue                   */
 201b188:	e0bff717 	ldw	r2,-36(fp)
 201b18c:	1080058b 	ldhu	r2,22(r2)
 201b190:	10bfffcc 	andi	r2,r2,65535
 201b194:	10001e26 	beq	r2,zero,201b210 <OSQPend+0x17c>
        pmsg = *pq->OSQOut++;                    /* Yes, extract oldest message from the queue         */
 201b198:	e0bff717 	ldw	r2,-36(fp)
 201b19c:	10800417 	ldw	r2,16(r2)
 201b1a0:	10c00017 	ldw	r3,0(r2)
 201b1a4:	e0fff515 	stw	r3,-44(fp)
 201b1a8:	10c00104 	addi	r3,r2,4
 201b1ac:	e0bff717 	ldw	r2,-36(fp)
 201b1b0:	10c00415 	stw	r3,16(r2)
        pq->OSQEntries--;                        /* Update the number of entries in the queue          */
 201b1b4:	e0bff717 	ldw	r2,-36(fp)
 201b1b8:	1080058b 	ldhu	r2,22(r2)
 201b1bc:	10bfffc4 	addi	r2,r2,-1
 201b1c0:	1007883a 	mov	r3,r2
 201b1c4:	e0bff717 	ldw	r2,-36(fp)
 201b1c8:	10c0058d 	sth	r3,22(r2)
        if (pq->OSQOut == pq->OSQEnd) {          /* Wrap OUT pointer if we are at the end of the queue */
 201b1cc:	e0bff717 	ldw	r2,-36(fp)
 201b1d0:	10c00417 	ldw	r3,16(r2)
 201b1d4:	e0bff717 	ldw	r2,-36(fp)
 201b1d8:	10800217 	ldw	r2,8(r2)
 201b1dc:	1880041e 	bne	r3,r2,201b1f0 <OSQPend+0x15c>
            pq->OSQOut = pq->OSQStart;
 201b1e0:	e0bff717 	ldw	r2,-36(fp)
 201b1e4:	10c00117 	ldw	r3,4(r2)
 201b1e8:	e0bff717 	ldw	r2,-36(fp)
 201b1ec:	10c00415 	stw	r3,16(r2)
 201b1f0:	e0bff617 	ldw	r2,-40(fp)
 201b1f4:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b1f8:	e0bff917 	ldw	r2,-28(fp)
 201b1fc:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 201b200:	e0bfff17 	ldw	r2,-4(fp)
 201b204:	10000005 	stb	zero,0(r2)
        return (pmsg);                           /* Return message received                            */
 201b208:	e0bff517 	ldw	r2,-44(fp)
 201b20c:	00005b06 	br	201b37c <OSQPend+0x2e8>
    }
    OSTCBCur->OSTCBStat     |= OS_STAT_Q;        /* Task will have to pend for a message to be posted  */
 201b210:	00808174 	movhi	r2,517
 201b214:	1090aa04 	addi	r2,r2,17064
 201b218:	10800017 	ldw	r2,0(r2)
 201b21c:	00c08174 	movhi	r3,517
 201b220:	18d0aa04 	addi	r3,r3,17064
 201b224:	18c00017 	ldw	r3,0(r3)
 201b228:	18c00c03 	ldbu	r3,48(r3)
 201b22c:	18c00114 	ori	r3,r3,4
 201b230:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 201b234:	00808174 	movhi	r2,517
 201b238:	1090aa04 	addi	r2,r2,17064
 201b23c:	10800017 	ldw	r2,0(r2)
 201b240:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;          /* Load timeout into TCB                              */
 201b244:	00808174 	movhi	r2,517
 201b248:	1090aa04 	addi	r2,r2,17064
 201b24c:	10800017 	ldw	r2,0(r2)
 201b250:	e0fffe0b 	ldhu	r3,-8(fp)
 201b254:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                    /* Suspend task until event or timeout occurs         */
 201b258:	e13ffd17 	ldw	r4,-12(fp)
 201b25c:	2016da40 	call	2016da4 <OS_EventTaskWait>
 201b260:	e0bff617 	ldw	r2,-40(fp)
 201b264:	e0bffa15 	stw	r2,-24(fp)
 201b268:	e0bffa17 	ldw	r2,-24(fp)
 201b26c:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                  /* Find next highest priority task ready to run       */
 201b270:	20176280 	call	2017628 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b274:	0005303a 	rdctl	r2,status
 201b278:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b27c:	e0fffb17 	ldw	r3,-20(fp)
 201b280:	00bfff84 	movi	r2,-2
 201b284:	1884703a 	and	r2,r3,r2
 201b288:	1001703a 	wrctl	status,r2
  
  return context;
 201b28c:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 201b290:	e0bff615 	stw	r2,-40(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 201b294:	00808174 	movhi	r2,517
 201b298:	1090aa04 	addi	r2,r2,17064
 201b29c:	10800017 	ldw	r2,0(r2)
 201b2a0:	10800c43 	ldbu	r2,49(r2)
 201b2a4:	10803fcc 	andi	r2,r2,255
 201b2a8:	10000326 	beq	r2,zero,201b2b8 <OSQPend+0x224>
 201b2ac:	108000a0 	cmpeqi	r2,r2,2
 201b2b0:	1000091e 	bne	r2,zero,201b2d8 <OSQPend+0x244>
 201b2b4:	00000d06 	br	201b2ec <OSQPend+0x258>
        case OS_STAT_PEND_OK:                         /* Extract message from TCB (Put there by QPost) */
             pmsg =  OSTCBCur->OSTCBMsg;
 201b2b8:	00808174 	movhi	r2,517
 201b2bc:	1090aa04 	addi	r2,r2,17064
 201b2c0:	10800017 	ldw	r2,0(r2)
 201b2c4:	10800917 	ldw	r2,36(r2)
 201b2c8:	e0bff515 	stw	r2,-44(fp)
            *perr =  OS_ERR_NONE;
 201b2cc:	e0bfff17 	ldw	r2,-4(fp)
 201b2d0:	10000005 	stb	zero,0(r2)
             break;
 201b2d4:	00001006 	br	201b318 <OSQPend+0x284>

        case OS_STAT_PEND_ABORT:
             pmsg = (void *)0;
 201b2d8:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 201b2dc:	e0bfff17 	ldw	r2,-4(fp)
 201b2e0:	00c00384 	movi	r3,14
 201b2e4:	10c00005 	stb	r3,0(r2)
             break;
 201b2e8:	00000b06 	br	201b318 <OSQPend+0x284>

        case OS_STAT_PEND_TO:
        default:
             OS_EventTaskRemove(OSTCBCur, pevent);
 201b2ec:	00808174 	movhi	r2,517
 201b2f0:	1090aa04 	addi	r2,r2,17064
 201b2f4:	10800017 	ldw	r2,0(r2)
 201b2f8:	1009883a 	mov	r4,r2
 201b2fc:	e17ffd17 	ldw	r5,-12(fp)
 201b300:	2016ff40 	call	2016ff4 <OS_EventTaskRemove>
             pmsg = (void *)0;
 201b304:	e03ff515 	stw	zero,-44(fp)
            *perr =  OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 201b308:	e0bfff17 	ldw	r2,-4(fp)
 201b30c:	00c00284 	movi	r3,10
 201b310:	10c00005 	stb	r3,0(r2)
             break;
 201b314:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 201b318:	00808174 	movhi	r2,517
 201b31c:	1090aa04 	addi	r2,r2,17064
 201b320:	10800017 	ldw	r2,0(r2)
 201b324:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 201b328:	00808174 	movhi	r2,517
 201b32c:	1090aa04 	addi	r2,r2,17064
 201b330:	10800017 	ldw	r2,0(r2)
 201b334:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 201b338:	00808174 	movhi	r2,517
 201b33c:	1090aa04 	addi	r2,r2,17064
 201b340:	10800017 	ldw	r2,0(r2)
 201b344:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 201b348:	00808174 	movhi	r2,517
 201b34c:	1090aa04 	addi	r2,r2,17064
 201b350:	10800017 	ldw	r2,0(r2)
 201b354:	10000815 	stw	zero,32(r2)
#endif
    OSTCBCur->OSTCBMsg           = (void      *)0;    /* Clear  received message                       */
 201b358:	00808174 	movhi	r2,517
 201b35c:	1090aa04 	addi	r2,r2,17064
 201b360:	10800017 	ldw	r2,0(r2)
 201b364:	10000915 	stw	zero,36(r2)
 201b368:	e0bff617 	ldw	r2,-40(fp)
 201b36c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b370:	e0bffc17 	ldw	r2,-16(fp)
 201b374:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (pmsg);                                    /* Return received message                       */
 201b378:	e0bff517 	ldw	r2,-44(fp)
}
 201b37c:	e037883a 	mov	sp,fp
 201b380:	dfc00117 	ldw	ra,4(sp)
 201b384:	df000017 	ldw	fp,0(sp)
 201b388:	dec00204 	addi	sp,sp,8
 201b38c:	f800283a 	ret

0201b390 <OSQPendAbort>:
*********************************************************************************************************
*/

#if OS_Q_PEND_ABORT_EN > 0
INT8U  OSQPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 201b390:	defff604 	addi	sp,sp,-40
 201b394:	dfc00915 	stw	ra,36(sp)
 201b398:	df000815 	stw	fp,32(sp)
 201b39c:	df000804 	addi	fp,sp,32
 201b3a0:	e13ffd15 	stw	r4,-12(fp)
 201b3a4:	2805883a 	mov	r2,r5
 201b3a8:	e1bfff15 	stw	r6,-4(fp)
 201b3ac:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201b3b0:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 201b3b4:	e0bfff17 	ldw	r2,-4(fp)
 201b3b8:	1000021e 	bne	r2,zero,201b3c4 <OSQPendAbort+0x34>
        return (0);
 201b3bc:	0005883a 	mov	r2,zero
 201b3c0:	00004b06 	br	201b4f0 <OSQPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201b3c4:	e0bffd17 	ldw	r2,-12(fp)
 201b3c8:	1000051e 	bne	r2,zero,201b3e0 <OSQPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201b3cc:	e0bfff17 	ldw	r2,-4(fp)
 201b3d0:	00c00104 	movi	r3,4
 201b3d4:	10c00005 	stb	r3,0(r2)
        return (0);
 201b3d8:	0005883a 	mov	r2,zero
 201b3dc:	00004406 	br	201b4f0 <OSQPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {          /* Validate event block type                */
 201b3e0:	e0bffd17 	ldw	r2,-12(fp)
 201b3e4:	10800003 	ldbu	r2,0(r2)
 201b3e8:	10803fcc 	andi	r2,r2,255
 201b3ec:	108000a0 	cmpeqi	r2,r2,2
 201b3f0:	1000051e 	bne	r2,zero,201b408 <OSQPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201b3f4:	e0bfff17 	ldw	r2,-4(fp)
 201b3f8:	00c00044 	movi	r3,1
 201b3fc:	10c00005 	stb	r3,0(r2)
        return (0);
 201b400:	0005883a 	mov	r2,zero
 201b404:	00003a06 	br	201b4f0 <OSQPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b408:	0005303a 	rdctl	r2,status
 201b40c:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b410:	e0fffa17 	ldw	r3,-24(fp)
 201b414:	00bfff84 	movi	r2,-2
 201b418:	1884703a 	and	r2,r3,r2
 201b41c:	1001703a 	wrctl	status,r2
  
  return context;
 201b420:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 201b424:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
 201b428:	e0bffd17 	ldw	r2,-12(fp)
 201b42c:	10800283 	ldbu	r2,10(r2)
 201b430:	10803fcc 	andi	r2,r2,255
 201b434:	10002726 	beq	r2,zero,201b4d4 <OSQPendAbort+0x144>
        nbr_tasks = 0;
 201b438:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 201b43c:	e0bffe03 	ldbu	r2,-8(fp)
 201b440:	10800060 	cmpeqi	r2,r2,1
 201b444:	10000a1e 	bne	r2,zero,201b470 <OSQPendAbort+0xe0>
 201b448:	00000f06 	br	201b488 <OSQPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 201b44c:	e13ffd17 	ldw	r4,-12(fp)
 201b450:	000b883a 	mov	r5,zero
 201b454:	01800104 	movi	r6,4
 201b458:	01c00084 	movi	r7,2
 201b45c:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
                     nbr_tasks++;
 201b460:	e0bff803 	ldbu	r2,-32(fp)
 201b464:	10800044 	addi	r2,r2,1
 201b468:	e0bff805 	stb	r2,-32(fp)
 201b46c:	00000106 	br	201b474 <OSQPendAbort+0xe4>
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                         /* See if any task waiting on queue?        */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:                    /* Do we need to abort ALL waiting tasks?   */
                 while (pevent->OSEventGrp != 0) {         /* Yes, ready ALL tasks waiting on queue    */
 201b470:	0001883a 	nop
 201b474:	e0bffd17 	ldw	r2,-12(fp)
 201b478:	10800283 	ldbu	r2,10(r2)
 201b47c:	10803fcc 	andi	r2,r2,255
 201b480:	103ff21e 	bne	r2,zero,201b44c <OSQPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 201b484:	00000906 	br	201b4ac <OSQPendAbort+0x11c>
               
            case OS_PEND_OPT_NONE:
            default:                                       /* No,  ready HPT       waiting on queue    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_Q, OS_STAT_PEND_ABORT);
 201b488:	e13ffd17 	ldw	r4,-12(fp)
 201b48c:	000b883a 	mov	r5,zero
 201b490:	01800104 	movi	r6,4
 201b494:	01c00084 	movi	r7,2
 201b498:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
                 nbr_tasks++;
 201b49c:	e0bff803 	ldbu	r2,-32(fp)
 201b4a0:	10800044 	addi	r2,r2,1
 201b4a4:	e0bff805 	stb	r2,-32(fp)
                 break;
 201b4a8:	0001883a 	nop
 201b4ac:	e0bff917 	ldw	r2,-28(fp)
 201b4b0:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b4b4:	e0bffb17 	ldw	r2,-20(fp)
 201b4b8:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                        /* Find HPT ready to run                    */
 201b4bc:	20176280 	call	2017628 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 201b4c0:	e0bfff17 	ldw	r2,-4(fp)
 201b4c4:	00c00384 	movi	r3,14
 201b4c8:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 201b4cc:	e0bff803 	ldbu	r2,-32(fp)
 201b4d0:	00000706 	br	201b4f0 <OSQPendAbort+0x160>
 201b4d4:	e0bff917 	ldw	r2,-28(fp)
 201b4d8:	e0bffc15 	stw	r2,-16(fp)
 201b4dc:	e0bffc17 	ldw	r2,-16(fp)
 201b4e0:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201b4e4:	e0bfff17 	ldw	r2,-4(fp)
 201b4e8:	10000005 	stb	zero,0(r2)
    return (0);                                            /* No tasks waiting on queue                */
 201b4ec:	0005883a 	mov	r2,zero
}
 201b4f0:	e037883a 	mov	sp,fp
 201b4f4:	dfc00117 	ldw	ra,4(sp)
 201b4f8:	df000017 	ldw	fp,0(sp)
 201b4fc:	dec00204 	addi	sp,sp,8
 201b500:	f800283a 	ret

0201b504 <OSQPost>:
*********************************************************************************************************
*/

#if OS_Q_POST_EN > 0
INT8U  OSQPost (OS_EVENT *pevent, void *pmsg)
{
 201b504:	defff604 	addi	sp,sp,-40
 201b508:	dfc00915 	stw	ra,36(sp)
 201b50c:	df000815 	stw	fp,32(sp)
 201b510:	df000804 	addi	fp,sp,32
 201b514:	e13ffe15 	stw	r4,-8(fp)
 201b518:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 201b51c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 201b520:	e0bffe17 	ldw	r2,-8(fp)
 201b524:	1000021e 	bne	r2,zero,201b530 <OSQPost+0x2c>
        return (OS_ERR_PEVENT_NULL);
 201b528:	00800104 	movi	r2,4
 201b52c:	00004a06 	br	201b658 <OSQPost+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 201b530:	e0bffe17 	ldw	r2,-8(fp)
 201b534:	10800003 	ldbu	r2,0(r2)
 201b538:	10803fcc 	andi	r2,r2,255
 201b53c:	108000a0 	cmpeqi	r2,r2,2
 201b540:	1000021e 	bne	r2,zero,201b54c <OSQPost+0x48>
        return (OS_ERR_EVENT_TYPE);
 201b544:	00800044 	movi	r2,1
 201b548:	00004306 	br	201b658 <OSQPost+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b54c:	0005303a 	rdctl	r2,status
 201b550:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b554:	e0fffa17 	ldw	r3,-24(fp)
 201b558:	00bfff84 	movi	r2,-2
 201b55c:	1884703a 	and	r2,r3,r2
 201b560:	1001703a 	wrctl	status,r2
  
  return context;
 201b564:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 201b568:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                     /* See if any task pending on queue             */
 201b56c:	e0bffe17 	ldw	r2,-8(fp)
 201b570:	10800283 	ldbu	r2,10(r2)
 201b574:	10803fcc 	andi	r2,r2,255
 201b578:	10000c26 	beq	r2,zero,201b5ac <OSQPost+0xa8>
                                                       /* Ready highest priority task waiting on event */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 201b57c:	e13ffe17 	ldw	r4,-8(fp)
 201b580:	e17fff17 	ldw	r5,-4(fp)
 201b584:	01800104 	movi	r6,4
 201b588:	000f883a 	mov	r7,zero
 201b58c:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201b590:	e0bff817 	ldw	r2,-32(fp)
 201b594:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b598:	e0bffb17 	ldw	r2,-20(fp)
 201b59c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                    /* Find highest priority task ready to run      */
 201b5a0:	20176280 	call	2017628 <OS_Sched>
        return (OS_ERR_NONE);
 201b5a4:	0005883a 	mov	r2,zero
 201b5a8:	00002b06 	br	201b658 <OSQPost+0x154>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                   /* Point to queue control block                 */
 201b5ac:	e0bffe17 	ldw	r2,-8(fp)
 201b5b0:	10800117 	ldw	r2,4(r2)
 201b5b4:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries >= pq->OSQSize) {               /* Make sure queue is not full                  */
 201b5b8:	e0bff917 	ldw	r2,-28(fp)
 201b5bc:	10c0058b 	ldhu	r3,22(r2)
 201b5c0:	e0bff917 	ldw	r2,-28(fp)
 201b5c4:	1080050b 	ldhu	r2,20(r2)
 201b5c8:	18ffffcc 	andi	r3,r3,65535
 201b5cc:	10bfffcc 	andi	r2,r2,65535
 201b5d0:	18800636 	bltu	r3,r2,201b5ec <OSQPost+0xe8>
 201b5d4:	e0bff817 	ldw	r2,-32(fp)
 201b5d8:	e0bffc15 	stw	r2,-16(fp)
 201b5dc:	e0bffc17 	ldw	r2,-16(fp)
 201b5e0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 201b5e4:	00800784 	movi	r2,30
 201b5e8:	00001b06 	br	201b658 <OSQPost+0x154>
    }
    *pq->OSQIn++ = pmsg;                               /* Insert message into queue                    */
 201b5ec:	e0bff917 	ldw	r2,-28(fp)
 201b5f0:	10800317 	ldw	r2,12(r2)
 201b5f4:	e0ffff17 	ldw	r3,-4(fp)
 201b5f8:	10c00015 	stw	r3,0(r2)
 201b5fc:	10c00104 	addi	r3,r2,4
 201b600:	e0bff917 	ldw	r2,-28(fp)
 201b604:	10c00315 	stw	r3,12(r2)
    pq->OSQEntries++;                                  /* Update the nbr of entries in the queue       */
 201b608:	e0bff917 	ldw	r2,-28(fp)
 201b60c:	1080058b 	ldhu	r2,22(r2)
 201b610:	10800044 	addi	r2,r2,1
 201b614:	1007883a 	mov	r3,r2
 201b618:	e0bff917 	ldw	r2,-28(fp)
 201b61c:	10c0058d 	sth	r3,22(r2)
    if (pq->OSQIn == pq->OSQEnd) {                     /* Wrap IN ptr if we are at end of queue        */
 201b620:	e0bff917 	ldw	r2,-28(fp)
 201b624:	10c00317 	ldw	r3,12(r2)
 201b628:	e0bff917 	ldw	r2,-28(fp)
 201b62c:	10800217 	ldw	r2,8(r2)
 201b630:	1880041e 	bne	r3,r2,201b644 <OSQPost+0x140>
        pq->OSQIn = pq->OSQStart;
 201b634:	e0bff917 	ldw	r2,-28(fp)
 201b638:	10c00117 	ldw	r3,4(r2)
 201b63c:	e0bff917 	ldw	r2,-28(fp)
 201b640:	10c00315 	stw	r3,12(r2)
 201b644:	e0bff817 	ldw	r2,-32(fp)
 201b648:	e0bffd15 	stw	r2,-12(fp)
 201b64c:	e0bffd17 	ldw	r2,-12(fp)
 201b650:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201b654:	0005883a 	mov	r2,zero
}
 201b658:	e037883a 	mov	sp,fp
 201b65c:	dfc00117 	ldw	ra,4(sp)
 201b660:	df000017 	ldw	fp,0(sp)
 201b664:	dec00204 	addi	sp,sp,8
 201b668:	f800283a 	ret

0201b66c <OSQPostFront>:
*********************************************************************************************************
*/

#if OS_Q_POST_FRONT_EN > 0
INT8U  OSQPostFront (OS_EVENT *pevent, void *pmsg)
{
 201b66c:	defff604 	addi	sp,sp,-40
 201b670:	dfc00915 	stw	ra,36(sp)
 201b674:	df000815 	stw	fp,32(sp)
 201b678:	df000804 	addi	fp,sp,32
 201b67c:	e13ffe15 	stw	r4,-8(fp)
 201b680:	e17fff15 	stw	r5,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201b684:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201b688:	e0bffe17 	ldw	r2,-8(fp)
 201b68c:	1000021e 	bne	r2,zero,201b698 <OSQPostFront+0x2c>
        return (OS_ERR_PEVENT_NULL);
 201b690:	00800104 	movi	r2,4
 201b694:	00004c06 	br	201b7c8 <OSQPostFront+0x15c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 201b698:	e0bffe17 	ldw	r2,-8(fp)
 201b69c:	10800003 	ldbu	r2,0(r2)
 201b6a0:	10803fcc 	andi	r2,r2,255
 201b6a4:	108000a0 	cmpeqi	r2,r2,2
 201b6a8:	1000021e 	bne	r2,zero,201b6b4 <OSQPostFront+0x48>
        return (OS_ERR_EVENT_TYPE);
 201b6ac:	00800044 	movi	r2,1
 201b6b0:	00004506 	br	201b7c8 <OSQPostFront+0x15c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b6b4:	0005303a 	rdctl	r2,status
 201b6b8:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b6bc:	e0fffa17 	ldw	r3,-24(fp)
 201b6c0:	00bfff84 	movi	r2,-2
 201b6c4:	1884703a 	and	r2,r3,r2
 201b6c8:	1001703a 	wrctl	status,r2
  
  return context;
 201b6cc:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 201b6d0:	e0bff815 	stw	r2,-32(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task pending on queue              */
 201b6d4:	e0bffe17 	ldw	r2,-8(fp)
 201b6d8:	10800283 	ldbu	r2,10(r2)
 201b6dc:	10803fcc 	andi	r2,r2,255
 201b6e0:	10000c26 	beq	r2,zero,201b714 <OSQPostFront+0xa8>
                                                      /* Ready highest priority task waiting on event  */
        (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 201b6e4:	e13ffe17 	ldw	r4,-8(fp)
 201b6e8:	e17fff17 	ldw	r5,-4(fp)
 201b6ec:	01800104 	movi	r6,4
 201b6f0:	000f883a 	mov	r7,zero
 201b6f4:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201b6f8:	e0bff817 	ldw	r2,-32(fp)
 201b6fc:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b700:	e0bffb17 	ldw	r2,-20(fp)
 201b704:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find highest priority task ready to run       */
 201b708:	20176280 	call	2017628 <OS_Sched>
        return (OS_ERR_NONE);
 201b70c:	0005883a 	mov	r2,zero
 201b710:	00002d06 	br	201b7c8 <OSQPostFront+0x15c>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 201b714:	e0bffe17 	ldw	r2,-8(fp)
 201b718:	10800117 	ldw	r2,4(r2)
 201b71c:	e0bff915 	stw	r2,-28(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 201b720:	e0bff917 	ldw	r2,-28(fp)
 201b724:	10c0058b 	ldhu	r3,22(r2)
 201b728:	e0bff917 	ldw	r2,-28(fp)
 201b72c:	1080050b 	ldhu	r2,20(r2)
 201b730:	18ffffcc 	andi	r3,r3,65535
 201b734:	10bfffcc 	andi	r2,r2,65535
 201b738:	18800636 	bltu	r3,r2,201b754 <OSQPostFront+0xe8>
 201b73c:	e0bff817 	ldw	r2,-32(fp)
 201b740:	e0bffc15 	stw	r2,-16(fp)
 201b744:	e0bffc17 	ldw	r2,-16(fp)
 201b748:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 201b74c:	00800784 	movi	r2,30
 201b750:	00001d06 	br	201b7c8 <OSQPostFront+0x15c>
    }
    if (pq->OSQOut == pq->OSQStart) {                 /* Wrap OUT ptr if we are at the 1st queue entry */
 201b754:	e0bff917 	ldw	r2,-28(fp)
 201b758:	10c00417 	ldw	r3,16(r2)
 201b75c:	e0bff917 	ldw	r2,-28(fp)
 201b760:	10800117 	ldw	r2,4(r2)
 201b764:	1880041e 	bne	r3,r2,201b778 <OSQPostFront+0x10c>
        pq->OSQOut = pq->OSQEnd;
 201b768:	e0bff917 	ldw	r2,-28(fp)
 201b76c:	10c00217 	ldw	r3,8(r2)
 201b770:	e0bff917 	ldw	r2,-28(fp)
 201b774:	10c00415 	stw	r3,16(r2)
    }
    pq->OSQOut--;
 201b778:	e0bff917 	ldw	r2,-28(fp)
 201b77c:	10800417 	ldw	r2,16(r2)
 201b780:	10ffff04 	addi	r3,r2,-4
 201b784:	e0bff917 	ldw	r2,-28(fp)
 201b788:	10c00415 	stw	r3,16(r2)
    *pq->OSQOut = pmsg;                               /* Insert message into queue                     */
 201b78c:	e0bff917 	ldw	r2,-28(fp)
 201b790:	10800417 	ldw	r2,16(r2)
 201b794:	e0ffff17 	ldw	r3,-4(fp)
 201b798:	10c00015 	stw	r3,0(r2)
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 201b79c:	e0bff917 	ldw	r2,-28(fp)
 201b7a0:	1080058b 	ldhu	r2,22(r2)
 201b7a4:	10800044 	addi	r2,r2,1
 201b7a8:	1007883a 	mov	r3,r2
 201b7ac:	e0bff917 	ldw	r2,-28(fp)
 201b7b0:	10c0058d 	sth	r3,22(r2)
 201b7b4:	e0bff817 	ldw	r2,-32(fp)
 201b7b8:	e0bffd15 	stw	r2,-12(fp)
 201b7bc:	e0bffd17 	ldw	r2,-12(fp)
 201b7c0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201b7c4:	0005883a 	mov	r2,zero
}
 201b7c8:	e037883a 	mov	sp,fp
 201b7cc:	dfc00117 	ldw	ra,4(sp)
 201b7d0:	df000017 	ldw	fp,0(sp)
 201b7d4:	dec00204 	addi	sp,sp,8
 201b7d8:	f800283a 	ret

0201b7dc <OSQPostOpt>:
*********************************************************************************************************
*/

#if OS_Q_POST_OPT_EN > 0
INT8U  OSQPostOpt (OS_EVENT *pevent, void *pmsg, INT8U opt)
{
 201b7dc:	defff504 	addi	sp,sp,-44
 201b7e0:	dfc00a15 	stw	ra,40(sp)
 201b7e4:	df000915 	stw	fp,36(sp)
 201b7e8:	df000904 	addi	fp,sp,36
 201b7ec:	e13ffd15 	stw	r4,-12(fp)
 201b7f0:	e17ffe15 	stw	r5,-8(fp)
 201b7f4:	3005883a 	mov	r2,r6
 201b7f8:	e0bfff05 	stb	r2,-4(fp)
    OS_Q      *pq;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201b7fc:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201b800:	e0bffd17 	ldw	r2,-12(fp)
 201b804:	1000021e 	bne	r2,zero,201b810 <OSQPostOpt+0x34>
        return (OS_ERR_PEVENT_NULL);
 201b808:	00800104 	movi	r2,4
 201b80c:	00007106 	br	201b9d4 <OSQPostOpt+0x1f8>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {     /* Validate event block type                     */
 201b810:	e0bffd17 	ldw	r2,-12(fp)
 201b814:	10800003 	ldbu	r2,0(r2)
 201b818:	10803fcc 	andi	r2,r2,255
 201b81c:	108000a0 	cmpeqi	r2,r2,2
 201b820:	1000021e 	bne	r2,zero,201b82c <OSQPostOpt+0x50>
        return (OS_ERR_EVENT_TYPE);
 201b824:	00800044 	movi	r2,1
 201b828:	00006a06 	br	201b9d4 <OSQPostOpt+0x1f8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201b82c:	0005303a 	rdctl	r2,status
 201b830:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201b834:	e0fff917 	ldw	r3,-28(fp)
 201b838:	00bfff84 	movi	r2,-2
 201b83c:	1884703a 	and	r2,r3,r2
 201b840:	1001703a 	wrctl	status,r2
  
  return context;
 201b844:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 201b848:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
 201b84c:	e0bffd17 	ldw	r2,-12(fp)
 201b850:	10800283 	ldbu	r2,10(r2)
 201b854:	10803fcc 	andi	r2,r2,255
 201b858:	10001d26 	beq	r2,zero,201b8d0 <OSQPostOpt+0xf4>
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
 201b85c:	e0bfff03 	ldbu	r2,-4(fp)
 201b860:	1080004c 	andi	r2,r2,1
 201b864:	10000b26 	beq	r2,zero,201b894 <OSQPostOpt+0xb8>
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 201b868:	00000506 	br	201b880 <OSQPostOpt+0xa4>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 201b86c:	e13ffd17 	ldw	r4,-12(fp)
 201b870:	e17ffe17 	ldw	r5,-8(fp)
 201b874:	01800104 	movi	r6,4
 201b878:	000f883a 	mov	r7,zero
 201b87c:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
        return (OS_ERR_EVENT_TYPE);
    }
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0x00) {                 /* See if any task pending on queue              */
        if ((opt & OS_POST_OPT_BROADCAST) != 0x00) {  /* Do we need to post msg to ALL waiting tasks ? */
            while (pevent->OSEventGrp != 0) {         /* Yes, Post to ALL tasks waiting on queue       */
 201b880:	e0bffd17 	ldw	r2,-12(fp)
 201b884:	10800283 	ldbu	r2,10(r2)
 201b888:	10803fcc 	andi	r2,r2,255
 201b88c:	103ff71e 	bne	r2,zero,201b86c <OSQPostOpt+0x90>
 201b890:	00000506 	br	201b8a8 <OSQPostOpt+0xcc>
                (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
            }
        } else {                                      /* No,  Post to HPT waiting on queue             */
            (void)OS_EventTaskRdy(pevent, pmsg, OS_STAT_Q, OS_STAT_PEND_OK);
 201b894:	e13ffd17 	ldw	r4,-12(fp)
 201b898:	e17ffe17 	ldw	r5,-8(fp)
 201b89c:	01800104 	movi	r6,4
 201b8a0:	000f883a 	mov	r7,zero
 201b8a4:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201b8a8:	e0bff717 	ldw	r2,-36(fp)
 201b8ac:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201b8b0:	e0bffa17 	ldw	r2,-24(fp)
 201b8b4:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        if ((opt & OS_POST_OPT_NO_SCHED) == 0) {	  /* See if scheduler needs to be invoked          */
 201b8b8:	e0bfff03 	ldbu	r2,-4(fp)
 201b8bc:	1080010c 	andi	r2,r2,4
 201b8c0:	1000011e 	bne	r2,zero,201b8c8 <OSQPostOpt+0xec>
            OS_Sched();                               /* Find highest priority task ready to run       */
 201b8c4:	20176280 	call	2017628 <OS_Sched>
        }
        return (OS_ERR_NONE);
 201b8c8:	0005883a 	mov	r2,zero
 201b8cc:	00004106 	br	201b9d4 <OSQPostOpt+0x1f8>
    }
    pq = (OS_Q *)pevent->OSEventPtr;                  /* Point to queue control block                  */
 201b8d0:	e0bffd17 	ldw	r2,-12(fp)
 201b8d4:	10800117 	ldw	r2,4(r2)
 201b8d8:	e0bff815 	stw	r2,-32(fp)
    if (pq->OSQEntries >= pq->OSQSize) {              /* Make sure queue is not full                   */
 201b8dc:	e0bff817 	ldw	r2,-32(fp)
 201b8e0:	10c0058b 	ldhu	r3,22(r2)
 201b8e4:	e0bff817 	ldw	r2,-32(fp)
 201b8e8:	1080050b 	ldhu	r2,20(r2)
 201b8ec:	18ffffcc 	andi	r3,r3,65535
 201b8f0:	10bfffcc 	andi	r2,r2,65535
 201b8f4:	18800636 	bltu	r3,r2,201b910 <OSQPostOpt+0x134>
 201b8f8:	e0bff717 	ldw	r2,-36(fp)
 201b8fc:	e0bffb15 	stw	r2,-20(fp)
 201b900:	e0bffb17 	ldw	r2,-20(fp)
 201b904:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_Q_FULL);
 201b908:	00800784 	movi	r2,30
 201b90c:	00003106 	br	201b9d4 <OSQPostOpt+0x1f8>
    }
    if ((opt & OS_POST_OPT_FRONT) != 0x00) {          /* Do we post to the FRONT of the queue?         */
 201b910:	e0bfff03 	ldbu	r2,-4(fp)
 201b914:	1080008c 	andi	r2,r2,2
 201b918:	10001326 	beq	r2,zero,201b968 <OSQPostOpt+0x18c>
        if (pq->OSQOut == pq->OSQStart) {             /* Yes, Post as LIFO, Wrap OUT pointer if we ... */
 201b91c:	e0bff817 	ldw	r2,-32(fp)
 201b920:	10c00417 	ldw	r3,16(r2)
 201b924:	e0bff817 	ldw	r2,-32(fp)
 201b928:	10800117 	ldw	r2,4(r2)
 201b92c:	1880041e 	bne	r3,r2,201b940 <OSQPostOpt+0x164>
            pq->OSQOut = pq->OSQEnd;                  /*      ... are at the 1st queue entry           */
 201b930:	e0bff817 	ldw	r2,-32(fp)
 201b934:	10c00217 	ldw	r3,8(r2)
 201b938:	e0bff817 	ldw	r2,-32(fp)
 201b93c:	10c00415 	stw	r3,16(r2)
        }
        pq->OSQOut--;
 201b940:	e0bff817 	ldw	r2,-32(fp)
 201b944:	10800417 	ldw	r2,16(r2)
 201b948:	10ffff04 	addi	r3,r2,-4
 201b94c:	e0bff817 	ldw	r2,-32(fp)
 201b950:	10c00415 	stw	r3,16(r2)
        *pq->OSQOut = pmsg;                           /*      Insert message into queue                */
 201b954:	e0bff817 	ldw	r2,-32(fp)
 201b958:	10800417 	ldw	r2,16(r2)
 201b95c:	e0fffe17 	ldw	r3,-8(fp)
 201b960:	10c00015 	stw	r3,0(r2)
 201b964:	00001006 	br	201b9a8 <OSQPostOpt+0x1cc>
    } else {                                          /* No,  Post as FIFO                             */
        *pq->OSQIn++ = pmsg;                          /*      Insert message into queue                */
 201b968:	e0bff817 	ldw	r2,-32(fp)
 201b96c:	10800317 	ldw	r2,12(r2)
 201b970:	e0fffe17 	ldw	r3,-8(fp)
 201b974:	10c00015 	stw	r3,0(r2)
 201b978:	10c00104 	addi	r3,r2,4
 201b97c:	e0bff817 	ldw	r2,-32(fp)
 201b980:	10c00315 	stw	r3,12(r2)
        if (pq->OSQIn == pq->OSQEnd) {                /*      Wrap IN ptr if we are at end of queue    */
 201b984:	e0bff817 	ldw	r2,-32(fp)
 201b988:	10c00317 	ldw	r3,12(r2)
 201b98c:	e0bff817 	ldw	r2,-32(fp)
 201b990:	10800217 	ldw	r2,8(r2)
 201b994:	1880041e 	bne	r3,r2,201b9a8 <OSQPostOpt+0x1cc>
            pq->OSQIn = pq->OSQStart;
 201b998:	e0bff817 	ldw	r2,-32(fp)
 201b99c:	10c00117 	ldw	r3,4(r2)
 201b9a0:	e0bff817 	ldw	r2,-32(fp)
 201b9a4:	10c00315 	stw	r3,12(r2)
        }
    }
    pq->OSQEntries++;                                 /* Update the nbr of entries in the queue        */
 201b9a8:	e0bff817 	ldw	r2,-32(fp)
 201b9ac:	1080058b 	ldhu	r2,22(r2)
 201b9b0:	10800044 	addi	r2,r2,1
 201b9b4:	1007883a 	mov	r3,r2
 201b9b8:	e0bff817 	ldw	r2,-32(fp)
 201b9bc:	10c0058d 	sth	r3,22(r2)
 201b9c0:	e0bff717 	ldw	r2,-36(fp)
 201b9c4:	e0bffc15 	stw	r2,-16(fp)
 201b9c8:	e0bffc17 	ldw	r2,-16(fp)
 201b9cc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201b9d0:	0005883a 	mov	r2,zero
}
 201b9d4:	e037883a 	mov	sp,fp
 201b9d8:	dfc00117 	ldw	ra,4(sp)
 201b9dc:	df000017 	ldw	fp,0(sp)
 201b9e0:	dec00204 	addi	sp,sp,8
 201b9e4:	f800283a 	ret

0201b9e8 <OSQQuery>:
*********************************************************************************************************
*/

#if OS_Q_QUERY_EN > 0
INT8U  OSQQuery (OS_EVENT *pevent, OS_Q_DATA *p_q_data)
{
 201b9e8:	defff604 	addi	sp,sp,-40
 201b9ec:	df000915 	stw	fp,36(sp)
 201b9f0:	df000904 	addi	fp,sp,36
 201b9f4:	e13ffe15 	stw	r4,-8(fp)
 201b9f8:	e17fff15 	stw	r5,-4(fp)
#else
    INT16U    *psrc;
    INT16U    *pdest;
#endif
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 201b9fc:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                     /* Validate 'pevent'                            */
 201ba00:	e0bffe17 	ldw	r2,-8(fp)
 201ba04:	1000021e 	bne	r2,zero,201ba10 <OSQQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 201ba08:	00800104 	movi	r2,4
 201ba0c:	00004b06 	br	201bb3c <OSQQuery+0x154>
    }
    if (p_q_data == (OS_Q_DATA *)0) {                  /* Validate 'p_q_data'                          */
 201ba10:	e0bfff17 	ldw	r2,-4(fp)
 201ba14:	1000021e 	bne	r2,zero,201ba20 <OSQQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 201ba18:	00800244 	movi	r2,9
 201ba1c:	00004706 	br	201bb3c <OSQQuery+0x154>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_Q) {      /* Validate event block type                    */
 201ba20:	e0bffe17 	ldw	r2,-8(fp)
 201ba24:	10800003 	ldbu	r2,0(r2)
 201ba28:	10803fcc 	andi	r2,r2,255
 201ba2c:	108000a0 	cmpeqi	r2,r2,2
 201ba30:	1000021e 	bne	r2,zero,201ba3c <OSQQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 201ba34:	00800044 	movi	r2,1
 201ba38:	00004006 	br	201bb3c <OSQQuery+0x154>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ba3c:	0005303a 	rdctl	r2,status
 201ba40:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201ba44:	e0fffc17 	ldw	r3,-16(fp)
 201ba48:	00bfff84 	movi	r2,-2
 201ba4c:	1884703a 	and	r2,r3,r2
 201ba50:	1001703a 	wrctl	status,r2
  
  return context;
 201ba54:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201ba58:	e0bffa15 	stw	r2,-24(fp)
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
 201ba5c:	e0bffe17 	ldw	r2,-8(fp)
 201ba60:	10c00283 	ldbu	r3,10(r2)
 201ba64:	e0bfff17 	ldw	r2,-4(fp)
 201ba68:	10c002c5 	stb	r3,11(r2)
    psrc                 = &pevent->OSEventTbl[0];
 201ba6c:	e0bffe17 	ldw	r2,-8(fp)
 201ba70:	108002c4 	addi	r2,r2,11
 201ba74:	e0bff815 	stw	r2,-32(fp)
    pdest                = &p_q_data->OSEventTbl[0];
 201ba78:	e0bfff17 	ldw	r2,-4(fp)
 201ba7c:	10800204 	addi	r2,r2,8
 201ba80:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201ba84:	e03ff705 	stb	zero,-36(fp)
 201ba88:	00000d06 	br	201bac0 <OSQQuery+0xd8>
        *pdest++ = *psrc++;
 201ba8c:	e0bff817 	ldw	r2,-32(fp)
 201ba90:	10c00003 	ldbu	r3,0(r2)
 201ba94:	e0bff917 	ldw	r2,-28(fp)
 201ba98:	10c00005 	stb	r3,0(r2)
 201ba9c:	e0bff917 	ldw	r2,-28(fp)
 201baa0:	10800044 	addi	r2,r2,1
 201baa4:	e0bff915 	stw	r2,-28(fp)
 201baa8:	e0bff817 	ldw	r2,-32(fp)
 201baac:	10800044 	addi	r2,r2,1
 201bab0:	e0bff815 	stw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
    p_q_data->OSEventGrp = pevent->OSEventGrp;         /* Copy message queue wait list                 */
    psrc                 = &pevent->OSEventTbl[0];
    pdest                = &p_q_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201bab4:	e0bff703 	ldbu	r2,-36(fp)
 201bab8:	10800044 	addi	r2,r2,1
 201babc:	e0bff705 	stb	r2,-36(fp)
 201bac0:	e0bff703 	ldbu	r2,-36(fp)
 201bac4:	108000f0 	cmpltui	r2,r2,3
 201bac8:	103ff01e 	bne	r2,zero,201ba8c <OSQQuery+0xa4>
        *pdest++ = *psrc++;
    }
    pq = (OS_Q *)pevent->OSEventPtr;
 201bacc:	e0bffe17 	ldw	r2,-8(fp)
 201bad0:	10800117 	ldw	r2,4(r2)
 201bad4:	e0bffb15 	stw	r2,-20(fp)
    if (pq->OSQEntries > 0) {
 201bad8:	e0bffb17 	ldw	r2,-20(fp)
 201badc:	1080058b 	ldhu	r2,22(r2)
 201bae0:	10bfffcc 	andi	r2,r2,65535
 201bae4:	10000626 	beq	r2,zero,201bb00 <OSQQuery+0x118>
        p_q_data->OSMsg = *pq->OSQOut;                 /* Get next message to return if available      */
 201bae8:	e0bffb17 	ldw	r2,-20(fp)
 201baec:	10800417 	ldw	r2,16(r2)
 201baf0:	10c00017 	ldw	r3,0(r2)
 201baf4:	e0bfff17 	ldw	r2,-4(fp)
 201baf8:	10c00015 	stw	r3,0(r2)
 201bafc:	00000206 	br	201bb08 <OSQQuery+0x120>
    } else {
        p_q_data->OSMsg = (void *)0;
 201bb00:	e0bfff17 	ldw	r2,-4(fp)
 201bb04:	10000015 	stw	zero,0(r2)
    }
    p_q_data->OSNMsgs = pq->OSQEntries;
 201bb08:	e0bffb17 	ldw	r2,-20(fp)
 201bb0c:	10c0058b 	ldhu	r3,22(r2)
 201bb10:	e0bfff17 	ldw	r2,-4(fp)
 201bb14:	10c0010d 	sth	r3,4(r2)
    p_q_data->OSQSize = pq->OSQSize;
 201bb18:	e0bffb17 	ldw	r2,-20(fp)
 201bb1c:	10c0050b 	ldhu	r3,20(r2)
 201bb20:	e0bfff17 	ldw	r2,-4(fp)
 201bb24:	10c0018d 	sth	r3,6(r2)
 201bb28:	e0bffa17 	ldw	r2,-24(fp)
 201bb2c:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bb30:	e0bffd17 	ldw	r2,-12(fp)
 201bb34:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201bb38:	0005883a 	mov	r2,zero
}
 201bb3c:	e037883a 	mov	sp,fp
 201bb40:	df000017 	ldw	fp,0(sp)
 201bb44:	dec00104 	addi	sp,sp,4
 201bb48:	f800283a 	ret

0201bb4c <OS_QInit>:
* Note(s)    : This function is INTERNAL to uC/OS-II and your application should not call it.
*********************************************************************************************************
*/

void  OS_QInit (void)
{
 201bb4c:	defffb04 	addi	sp,sp,-20
 201bb50:	dfc00415 	stw	ra,16(sp)
 201bb54:	df000315 	stw	fp,12(sp)
 201bb58:	df000304 	addi	fp,sp,12
    OS_Q   *pq1;
    OS_Q   *pq2;



    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
 201bb5c:	01009934 	movhi	r4,612
 201bb60:	212dcb04 	addi	r4,r4,-18644
 201bb64:	01407804 	movi	r5,480
 201bb68:	20175680 	call	2017568 <OS_MemClr>
    pq1 = &OSQTbl[0];
 201bb6c:	00809934 	movhi	r2,612
 201bb70:	10adcb04 	addi	r2,r2,-18644
 201bb74:	e0bffe15 	stw	r2,-8(fp)
    pq2 = &OSQTbl[1];
 201bb78:	00809934 	movhi	r2,612
 201bb7c:	10add104 	addi	r2,r2,-18620
 201bb80:	e0bfff15 	stw	r2,-4(fp)
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 201bb84:	e03ffd0d 	sth	zero,-12(fp)
 201bb88:	00000c06 	br	201bbbc <OS_QInit+0x70>
        pq1->OSQPtr = pq2;
 201bb8c:	e0bffe17 	ldw	r2,-8(fp)
 201bb90:	e0ffff17 	ldw	r3,-4(fp)
 201bb94:	10c00015 	stw	r3,0(r2)
        pq1++;
 201bb98:	e0bffe17 	ldw	r2,-8(fp)
 201bb9c:	10800604 	addi	r2,r2,24
 201bba0:	e0bffe15 	stw	r2,-8(fp)
        pq2++;
 201bba4:	e0bfff17 	ldw	r2,-4(fp)
 201bba8:	10800604 	addi	r2,r2,24
 201bbac:	e0bfff15 	stw	r2,-4(fp)


    OS_MemClr((INT8U *)&OSQTbl[0], sizeof(OSQTbl));  /* Clear the queue table                          */
    pq1 = &OSQTbl[0];
    pq2 = &OSQTbl[1];
    for (i = 0; i < (OS_MAX_QS - 1); i++) {          /* Init. list of free QUEUE control blocks        */
 201bbb0:	e0bffd0b 	ldhu	r2,-12(fp)
 201bbb4:	10800044 	addi	r2,r2,1
 201bbb8:	e0bffd0d 	sth	r2,-12(fp)
 201bbbc:	e0bffd0b 	ldhu	r2,-12(fp)
 201bbc0:	108004f0 	cmpltui	r2,r2,19
 201bbc4:	103ff11e 	bne	r2,zero,201bb8c <OS_QInit+0x40>
        pq1->OSQPtr = pq2;
        pq1++;
        pq2++;
    }
    pq1->OSQPtr = (OS_Q *)0;
 201bbc8:	e0bffe17 	ldw	r2,-8(fp)
 201bbcc:	10000015 	stw	zero,0(r2)
    OSQFreeList = &OSQTbl[0];
 201bbd0:	00808174 	movhi	r2,517
 201bbd4:	1090a604 	addi	r2,r2,17048
 201bbd8:	00c09934 	movhi	r3,612
 201bbdc:	18edcb04 	addi	r3,r3,-18644
 201bbe0:	10c00015 	stw	r3,0(r2)
#endif
}
 201bbe4:	e037883a 	mov	sp,fp
 201bbe8:	dfc00117 	ldw	ra,4(sp)
 201bbec:	df000017 	ldw	fp,0(sp)
 201bbf0:	dec00204 	addi	sp,sp,8
 201bbf4:	f800283a 	ret

0201bbf8 <OSSemAccept>:
*********************************************************************************************************
*/

#if OS_SEM_ACCEPT_EN > 0
INT16U  OSSemAccept (OS_EVENT *pevent)
{
 201bbf8:	defffa04 	addi	sp,sp,-24
 201bbfc:	df000515 	stw	fp,20(sp)
 201bc00:	df000504 	addi	fp,sp,20
 201bc04:	e13fff15 	stw	r4,-4(fp)
    INT16U     cnt;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201bc08:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201bc0c:	e0bfff17 	ldw	r2,-4(fp)
 201bc10:	1000021e 	bne	r2,zero,201bc1c <OSSemAccept+0x24>
        return (0);
 201bc14:	0005883a 	mov	r2,zero
 201bc18:	00001f06 	br	201bc98 <OSSemAccept+0xa0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201bc1c:	e0bfff17 	ldw	r2,-4(fp)
 201bc20:	10800003 	ldbu	r2,0(r2)
 201bc24:	10803fcc 	andi	r2,r2,255
 201bc28:	108000e0 	cmpeqi	r2,r2,3
 201bc2c:	1000021e 	bne	r2,zero,201bc38 <OSSemAccept+0x40>
        return (0);
 201bc30:	0005883a 	mov	r2,zero
 201bc34:	00001806 	br	201bc98 <OSSemAccept+0xa0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201bc38:	0005303a 	rdctl	r2,status
 201bc3c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bc40:	e0fffd17 	ldw	r3,-12(fp)
 201bc44:	00bfff84 	movi	r2,-2
 201bc48:	1884703a 	and	r2,r3,r2
 201bc4c:	1001703a 	wrctl	status,r2
  
  return context;
 201bc50:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 201bc54:	e0bffb15 	stw	r2,-20(fp)
    cnt = pevent->OSEventCnt;
 201bc58:	e0bfff17 	ldw	r2,-4(fp)
 201bc5c:	1080020b 	ldhu	r2,8(r2)
 201bc60:	e0bffc0d 	sth	r2,-16(fp)
    if (cnt > 0) {                                    /* See if resource is available                  */
 201bc64:	e0bffc0b 	ldhu	r2,-16(fp)
 201bc68:	10000626 	beq	r2,zero,201bc84 <OSSemAccept+0x8c>
        pevent->OSEventCnt--;                         /* Yes, decrement semaphore and notify caller    */
 201bc6c:	e0bfff17 	ldw	r2,-4(fp)
 201bc70:	1080020b 	ldhu	r2,8(r2)
 201bc74:	10bfffc4 	addi	r2,r2,-1
 201bc78:	1007883a 	mov	r3,r2
 201bc7c:	e0bfff17 	ldw	r2,-4(fp)
 201bc80:	10c0020d 	sth	r3,8(r2)
 201bc84:	e0bffb17 	ldw	r2,-20(fp)
 201bc88:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bc8c:	e0bffe17 	ldw	r2,-8(fp)
 201bc90:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (cnt);                                     /* Return semaphore count                        */
 201bc94:	e0bffc0b 	ldhu	r2,-16(fp)
}
 201bc98:	e037883a 	mov	sp,fp
 201bc9c:	df000017 	ldw	fp,0(sp)
 201bca0:	dec00104 	addi	sp,sp,4
 201bca4:	f800283a 	ret

0201bca8 <OSSemCreate>:
*              == (void *)0  if no event control blocks were available
*********************************************************************************************************
*/

OS_EVENT  *OSSemCreate (INT16U cnt)
{
 201bca8:	defff904 	addi	sp,sp,-28
 201bcac:	dfc00615 	stw	ra,24(sp)
 201bcb0:	df000515 	stw	fp,20(sp)
 201bcb4:	df000504 	addi	fp,sp,20
 201bcb8:	2005883a 	mov	r2,r4
 201bcbc:	e0bfff0d 	sth	r2,-4(fp)
    OS_EVENT  *pevent;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201bcc0:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 201bcc4:	00808174 	movhi	r2,517
 201bcc8:	1090a904 	addi	r2,r2,17060
 201bccc:	10800003 	ldbu	r2,0(r2)
 201bcd0:	10803fcc 	andi	r2,r2,255
 201bcd4:	10000226 	beq	r2,zero,201bce0 <OSSemCreate+0x38>
        return ((OS_EVENT *)0);                            /* ... can't CREATE from an ISR             */
 201bcd8:	0005883a 	mov	r2,zero
 201bcdc:	00002d06 	br	201bd94 <OSSemCreate+0xec>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201bce0:	0005303a 	rdctl	r2,status
 201bce4:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201bce8:	e0fffd17 	ldw	r3,-12(fp)
 201bcec:	00bfff84 	movi	r2,-2
 201bcf0:	1884703a 	and	r2,r3,r2
 201bcf4:	1001703a 	wrctl	status,r2
  
  return context;
 201bcf8:	e0bffd17 	ldw	r2,-12(fp)
    }
    OS_ENTER_CRITICAL();
 201bcfc:	e0bffb15 	stw	r2,-20(fp)
    pevent = OSEventFreeList;                              /* Get next free event control block        */
 201bd00:	00808174 	movhi	r2,517
 201bd04:	1090a804 	addi	r2,r2,17056
 201bd08:	10800017 	ldw	r2,0(r2)
 201bd0c:	e0bffc15 	stw	r2,-16(fp)
    if (OSEventFreeList != (OS_EVENT *)0) {                /* See if pool of free ECB pool was empty   */
 201bd10:	00808174 	movhi	r2,517
 201bd14:	1090a804 	addi	r2,r2,17056
 201bd18:	10800017 	ldw	r2,0(r2)
 201bd1c:	10000726 	beq	r2,zero,201bd3c <OSSemCreate+0x94>
        OSEventFreeList = (OS_EVENT *)OSEventFreeList->OSEventPtr;
 201bd20:	00808174 	movhi	r2,517
 201bd24:	1090a804 	addi	r2,r2,17056
 201bd28:	10800017 	ldw	r2,0(r2)
 201bd2c:	10c00117 	ldw	r3,4(r2)
 201bd30:	00808174 	movhi	r2,517
 201bd34:	1090a804 	addi	r2,r2,17056
 201bd38:	10c00015 	stw	r3,0(r2)
 201bd3c:	e0bffb17 	ldw	r2,-20(fp)
 201bd40:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bd44:	e0bffe17 	ldw	r2,-8(fp)
 201bd48:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    if (pevent != (OS_EVENT *)0) {                         /* Get an event control block               */
 201bd4c:	e0bffc17 	ldw	r2,-16(fp)
 201bd50:	10000f26 	beq	r2,zero,201bd90 <OSSemCreate+0xe8>
        pevent->OSEventType    = OS_EVENT_TYPE_SEM;
 201bd54:	e0bffc17 	ldw	r2,-16(fp)
 201bd58:	00c000c4 	movi	r3,3
 201bd5c:	10c00005 	stb	r3,0(r2)
        pevent->OSEventCnt     = cnt;                      /* Set semaphore value                      */
 201bd60:	e0bffc17 	ldw	r2,-16(fp)
 201bd64:	e0ffff0b 	ldhu	r3,-4(fp)
 201bd68:	10c0020d 	sth	r3,8(r2)
        pevent->OSEventPtr     = (void *)0;                /* Unlink from ECB free list                */
 201bd6c:	e0bffc17 	ldw	r2,-16(fp)
 201bd70:	10000115 	stw	zero,4(r2)
#if OS_EVENT_NAME_SIZE > 1
        pevent->OSEventName[0] = '?';                      /* Unknown name                             */
 201bd74:	e0bffc17 	ldw	r2,-16(fp)
 201bd78:	00c00fc4 	movi	r3,63
 201bd7c:	10c00385 	stb	r3,14(r2)
        pevent->OSEventName[1] = OS_ASCII_NUL;
 201bd80:	e0bffc17 	ldw	r2,-16(fp)
 201bd84:	100003c5 	stb	zero,15(r2)
#endif
        OS_EventWaitListInit(pevent);                      /* Initialize to 'nobody waiting' on sem.   */
 201bd88:	e13ffc17 	ldw	r4,-16(fp)
 201bd8c:	201719c0 	call	201719c <OS_EventWaitListInit>
    }
    return (pevent);
 201bd90:	e0bffc17 	ldw	r2,-16(fp)
}
 201bd94:	e037883a 	mov	sp,fp
 201bd98:	dfc00117 	ldw	ra,4(sp)
 201bd9c:	df000017 	ldw	fp,0(sp)
 201bda0:	dec00204 	addi	sp,sp,8
 201bda4:	f800283a 	ret

0201bda8 <OSSemDel>:
*********************************************************************************************************
*/

#if OS_SEM_DEL_EN > 0
OS_EVENT  *OSSemDel (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 201bda8:	defff304 	addi	sp,sp,-52
 201bdac:	dfc00c15 	stw	ra,48(sp)
 201bdb0:	df000b15 	stw	fp,44(sp)
 201bdb4:	df000b04 	addi	fp,sp,44
 201bdb8:	e13ffd15 	stw	r4,-12(fp)
 201bdbc:	2805883a 	mov	r2,r5
 201bdc0:	e1bfff15 	stw	r6,-4(fp)
 201bdc4:	e0bffe05 	stb	r2,-8(fp)
    BOOLEAN    tasks_waiting;
    OS_EVENT  *pevent_return;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201bdc8:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                              /* Validate 'perr'                          */
 201bdcc:	e0bfff17 	ldw	r2,-4(fp)
 201bdd0:	1000021e 	bne	r2,zero,201bddc <OSSemDel+0x34>
        return (pevent);
 201bdd4:	e0bffd17 	ldw	r2,-12(fp)
 201bdd8:	00008a06 	br	201c004 <OSSemDel+0x25c>
    }
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201bddc:	e0bffd17 	ldw	r2,-12(fp)
 201bde0:	1000051e 	bne	r2,zero,201bdf8 <OSSemDel+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201bde4:	e0bfff17 	ldw	r2,-4(fp)
 201bde8:	00c00104 	movi	r3,4
 201bdec:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201bdf0:	e0bffd17 	ldw	r2,-12(fp)
 201bdf4:	00008306 	br	201c004 <OSSemDel+0x25c>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 201bdf8:	e0bffd17 	ldw	r2,-12(fp)
 201bdfc:	10800003 	ldbu	r2,0(r2)
 201be00:	10803fcc 	andi	r2,r2,255
 201be04:	108000e0 	cmpeqi	r2,r2,3
 201be08:	1000051e 	bne	r2,zero,201be20 <OSSemDel+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201be0c:	e0bfff17 	ldw	r2,-4(fp)
 201be10:	00c00044 	movi	r3,1
 201be14:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201be18:	e0bffd17 	ldw	r2,-12(fp)
 201be1c:	00007906 	br	201c004 <OSSemDel+0x25c>
    }
    if (OSIntNesting > 0) {                                /* See if called from ISR ...               */
 201be20:	00808174 	movhi	r2,517
 201be24:	1090a904 	addi	r2,r2,17060
 201be28:	10800003 	ldbu	r2,0(r2)
 201be2c:	10803fcc 	andi	r2,r2,255
 201be30:	10000526 	beq	r2,zero,201be48 <OSSemDel+0xa0>
        *perr = OS_ERR_DEL_ISR;                             /* ... can't DELETE from an ISR             */
 201be34:	e0bfff17 	ldw	r2,-4(fp)
 201be38:	00c003c4 	movi	r3,15
 201be3c:	10c00005 	stb	r3,0(r2)
        return (pevent);
 201be40:	e0bffd17 	ldw	r2,-12(fp)
 201be44:	00006f06 	br	201c004 <OSSemDel+0x25c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201be48:	0005303a 	rdctl	r2,status
 201be4c:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201be50:	e0fff817 	ldw	r3,-32(fp)
 201be54:	00bfff84 	movi	r2,-2
 201be58:	1884703a 	and	r2,r3,r2
 201be5c:	1001703a 	wrctl	status,r2
  
  return context;
 201be60:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 201be64:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventGrp != 0) {                         /* See if any tasks waiting on semaphore    */
 201be68:	e0bffd17 	ldw	r2,-12(fp)
 201be6c:	10800283 	ldbu	r2,10(r2)
 201be70:	10803fcc 	andi	r2,r2,255
 201be74:	10000326 	beq	r2,zero,201be84 <OSSemDel+0xdc>
        tasks_waiting = OS_TRUE;                           /* Yes                                      */
 201be78:	00800044 	movi	r2,1
 201be7c:	e0bff505 	stb	r2,-44(fp)
 201be80:	00000106 	br	201be88 <OSSemDel+0xe0>
    } else {
        tasks_waiting = OS_FALSE;                          /* No                                       */
 201be84:	e03ff505 	stb	zero,-44(fp)
    }
    switch (opt) {
 201be88:	e0bffe03 	ldbu	r2,-8(fp)
 201be8c:	10000326 	beq	r2,zero,201be9c <OSSemDel+0xf4>
 201be90:	10800060 	cmpeqi	r2,r2,1
 201be94:	10002d1e 	bne	r2,zero,201bf4c <OSSemDel+0x1a4>
 201be98:	00004f06 	br	201bfd8 <OSSemDel+0x230>
        case OS_DEL_NO_PEND:                               /* Delete semaphore only if no task waiting */
             if (tasks_waiting == OS_FALSE) {
 201be9c:	e0bff503 	ldbu	r2,-44(fp)
 201bea0:	10001a1e 	bne	r2,zero,201bf0c <OSSemDel+0x164>
#if OS_EVENT_NAME_SIZE > 1
                 pevent->OSEventName[0] = '?';             /* Unknown name                             */
 201bea4:	e0bffd17 	ldw	r2,-12(fp)
 201bea8:	00c00fc4 	movi	r3,63
 201beac:	10c00385 	stb	r3,14(r2)
                 pevent->OSEventName[1] = OS_ASCII_NUL;
 201beb0:	e0bffd17 	ldw	r2,-12(fp)
 201beb4:	100003c5 	stb	zero,15(r2)
#endif
                 pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 201beb8:	e0bffd17 	ldw	r2,-12(fp)
 201bebc:	10000005 	stb	zero,0(r2)
                 pevent->OSEventPtr     = OSEventFreeList; /* Return Event Control Block to free list  */
 201bec0:	00808174 	movhi	r2,517
 201bec4:	1090a804 	addi	r2,r2,17056
 201bec8:	10c00017 	ldw	r3,0(r2)
 201becc:	e0bffd17 	ldw	r2,-12(fp)
 201bed0:	10c00115 	stw	r3,4(r2)
                 pevent->OSEventCnt     = 0;
 201bed4:	e0bffd17 	ldw	r2,-12(fp)
 201bed8:	1000020d 	sth	zero,8(r2)
                 OSEventFreeList        = pevent;          /* Get next free event control block        */
 201bedc:	00808174 	movhi	r2,517
 201bee0:	1090a804 	addi	r2,r2,17056
 201bee4:	e0fffd17 	ldw	r3,-12(fp)
 201bee8:	10c00015 	stw	r3,0(r2)
 201beec:	e0bff717 	ldw	r2,-36(fp)
 201bef0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201bef4:	e0bff917 	ldw	r2,-28(fp)
 201bef8:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
 201befc:	e0bfff17 	ldw	r2,-4(fp)
 201bf00:	10000005 	stb	zero,0(r2)
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
 201bf04:	e03ff615 	stw	zero,-40(fp)
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
                 pevent_return          = pevent;
             }
             break;
 201bf08:	00003d06 	br	201c000 <OSSemDel+0x258>
 201bf0c:	e0bff717 	ldw	r2,-36(fp)
 201bf10:	e0bffa15 	stw	r2,-24(fp)
 201bf14:	e0bffa17 	ldw	r2,-24(fp)
 201bf18:	1001703a 	wrctl	status,r2
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_NONE;
                 pevent_return          = (OS_EVENT *)0;   /* Semaphore has been deleted               */
             } else {
                 OS_EXIT_CRITICAL();
                 *perr                  = OS_ERR_TASK_WAITING;
 201bf1c:	e0bfff17 	ldw	r2,-4(fp)
 201bf20:	00c01244 	movi	r3,73
 201bf24:	10c00005 	stb	r3,0(r2)
                 pevent_return          = pevent;
 201bf28:	e0bffd17 	ldw	r2,-12(fp)
 201bf2c:	e0bff615 	stw	r2,-40(fp)
             }
             break;
 201bf30:	00003306 	br	201c000 <OSSemDel+0x258>

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 201bf34:	e13ffd17 	ldw	r4,-12(fp)
 201bf38:	000b883a 	mov	r5,zero
 201bf3c:	01800044 	movi	r6,1
 201bf40:	000f883a 	mov	r7,zero
 201bf44:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201bf48:	00000106 	br	201bf50 <OSSemDel+0x1a8>
                 pevent_return          = pevent;
             }
             break;

        case OS_DEL_ALWAYS:                                /* Always delete the semaphore              */
             while (pevent->OSEventGrp != 0) {             /* Ready ALL tasks waiting for semaphore    */
 201bf4c:	0001883a 	nop
 201bf50:	e0bffd17 	ldw	r2,-12(fp)
 201bf54:	10800283 	ldbu	r2,10(r2)
 201bf58:	10803fcc 	andi	r2,r2,255
 201bf5c:	103ff51e 	bne	r2,zero,201bf34 <OSSemDel+0x18c>
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
             }
#if OS_EVENT_NAME_SIZE > 1
             pevent->OSEventName[0] = '?';                 /* Unknown name                             */
 201bf60:	e0bffd17 	ldw	r2,-12(fp)
 201bf64:	00c00fc4 	movi	r3,63
 201bf68:	10c00385 	stb	r3,14(r2)
             pevent->OSEventName[1] = OS_ASCII_NUL;
 201bf6c:	e0bffd17 	ldw	r2,-12(fp)
 201bf70:	100003c5 	stb	zero,15(r2)
#endif
             pevent->OSEventType    = OS_EVENT_TYPE_UNUSED;
 201bf74:	e0bffd17 	ldw	r2,-12(fp)
 201bf78:	10000005 	stb	zero,0(r2)
             pevent->OSEventPtr     = OSEventFreeList;     /* Return Event Control Block to free list  */
 201bf7c:	00808174 	movhi	r2,517
 201bf80:	1090a804 	addi	r2,r2,17056
 201bf84:	10c00017 	ldw	r3,0(r2)
 201bf88:	e0bffd17 	ldw	r2,-12(fp)
 201bf8c:	10c00115 	stw	r3,4(r2)
             pevent->OSEventCnt     = 0;
 201bf90:	e0bffd17 	ldw	r2,-12(fp)
 201bf94:	1000020d 	sth	zero,8(r2)
             OSEventFreeList        = pevent;              /* Get next free event control block        */
 201bf98:	00808174 	movhi	r2,517
 201bf9c:	1090a804 	addi	r2,r2,17056
 201bfa0:	e0fffd17 	ldw	r3,-12(fp)
 201bfa4:	10c00015 	stw	r3,0(r2)
 201bfa8:	e0bff717 	ldw	r2,-36(fp)
 201bfac:	e0bffb15 	stw	r2,-20(fp)
 201bfb0:	e0bffb17 	ldw	r2,-20(fp)
 201bfb4:	1001703a 	wrctl	status,r2
             OS_EXIT_CRITICAL();
             if (tasks_waiting == OS_TRUE) {               /* Reschedule only if task(s) were waiting  */
 201bfb8:	e0bff503 	ldbu	r2,-44(fp)
 201bfbc:	10800058 	cmpnei	r2,r2,1
 201bfc0:	1000011e 	bne	r2,zero,201bfc8 <OSSemDel+0x220>
                 OS_Sched();                               /* Find highest priority task ready to run  */
 201bfc4:	20176280 	call	2017628 <OS_Sched>
             }
             *perr                  = OS_ERR_NONE;
 201bfc8:	e0bfff17 	ldw	r2,-4(fp)
 201bfcc:	10000005 	stb	zero,0(r2)
             pevent_return          = (OS_EVENT *)0;       /* Semaphore has been deleted               */
 201bfd0:	e03ff615 	stw	zero,-40(fp)
             break;
 201bfd4:	00000a06 	br	201c000 <OSSemDel+0x258>
 201bfd8:	e0bff717 	ldw	r2,-36(fp)
 201bfdc:	e0bffc15 	stw	r2,-16(fp)
 201bfe0:	e0bffc17 	ldw	r2,-16(fp)
 201bfe4:	1001703a 	wrctl	status,r2

        default:
             OS_EXIT_CRITICAL();
             *perr                  = OS_ERR_INVALID_OPT;
 201bfe8:	e0bfff17 	ldw	r2,-4(fp)
 201bfec:	00c001c4 	movi	r3,7
 201bff0:	10c00005 	stb	r3,0(r2)
             pevent_return          = pevent;
 201bff4:	e0bffd17 	ldw	r2,-12(fp)
 201bff8:	e0bff615 	stw	r2,-40(fp)
             break;
 201bffc:	0001883a 	nop
    }
    return (pevent_return);
 201c000:	e0bff617 	ldw	r2,-40(fp)
}
 201c004:	e037883a 	mov	sp,fp
 201c008:	dfc00117 	ldw	ra,4(sp)
 201c00c:	df000017 	ldw	fp,0(sp)
 201c010:	dec00204 	addi	sp,sp,8
 201c014:	f800283a 	ret

0201c018 <OSSemPend>:
* Returns    : none
*********************************************************************************************************
*/
/*$PAGE*/
void  OSSemPend (OS_EVENT *pevent, INT16U timeout, INT8U *perr)
{
 201c018:	defff504 	addi	sp,sp,-44
 201c01c:	dfc00a15 	stw	ra,40(sp)
 201c020:	df000915 	stw	fp,36(sp)
 201c024:	df000904 	addi	fp,sp,36
 201c028:	e13ffd15 	stw	r4,-12(fp)
 201c02c:	2805883a 	mov	r2,r5
 201c030:	e1bfff15 	stw	r6,-4(fp)
 201c034:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201c038:	e03ff715 	stw	zero,-36(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201c03c:	e0bfff17 	ldw	r2,-4(fp)
 201c040:	10008a26 	beq	r2,zero,201c26c <OSSemPend+0x254>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201c044:	e0bffd17 	ldw	r2,-12(fp)
 201c048:	1000041e 	bne	r2,zero,201c05c <OSSemPend+0x44>
        *perr = OS_ERR_PEVENT_NULL;
 201c04c:	e0bfff17 	ldw	r2,-4(fp)
 201c050:	00c00104 	movi	r3,4
 201c054:	10c00005 	stb	r3,0(r2)
        return;
 201c058:	00008506 	br	201c270 <OSSemPend+0x258>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201c05c:	e0bffd17 	ldw	r2,-12(fp)
 201c060:	10800003 	ldbu	r2,0(r2)
 201c064:	10803fcc 	andi	r2,r2,255
 201c068:	108000e0 	cmpeqi	r2,r2,3
 201c06c:	1000041e 	bne	r2,zero,201c080 <OSSemPend+0x68>
        *perr = OS_ERR_EVENT_TYPE;
 201c070:	e0bfff17 	ldw	r2,-4(fp)
 201c074:	00c00044 	movi	r3,1
 201c078:	10c00005 	stb	r3,0(r2)
        return;
 201c07c:	00007c06 	br	201c270 <OSSemPend+0x258>
    }
    if (OSIntNesting > 0) {                           /* See if called from ISR ...                    */
 201c080:	00808174 	movhi	r2,517
 201c084:	1090a904 	addi	r2,r2,17060
 201c088:	10800003 	ldbu	r2,0(r2)
 201c08c:	10803fcc 	andi	r2,r2,255
 201c090:	10000426 	beq	r2,zero,201c0a4 <OSSemPend+0x8c>
        *perr = OS_ERR_PEND_ISR;                      /* ... can't PEND from an ISR                    */
 201c094:	e0bfff17 	ldw	r2,-4(fp)
 201c098:	00c00084 	movi	r3,2
 201c09c:	10c00005 	stb	r3,0(r2)
        return;
 201c0a0:	00007306 	br	201c270 <OSSemPend+0x258>
    }
    if (OSLockNesting > 0) {                          /* See if called with scheduler locked ...       */
 201c0a4:	00808174 	movhi	r2,517
 201c0a8:	10909b04 	addi	r2,r2,17004
 201c0ac:	10800003 	ldbu	r2,0(r2)
 201c0b0:	10803fcc 	andi	r2,r2,255
 201c0b4:	10000426 	beq	r2,zero,201c0c8 <OSSemPend+0xb0>
        *perr = OS_ERR_PEND_LOCKED;                   /* ... can't PEND when locked                    */
 201c0b8:	e0bfff17 	ldw	r2,-4(fp)
 201c0bc:	00c00344 	movi	r3,13
 201c0c0:	10c00005 	stb	r3,0(r2)
        return;
 201c0c4:	00006a06 	br	201c270 <OSSemPend+0x258>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c0c8:	0005303a 	rdctl	r2,status
 201c0cc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c0d0:	e0fff817 	ldw	r3,-32(fp)
 201c0d4:	00bfff84 	movi	r2,-2
 201c0d8:	1884703a 	and	r2,r3,r2
 201c0dc:	1001703a 	wrctl	status,r2
  
  return context;
 201c0e0:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 201c0e4:	e0bff715 	stw	r2,-36(fp)
    if (pevent->OSEventCnt > 0) {                     /* If sem. is positive, resource available ...   */
 201c0e8:	e0bffd17 	ldw	r2,-12(fp)
 201c0ec:	1080020b 	ldhu	r2,8(r2)
 201c0f0:	10bfffcc 	andi	r2,r2,65535
 201c0f4:	10000d26 	beq	r2,zero,201c12c <OSSemPend+0x114>
        pevent->OSEventCnt--;                         /* ... decrement semaphore only if positive.     */
 201c0f8:	e0bffd17 	ldw	r2,-12(fp)
 201c0fc:	1080020b 	ldhu	r2,8(r2)
 201c100:	10bfffc4 	addi	r2,r2,-1
 201c104:	1007883a 	mov	r3,r2
 201c108:	e0bffd17 	ldw	r2,-12(fp)
 201c10c:	10c0020d 	sth	r3,8(r2)
 201c110:	e0bff717 	ldw	r2,-36(fp)
 201c114:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c118:	e0bff917 	ldw	r2,-28(fp)
 201c11c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_NONE;
 201c120:	e0bfff17 	ldw	r2,-4(fp)
 201c124:	10000005 	stb	zero,0(r2)
        return;
 201c128:	00005106 	br	201c270 <OSSemPend+0x258>
    }
                                                      /* Otherwise, must wait until event occurs       */
    OSTCBCur->OSTCBStat     |= OS_STAT_SEM;           /* Resource not available, pend on semaphore     */
 201c12c:	00808174 	movhi	r2,517
 201c130:	1090aa04 	addi	r2,r2,17064
 201c134:	10800017 	ldw	r2,0(r2)
 201c138:	00c08174 	movhi	r3,517
 201c13c:	18d0aa04 	addi	r3,r3,17064
 201c140:	18c00017 	ldw	r3,0(r3)
 201c144:	18c00c03 	ldbu	r3,48(r3)
 201c148:	18c00054 	ori	r3,r3,1
 201c14c:	10c00c05 	stb	r3,48(r2)
    OSTCBCur->OSTCBStatPend  = OS_STAT_PEND_OK;
 201c150:	00808174 	movhi	r2,517
 201c154:	1090aa04 	addi	r2,r2,17064
 201c158:	10800017 	ldw	r2,0(r2)
 201c15c:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBDly       = timeout;               /* Store pend timeout in TCB                     */
 201c160:	00808174 	movhi	r2,517
 201c164:	1090aa04 	addi	r2,r2,17064
 201c168:	10800017 	ldw	r2,0(r2)
 201c16c:	e0fffe0b 	ldhu	r3,-8(fp)
 201c170:	10c00b8d 	sth	r3,46(r2)
    OS_EventTaskWait(pevent);                         /* Suspend task until event or timeout occurs    */
 201c174:	e13ffd17 	ldw	r4,-12(fp)
 201c178:	2016da40 	call	2016da4 <OS_EventTaskWait>
 201c17c:	e0bff717 	ldw	r2,-36(fp)
 201c180:	e0bffa15 	stw	r2,-24(fp)
 201c184:	e0bffa17 	ldw	r2,-24(fp)
 201c188:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    OS_Sched();                                       /* Find next highest priority task ready         */
 201c18c:	20176280 	call	2017628 <OS_Sched>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c190:	0005303a 	rdctl	r2,status
 201c194:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c198:	e0fffb17 	ldw	r3,-20(fp)
 201c19c:	00bfff84 	movi	r2,-2
 201c1a0:	1884703a 	and	r2,r3,r2
 201c1a4:	1001703a 	wrctl	status,r2
  
  return context;
 201c1a8:	e0bffb17 	ldw	r2,-20(fp)
    OS_ENTER_CRITICAL();
 201c1ac:	e0bff715 	stw	r2,-36(fp)
    switch (OSTCBCur->OSTCBStatPend) {                /* See if we timed-out or aborted                */
 201c1b0:	00808174 	movhi	r2,517
 201c1b4:	1090aa04 	addi	r2,r2,17064
 201c1b8:	10800017 	ldw	r2,0(r2)
 201c1bc:	10800c43 	ldbu	r2,49(r2)
 201c1c0:	10803fcc 	andi	r2,r2,255
 201c1c4:	10000326 	beq	r2,zero,201c1d4 <OSSemPend+0x1bc>
 201c1c8:	108000a0 	cmpeqi	r2,r2,2
 201c1cc:	1000041e 	bne	r2,zero,201c1e0 <OSSemPend+0x1c8>
 201c1d0:	00000706 	br	201c1f0 <OSSemPend+0x1d8>
        case OS_STAT_PEND_OK:
             *perr = OS_ERR_NONE;
 201c1d4:	e0bfff17 	ldw	r2,-4(fp)
 201c1d8:	10000005 	stb	zero,0(r2)
             break;
 201c1dc:	00000e06 	br	201c218 <OSSemPend+0x200>

        case OS_STAT_PEND_ABORT:
             *perr = OS_ERR_PEND_ABORT;               /* Indicate that we aborted                      */
 201c1e0:	e0bfff17 	ldw	r2,-4(fp)
 201c1e4:	00c00384 	movi	r3,14
 201c1e8:	10c00005 	stb	r3,0(r2)
             break;
 201c1ec:	00000a06 	br	201c218 <OSSemPend+0x200>

        case OS_STAT_PEND_TO:
        default:        
             OS_EventTaskRemove(OSTCBCur, pevent);
 201c1f0:	00808174 	movhi	r2,517
 201c1f4:	1090aa04 	addi	r2,r2,17064
 201c1f8:	10800017 	ldw	r2,0(r2)
 201c1fc:	1009883a 	mov	r4,r2
 201c200:	e17ffd17 	ldw	r5,-12(fp)
 201c204:	2016ff40 	call	2016ff4 <OS_EventTaskRemove>
             *perr = OS_ERR_TIMEOUT;                  /* Indicate that we didn't get event within TO   */
 201c208:	e0bfff17 	ldw	r2,-4(fp)
 201c20c:	00c00284 	movi	r3,10
 201c210:	10c00005 	stb	r3,0(r2)
             break;
 201c214:	0001883a 	nop
    }
    OSTCBCur->OSTCBStat          =  OS_STAT_RDY;      /* Set   task  status to ready                   */
 201c218:	00808174 	movhi	r2,517
 201c21c:	1090aa04 	addi	r2,r2,17064
 201c220:	10800017 	ldw	r2,0(r2)
 201c224:	10000c05 	stb	zero,48(r2)
    OSTCBCur->OSTCBStatPend      =  OS_STAT_PEND_OK;  /* Clear pend  status                            */
 201c228:	00808174 	movhi	r2,517
 201c22c:	1090aa04 	addi	r2,r2,17064
 201c230:	10800017 	ldw	r2,0(r2)
 201c234:	10000c45 	stb	zero,49(r2)
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
 201c238:	00808174 	movhi	r2,517
 201c23c:	1090aa04 	addi	r2,r2,17064
 201c240:	10800017 	ldw	r2,0(r2)
 201c244:	10000715 	stw	zero,28(r2)
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
 201c248:	00808174 	movhi	r2,517
 201c24c:	1090aa04 	addi	r2,r2,17064
 201c250:	10800017 	ldw	r2,0(r2)
 201c254:	10000815 	stw	zero,32(r2)
 201c258:	e0bff717 	ldw	r2,-36(fp)
 201c25c:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c260:	e0bffc17 	ldw	r2,-16(fp)
 201c264:	1001703a 	wrctl	status,r2
 201c268:	00000106 	br	201c270 <OSSemPend+0x258>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 201c26c:	0001883a 	nop
    OSTCBCur->OSTCBEventPtr      = (OS_EVENT  *)0;    /* Clear event pointers                          */
#if (OS_EVENT_MULTI_EN > 0)
    OSTCBCur->OSTCBEventMultiPtr = (OS_EVENT **)0;
#endif
    OS_EXIT_CRITICAL();
}
 201c270:	e037883a 	mov	sp,fp
 201c274:	dfc00117 	ldw	ra,4(sp)
 201c278:	df000017 	ldw	fp,0(sp)
 201c27c:	dec00204 	addi	sp,sp,8
 201c280:	f800283a 	ret

0201c284 <OSSemPendAbort>:
*********************************************************************************************************
*/

#if OS_SEM_PEND_ABORT_EN > 0
INT8U  OSSemPendAbort (OS_EVENT *pevent, INT8U opt, INT8U *perr)
{
 201c284:	defff604 	addi	sp,sp,-40
 201c288:	dfc00915 	stw	ra,36(sp)
 201c28c:	df000815 	stw	fp,32(sp)
 201c290:	df000804 	addi	fp,sp,32
 201c294:	e13ffd15 	stw	r4,-12(fp)
 201c298:	2805883a 	mov	r2,r5
 201c29c:	e1bfff15 	stw	r6,-4(fp)
 201c2a0:	e0bffe05 	stb	r2,-8(fp)
    INT8U      nbr_tasks;
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201c2a4:	e03ff915 	stw	zero,-28(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201c2a8:	e0bfff17 	ldw	r2,-4(fp)
 201c2ac:	1000021e 	bne	r2,zero,201c2b8 <OSSemPendAbort+0x34>
        return (0);
 201c2b0:	0005883a 	mov	r2,zero
 201c2b4:	00004b06 	br	201c3e4 <OSSemPendAbort+0x160>
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201c2b8:	e0bffd17 	ldw	r2,-12(fp)
 201c2bc:	1000051e 	bne	r2,zero,201c2d4 <OSSemPendAbort+0x50>
        *perr = OS_ERR_PEVENT_NULL;
 201c2c0:	e0bfff17 	ldw	r2,-4(fp)
 201c2c4:	00c00104 	movi	r3,4
 201c2c8:	10c00005 	stb	r3,0(r2)
        return (0);
 201c2cc:	0005883a 	mov	r2,zero
 201c2d0:	00004406 	br	201c3e4 <OSSemPendAbort+0x160>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201c2d4:	e0bffd17 	ldw	r2,-12(fp)
 201c2d8:	10800003 	ldbu	r2,0(r2)
 201c2dc:	10803fcc 	andi	r2,r2,255
 201c2e0:	108000e0 	cmpeqi	r2,r2,3
 201c2e4:	1000051e 	bne	r2,zero,201c2fc <OSSemPendAbort+0x78>
        *perr = OS_ERR_EVENT_TYPE;
 201c2e8:	e0bfff17 	ldw	r2,-4(fp)
 201c2ec:	00c00044 	movi	r3,1
 201c2f0:	10c00005 	stb	r3,0(r2)
        return (0);
 201c2f4:	0005883a 	mov	r2,zero
 201c2f8:	00003a06 	br	201c3e4 <OSSemPendAbort+0x160>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c2fc:	0005303a 	rdctl	r2,status
 201c300:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c304:	e0fffa17 	ldw	r3,-24(fp)
 201c308:	00bfff84 	movi	r2,-2
 201c30c:	1884703a 	and	r2,r3,r2
 201c310:	1001703a 	wrctl	status,r2
  
  return context;
 201c314:	e0bffa17 	ldw	r2,-24(fp)
    }
    OS_ENTER_CRITICAL();
 201c318:	e0bff915 	stw	r2,-28(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
 201c31c:	e0bffd17 	ldw	r2,-12(fp)
 201c320:	10800283 	ldbu	r2,10(r2)
 201c324:	10803fcc 	andi	r2,r2,255
 201c328:	10002726 	beq	r2,zero,201c3c8 <OSSemPendAbort+0x144>
        nbr_tasks = 0;
 201c32c:	e03ff805 	stb	zero,-32(fp)
        switch (opt) {
 201c330:	e0bffe03 	ldbu	r2,-8(fp)
 201c334:	10800060 	cmpeqi	r2,r2,1
 201c338:	10000a1e 	bne	r2,zero,201c364 <OSSemPendAbort+0xe0>
 201c33c:	00000f06 	br	201c37c <OSSemPendAbort+0xf8>
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 201c340:	e13ffd17 	ldw	r4,-12(fp)
 201c344:	000b883a 	mov	r5,zero
 201c348:	01800044 	movi	r6,1
 201c34c:	01c00084 	movi	r7,2
 201c350:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
                     nbr_tasks++;
 201c354:	e0bff803 	ldbu	r2,-32(fp)
 201c358:	10800044 	addi	r2,r2,1
 201c35c:	e0bff805 	stb	r2,-32(fp)
 201c360:	00000106 	br	201c368 <OSSemPendAbort+0xe4>
    OS_ENTER_CRITICAL();
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting on semaphore?         */
        nbr_tasks = 0;
        switch (opt) {
            case OS_PEND_OPT_BROADCAST:               /* Do we need to abort ALL waiting tasks?        */
                 while (pevent->OSEventGrp != 0) {    /* Yes, ready ALL tasks waiting on semaphore     */
 201c364:	0001883a 	nop
 201c368:	e0bffd17 	ldw	r2,-12(fp)
 201c36c:	10800283 	ldbu	r2,10(r2)
 201c370:	10803fcc 	andi	r2,r2,255
 201c374:	103ff21e 	bne	r2,zero,201c340 <OSSemPendAbort+0xbc>
                     (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
                     nbr_tasks++;
                 }
                 break;
 201c378:	00000906 	br	201c3a0 <OSSemPendAbort+0x11c>
                 
            case OS_PEND_OPT_NONE:
            default:                                  /* No,  ready HPT       waiting on semaphore     */
                 (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_ABORT);
 201c37c:	e13ffd17 	ldw	r4,-12(fp)
 201c380:	000b883a 	mov	r5,zero
 201c384:	01800044 	movi	r6,1
 201c388:	01c00084 	movi	r7,2
 201c38c:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
                 nbr_tasks++;
 201c390:	e0bff803 	ldbu	r2,-32(fp)
 201c394:	10800044 	addi	r2,r2,1
 201c398:	e0bff805 	stb	r2,-32(fp)
                 break;
 201c39c:	0001883a 	nop
 201c3a0:	e0bff917 	ldw	r2,-28(fp)
 201c3a4:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c3a8:	e0bffb17 	ldw	r2,-20(fp)
 201c3ac:	1001703a 	wrctl	status,r2
        }
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 201c3b0:	20176280 	call	2017628 <OS_Sched>
        *perr = OS_ERR_PEND_ABORT;
 201c3b4:	e0bfff17 	ldw	r2,-4(fp)
 201c3b8:	00c00384 	movi	r3,14
 201c3bc:	10c00005 	stb	r3,0(r2)
        return (nbr_tasks);
 201c3c0:	e0bff803 	ldbu	r2,-32(fp)
 201c3c4:	00000706 	br	201c3e4 <OSSemPendAbort+0x160>
 201c3c8:	e0bff917 	ldw	r2,-28(fp)
 201c3cc:	e0bffc15 	stw	r2,-16(fp)
 201c3d0:	e0bffc17 	ldw	r2,-16(fp)
 201c3d4:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201c3d8:	e0bfff17 	ldw	r2,-4(fp)
 201c3dc:	10000005 	stb	zero,0(r2)
    return (0);                                       /* No tasks waiting on semaphore                 */
 201c3e0:	0005883a 	mov	r2,zero
}
 201c3e4:	e037883a 	mov	sp,fp
 201c3e8:	dfc00117 	ldw	ra,4(sp)
 201c3ec:	df000017 	ldw	fp,0(sp)
 201c3f0:	dec00204 	addi	sp,sp,8
 201c3f4:	f800283a 	ret

0201c3f8 <OSSemPost>:
*              OS_ERR_PEVENT_NULL  If 'pevent' is a NULL pointer.
*********************************************************************************************************
*/

INT8U  OSSemPost (OS_EVENT *pevent)
{
 201c3f8:	defff804 	addi	sp,sp,-32
 201c3fc:	dfc00715 	stw	ra,28(sp)
 201c400:	df000615 	stw	fp,24(sp)
 201c404:	df000604 	addi	fp,sp,24
 201c408:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201c40c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201c410:	e0bfff17 	ldw	r2,-4(fp)
 201c414:	1000021e 	bne	r2,zero,201c420 <OSSemPost+0x28>
        return (OS_ERR_PEVENT_NULL);
 201c418:	00800104 	movi	r2,4
 201c41c:	00003506 	br	201c4f4 <OSSemPost+0xfc>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201c420:	e0bfff17 	ldw	r2,-4(fp)
 201c424:	10800003 	ldbu	r2,0(r2)
 201c428:	10803fcc 	andi	r2,r2,255
 201c42c:	108000e0 	cmpeqi	r2,r2,3
 201c430:	1000021e 	bne	r2,zero,201c43c <OSSemPost+0x44>
        return (OS_ERR_EVENT_TYPE);
 201c434:	00800044 	movi	r2,1
 201c438:	00002e06 	br	201c4f4 <OSSemPost+0xfc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c43c:	0005303a 	rdctl	r2,status
 201c440:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c444:	e0fffb17 	ldw	r3,-20(fp)
 201c448:	00bfff84 	movi	r2,-2
 201c44c:	1884703a 	and	r2,r3,r2
 201c450:	1001703a 	wrctl	status,r2
  
  return context;
 201c454:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 201c458:	e0bffa15 	stw	r2,-24(fp)
    if (pevent->OSEventGrp != 0) {                    /* See if any task waiting for semaphore         */
 201c45c:	e0bfff17 	ldw	r2,-4(fp)
 201c460:	10800283 	ldbu	r2,10(r2)
 201c464:	10803fcc 	andi	r2,r2,255
 201c468:	10000c26 	beq	r2,zero,201c49c <OSSemPost+0xa4>
                                                      /* Ready HPT waiting on event                    */
        (void)OS_EventTaskRdy(pevent, (void *)0, OS_STAT_SEM, OS_STAT_PEND_OK);
 201c46c:	e13fff17 	ldw	r4,-4(fp)
 201c470:	000b883a 	mov	r5,zero
 201c474:	01800044 	movi	r6,1
 201c478:	000f883a 	mov	r7,zero
 201c47c:	2016c0c0 	call	2016c0c <OS_EventTaskRdy>
 201c480:	e0bffa17 	ldw	r2,-24(fp)
 201c484:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c488:	e0bffc17 	ldw	r2,-16(fp)
 201c48c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                   /* Find HPT ready to run                         */
 201c490:	20176280 	call	2017628 <OS_Sched>
        return (OS_ERR_NONE);
 201c494:	0005883a 	mov	r2,zero
 201c498:	00001606 	br	201c4f4 <OSSemPost+0xfc>
    }
    if (pevent->OSEventCnt < 65535u) {                /* Make sure semaphore will not overflow         */
 201c49c:	e0bfff17 	ldw	r2,-4(fp)
 201c4a0:	1080020b 	ldhu	r2,8(r2)
 201c4a4:	10ffffcc 	andi	r3,r2,65535
 201c4a8:	00bfffd4 	movui	r2,65535
 201c4ac:	18800c26 	beq	r3,r2,201c4e0 <OSSemPost+0xe8>
        pevent->OSEventCnt++;                         /* Increment semaphore count to register event   */
 201c4b0:	e0bfff17 	ldw	r2,-4(fp)
 201c4b4:	1080020b 	ldhu	r2,8(r2)
 201c4b8:	10800044 	addi	r2,r2,1
 201c4bc:	1007883a 	mov	r3,r2
 201c4c0:	e0bfff17 	ldw	r2,-4(fp)
 201c4c4:	10c0020d 	sth	r3,8(r2)
 201c4c8:	e0bffa17 	ldw	r2,-24(fp)
 201c4cc:	e0bffd15 	stw	r2,-12(fp)
 201c4d0:	e0bffd17 	ldw	r2,-12(fp)
 201c4d4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_NONE);
 201c4d8:	0005883a 	mov	r2,zero
 201c4dc:	00000506 	br	201c4f4 <OSSemPost+0xfc>
 201c4e0:	e0bffa17 	ldw	r2,-24(fp)
 201c4e4:	e0bffe15 	stw	r2,-8(fp)
 201c4e8:	e0bffe17 	ldw	r2,-8(fp)
 201c4ec:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                               /* Semaphore value has reached its maximum       */
    return (OS_ERR_SEM_OVF);
 201c4f0:	00800c84 	movi	r2,50
}
 201c4f4:	e037883a 	mov	sp,fp
 201c4f8:	dfc00117 	ldw	ra,4(sp)
 201c4fc:	df000017 	ldw	fp,0(sp)
 201c500:	dec00204 	addi	sp,sp,8
 201c504:	f800283a 	ret

0201c508 <OSSemQuery>:
*********************************************************************************************************
*/

#if OS_SEM_QUERY_EN > 0
INT8U  OSSemQuery (OS_EVENT *pevent, OS_SEM_DATA *p_sem_data)
{
 201c508:	defff704 	addi	sp,sp,-36
 201c50c:	df000815 	stw	fp,32(sp)
 201c510:	df000804 	addi	fp,sp,32
 201c514:	e13ffe15 	stw	r4,-8(fp)
 201c518:	e17fff15 	stw	r5,-4(fp)
    INT16U    *psrc;
    INT16U    *pdest;
#endif
    INT8U      i;
#if OS_CRITICAL_METHOD == 3                                /* Allocate storage for CPU status register */
    OS_CPU_SR  cpu_sr = 0;
 201c51c:	e03ffb15 	stw	zero,-20(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (pevent == (OS_EVENT *)0) {                         /* Validate 'pevent'                        */
 201c520:	e0bffe17 	ldw	r2,-8(fp)
 201c524:	1000021e 	bne	r2,zero,201c530 <OSSemQuery+0x28>
        return (OS_ERR_PEVENT_NULL);
 201c528:	00800104 	movi	r2,4
 201c52c:	00003806 	br	201c610 <OSSemQuery+0x108>
    }
    if (p_sem_data == (OS_SEM_DATA *)0) {                  /* Validate 'p_sem_data'                    */
 201c530:	e0bfff17 	ldw	r2,-4(fp)
 201c534:	1000021e 	bne	r2,zero,201c540 <OSSemQuery+0x38>
        return (OS_ERR_PDATA_NULL);
 201c538:	00800244 	movi	r2,9
 201c53c:	00003406 	br	201c610 <OSSemQuery+0x108>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {        /* Validate event block type                */
 201c540:	e0bffe17 	ldw	r2,-8(fp)
 201c544:	10800003 	ldbu	r2,0(r2)
 201c548:	10803fcc 	andi	r2,r2,255
 201c54c:	108000e0 	cmpeqi	r2,r2,3
 201c550:	1000021e 	bne	r2,zero,201c55c <OSSemQuery+0x54>
        return (OS_ERR_EVENT_TYPE);
 201c554:	00800044 	movi	r2,1
 201c558:	00002d06 	br	201c610 <OSSemQuery+0x108>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c55c:	0005303a 	rdctl	r2,status
 201c560:	e0bffc15 	stw	r2,-16(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c564:	e0fffc17 	ldw	r3,-16(fp)
 201c568:	00bfff84 	movi	r2,-2
 201c56c:	1884703a 	and	r2,r3,r2
 201c570:	1001703a 	wrctl	status,r2
  
  return context;
 201c574:	e0bffc17 	ldw	r2,-16(fp)
    }
    OS_ENTER_CRITICAL();
 201c578:	e0bffb15 	stw	r2,-20(fp)
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
 201c57c:	e0bffe17 	ldw	r2,-8(fp)
 201c580:	10c00283 	ldbu	r3,10(r2)
 201c584:	e0bfff17 	ldw	r2,-4(fp)
 201c588:	10c00145 	stb	r3,5(r2)
    psrc                   = &pevent->OSEventTbl[0];
 201c58c:	e0bffe17 	ldw	r2,-8(fp)
 201c590:	108002c4 	addi	r2,r2,11
 201c594:	e0bff815 	stw	r2,-32(fp)
    pdest                  = &p_sem_data->OSEventTbl[0];
 201c598:	e0bfff17 	ldw	r2,-4(fp)
 201c59c:	10800084 	addi	r2,r2,2
 201c5a0:	e0bff915 	stw	r2,-28(fp)
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201c5a4:	e03ffa05 	stb	zero,-24(fp)
 201c5a8:	00000d06 	br	201c5e0 <OSSemQuery+0xd8>
        *pdest++ = *psrc++;
 201c5ac:	e0bff817 	ldw	r2,-32(fp)
 201c5b0:	10c00003 	ldbu	r3,0(r2)
 201c5b4:	e0bff917 	ldw	r2,-28(fp)
 201c5b8:	10c00005 	stb	r3,0(r2)
 201c5bc:	e0bff917 	ldw	r2,-28(fp)
 201c5c0:	10800044 	addi	r2,r2,1
 201c5c4:	e0bff915 	stw	r2,-28(fp)
 201c5c8:	e0bff817 	ldw	r2,-32(fp)
 201c5cc:	10800044 	addi	r2,r2,1
 201c5d0:	e0bff815 	stw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
    p_sem_data->OSEventGrp = pevent->OSEventGrp;           /* Copy message mailbox wait list           */
    psrc                   = &pevent->OSEventTbl[0];
    pdest                  = &p_sem_data->OSEventTbl[0];
    for (i = 0; i < OS_EVENT_TBL_SIZE; i++) {
 201c5d4:	e0bffa03 	ldbu	r2,-24(fp)
 201c5d8:	10800044 	addi	r2,r2,1
 201c5dc:	e0bffa05 	stb	r2,-24(fp)
 201c5e0:	e0bffa03 	ldbu	r2,-24(fp)
 201c5e4:	108000f0 	cmpltui	r2,r2,3
 201c5e8:	103ff01e 	bne	r2,zero,201c5ac <OSSemQuery+0xa4>
        *pdest++ = *psrc++;
    }
    p_sem_data->OSCnt = pevent->OSEventCnt;                /* Get semaphore count                      */
 201c5ec:	e0bffe17 	ldw	r2,-8(fp)
 201c5f0:	10c0020b 	ldhu	r3,8(r2)
 201c5f4:	e0bfff17 	ldw	r2,-4(fp)
 201c5f8:	10c0000d 	sth	r3,0(r2)
 201c5fc:	e0bffb17 	ldw	r2,-20(fp)
 201c600:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c604:	e0bffd17 	ldw	r2,-12(fp)
 201c608:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201c60c:	0005883a 	mov	r2,zero
}
 201c610:	e037883a 	mov	sp,fp
 201c614:	df000017 	ldw	fp,0(sp)
 201c618:	dec00104 	addi	sp,sp,4
 201c61c:	f800283a 	ret

0201c620 <OSSemSet>:
*********************************************************************************************************
*/

#if OS_SEM_SET_EN > 0
void  OSSemSet (OS_EVENT *pevent, INT16U cnt, INT8U *perr)
{
 201c620:	defff904 	addi	sp,sp,-28
 201c624:	df000615 	stw	fp,24(sp)
 201c628:	df000604 	addi	fp,sp,24
 201c62c:	e13ffd15 	stw	r4,-12(fp)
 201c630:	2805883a 	mov	r2,r5
 201c634:	e1bfff15 	stw	r6,-4(fp)
 201c638:	e0bffe0d 	sth	r2,-8(fp)
#if OS_CRITICAL_METHOD == 3                           /* Allocate storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201c63c:	e03ffa15 	stw	zero,-24(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
 201c640:	e0bfff17 	ldw	r2,-4(fp)
 201c644:	10003126 	beq	r2,zero,201c70c <OSSemSet+0xec>
        return;
    }
    if (pevent == (OS_EVENT *)0) {                    /* Validate 'pevent'                             */
 201c648:	e0bffd17 	ldw	r2,-12(fp)
 201c64c:	1000041e 	bne	r2,zero,201c660 <OSSemSet+0x40>
        *perr = OS_ERR_PEVENT_NULL;
 201c650:	e0bfff17 	ldw	r2,-4(fp)
 201c654:	00c00104 	movi	r3,4
 201c658:	10c00005 	stb	r3,0(r2)
        return;
 201c65c:	00002c06 	br	201c710 <OSSemSet+0xf0>
    }
#endif
    if (pevent->OSEventType != OS_EVENT_TYPE_SEM) {   /* Validate event block type                     */
 201c660:	e0bffd17 	ldw	r2,-12(fp)
 201c664:	10800003 	ldbu	r2,0(r2)
 201c668:	10803fcc 	andi	r2,r2,255
 201c66c:	108000e0 	cmpeqi	r2,r2,3
 201c670:	1000041e 	bne	r2,zero,201c684 <OSSemSet+0x64>
        *perr = OS_ERR_EVENT_TYPE;
 201c674:	e0bfff17 	ldw	r2,-4(fp)
 201c678:	00c00044 	movi	r3,1
 201c67c:	10c00005 	stb	r3,0(r2)
        return;
 201c680:	00002306 	br	201c710 <OSSemSet+0xf0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c684:	0005303a 	rdctl	r2,status
 201c688:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c68c:	e0fffb17 	ldw	r3,-20(fp)
 201c690:	00bfff84 	movi	r2,-2
 201c694:	1884703a 	and	r2,r3,r2
 201c698:	1001703a 	wrctl	status,r2
  
  return context;
 201c69c:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 201c6a0:	e0bffa15 	stw	r2,-24(fp)
    *perr = OS_ERR_NONE;
 201c6a4:	e0bfff17 	ldw	r2,-4(fp)
 201c6a8:	10000005 	stb	zero,0(r2)
    if (pevent->OSEventCnt > 0) {                     /* See if semaphore already has a count          */
 201c6ac:	e0bffd17 	ldw	r2,-12(fp)
 201c6b0:	1080020b 	ldhu	r2,8(r2)
 201c6b4:	10bfffcc 	andi	r2,r2,65535
 201c6b8:	10000426 	beq	r2,zero,201c6cc <OSSemSet+0xac>
        pevent->OSEventCnt = cnt;                     /* Yes, set it to the new value specified.       */
 201c6bc:	e0bffd17 	ldw	r2,-12(fp)
 201c6c0:	e0fffe0b 	ldhu	r3,-8(fp)
 201c6c4:	10c0020d 	sth	r3,8(r2)
 201c6c8:	00000b06 	br	201c6f8 <OSSemSet+0xd8>
    } else {                                          /* No                                            */
        if (pevent->OSEventGrp == 0) {                /*      See if task(s) waiting?                  */
 201c6cc:	e0bffd17 	ldw	r2,-12(fp)
 201c6d0:	10800283 	ldbu	r2,10(r2)
 201c6d4:	10803fcc 	andi	r2,r2,255
 201c6d8:	1000041e 	bne	r2,zero,201c6ec <OSSemSet+0xcc>
            pevent->OSEventCnt = cnt;                 /*      No, OK to set the value                  */
 201c6dc:	e0bffd17 	ldw	r2,-12(fp)
 201c6e0:	e0fffe0b 	ldhu	r3,-8(fp)
 201c6e4:	10c0020d 	sth	r3,8(r2)
 201c6e8:	00000306 	br	201c6f8 <OSSemSet+0xd8>
        } else {
            *perr              = OS_ERR_TASK_WAITING;
 201c6ec:	e0bfff17 	ldw	r2,-4(fp)
 201c6f0:	00c01244 	movi	r3,73
 201c6f4:	10c00005 	stb	r3,0(r2)
 201c6f8:	e0bffa17 	ldw	r2,-24(fp)
 201c6fc:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c700:	e0bffc17 	ldw	r2,-16(fp)
 201c704:	1001703a 	wrctl	status,r2
 201c708:	00000106 	br	201c710 <OSSemSet+0xf0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                         /* Validate 'perr'                               */
        return;
 201c70c:	0001883a 	nop
        } else {
            *perr              = OS_ERR_TASK_WAITING;
        }
    }
    OS_EXIT_CRITICAL();
}
 201c710:	e037883a 	mov	sp,fp
 201c714:	df000017 	ldw	fp,0(sp)
 201c718:	dec00104 	addi	sp,sp,4
 201c71c:	f800283a 	ret

0201c720 <OSTaskChangePrio>:
*********************************************************************************************************
*/

#if OS_TASK_CHANGE_PRIO_EN > 0
INT8U  OSTaskChangePrio (INT8U oldprio, INT8U newprio)
{
 201c720:	defff104 	addi	sp,sp,-60
 201c724:	dfc00e15 	stw	ra,56(sp)
 201c728:	df000d15 	stw	fp,52(sp)
 201c72c:	df000d04 	addi	fp,sp,52
 201c730:	2007883a 	mov	r3,r4
 201c734:	2805883a 	mov	r2,r5
 201c738:	e0fffe05 	stb	r3,-8(fp)
 201c73c:	e0bfff05 	stb	r2,-4(fp)
    INT16U     bitx_new;
    INT16U     bity_old;
    INT16U     bitx_old;
#endif
#if OS_CRITICAL_METHOD == 3
    OS_CPU_SR  cpu_sr = 0;                                  /* Storage for CPU status register         */
 201c740:	e03ff515 	stw	zero,-44(fp)
#endif


/*$PAGE*/
#if OS_ARG_CHK_EN > 0
    if (oldprio >= OS_LOWEST_PRIO) {
 201c744:	e0bffe03 	ldbu	r2,-8(fp)
 201c748:	10800530 	cmpltui	r2,r2,20
 201c74c:	1000051e 	bne	r2,zero,201c764 <OSTaskChangePrio+0x44>
        if (oldprio != OS_PRIO_SELF) {
 201c750:	e0bffe03 	ldbu	r2,-8(fp)
 201c754:	10803fe0 	cmpeqi	r2,r2,255
 201c758:	1000021e 	bne	r2,zero,201c764 <OSTaskChangePrio+0x44>
            return (OS_ERR_PRIO_INVALID);
 201c75c:	00800a84 	movi	r2,42
 201c760:	00013406 	br	201cc34 <OSTaskChangePrio+0x514>
        }
    }
    if (newprio >= OS_LOWEST_PRIO) {
 201c764:	e0bfff03 	ldbu	r2,-4(fp)
 201c768:	10800530 	cmpltui	r2,r2,20
 201c76c:	1000021e 	bne	r2,zero,201c778 <OSTaskChangePrio+0x58>
        return (OS_ERR_PRIO_INVALID);
 201c770:	00800a84 	movi	r2,42
 201c774:	00012f06 	br	201cc34 <OSTaskChangePrio+0x514>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201c778:	0005303a 	rdctl	r2,status
 201c77c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201c780:	e0fff917 	ldw	r3,-28(fp)
 201c784:	00bfff84 	movi	r2,-2
 201c788:	1884703a 	and	r2,r3,r2
 201c78c:	1001703a 	wrctl	status,r2
  
  return context;
 201c790:	e0bff917 	ldw	r2,-28(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201c794:	e0bff515 	stw	r2,-44(fp)
    if (OSTCBPrioTbl[newprio] != (OS_TCB *)0) {             /* New priority must not already exist     */
 201c798:	e0bfff03 	ldbu	r2,-4(fp)
 201c79c:	00c09934 	movhi	r3,612
 201c7a0:	18f45704 	addi	r3,r3,-11940
 201c7a4:	1085883a 	add	r2,r2,r2
 201c7a8:	1085883a 	add	r2,r2,r2
 201c7ac:	1885883a 	add	r2,r3,r2
 201c7b0:	10800017 	ldw	r2,0(r2)
 201c7b4:	10000626 	beq	r2,zero,201c7d0 <OSTaskChangePrio+0xb0>
 201c7b8:	e0bff517 	ldw	r2,-44(fp)
 201c7bc:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201c7c0:	e0bffa17 	ldw	r2,-24(fp)
 201c7c4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO_EXIST);
 201c7c8:	00800a04 	movi	r2,40
 201c7cc:	00011906 	br	201cc34 <OSTaskChangePrio+0x514>
    }
    if (oldprio == OS_PRIO_SELF) {                          /* See if changing self                    */
 201c7d0:	e0bffe03 	ldbu	r2,-8(fp)
 201c7d4:	10803fd8 	cmpnei	r2,r2,255
 201c7d8:	1000051e 	bne	r2,zero,201c7f0 <OSTaskChangePrio+0xd0>
        oldprio = OSTCBCur->OSTCBPrio;                      /* Yes, get priority                       */
 201c7dc:	00808174 	movhi	r2,517
 201c7e0:	1090aa04 	addi	r2,r2,17064
 201c7e4:	10800017 	ldw	r2,0(r2)
 201c7e8:	10800c83 	ldbu	r2,50(r2)
 201c7ec:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[oldprio];
 201c7f0:	e0bffe03 	ldbu	r2,-8(fp)
 201c7f4:	00c09934 	movhi	r3,612
 201c7f8:	18f45704 	addi	r3,r3,-11940
 201c7fc:	1085883a 	add	r2,r2,r2
 201c800:	1085883a 	add	r2,r2,r2
 201c804:	1885883a 	add	r2,r3,r2
 201c808:	10800017 	ldw	r2,0(r2)
 201c80c:	e0bff615 	stw	r2,-40(fp)
    if (ptcb == (OS_TCB *)0) {                              /* Does task to change exist?              */
 201c810:	e0bff617 	ldw	r2,-40(fp)
 201c814:	1000061e 	bne	r2,zero,201c830 <OSTaskChangePrio+0x110>
 201c818:	e0bff517 	ldw	r2,-44(fp)
 201c81c:	e0bffb15 	stw	r2,-20(fp)
 201c820:	e0bffb17 	ldw	r2,-20(fp)
 201c824:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_PRIO);
 201c828:	00800a44 	movi	r2,41
 201c82c:	00010106 	br	201cc34 <OSTaskChangePrio+0x514>
    }
    if (ptcb == OS_TCB_RESERVED) {                          /* Is task assigned to Mutex               */
 201c830:	e0bff617 	ldw	r2,-40(fp)
 201c834:	10800058 	cmpnei	r2,r2,1
 201c838:	1000061e 	bne	r2,zero,201c854 <OSTaskChangePrio+0x134>
 201c83c:	e0bff517 	ldw	r2,-44(fp)
 201c840:	e0bffc15 	stw	r2,-16(fp)
 201c844:	e0bffc17 	ldw	r2,-16(fp)
 201c848:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                                 /* No, can't change its priority!          */
        return (OS_ERR_TASK_NOT_EXIST);
 201c84c:	008010c4 	movi	r2,67
 201c850:	0000f806 	br	201cc34 <OSTaskChangePrio+0x514>
    }
#if OS_LOWEST_PRIO <= 63
    y_new                 = (INT8U)(newprio >> 3);          /* Yes, compute new TCB fields             */
 201c854:	e0bfff03 	ldbu	r2,-4(fp)
 201c858:	1004d0fa 	srli	r2,r2,3
 201c85c:	e0bff705 	stb	r2,-36(fp)
    x_new                 = (INT8U)(newprio & 0x07);
 201c860:	e0bfff03 	ldbu	r2,-4(fp)
 201c864:	108001cc 	andi	r2,r2,7
 201c868:	e0bff745 	stb	r2,-35(fp)
    bity_new              = (INT8U)(1 << y_new);
 201c86c:	e0bff703 	ldbu	r2,-36(fp)
 201c870:	00c00044 	movi	r3,1
 201c874:	1884983a 	sll	r2,r3,r2
 201c878:	e0bff785 	stb	r2,-34(fp)
    bitx_new              = (INT8U)(1 << x_new);
 201c87c:	e0bff743 	ldbu	r2,-35(fp)
 201c880:	00c00044 	movi	r3,1
 201c884:	1884983a 	sll	r2,r3,r2
 201c888:	e0bff7c5 	stb	r2,-33(fp)
    x_new                 = (INT8U)( newprio & 0x0F);
    bity_new              = (INT16U)(1 << y_new);
    bitx_new              = (INT16U)(1 << x_new);
#endif

    OSTCBPrioTbl[oldprio] = (OS_TCB *)0;                    /* Remove TCB from old priority            */
 201c88c:	e0bffe03 	ldbu	r2,-8(fp)
 201c890:	00c09934 	movhi	r3,612
 201c894:	18f45704 	addi	r3,r3,-11940
 201c898:	1085883a 	add	r2,r2,r2
 201c89c:	1085883a 	add	r2,r2,r2
 201c8a0:	1885883a 	add	r2,r3,r2
 201c8a4:	10000015 	stw	zero,0(r2)
    OSTCBPrioTbl[newprio] =  ptcb;                          /* Place pointer to TCB @ new priority     */
 201c8a8:	e0bfff03 	ldbu	r2,-4(fp)
 201c8ac:	00c09934 	movhi	r3,612
 201c8b0:	18f45704 	addi	r3,r3,-11940
 201c8b4:	1085883a 	add	r2,r2,r2
 201c8b8:	1085883a 	add	r2,r2,r2
 201c8bc:	1885883a 	add	r2,r3,r2
 201c8c0:	e0fff617 	ldw	r3,-40(fp)
 201c8c4:	10c00015 	stw	r3,0(r2)
    y_old                 =  ptcb->OSTCBY;
 201c8c8:	e0bff617 	ldw	r2,-40(fp)
 201c8cc:	10800d03 	ldbu	r2,52(r2)
 201c8d0:	e0bff805 	stb	r2,-32(fp)
    bity_old              =  ptcb->OSTCBBitY;
 201c8d4:	e0bff617 	ldw	r2,-40(fp)
 201c8d8:	10800d83 	ldbu	r2,54(r2)
 201c8dc:	e0bff845 	stb	r2,-31(fp)
    bitx_old              =  ptcb->OSTCBBitX;
 201c8e0:	e0bff617 	ldw	r2,-40(fp)
 201c8e4:	10800d43 	ldbu	r2,53(r2)
 201c8e8:	e0bff885 	stb	r2,-30(fp)
    if ((OSRdyTbl[y_old] &   bitx_old) != 0) {              /* If task is ready make it not            */
 201c8ec:	e0bff803 	ldbu	r2,-32(fp)
 201c8f0:	00c08174 	movhi	r3,517
 201c8f4:	18d0a744 	addi	r3,r3,17053
 201c8f8:	1885883a 	add	r2,r3,r2
 201c8fc:	10c00003 	ldbu	r3,0(r2)
 201c900:	e0bff883 	ldbu	r2,-30(fp)
 201c904:	1884703a 	and	r2,r3,r2
 201c908:	10803fcc 	andi	r2,r2,255
 201c90c:	10003526 	beq	r2,zero,201c9e4 <OSTaskChangePrio+0x2c4>
         OSRdyTbl[y_old] &= ~bitx_old;
 201c910:	e0bff803 	ldbu	r2,-32(fp)
 201c914:	e0fff803 	ldbu	r3,-32(fp)
 201c918:	01008174 	movhi	r4,517
 201c91c:	2110a744 	addi	r4,r4,17053
 201c920:	20c7883a 	add	r3,r4,r3
 201c924:	18c00003 	ldbu	r3,0(r3)
 201c928:	1809883a 	mov	r4,r3
 201c92c:	e0fff883 	ldbu	r3,-30(fp)
 201c930:	00c6303a 	nor	r3,zero,r3
 201c934:	20c6703a 	and	r3,r4,r3
 201c938:	01008174 	movhi	r4,517
 201c93c:	2110a744 	addi	r4,r4,17053
 201c940:	2085883a 	add	r2,r4,r2
 201c944:	10c00005 	stb	r3,0(r2)
         if (OSRdyTbl[y_old] == 0) {
 201c948:	e0bff803 	ldbu	r2,-32(fp)
 201c94c:	00c08174 	movhi	r3,517
 201c950:	18d0a744 	addi	r3,r3,17053
 201c954:	1885883a 	add	r2,r3,r2
 201c958:	10800003 	ldbu	r2,0(r2)
 201c95c:	10803fcc 	andi	r2,r2,255
 201c960:	10000b1e 	bne	r2,zero,201c990 <OSTaskChangePrio+0x270>
             OSRdyGrp &= ~bity_old;
 201c964:	e0bff843 	ldbu	r2,-31(fp)
 201c968:	0084303a 	nor	r2,zero,r2
 201c96c:	1007883a 	mov	r3,r2
 201c970:	00808174 	movhi	r2,517
 201c974:	1090a704 	addi	r2,r2,17052
 201c978:	10800003 	ldbu	r2,0(r2)
 201c97c:	1884703a 	and	r2,r3,r2
 201c980:	1007883a 	mov	r3,r2
 201c984:	00808174 	movhi	r2,517
 201c988:	1090a704 	addi	r2,r2,17052
 201c98c:	10c00005 	stb	r3,0(r2)
         }
         OSRdyGrp        |= bity_new;                       /* Make new priority ready to run          */
 201c990:	00808174 	movhi	r2,517
 201c994:	1090a704 	addi	r2,r2,17052
 201c998:	10c00003 	ldbu	r3,0(r2)
 201c99c:	e0bff783 	ldbu	r2,-34(fp)
 201c9a0:	1884b03a 	or	r2,r3,r2
 201c9a4:	1007883a 	mov	r3,r2
 201c9a8:	00808174 	movhi	r2,517
 201c9ac:	1090a704 	addi	r2,r2,17052
 201c9b0:	10c00005 	stb	r3,0(r2)
         OSRdyTbl[y_new] |= bitx_new;
 201c9b4:	e0bff703 	ldbu	r2,-36(fp)
 201c9b8:	e0fff703 	ldbu	r3,-36(fp)
 201c9bc:	01008174 	movhi	r4,517
 201c9c0:	2110a744 	addi	r4,r4,17053
 201c9c4:	20c7883a 	add	r3,r4,r3
 201c9c8:	19000003 	ldbu	r4,0(r3)
 201c9cc:	e0fff7c3 	ldbu	r3,-33(fp)
 201c9d0:	20c6b03a 	or	r3,r4,r3
 201c9d4:	01008174 	movhi	r4,517
 201c9d8:	2110a744 	addi	r4,r4,17053
 201c9dc:	2085883a 	add	r2,r4,r2
 201c9e0:	10c00005 	stb	r3,0(r2)
    }

#if (OS_EVENT_EN)
    pevent = ptcb->OSTCBEventPtr;
 201c9e4:	e0bff617 	ldw	r2,-40(fp)
 201c9e8:	10800717 	ldw	r2,28(r2)
 201c9ec:	e0bff315 	stw	r2,-52(fp)
    if (pevent != (OS_EVENT *)0) {
 201c9f0:	e0bff317 	ldw	r2,-52(fp)
 201c9f4:	10003126 	beq	r2,zero,201cabc <OSTaskChangePrio+0x39c>
        pevent->OSEventTbl[y_old] &= ~bitx_old;             /* Remove old task prio from wait list     */
 201c9f8:	e0bff803 	ldbu	r2,-32(fp)
 201c9fc:	e0fff803 	ldbu	r3,-32(fp)
 201ca00:	e13ff317 	ldw	r4,-52(fp)
 201ca04:	20c7883a 	add	r3,r4,r3
 201ca08:	18c00204 	addi	r3,r3,8
 201ca0c:	18c000c3 	ldbu	r3,3(r3)
 201ca10:	1809883a 	mov	r4,r3
 201ca14:	e0fff883 	ldbu	r3,-30(fp)
 201ca18:	00c6303a 	nor	r3,zero,r3
 201ca1c:	20c6703a 	and	r3,r4,r3
 201ca20:	e13ff317 	ldw	r4,-52(fp)
 201ca24:	2085883a 	add	r2,r4,r2
 201ca28:	10800204 	addi	r2,r2,8
 201ca2c:	10c000c5 	stb	r3,3(r2)
        if (pevent->OSEventTbl[y_old] == 0) {
 201ca30:	e0bff803 	ldbu	r2,-32(fp)
 201ca34:	e0fff317 	ldw	r3,-52(fp)
 201ca38:	1885883a 	add	r2,r3,r2
 201ca3c:	10800204 	addi	r2,r2,8
 201ca40:	108000c3 	ldbu	r2,3(r2)
 201ca44:	10803fcc 	andi	r2,r2,255
 201ca48:	1000091e 	bne	r2,zero,201ca70 <OSTaskChangePrio+0x350>
            pevent->OSEventGrp    &= ~bity_old;
 201ca4c:	e0bff317 	ldw	r2,-52(fp)
 201ca50:	10800283 	ldbu	r2,10(r2)
 201ca54:	1007883a 	mov	r3,r2
 201ca58:	e0bff843 	ldbu	r2,-31(fp)
 201ca5c:	0084303a 	nor	r2,zero,r2
 201ca60:	1884703a 	and	r2,r3,r2
 201ca64:	1007883a 	mov	r3,r2
 201ca68:	e0bff317 	ldw	r2,-52(fp)
 201ca6c:	10c00285 	stb	r3,10(r2)
        }
        pevent->OSEventGrp        |= bity_new;              /* Add    new task prio to   wait list     */
 201ca70:	e0bff317 	ldw	r2,-52(fp)
 201ca74:	10c00283 	ldbu	r3,10(r2)
 201ca78:	e0bff783 	ldbu	r2,-34(fp)
 201ca7c:	1884b03a 	or	r2,r3,r2
 201ca80:	1007883a 	mov	r3,r2
 201ca84:	e0bff317 	ldw	r2,-52(fp)
 201ca88:	10c00285 	stb	r3,10(r2)
        pevent->OSEventTbl[y_new] |= bitx_new;
 201ca8c:	e0bff703 	ldbu	r2,-36(fp)
 201ca90:	e0fff703 	ldbu	r3,-36(fp)
 201ca94:	e13ff317 	ldw	r4,-52(fp)
 201ca98:	20c7883a 	add	r3,r4,r3
 201ca9c:	18c00204 	addi	r3,r3,8
 201caa0:	190000c3 	ldbu	r4,3(r3)
 201caa4:	e0fff7c3 	ldbu	r3,-33(fp)
 201caa8:	20c6b03a 	or	r3,r4,r3
 201caac:	e13ff317 	ldw	r4,-52(fp)
 201cab0:	2085883a 	add	r2,r4,r2
 201cab4:	10800204 	addi	r2,r2,8
 201cab8:	10c000c5 	stb	r3,3(r2)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
 201cabc:	e0bff617 	ldw	r2,-40(fp)
 201cac0:	10800817 	ldw	r2,32(r2)
 201cac4:	10004026 	beq	r2,zero,201cbc8 <OSTaskChangePrio+0x4a8>
        pevents =  ptcb->OSTCBEventMultiPtr;
 201cac8:	e0bff617 	ldw	r2,-40(fp)
 201cacc:	10800817 	ldw	r2,32(r2)
 201cad0:	e0bff415 	stw	r2,-48(fp)
        pevent  = *pevents;
 201cad4:	e0bff417 	ldw	r2,-48(fp)
 201cad8:	10800017 	ldw	r2,0(r2)
 201cadc:	e0bff315 	stw	r2,-52(fp)
        while (pevent != (OS_EVENT *)0) {
 201cae0:	00003706 	br	201cbc0 <OSTaskChangePrio+0x4a0>
            pevent->OSEventTbl[y_old] &= ~bitx_old;         /* Remove old task prio from wait lists    */
 201cae4:	e0bff803 	ldbu	r2,-32(fp)
 201cae8:	e0fff803 	ldbu	r3,-32(fp)
 201caec:	e13ff317 	ldw	r4,-52(fp)
 201caf0:	20c7883a 	add	r3,r4,r3
 201caf4:	18c00204 	addi	r3,r3,8
 201caf8:	18c000c3 	ldbu	r3,3(r3)
 201cafc:	1809883a 	mov	r4,r3
 201cb00:	e0fff883 	ldbu	r3,-30(fp)
 201cb04:	00c6303a 	nor	r3,zero,r3
 201cb08:	20c6703a 	and	r3,r4,r3
 201cb0c:	e13ff317 	ldw	r4,-52(fp)
 201cb10:	2085883a 	add	r2,r4,r2
 201cb14:	10800204 	addi	r2,r2,8
 201cb18:	10c000c5 	stb	r3,3(r2)
            if (pevent->OSEventTbl[y_old] == 0) {
 201cb1c:	e0bff803 	ldbu	r2,-32(fp)
 201cb20:	e0fff317 	ldw	r3,-52(fp)
 201cb24:	1885883a 	add	r2,r3,r2
 201cb28:	10800204 	addi	r2,r2,8
 201cb2c:	108000c3 	ldbu	r2,3(r2)
 201cb30:	10803fcc 	andi	r2,r2,255
 201cb34:	1000091e 	bne	r2,zero,201cb5c <OSTaskChangePrio+0x43c>
                pevent->OSEventGrp    &= ~bity_old;
 201cb38:	e0bff317 	ldw	r2,-52(fp)
 201cb3c:	10800283 	ldbu	r2,10(r2)
 201cb40:	1007883a 	mov	r3,r2
 201cb44:	e0bff843 	ldbu	r2,-31(fp)
 201cb48:	0084303a 	nor	r2,zero,r2
 201cb4c:	1884703a 	and	r2,r3,r2
 201cb50:	1007883a 	mov	r3,r2
 201cb54:	e0bff317 	ldw	r2,-52(fp)
 201cb58:	10c00285 	stb	r3,10(r2)
            }
            pevent->OSEventGrp        |= bity_new;          /* Add    new task prio to   wait lists    */
 201cb5c:	e0bff317 	ldw	r2,-52(fp)
 201cb60:	10c00283 	ldbu	r3,10(r2)
 201cb64:	e0bff783 	ldbu	r2,-34(fp)
 201cb68:	1884b03a 	or	r2,r3,r2
 201cb6c:	1007883a 	mov	r3,r2
 201cb70:	e0bff317 	ldw	r2,-52(fp)
 201cb74:	10c00285 	stb	r3,10(r2)
            pevent->OSEventTbl[y_new] |= bitx_new;
 201cb78:	e0bff703 	ldbu	r2,-36(fp)
 201cb7c:	e0fff703 	ldbu	r3,-36(fp)
 201cb80:	e13ff317 	ldw	r4,-52(fp)
 201cb84:	20c7883a 	add	r3,r4,r3
 201cb88:	18c00204 	addi	r3,r3,8
 201cb8c:	190000c3 	ldbu	r4,3(r3)
 201cb90:	e0fff7c3 	ldbu	r3,-33(fp)
 201cb94:	20c6b03a 	or	r3,r4,r3
 201cb98:	e13ff317 	ldw	r4,-52(fp)
 201cb9c:	2085883a 	add	r2,r4,r2
 201cba0:	10800204 	addi	r2,r2,8
 201cba4:	10c000c5 	stb	r3,3(r2)
            pevents++;
 201cba8:	e0bff417 	ldw	r2,-48(fp)
 201cbac:	10800104 	addi	r2,r2,4
 201cbb0:	e0bff415 	stw	r2,-48(fp)
            pevent                     = *pevents;
 201cbb4:	e0bff417 	ldw	r2,-48(fp)
 201cbb8:	10800017 	ldw	r2,0(r2)
 201cbbc:	e0bff315 	stw	r2,-52(fp)
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {
        pevents =  ptcb->OSTCBEventMultiPtr;
        pevent  = *pevents;
        while (pevent != (OS_EVENT *)0) {
 201cbc0:	e0bff317 	ldw	r2,-52(fp)
 201cbc4:	103fc71e 	bne	r2,zero,201cae4 <OSTaskChangePrio+0x3c4>
        }
    }
#endif
#endif

    ptcb->OSTCBPrio = newprio;                              /* Set new task priority                   */
 201cbc8:	e0bff617 	ldw	r2,-40(fp)
 201cbcc:	e0ffff03 	ldbu	r3,-4(fp)
 201cbd0:	10c00c85 	stb	r3,50(r2)
    ptcb->OSTCBY    = y_new;
 201cbd4:	e0bff617 	ldw	r2,-40(fp)
 201cbd8:	e0fff703 	ldbu	r3,-36(fp)
 201cbdc:	10c00d05 	stb	r3,52(r2)
    ptcb->OSTCBX    = x_new;
 201cbe0:	e0bff617 	ldw	r2,-40(fp)
 201cbe4:	e0fff743 	ldbu	r3,-35(fp)
 201cbe8:	10c00cc5 	stb	r3,51(r2)
    ptcb->OSTCBBitY = bity_new;
 201cbec:	e0bff617 	ldw	r2,-40(fp)
 201cbf0:	e0fff783 	ldbu	r3,-34(fp)
 201cbf4:	10c00d85 	stb	r3,54(r2)
    ptcb->OSTCBBitX = bitx_new;
 201cbf8:	e0bff617 	ldw	r2,-40(fp)
 201cbfc:	e0fff7c3 	ldbu	r3,-33(fp)
 201cc00:	10c00d45 	stb	r3,53(r2)
 201cc04:	e0bff517 	ldw	r2,-44(fp)
 201cc08:	e0bffd15 	stw	r2,-12(fp)
 201cc0c:	e0bffd17 	ldw	r2,-12(fp)
 201cc10:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 201cc14:	00808174 	movhi	r2,517
 201cc18:	10909b44 	addi	r2,r2,17005
 201cc1c:	10800003 	ldbu	r2,0(r2)
 201cc20:	10803fcc 	andi	r2,r2,255
 201cc24:	10800058 	cmpnei	r2,r2,1
 201cc28:	1000011e 	bne	r2,zero,201cc30 <OSTaskChangePrio+0x510>
        OS_Sched();                                         /* Find new highest priority task          */
 201cc2c:	20176280 	call	2017628 <OS_Sched>
    }
    return (OS_ERR_NONE);
 201cc30:	0005883a 	mov	r2,zero
}
 201cc34:	e037883a 	mov	sp,fp
 201cc38:	dfc00117 	ldw	ra,4(sp)
 201cc3c:	df000017 	ldw	fp,0(sp)
 201cc40:	dec00204 	addi	sp,sp,8
 201cc44:	f800283a 	ret

0201cc48 <OSTaskCreate>:
*********************************************************************************************************
*/

#if OS_TASK_CREATE_EN > 0
INT8U  OSTaskCreate (void (*task)(void *p_arg), void *p_arg, OS_STK *ptos, INT8U prio)
{
 201cc48:	deffee04 	addi	sp,sp,-72
 201cc4c:	dfc01115 	stw	ra,68(sp)
 201cc50:	df001015 	stw	fp,64(sp)
 201cc54:	df001004 	addi	fp,sp,64
 201cc58:	e13ffc15 	stw	r4,-16(fp)
 201cc5c:	e17ffd15 	stw	r5,-12(fp)
 201cc60:	e1bffe15 	stw	r6,-8(fp)
 201cc64:	3805883a 	mov	r2,r7
 201cc68:	e0bfff05 	stb	r2,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 201cc6c:	e03ff315 	stw	zero,-52(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 201cc70:	e0bfff03 	ldbu	r2,-4(fp)
 201cc74:	10800570 	cmpltui	r2,r2,21
 201cc78:	1000021e 	bne	r2,zero,201cc84 <OSTaskCreate+0x3c>
        return (OS_ERR_PRIO_INVALID);
 201cc7c:	00800a84 	movi	r2,42
 201cc80:	00005b06 	br	201cdf0 <OSTaskCreate+0x1a8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201cc84:	0005303a 	rdctl	r2,status
 201cc88:	e0bff615 	stw	r2,-40(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201cc8c:	e0fff617 	ldw	r3,-40(fp)
 201cc90:	00bfff84 	movi	r2,-2
 201cc94:	1884703a 	and	r2,r3,r2
 201cc98:	1001703a 	wrctl	status,r2
  
  return context;
 201cc9c:	e0bff617 	ldw	r2,-40(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201cca0:	e0bff315 	stw	r2,-52(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 201cca4:	00808174 	movhi	r2,517
 201cca8:	1090a904 	addi	r2,r2,17060
 201ccac:	10800003 	ldbu	r2,0(r2)
 201ccb0:	10803fcc 	andi	r2,r2,255
 201ccb4:	10000626 	beq	r2,zero,201ccd0 <OSTaskCreate+0x88>
 201ccb8:	e0bff317 	ldw	r2,-52(fp)
 201ccbc:	e0bff715 	stw	r2,-36(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ccc0:	e0bff717 	ldw	r2,-36(fp)
 201ccc4:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 201ccc8:	00800f04 	movi	r2,60
 201cccc:	00004806 	br	201cdf0 <OSTaskCreate+0x1a8>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 201ccd0:	e0bfff03 	ldbu	r2,-4(fp)
 201ccd4:	00c09934 	movhi	r3,612
 201ccd8:	18f45704 	addi	r3,r3,-11940
 201ccdc:	1085883a 	add	r2,r2,r2
 201cce0:	1085883a 	add	r2,r2,r2
 201cce4:	1885883a 	add	r2,r3,r2
 201cce8:	10800017 	ldw	r2,0(r2)
 201ccec:	10003b1e 	bne	r2,zero,201cddc <OSTaskCreate+0x194>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 201ccf0:	e0bfff03 	ldbu	r2,-4(fp)
 201ccf4:	00c09934 	movhi	r3,612
 201ccf8:	18f45704 	addi	r3,r3,-11940
 201ccfc:	1085883a 	add	r2,r2,r2
 201cd00:	1085883a 	add	r2,r2,r2
 201cd04:	1885883a 	add	r2,r3,r2
 201cd08:	00c00044 	movi	r3,1
 201cd0c:	10c00015 	stw	r3,0(r2)
 201cd10:	e0bff317 	ldw	r2,-52(fp)
 201cd14:	e0bff815 	stw	r2,-32(fp)
 201cd18:	e0bff817 	ldw	r2,-32(fp)
 201cd1c:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();
        psp = OSTaskStkInit(task, p_arg, ptos, 0);              /* Initialize the task's stack         */
 201cd20:	e13ffc17 	ldw	r4,-16(fp)
 201cd24:	e17ffd17 	ldw	r5,-12(fp)
 201cd28:	e1bffe17 	ldw	r6,-8(fp)
 201cd2c:	000f883a 	mov	r7,zero
 201cd30:	2037bd40 	call	2037bd4 <OSTaskStkInit>
 201cd34:	e0bff415 	stw	r2,-48(fp)
        err = OS_TCBInit(prio, psp, (OS_STK *)0, 0, 0, (void *)0, 0);
 201cd38:	e0bfff03 	ldbu	r2,-4(fp)
 201cd3c:	d8000015 	stw	zero,0(sp)
 201cd40:	d8000115 	stw	zero,4(sp)
 201cd44:	d8000215 	stw	zero,8(sp)
 201cd48:	1009883a 	mov	r4,r2
 201cd4c:	e17ff417 	ldw	r5,-48(fp)
 201cd50:	000d883a 	mov	r6,zero
 201cd54:	000f883a 	mov	r7,zero
 201cd58:	2017a140 	call	2017a14 <OS_TCBInit>
 201cd5c:	e0bff505 	stb	r2,-44(fp)
        if (err == OS_ERR_NONE) {
 201cd60:	e0bff503 	ldbu	r2,-44(fp)
 201cd64:	1000081e 	bne	r2,zero,201cd88 <OSTaskCreate+0x140>
            if (OSRunning == OS_TRUE) {      /* Find highest priority task if multitasking has started */
 201cd68:	00808174 	movhi	r2,517
 201cd6c:	10909b44 	addi	r2,r2,17005
 201cd70:	10800003 	ldbu	r2,0(r2)
 201cd74:	10803fcc 	andi	r2,r2,255
 201cd78:	10800058 	cmpnei	r2,r2,1
 201cd7c:	1000151e 	bne	r2,zero,201cdd4 <OSTaskCreate+0x18c>
                OS_Sched();
 201cd80:	20176280 	call	2017628 <OS_Sched>
 201cd84:	00001306 	br	201cdd4 <OSTaskCreate+0x18c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201cd88:	0005303a 	rdctl	r2,status
 201cd8c:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201cd90:	e0fff917 	ldw	r3,-28(fp)
 201cd94:	00bfff84 	movi	r2,-2
 201cd98:	1884703a 	and	r2,r3,r2
 201cd9c:	1001703a 	wrctl	status,r2
  
  return context;
 201cda0:	e0bff917 	ldw	r2,-28(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 201cda4:	e0bff315 	stw	r2,-52(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;/* Make this priority available to others                 */
 201cda8:	e0bfff03 	ldbu	r2,-4(fp)
 201cdac:	00c09934 	movhi	r3,612
 201cdb0:	18f45704 	addi	r3,r3,-11940
 201cdb4:	1085883a 	add	r2,r2,r2
 201cdb8:	1085883a 	add	r2,r2,r2
 201cdbc:	1885883a 	add	r2,r3,r2
 201cdc0:	10000015 	stw	zero,0(r2)
 201cdc4:	e0bff317 	ldw	r2,-52(fp)
 201cdc8:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201cdcc:	e0bffa17 	ldw	r2,-24(fp)
 201cdd0:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 201cdd4:	e0bff503 	ldbu	r2,-44(fp)
 201cdd8:	00000506 	br	201cdf0 <OSTaskCreate+0x1a8>
 201cddc:	e0bff317 	ldw	r2,-52(fp)
 201cde0:	e0bffb15 	stw	r2,-20(fp)
 201cde4:	e0bffb17 	ldw	r2,-20(fp)
 201cde8:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 201cdec:	00800a04 	movi	r2,40
}
 201cdf0:	e037883a 	mov	sp,fp
 201cdf4:	dfc00117 	ldw	ra,4(sp)
 201cdf8:	df000017 	ldw	fp,0(sp)
 201cdfc:	dec00204 	addi	sp,sp,8
 201ce00:	f800283a 	ret

0201ce04 <OSTaskCreateExt>:
                        INT16U   id,
                        OS_STK  *pbos,
                        INT32U   stk_size,
                        void    *pext,
                        INT16U   opt)
{
 201ce04:	deffec04 	addi	sp,sp,-80
 201ce08:	dfc01315 	stw	ra,76(sp)
 201ce0c:	df001215 	stw	fp,72(sp)
 201ce10:	df001204 	addi	fp,sp,72
 201ce14:	e13ffa15 	stw	r4,-24(fp)
 201ce18:	e17ffb15 	stw	r5,-20(fp)
 201ce1c:	e1bffc15 	stw	r6,-16(fp)
 201ce20:	3805883a 	mov	r2,r7
 201ce24:	e1000217 	ldw	r4,8(fp)
 201ce28:	e0c00617 	ldw	r3,24(fp)
 201ce2c:	e0bffd05 	stb	r2,-12(fp)
 201ce30:	e13ffe0d 	sth	r4,-8(fp)
 201ce34:	e0ffff0d 	sth	r3,-4(fp)
    OS_STK    *psp;
    INT8U      err;
#if OS_CRITICAL_METHOD == 3                  /* Allocate storage for CPU status register               */
    OS_CPU_SR  cpu_sr = 0;
 201ce38:	e03ff115 	stw	zero,-60(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {             /* Make sure priority is within allowable range           */
 201ce3c:	e0bffd03 	ldbu	r2,-12(fp)
 201ce40:	10800570 	cmpltui	r2,r2,21
 201ce44:	1000021e 	bne	r2,zero,201ce50 <OSTaskCreateExt+0x4c>
        return (OS_ERR_PRIO_INVALID);
 201ce48:	00800a84 	movi	r2,42
 201ce4c:	00006506 	br	201cfe4 <OSTaskCreateExt+0x1e0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201ce50:	0005303a 	rdctl	r2,status
 201ce54:	e0bff415 	stw	r2,-48(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201ce58:	e0fff417 	ldw	r3,-48(fp)
 201ce5c:	00bfff84 	movi	r2,-2
 201ce60:	1884703a 	and	r2,r3,r2
 201ce64:	1001703a 	wrctl	status,r2
  
  return context;
 201ce68:	e0bff417 	ldw	r2,-48(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201ce6c:	e0bff115 	stw	r2,-60(fp)
    if (OSIntNesting > 0) {                  /* Make sure we don't create the task from within an ISR  */
 201ce70:	00808174 	movhi	r2,517
 201ce74:	1090a904 	addi	r2,r2,17060
 201ce78:	10800003 	ldbu	r2,0(r2)
 201ce7c:	10803fcc 	andi	r2,r2,255
 201ce80:	10000626 	beq	r2,zero,201ce9c <OSTaskCreateExt+0x98>
 201ce84:	e0bff117 	ldw	r2,-60(fp)
 201ce88:	e0bff515 	stw	r2,-44(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201ce8c:	e0bff517 	ldw	r2,-44(fp)
 201ce90:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_CREATE_ISR);
 201ce94:	00800f04 	movi	r2,60
 201ce98:	00005206 	br	201cfe4 <OSTaskCreateExt+0x1e0>
    }
    if (OSTCBPrioTbl[prio] == (OS_TCB *)0) { /* Make sure task doesn't already exist at this priority  */
 201ce9c:	e0bffd03 	ldbu	r2,-12(fp)
 201cea0:	00c09934 	movhi	r3,612
 201cea4:	18f45704 	addi	r3,r3,-11940
 201cea8:	1085883a 	add	r2,r2,r2
 201ceac:	1085883a 	add	r2,r2,r2
 201ceb0:	1885883a 	add	r2,r3,r2
 201ceb4:	10800017 	ldw	r2,0(r2)
 201ceb8:	1000451e 	bne	r2,zero,201cfd0 <OSTaskCreateExt+0x1cc>
        OSTCBPrioTbl[prio] = OS_TCB_RESERVED;/* Reserve the priority to prevent others from doing ...  */
 201cebc:	e0bffd03 	ldbu	r2,-12(fp)
 201cec0:	00c09934 	movhi	r3,612
 201cec4:	18f45704 	addi	r3,r3,-11940
 201cec8:	1085883a 	add	r2,r2,r2
 201cecc:	1085883a 	add	r2,r2,r2
 201ced0:	1885883a 	add	r2,r3,r2
 201ced4:	00c00044 	movi	r3,1
 201ced8:	10c00015 	stw	r3,0(r2)
 201cedc:	e0bff117 	ldw	r2,-60(fp)
 201cee0:	e0bff615 	stw	r2,-40(fp)
 201cee4:	e0bff617 	ldw	r2,-40(fp)
 201cee8:	1001703a 	wrctl	status,r2
                                             /* ... the same thing until task is created.              */
        OS_EXIT_CRITICAL();

#if (OS_TASK_STAT_STK_CHK_EN > 0)
        OS_TaskStkClr(pbos, stk_size, opt);                    /* Clear the task stack (if needed)     */
 201ceec:	e0bfff0b 	ldhu	r2,-4(fp)
 201cef0:	e1000317 	ldw	r4,12(fp)
 201cef4:	e1400417 	ldw	r5,16(fp)
 201cef8:	100d883a 	mov	r6,r2
 201cefc:	201df9c0 	call	201df9c <OS_TaskStkClr>
#endif

        psp = OSTaskStkInit(task, p_arg, ptos, opt);           /* Initialize the task's stack          */
 201cf00:	e0bfff0b 	ldhu	r2,-4(fp)
 201cf04:	e13ffa17 	ldw	r4,-24(fp)
 201cf08:	e17ffb17 	ldw	r5,-20(fp)
 201cf0c:	e1bffc17 	ldw	r6,-16(fp)
 201cf10:	100f883a 	mov	r7,r2
 201cf14:	2037bd40 	call	2037bd4 <OSTaskStkInit>
 201cf18:	e0bff215 	stw	r2,-56(fp)
        err = OS_TCBInit(prio, psp, pbos, id, stk_size, pext, opt);
 201cf1c:	e0fffd03 	ldbu	r3,-12(fp)
 201cf20:	e0bffe0b 	ldhu	r2,-8(fp)
 201cf24:	e13fff0b 	ldhu	r4,-4(fp)
 201cf28:	e1400417 	ldw	r5,16(fp)
 201cf2c:	d9400015 	stw	r5,0(sp)
 201cf30:	e1400517 	ldw	r5,20(fp)
 201cf34:	d9400115 	stw	r5,4(sp)
 201cf38:	d9000215 	stw	r4,8(sp)
 201cf3c:	1809883a 	mov	r4,r3
 201cf40:	e17ff217 	ldw	r5,-56(fp)
 201cf44:	e1800317 	ldw	r6,12(fp)
 201cf48:	100f883a 	mov	r7,r2
 201cf4c:	2017a140 	call	2017a14 <OS_TCBInit>
 201cf50:	e0bff305 	stb	r2,-52(fp)
        if (err == OS_ERR_NONE) {
 201cf54:	e0bff303 	ldbu	r2,-52(fp)
 201cf58:	1000081e 	bne	r2,zero,201cf7c <OSTaskCreateExt+0x178>
            if (OSRunning == OS_TRUE) {                        /* Find HPT if multitasking has started */
 201cf5c:	00808174 	movhi	r2,517
 201cf60:	10909b44 	addi	r2,r2,17005
 201cf64:	10800003 	ldbu	r2,0(r2)
 201cf68:	10803fcc 	andi	r2,r2,255
 201cf6c:	10800058 	cmpnei	r2,r2,1
 201cf70:	1000151e 	bne	r2,zero,201cfc8 <OSTaskCreateExt+0x1c4>
                OS_Sched();
 201cf74:	20176280 	call	2017628 <OS_Sched>
 201cf78:	00001306 	br	201cfc8 <OSTaskCreateExt+0x1c4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201cf7c:	0005303a 	rdctl	r2,status
 201cf80:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201cf84:	e0fff717 	ldw	r3,-36(fp)
 201cf88:	00bfff84 	movi	r2,-2
 201cf8c:	1884703a 	and	r2,r3,r2
 201cf90:	1001703a 	wrctl	status,r2
  
  return context;
 201cf94:	e0bff717 	ldw	r2,-36(fp)
            }
        } else {
            OS_ENTER_CRITICAL();
 201cf98:	e0bff115 	stw	r2,-60(fp)
            OSTCBPrioTbl[prio] = (OS_TCB *)0;                  /* Make this priority avail. to others  */
 201cf9c:	e0bffd03 	ldbu	r2,-12(fp)
 201cfa0:	00c09934 	movhi	r3,612
 201cfa4:	18f45704 	addi	r3,r3,-11940
 201cfa8:	1085883a 	add	r2,r2,r2
 201cfac:	1085883a 	add	r2,r2,r2
 201cfb0:	1885883a 	add	r2,r3,r2
 201cfb4:	10000015 	stw	zero,0(r2)
 201cfb8:	e0bff117 	ldw	r2,-60(fp)
 201cfbc:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201cfc0:	e0bff817 	ldw	r2,-32(fp)
 201cfc4:	1001703a 	wrctl	status,r2
            OS_EXIT_CRITICAL();
        }
        return (err);
 201cfc8:	e0bff303 	ldbu	r2,-52(fp)
 201cfcc:	00000506 	br	201cfe4 <OSTaskCreateExt+0x1e0>
 201cfd0:	e0bff117 	ldw	r2,-60(fp)
 201cfd4:	e0bff915 	stw	r2,-28(fp)
 201cfd8:	e0bff917 	ldw	r2,-28(fp)
 201cfdc:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_PRIO_EXIST);
 201cfe0:	00800a04 	movi	r2,40
}
 201cfe4:	e037883a 	mov	sp,fp
 201cfe8:	dfc00117 	ldw	ra,4(sp)
 201cfec:	df000017 	ldw	fp,0(sp)
 201cff0:	dec00204 	addi	sp,sp,8
 201cff4:	f800283a 	ret

0201cff8 <OSTaskDel>:
*********************************************************************************************************
*/

#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDel (INT8U prio)
{
 201cff8:	defff404 	addi	sp,sp,-48
 201cffc:	dfc00b15 	stw	ra,44(sp)
 201d000:	df000a15 	stw	fp,40(sp)
 201d004:	df000a04 	addi	fp,sp,40
 201d008:	2005883a 	mov	r2,r4
 201d00c:	e0bfff05 	stb	r2,-4(fp)
#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    OS_FLAG_NODE *pnode;
#endif
    OS_TCB       *ptcb;
#if OS_CRITICAL_METHOD == 3                             /* Allocate storage for CPU status register    */
    OS_CPU_SR     cpu_sr = 0;
 201d010:	e03ff615 	stw	zero,-40(fp)
#endif



    if (OSIntNesting > 0) {                             /* See if trying to delete from ISR            */
 201d014:	00808174 	movhi	r2,517
 201d018:	1090a904 	addi	r2,r2,17060
 201d01c:	10800003 	ldbu	r2,0(r2)
 201d020:	10803fcc 	andi	r2,r2,255
 201d024:	10000226 	beq	r2,zero,201d030 <OSTaskDel+0x38>
        return (OS_ERR_TASK_DEL_ISR);
 201d028:	00801004 	movi	r2,64
 201d02c:	0000e406 	br	201d3c0 <OSTaskDel+0x3c8>
    }
    if (prio == OS_TASK_IDLE_PRIO) {                    /* Not allowed to delete idle task             */
 201d030:	e0bfff03 	ldbu	r2,-4(fp)
 201d034:	10800518 	cmpnei	r2,r2,20
 201d038:	1000021e 	bne	r2,zero,201d044 <OSTaskDel+0x4c>
        return (OS_ERR_TASK_DEL_IDLE);
 201d03c:	00800f84 	movi	r2,62
 201d040:	0000df06 	br	201d3c0 <OSTaskDel+0x3c8>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                       /* Task priority valid ?                       */
 201d044:	e0bfff03 	ldbu	r2,-4(fp)
 201d048:	10800530 	cmpltui	r2,r2,20
 201d04c:	1000051e 	bne	r2,zero,201d064 <OSTaskDel+0x6c>
        if (prio != OS_PRIO_SELF) {
 201d050:	e0bfff03 	ldbu	r2,-4(fp)
 201d054:	10803fe0 	cmpeqi	r2,r2,255
 201d058:	1000021e 	bne	r2,zero,201d064 <OSTaskDel+0x6c>
            return (OS_ERR_PRIO_INVALID);
 201d05c:	00800a84 	movi	r2,42
 201d060:	0000d706 	br	201d3c0 <OSTaskDel+0x3c8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d064:	0005303a 	rdctl	r2,status
 201d068:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d06c:	e0fff917 	ldw	r3,-28(fp)
 201d070:	00bfff84 	movi	r2,-2
 201d074:	1884703a 	and	r2,r3,r2
 201d078:	1001703a 	wrctl	status,r2
  
  return context;
 201d07c:	e0bff917 	ldw	r2,-28(fp)
        }
    }
#endif

/*$PAGE*/
    OS_ENTER_CRITICAL();
 201d080:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                         /* See if requesting to delete self            */
 201d084:	e0bfff03 	ldbu	r2,-4(fp)
 201d088:	10803fd8 	cmpnei	r2,r2,255
 201d08c:	1000051e 	bne	r2,zero,201d0a4 <OSTaskDel+0xac>
        prio = OSTCBCur->OSTCBPrio;                     /* Set priority to delete to current           */
 201d090:	00808174 	movhi	r2,517
 201d094:	1090aa04 	addi	r2,r2,17064
 201d098:	10800017 	ldw	r2,0(r2)
 201d09c:	10800c83 	ldbu	r2,50(r2)
 201d0a0:	e0bfff05 	stb	r2,-4(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201d0a4:	e0bfff03 	ldbu	r2,-4(fp)
 201d0a8:	00c09934 	movhi	r3,612
 201d0ac:	18f45704 	addi	r3,r3,-11940
 201d0b0:	1085883a 	add	r2,r2,r2
 201d0b4:	1085883a 	add	r2,r2,r2
 201d0b8:	1885883a 	add	r2,r3,r2
 201d0bc:	10800017 	ldw	r2,0(r2)
 201d0c0:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                          /* Task to delete must exist                   */
 201d0c4:	e0bff717 	ldw	r2,-36(fp)
 201d0c8:	1000061e 	bne	r2,zero,201d0e4 <OSTaskDel+0xec>
 201d0cc:	e0bff617 	ldw	r2,-40(fp)
 201d0d0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d0d4:	e0bffa17 	ldw	r2,-24(fp)
 201d0d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201d0dc:	008010c4 	movi	r2,67
 201d0e0:	0000b706 	br	201d3c0 <OSTaskDel+0x3c8>
    }
    if (ptcb == OS_TCB_RESERVED) {                      /* Must not be assigned to Mutex               */
 201d0e4:	e0bff717 	ldw	r2,-36(fp)
 201d0e8:	10800058 	cmpnei	r2,r2,1
 201d0ec:	1000061e 	bne	r2,zero,201d108 <OSTaskDel+0x110>
 201d0f0:	e0bff617 	ldw	r2,-40(fp)
 201d0f4:	e0bffb15 	stw	r2,-20(fp)
 201d0f8:	e0bffb17 	ldw	r2,-20(fp)
 201d0fc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 201d100:	00800f44 	movi	r2,61
 201d104:	0000ae06 	br	201d3c0 <OSTaskDel+0x3c8>
    }

    OSRdyTbl[ptcb->OSTCBY] &= ~ptcb->OSTCBBitX;
 201d108:	e0bff717 	ldw	r2,-36(fp)
 201d10c:	10800d03 	ldbu	r2,52(r2)
 201d110:	10803fcc 	andi	r2,r2,255
 201d114:	e0fff717 	ldw	r3,-36(fp)
 201d118:	18c00d03 	ldbu	r3,52(r3)
 201d11c:	18c03fcc 	andi	r3,r3,255
 201d120:	01008174 	movhi	r4,517
 201d124:	2110a744 	addi	r4,r4,17053
 201d128:	20c7883a 	add	r3,r4,r3
 201d12c:	18c00003 	ldbu	r3,0(r3)
 201d130:	1809883a 	mov	r4,r3
 201d134:	e0fff717 	ldw	r3,-36(fp)
 201d138:	18c00d43 	ldbu	r3,53(r3)
 201d13c:	00c6303a 	nor	r3,zero,r3
 201d140:	20c6703a 	and	r3,r4,r3
 201d144:	01008174 	movhi	r4,517
 201d148:	2110a744 	addi	r4,r4,17053
 201d14c:	2085883a 	add	r2,r4,r2
 201d150:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[ptcb->OSTCBY] == 0) {                  /* Make task not ready                         */
 201d154:	e0bff717 	ldw	r2,-36(fp)
 201d158:	10800d03 	ldbu	r2,52(r2)
 201d15c:	10803fcc 	andi	r2,r2,255
 201d160:	00c08174 	movhi	r3,517
 201d164:	18d0a744 	addi	r3,r3,17053
 201d168:	1885883a 	add	r2,r3,r2
 201d16c:	10800003 	ldbu	r2,0(r2)
 201d170:	10803fcc 	andi	r2,r2,255
 201d174:	10000c1e 	bne	r2,zero,201d1a8 <OSTaskDel+0x1b0>
        OSRdyGrp           &= ~ptcb->OSTCBBitY;
 201d178:	e0bff717 	ldw	r2,-36(fp)
 201d17c:	10800d83 	ldbu	r2,54(r2)
 201d180:	0084303a 	nor	r2,zero,r2
 201d184:	1007883a 	mov	r3,r2
 201d188:	00808174 	movhi	r2,517
 201d18c:	1090a704 	addi	r2,r2,17052
 201d190:	10800003 	ldbu	r2,0(r2)
 201d194:	1884703a 	and	r2,r3,r2
 201d198:	1007883a 	mov	r3,r2
 201d19c:	00808174 	movhi	r2,517
 201d1a0:	1090a704 	addi	r2,r2,17052
 201d1a4:	10c00005 	stb	r3,0(r2)
    }
    
#if (OS_EVENT_EN)
    if (ptcb->OSTCBEventPtr != (OS_EVENT *)0) {
 201d1a8:	e0bff717 	ldw	r2,-36(fp)
 201d1ac:	10800717 	ldw	r2,28(r2)
 201d1b0:	10000526 	beq	r2,zero,201d1c8 <OSTaskDel+0x1d0>
        OS_EventTaskRemove(ptcb, ptcb->OSTCBEventPtr);  /* Remove this task from any event   wait list */
 201d1b4:	e0bff717 	ldw	r2,-36(fp)
 201d1b8:	10800717 	ldw	r2,28(r2)
 201d1bc:	e13ff717 	ldw	r4,-36(fp)
 201d1c0:	100b883a 	mov	r5,r2
 201d1c4:	2016ff40 	call	2016ff4 <OS_EventTaskRemove>
    }
#if (OS_EVENT_MULTI_EN > 0)
    if (ptcb->OSTCBEventMultiPtr != (OS_EVENT **)0) {   /* Remove this task from any events' wait lists*/
 201d1c8:	e0bff717 	ldw	r2,-36(fp)
 201d1cc:	10800817 	ldw	r2,32(r2)
 201d1d0:	10000526 	beq	r2,zero,201d1e8 <OSTaskDel+0x1f0>
        OS_EventTaskRemoveMulti(ptcb, ptcb->OSTCBEventMultiPtr);
 201d1d4:	e0bff717 	ldw	r2,-36(fp)
 201d1d8:	10800817 	ldw	r2,32(r2)
 201d1dc:	e13ff717 	ldw	r4,-36(fp)
 201d1e0:	100b883a 	mov	r5,r2
 201d1e4:	20170a40 	call	20170a4 <OS_EventTaskRemoveMulti>
    }
#endif
#endif

#if (OS_FLAG_EN > 0) && (OS_MAX_FLAGS > 0)
    pnode = ptcb->OSTCBFlagNode;
 201d1e8:	e0bff717 	ldw	r2,-36(fp)
 201d1ec:	10800a17 	ldw	r2,40(r2)
 201d1f0:	e0bff815 	stw	r2,-32(fp)
    if (pnode != (OS_FLAG_NODE *)0) {                   /* If task is waiting on event flag            */
 201d1f4:	e0bff817 	ldw	r2,-32(fp)
 201d1f8:	10000226 	beq	r2,zero,201d204 <OSTaskDel+0x20c>
        OS_FlagUnlink(pnode);                           /* Remove from wait list                       */
 201d1fc:	e13ff817 	ldw	r4,-32(fp)
 201d200:	201960c0 	call	201960c <OS_FlagUnlink>
    }
#endif

    ptcb->OSTCBDly      = 0;                            /* Prevent OSTimeTick() from updating          */
 201d204:	e0bff717 	ldw	r2,-36(fp)
 201d208:	10000b8d 	sth	zero,46(r2)
    ptcb->OSTCBStat     = OS_STAT_RDY;                  /* Prevent task from being resumed             */
 201d20c:	e0bff717 	ldw	r2,-36(fp)
 201d210:	10000c05 	stb	zero,48(r2)
    ptcb->OSTCBStatPend = OS_STAT_PEND_OK;
 201d214:	e0bff717 	ldw	r2,-36(fp)
 201d218:	10000c45 	stb	zero,49(r2)
    if (OSLockNesting < 255u) {                         /* Make sure we don't context switch           */
 201d21c:	00808174 	movhi	r2,517
 201d220:	10909b04 	addi	r2,r2,17004
 201d224:	10800003 	ldbu	r2,0(r2)
 201d228:	10803fcc 	andi	r2,r2,255
 201d22c:	10803fe0 	cmpeqi	r2,r2,255
 201d230:	1000081e 	bne	r2,zero,201d254 <OSTaskDel+0x25c>
        OSLockNesting++;
 201d234:	00808174 	movhi	r2,517
 201d238:	10909b04 	addi	r2,r2,17004
 201d23c:	10800003 	ldbu	r2,0(r2)
 201d240:	10800044 	addi	r2,r2,1
 201d244:	1007883a 	mov	r3,r2
 201d248:	00808174 	movhi	r2,517
 201d24c:	10909b04 	addi	r2,r2,17004
 201d250:	10c00005 	stb	r3,0(r2)
 201d254:	e0bff617 	ldw	r2,-40(fp)
 201d258:	e0bffc15 	stw	r2,-16(fp)
 201d25c:	e0bffc17 	ldw	r2,-16(fp)
 201d260:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();                                 /* Enabling INT. ignores next instruc.         */
    OS_Dummy();                                         /* ... Dummy ensures that INTs will be         */
 201d264:	2016bf00 	call	2016bf0 <OS_Dummy>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d268:	0005303a 	rdctl	r2,status
 201d26c:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d270:	e0fffd17 	ldw	r3,-12(fp)
 201d274:	00bfff84 	movi	r2,-2
 201d278:	1884703a 	and	r2,r3,r2
 201d27c:	1001703a 	wrctl	status,r2
  
  return context;
 201d280:	e0bffd17 	ldw	r2,-12(fp)
    OS_ENTER_CRITICAL();                                /* ... disabled HERE!                          */
 201d284:	e0bff615 	stw	r2,-40(fp)
    if (OSLockNesting > 0) {                            /* Remove context switch lock                  */
 201d288:	00808174 	movhi	r2,517
 201d28c:	10909b04 	addi	r2,r2,17004
 201d290:	10800003 	ldbu	r2,0(r2)
 201d294:	10803fcc 	andi	r2,r2,255
 201d298:	10000826 	beq	r2,zero,201d2bc <OSTaskDel+0x2c4>
        OSLockNesting--;
 201d29c:	00808174 	movhi	r2,517
 201d2a0:	10909b04 	addi	r2,r2,17004
 201d2a4:	10800003 	ldbu	r2,0(r2)
 201d2a8:	10bfffc4 	addi	r2,r2,-1
 201d2ac:	1007883a 	mov	r3,r2
 201d2b0:	00808174 	movhi	r2,517
 201d2b4:	10909b04 	addi	r2,r2,17004
 201d2b8:	10c00005 	stb	r3,0(r2)
    }
    OSTaskDelHook(ptcb);                                /* Call user defined hook                      */
 201d2bc:	e13ff717 	ldw	r4,-36(fp)
 201d2c0:	2037ee80 	call	2037ee8 <OSTaskDelHook>
    OSTaskCtr--;                                        /* One less task being managed                 */
 201d2c4:	00808174 	movhi	r2,517
 201d2c8:	1090a344 	addi	r2,r2,17037
 201d2cc:	10800003 	ldbu	r2,0(r2)
 201d2d0:	10bfffc4 	addi	r2,r2,-1
 201d2d4:	1007883a 	mov	r3,r2
 201d2d8:	00808174 	movhi	r2,517
 201d2dc:	1090a344 	addi	r2,r2,17037
 201d2e0:	10c00005 	stb	r3,0(r2)
    OSTCBPrioTbl[prio] = (OS_TCB *)0;                   /* Clear old priority entry                    */
 201d2e4:	e0bfff03 	ldbu	r2,-4(fp)
 201d2e8:	00c09934 	movhi	r3,612
 201d2ec:	18f45704 	addi	r3,r3,-11940
 201d2f0:	1085883a 	add	r2,r2,r2
 201d2f4:	1085883a 	add	r2,r2,r2
 201d2f8:	1885883a 	add	r2,r3,r2
 201d2fc:	10000015 	stw	zero,0(r2)
    if (ptcb->OSTCBPrev == (OS_TCB *)0) {               /* Remove from TCB chain                       */
 201d300:	e0bff717 	ldw	r2,-36(fp)
 201d304:	10800617 	ldw	r2,24(r2)
 201d308:	1000091e 	bne	r2,zero,201d330 <OSTaskDel+0x338>
        ptcb->OSTCBNext->OSTCBPrev = (OS_TCB *)0;
 201d30c:	e0bff717 	ldw	r2,-36(fp)
 201d310:	10800517 	ldw	r2,20(r2)
 201d314:	10000615 	stw	zero,24(r2)
        OSTCBList                  = ptcb->OSTCBNext;
 201d318:	e0bff717 	ldw	r2,-36(fp)
 201d31c:	10c00517 	ldw	r3,20(r2)
 201d320:	00808174 	movhi	r2,517
 201d324:	10909e04 	addi	r2,r2,17016
 201d328:	10c00015 	stw	r3,0(r2)
 201d32c:	00000a06 	br	201d358 <OSTaskDel+0x360>
    } else {
        ptcb->OSTCBPrev->OSTCBNext = ptcb->OSTCBNext;
 201d330:	e0bff717 	ldw	r2,-36(fp)
 201d334:	10800617 	ldw	r2,24(r2)
 201d338:	e0fff717 	ldw	r3,-36(fp)
 201d33c:	18c00517 	ldw	r3,20(r3)
 201d340:	10c00515 	stw	r3,20(r2)
        ptcb->OSTCBNext->OSTCBPrev = ptcb->OSTCBPrev;
 201d344:	e0bff717 	ldw	r2,-36(fp)
 201d348:	10800517 	ldw	r2,20(r2)
 201d34c:	e0fff717 	ldw	r3,-36(fp)
 201d350:	18c00617 	ldw	r3,24(r3)
 201d354:	10c00615 	stw	r3,24(r2)
    }
    ptcb->OSTCBNext   = OSTCBFreeList;                  /* Return TCB to free TCB list                 */
 201d358:	00808174 	movhi	r2,517
 201d35c:	1090a204 	addi	r2,r2,17032
 201d360:	10c00017 	ldw	r3,0(r2)
 201d364:	e0bff717 	ldw	r2,-36(fp)
 201d368:	10c00515 	stw	r3,20(r2)
    OSTCBFreeList     = ptcb;
 201d36c:	00808174 	movhi	r2,517
 201d370:	1090a204 	addi	r2,r2,17032
 201d374:	e0fff717 	ldw	r3,-36(fp)
 201d378:	10c00015 	stw	r3,0(r2)
#if OS_TASK_NAME_SIZE > 1
    ptcb->OSTCBTaskName[0] = '?';                       /* Unknown name                                */
 201d37c:	e0bff717 	ldw	r2,-36(fp)
 201d380:	00c00fc4 	movi	r3,63
 201d384:	10c01305 	stb	r3,76(r2)
    ptcb->OSTCBTaskName[1] = OS_ASCII_NUL;
 201d388:	e0bff717 	ldw	r2,-36(fp)
 201d38c:	10001345 	stb	zero,77(r2)
 201d390:	e0bff617 	ldw	r2,-40(fp)
 201d394:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d398:	e0bffe17 	ldw	r2,-8(fp)
 201d39c:	1001703a 	wrctl	status,r2
#endif
    OS_EXIT_CRITICAL();
    if (OSRunning == OS_TRUE) {
 201d3a0:	00808174 	movhi	r2,517
 201d3a4:	10909b44 	addi	r2,r2,17005
 201d3a8:	10800003 	ldbu	r2,0(r2)
 201d3ac:	10803fcc 	andi	r2,r2,255
 201d3b0:	10800058 	cmpnei	r2,r2,1
 201d3b4:	1000011e 	bne	r2,zero,201d3bc <OSTaskDel+0x3c4>
        OS_Sched();                                     /* Find new highest priority task              */
 201d3b8:	20176280 	call	2017628 <OS_Sched>
    }
    return (OS_ERR_NONE);
 201d3bc:	0005883a 	mov	r2,zero
}
 201d3c0:	e037883a 	mov	sp,fp
 201d3c4:	dfc00117 	ldw	ra,4(sp)
 201d3c8:	df000017 	ldw	fp,0(sp)
 201d3cc:	dec00204 	addi	sp,sp,8
 201d3d0:	f800283a 	ret

0201d3d4 <OSTaskDelReq>:
*********************************************************************************************************
*/
/*$PAGE*/
#if OS_TASK_DEL_EN > 0
INT8U  OSTaskDelReq (INT8U prio)
{
 201d3d4:	defff504 	addi	sp,sp,-44
 201d3d8:	df000a15 	stw	fp,40(sp)
 201d3dc:	df000a04 	addi	fp,sp,40
 201d3e0:	2005883a 	mov	r2,r4
 201d3e4:	e0bfff05 	stb	r2,-4(fp)
    INT8U      stat;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201d3e8:	e03ff615 	stw	zero,-40(fp)
#endif



    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to delete idle task     */
 201d3ec:	e0bfff03 	ldbu	r2,-4(fp)
 201d3f0:	10800518 	cmpnei	r2,r2,20
 201d3f4:	1000021e 	bne	r2,zero,201d400 <OSTaskDelReq+0x2c>
        return (OS_ERR_TASK_DEL_IDLE);
 201d3f8:	00800f84 	movi	r2,62
 201d3fc:	00004706 	br	201d51c <OSTaskDelReq+0x148>
    }
#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 201d400:	e0bfff03 	ldbu	r2,-4(fp)
 201d404:	10800530 	cmpltui	r2,r2,20
 201d408:	1000051e 	bne	r2,zero,201d420 <OSTaskDelReq+0x4c>
        if (prio != OS_PRIO_SELF) {
 201d40c:	e0bfff03 	ldbu	r2,-4(fp)
 201d410:	10803fe0 	cmpeqi	r2,r2,255
 201d414:	1000021e 	bne	r2,zero,201d420 <OSTaskDelReq+0x4c>
            return (OS_ERR_PRIO_INVALID);
 201d418:	00800a84 	movi	r2,42
 201d41c:	00003f06 	br	201d51c <OSTaskDelReq+0x148>
        }
    }
#endif
    if (prio == OS_PRIO_SELF) {                                 /* See if a task is requesting to ...  */
 201d420:	e0bfff03 	ldbu	r2,-4(fp)
 201d424:	10803fd8 	cmpnei	r2,r2,255
 201d428:	1000131e 	bne	r2,zero,201d478 <OSTaskDelReq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d42c:	0005303a 	rdctl	r2,status
 201d430:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d434:	e0fff917 	ldw	r3,-28(fp)
 201d438:	00bfff84 	movi	r2,-2
 201d43c:	1884703a 	and	r2,r3,r2
 201d440:	1001703a 	wrctl	status,r2
  
  return context;
 201d444:	e0bff917 	ldw	r2,-28(fp)
        OS_ENTER_CRITICAL();                                    /* ... this task to delete itself      */
 201d448:	e0bff615 	stw	r2,-40(fp)
        stat = OSTCBCur->OSTCBDelReq;                           /* Return request status to caller     */
 201d44c:	00808174 	movhi	r2,517
 201d450:	1090aa04 	addi	r2,r2,17064
 201d454:	10800017 	ldw	r2,0(r2)
 201d458:	10800dc3 	ldbu	r2,55(r2)
 201d45c:	e0bff705 	stb	r2,-36(fp)
 201d460:	e0bff617 	ldw	r2,-40(fp)
 201d464:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d468:	e0bffa17 	ldw	r2,-24(fp)
 201d46c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (stat);
 201d470:	e0bff703 	ldbu	r2,-36(fp)
 201d474:	00002906 	br	201d51c <OSTaskDelReq+0x148>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d478:	0005303a 	rdctl	r2,status
 201d47c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d480:	e0fffb17 	ldw	r3,-20(fp)
 201d484:	00bfff84 	movi	r2,-2
 201d488:	1884703a 	and	r2,r3,r2
 201d48c:	1001703a 	wrctl	status,r2
  
  return context;
 201d490:	e0bffb17 	ldw	r2,-20(fp)
    }
    OS_ENTER_CRITICAL();
 201d494:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 201d498:	e0bfff03 	ldbu	r2,-4(fp)
 201d49c:	00c09934 	movhi	r3,612
 201d4a0:	18f45704 	addi	r3,r3,-11940
 201d4a4:	1085883a 	add	r2,r2,r2
 201d4a8:	1085883a 	add	r2,r2,r2
 201d4ac:	1885883a 	add	r2,r3,r2
 201d4b0:	10800017 	ldw	r2,0(r2)
 201d4b4:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to delete must exist           */
 201d4b8:	e0bff817 	ldw	r2,-32(fp)
 201d4bc:	1000061e 	bne	r2,zero,201d4d8 <OSTaskDelReq+0x104>
 201d4c0:	e0bff617 	ldw	r2,-40(fp)
 201d4c4:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d4c8:	e0bffc17 	ldw	r2,-16(fp)
 201d4cc:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                         /* Task must already be deleted        */
 201d4d0:	008010c4 	movi	r2,67
 201d4d4:	00001106 	br	201d51c <OSTaskDelReq+0x148>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* Must NOT be assigned to a Mutex     */
 201d4d8:	e0bff817 	ldw	r2,-32(fp)
 201d4dc:	10800058 	cmpnei	r2,r2,1
 201d4e0:	1000061e 	bne	r2,zero,201d4fc <OSTaskDelReq+0x128>
 201d4e4:	e0bff617 	ldw	r2,-40(fp)
 201d4e8:	e0bffd15 	stw	r2,-12(fp)
 201d4ec:	e0bffd17 	ldw	r2,-12(fp)
 201d4f0:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_DEL);
 201d4f4:	00800f44 	movi	r2,61
 201d4f8:	00000806 	br	201d51c <OSTaskDelReq+0x148>
    }
    ptcb->OSTCBDelReq = OS_ERR_TASK_DEL_REQ;                    /* Set flag indicating task to be DEL. */
 201d4fc:	e0bff817 	ldw	r2,-32(fp)
 201d500:	00c00fc4 	movi	r3,63
 201d504:	10c00dc5 	stb	r3,55(r2)
 201d508:	e0bff617 	ldw	r2,-40(fp)
 201d50c:	e0bffe15 	stw	r2,-8(fp)
 201d510:	e0bffe17 	ldw	r2,-8(fp)
 201d514:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201d518:	0005883a 	mov	r2,zero
}
 201d51c:	e037883a 	mov	sp,fp
 201d520:	df000017 	ldw	fp,0(sp)
 201d524:	dec00104 	addi	sp,sp,4
 201d528:	f800283a 	ret

0201d52c <OSTaskNameGet>:
*********************************************************************************************************
*/

#if OS_TASK_NAME_SIZE > 1
INT8U  OSTaskNameGet (INT8U prio, INT8U *pname, INT8U *perr)
{
 201d52c:	defff404 	addi	sp,sp,-48
 201d530:	dfc00b15 	stw	ra,44(sp)
 201d534:	df000a15 	stw	fp,40(sp)
 201d538:	df000a04 	addi	fp,sp,40
 201d53c:	2005883a 	mov	r2,r4
 201d540:	e17ffe15 	stw	r5,-8(fp)
 201d544:	e1bfff15 	stw	r6,-4(fp)
 201d548:	e0bffd05 	stb	r2,-12(fp)
    OS_TCB    *ptcb;
    INT8U      len;
#if OS_CRITICAL_METHOD == 3                              /* Allocate storage for CPU status register   */
    OS_CPU_SR  cpu_sr = 0;
 201d54c:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                            /* Validate 'perr'                            */
 201d550:	e0bfff17 	ldw	r2,-4(fp)
 201d554:	1000021e 	bne	r2,zero,201d560 <OSTaskNameGet+0x34>
        return (0);
 201d558:	0005883a 	mov	r2,zero
 201d55c:	00005806 	br	201d6c0 <OSTaskNameGet+0x194>
    }
    if (prio > OS_LOWEST_PRIO) {                         /* Task priority valid ?                      */
 201d560:	e0bffd03 	ldbu	r2,-12(fp)
 201d564:	10800570 	cmpltui	r2,r2,21
 201d568:	1000081e 	bne	r2,zero,201d58c <OSTaskNameGet+0x60>
        if (prio != OS_PRIO_SELF) {
 201d56c:	e0bffd03 	ldbu	r2,-12(fp)
 201d570:	10803fe0 	cmpeqi	r2,r2,255
 201d574:	1000051e 	bne	r2,zero,201d58c <OSTaskNameGet+0x60>
            *perr = OS_ERR_PRIO_INVALID;                 /* No                                         */
 201d578:	e0bfff17 	ldw	r2,-4(fp)
 201d57c:	00c00a84 	movi	r3,42
 201d580:	10c00005 	stb	r3,0(r2)
            return (0);
 201d584:	0005883a 	mov	r2,zero
 201d588:	00004d06 	br	201d6c0 <OSTaskNameGet+0x194>
        }
    }
    if (pname == (INT8U *)0) {                           /* Is 'pname' a NULL pointer?                 */
 201d58c:	e0bffe17 	ldw	r2,-8(fp)
 201d590:	1000051e 	bne	r2,zero,201d5a8 <OSTaskNameGet+0x7c>
        *perr = OS_ERR_PNAME_NULL;                       /* Yes                                        */
 201d594:	e0bfff17 	ldw	r2,-4(fp)
 201d598:	00c00304 	movi	r3,12
 201d59c:	10c00005 	stb	r3,0(r2)
        return (0);
 201d5a0:	0005883a 	mov	r2,zero
 201d5a4:	00004606 	br	201d6c0 <OSTaskNameGet+0x194>
    }
#endif
    if (OSIntNesting > 0) {                              /* See if trying to call from an ISR          */
 201d5a8:	00808174 	movhi	r2,517
 201d5ac:	1090a904 	addi	r2,r2,17060
 201d5b0:	10800003 	ldbu	r2,0(r2)
 201d5b4:	10803fcc 	andi	r2,r2,255
 201d5b8:	10000526 	beq	r2,zero,201d5d0 <OSTaskNameGet+0xa4>
        *perr = OS_ERR_NAME_GET_ISR;
 201d5bc:	e0bfff17 	ldw	r2,-4(fp)
 201d5c0:	00c00444 	movi	r3,17
 201d5c4:	10c00005 	stb	r3,0(r2)
        return (0);
 201d5c8:	0005883a 	mov	r2,zero
 201d5cc:	00003c06 	br	201d6c0 <OSTaskNameGet+0x194>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d5d0:	0005303a 	rdctl	r2,status
 201d5d4:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d5d8:	e0fff917 	ldw	r3,-28(fp)
 201d5dc:	00bfff84 	movi	r2,-2
 201d5e0:	1884703a 	and	r2,r3,r2
 201d5e4:	1001703a 	wrctl	status,r2
  
  return context;
 201d5e8:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 201d5ec:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                          /* See if caller desires it's own name        */
 201d5f0:	e0bffd03 	ldbu	r2,-12(fp)
 201d5f4:	10803fd8 	cmpnei	r2,r2,255
 201d5f8:	1000051e 	bne	r2,zero,201d610 <OSTaskNameGet+0xe4>
        prio = OSTCBCur->OSTCBPrio;
 201d5fc:	00808174 	movhi	r2,517
 201d600:	1090aa04 	addi	r2,r2,17064
 201d604:	10800017 	ldw	r2,0(r2)
 201d608:	10800c83 	ldbu	r2,50(r2)
 201d60c:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201d610:	e0bffd03 	ldbu	r2,-12(fp)
 201d614:	00c09934 	movhi	r3,612
 201d618:	18f45704 	addi	r3,r3,-11940
 201d61c:	1085883a 	add	r2,r2,r2
 201d620:	1085883a 	add	r2,r2,r2
 201d624:	1885883a 	add	r2,r3,r2
 201d628:	10800017 	ldw	r2,0(r2)
 201d62c:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                           /* Does task exist?                           */
 201d630:	e0bff717 	ldw	r2,-36(fp)
 201d634:	1000091e 	bne	r2,zero,201d65c <OSTaskNameGet+0x130>
 201d638:	e0bff617 	ldw	r2,-40(fp)
 201d63c:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d640:	e0bffa17 	ldw	r2,-24(fp)
 201d644:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* No                                         */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201d648:	e0bfff17 	ldw	r2,-4(fp)
 201d64c:	00c010c4 	movi	r3,67
 201d650:	10c00005 	stb	r3,0(r2)
        return (0);
 201d654:	0005883a 	mov	r2,zero
 201d658:	00001906 	br	201d6c0 <OSTaskNameGet+0x194>
    }
    if (ptcb == OS_TCB_RESERVED) {                       /* Task assigned to a Mutex?                  */
 201d65c:	e0bff717 	ldw	r2,-36(fp)
 201d660:	10800058 	cmpnei	r2,r2,1
 201d664:	1000091e 	bne	r2,zero,201d68c <OSTaskNameGet+0x160>
 201d668:	e0bff617 	ldw	r2,-40(fp)
 201d66c:	e0bffb15 	stw	r2,-20(fp)
 201d670:	e0bffb17 	ldw	r2,-20(fp)
 201d674:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                              /* Yes                                        */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201d678:	e0bfff17 	ldw	r2,-4(fp)
 201d67c:	00c010c4 	movi	r3,67
 201d680:	10c00005 	stb	r3,0(r2)
        return (0);
 201d684:	0005883a 	mov	r2,zero
 201d688:	00000d06 	br	201d6c0 <OSTaskNameGet+0x194>
    }
    len   = OS_StrCopy(pname, ptcb->OSTCBTaskName);      /* Yes, copy name from TCB                    */
 201d68c:	e0bff717 	ldw	r2,-36(fp)
 201d690:	10801304 	addi	r2,r2,76
 201d694:	e13ffe17 	ldw	r4,-8(fp)
 201d698:	100b883a 	mov	r5,r2
 201d69c:	20177640 	call	2017764 <OS_StrCopy>
 201d6a0:	e0bff805 	stb	r2,-32(fp)
 201d6a4:	e0bff617 	ldw	r2,-40(fp)
 201d6a8:	e0bffc15 	stw	r2,-16(fp)
 201d6ac:	e0bffc17 	ldw	r2,-16(fp)
 201d6b0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201d6b4:	e0bfff17 	ldw	r2,-4(fp)
 201d6b8:	10000005 	stb	zero,0(r2)
    return (len);
 201d6bc:	e0bff803 	ldbu	r2,-32(fp)
}
 201d6c0:	e037883a 	mov	sp,fp
 201d6c4:	dfc00117 	ldw	ra,4(sp)
 201d6c8:	df000017 	ldw	fp,0(sp)
 201d6cc:	dec00204 	addi	sp,sp,8
 201d6d0:	f800283a 	ret

0201d6d4 <OSTaskNameSet>:
* Returns    : None
*********************************************************************************************************
*/
#if OS_TASK_NAME_SIZE > 1
void  OSTaskNameSet (INT8U prio, INT8U *pname, INT8U *perr)
{
 201d6d4:	defff304 	addi	sp,sp,-52
 201d6d8:	dfc00c15 	stw	ra,48(sp)
 201d6dc:	df000b15 	stw	fp,44(sp)
 201d6e0:	df000b04 	addi	fp,sp,44
 201d6e4:	2005883a 	mov	r2,r4
 201d6e8:	e17ffe15 	stw	r5,-8(fp)
 201d6ec:	e1bfff15 	stw	r6,-4(fp)
 201d6f0:	e0bffd05 	stb	r2,-12(fp)
    INT8U      len;
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                          /* Allocate storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 201d6f4:	e03ff515 	stw	zero,-44(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
 201d6f8:	e0bfff17 	ldw	r2,-4(fp)
 201d6fc:	10006026 	beq	r2,zero,201d880 <OSTaskNameSet+0x1ac>
        return;
    }
    if (prio > OS_LOWEST_PRIO) {                     /* Task priority valid ?                          */
 201d700:	e0bffd03 	ldbu	r2,-12(fp)
 201d704:	10800570 	cmpltui	r2,r2,21
 201d708:	1000071e 	bne	r2,zero,201d728 <OSTaskNameSet+0x54>
        if (prio != OS_PRIO_SELF) {
 201d70c:	e0bffd03 	ldbu	r2,-12(fp)
 201d710:	10803fe0 	cmpeqi	r2,r2,255
 201d714:	1000041e 	bne	r2,zero,201d728 <OSTaskNameSet+0x54>
            *perr = OS_ERR_PRIO_INVALID;             /* No                                             */
 201d718:	e0bfff17 	ldw	r2,-4(fp)
 201d71c:	00c00a84 	movi	r3,42
 201d720:	10c00005 	stb	r3,0(r2)
            return;
 201d724:	00005706 	br	201d884 <OSTaskNameSet+0x1b0>
        }
    }
    if (pname == (INT8U *)0) {                       /* Is 'pname' a NULL pointer?                     */
 201d728:	e0bffe17 	ldw	r2,-8(fp)
 201d72c:	1000041e 	bne	r2,zero,201d740 <OSTaskNameSet+0x6c>
        *perr = OS_ERR_PNAME_NULL;                   /* Yes                                            */
 201d730:	e0bfff17 	ldw	r2,-4(fp)
 201d734:	00c00304 	movi	r3,12
 201d738:	10c00005 	stb	r3,0(r2)
        return;
 201d73c:	00005106 	br	201d884 <OSTaskNameSet+0x1b0>
    }
#endif
    if (OSIntNesting > 0) {                          /* See if trying to call from an ISR              */
 201d740:	00808174 	movhi	r2,517
 201d744:	1090a904 	addi	r2,r2,17060
 201d748:	10800003 	ldbu	r2,0(r2)
 201d74c:	10803fcc 	andi	r2,r2,255
 201d750:	10000426 	beq	r2,zero,201d764 <OSTaskNameSet+0x90>
        *perr = OS_ERR_NAME_SET_ISR;
 201d754:	e0bfff17 	ldw	r2,-4(fp)
 201d758:	00c00484 	movi	r3,18
 201d75c:	10c00005 	stb	r3,0(r2)
        return;
 201d760:	00004806 	br	201d884 <OSTaskNameSet+0x1b0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d764:	0005303a 	rdctl	r2,status
 201d768:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d76c:	e0fff817 	ldw	r3,-32(fp)
 201d770:	00bfff84 	movi	r2,-2
 201d774:	1884703a 	and	r2,r3,r2
 201d778:	1001703a 	wrctl	status,r2
  
  return context;
 201d77c:	e0bff817 	ldw	r2,-32(fp)
    }
    OS_ENTER_CRITICAL();
 201d780:	e0bff515 	stw	r2,-44(fp)
    if (prio == OS_PRIO_SELF) {                      /* See if caller desires to set it's own name     */
 201d784:	e0bffd03 	ldbu	r2,-12(fp)
 201d788:	10803fd8 	cmpnei	r2,r2,255
 201d78c:	1000051e 	bne	r2,zero,201d7a4 <OSTaskNameSet+0xd0>
        prio = OSTCBCur->OSTCBPrio;
 201d790:	00808174 	movhi	r2,517
 201d794:	1090aa04 	addi	r2,r2,17064
 201d798:	10800017 	ldw	r2,0(r2)
 201d79c:	10800c83 	ldbu	r2,50(r2)
 201d7a0:	e0bffd05 	stb	r2,-12(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201d7a4:	e0bffd03 	ldbu	r2,-12(fp)
 201d7a8:	00c09934 	movhi	r3,612
 201d7ac:	18f45704 	addi	r3,r3,-11940
 201d7b0:	1085883a 	add	r2,r2,r2
 201d7b4:	1085883a 	add	r2,r2,r2
 201d7b8:	1885883a 	add	r2,r3,r2
 201d7bc:	10800017 	ldw	r2,0(r2)
 201d7c0:	e0bff615 	stw	r2,-40(fp)
    if (ptcb == (OS_TCB *)0) {                       /* Does task exist?                               */
 201d7c4:	e0bff617 	ldw	r2,-40(fp)
 201d7c8:	1000081e 	bne	r2,zero,201d7ec <OSTaskNameSet+0x118>
 201d7cc:	e0bff517 	ldw	r2,-44(fp)
 201d7d0:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d7d4:	e0bff917 	ldw	r2,-28(fp)
 201d7d8:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* No                                             */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201d7dc:	e0bfff17 	ldw	r2,-4(fp)
 201d7e0:	00c010c4 	movi	r3,67
 201d7e4:	10c00005 	stb	r3,0(r2)
        return;
 201d7e8:	00002606 	br	201d884 <OSTaskNameSet+0x1b0>
    }
    if (ptcb == OS_TCB_RESERVED) {                   /* Task assigned to a Mutex?                      */
 201d7ec:	e0bff617 	ldw	r2,-40(fp)
 201d7f0:	10800058 	cmpnei	r2,r2,1
 201d7f4:	1000081e 	bne	r2,zero,201d818 <OSTaskNameSet+0x144>
 201d7f8:	e0bff517 	ldw	r2,-44(fp)
 201d7fc:	e0bffa15 	stw	r2,-24(fp)
 201d800:	e0bffa17 	ldw	r2,-24(fp)
 201d804:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();                          /* Yes                                            */
        *perr = OS_ERR_TASK_NOT_EXIST;
 201d808:	e0bfff17 	ldw	r2,-4(fp)
 201d80c:	00c010c4 	movi	r3,67
 201d810:	10c00005 	stb	r3,0(r2)
        return;
 201d814:	00001b06 	br	201d884 <OSTaskNameSet+0x1b0>
    }
    len = OS_StrLen(pname);                          /* Yes, Can we fit the string in the TCB?         */
 201d818:	e13ffe17 	ldw	r4,-8(fp)
 201d81c:	20177e00 	call	20177e0 <OS_StrLen>
 201d820:	e0bff705 	stb	r2,-36(fp)
    if (len > (OS_TASK_NAME_SIZE - 1)) {             /*      No                                        */
 201d824:	e0bff703 	ldbu	r2,-36(fp)
 201d828:	10800830 	cmpltui	r2,r2,32
 201d82c:	1000081e 	bne	r2,zero,201d850 <OSTaskNameSet+0x17c>
 201d830:	e0bff517 	ldw	r2,-44(fp)
 201d834:	e0bffb15 	stw	r2,-20(fp)
 201d838:	e0bffb17 	ldw	r2,-20(fp)
 201d83c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        *perr = OS_ERR_TASK_NAME_TOO_LONG;
 201d840:	e0bfff17 	ldw	r2,-4(fp)
 201d844:	00c01044 	movi	r3,65
 201d848:	10c00005 	stb	r3,0(r2)
        return;
 201d84c:	00000d06 	br	201d884 <OSTaskNameSet+0x1b0>
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
 201d850:	e0bff617 	ldw	r2,-40(fp)
 201d854:	10801304 	addi	r2,r2,76
 201d858:	1009883a 	mov	r4,r2
 201d85c:	e17ffe17 	ldw	r5,-8(fp)
 201d860:	20177640 	call	2017764 <OS_StrCopy>
 201d864:	e0bff517 	ldw	r2,-44(fp)
 201d868:	e0bffc15 	stw	r2,-16(fp)
 201d86c:	e0bffc17 	ldw	r2,-16(fp)
 201d870:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
 201d874:	e0bfff17 	ldw	r2,-4(fp)
 201d878:	10000005 	stb	zero,0(r2)
 201d87c:	00000106 	br	201d884 <OSTaskNameSet+0x1b0>



#if OS_ARG_CHK_EN > 0
    if (perr == (INT8U *)0) {                        /* Validate 'perr'                                */
        return;
 201d880:	0001883a 	nop
        return;
    }
    (void)OS_StrCopy(ptcb->OSTCBTaskName, pname);    /*      Yes, copy to TCB                          */
    OS_EXIT_CRITICAL();
    *perr = OS_ERR_NONE;
}
 201d884:	e037883a 	mov	sp,fp
 201d888:	dfc00117 	ldw	ra,4(sp)
 201d88c:	df000017 	ldw	fp,0(sp)
 201d890:	dec00204 	addi	sp,sp,8
 201d894:	f800283a 	ret

0201d898 <OSTaskResume>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskResume (INT8U prio)
{
 201d898:	defff404 	addi	sp,sp,-48
 201d89c:	dfc00b15 	stw	ra,44(sp)
 201d8a0:	df000a15 	stw	fp,40(sp)
 201d8a4:	df000a04 	addi	fp,sp,40
 201d8a8:	2005883a 	mov	r2,r4
 201d8ac:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                   /* Storage for CPU status register       */
    OS_CPU_SR  cpu_sr = 0;
 201d8b0:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio >= OS_LOWEST_PRIO) {                             /* Make sure task priority is valid      */
 201d8b4:	e0bfff03 	ldbu	r2,-4(fp)
 201d8b8:	10800530 	cmpltui	r2,r2,20
 201d8bc:	1000021e 	bne	r2,zero,201d8c8 <OSTaskResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 201d8c0:	00800a84 	movi	r2,42
 201d8c4:	00006c06 	br	201da78 <OSTaskResume+0x1e0>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201d8c8:	0005303a 	rdctl	r2,status
 201d8cc:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201d8d0:	e0fff817 	ldw	r3,-32(fp)
 201d8d4:	00bfff84 	movi	r2,-2
 201d8d8:	1884703a 	and	r2,r3,r2
 201d8dc:	1001703a 	wrctl	status,r2
  
  return context;
 201d8e0:	e0bff817 	ldw	r2,-32(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201d8e4:	e0bff615 	stw	r2,-40(fp)
    ptcb = OSTCBPrioTbl[prio];
 201d8e8:	e0bfff03 	ldbu	r2,-4(fp)
 201d8ec:	00c09934 	movhi	r3,612
 201d8f0:	18f45704 	addi	r3,r3,-11940
 201d8f4:	1085883a 	add	r2,r2,r2
 201d8f8:	1085883a 	add	r2,r2,r2
 201d8fc:	1885883a 	add	r2,r3,r2
 201d900:	10800017 	ldw	r2,0(r2)
 201d904:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                                /* Task to suspend must exist            */
 201d908:	e0bff717 	ldw	r2,-36(fp)
 201d90c:	1000061e 	bne	r2,zero,201d928 <OSTaskResume+0x90>
 201d910:	e0bff617 	ldw	r2,-40(fp)
 201d914:	e0bff915 	stw	r2,-28(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201d918:	e0bff917 	ldw	r2,-28(fp)
 201d91c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_RESUME_PRIO);
 201d920:	00801184 	movi	r2,70
 201d924:	00005406 	br	201da78 <OSTaskResume+0x1e0>
    }
    if (ptcb == OS_TCB_RESERVED) {                            /* See if assigned to Mutex              */
 201d928:	e0bff717 	ldw	r2,-36(fp)
 201d92c:	10800058 	cmpnei	r2,r2,1
 201d930:	1000061e 	bne	r2,zero,201d94c <OSTaskResume+0xb4>
 201d934:	e0bff617 	ldw	r2,-40(fp)
 201d938:	e0bffa15 	stw	r2,-24(fp)
 201d93c:	e0bffa17 	ldw	r2,-24(fp)
 201d940:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201d944:	008010c4 	movi	r2,67
 201d948:	00004b06 	br	201da78 <OSTaskResume+0x1e0>
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) != OS_STAT_RDY) { /* Task must be suspended                */
 201d94c:	e0bff717 	ldw	r2,-36(fp)
 201d950:	10800c03 	ldbu	r2,48(r2)
 201d954:	10803fcc 	andi	r2,r2,255
 201d958:	1080020c 	andi	r2,r2,8
 201d95c:	10004126 	beq	r2,zero,201da64 <OSTaskResume+0x1cc>
        ptcb->OSTCBStat &= ~(INT8U)OS_STAT_SUSPEND;           /* Remove suspension                     */
 201d960:	e0bff717 	ldw	r2,-36(fp)
 201d964:	10c00c03 	ldbu	r3,48(r2)
 201d968:	00bffdc4 	movi	r2,-9
 201d96c:	1884703a 	and	r2,r3,r2
 201d970:	1007883a 	mov	r3,r2
 201d974:	e0bff717 	ldw	r2,-36(fp)
 201d978:	10c00c05 	stb	r3,48(r2)
        if (ptcb->OSTCBStat == OS_STAT_RDY) {                 /* See if task is now ready              */
 201d97c:	e0bff717 	ldw	r2,-36(fp)
 201d980:	10800c03 	ldbu	r2,48(r2)
 201d984:	10803fcc 	andi	r2,r2,255
 201d988:	1000301e 	bne	r2,zero,201da4c <OSTaskResume+0x1b4>
            if (ptcb->OSTCBDly == 0) {
 201d98c:	e0bff717 	ldw	r2,-36(fp)
 201d990:	10800b8b 	ldhu	r2,46(r2)
 201d994:	10bfffcc 	andi	r2,r2,65535
 201d998:	1000271e 	bne	r2,zero,201da38 <OSTaskResume+0x1a0>
                OSRdyGrp               |= ptcb->OSTCBBitY;    /* Yes, Make task ready to run           */
 201d99c:	e0bff717 	ldw	r2,-36(fp)
 201d9a0:	10c00d83 	ldbu	r3,54(r2)
 201d9a4:	00808174 	movhi	r2,517
 201d9a8:	1090a704 	addi	r2,r2,17052
 201d9ac:	10800003 	ldbu	r2,0(r2)
 201d9b0:	1884b03a 	or	r2,r3,r2
 201d9b4:	1007883a 	mov	r3,r2
 201d9b8:	00808174 	movhi	r2,517
 201d9bc:	1090a704 	addi	r2,r2,17052
 201d9c0:	10c00005 	stb	r3,0(r2)
                OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 201d9c4:	e0bff717 	ldw	r2,-36(fp)
 201d9c8:	10800d03 	ldbu	r2,52(r2)
 201d9cc:	10803fcc 	andi	r2,r2,255
 201d9d0:	e0fff717 	ldw	r3,-36(fp)
 201d9d4:	18c00d03 	ldbu	r3,52(r3)
 201d9d8:	18c03fcc 	andi	r3,r3,255
 201d9dc:	01008174 	movhi	r4,517
 201d9e0:	2110a744 	addi	r4,r4,17053
 201d9e4:	20c7883a 	add	r3,r4,r3
 201d9e8:	19000003 	ldbu	r4,0(r3)
 201d9ec:	e0fff717 	ldw	r3,-36(fp)
 201d9f0:	18c00d43 	ldbu	r3,53(r3)
 201d9f4:	20c6b03a 	or	r3,r4,r3
 201d9f8:	01008174 	movhi	r4,517
 201d9fc:	2110a744 	addi	r4,r4,17053
 201da00:	2085883a 	add	r2,r4,r2
 201da04:	10c00005 	stb	r3,0(r2)
 201da08:	e0bff617 	ldw	r2,-40(fp)
 201da0c:	e0bffb15 	stw	r2,-20(fp)
 201da10:	e0bffb17 	ldw	r2,-20(fp)
 201da14:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
                if (OSRunning == OS_TRUE) {
 201da18:	00808174 	movhi	r2,517
 201da1c:	10909b44 	addi	r2,r2,17005
 201da20:	10800003 	ldbu	r2,0(r2)
 201da24:	10803fcc 	andi	r2,r2,255
 201da28:	10800058 	cmpnei	r2,r2,1
 201da2c:	10000b1e 	bne	r2,zero,201da5c <OSTaskResume+0x1c4>
                    OS_Sched();                               /* Find new highest priority task        */
 201da30:	20176280 	call	2017628 <OS_Sched>
 201da34:	00000906 	br	201da5c <OSTaskResume+0x1c4>
 201da38:	e0bff617 	ldw	r2,-40(fp)
 201da3c:	e0bffc15 	stw	r2,-16(fp)
 201da40:	e0bffc17 	ldw	r2,-16(fp)
 201da44:	1001703a 	wrctl	status,r2
 201da48:	00000406 	br	201da5c <OSTaskResume+0x1c4>
 201da4c:	e0bff617 	ldw	r2,-40(fp)
 201da50:	e0bffd15 	stw	r2,-12(fp)
 201da54:	e0bffd17 	ldw	r2,-12(fp)
 201da58:	1001703a 	wrctl	status,r2
                OS_EXIT_CRITICAL();
            }
        } else {                                              /* Must be pending on event              */
            OS_EXIT_CRITICAL();
        }
        return (OS_ERR_NONE);
 201da5c:	0005883a 	mov	r2,zero
 201da60:	00000506 	br	201da78 <OSTaskResume+0x1e0>
 201da64:	e0bff617 	ldw	r2,-40(fp)
 201da68:	e0bffe15 	stw	r2,-8(fp)
 201da6c:	e0bffe17 	ldw	r2,-8(fp)
 201da70:	1001703a 	wrctl	status,r2
    }
    OS_EXIT_CRITICAL();
    return (OS_ERR_TASK_NOT_SUSPENDED);
 201da74:	00801104 	movi	r2,68
}
 201da78:	e037883a 	mov	sp,fp
 201da7c:	dfc00117 	ldw	ra,4(sp)
 201da80:	df000017 	ldw	fp,0(sp)
 201da84:	dec00204 	addi	sp,sp,8
 201da88:	f800283a 	ret

0201da8c <OSTaskStkChk>:
*              OS_ERR_PDATA_NULL      if 'p_stk_data' is a NULL pointer
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
INT8U  OSTaskStkChk (INT8U prio, OS_STK_DATA *p_stk_data)
{
 201da8c:	defff304 	addi	sp,sp,-52
 201da90:	df000c15 	stw	fp,48(sp)
 201da94:	df000c04 	addi	fp,sp,48
 201da98:	2005883a 	mov	r2,r4
 201da9c:	e17fff15 	stw	r5,-4(fp)
 201daa0:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
    OS_STK    *pchk;
    INT32U     nfree;
    INT32U     size;
#if OS_CRITICAL_METHOD == 3                            /* Allocate storage for CPU status register     */
    OS_CPU_SR  cpu_sr = 0;
 201daa4:	e03ff615 	stw	zero,-40(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                       /* Make sure task priority is valid             */
 201daa8:	e0bffe03 	ldbu	r2,-8(fp)
 201daac:	10800570 	cmpltui	r2,r2,21
 201dab0:	1000051e 	bne	r2,zero,201dac8 <OSTaskStkChk+0x3c>
        if (prio != OS_PRIO_SELF) {
 201dab4:	e0bffe03 	ldbu	r2,-8(fp)
 201dab8:	10803fe0 	cmpeqi	r2,r2,255
 201dabc:	1000021e 	bne	r2,zero,201dac8 <OSTaskStkChk+0x3c>
            return (OS_ERR_PRIO_INVALID);
 201dac0:	00800a84 	movi	r2,42
 201dac4:	00006206 	br	201dc50 <OSTaskStkChk+0x1c4>
        }
    }
    if (p_stk_data == (OS_STK_DATA *)0) {              /* Validate 'p_stk_data'                        */
 201dac8:	e0bfff17 	ldw	r2,-4(fp)
 201dacc:	1000021e 	bne	r2,zero,201dad8 <OSTaskStkChk+0x4c>
        return (OS_ERR_PDATA_NULL);
 201dad0:	00800244 	movi	r2,9
 201dad4:	00005e06 	br	201dc50 <OSTaskStkChk+0x1c4>
    }
#endif
    p_stk_data->OSFree = 0;                            /* Assume failure, set to 0 size                */
 201dad8:	e0bfff17 	ldw	r2,-4(fp)
 201dadc:	10000015 	stw	zero,0(r2)
    p_stk_data->OSUsed = 0;
 201dae0:	e0bfff17 	ldw	r2,-4(fp)
 201dae4:	10000115 	stw	zero,4(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201dae8:	0005303a 	rdctl	r2,status
 201daec:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201daf0:	e0fff917 	ldw	r3,-28(fp)
 201daf4:	00bfff84 	movi	r2,-2
 201daf8:	1884703a 	and	r2,r3,r2
 201dafc:	1001703a 	wrctl	status,r2
  
  return context;
 201db00:	e0bff917 	ldw	r2,-28(fp)
    OS_ENTER_CRITICAL();
 201db04:	e0bff615 	stw	r2,-40(fp)
    if (prio == OS_PRIO_SELF) {                        /* See if check for SELF                        */
 201db08:	e0bffe03 	ldbu	r2,-8(fp)
 201db0c:	10803fd8 	cmpnei	r2,r2,255
 201db10:	1000051e 	bne	r2,zero,201db28 <OSTaskStkChk+0x9c>
        prio = OSTCBCur->OSTCBPrio;
 201db14:	00808174 	movhi	r2,517
 201db18:	1090aa04 	addi	r2,r2,17064
 201db1c:	10800017 	ldw	r2,0(r2)
 201db20:	10800c83 	ldbu	r2,50(r2)
 201db24:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201db28:	e0bffe03 	ldbu	r2,-8(fp)
 201db2c:	00c09934 	movhi	r3,612
 201db30:	18f45704 	addi	r3,r3,-11940
 201db34:	1085883a 	add	r2,r2,r2
 201db38:	1085883a 	add	r2,r2,r2
 201db3c:	1885883a 	add	r2,r3,r2
 201db40:	10800017 	ldw	r2,0(r2)
 201db44:	e0bff715 	stw	r2,-36(fp)
    if (ptcb == (OS_TCB *)0) {                         /* Make sure task exist                         */
 201db48:	e0bff717 	ldw	r2,-36(fp)
 201db4c:	1000061e 	bne	r2,zero,201db68 <OSTaskStkChk+0xdc>
 201db50:	e0bff617 	ldw	r2,-40(fp)
 201db54:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201db58:	e0bffa17 	ldw	r2,-24(fp)
 201db5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201db60:	008010c4 	movi	r2,67
 201db64:	00003a06 	br	201dc50 <OSTaskStkChk+0x1c4>
    }
    if (ptcb == OS_TCB_RESERVED) {
 201db68:	e0bff717 	ldw	r2,-36(fp)
 201db6c:	10800058 	cmpnei	r2,r2,1
 201db70:	1000061e 	bne	r2,zero,201db8c <OSTaskStkChk+0x100>
 201db74:	e0bff617 	ldw	r2,-40(fp)
 201db78:	e0bffb15 	stw	r2,-20(fp)
 201db7c:	e0bffb17 	ldw	r2,-20(fp)
 201db80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201db84:	008010c4 	movi	r2,67
 201db88:	00003106 	br	201dc50 <OSTaskStkChk+0x1c4>
    }
    if ((ptcb->OSTCBOpt & OS_TASK_OPT_STK_CHK) == 0) { /* Make sure stack checking option is set       */
 201db8c:	e0bff717 	ldw	r2,-36(fp)
 201db90:	1080040b 	ldhu	r2,16(r2)
 201db94:	10bfffcc 	andi	r2,r2,65535
 201db98:	1080004c 	andi	r2,r2,1
 201db9c:	1000061e 	bne	r2,zero,201dbb8 <OSTaskStkChk+0x12c>
 201dba0:	e0bff617 	ldw	r2,-40(fp)
 201dba4:	e0bffc15 	stw	r2,-16(fp)
 201dba8:	e0bffc17 	ldw	r2,-16(fp)
 201dbac:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_OPT);
 201dbb0:	00801144 	movi	r2,69
 201dbb4:	00002606 	br	201dc50 <OSTaskStkChk+0x1c4>
    }
    nfree = 0;
 201dbb8:	e03ff515 	stw	zero,-44(fp)
    size  = ptcb->OSTCBStkSize;
 201dbbc:	e0bff717 	ldw	r2,-36(fp)
 201dbc0:	10800317 	ldw	r2,12(r2)
 201dbc4:	e0bff815 	stw	r2,-32(fp)
    pchk  = ptcb->OSTCBStkBottom;
 201dbc8:	e0bff717 	ldw	r2,-36(fp)
 201dbcc:	10800217 	ldw	r2,8(r2)
 201dbd0:	e0bff415 	stw	r2,-48(fp)
 201dbd4:	e0bff617 	ldw	r2,-40(fp)
 201dbd8:	e0bffd15 	stw	r2,-12(fp)
 201dbdc:	e0bffd17 	ldw	r2,-12(fp)
 201dbe0:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 201dbe4:	00000306 	br	201dbf4 <OSTaskStkChk+0x168>
        nfree++;
 201dbe8:	e0bff517 	ldw	r2,-44(fp)
 201dbec:	10800044 	addi	r2,r2,1
 201dbf0:	e0bff515 	stw	r2,-44(fp)
    nfree = 0;
    size  = ptcb->OSTCBStkSize;
    pchk  = ptcb->OSTCBStkBottom;
    OS_EXIT_CRITICAL();
#if OS_STK_GROWTH == 1
    while (*pchk++ == (OS_STK)0) {                    /* Compute the number of zero entries on the stk */
 201dbf4:	e0bff417 	ldw	r2,-48(fp)
 201dbf8:	10800017 	ldw	r2,0(r2)
 201dbfc:	1005003a 	cmpeq	r2,r2,zero
 201dc00:	e0fff417 	ldw	r3,-48(fp)
 201dc04:	18c00104 	addi	r3,r3,4
 201dc08:	e0fff415 	stw	r3,-48(fp)
 201dc0c:	10803fcc 	andi	r2,r2,255
 201dc10:	103ff51e 	bne	r2,zero,201dbe8 <OSTaskStkChk+0x15c>
#else
    while (*pchk-- == (OS_STK)0) {
        nfree++;
    }
#endif
    p_stk_data->OSFree = nfree * sizeof(OS_STK);          /* Compute number of free bytes on the stack */
 201dc14:	e0bff517 	ldw	r2,-44(fp)
 201dc18:	1085883a 	add	r2,r2,r2
 201dc1c:	1085883a 	add	r2,r2,r2
 201dc20:	1007883a 	mov	r3,r2
 201dc24:	e0bfff17 	ldw	r2,-4(fp)
 201dc28:	10c00015 	stw	r3,0(r2)
    p_stk_data->OSUsed = (size - nfree) * sizeof(OS_STK); /* Compute number of bytes used on the stack */
 201dc2c:	e0fff817 	ldw	r3,-32(fp)
 201dc30:	e0bff517 	ldw	r2,-44(fp)
 201dc34:	1885c83a 	sub	r2,r3,r2
 201dc38:	1085883a 	add	r2,r2,r2
 201dc3c:	1085883a 	add	r2,r2,r2
 201dc40:	1007883a 	mov	r3,r2
 201dc44:	e0bfff17 	ldw	r2,-4(fp)
 201dc48:	10c00115 	stw	r3,4(r2)
    return (OS_ERR_NONE);
 201dc4c:	0005883a 	mov	r2,zero
}
 201dc50:	e037883a 	mov	sp,fp
 201dc54:	df000017 	ldw	fp,0(sp)
 201dc58:	dec00104 	addi	sp,sp,4
 201dc5c:	f800283a 	ret

0201dc60 <OSTaskSuspend>:
*********************************************************************************************************
*/

#if OS_TASK_SUSPEND_EN > 0
INT8U  OSTaskSuspend (INT8U prio)
{
 201dc60:	defff504 	addi	sp,sp,-44
 201dc64:	dfc00a15 	stw	ra,40(sp)
 201dc68:	df000915 	stw	fp,36(sp)
 201dc6c:	df000904 	addi	fp,sp,36
 201dc70:	2005883a 	mov	r2,r4
 201dc74:	e0bfff05 	stb	r2,-4(fp)
    BOOLEAN    self;
    OS_TCB    *ptcb;
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201dc78:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio == OS_TASK_IDLE_PRIO) {                            /* Not allowed to suspend idle task    */
 201dc7c:	e0bfff03 	ldbu	r2,-4(fp)
 201dc80:	10800518 	cmpnei	r2,r2,20
 201dc84:	1000021e 	bne	r2,zero,201dc90 <OSTaskSuspend+0x30>
        return (OS_ERR_TASK_SUSPEND_IDLE);
 201dc88:	008011c4 	movi	r2,71
 201dc8c:	00007306 	br	201de5c <OSTaskSuspend+0x1fc>
    }
    if (prio >= OS_LOWEST_PRIO) {                               /* Task priority valid ?               */
 201dc90:	e0bfff03 	ldbu	r2,-4(fp)
 201dc94:	10800530 	cmpltui	r2,r2,20
 201dc98:	1000051e 	bne	r2,zero,201dcb0 <OSTaskSuspend+0x50>
        if (prio != OS_PRIO_SELF) {
 201dc9c:	e0bfff03 	ldbu	r2,-4(fp)
 201dca0:	10803fe0 	cmpeqi	r2,r2,255
 201dca4:	1000021e 	bne	r2,zero,201dcb0 <OSTaskSuspend+0x50>
            return (OS_ERR_PRIO_INVALID);
 201dca8:	00800a84 	movi	r2,42
 201dcac:	00006b06 	br	201de5c <OSTaskSuspend+0x1fc>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201dcb0:	0005303a 	rdctl	r2,status
 201dcb4:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201dcb8:	e0fffb17 	ldw	r3,-20(fp)
 201dcbc:	00bfff84 	movi	r2,-2
 201dcc0:	1884703a 	and	r2,r3,r2
 201dcc4:	1001703a 	wrctl	status,r2
  
  return context;
 201dcc8:	e0bffb17 	ldw	r2,-20(fp)
        }
    }
#endif
    OS_ENTER_CRITICAL();
 201dccc:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                                 /* See if suspend SELF                 */
 201dcd0:	e0bfff03 	ldbu	r2,-4(fp)
 201dcd4:	10803fd8 	cmpnei	r2,r2,255
 201dcd8:	1000081e 	bne	r2,zero,201dcfc <OSTaskSuspend+0x9c>
        prio = OSTCBCur->OSTCBPrio;
 201dcdc:	00808174 	movhi	r2,517
 201dce0:	1090aa04 	addi	r2,r2,17064
 201dce4:	10800017 	ldw	r2,0(r2)
 201dce8:	10800c83 	ldbu	r2,50(r2)
 201dcec:	e0bfff05 	stb	r2,-4(fp)
        self = OS_TRUE;
 201dcf0:	00800044 	movi	r2,1
 201dcf4:	e0bff705 	stb	r2,-36(fp)
 201dcf8:	00000b06 	br	201dd28 <OSTaskSuspend+0xc8>
    } else if (prio == OSTCBCur->OSTCBPrio) {                   /* See if suspending self              */
 201dcfc:	00808174 	movhi	r2,517
 201dd00:	1090aa04 	addi	r2,r2,17064
 201dd04:	10800017 	ldw	r2,0(r2)
 201dd08:	10800c83 	ldbu	r2,50(r2)
 201dd0c:	10c03fcc 	andi	r3,r2,255
 201dd10:	e0bfff03 	ldbu	r2,-4(fp)
 201dd14:	1880031e 	bne	r3,r2,201dd24 <OSTaskSuspend+0xc4>
        self = OS_TRUE;
 201dd18:	00800044 	movi	r2,1
 201dd1c:	e0bff705 	stb	r2,-36(fp)
 201dd20:	00000106 	br	201dd28 <OSTaskSuspend+0xc8>
    } else {
        self = OS_FALSE;                                        /* No suspending another task          */
 201dd24:	e03ff705 	stb	zero,-36(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201dd28:	e0bfff03 	ldbu	r2,-4(fp)
 201dd2c:	00c09934 	movhi	r3,612
 201dd30:	18f45704 	addi	r3,r3,-11940
 201dd34:	1085883a 	add	r2,r2,r2
 201dd38:	1085883a 	add	r2,r2,r2
 201dd3c:	1885883a 	add	r2,r3,r2
 201dd40:	10800017 	ldw	r2,0(r2)
 201dd44:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {                                  /* Task to suspend must exist          */
 201dd48:	e0bff917 	ldw	r2,-28(fp)
 201dd4c:	1000061e 	bne	r2,zero,201dd68 <OSTaskSuspend+0x108>
 201dd50:	e0bff817 	ldw	r2,-32(fp)
 201dd54:	e0bffc15 	stw	r2,-16(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201dd58:	e0bffc17 	ldw	r2,-16(fp)
 201dd5c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_SUSPEND_PRIO);
 201dd60:	00801204 	movi	r2,72
 201dd64:	00003d06 	br	201de5c <OSTaskSuspend+0x1fc>
    }
    if (ptcb == OS_TCB_RESERVED) {                              /* See if assigned to Mutex            */
 201dd68:	e0bff917 	ldw	r2,-28(fp)
 201dd6c:	10800058 	cmpnei	r2,r2,1
 201dd70:	1000061e 	bne	r2,zero,201dd8c <OSTaskSuspend+0x12c>
 201dd74:	e0bff817 	ldw	r2,-32(fp)
 201dd78:	e0bffd15 	stw	r2,-12(fp)
 201dd7c:	e0bffd17 	ldw	r2,-12(fp)
 201dd80:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201dd84:	008010c4 	movi	r2,67
 201dd88:	00003406 	br	201de5c <OSTaskSuspend+0x1fc>
    }
    y            = ptcb->OSTCBY;
 201dd8c:	e0bff917 	ldw	r2,-28(fp)
 201dd90:	10800d03 	ldbu	r2,52(r2)
 201dd94:	e0bffa05 	stb	r2,-24(fp)
    OSRdyTbl[y] &= ~ptcb->OSTCBBitX;                            /* Make task not ready                 */
 201dd98:	e0bffa03 	ldbu	r2,-24(fp)
 201dd9c:	e0fffa03 	ldbu	r3,-24(fp)
 201dda0:	01008174 	movhi	r4,517
 201dda4:	2110a744 	addi	r4,r4,17053
 201dda8:	20c7883a 	add	r3,r4,r3
 201ddac:	18c00003 	ldbu	r3,0(r3)
 201ddb0:	1809883a 	mov	r4,r3
 201ddb4:	e0fff917 	ldw	r3,-28(fp)
 201ddb8:	18c00d43 	ldbu	r3,53(r3)
 201ddbc:	00c6303a 	nor	r3,zero,r3
 201ddc0:	20c6703a 	and	r3,r4,r3
 201ddc4:	01008174 	movhi	r4,517
 201ddc8:	2110a744 	addi	r4,r4,17053
 201ddcc:	2085883a 	add	r2,r4,r2
 201ddd0:	10c00005 	stb	r3,0(r2)
    if (OSRdyTbl[y] == 0) {
 201ddd4:	e0bffa03 	ldbu	r2,-24(fp)
 201ddd8:	00c08174 	movhi	r3,517
 201dddc:	18d0a744 	addi	r3,r3,17053
 201dde0:	1885883a 	add	r2,r3,r2
 201dde4:	10800003 	ldbu	r2,0(r2)
 201dde8:	10803fcc 	andi	r2,r2,255
 201ddec:	10000c1e 	bne	r2,zero,201de20 <OSTaskSuspend+0x1c0>
        OSRdyGrp &= ~ptcb->OSTCBBitY;
 201ddf0:	e0bff917 	ldw	r2,-28(fp)
 201ddf4:	10800d83 	ldbu	r2,54(r2)
 201ddf8:	0084303a 	nor	r2,zero,r2
 201ddfc:	1007883a 	mov	r3,r2
 201de00:	00808174 	movhi	r2,517
 201de04:	1090a704 	addi	r2,r2,17052
 201de08:	10800003 	ldbu	r2,0(r2)
 201de0c:	1884703a 	and	r2,r3,r2
 201de10:	1007883a 	mov	r3,r2
 201de14:	00808174 	movhi	r2,517
 201de18:	1090a704 	addi	r2,r2,17052
 201de1c:	10c00005 	stb	r3,0(r2)
    }
    ptcb->OSTCBStat |= OS_STAT_SUSPEND;                         /* Status of task is 'SUSPENDED'       */
 201de20:	e0bff917 	ldw	r2,-28(fp)
 201de24:	10800c03 	ldbu	r2,48(r2)
 201de28:	10800214 	ori	r2,r2,8
 201de2c:	1007883a 	mov	r3,r2
 201de30:	e0bff917 	ldw	r2,-28(fp)
 201de34:	10c00c05 	stb	r3,48(r2)
 201de38:	e0bff817 	ldw	r2,-32(fp)
 201de3c:	e0bffe15 	stw	r2,-8(fp)
 201de40:	e0bffe17 	ldw	r2,-8(fp)
 201de44:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    if (self == OS_TRUE) {                                      /* Context switch only if SELF         */
 201de48:	e0bff703 	ldbu	r2,-36(fp)
 201de4c:	10800058 	cmpnei	r2,r2,1
 201de50:	1000011e 	bne	r2,zero,201de58 <OSTaskSuspend+0x1f8>
        OS_Sched();                                             /* Find new highest priority task      */
 201de54:	20176280 	call	2017628 <OS_Sched>
    }
    return (OS_ERR_NONE);
 201de58:	0005883a 	mov	r2,zero
}
 201de5c:	e037883a 	mov	sp,fp
 201de60:	dfc00117 	ldw	ra,4(sp)
 201de64:	df000017 	ldw	fp,0(sp)
 201de68:	dec00204 	addi	sp,sp,8
 201de6c:	f800283a 	ret

0201de70 <OSTaskQuery>:
*********************************************************************************************************
*/

#if OS_TASK_QUERY_EN > 0
INT8U  OSTaskQuery (INT8U prio, OS_TCB *p_task_data)
{
 201de70:	defff604 	addi	sp,sp,-40
 201de74:	dfc00915 	stw	ra,36(sp)
 201de78:	df000815 	stw	fp,32(sp)
 201de7c:	df000804 	addi	fp,sp,32
 201de80:	2005883a 	mov	r2,r4
 201de84:	e17fff15 	stw	r5,-4(fp)
 201de88:	e0bffe05 	stb	r2,-8(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201de8c:	e03ff815 	stw	zero,-32(fp)
#endif



#if OS_ARG_CHK_EN > 0
    if (prio > OS_LOWEST_PRIO) {                 /* Task priority valid ?                              */
 201de90:	e0bffe03 	ldbu	r2,-8(fp)
 201de94:	10800570 	cmpltui	r2,r2,21
 201de98:	1000051e 	bne	r2,zero,201deb0 <OSTaskQuery+0x40>
        if (prio != OS_PRIO_SELF) {
 201de9c:	e0bffe03 	ldbu	r2,-8(fp)
 201dea0:	10803fe0 	cmpeqi	r2,r2,255
 201dea4:	1000021e 	bne	r2,zero,201deb0 <OSTaskQuery+0x40>
            return (OS_ERR_PRIO_INVALID);
 201dea8:	00800a84 	movi	r2,42
 201deac:	00003606 	br	201df88 <OSTaskQuery+0x118>
        }
    }
    if (p_task_data == (OS_TCB *)0) {            /* Validate 'p_task_data'                             */
 201deb0:	e0bfff17 	ldw	r2,-4(fp)
 201deb4:	1000021e 	bne	r2,zero,201dec0 <OSTaskQuery+0x50>
        return (OS_ERR_PDATA_NULL);
 201deb8:	00800244 	movi	r2,9
 201debc:	00003206 	br	201df88 <OSTaskQuery+0x118>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201dec0:	0005303a 	rdctl	r2,status
 201dec4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201dec8:	e0fffa17 	ldw	r3,-24(fp)
 201decc:	00bfff84 	movi	r2,-2
 201ded0:	1884703a 	and	r2,r3,r2
 201ded4:	1001703a 	wrctl	status,r2
  
  return context;
 201ded8:	e0bffa17 	ldw	r2,-24(fp)
    }
#endif
    OS_ENTER_CRITICAL();
 201dedc:	e0bff815 	stw	r2,-32(fp)
    if (prio == OS_PRIO_SELF) {                  /* See if suspend SELF                                */
 201dee0:	e0bffe03 	ldbu	r2,-8(fp)
 201dee4:	10803fd8 	cmpnei	r2,r2,255
 201dee8:	1000051e 	bne	r2,zero,201df00 <OSTaskQuery+0x90>
        prio = OSTCBCur->OSTCBPrio;
 201deec:	00808174 	movhi	r2,517
 201def0:	1090aa04 	addi	r2,r2,17064
 201def4:	10800017 	ldw	r2,0(r2)
 201def8:	10800c83 	ldbu	r2,50(r2)
 201defc:	e0bffe05 	stb	r2,-8(fp)
    }
    ptcb = OSTCBPrioTbl[prio];
 201df00:	e0bffe03 	ldbu	r2,-8(fp)
 201df04:	00c09934 	movhi	r3,612
 201df08:	18f45704 	addi	r3,r3,-11940
 201df0c:	1085883a 	add	r2,r2,r2
 201df10:	1085883a 	add	r2,r2,r2
 201df14:	1885883a 	add	r2,r3,r2
 201df18:	10800017 	ldw	r2,0(r2)
 201df1c:	e0bff915 	stw	r2,-28(fp)
    if (ptcb == (OS_TCB *)0) {                   /* Task to query must exist                           */
 201df20:	e0bff917 	ldw	r2,-28(fp)
 201df24:	1000061e 	bne	r2,zero,201df40 <OSTaskQuery+0xd0>
 201df28:	e0bff817 	ldw	r2,-32(fp)
 201df2c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201df30:	e0bffb17 	ldw	r2,-20(fp)
 201df34:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_PRIO);
 201df38:	00800a44 	movi	r2,41
 201df3c:	00001206 	br	201df88 <OSTaskQuery+0x118>
    }
    if (ptcb == OS_TCB_RESERVED) {               /* Task to query must not be assigned to a Mutex      */
 201df40:	e0bff917 	ldw	r2,-28(fp)
 201df44:	10800058 	cmpnei	r2,r2,1
 201df48:	1000061e 	bne	r2,zero,201df64 <OSTaskQuery+0xf4>
 201df4c:	e0bff817 	ldw	r2,-32(fp)
 201df50:	e0bffc15 	stw	r2,-16(fp)
 201df54:	e0bffc17 	ldw	r2,-16(fp)
 201df58:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);
 201df5c:	008010c4 	movi	r2,67
 201df60:	00000906 	br	201df88 <OSTaskQuery+0x118>
    }
                                                 /* Copy TCB into user storage area                    */
    OS_MemCopy((INT8U *)p_task_data, (INT8U *)ptcb, sizeof(OS_TCB));
 201df64:	e13fff17 	ldw	r4,-4(fp)
 201df68:	e17ff917 	ldw	r5,-28(fp)
 201df6c:	01801b04 	movi	r6,108
 201df70:	20175bc0 	call	20175bc <OS_MemCopy>
 201df74:	e0bff817 	ldw	r2,-32(fp)
 201df78:	e0bffd15 	stw	r2,-12(fp)
 201df7c:	e0bffd17 	ldw	r2,-12(fp)
 201df80:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (OS_ERR_NONE);
 201df84:	0005883a 	mov	r2,zero
}
 201df88:	e037883a 	mov	sp,fp
 201df8c:	dfc00117 	ldw	ra,4(sp)
 201df90:	df000017 	ldw	fp,0(sp)
 201df94:	dec00204 	addi	sp,sp,8
 201df98:	f800283a 	ret

0201df9c <OS_TaskStkClr>:
* Returns    : none
*********************************************************************************************************
*/
#if (OS_TASK_STAT_STK_CHK_EN > 0) && (OS_TASK_CREATE_EXT_EN > 0)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
 201df9c:	defffc04 	addi	sp,sp,-16
 201dfa0:	df000315 	stw	fp,12(sp)
 201dfa4:	df000304 	addi	fp,sp,12
 201dfa8:	e13ffd15 	stw	r4,-12(fp)
 201dfac:	e17ffe15 	stw	r5,-8(fp)
 201dfb0:	3005883a 	mov	r2,r6
 201dfb4:	e0bfff0d 	sth	r2,-4(fp)
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
 201dfb8:	e0bfff0b 	ldhu	r2,-4(fp)
 201dfbc:	1080004c 	andi	r2,r2,1
 201dfc0:	10000e26 	beq	r2,zero,201dffc <OS_TaskStkClr+0x60>
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
 201dfc4:	e0bfff0b 	ldhu	r2,-4(fp)
 201dfc8:	1080008c 	andi	r2,r2,2
 201dfcc:	10000b26 	beq	r2,zero,201dffc <OS_TaskStkClr+0x60>
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 201dfd0:	00000806 	br	201dff4 <OS_TaskStkClr+0x58>
                size--;
 201dfd4:	e0bffe17 	ldw	r2,-8(fp)
 201dfd8:	10bfffc4 	addi	r2,r2,-1
 201dfdc:	e0bffe15 	stw	r2,-8(fp)
                *pbos++ = (OS_STK)0;                   /* Clear from bottom of stack and up!           */
 201dfe0:	e0bffd17 	ldw	r2,-12(fp)
 201dfe4:	10000015 	stw	zero,0(r2)
 201dfe8:	e0bffd17 	ldw	r2,-12(fp)
 201dfec:	10800104 	addi	r2,r2,4
 201dff0:	e0bffd15 	stw	r2,-12(fp)
void  OS_TaskStkClr (OS_STK *pbos, INT32U size, INT16U opt)
{
    if ((opt & OS_TASK_OPT_STK_CHK) != 0x0000) {       /* See if stack checking has been enabled       */
        if ((opt & OS_TASK_OPT_STK_CLR) != 0x0000) {   /* See if stack needs to be cleared             */
#if OS_STK_GROWTH == 1
            while (size > 0) {                         /* Stack grows from HIGH to LOW memory          */
 201dff4:	e0bffe17 	ldw	r2,-8(fp)
 201dff8:	103ff61e 	bne	r2,zero,201dfd4 <OS_TaskStkClr+0x38>
                *pbos-- = (OS_STK)0;                   /* Clear from bottom of stack and down          */
            }
#endif
        }
    }
}
 201dffc:	e037883a 	mov	sp,fp
 201e000:	df000017 	ldw	fp,0(sp)
 201e004:	dec00104 	addi	sp,sp,4
 201e008:	f800283a 	ret

0201e00c <OSTimeDly>:
* Returns    : none
*********************************************************************************************************
*/

void  OSTimeDly (INT16U ticks)
{
 201e00c:	defff904 	addi	sp,sp,-28
 201e010:	dfc00615 	stw	ra,24(sp)
 201e014:	df000515 	stw	fp,20(sp)
 201e018:	df000504 	addi	fp,sp,20
 201e01c:	2005883a 	mov	r2,r4
 201e020:	e0bfff0d 	sth	r2,-4(fp)
    INT8U      y;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201e024:	e03ffb15 	stw	zero,-20(fp)
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 201e028:	00808174 	movhi	r2,517
 201e02c:	1090a904 	addi	r2,r2,17060
 201e030:	10800003 	ldbu	r2,0(r2)
 201e034:	10803fcc 	andi	r2,r2,255
 201e038:	1000401e 	bne	r2,zero,201e13c <OSTimeDly+0x130>
        return;
    }
    if (ticks > 0) {                             /* 0 means no delay!                                  */
 201e03c:	e0bfff0b 	ldhu	r2,-4(fp)
 201e040:	10003f26 	beq	r2,zero,201e140 <OSTimeDly+0x134>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e044:	0005303a 	rdctl	r2,status
 201e048:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e04c:	e0fffd17 	ldw	r3,-12(fp)
 201e050:	00bfff84 	movi	r2,-2
 201e054:	1884703a 	and	r2,r3,r2
 201e058:	1001703a 	wrctl	status,r2
  
  return context;
 201e05c:	e0bffd17 	ldw	r2,-12(fp)
        OS_ENTER_CRITICAL();
 201e060:	e0bffb15 	stw	r2,-20(fp)
        y            =  OSTCBCur->OSTCBY;        /* Delay current task                                 */
 201e064:	00808174 	movhi	r2,517
 201e068:	1090aa04 	addi	r2,r2,17064
 201e06c:	10800017 	ldw	r2,0(r2)
 201e070:	10800d03 	ldbu	r2,52(r2)
 201e074:	e0bffc05 	stb	r2,-16(fp)
        OSRdyTbl[y] &= ~OSTCBCur->OSTCBBitX;
 201e078:	e0bffc03 	ldbu	r2,-16(fp)
 201e07c:	e0fffc03 	ldbu	r3,-16(fp)
 201e080:	01008174 	movhi	r4,517
 201e084:	2110a744 	addi	r4,r4,17053
 201e088:	20c7883a 	add	r3,r4,r3
 201e08c:	18c00003 	ldbu	r3,0(r3)
 201e090:	1809883a 	mov	r4,r3
 201e094:	00c08174 	movhi	r3,517
 201e098:	18d0aa04 	addi	r3,r3,17064
 201e09c:	18c00017 	ldw	r3,0(r3)
 201e0a0:	18c00d43 	ldbu	r3,53(r3)
 201e0a4:	00c6303a 	nor	r3,zero,r3
 201e0a8:	20c6703a 	and	r3,r4,r3
 201e0ac:	01008174 	movhi	r4,517
 201e0b0:	2110a744 	addi	r4,r4,17053
 201e0b4:	2085883a 	add	r2,r4,r2
 201e0b8:	10c00005 	stb	r3,0(r2)
        if (OSRdyTbl[y] == 0) {
 201e0bc:	e0bffc03 	ldbu	r2,-16(fp)
 201e0c0:	00c08174 	movhi	r3,517
 201e0c4:	18d0a744 	addi	r3,r3,17053
 201e0c8:	1885883a 	add	r2,r3,r2
 201e0cc:	10800003 	ldbu	r2,0(r2)
 201e0d0:	10803fcc 	andi	r2,r2,255
 201e0d4:	10000e1e 	bne	r2,zero,201e110 <OSTimeDly+0x104>
            OSRdyGrp &= ~OSTCBCur->OSTCBBitY;
 201e0d8:	00808174 	movhi	r2,517
 201e0dc:	1090aa04 	addi	r2,r2,17064
 201e0e0:	10800017 	ldw	r2,0(r2)
 201e0e4:	10800d83 	ldbu	r2,54(r2)
 201e0e8:	0084303a 	nor	r2,zero,r2
 201e0ec:	1007883a 	mov	r3,r2
 201e0f0:	00808174 	movhi	r2,517
 201e0f4:	1090a704 	addi	r2,r2,17052
 201e0f8:	10800003 	ldbu	r2,0(r2)
 201e0fc:	1884703a 	and	r2,r3,r2
 201e100:	1007883a 	mov	r3,r2
 201e104:	00808174 	movhi	r2,517
 201e108:	1090a704 	addi	r2,r2,17052
 201e10c:	10c00005 	stb	r3,0(r2)
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
 201e110:	00808174 	movhi	r2,517
 201e114:	1090aa04 	addi	r2,r2,17064
 201e118:	10800017 	ldw	r2,0(r2)
 201e11c:	e0ffff0b 	ldhu	r3,-4(fp)
 201e120:	10c00b8d 	sth	r3,46(r2)
 201e124:	e0bffb17 	ldw	r2,-20(fp)
 201e128:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e12c:	e0bffe17 	ldw	r2,-8(fp)
 201e130:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
 201e134:	20176280 	call	2017628 <OS_Sched>
 201e138:	00000106 	br	201e140 <OSTimeDly+0x134>
#endif



    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
        return;
 201e13c:	0001883a 	nop
        }
        OSTCBCur->OSTCBDly = ticks;              /* Load ticks in TCB                                  */
        OS_EXIT_CRITICAL();
        OS_Sched();                              /* Find next task to run!                             */
    }
}
 201e140:	e037883a 	mov	sp,fp
 201e144:	dfc00117 	ldw	ra,4(sp)
 201e148:	df000017 	ldw	fp,0(sp)
 201e14c:	dec00204 	addi	sp,sp,8
 201e150:	f800283a 	ret

0201e154 <OSTimeDlyHMSM>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_HMSM_EN > 0
INT8U  OSTimeDlyHMSM (INT8U hours, INT8U minutes, INT8U seconds, INT16U ms)
{
 201e154:	defff604 	addi	sp,sp,-40
 201e158:	dfc00915 	stw	ra,36(sp)
 201e15c:	df000815 	stw	fp,32(sp)
 201e160:	dc400715 	stw	r17,28(sp)
 201e164:	dc000615 	stw	r16,24(sp)
 201e168:	df000604 	addi	fp,sp,24
 201e16c:	2011883a 	mov	r8,r4
 201e170:	2809883a 	mov	r4,r5
 201e174:	3007883a 	mov	r3,r6
 201e178:	3805883a 	mov	r2,r7
 201e17c:	e23ffc05 	stb	r8,-16(fp)
 201e180:	e13ffd05 	stb	r4,-12(fp)
 201e184:	e0fffe05 	stb	r3,-8(fp)
 201e188:	e0bfff0d 	sth	r2,-4(fp)
    INT32U ticks;
    INT16U loops;


    if (OSIntNesting > 0) {                      /* See if trying to call from an ISR                  */
 201e18c:	00808174 	movhi	r2,517
 201e190:	1090a904 	addi	r2,r2,17060
 201e194:	10800003 	ldbu	r2,0(r2)
 201e198:	10803fcc 	andi	r2,r2,255
 201e19c:	10000226 	beq	r2,zero,201e1a8 <OSTimeDlyHMSM+0x54>
        return (OS_ERR_TIME_DLY_ISR);
 201e1a0:	00801544 	movi	r2,85
 201e1a4:	00007006 	br	201e368 <OSTimeDlyHMSM+0x214>
    }
#if OS_ARG_CHK_EN > 0
    if (hours == 0) {
 201e1a8:	e0bffc03 	ldbu	r2,-16(fp)
 201e1ac:	1000081e 	bne	r2,zero,201e1d0 <OSTimeDlyHMSM+0x7c>
        if (minutes == 0) {
 201e1b0:	e0bffd03 	ldbu	r2,-12(fp)
 201e1b4:	1000061e 	bne	r2,zero,201e1d0 <OSTimeDlyHMSM+0x7c>
            if (seconds == 0) {
 201e1b8:	e0bffe03 	ldbu	r2,-8(fp)
 201e1bc:	1000041e 	bne	r2,zero,201e1d0 <OSTimeDlyHMSM+0x7c>
                if (ms == 0) {
 201e1c0:	e0bfff0b 	ldhu	r2,-4(fp)
 201e1c4:	1000021e 	bne	r2,zero,201e1d0 <OSTimeDlyHMSM+0x7c>
                    return (OS_ERR_TIME_ZERO_DLY);
 201e1c8:	00801504 	movi	r2,84
 201e1cc:	00006606 	br	201e368 <OSTimeDlyHMSM+0x214>
                }
            }
        }
    }
    if (minutes > 59) {
 201e1d0:	e0bffd03 	ldbu	r2,-12(fp)
 201e1d4:	10800f30 	cmpltui	r2,r2,60
 201e1d8:	1000021e 	bne	r2,zero,201e1e4 <OSTimeDlyHMSM+0x90>
        return (OS_ERR_TIME_INVALID_MINUTES);    /* Validate arguments to be within range              */
 201e1dc:	00801444 	movi	r2,81
 201e1e0:	00006106 	br	201e368 <OSTimeDlyHMSM+0x214>
    }
    if (seconds > 59) {
 201e1e4:	e0bffe03 	ldbu	r2,-8(fp)
 201e1e8:	10800f30 	cmpltui	r2,r2,60
 201e1ec:	1000021e 	bne	r2,zero,201e1f8 <OSTimeDlyHMSM+0xa4>
        return (OS_ERR_TIME_INVALID_SECONDS);
 201e1f0:	00801484 	movi	r2,82
 201e1f4:	00005c06 	br	201e368 <OSTimeDlyHMSM+0x214>
    }
    if (ms > 999) {
 201e1f8:	e0bfff0b 	ldhu	r2,-4(fp)
 201e1fc:	1080fa30 	cmpltui	r2,r2,1000
 201e200:	1000021e 	bne	r2,zero,201e20c <OSTimeDlyHMSM+0xb8>
        return (OS_ERR_TIME_INVALID_MS);
 201e204:	008014c4 	movi	r2,83
 201e208:	00005706 	br	201e368 <OSTimeDlyHMSM+0x214>
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 201e20c:	e0bffc03 	ldbu	r2,-16(fp)
 201e210:	10c38424 	muli	r3,r2,3600
 201e214:	e0bffd03 	ldbu	r2,-12(fp)
 201e218:	10800f24 	muli	r2,r2,60
 201e21c:	1887883a 	add	r3,r3,r2
 201e220:	e0bffe03 	ldbu	r2,-8(fp)
 201e224:	1885883a 	add	r2,r3,r2
 201e228:	1009883a 	mov	r4,r2
 201e22c:	20145600 	call	2014560 <__floatunsidf>
 201e230:	100b883a 	mov	r5,r2
 201e234:	180d883a 	mov	r6,r3
 201e238:	2809883a 	mov	r4,r5
 201e23c:	300b883a 	mov	r5,r6
 201e240:	000d883a 	mov	r6,zero
 201e244:	01d01674 	movhi	r7,16473
 201e248:	2013c880 	call	2013c88 <__muldf3>
 201e24c:	1009883a 	mov	r4,r2
 201e250:	180b883a 	mov	r5,r3
 201e254:	2021883a 	mov	r16,r4
 201e258:	2823883a 	mov	r17,r5
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
 201e25c:	e0bfff0b 	ldhu	r2,-4(fp)
 201e260:	1009883a 	mov	r4,r2
 201e264:	20145600 	call	2014560 <__floatunsidf>
 201e268:	100b883a 	mov	r5,r2
 201e26c:	180d883a 	mov	r6,r3
 201e270:	2809883a 	mov	r4,r5
 201e274:	300b883a 	mov	r5,r6
 201e278:	000d883a 	mov	r6,zero
 201e27c:	01d00534 	movhi	r7,16404
 201e280:	2013bd40 	call	2013bd4 <__adddf3>
 201e284:	1009883a 	mov	r4,r2
 201e288:	180b883a 	mov	r5,r3
 201e28c:	2005883a 	mov	r2,r4
 201e290:	2807883a 	mov	r3,r5
 201e294:	1009883a 	mov	r4,r2
 201e298:	180b883a 	mov	r5,r3
 201e29c:	000d883a 	mov	r6,zero
 201e2a0:	01d01674 	movhi	r7,16473
 201e2a4:	2013c880 	call	2013c88 <__muldf3>
 201e2a8:	1009883a 	mov	r4,r2
 201e2ac:	180b883a 	mov	r5,r3
 201e2b0:	2005883a 	mov	r2,r4
 201e2b4:	2807883a 	mov	r3,r5
 201e2b8:	1009883a 	mov	r4,r2
 201e2bc:	180b883a 	mov	r5,r3
 201e2c0:	000d883a 	mov	r6,zero
 201e2c4:	01d023f4 	movhi	r7,16527
 201e2c8:	39d00004 	addi	r7,r7,16384
 201e2cc:	2013f6c0 	call	2013f6c <__divdf3>
 201e2d0:	1009883a 	mov	r4,r2
 201e2d4:	180b883a 	mov	r5,r3
 201e2d8:	2005883a 	mov	r2,r4
 201e2dc:	2807883a 	mov	r3,r5
 201e2e0:	8009883a 	mov	r4,r16
 201e2e4:	880b883a 	mov	r5,r17
 201e2e8:	100d883a 	mov	r6,r2
 201e2ec:	180f883a 	mov	r7,r3
 201e2f0:	2013bd40 	call	2013bd4 <__adddf3>
 201e2f4:	1009883a 	mov	r4,r2
 201e2f8:	180b883a 	mov	r5,r3
 201e2fc:	2005883a 	mov	r2,r4
 201e300:	2807883a 	mov	r3,r5
        return (OS_ERR_TIME_INVALID_MS);
    }
#endif
                                                 /* Compute the total number of clock ticks required.. */
                                                 /* .. (rounded to the nearest tick)                   */
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
 201e304:	1009883a 	mov	r4,r2
 201e308:	180b883a 	mov	r5,r3
 201e30c:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 201e310:	e0bffb15 	stw	r2,-20(fp)
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
 201e314:	e0bffb17 	ldw	r2,-20(fp)
 201e318:	1004d43a 	srli	r2,r2,16
 201e31c:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
 201e320:	e0bffb17 	ldw	r2,-20(fp)
 201e324:	10bfffcc 	andi	r2,r2,65535
 201e328:	e0bffb15 	stw	r2,-20(fp)
    OSTimeDly((INT16U)ticks);
 201e32c:	e0bffb17 	ldw	r2,-20(fp)
 201e330:	10bfffcc 	andi	r2,r2,65535
 201e334:	1009883a 	mov	r4,r2
 201e338:	201e00c0 	call	201e00c <OSTimeDly>
    while (loops > 0) {
 201e33c:	00000706 	br	201e35c <OSTimeDlyHMSM+0x208>
        OSTimeDly((INT16U)32768u);
 201e340:	01200014 	movui	r4,32768
 201e344:	201e00c0 	call	201e00c <OSTimeDly>
        OSTimeDly((INT16U)32768u);
 201e348:	01200014 	movui	r4,32768
 201e34c:	201e00c0 	call	201e00c <OSTimeDly>
        loops--;
 201e350:	e0bffa0b 	ldhu	r2,-24(fp)
 201e354:	10bfffc4 	addi	r2,r2,-1
 201e358:	e0bffa0d 	sth	r2,-24(fp)
    ticks = ((INT32U)hours * 3600L + (INT32U)minutes * 60L + (INT32U)seconds) * OS_TICKS_PER_SEC
          + OS_TICKS_PER_SEC * ((INT32U)ms + 500L / OS_TICKS_PER_SEC) / 1000L;
    loops = (INT16U)(ticks >> 16);               /* Compute the integral number of 65536 tick delays   */
    ticks = ticks & 0xFFFFL;                     /* Obtain  the fractional number of ticks             */
    OSTimeDly((INT16U)ticks);
    while (loops > 0) {
 201e35c:	e0bffa0b 	ldhu	r2,-24(fp)
 201e360:	103ff71e 	bne	r2,zero,201e340 <OSTimeDlyHMSM+0x1ec>
        OSTimeDly((INT16U)32768u);
        OSTimeDly((INT16U)32768u);
        loops--;
    }
    return (OS_ERR_NONE);
 201e364:	0005883a 	mov	r2,zero
}
 201e368:	e037883a 	mov	sp,fp
 201e36c:	dfc00317 	ldw	ra,12(sp)
 201e370:	df000217 	ldw	fp,8(sp)
 201e374:	dc400117 	ldw	r17,4(sp)
 201e378:	dc000017 	ldw	r16,0(sp)
 201e37c:	dec00404 	addi	sp,sp,16
 201e380:	f800283a 	ret

0201e384 <OSTimeDlyResume>:
*********************************************************************************************************
*/

#if OS_TIME_DLY_RESUME_EN > 0
INT8U  OSTimeDlyResume (INT8U prio)
{
 201e384:	defff504 	addi	sp,sp,-44
 201e388:	dfc00a15 	stw	ra,40(sp)
 201e38c:	df000915 	stw	fp,36(sp)
 201e390:	df000904 	addi	fp,sp,36
 201e394:	2005883a 	mov	r2,r4
 201e398:	e0bfff05 	stb	r2,-4(fp)
    OS_TCB    *ptcb;
#if OS_CRITICAL_METHOD == 3                                    /* Storage for CPU status register      */
    OS_CPU_SR  cpu_sr = 0;
 201e39c:	e03ff715 	stw	zero,-36(fp)
#endif



    if (prio >= OS_LOWEST_PRIO) {
 201e3a0:	e0bfff03 	ldbu	r2,-4(fp)
 201e3a4:	10800530 	cmpltui	r2,r2,20
 201e3a8:	1000021e 	bne	r2,zero,201e3b4 <OSTimeDlyResume+0x30>
        return (OS_ERR_PRIO_INVALID);
 201e3ac:	00800a84 	movi	r2,42
 201e3b0:	00006a06 	br	201e55c <OSTimeDlyResume+0x1d8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e3b4:	0005303a 	rdctl	r2,status
 201e3b8:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e3bc:	e0fff917 	ldw	r3,-28(fp)
 201e3c0:	00bfff84 	movi	r2,-2
 201e3c4:	1884703a 	and	r2,r3,r2
 201e3c8:	1001703a 	wrctl	status,r2
  
  return context;
 201e3cc:	e0bff917 	ldw	r2,-28(fp)
    }
    OS_ENTER_CRITICAL();
 201e3d0:	e0bff715 	stw	r2,-36(fp)
    ptcb = OSTCBPrioTbl[prio];                                 /* Make sure that task exist            */
 201e3d4:	e0bfff03 	ldbu	r2,-4(fp)
 201e3d8:	00c09934 	movhi	r3,612
 201e3dc:	18f45704 	addi	r3,r3,-11940
 201e3e0:	1085883a 	add	r2,r2,r2
 201e3e4:	1085883a 	add	r2,r2,r2
 201e3e8:	1885883a 	add	r2,r3,r2
 201e3ec:	10800017 	ldw	r2,0(r2)
 201e3f0:	e0bff815 	stw	r2,-32(fp)
    if (ptcb == (OS_TCB *)0) {
 201e3f4:	e0bff817 	ldw	r2,-32(fp)
 201e3f8:	1000061e 	bne	r2,zero,201e414 <OSTimeDlyResume+0x90>
 201e3fc:	e0bff717 	ldw	r2,-36(fp)
 201e400:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e404:	e0bffa17 	ldw	r2,-24(fp)
 201e408:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 201e40c:	008010c4 	movi	r2,67
 201e410:	00005206 	br	201e55c <OSTimeDlyResume+0x1d8>
    }
    if (ptcb == OS_TCB_RESERVED) {
 201e414:	e0bff817 	ldw	r2,-32(fp)
 201e418:	10800058 	cmpnei	r2,r2,1
 201e41c:	1000061e 	bne	r2,zero,201e438 <OSTimeDlyResume+0xb4>
 201e420:	e0bff717 	ldw	r2,-36(fp)
 201e424:	e0bffb15 	stw	r2,-20(fp)
 201e428:	e0bffb17 	ldw	r2,-20(fp)
 201e42c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TASK_NOT_EXIST);                        /* The task does not exist              */
 201e430:	008010c4 	movi	r2,67
 201e434:	00004906 	br	201e55c <OSTimeDlyResume+0x1d8>
    }
    if (ptcb->OSTCBDly == 0) {                                 /* See if task is delayed               */
 201e438:	e0bff817 	ldw	r2,-32(fp)
 201e43c:	10800b8b 	ldhu	r2,46(r2)
 201e440:	10bfffcc 	andi	r2,r2,65535
 201e444:	1000061e 	bne	r2,zero,201e460 <OSTimeDlyResume+0xdc>
 201e448:	e0bff717 	ldw	r2,-36(fp)
 201e44c:	e0bffc15 	stw	r2,-16(fp)
 201e450:	e0bffc17 	ldw	r2,-16(fp)
 201e454:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        return (OS_ERR_TIME_NOT_DLY);                          /* Indicate that task was not delayed   */
 201e458:	00801404 	movi	r2,80
 201e45c:	00003f06 	br	201e55c <OSTimeDlyResume+0x1d8>
    }

    ptcb->OSTCBDly = 0;                                        /* Clear the time delay                 */
 201e460:	e0bff817 	ldw	r2,-32(fp)
 201e464:	10000b8d 	sth	zero,46(r2)
    if ((ptcb->OSTCBStat & OS_STAT_PEND_ANY) != OS_STAT_RDY) {
 201e468:	e0bff817 	ldw	r2,-32(fp)
 201e46c:	10800c03 	ldbu	r2,48(r2)
 201e470:	10803fcc 	andi	r2,r2,255
 201e474:	10800dcc 	andi	r2,r2,55
 201e478:	10000b26 	beq	r2,zero,201e4a8 <OSTimeDlyResume+0x124>
        ptcb->OSTCBStat     &= ~OS_STAT_PEND_ANY;              /* Yes, Clear status flag               */
 201e47c:	e0bff817 	ldw	r2,-32(fp)
 201e480:	10c00c03 	ldbu	r3,48(r2)
 201e484:	00bff204 	movi	r2,-56
 201e488:	1884703a 	and	r2,r3,r2
 201e48c:	1007883a 	mov	r3,r2
 201e490:	e0bff817 	ldw	r2,-32(fp)
 201e494:	10c00c05 	stb	r3,48(r2)
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_TO;               /* Indicate PEND timeout                */
 201e498:	e0bff817 	ldw	r2,-32(fp)
 201e49c:	00c00044 	movi	r3,1
 201e4a0:	10c00c45 	stb	r3,49(r2)
 201e4a4:	00000206 	br	201e4b0 <OSTimeDlyResume+0x12c>
    } else {
        ptcb->OSTCBStatPend  =  OS_STAT_PEND_OK;
 201e4a8:	e0bff817 	ldw	r2,-32(fp)
 201e4ac:	10000c45 	stb	zero,49(r2)
    }
    if ((ptcb->OSTCBStat & OS_STAT_SUSPEND) == OS_STAT_RDY) {  /* Is task suspended?                   */
 201e4b0:	e0bff817 	ldw	r2,-32(fp)
 201e4b4:	10800c03 	ldbu	r2,48(r2)
 201e4b8:	10803fcc 	andi	r2,r2,255
 201e4bc:	1080020c 	andi	r2,r2,8
 201e4c0:	1000211e 	bne	r2,zero,201e548 <OSTimeDlyResume+0x1c4>
        OSRdyGrp               |= ptcb->OSTCBBitY;             /* No,  Make ready                      */
 201e4c4:	e0bff817 	ldw	r2,-32(fp)
 201e4c8:	10c00d83 	ldbu	r3,54(r2)
 201e4cc:	00808174 	movhi	r2,517
 201e4d0:	1090a704 	addi	r2,r2,17052
 201e4d4:	10800003 	ldbu	r2,0(r2)
 201e4d8:	1884b03a 	or	r2,r3,r2
 201e4dc:	1007883a 	mov	r3,r2
 201e4e0:	00808174 	movhi	r2,517
 201e4e4:	1090a704 	addi	r2,r2,17052
 201e4e8:	10c00005 	stb	r3,0(r2)
        OSRdyTbl[ptcb->OSTCBY] |= ptcb->OSTCBBitX;
 201e4ec:	e0bff817 	ldw	r2,-32(fp)
 201e4f0:	10800d03 	ldbu	r2,52(r2)
 201e4f4:	10803fcc 	andi	r2,r2,255
 201e4f8:	e0fff817 	ldw	r3,-32(fp)
 201e4fc:	18c00d03 	ldbu	r3,52(r3)
 201e500:	18c03fcc 	andi	r3,r3,255
 201e504:	01008174 	movhi	r4,517
 201e508:	2110a744 	addi	r4,r4,17053
 201e50c:	20c7883a 	add	r3,r4,r3
 201e510:	19000003 	ldbu	r4,0(r3)
 201e514:	e0fff817 	ldw	r3,-32(fp)
 201e518:	18c00d43 	ldbu	r3,53(r3)
 201e51c:	20c6b03a 	or	r3,r4,r3
 201e520:	01008174 	movhi	r4,517
 201e524:	2110a744 	addi	r4,r4,17053
 201e528:	2085883a 	add	r2,r4,r2
 201e52c:	10c00005 	stb	r3,0(r2)
 201e530:	e0bff717 	ldw	r2,-36(fp)
 201e534:	e0bffd15 	stw	r2,-12(fp)
 201e538:	e0bffd17 	ldw	r2,-12(fp)
 201e53c:	1001703a 	wrctl	status,r2
        OS_EXIT_CRITICAL();
        OS_Sched();                                            /* See if this is new highest priority  */
 201e540:	20176280 	call	2017628 <OS_Sched>
 201e544:	00000406 	br	201e558 <OSTimeDlyResume+0x1d4>
 201e548:	e0bff717 	ldw	r2,-36(fp)
 201e54c:	e0bffe15 	stw	r2,-8(fp)
 201e550:	e0bffe17 	ldw	r2,-8(fp)
 201e554:	1001703a 	wrctl	status,r2
    } else {
        OS_EXIT_CRITICAL();                                    /* Task may be suspended                */
    }
    return (OS_ERR_NONE);
 201e558:	0005883a 	mov	r2,zero
}
 201e55c:	e037883a 	mov	sp,fp
 201e560:	dfc00117 	ldw	ra,4(sp)
 201e564:	df000017 	ldw	fp,0(sp)
 201e568:	dec00204 	addi	sp,sp,8
 201e56c:	f800283a 	ret

0201e570 <OSTimeGet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
INT32U  OSTimeGet (void)
{
 201e570:	defffb04 	addi	sp,sp,-20
 201e574:	df000415 	stw	fp,16(sp)
 201e578:	df000404 	addi	fp,sp,16
    INT32U     ticks;
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201e57c:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e580:	0005303a 	rdctl	r2,status
 201e584:	e0bffe15 	stw	r2,-8(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e588:	e0fffe17 	ldw	r3,-8(fp)
 201e58c:	00bfff84 	movi	r2,-2
 201e590:	1884703a 	and	r2,r3,r2
 201e594:	1001703a 	wrctl	status,r2
  
  return context;
 201e598:	e0bffe17 	ldw	r2,-8(fp)
#endif



    OS_ENTER_CRITICAL();
 201e59c:	e0bffc15 	stw	r2,-16(fp)
    ticks = OSTime;
 201e5a0:	00808174 	movhi	r2,517
 201e5a4:	1090ab04 	addi	r2,r2,17068
 201e5a8:	10800017 	ldw	r2,0(r2)
 201e5ac:	e0bffd15 	stw	r2,-12(fp)
 201e5b0:	e0bffc17 	ldw	r2,-16(fp)
 201e5b4:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e5b8:	e0bfff17 	ldw	r2,-4(fp)
 201e5bc:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
    return (ticks);
 201e5c0:	e0bffd17 	ldw	r2,-12(fp)
}
 201e5c4:	e037883a 	mov	sp,fp
 201e5c8:	df000017 	ldw	fp,0(sp)
 201e5cc:	dec00104 	addi	sp,sp,4
 201e5d0:	f800283a 	ret

0201e5d4 <OSTimeSet>:
*********************************************************************************************************
*/

#if OS_TIME_GET_SET_EN > 0
void  OSTimeSet (INT32U ticks)
{
 201e5d4:	defffb04 	addi	sp,sp,-20
 201e5d8:	df000415 	stw	fp,16(sp)
 201e5dc:	df000404 	addi	fp,sp,16
 201e5e0:	e13fff15 	stw	r4,-4(fp)
#if OS_CRITICAL_METHOD == 3                      /* Allocate storage for CPU status register           */
    OS_CPU_SR  cpu_sr = 0;
 201e5e4:	e03ffc15 	stw	zero,-16(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201e5e8:	0005303a 	rdctl	r2,status
 201e5ec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201e5f0:	e0fffd17 	ldw	r3,-12(fp)
 201e5f4:	00bfff84 	movi	r2,-2
 201e5f8:	1884703a 	and	r2,r3,r2
 201e5fc:	1001703a 	wrctl	status,r2
  
  return context;
 201e600:	e0bffd17 	ldw	r2,-12(fp)
#endif



    OS_ENTER_CRITICAL();
 201e604:	e0bffc15 	stw	r2,-16(fp)
    OSTime = ticks;
 201e608:	00808174 	movhi	r2,517
 201e60c:	1090ab04 	addi	r2,r2,17068
 201e610:	e0ffff17 	ldw	r3,-4(fp)
 201e614:	10c00015 	stw	r3,0(r2)
 201e618:	e0bffc17 	ldw	r2,-16(fp)
 201e61c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201e620:	e0bffe17 	ldw	r2,-8(fp)
 201e624:	1001703a 	wrctl	status,r2
    OS_EXIT_CRITICAL();
}
 201e628:	e037883a 	mov	sp,fp
 201e62c:	df000017 	ldw	fp,0(sp)
 201e630:	dec00104 	addi	sp,sp,4
 201e634:	f800283a 	ret

0201e638 <alt_dev_reg>:
 */

extern int alt_fs_reg  (alt_dev* dev); 

static ALT_INLINE int alt_dev_reg (alt_dev* dev)
{
 201e638:	defffd04 	addi	sp,sp,-12
 201e63c:	dfc00215 	stw	ra,8(sp)
 201e640:	df000115 	stw	fp,4(sp)
 201e644:	df000104 	addi	fp,sp,4
 201e648:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) dev, &alt_dev_list);
 201e64c:	e13fff17 	ldw	r4,-4(fp)
 201e650:	01408174 	movhi	r5,517
 201e654:	29507404 	addi	r5,r5,16848
 201e658:	2036f200 	call	2036f20 <alt_dev_llist_insert>
}
 201e65c:	e037883a 	mov	sp,fp
 201e660:	dfc00117 	ldw	ra,4(sp)
 201e664:	df000017 	ldw	fp,0(sp)
 201e668:	dec00204 	addi	sp,sp,8
 201e66c:	f800283a 	ret

0201e670 <alt_irq_init>:
 * The "base" parameter is ignored and only
 * present for backwards-compatibility.
 */

void alt_irq_init ( const void* base )
{
 201e670:	defffd04 	addi	sp,sp,-12
 201e674:	dfc00215 	stw	ra,8(sp)
 201e678:	df000115 	stw	fp,4(sp)
 201e67c:	df000104 	addi	fp,sp,4
 201e680:	e13fff15 	stw	r4,-4(fp)
    ALTERA_NIOS2_QSYS_IRQ_INIT ( NIOS2, nios2);
 201e684:	2037ae40 	call	2037ae4 <altera_nios2_qsys_irq_init>
 * alt_irq_cpu_enable_interrupts() enables the CPU to start taking interrupts.
 */
static ALT_INLINE void ALT_ALWAYS_INLINE 
       alt_irq_cpu_enable_interrupts ()
{
    NIOS2_WRITE_STATUS(NIOS2_STATUS_PIE_MSK
 201e688:	00800044 	movi	r2,1
 201e68c:	1001703a 	wrctl	status,r2
    alt_irq_cpu_enable_interrupts();
}
 201e690:	e037883a 	mov	sp,fp
 201e694:	dfc00117 	ldw	ra,4(sp)
 201e698:	df000017 	ldw	fp,0(sp)
 201e69c:	dec00204 	addi	sp,sp,8
 201e6a0:	f800283a 	ret

0201e6a4 <alt_sys_init>:
 * Initialize the non-interrupt controller devices.
 * Called after alt_irq_init().
 */

void alt_sys_init( void )
{
 201e6a4:	defffa04 	addi	sp,sp,-24
 201e6a8:	dfc00515 	stw	ra,20(sp)
 201e6ac:	df000415 	stw	fp,16(sp)
 201e6b0:	df000404 	addi	fp,sp,16
    ALTERA_AVALON_TIMER_INIT ( HIGH_RES_TIMER, high_res_timer);
    ALTERA_AVALON_TIMER_INIT ( SYS_CLK_TIMER, sys_clk_timer);
 201e6b4:	0107a804 	movi	r4,7840
 201e6b8:	000b883a 	mov	r5,zero
 201e6bc:	01800104 	movi	r6,4
 201e6c0:	01c01904 	movi	r7,100
 201e6c4:	2020d5c0 	call	2020d5c <alt_avalon_timer_sc_init>
    ALTERA_AVALON_EPCS_FLASH_CONTROLLER_INIT ( EPCS_FLASH_CONTROLLER, epcs_flash_controller);
 201e6c8:	01008174 	movhi	r4,517
 201e6cc:	210a7f04 	addi	r4,r4,10748
 201e6d0:	201e9480 	call	201e948 <alt_epcs_flash_init>
    ALTERA_AVALON_JTAG_UART_INIT ( JTAG_UART, jtag_uart);
 201e6d4:	01008174 	movhi	r4,517
 201e6d8:	210abb04 	addi	r4,r4,10988
 201e6dc:	000b883a 	mov	r5,zero
 201e6e0:	01800044 	movi	r6,1
 201e6e4:	201f4040 	call	201f404 <altera_avalon_jtag_uart_init>
 201e6e8:	01008174 	movhi	r4,517
 201e6ec:	210ab104 	addi	r4,r4,10948
 201e6f0:	201e6380 	call	201e638 <alt_dev_reg>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_RX, sgdma_rx);
 201e6f4:	01008174 	movhi	r4,517
 201e6f8:	210ecc04 	addi	r4,r4,15152
 201e6fc:	000b883a 	mov	r5,zero
 201e700:	018000c4 	movi	r6,3
 201e704:	2020c440 	call	2020c44 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SGDMA_INIT ( SGDMA_TX, sgdma_tx);
 201e708:	01008174 	movhi	r4,517
 201e70c:	210ed804 	addi	r4,r4,15200
 201e710:	000b883a 	mov	r5,zero
 201e714:	01800084 	movi	r6,2
 201e718:	2020c440 	call	2020c44 <alt_avalon_sgdma_init>
    ALTERA_AVALON_SYSID_QSYS_INIT ( SYSID_QSYS, sysid_qsys);
 201e71c:	0001883a 	nop
    ALTERA_ETH_TSE_INIT ( TSE_MAC, tse_mac);
 201e720:	e03ffc15 	stw	zero,-16(fp)
 201e724:	00800044 	movi	r2,1
 201e728:	e0bffd15 	stw	r2,-12(fp)
 201e72c:	e0bffd17 	ldw	r2,-12(fp)
 201e730:	00800216 	blt	zero,r2,201e73c <alt_sys_init+0x98>
 201e734:	00800044 	movi	r2,1
 201e738:	e0bffd15 	stw	r2,-12(fp)
 201e73c:	e03ffc15 	stw	zero,-16(fp)
 201e740:	00006406 	br	201e8d4 <alt_sys_init+0x230>
 201e744:	00c09934 	movhi	r3,612
 201e748:	18f46c04 	addi	r3,r3,-11856
 201e74c:	e0bffc17 	ldw	r2,-16(fp)
 201e750:	10800724 	muli	r2,r2,28
 201e754:	1885883a 	add	r2,r3,r2
 201e758:	10000015 	stw	zero,0(r2)
 201e75c:	00c09934 	movhi	r3,612
 201e760:	18f46c04 	addi	r3,r3,-11856
 201e764:	e0bffc17 	ldw	r2,-16(fp)
 201e768:	10800724 	muli	r2,r2,28
 201e76c:	1885883a 	add	r2,r3,r2
 201e770:	10800104 	addi	r2,r2,4
 201e774:	10000015 	stw	zero,0(r2)
 201e778:	d0e03417 	ldw	r3,-32560(gp)
 201e77c:	01009934 	movhi	r4,612
 201e780:	21346c04 	addi	r4,r4,-11856
 201e784:	e0bffc17 	ldw	r2,-16(fp)
 201e788:	10800724 	muli	r2,r2,28
 201e78c:	2085883a 	add	r2,r4,r2
 201e790:	10800204 	addi	r2,r2,8
 201e794:	10c00015 	stw	r3,0(r2)
 201e798:	00c09934 	movhi	r3,612
 201e79c:	18f46c04 	addi	r3,r3,-11856
 201e7a0:	e0bffc17 	ldw	r2,-16(fp)
 201e7a4:	10800724 	muli	r2,r2,28
 201e7a8:	1885883a 	add	r2,r3,r2
 201e7ac:	10800304 	addi	r2,r2,12
 201e7b0:	00c080b4 	movhi	r3,514
 201e7b4:	18c80f04 	addi	r3,r3,8252
 201e7b8:	10c00015 	stw	r3,0(r2)
 201e7bc:	e0bffc17 	ldw	r2,-16(fp)
 201e7c0:	10c00724 	muli	r3,r2,28
 201e7c4:	00809934 	movhi	r2,612
 201e7c8:	10b46c04 	addi	r2,r2,-11856
 201e7cc:	1885883a 	add	r2,r3,r2
 201e7d0:	00c08174 	movhi	r3,517
 201e7d4:	18d06104 	addi	r3,r3,16772
 201e7d8:	e0fffe15 	stw	r3,-8(fp)
 201e7dc:	e0bfff15 	stw	r2,-4(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 201e7e0:	e0bfff17 	ldw	r2,-4(fp)
 201e7e4:	e0fffe17 	ldw	r3,-8(fp)
 201e7e8:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 201e7ec:	e0bffe17 	ldw	r2,-8(fp)
 201e7f0:	10c00017 	ldw	r3,0(r2)
 201e7f4:	e0bfff17 	ldw	r2,-4(fp)
 201e7f8:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 201e7fc:	e0bffe17 	ldw	r2,-8(fp)
 201e800:	10800017 	ldw	r2,0(r2)
 201e804:	e0ffff17 	ldw	r3,-4(fp)
 201e808:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 201e80c:	e0bffe17 	ldw	r2,-8(fp)
 201e810:	e0ffff17 	ldw	r3,-4(fp)
 201e814:	10c00015 	stw	r3,0(r2)
 201e818:	00808174 	movhi	r2,517
 201e81c:	1090af04 	addi	r2,r2,17084
 201e820:	10800003 	ldbu	r2,0(r2)
 201e824:	10803fcc 	andi	r2,r2,255
 201e828:	e0fffc17 	ldw	r3,-16(fp)
 201e82c:	19000724 	muli	r4,r3,28
 201e830:	00c09934 	movhi	r3,612
 201e834:	18f46c04 	addi	r3,r3,-11856
 201e838:	20c7883a 	add	r3,r4,r3
 201e83c:	01009934 	movhi	r4,612
 201e840:	2134a404 	addi	r4,r4,-11632
 201e844:	10800324 	muli	r2,r2,12
 201e848:	2085883a 	add	r2,r4,r2
 201e84c:	10c00015 	stw	r3,0(r2)
 201e850:	00808174 	movhi	r2,517
 201e854:	1090af04 	addi	r2,r2,17084
 201e858:	10800003 	ldbu	r2,0(r2)
 201e85c:	10803fcc 	andi	r2,r2,255
 201e860:	00c09934 	movhi	r3,612
 201e864:	18f4a404 	addi	r3,r3,-11632
 201e868:	10800324 	muli	r2,r2,12
 201e86c:	1885883a 	add	r2,r3,r2
 201e870:	10800104 	addi	r2,r2,4
 201e874:	00c60004 	movi	r3,6144
 201e878:	10c00015 	stw	r3,0(r2)
 201e87c:	00808174 	movhi	r2,517
 201e880:	1090af04 	addi	r2,r2,17084
 201e884:	10800003 	ldbu	r2,0(r2)
 201e888:	10803fcc 	andi	r2,r2,255
 201e88c:	e0fffc17 	ldw	r3,-16(fp)
 201e890:	01009934 	movhi	r4,612
 201e894:	2134a404 	addi	r4,r4,-11632
 201e898:	10800324 	muli	r2,r2,12
 201e89c:	2085883a 	add	r2,r4,r2
 201e8a0:	10800204 	addi	r2,r2,8
 201e8a4:	10c00005 	stb	r3,0(r2)
 201e8a8:	00808174 	movhi	r2,517
 201e8ac:	1090af04 	addi	r2,r2,17084
 201e8b0:	10800003 	ldbu	r2,0(r2)
 201e8b4:	10800044 	addi	r2,r2,1
 201e8b8:	1007883a 	mov	r3,r2
 201e8bc:	00808174 	movhi	r2,517
 201e8c0:	1090af04 	addi	r2,r2,17084
 201e8c4:	10c00005 	stb	r3,0(r2)
 201e8c8:	e0bffc17 	ldw	r2,-16(fp)
 201e8cc:	10800044 	addi	r2,r2,1
 201e8d0:	e0bffc15 	stw	r2,-16(fp)
 201e8d4:	e0fffc17 	ldw	r3,-16(fp)
 201e8d8:	e0bffd17 	ldw	r2,-12(fp)
 201e8dc:	18bf9916 	blt	r3,r2,201e744 <alt_sys_init+0xa0>
    ALTERA_RO_ZIPFS_INIT ( ALTERA_RO_ZIPFS, altera_ro_zipfs);
 201e8e0:	01008174 	movhi	r4,517
 201e8e4:	210ee404 	addi	r4,r4,15248
 201e8e8:	20219c00 	call	20219c0 <alt_ro_zipfs_check_valid>
 201e8ec:	10000326 	beq	r2,zero,201e8fc <alt_sys_init+0x258>
 201e8f0:	01008174 	movhi	r4,517
 201e8f4:	210ee404 	addi	r4,r4,15248
 201e8f8:	203721c0 	call	203721c <alt_fs_reg>
}
 201e8fc:	e037883a 	mov	sp,fp
 201e900:	dfc00117 	ldw	ra,4(sp)
 201e904:	df000017 	ldw	fp,0(sp)
 201e908:	dec00204 	addi	sp,sp,8
 201e90c:	f800283a 	ret

0201e910 <alt_flash_device_register>:

typedef struct alt_flash_dev alt_flash_dev; 
typedef alt_flash_dev alt_flash_fd;

static ALT_INLINE int alt_flash_device_register( alt_flash_fd* fd)
{
 201e910:	defffd04 	addi	sp,sp,-12
 201e914:	dfc00215 	stw	ra,8(sp)
 201e918:	df000115 	stw	fp,4(sp)
 201e91c:	df000104 	addi	fp,sp,4
 201e920:	e13fff15 	stw	r4,-4(fp)
  extern alt_llist alt_flash_dev_list;

  return alt_dev_llist_insert ((alt_dev_llist*) fd, &alt_flash_dev_list);
 201e924:	e13fff17 	ldw	r4,-4(fp)
 201e928:	01408174 	movhi	r5,517
 201e92c:	29503a04 	addi	r5,r5,16616
 201e930:	2036f200 	call	2036f20 <alt_dev_llist_insert>
}
 201e934:	e037883a 	mov	sp,fp
 201e938:	dfc00117 	ldw	ra,4(sp)
 201e93c:	df000017 	ldw	fp,0(sp)
 201e940:	dec00204 	addi	sp,sp,8
 201e944:	f800283a 	ret

0201e948 <alt_epcs_flash_init>:
/*
 * alt_epcs_flash_init
 *
 */
int alt_epcs_flash_init(alt_flash_epcs_dev* flash)
{
 201e948:	defffc04 	addi	sp,sp,-16
 201e94c:	dfc00315 	stw	ra,12(sp)
 201e950:	df000215 	stw	fp,8(sp)
 201e954:	df000204 	addi	fp,sp,8
 201e958:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 201e95c:	e03ffe15 	stw	zero,-8(fp)

  /* Set up function pointers and/or data structures as needed. */
  ret_code = alt_epcs_flash_query(flash);
 201e960:	e13fff17 	ldw	r4,-4(fp)
 201e964:	201e99c0 	call	201e99c <alt_epcs_flash_query>
 201e968:	e0bffe15 	stw	r2,-8(fp)
  */

  /*
  *  Register this device as a valid flash device type
  */
  if (!ret_code)
 201e96c:	e0bffe17 	ldw	r2,-8(fp)
 201e970:	1000041e 	bne	r2,zero,201e984 <alt_epcs_flash_init+0x3c>
    ret_code = alt_flash_device_register(&(flash->dev));
 201e974:	e0bfff17 	ldw	r2,-4(fp)
 201e978:	1009883a 	mov	r4,r2
 201e97c:	201e9100 	call	201e910 <alt_flash_device_register>
 201e980:	e0bffe15 	stw	r2,-8(fp)

  return ret_code;
 201e984:	e0bffe17 	ldw	r2,-8(fp)
}
 201e988:	e037883a 	mov	sp,fp
 201e98c:	dfc00117 	ldw	ra,4(sp)
 201e990:	df000017 	ldw	fp,0(sp)
 201e994:	dec00204 	addi	sp,sp,8
 201e998:	f800283a 	ret

0201e99c <alt_epcs_flash_query>:


static int alt_epcs_flash_query(alt_flash_epcs_dev* flash)
{
 201e99c:	defffc04 	addi	sp,sp,-16
 201e9a0:	dfc00315 	stw	ra,12(sp)
 201e9a4:	df000215 	stw	fp,8(sp)
 201e9a8:	df000204 	addi	fp,sp,8
 201e9ac:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 201e9b0:	e03ffe15 	stw	zero,-8(fp)
   * reset the device, or whatever, to ensure that
   * it's in a known working state.
  */
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
 201e9b4:	e0bfff17 	ldw	r2,-4(fp)
 201e9b8:	10003115 	stw	zero,196(r2)
  
  /* Send the RES command sequence */
  flash->silicon_id =
    epcs_read_electronic_signature(flash->register_base);
 201e9bc:	e0bfff17 	ldw	r2,-4(fp)
 201e9c0:	10802d17 	ldw	r2,180(r2)
 201e9c4:	1009883a 	mov	r4,r2
 201e9c8:	2021ea40 	call	2021ea4 <epcs_read_electronic_signature>
  
  /* Disable 4-bytes address mode. */
  flash->four_bytes_mode = 0;
  
  /* Send the RES command sequence */
  flash->silicon_id =
 201e9cc:	10c03fcc 	andi	r3,r2,255
 201e9d0:	e0bfff17 	ldw	r2,-4(fp)
 201e9d4:	10c02f15 	stw	r3,188(r2)
    epcs_read_electronic_signature(flash->register_base);

  /* Fill in all device-specific parameters. */
  if (flash->silicon_id == 0x16) /* EPCS64 */
 201e9d8:	e0bfff17 	ldw	r2,-4(fp)
 201e9dc:	10802f17 	ldw	r2,188(r2)
 201e9e0:	10800598 	cmpnei	r2,r2,22
 201e9e4:	10000a1e 	bne	r2,zero,201ea10 <alt_epcs_flash_query+0x74>
  {
    flash->dev.region_info[0].region_size = 64 * 1024 * 1024 / 8;
 201e9e8:	e0bfff17 	ldw	r2,-4(fp)
 201e9ec:	00c02034 	movhi	r3,128
 201e9f0:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 128;
 201e9f4:	e0bfff17 	ldw	r2,-4(fp)
 201e9f8:	00c02004 	movi	r3,128
 201e9fc:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 201ea00:	e0bfff17 	ldw	r2,-4(fp)
 201ea04:	00c00074 	movhi	r3,1
 201ea08:	10c01015 	stw	r3,64(r2)
 201ea0c:	00007306 	br	201ebdc <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x14) /* EPCS16 */
 201ea10:	e0bfff17 	ldw	r2,-4(fp)
 201ea14:	10802f17 	ldw	r2,188(r2)
 201ea18:	10800518 	cmpnei	r2,r2,20
 201ea1c:	10000a1e 	bne	r2,zero,201ea48 <alt_epcs_flash_query+0xac>
  {
    flash->dev.region_info[0].region_size = 16 * 1024 * 1024 / 8;
 201ea20:	e0bfff17 	ldw	r2,-4(fp)
 201ea24:	00c00834 	movhi	r3,32
 201ea28:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 32;
 201ea2c:	e0bfff17 	ldw	r2,-4(fp)
 201ea30:	00c00804 	movi	r3,32
 201ea34:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 201ea38:	e0bfff17 	ldw	r2,-4(fp)
 201ea3c:	00c00074 	movhi	r3,1
 201ea40:	10c01015 	stw	r3,64(r2)
 201ea44:	00006506 	br	201ebdc <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x13) /* EPCS8 */
 201ea48:	e0bfff17 	ldw	r2,-4(fp)
 201ea4c:	10802f17 	ldw	r2,188(r2)
 201ea50:	108004d8 	cmpnei	r2,r2,19
 201ea54:	10000a1e 	bne	r2,zero,201ea80 <alt_epcs_flash_query+0xe4>
  {
    flash->dev.region_info[0].region_size = 8 * 1024 * 1024 / 8;
 201ea58:	e0bfff17 	ldw	r2,-4(fp)
 201ea5c:	00c00434 	movhi	r3,16
 201ea60:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 16;
 201ea64:	e0bfff17 	ldw	r2,-4(fp)
 201ea68:	00c00404 	movi	r3,16
 201ea6c:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 201ea70:	e0bfff17 	ldw	r2,-4(fp)
 201ea74:	00c00074 	movhi	r3,1
 201ea78:	10c01015 	stw	r3,64(r2)
 201ea7c:	00005706 	br	201ebdc <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x12) /* EPCS4 */
 201ea80:	e0bfff17 	ldw	r2,-4(fp)
 201ea84:	10802f17 	ldw	r2,188(r2)
 201ea88:	10800498 	cmpnei	r2,r2,18
 201ea8c:	10000a1e 	bne	r2,zero,201eab8 <alt_epcs_flash_query+0x11c>
  {
    flash->dev.region_info[0].region_size = 4 * 1024 * 1024 / 8;
 201ea90:	e0bfff17 	ldw	r2,-4(fp)
 201ea94:	00c00234 	movhi	r3,8
 201ea98:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 8;
 201ea9c:	e0bfff17 	ldw	r2,-4(fp)
 201eaa0:	00c00204 	movi	r3,8
 201eaa4:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 65536;
 201eaa8:	e0bfff17 	ldw	r2,-4(fp)
 201eaac:	00c00074 	movhi	r3,1
 201eab0:	10c01015 	stw	r3,64(r2)
 201eab4:	00004906 	br	201ebdc <alt_epcs_flash_query+0x240>
  }
  else if (flash->silicon_id == 0x10) /* EPCS1 */
 201eab8:	e0bfff17 	ldw	r2,-4(fp)
 201eabc:	10802f17 	ldw	r2,188(r2)
 201eac0:	10800418 	cmpnei	r2,r2,16
 201eac4:	10000a1e 	bne	r2,zero,201eaf0 <alt_epcs_flash_query+0x154>
  {
    flash->dev.region_info[0].region_size = 1 * 1024 * 1024 / 8;
 201eac8:	e0bfff17 	ldw	r2,-4(fp)
 201eacc:	00c000b4 	movhi	r3,2
 201ead0:	10c00e15 	stw	r3,56(r2)
    flash->dev.region_info[0].number_of_blocks = 4;
 201ead4:	e0bfff17 	ldw	r2,-4(fp)
 201ead8:	00c00104 	movi	r3,4
 201eadc:	10c00f15 	stw	r3,60(r2)
    flash->dev.region_info[0].block_size = 32768;
 201eae0:	e0bfff17 	ldw	r2,-4(fp)
 201eae4:	00e00014 	movui	r3,32768
 201eae8:	10c01015 	stw	r3,64(r2)
 201eaec:	00003b06 	br	201ebdc <alt_epcs_flash_query+0x240>
  {
    /* 
     * Read electronic signature doesn't work for the EPCS128; try 
     * the "Read Device ID" command" before giving up.
     */
    flash->silicon_id = epcs_read_device_id(flash->register_base);
 201eaf0:	e0bfff17 	ldw	r2,-4(fp)
 201eaf4:	10802d17 	ldw	r2,180(r2)
 201eaf8:	1009883a 	mov	r4,r2
 201eafc:	2021f0c0 	call	2021f0c <epcs_read_device_id>
 201eb00:	e0ffff17 	ldw	r3,-4(fp)
 201eb04:	18802f15 	stw	r2,188(r3)
    /*
     * Last byte is the density ID. Note the difference between
     * EPCS128 and EPCQ128 -- arranged differently, though the 
     * least significant byte of each is '0x18'.
     */
    if((flash->silicon_id & 0xFFFFFF) == 0x20BA18) /* EPCQ128 */
 201eb08:	e0bfff17 	ldw	r2,-4(fp)
 201eb0c:	10c02f17 	ldw	r3,188(r2)
 201eb10:	00804034 	movhi	r2,256
 201eb14:	10bfffc4 	addi	r2,r2,-1
 201eb18:	1886703a 	and	r3,r3,r2
 201eb1c:	00800874 	movhi	r2,33
 201eb20:	10ae8604 	addi	r2,r2,-17896
 201eb24:	18800a1e 	bne	r3,r2,201eb50 <alt_epcs_flash_query+0x1b4>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 201eb28:	e0bfff17 	ldw	r2,-4(fp)
 201eb2c:	00c04034 	movhi	r3,256
 201eb30:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 256; /* number of sectors */
 201eb34:	e0bfff17 	ldw	r2,-4(fp)
 201eb38:	00c04004 	movi	r3,256
 201eb3c:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 201eb40:	e0bfff17 	ldw	r2,-4(fp)
 201eb44:	00c00074 	movhi	r3,1
 201eb48:	10c01015 	stw	r3,64(r2)
 201eb4c:	00002306 	br	201ebdc <alt_epcs_flash_query+0x240>
    }
    else if((flash->silicon_id & 0xFF) == 0x18) /* EPCS128 */
 201eb50:	e0bfff17 	ldw	r2,-4(fp)
 201eb54:	10802f17 	ldw	r2,188(r2)
 201eb58:	10803fcc 	andi	r2,r2,255
 201eb5c:	10800618 	cmpnei	r2,r2,24
 201eb60:	10000a1e 	bne	r2,zero,201eb8c <alt_epcs_flash_query+0x1f0>
    {
      flash->dev.region_info[0].region_size = 128 * 1024 * 1024 / 8;
 201eb64:	e0bfff17 	ldw	r2,-4(fp)
 201eb68:	00c04034 	movhi	r3,256
 201eb6c:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 64;
 201eb70:	e0bfff17 	ldw	r2,-4(fp)
 201eb74:	00c01004 	movi	r3,64
 201eb78:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 262144;
 201eb7c:	e0bfff17 	ldw	r2,-4(fp)
 201eb80:	00c00134 	movhi	r3,4
 201eb84:	10c01015 	stw	r3,64(r2)
 201eb88:	00001406 	br	201ebdc <alt_epcs_flash_query+0x240>
    }
    else if((flash->silicon_id & 0xFF ) == 0x19) /* EPCQ256 */
 201eb8c:	e0bfff17 	ldw	r2,-4(fp)
 201eb90:	10802f17 	ldw	r2,188(r2)
 201eb94:	10803fcc 	andi	r2,r2,255
 201eb98:	10800658 	cmpnei	r2,r2,25
 201eb9c:	10000d1e 	bne	r2,zero,201ebd4 <alt_epcs_flash_query+0x238>
    {
      flash->dev.region_info[0].region_size = 256 * 1024 * 1024 / 8;
 201eba0:	e0bfff17 	ldw	r2,-4(fp)
 201eba4:	00c08034 	movhi	r3,512
 201eba8:	10c00e15 	stw	r3,56(r2)
      flash->dev.region_info[0].number_of_blocks = 512; /* number of sectors */
 201ebac:	e0bfff17 	ldw	r2,-4(fp)
 201ebb0:	00c08004 	movi	r3,512
 201ebb4:	10c00f15 	stw	r3,60(r2)
      flash->dev.region_info[0].block_size = 65536;  /* sector size */
 201ebb8:	e0bfff17 	ldw	r2,-4(fp)
 201ebbc:	00c00074 	movhi	r3,1
 201ebc0:	10c01015 	stw	r3,64(r2)
       * must first be programmed into the device, though. To complicate things, 
       * other Altera IP expects the chip to be in 3 byte address mode when they 
       * start using it. To be nice, we'll place the device into 4-byte address mode
       * when we need to, and take it back out when we're done.
       */
      flash->four_bytes_mode = 1;
 201ebc4:	e0bfff17 	ldw	r2,-4(fp)
 201ebc8:	00c00044 	movi	r3,1
 201ebcc:	10c03115 	stw	r3,196(r2)
 201ebd0:	00000206 	br	201ebdc <alt_epcs_flash_query+0x240>
    }
    else 
    {
      ret_code = -ENODEV; /* No known device found! */
 201ebd4:	00bffb44 	movi	r2,-19
 201ebd8:	e0bffe15 	stw	r2,-8(fp)
    }
  }
  
  flash->size_in_bytes = flash->dev.region_info[0].region_size;
 201ebdc:	e0bfff17 	ldw	r2,-4(fp)
 201ebe0:	10800e17 	ldw	r2,56(r2)
 201ebe4:	1007883a 	mov	r3,r2
 201ebe8:	e0bfff17 	ldw	r2,-4(fp)
 201ebec:	10c02e15 	stw	r3,184(r2)
  flash->dev.number_of_regions = 1;
 201ebf0:	e0bfff17 	ldw	r2,-4(fp)
 201ebf4:	00c00044 	movi	r3,1
 201ebf8:	10c00c15 	stw	r3,48(r2)
  flash->dev.region_info[0].offset = 0;
 201ebfc:	e0bfff17 	ldw	r2,-4(fp)
 201ec00:	10000d15 	stw	zero,52(r2)
  flash->page_size = 256;
 201ec04:	e0bfff17 	ldw	r2,-4(fp)
 201ec08:	00c04004 	movi	r3,256
 201ec0c:	10c03015 	stw	r3,192(r2)

  /* Consider clearing all BP bits here. */
  return ret_code;
 201ec10:	e0bffe17 	ldw	r2,-8(fp)
}
 201ec14:	e037883a 	mov	sp,fp
 201ec18:	dfc00117 	ldw	ra,4(sp)
 201ec1c:	df000017 	ldw	fp,0(sp)
 201ec20:	dec00204 	addi	sp,sp,8
 201ec24:	f800283a 	ret

0201ec28 <alt_epcs_flash_memcmp>:
  alt_flash_dev* flash_info,
  const void* src_buffer,
  int offset,
  size_t n
)
{
 201ec28:	deffee04 	addi	sp,sp,-72
 201ec2c:	dfc01115 	stw	ra,68(sp)
 201ec30:	df001015 	stw	fp,64(sp)
 201ec34:	df001004 	addi	fp,sp,64
 201ec38:	e13ffc15 	stw	r4,-16(fp)
 201ec3c:	e17ffd15 	stw	r5,-12(fp)
 201ec40:	e1bffe15 	stw	r6,-8(fp)
 201ec44:	e1ffff15 	stw	r7,-4(fp)
  /*
   * Compare chunks of memory at a time, for better serial-flash
   * read efficiency.
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
 201ec48:	00800804 	movi	r2,32
 201ec4c:	e0bff115 	stw	r2,-60(fp)
  int current_offset = 0;
 201ec50:	e03ff015 	stw	zero,-64(fp)

  while (n > 0)
 201ec54:	00002606 	br	201ecf0 <alt_epcs_flash_memcmp+0xc8>
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
 201ec58:	e0bff117 	ldw	r2,-60(fp)
 201ec5c:	e0ffff17 	ldw	r3,-4(fp)
 201ec60:	1880012e 	bgeu	r3,r2,201ec68 <alt_epcs_flash_memcmp+0x40>
 201ec64:	1805883a 	mov	r2,r3
 201ec68:	e0bff215 	stw	r2,-56(fp)
    int this_chunk_cmp;

    if (
      alt_epcs_flash_read(
 201ec6c:	e0fffe17 	ldw	r3,-8(fp)
 201ec70:	e0bff017 	ldw	r2,-64(fp)
 201ec74:	1887883a 	add	r3,r3,r2
 201ec78:	e0bff404 	addi	r2,fp,-48
 201ec7c:	e13ffc17 	ldw	r4,-16(fp)
 201ec80:	180b883a 	mov	r5,r3
 201ec84:	100d883a 	mov	r6,r2
 201ec88:	e1fff217 	ldw	r7,-56(fp)
 201ec8c:	201f2080 	call	201f208 <alt_epcs_flash_read>
  while (n > 0)
  {
    int this_chunk_size = n > chunk_size ? chunk_size : n;
    int this_chunk_cmp;

    if (
 201ec90:	1000020e 	bge	r2,zero,201ec9c <alt_epcs_flash_memcmp+0x74>
    {
      /*
      * If the read fails, I'm not sure what the appropriate action is.
      * Compare success seems wrong, so make it compare fail.
      */
      return -1;
 201ec94:	00bfffc4 	movi	r2,-1
 201ec98:	00001806 	br	201ecfc <alt_epcs_flash_memcmp+0xd4>
    }

    /* Compare this chunk against the source memory buffer. */
    this_chunk_cmp = memcmp(&((unsigned char*)(src_buffer))[current_offset], chunk_buffer, this_chunk_size);
 201ec9c:	e0bff017 	ldw	r2,-64(fp)
 201eca0:	e0fffd17 	ldw	r3,-12(fp)
 201eca4:	1889883a 	add	r4,r3,r2
 201eca8:	e0bff217 	ldw	r2,-56(fp)
 201ecac:	e0fff404 	addi	r3,fp,-48
 201ecb0:	180b883a 	mov	r5,r3
 201ecb4:	100d883a 	mov	r6,r2
 201ecb8:	200e5b80 	call	200e5b8 <memcmp>
 201ecbc:	e0bff315 	stw	r2,-52(fp)
    if (this_chunk_cmp)
 201ecc0:	e0bff317 	ldw	r2,-52(fp)
 201ecc4:	10000226 	beq	r2,zero,201ecd0 <alt_epcs_flash_memcmp+0xa8>
    {
      return this_chunk_cmp;
 201ecc8:	e0bff317 	ldw	r2,-52(fp)
 201eccc:	00000b06 	br	201ecfc <alt_epcs_flash_memcmp+0xd4>
    }

    n -= this_chunk_size;
 201ecd0:	e0bff217 	ldw	r2,-56(fp)
 201ecd4:	e0ffff17 	ldw	r3,-4(fp)
 201ecd8:	1885c83a 	sub	r2,r3,r2
 201ecdc:	e0bfff15 	stw	r2,-4(fp)
    current_offset += this_chunk_size;
 201ece0:	e0fff017 	ldw	r3,-64(fp)
 201ece4:	e0bff217 	ldw	r2,-56(fp)
 201ece8:	1885883a 	add	r2,r3,r2
 201ecec:	e0bff015 	stw	r2,-64(fp)
   */
  alt_u8 chunk_buffer[32];
  const int chunk_size = sizeof(chunk_buffer) / sizeof(*chunk_buffer);
  int current_offset = 0;

  while (n > 0)
 201ecf0:	e0bfff17 	ldw	r2,-4(fp)
 201ecf4:	103fd81e 	bne	r2,zero,201ec58 <alt_epcs_flash_memcmp+0x30>
  }

  /*
   * If execution made it to this point, compare is successful.
   */
  return 0;
 201ecf8:	0005883a 	mov	r2,zero
}
 201ecfc:	e037883a 	mov	sp,fp
 201ed00:	dfc00117 	ldw	ra,4(sp)
 201ed04:	df000017 	ldw	fp,0(sp)
 201ed08:	dec00204 	addi	sp,sp,8
 201ed0c:	f800283a 	ret

0201ed10 <alt_epcs_flash_write>:
 * large buffer to tie up in our programming library, when not all users will
 * want that functionality.
 */
int alt_epcs_flash_write(alt_flash_dev* flash_info, int offset,
                          const void* src_addr, int length)
{
 201ed10:	defff404 	addi	sp,sp,-48
 201ed14:	dfc00b15 	stw	ra,44(sp)
 201ed18:	df000a15 	stw	fp,40(sp)
 201ed1c:	df000a04 	addi	fp,sp,40
 201ed20:	e13ffc15 	stw	r4,-16(fp)
 201ed24:	e17ffd15 	stw	r5,-12(fp)
 201ed28:	e1bffe15 	stw	r6,-8(fp)
 201ed2c:	e1ffff15 	stw	r7,-4(fp)
  int         ret_code = 0;
 201ed30:	e03ff715 	stw	zero,-36(fp)
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 201ed34:	e03ff815 	stw	zero,-32(fp)
 201ed38:	00008306 	br	201ef48 <alt_epcs_flash_write+0x238>
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 201ed3c:	e0fffc17 	ldw	r3,-16(fp)
 201ed40:	e0bff817 	ldw	r2,-32(fp)
 201ed44:	1004913a 	slli	r2,r2,4
 201ed48:	1885883a 	add	r2,r3,r2
 201ed4c:	10800d04 	addi	r2,r2,52
 201ed50:	10800017 	ldw	r2,0(r2)
 201ed54:	e0fffd17 	ldw	r3,-12(fp)
 201ed58:	18807816 	blt	r3,r2,201ef3c <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
 201ed5c:	e0fffc17 	ldw	r3,-16(fp)
 201ed60:	e0bff817 	ldw	r2,-32(fp)
 201ed64:	1004913a 	slli	r2,r2,4
 201ed68:	1885883a 	add	r2,r3,r2
 201ed6c:	10800d04 	addi	r2,r2,52
 201ed70:	10c00017 	ldw	r3,0(r2)
      flash_info->region_info[i].region_size)))
 201ed74:	e13ffc17 	ldw	r4,-16(fp)
 201ed78:	e0bff817 	ldw	r2,-32(fp)
 201ed7c:	1004913a 	slli	r2,r2,4
 201ed80:	2085883a 	add	r2,r4,r2
 201ed84:	10800e04 	addi	r2,r2,56
 201ed88:	10800017 	ldw	r2,0(r2)
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
      (offset < (flash_info->region_info[i].offset +
 201ed8c:	1885883a 	add	r2,r3,r2
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
  {
    /* Is it in this erase block region?*/
    if((offset >= flash_info->region_info[i].offset) &&
 201ed90:	e0fffd17 	ldw	r3,-12(fp)
 201ed94:	1880690e 	bge	r3,r2,201ef3c <alt_epcs_flash_write+0x22c>
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;
 201ed98:	e0fffc17 	ldw	r3,-16(fp)
 201ed9c:	e0bff817 	ldw	r2,-32(fp)
 201eda0:	1004913a 	slli	r2,r2,4
 201eda4:	1885883a 	add	r2,r3,r2
 201eda8:	10800d04 	addi	r2,r2,52
 201edac:	10800017 	ldw	r2,0(r2)
 201edb0:	e0bffa15 	stw	r2,-24(fp)

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 201edb4:	e03ff915 	stw	zero,-28(fp)
 201edb8:	00005806 	br	201ef1c <alt_epcs_flash_write+0x20c>
      {
        if ((offset >= current_offset ) &&
 201edbc:	e0fffd17 	ldw	r3,-12(fp)
 201edc0:	e0bffa17 	ldw	r2,-24(fp)
 201edc4:	18804916 	blt	r3,r2,201eeec <alt_epcs_flash_write+0x1dc>
            (offset < (current_offset +
            flash_info->region_info[i].block_size)))
 201edc8:	e0fffc17 	ldw	r3,-16(fp)
 201edcc:	e0bff817 	ldw	r2,-32(fp)
 201edd0:	10800104 	addi	r2,r2,4
 201edd4:	1004913a 	slli	r2,r2,4
 201edd8:	1885883a 	add	r2,r3,r2
 201eddc:	10c00017 	ldw	r3,0(r2)
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
            (offset < (current_offset +
 201ede0:	e0bffa17 	ldw	r2,-24(fp)
 201ede4:	1885883a 	add	r2,r3,r2
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
      {
        if ((offset >= current_offset ) &&
 201ede8:	e0fffd17 	ldw	r3,-12(fp)
 201edec:	18803f0e 	bge	r3,r2,201eeec <alt_epcs_flash_write+0x1dc>
        {
          /*
           * Check if the contents of the block are different
           * from the data we wish to put there
           */
          data_to_write = ( current_offset + flash_info->region_info[i].block_size
 201edf0:	e0fffc17 	ldw	r3,-16(fp)
 201edf4:	e0bff817 	ldw	r2,-32(fp)
 201edf8:	10800104 	addi	r2,r2,4
 201edfc:	1004913a 	slli	r2,r2,4
 201ee00:	1885883a 	add	r2,r3,r2
 201ee04:	10c00017 	ldw	r3,0(r2)
 201ee08:	e0bffa17 	ldw	r2,-24(fp)
 201ee0c:	1887883a 	add	r3,r3,r2
 201ee10:	e0bffd17 	ldw	r2,-12(fp)
 201ee14:	1885c83a 	sub	r2,r3,r2
 201ee18:	e0bffb15 	stw	r2,-20(fp)
                            - offset);
          data_to_write = MIN(data_to_write, length);
 201ee1c:	e0fffb17 	ldw	r3,-20(fp)
 201ee20:	e0bfff17 	ldw	r2,-4(fp)
 201ee24:	1880010e 	bge	r3,r2,201ee2c <alt_epcs_flash_write+0x11c>
 201ee28:	1805883a 	mov	r2,r3
 201ee2c:	e0bffb15 	stw	r2,-20(fp)

          if(alt_epcs_flash_memcmp(flash_info, src_addr, offset, data_to_write))
 201ee30:	e0bffb17 	ldw	r2,-20(fp)
 201ee34:	e13ffc17 	ldw	r4,-16(fp)
 201ee38:	e17ffe17 	ldw	r5,-8(fp)
 201ee3c:	e1bffd17 	ldw	r6,-12(fp)
 201ee40:	100f883a 	mov	r7,r2
 201ee44:	201ec280 	call	201ec28 <alt_epcs_flash_memcmp>
 201ee48:	10001226 	beq	r2,zero,201ee94 <alt_epcs_flash_write+0x184>
          {
            ret_code = (*flash_info->erase_block)(flash_info, current_offset);
 201ee4c:	e0bffc17 	ldw	r2,-16(fp)
 201ee50:	10800817 	ldw	r2,32(r2)
 201ee54:	e13ffc17 	ldw	r4,-16(fp)
 201ee58:	e17ffa17 	ldw	r5,-24(fp)
 201ee5c:	103ee83a 	callr	r2
 201ee60:	e0bff715 	stw	r2,-36(fp)

            if (!ret_code)
 201ee64:	e0bff717 	ldw	r2,-36(fp)
 201ee68:	10000a1e 	bne	r2,zero,201ee94 <alt_epcs_flash_write+0x184>
            {
              ret_code = (*flash_info->write_block)(
 201ee6c:	e0bffc17 	ldw	r2,-16(fp)
 201ee70:	10800917 	ldw	r2,36(r2)
 201ee74:	e0fffb17 	ldw	r3,-20(fp)
 201ee78:	d8c00015 	stw	r3,0(sp)
 201ee7c:	e13ffc17 	ldw	r4,-16(fp)
 201ee80:	e17ffa17 	ldw	r5,-24(fp)
 201ee84:	e1bffd17 	ldw	r6,-12(fp)
 201ee88:	e1fffe17 	ldw	r7,-8(fp)
 201ee8c:	103ee83a 	callr	r2
 201ee90:	e0bff715 	stw	r2,-36(fp)
                                                  data_to_write);
            }
          }

          /* Was this the last block? */
          if ((length == data_to_write) || ret_code)
 201ee94:	e0ffff17 	ldw	r3,-4(fp)
 201ee98:	e0bffb17 	ldw	r2,-20(fp)
 201ee9c:	18802e26 	beq	r3,r2,201ef58 <alt_epcs_flash_write+0x248>
 201eea0:	e0bff717 	ldw	r2,-36(fp)
 201eea4:	10002c1e 	bne	r2,zero,201ef58 <alt_epcs_flash_write+0x248>
          {
            goto finished;
          }

          length -= data_to_write;
 201eea8:	e0ffff17 	ldw	r3,-4(fp)
 201eeac:	e0bffb17 	ldw	r2,-20(fp)
 201eeb0:	1885c83a 	sub	r2,r3,r2
 201eeb4:	e0bfff15 	stw	r2,-4(fp)
          offset = current_offset + flash_info->region_info[i].block_size;
 201eeb8:	e0fffc17 	ldw	r3,-16(fp)
 201eebc:	e0bff817 	ldw	r2,-32(fp)
 201eec0:	10800104 	addi	r2,r2,4
 201eec4:	1004913a 	slli	r2,r2,4
 201eec8:	1885883a 	add	r2,r3,r2
 201eecc:	10c00017 	ldw	r3,0(r2)
 201eed0:	e0bffa17 	ldw	r2,-24(fp)
 201eed4:	1885883a 	add	r2,r3,r2
 201eed8:	e0bffd15 	stw	r2,-12(fp)
          src_addr = (alt_u8*)src_addr + data_to_write;
 201eedc:	e0bffb17 	ldw	r2,-20(fp)
 201eee0:	e0fffe17 	ldw	r3,-8(fp)
 201eee4:	1885883a 	add	r2,r3,r2
 201eee8:	e0bffe15 	stw	r2,-8(fp)
        }
        current_offset += flash_info->region_info[i].block_size;
 201eeec:	e0fffc17 	ldw	r3,-16(fp)
 201eef0:	e0bff817 	ldw	r2,-32(fp)
 201eef4:	10800104 	addi	r2,r2,4
 201eef8:	1004913a 	slli	r2,r2,4
 201eefc:	1885883a 	add	r2,r3,r2
 201ef00:	10800017 	ldw	r2,0(r2)
 201ef04:	e0fffa17 	ldw	r3,-24(fp)
 201ef08:	1885883a 	add	r2,r3,r2
 201ef0c:	e0bffa15 	stw	r2,-24(fp)
      (offset < (flash_info->region_info[i].offset +
      flash_info->region_info[i].region_size)))
    {
      current_offset = flash_info->region_info[i].offset;

      for(j=0;j<flash_info->region_info[i].number_of_blocks;j++)
 201ef10:	e0bff917 	ldw	r2,-28(fp)
 201ef14:	10800044 	addi	r2,r2,1
 201ef18:	e0bff915 	stw	r2,-28(fp)
 201ef1c:	e0fffc17 	ldw	r3,-16(fp)
 201ef20:	e0bff817 	ldw	r2,-32(fp)
 201ef24:	1004913a 	slli	r2,r2,4
 201ef28:	1885883a 	add	r2,r3,r2
 201ef2c:	10800f04 	addi	r2,r2,60
 201ef30:	10800017 	ldw	r2,0(r2)
 201ef34:	e0fff917 	ldw	r3,-28(fp)
 201ef38:	18bfa016 	blt	r3,r2,201edbc <alt_epcs_flash_write+0xac>
  int         current_offset;

  /*
   * First and foremost which sectors are affected?
   */
  for(i = 0; i < flash_info->number_of_regions; i++)
 201ef3c:	e0bff817 	ldw	r2,-32(fp)
 201ef40:	10800044 	addi	r2,r2,1
 201ef44:	e0bff815 	stw	r2,-32(fp)
 201ef48:	e0bffc17 	ldw	r2,-16(fp)
 201ef4c:	10800c17 	ldw	r2,48(r2)
 201ef50:	e0fff817 	ldw	r3,-32(fp)
 201ef54:	18bf7916 	blt	r3,r2,201ed3c <alt_epcs_flash_write+0x2c>
      }
    }
  }

finished:
  return ret_code;
 201ef58:	e0bff717 	ldw	r2,-36(fp)
}
 201ef5c:	e037883a 	mov	sp,fp
 201ef60:	dfc00117 	ldw	ra,4(sp)
 201ef64:	df000017 	ldw	fp,0(sp)
 201ef68:	dec00204 	addi	sp,sp,8
 201ef6c:	f800283a 	ret

0201ef70 <alt_epcs_flash_get_info>:
 *
 *  Pass the table of erase blocks to the user
 */
int alt_epcs_flash_get_info(alt_flash_fd* fd, flash_region** info,
                            int* number_of_regions)
{
 201ef70:	defffa04 	addi	sp,sp,-24
 201ef74:	df000515 	stw	fp,20(sp)
 201ef78:	df000504 	addi	fp,sp,20
 201ef7c:	e13ffd15 	stw	r4,-12(fp)
 201ef80:	e17ffe15 	stw	r5,-8(fp)
 201ef84:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = 0;
 201ef88:	e03ffb15 	stw	zero,-20(fp)

  alt_flash_dev* flash = (alt_flash_dev*)fd;
 201ef8c:	e0bffd17 	ldw	r2,-12(fp)
 201ef90:	e0bffc15 	stw	r2,-16(fp)

  *number_of_regions = flash->number_of_regions;
 201ef94:	e0bffc17 	ldw	r2,-16(fp)
 201ef98:	10c00c17 	ldw	r3,48(r2)
 201ef9c:	e0bfff17 	ldw	r2,-4(fp)
 201efa0:	10c00015 	stw	r3,0(r2)

  if (!flash->number_of_regions)
 201efa4:	e0bffc17 	ldw	r2,-16(fp)
 201efa8:	10800c17 	ldw	r2,48(r2)
 201efac:	1000031e 	bne	r2,zero,201efbc <alt_epcs_flash_get_info+0x4c>
  {
    ret_code = -EIO;
 201efb0:	00bffec4 	movi	r2,-5
 201efb4:	e0bffb15 	stw	r2,-20(fp)
 201efb8:	00000b06 	br	201efe8 <alt_epcs_flash_get_info+0x78>
  }
  else if (flash->number_of_regions > ALT_MAX_NUMBER_OF_FLASH_REGIONS)
 201efbc:	e0bffc17 	ldw	r2,-16(fp)
 201efc0:	10800c17 	ldw	r2,48(r2)
 201efc4:	10800250 	cmplti	r2,r2,9
 201efc8:	1000031e 	bne	r2,zero,201efd8 <alt_epcs_flash_get_info+0x68>
  {
    ret_code = -ENOMEM;
 201efcc:	00bffd04 	movi	r2,-12
 201efd0:	e0bffb15 	stw	r2,-20(fp)
 201efd4:	00000406 	br	201efe8 <alt_epcs_flash_get_info+0x78>
  }
  else
  {
    *info = &flash->region_info[0];
 201efd8:	e0bffc17 	ldw	r2,-16(fp)
 201efdc:	10c00d04 	addi	r3,r2,52
 201efe0:	e0bffe17 	ldw	r2,-8(fp)
 201efe4:	10c00015 	stw	r3,0(r2)
  }

  return ret_code;
 201efe8:	e0bffb17 	ldw	r2,-20(fp)
}
 201efec:	e037883a 	mov	sp,fp
 201eff0:	df000017 	ldw	fp,0(sp)
 201eff4:	dec00104 	addi	sp,sp,4
 201eff8:	f800283a 	ret

0201effc <alt_epcs_test_address>:


/* This might be a candidate for optimization.  Precompute the last-address? */
static ALT_INLINE int alt_epcs_test_address(alt_flash_dev* flash_info, int offset)
{
 201effc:	defff904 	addi	sp,sp,-28
 201f000:	df000615 	stw	fp,24(sp)
 201f004:	df000604 	addi	fp,sp,24
 201f008:	e13ffe15 	stw	r4,-8(fp)
 201f00c:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 201f010:	e03ffa15 	stw	zero,-24(fp)
  /* Error checking:
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 201f014:	e0bffe17 	ldw	r2,-8(fp)
 201f018:	e0bffb15 	stw	r2,-20(fp)

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
 201f01c:	e0bffb17 	ldw	r2,-20(fp)
 201f020:	10800c17 	ldw	r2,48(r2)
 201f024:	10bfffc4 	addi	r2,r2,-1
 201f028:	e0bffc15 	stw	r2,-16(fp)
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 201f02c:	e0fffb17 	ldw	r3,-20(fp)
 201f030:	e0bffc17 	ldw	r2,-16(fp)
 201f034:	1004913a 	slli	r2,r2,4
 201f038:	1885883a 	add	r2,r3,r2
 201f03c:	10800d04 	addi	r2,r2,52
 201f040:	10800017 	ldw	r2,0(r2)
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
 201f044:	10ffffc4 	addi	r3,r2,-1
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;
 201f048:	e13ffb17 	ldw	r4,-20(fp)
 201f04c:	e0bffc17 	ldw	r2,-16(fp)
 201f050:	1004913a 	slli	r2,r2,4
 201f054:	2085883a 	add	r2,r4,r2
 201f058:	10800e04 	addi	r2,r2,56
 201f05c:	10800017 	ldw	r2,0(r2)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
    -1 +
    f->dev.region_info[last_region_index].offset +
 201f060:	1885883a 	add	r2,r3,r2
   * if the block offset is outside of the memory, return -EIO.
   */
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;

  const alt_u32 last_region_index = f->dev.number_of_regions - 1;
  alt_u32 last_device_address =
 201f064:	e0bffd15 	stw	r2,-12(fp)
    -1 +
    f->dev.region_info[last_region_index].offset +
    f->dev.region_info[last_region_index].region_size;

  if (offset > last_device_address)
 201f068:	e0bfff17 	ldw	r2,-4(fp)
 201f06c:	e0fffd17 	ldw	r3,-12(fp)
 201f070:	1880022e 	bgeu	r3,r2,201f07c <alt_epcs_test_address+0x80>
  {
    /* Someone tried to erase a block outside of this device's range. */
    ret_code = -EIO;
 201f074:	00bffec4 	movi	r2,-5
 201f078:	e0bffa15 	stw	r2,-24(fp)
  }
  return ret_code;
 201f07c:	e0bffa17 	ldw	r2,-24(fp)
}
 201f080:	e037883a 	mov	sp,fp
 201f084:	df000017 	ldw	fp,0(sp)
 201f088:	dec00104 	addi	sp,sp,4
 201f08c:	f800283a 	ret

0201f090 <alt_epcs_flash_erase_block>:
 *
 * Erase the selected erase block ("sector erase", from the POV
 * of the EPCS data sheet).
 */
int alt_epcs_flash_erase_block(alt_flash_dev* flash_info, int block_offset)
{
 201f090:	defffa04 	addi	sp,sp,-24
 201f094:	dfc00515 	stw	ra,20(sp)
 201f098:	df000415 	stw	fp,16(sp)
 201f09c:	df000404 	addi	fp,sp,16
 201f0a0:	e13ffe15 	stw	r4,-8(fp)
 201f0a4:	e17fff15 	stw	r5,-4(fp)
  int ret_code = 0;
 201f0a8:	e03ffc15 	stw	zero,-16(fp)
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 201f0ac:	e0bffe17 	ldw	r2,-8(fp)
 201f0b0:	e0bffd15 	stw	r2,-12(fp)

  ret_code = alt_epcs_test_address(flash_info, block_offset);
 201f0b4:	e13ffe17 	ldw	r4,-8(fp)
 201f0b8:	e17fff17 	ldw	r5,-4(fp)
 201f0bc:	201effc0 	call	201effc <alt_epcs_test_address>
 201f0c0:	e0bffc15 	stw	r2,-16(fp)

  if (ret_code >= 0)
 201f0c4:	e0bffc17 	ldw	r2,-16(fp)
 201f0c8:	10000816 	blt	r2,zero,201f0ec <alt_epcs_flash_erase_block+0x5c>
  {
    /* Send the Sector Erase command, whose 3 address bytes are anywhere
     * within the chosen sector.
     */
    epcs_sector_erase(f->register_base, block_offset, f->four_bytes_mode);
 201f0cc:	e0bffd17 	ldw	r2,-12(fp)
 201f0d0:	11002d17 	ldw	r4,180(r2)
 201f0d4:	e0ffff17 	ldw	r3,-4(fp)
 201f0d8:	e0bffd17 	ldw	r2,-12(fp)
 201f0dc:	10803117 	ldw	r2,196(r2)
 201f0e0:	180b883a 	mov	r5,r3
 201f0e4:	100d883a 	mov	r6,r2
 201f0e8:	2021ae40 	call	2021ae4 <epcs_sector_erase>
  }
  return ret_code;
 201f0ec:	e0bffc17 	ldw	r2,-16(fp)
}
 201f0f0:	e037883a 	mov	sp,fp
 201f0f4:	dfc00117 	ldw	ra,4(sp)
 201f0f8:	df000017 	ldw	fp,0(sp)
 201f0fc:	dec00204 	addi	sp,sp,8
 201f100:	f800283a 	ret

0201f104 <alt_epcs_flash_write_block>:
 * function type compatibility.
 */
int alt_epcs_flash_write_block(alt_flash_dev* flash_info, int block_offset,
                                      int data_offset, const void* data,
                                      int length)
{
 201f104:	defff404 	addi	sp,sp,-48
 201f108:	dfc00b15 	stw	ra,44(sp)
 201f10c:	df000a15 	stw	fp,40(sp)
 201f110:	df000a04 	addi	fp,sp,40
 201f114:	e13ffc15 	stw	r4,-16(fp)
 201f118:	e17ffd15 	stw	r5,-12(fp)
 201f11c:	e1bffe15 	stw	r6,-8(fp)
 201f120:	e1ffff15 	stw	r7,-4(fp)
  int ret_code;
  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 201f124:	e0bffc17 	ldw	r2,-16(fp)
 201f128:	e0bff815 	stw	r2,-32(fp)

  int buffer_offset = 0;
 201f12c:	e03ff715 	stw	zero,-36(fp)
  int length_of_current_write;
  ret_code = alt_epcs_test_address(flash_info, data_offset);
 201f130:	e13ffc17 	ldw	r4,-16(fp)
 201f134:	e17ffe17 	ldw	r5,-8(fp)
 201f138:	201effc0 	call	201effc <alt_epcs_test_address>
 201f13c:	e0bff915 	stw	r2,-28(fp)

  if (ret_code >= 0)
 201f140:	e0bff917 	ldw	r2,-28(fp)
 201f144:	10002a16 	blt	r2,zero,201f1f0 <alt_epcs_flash_write_block+0xec>
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 201f148:	00002706 	br	201f1e8 <alt_epcs_flash_write_block+0xe4>
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
 201f14c:	e0bff817 	ldw	r2,-32(fp)
 201f150:	10c03017 	ldw	r3,192(r2)
 201f154:	e0bffe17 	ldw	r2,-8(fp)
 201f158:	1887883a 	add	r3,r3,r2
 201f15c:	e0bff817 	ldw	r2,-32(fp)
 201f160:	10803017 	ldw	r2,192(r2)
 201f164:	0085c83a 	sub	r2,zero,r2
 201f168:	1884703a 	and	r2,r3,r2
 201f16c:	e0bffa15 	stw	r2,-24(fp)
      length_of_current_write = MIN(length, next_page_start - data_offset);
 201f170:	e0fffa17 	ldw	r3,-24(fp)
 201f174:	e0bffe17 	ldw	r2,-8(fp)
 201f178:	1885c83a 	sub	r2,r3,r2
 201f17c:	e0c00217 	ldw	r3,8(fp)
 201f180:	1880010e 	bge	r3,r2,201f188 <alt_epcs_flash_write_block+0x84>
 201f184:	1805883a 	mov	r2,r3
 201f188:	e0bffb15 	stw	r2,-20(fp)

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 201f18c:	e0bff817 	ldw	r2,-32(fp)
 201f190:	10c02d17 	ldw	r3,180(r2)
 201f194:	e0bff717 	ldw	r2,-36(fp)
 201f198:	e13fff17 	ldw	r4,-4(fp)
 201f19c:	2085883a 	add	r2,r4,r2
          f->four_bytes_mode);
 201f1a0:	e13ff817 	ldw	r4,-32(fp)
    while (length)
    {
      int next_page_start = (data_offset + f->page_size) & ~(f->page_size - 1);
      length_of_current_write = MIN(length, next_page_start - data_offset);

      epcs_write_buffer(f->register_base, data_offset, &((const alt_u8*)data)[buffer_offset], length_of_current_write,
 201f1a4:	21003117 	ldw	r4,196(r4)
 201f1a8:	d9000015 	stw	r4,0(sp)
 201f1ac:	1809883a 	mov	r4,r3
 201f1b0:	e17ffe17 	ldw	r5,-8(fp)
 201f1b4:	100d883a 	mov	r6,r2
 201f1b8:	e1fffb17 	ldw	r7,-20(fp)
 201f1bc:	2021d880 	call	2021d88 <epcs_write_buffer>
          f->four_bytes_mode);

      length -= length_of_current_write;
 201f1c0:	e0c00217 	ldw	r3,8(fp)
 201f1c4:	e0bffb17 	ldw	r2,-20(fp)
 201f1c8:	1885c83a 	sub	r2,r3,r2
 201f1cc:	e0800215 	stw	r2,8(fp)
      buffer_offset += length_of_current_write;
 201f1d0:	e0fff717 	ldw	r3,-36(fp)
 201f1d4:	e0bffb17 	ldw	r2,-20(fp)
 201f1d8:	1885883a 	add	r2,r3,r2
 201f1dc:	e0bff715 	stw	r2,-36(fp)
      data_offset = next_page_start;
 201f1e0:	e0bffa17 	ldw	r2,-24(fp)
 201f1e4:	e0bffe15 	stw	r2,-8(fp)
  {

    /* "Block" writes must be broken up into the page writes that
     * the device understands.  Partial page writes are allowed.
     */
    while (length)
 201f1e8:	e0800217 	ldw	r2,8(fp)
 201f1ec:	103fd71e 	bne	r2,zero,201f14c <alt_epcs_flash_write_block+0x48>
      length -= length_of_current_write;
      buffer_offset += length_of_current_write;
      data_offset = next_page_start;
    }
  }
  return ret_code;
 201f1f0:	e0bff917 	ldw	r2,-28(fp)
}
 201f1f4:	e037883a 	mov	sp,fp
 201f1f8:	dfc00117 	ldw	ra,4(sp)
 201f1fc:	df000017 	ldw	fp,0(sp)
 201f200:	dec00204 	addi	sp,sp,8
 201f204:	f800283a 	ret

0201f208 <alt_epcs_flash_read>:
 *  to the beginning.  Reads that start beyond the end of the memory are
 *  flagged as errors with EIO (is there a better error code?).
 */
int alt_epcs_flash_read(alt_flash_dev* flash_info, int offset,
                        void* dest_addr, int length)
{
 201f208:	defff704 	addi	sp,sp,-36
 201f20c:	dfc00815 	stw	ra,32(sp)
 201f210:	df000715 	stw	fp,28(sp)
 201f214:	df000704 	addi	fp,sp,28
 201f218:	e13ffc15 	stw	r4,-16(fp)
 201f21c:	e17ffd15 	stw	r5,-12(fp)
 201f220:	e1bffe15 	stw	r6,-8(fp)
 201f224:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = 0;
 201f228:	e03ffa15 	stw	zero,-24(fp)

  alt_flash_epcs_dev *f = (alt_flash_epcs_dev*)flash_info;
 201f22c:	e0bffc17 	ldw	r2,-16(fp)
 201f230:	e0bffb15 	stw	r2,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);
 201f234:	e13ffc17 	ldw	r4,-16(fp)
 201f238:	e17ffd17 	ldw	r5,-12(fp)
 201f23c:	201effc0 	call	201effc <alt_epcs_test_address>
 201f240:	e0bffa15 	stw	r2,-24(fp)

  if (ret_code >= 0)
 201f244:	e0bffa17 	ldw	r2,-24(fp)
 201f248:	10000f16 	blt	r2,zero,201f288 <alt_epcs_flash_read+0x80>
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 201f24c:	e0bffb17 	ldw	r2,-20(fp)
 201f250:	10802d17 	ldw	r2,180(r2)
                                f->four_bytes_mode);
 201f254:	e0fffb17 	ldw	r3,-20(fp)

  ret_code = alt_epcs_test_address(flash_info, offset);

  if (ret_code >= 0)
  {
    ret_code = epcs_read_buffer(f->register_base, offset, dest_addr, length,
 201f258:	18c03117 	ldw	r3,196(r3)
 201f25c:	d8c00015 	stw	r3,0(sp)
 201f260:	1009883a 	mov	r4,r2
 201f264:	e17ffd17 	ldw	r5,-12(fp)
 201f268:	e1bffe17 	ldw	r6,-8(fp)
 201f26c:	e1ffff17 	ldw	r7,-4(fp)
 201f270:	2021bdc0 	call	2021bdc <epcs_read_buffer>
 201f274:	e0bffa15 	stw	r2,-24(fp)
                                f->four_bytes_mode);

    /* epcs_read_buffer returns the number of buffers read, but
     * alt_epcs_flash_read returns 0 on success, <0 on failure.
     */
    if (ret_code == length)
 201f278:	e0fffa17 	ldw	r3,-24(fp)
 201f27c:	e0bfff17 	ldw	r2,-4(fp)
 201f280:	1880011e 	bne	r3,r2,201f288 <alt_epcs_flash_read+0x80>
    {
      ret_code = 0;
 201f284:	e03ffa15 	stw	zero,-24(fp)
    }
  }
  return ret_code;
 201f288:	e0bffa17 	ldw	r2,-24(fp)
}
 201f28c:	e037883a 	mov	sp,fp
 201f290:	dfc00117 	ldw	ra,4(sp)
 201f294:	df000017 	ldw	fp,0(sp)
 201f298:	dec00204 	addi	sp,sp,8
 201f29c:	f800283a 	ret

0201f2a0 <altera_avalon_jtag_uart_read_fd>:
 *
 */

int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
 201f2a0:	defffa04 	addi	sp,sp,-24
 201f2a4:	dfc00515 	stw	ra,20(sp)
 201f2a8:	df000415 	stw	fp,16(sp)
 201f2ac:	df000404 	addi	fp,sp,16
 201f2b0:	e13ffd15 	stw	r4,-12(fp)
 201f2b4:	e17ffe15 	stw	r5,-8(fp)
 201f2b8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 201f2bc:	e0bffd17 	ldw	r2,-12(fp)
 201f2c0:	10800017 	ldw	r2,0(r2)
 201f2c4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 201f2c8:	e0bffc17 	ldw	r2,-16(fp)
 201f2cc:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
 201f2d0:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_read_fd(alt_fd* fd, char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_read(&dev->state, buffer, space,
 201f2d4:	10800217 	ldw	r2,8(r2)
 201f2d8:	1809883a 	mov	r4,r3
 201f2dc:	e17ffe17 	ldw	r5,-8(fp)
 201f2e0:	e1bfff17 	ldw	r6,-4(fp)
 201f2e4:	100f883a 	mov	r7,r2
 201f2e8:	201fa540 	call	201fa54 <altera_avalon_jtag_uart_read>
      fd->fd_flags);
}
 201f2ec:	e037883a 	mov	sp,fp
 201f2f0:	dfc00117 	ldw	ra,4(sp)
 201f2f4:	df000017 	ldw	fp,0(sp)
 201f2f8:	dec00204 	addi	sp,sp,8
 201f2fc:	f800283a 	ret

0201f300 <altera_avalon_jtag_uart_write_fd>:

int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
 201f300:	defffa04 	addi	sp,sp,-24
 201f304:	dfc00515 	stw	ra,20(sp)
 201f308:	df000415 	stw	fp,16(sp)
 201f30c:	df000404 	addi	fp,sp,16
 201f310:	e13ffd15 	stw	r4,-12(fp)
 201f314:	e17ffe15 	stw	r5,-8(fp)
 201f318:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 201f31c:	e0bffd17 	ldw	r2,-12(fp)
 201f320:	10800017 	ldw	r2,0(r2)
 201f324:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 201f328:	e0bffc17 	ldw	r2,-16(fp)
 201f32c:	10c00a04 	addi	r3,r2,40
      fd->fd_flags);
 201f330:	e0bffd17 	ldw	r2,-12(fp)
int 
altera_avalon_jtag_uart_write_fd(alt_fd* fd, const char* buffer, int space)
{
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 

    return altera_avalon_jtag_uart_write(&dev->state, buffer, space,
 201f334:	10800217 	ldw	r2,8(r2)
 201f338:	1809883a 	mov	r4,r3
 201f33c:	e17ffe17 	ldw	r5,-8(fp)
 201f340:	e1bfff17 	ldw	r6,-4(fp)
 201f344:	100f883a 	mov	r7,r2
 201f348:	201fd180 	call	201fd18 <altera_avalon_jtag_uart_write>
      fd->fd_flags);
}
 201f34c:	e037883a 	mov	sp,fp
 201f350:	dfc00117 	ldw	ra,4(sp)
 201f354:	df000017 	ldw	fp,0(sp)
 201f358:	dec00204 	addi	sp,sp,8
 201f35c:	f800283a 	ret

0201f360 <altera_avalon_jtag_uart_close_fd>:

#ifndef ALTERA_AVALON_JTAG_UART_SMALL

int 
altera_avalon_jtag_uart_close_fd(alt_fd* fd)
{
 201f360:	defffc04 	addi	sp,sp,-16
 201f364:	dfc00315 	stw	ra,12(sp)
 201f368:	df000215 	stw	fp,8(sp)
 201f36c:	df000204 	addi	fp,sp,8
 201f370:	e13fff15 	stw	r4,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev; 
 201f374:	e0bfff17 	ldw	r2,-4(fp)
 201f378:	10800017 	ldw	r2,0(r2)
 201f37c:	e0bffe15 	stw	r2,-8(fp)

    return altera_avalon_jtag_uart_close(&dev->state, fd->fd_flags);
 201f380:	e0bffe17 	ldw	r2,-8(fp)
 201f384:	10c00a04 	addi	r3,r2,40
 201f388:	e0bfff17 	ldw	r2,-4(fp)
 201f38c:	10800217 	ldw	r2,8(r2)
 201f390:	1809883a 	mov	r4,r3
 201f394:	100b883a 	mov	r5,r2
 201f398:	201f8f80 	call	201f8f8 <altera_avalon_jtag_uart_close>
}
 201f39c:	e037883a 	mov	sp,fp
 201f3a0:	dfc00117 	ldw	ra,4(sp)
 201f3a4:	df000017 	ldw	fp,0(sp)
 201f3a8:	dec00204 	addi	sp,sp,8
 201f3ac:	f800283a 	ret

0201f3b0 <altera_avalon_jtag_uart_ioctl_fd>:

int 
altera_avalon_jtag_uart_ioctl_fd(alt_fd* fd, int req, void* arg)
{
 201f3b0:	defffa04 	addi	sp,sp,-24
 201f3b4:	dfc00515 	stw	ra,20(sp)
 201f3b8:	df000415 	stw	fp,16(sp)
 201f3bc:	df000404 	addi	fp,sp,16
 201f3c0:	e13ffd15 	stw	r4,-12(fp)
 201f3c4:	e17ffe15 	stw	r5,-8(fp)
 201f3c8:	e1bfff15 	stw	r6,-4(fp)
    altera_avalon_jtag_uart_dev* dev = (altera_avalon_jtag_uart_dev*) fd->dev;
 201f3cc:	e0bffd17 	ldw	r2,-12(fp)
 201f3d0:	10800017 	ldw	r2,0(r2)
 201f3d4:	e0bffc15 	stw	r2,-16(fp)

    return altera_avalon_jtag_uart_ioctl(&dev->state, req, arg);
 201f3d8:	e0bffc17 	ldw	r2,-16(fp)
 201f3dc:	10800a04 	addi	r2,r2,40
 201f3e0:	1009883a 	mov	r4,r2
 201f3e4:	e17ffe17 	ldw	r5,-8(fp)
 201f3e8:	e1bfff17 	ldw	r6,-4(fp)
 201f3ec:	201f9600 	call	201f960 <altera_avalon_jtag_uart_ioctl>
}
 201f3f0:	e037883a 	mov	sp,fp
 201f3f4:	dfc00117 	ldw	ra,4(sp)
 201f3f8:	df000017 	ldw	fp,0(sp)
 201f3fc:	dec00204 	addi	sp,sp,8
 201f400:	f800283a 	ret

0201f404 <altera_avalon_jtag_uart_init>:
 * Return 1 on sucessful IRQ register and 0 on failure.
 */

void altera_avalon_jtag_uart_init(altera_avalon_jtag_uart_state* sp, 
                                  int irq_controller_id, int irq)
{
 201f404:	defff404 	addi	sp,sp,-48
 201f408:	dfc00b15 	stw	ra,44(sp)
 201f40c:	df000a15 	stw	fp,40(sp)
 201f410:	df000a04 	addi	fp,sp,40
 201f414:	e13ffd15 	stw	r4,-12(fp)
 201f418:	e17ffe15 	stw	r5,-8(fp)
 201f41c:	e1bfff15 	stw	r6,-4(fp)
  ALT_FLAG_CREATE(&sp->events, 0);
 201f420:	e0bffd17 	ldw	r2,-12(fp)
 201f424:	10800c04 	addi	r2,r2,48
 201f428:	e0bff715 	stw	r2,-36(fp)
 201f42c:	e03ff80d 	sth	zero,-32(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_flag_create (OS_FLAG_GRP** pgroup, 
               OS_FLAGS flags)
{
  INT8U err;
  *pgroup = OSFlagCreate (flags, &err);
 201f430:	e0fff80b 	ldhu	r3,-32(fp)
 201f434:	e0bffc84 	addi	r2,fp,-14
 201f438:	1809883a 	mov	r4,r3
 201f43c:	100b883a 	mov	r5,r2
 201f440:	20181800 	call	2018180 <OSFlagCreate>
 201f444:	e0fff717 	ldw	r3,-36(fp)
 201f448:	18800015 	stw	r2,0(r3)
  ALT_SEM_CREATE(&sp->read_lock, 1);
 201f44c:	e0bffd17 	ldw	r2,-12(fp)
 201f450:	10800a04 	addi	r2,r2,40
 201f454:	e0bff915 	stw	r2,-28(fp)
 201f458:	00800044 	movi	r2,1
 201f45c:	e0bffa0d 	sth	r2,-24(fp)
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_create (OS_EVENT** sem, 
              INT16U value)
{
  *sem = OSSemCreate (value);
 201f460:	e0bffa0b 	ldhu	r2,-24(fp)
 201f464:	1009883a 	mov	r4,r2
 201f468:	201bca80 	call	201bca8 <OSSemCreate>
 201f46c:	e0fff917 	ldw	r3,-28(fp)
 201f470:	18800015 	stw	r2,0(r3)
  ALT_SEM_CREATE(&sp->write_lock, 1);
 201f474:	e0bffd17 	ldw	r2,-12(fp)
 201f478:	10800b04 	addi	r2,r2,44
 201f47c:	e0bffb15 	stw	r2,-20(fp)
 201f480:	00800044 	movi	r2,1
 201f484:	e0bffc0d 	sth	r2,-16(fp)
 201f488:	e0bffc0b 	ldhu	r2,-16(fp)
 201f48c:	1009883a 	mov	r4,r2
 201f490:	201bca80 	call	201bca8 <OSSemCreate>
 201f494:	e0fffb17 	ldw	r3,-20(fp)
 201f498:	18800015 	stw	r2,0(r3)

  /* enable read interrupts at the device */
  sp->irq_enable = ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 201f49c:	e0bffd17 	ldw	r2,-12(fp)
 201f4a0:	00c00044 	movi	r3,1
 201f4a4:	10c00815 	stw	r3,32(r2)

  IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable); 
 201f4a8:	e0bffd17 	ldw	r2,-12(fp)
 201f4ac:	10800017 	ldw	r2,0(r2)
 201f4b0:	10800104 	addi	r2,r2,4
 201f4b4:	e0fffd17 	ldw	r3,-12(fp)
 201f4b8:	18c00817 	ldw	r3,32(r3)
 201f4bc:	10c00035 	stwio	r3,0(r2)
  
  /* register the interrupt handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, altera_avalon_jtag_uart_irq, 
 201f4c0:	e0fffe17 	ldw	r3,-8(fp)
 201f4c4:	e0bfff17 	ldw	r2,-4(fp)
 201f4c8:	d8000015 	stw	zero,0(sp)
 201f4cc:	1809883a 	mov	r4,r3
 201f4d0:	100b883a 	mov	r5,r2
 201f4d4:	018080b4 	movhi	r6,514
 201f4d8:	31bd5004 	addi	r6,r6,-2752
 201f4dc:	e1fffd17 	ldw	r7,-12(fp)
 201f4e0:	203739c0 	call	203739c <alt_ic_isr_register>
#else
  alt_irq_register(irq, sp, altera_avalon_jtag_uart_irq);
#endif  

  /* Register an alarm to go off every second to check for presence of host */
  sp->host_inactive = 0;
 201f4e4:	e0bffd17 	ldw	r2,-12(fp)
 201f4e8:	10000915 	stw	zero,36(r2)

  if (alt_alarm_start(&sp->alarm, alt_ticks_per_second(), 
 201f4ec:	e0bffd17 	ldw	r2,-12(fp)
 201f4f0:	10c00204 	addi	r3,r2,8
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 201f4f4:	00808174 	movhi	r2,517
 201f4f8:	10909504 	addi	r2,r2,16980
 201f4fc:	10800017 	ldw	r2,0(r2)
 201f500:	1809883a 	mov	r4,r3
 201f504:	100b883a 	mov	r5,r2
 201f508:	018080b4 	movhi	r6,514
 201f50c:	31bdfb04 	addi	r6,r6,-2068
 201f510:	e1fffd17 	ldw	r7,-12(fp)
 201f514:	2036c4c0 	call	2036c4c <alt_alarm_start>
 201f518:	1000040e 	bge	r2,zero,201f52c <altera_avalon_jtag_uart_init+0x128>
    &altera_avalon_jtag_uart_timeout, sp) < 0)
  {
    /* If we can't set the alarm then record "don't know if host present" 
     * and behave as though the host is present.
     */
    sp->timeout = INT_MAX;
 201f51c:	e0bffd17 	ldw	r2,-12(fp)
 201f520:	00e00034 	movhi	r3,32768
 201f524:	18ffffc4 	addi	r3,r3,-1
 201f528:	10c00115 	stw	r3,4(r2)
  }

  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ALARM_REGISTER(sp, sp->base);
}
 201f52c:	e037883a 	mov	sp,fp
 201f530:	dfc00117 	ldw	ra,4(sp)
 201f534:	df000017 	ldw	fp,0(sp)
 201f538:	dec00204 	addi	sp,sp,8
 201f53c:	f800283a 	ret

0201f540 <altera_avalon_jtag_uart_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void altera_avalon_jtag_uart_irq(void* context)
#else
static void altera_avalon_jtag_uart_irq(void* context, alt_u32 id)
#endif
{
 201f540:	defff204 	addi	sp,sp,-56
 201f544:	dfc00d15 	stw	ra,52(sp)
 201f548:	df000c15 	stw	fp,48(sp)
 201f54c:	df000c04 	addi	fp,sp,48
 201f550:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state*) context;
 201f554:	e0bfff17 	ldw	r2,-4(fp)
 201f558:	e0bff615 	stw	r2,-40(fp)
  unsigned int base = sp->base;
 201f55c:	e0bff617 	ldw	r2,-40(fp)
 201f560:	10800017 	ldw	r2,0(r2)
 201f564:	e0bff715 	stw	r2,-36(fp)
 201f568:	00000106 	br	201f570 <altera_avalon_jtag_uart_irq+0x30>
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
 201f56c:	0001883a 	nop
  /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */ 
  ALT_LOG_JTAG_UART_ISR_FUNCTION(base, sp);

  for ( ; ; )
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 201f570:	e0bff717 	ldw	r2,-36(fp)
 201f574:	10800104 	addi	r2,r2,4
 201f578:	10800037 	ldwio	r2,0(r2)
 201f57c:	e0bff815 	stw	r2,-32(fp)

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
 201f580:	e0bff817 	ldw	r2,-32(fp)
 201f584:	1080c00c 	andi	r2,r2,768
 201f588:	10009226 	beq	r2,zero,201f7d4 <altera_avalon_jtag_uart_irq+0x294>
      break;

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK)
 201f58c:	e0bff817 	ldw	r2,-32(fp)
 201f590:	1080400c 	andi	r2,r2,256
 201f594:	10004826 	beq	r2,zero,201f6b8 <altera_avalon_jtag_uart_irq+0x178>
    {
      /* process a read irq.  Start by assuming that there is data in the
       * receive FIFO (otherwise why would we have been interrupted?)
       */
      unsigned int data = 1 << ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_OFST;
 201f598:	00800074 	movhi	r2,1
 201f59c:	e0bff415 	stw	r2,-48(fp)
 201f5a0:	00000106 	br	201f5a8 <altera_avalon_jtag_uart_irq+0x68>
        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }
 201f5a4:	0001883a 	nop
      for ( ; ; )
      {
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201f5a8:	e0bff617 	ldw	r2,-40(fp)
 201f5ac:	10800d17 	ldw	r2,52(r2)
 201f5b0:	10800044 	addi	r2,r2,1
 201f5b4:	1081ffcc 	andi	r2,r2,2047
 201f5b8:	e0bff915 	stw	r2,-28(fp)
        if (next == sp->rx_out)
 201f5bc:	e0bff617 	ldw	r2,-40(fp)
 201f5c0:	10c00e17 	ldw	r3,56(r2)
 201f5c4:	e0bff917 	ldw	r2,-28(fp)
 201f5c8:	18802726 	beq	r3,r2,201f668 <altera_avalon_jtag_uart_irq+0x128>
          break;

        /* Try to remove a character from the FIFO and find out whether there
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
 201f5cc:	e0bff717 	ldw	r2,-36(fp)
 201f5d0:	10800037 	ldwio	r2,0(r2)
 201f5d4:	e0bff415 	stw	r2,-48(fp)
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
 201f5d8:	e0bff417 	ldw	r2,-48(fp)
 201f5dc:	10a0000c 	andi	r2,r2,32768
 201f5e0:	10002326 	beq	r2,zero,201f670 <altera_avalon_jtag_uart_irq+0x130>
          break;

        sp->rx_buf[sp->rx_in] = (data & ALTERA_AVALON_JTAG_UART_DATA_DATA_MSK) >> ALTERA_AVALON_JTAG_UART_DATA_DATA_OFST;
 201f5e4:	e0bff617 	ldw	r2,-40(fp)
 201f5e8:	10800d17 	ldw	r2,52(r2)
 201f5ec:	e0fff417 	ldw	r3,-48(fp)
 201f5f0:	e13ff617 	ldw	r4,-40(fp)
 201f5f4:	2085883a 	add	r2,r4,r2
 201f5f8:	10801104 	addi	r2,r2,68
 201f5fc:	10c00005 	stb	r3,0(r2)
        sp->rx_in = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201f600:	e0bff617 	ldw	r2,-40(fp)
 201f604:	10800d17 	ldw	r2,52(r2)
 201f608:	10800044 	addi	r2,r2,1
 201f60c:	10c1ffcc 	andi	r3,r2,2047
 201f610:	e0bff617 	ldw	r2,-40(fp)
 201f614:	10c00d15 	stw	r3,52(r2)

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
 201f618:	e0bff617 	ldw	r2,-40(fp)
 201f61c:	10800c17 	ldw	r2,48(r2)
 201f620:	e0bffa15 	stw	r2,-24(fp)
 201f624:	00800044 	movi	r2,1
 201f628:	e0bffb0d 	sth	r2,-20(fp)
 201f62c:	00800044 	movi	r2,1
 201f630:	e0bffb85 	stb	r2,-18(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 201f634:	00808174 	movhi	r2,517
 201f638:	10909b44 	addi	r2,r2,17005
 201f63c:	10800003 	ldbu	r2,0(r2)
 201f640:	10803fcc 	andi	r2,r2,255
 201f644:	103fd726 	beq	r2,zero,201f5a4 <altera_avalon_jtag_uart_irq+0x64>
  {
    OSFlagPost (group, flags, opt, &err);
 201f648:	e17ffb0b 	ldhu	r5,-20(fp)
 201f64c:	e0fffb83 	ldbu	r3,-18(fp)
 201f650:	e0bffdc4 	addi	r2,fp,-9
 201f654:	e13ffa17 	ldw	r4,-24(fp)
 201f658:	180d883a 	mov	r6,r3
 201f65c:	100f883a 	mov	r7,r2
 201f660:	2018e040 	call	2018e04 <OSFlagPost>
      }
 201f664:	003fcf06 	br	201f5a4 <altera_avalon_jtag_uart_irq+0x64>
        /* Check whether there is space in the buffer.  If not then we must not
         * read any characters from the buffer as they will be lost.
         */
        unsigned int next = (sp->rx_in + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
        if (next == sp->rx_out)
          break;
 201f668:	0001883a 	nop
 201f66c:	00000106 	br	201f674 <altera_avalon_jtag_uart_irq+0x134>
         * are any more characters remaining.
         */
        data = IORD_ALTERA_AVALON_JTAG_UART_DATA(base);
        
        if ((data & ALTERA_AVALON_JTAG_UART_DATA_RVALID_MSK) == 0)
          break;
 201f670:	0001883a 	nop

        /* Post an event to notify jtag_uart_read that a character has been read */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_READ_RDY, OS_FLAG_SET);
      }

      if (data & ALTERA_AVALON_JTAG_UART_DATA_RAVAIL_MSK)
 201f674:	e0bff417 	ldw	r2,-48(fp)
 201f678:	10bfffec 	andhi	r2,r2,65535
 201f67c:	10000e26 	beq	r2,zero,201f6b8 <altera_avalon_jtag_uart_irq+0x178>
      {
        /* If there is still data available here then the buffer is full 
         * so turn off receive interrupts until some space becomes available.
         */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 201f680:	e0bff617 	ldw	r2,-40(fp)
 201f684:	10c00817 	ldw	r3,32(r2)
 201f688:	00bfff84 	movi	r2,-2
 201f68c:	1886703a 	and	r3,r3,r2
 201f690:	e0bff617 	ldw	r2,-40(fp)
 201f694:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(base, sp->irq_enable);
 201f698:	e0bff717 	ldw	r2,-36(fp)
 201f69c:	10800104 	addi	r2,r2,4
 201f6a0:	e0fff617 	ldw	r3,-40(fp)
 201f6a4:	18c00817 	ldw	r3,32(r3)
 201f6a8:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 201f6ac:	e0bff717 	ldw	r2,-36(fp)
 201f6b0:	10800104 	addi	r2,r2,4
 201f6b4:	10800037 	ldwio	r2,0(r2)
      }
    }

    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
 201f6b8:	e0bff817 	ldw	r2,-32(fp)
 201f6bc:	1080800c 	andi	r2,r2,512
 201f6c0:	103faa26 	beq	r2,zero,201f56c <altera_avalon_jtag_uart_irq+0x2c>
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;
 201f6c4:	e0bff817 	ldw	r2,-32(fp)
 201f6c8:	1004d43a 	srli	r2,r2,16
 201f6cc:	e0bff515 	stw	r2,-44(fp)

      while (space > 0 && sp->tx_out != sp->tx_in)
 201f6d0:	00002706 	br	201f770 <altera_avalon_jtag_uart_irq+0x230>
      {
        IOWR_ALTERA_AVALON_JTAG_UART_DATA(base, sp->tx_buf[sp->tx_out]);
 201f6d4:	e0bff717 	ldw	r2,-36(fp)
 201f6d8:	e0fff617 	ldw	r3,-40(fp)
 201f6dc:	18c01017 	ldw	r3,64(r3)
 201f6e0:	e13ff617 	ldw	r4,-40(fp)
 201f6e4:	20c7883a 	add	r3,r4,r3
 201f6e8:	18c21104 	addi	r3,r3,2116
 201f6ec:	18c00003 	ldbu	r3,0(r3)
 201f6f0:	18c03fcc 	andi	r3,r3,255
 201f6f4:	18c0201c 	xori	r3,r3,128
 201f6f8:	18ffe004 	addi	r3,r3,-128
 201f6fc:	10c00035 	stwio	r3,0(r2)

        sp->tx_out = (sp->tx_out + 1) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201f700:	e0bff617 	ldw	r2,-40(fp)
 201f704:	10801017 	ldw	r2,64(r2)
 201f708:	10800044 	addi	r2,r2,1
 201f70c:	10c1ffcc 	andi	r3,r2,2047
 201f710:	e0bff617 	ldw	r2,-40(fp)
 201f714:	10c01015 	stw	r3,64(r2)

        /* Post an event to notify jtag_uart_write that a character has been written */
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);
 201f718:	e0bff617 	ldw	r2,-40(fp)
 201f71c:	10800c17 	ldw	r2,48(r2)
 201f720:	e0bffc15 	stw	r2,-16(fp)
 201f724:	00800084 	movi	r2,2
 201f728:	e0bffd0d 	sth	r2,-12(fp)
 201f72c:	00800044 	movi	r2,1
 201f730:	e0bffd85 	stb	r2,-10(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 201f734:	00808174 	movhi	r2,517
 201f738:	10909b44 	addi	r2,r2,17005
 201f73c:	10800003 	ldbu	r2,0(r2)
 201f740:	10803fcc 	andi	r2,r2,255
 201f744:	10000726 	beq	r2,zero,201f764 <altera_avalon_jtag_uart_irq+0x224>
  {
    OSFlagPost (group, flags, opt, &err);
 201f748:	e17ffd0b 	ldhu	r5,-12(fp)
 201f74c:	e0fffd83 	ldbu	r3,-10(fp)
 201f750:	e0bffe04 	addi	r2,fp,-8
 201f754:	e13ffc17 	ldw	r4,-16(fp)
 201f758:	180d883a 	mov	r6,r3
 201f75c:	100f883a 	mov	r7,r2
 201f760:	2018e040 	call	2018e04 <OSFlagPost>

        space--;
 201f764:	e0bff517 	ldw	r2,-44(fp)
 201f768:	10bfffc4 	addi	r2,r2,-1
 201f76c:	e0bff515 	stw	r2,-44(fp)
    if (control & ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)
    {
      /* process a write irq */
      unsigned int space = (control & ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_MSK) >> ALTERA_AVALON_JTAG_UART_CONTROL_WSPACE_OFST;

      while (space > 0 && sp->tx_out != sp->tx_in)
 201f770:	e0bff517 	ldw	r2,-44(fp)
 201f774:	10000526 	beq	r2,zero,201f78c <altera_avalon_jtag_uart_irq+0x24c>
 201f778:	e0bff617 	ldw	r2,-40(fp)
 201f77c:	10c01017 	ldw	r3,64(r2)
 201f780:	e0bff617 	ldw	r2,-40(fp)
 201f784:	10800f17 	ldw	r2,60(r2)
 201f788:	18bfd21e 	bne	r3,r2,201f6d4 <altera_avalon_jtag_uart_irq+0x194>
        ALT_FLAG_POST (sp->events, ALT_JTAG_UART_WRITE_RDY, OS_FLAG_SET);

        space--;
      }

      if (space > 0)
 201f78c:	e0bff517 	ldw	r2,-44(fp)
 201f790:	103f7626 	beq	r2,zero,201f56c <altera_avalon_jtag_uart_irq+0x2c>
      {
        /* If we don't have any more data available then turn off the TX interrupt */
        sp->irq_enable &= ~ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 201f794:	e0bff617 	ldw	r2,-40(fp)
 201f798:	10c00817 	ldw	r3,32(r2)
 201f79c:	00bfff44 	movi	r2,-3
 201f7a0:	1886703a 	and	r3,r3,r2
 201f7a4:	e0bff617 	ldw	r2,-40(fp)
 201f7a8:	10c00815 	stw	r3,32(r2)
        IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 201f7ac:	e0bff617 	ldw	r2,-40(fp)
 201f7b0:	10800017 	ldw	r2,0(r2)
 201f7b4:	10800104 	addi	r2,r2,4
 201f7b8:	e0fff617 	ldw	r3,-40(fp)
 201f7bc:	18c00817 	ldw	r3,32(r3)
 201f7c0:	10c00035 	stwio	r3,0(r2)
        
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
 201f7c4:	e0bff717 	ldw	r2,-36(fp)
 201f7c8:	10800104 	addi	r2,r2,4
 201f7cc:	10800037 	ldwio	r2,0(r2)
      }
    }
  }
 201f7d0:	003f6606 	br	201f56c <altera_avalon_jtag_uart_irq+0x2c>
  {
    unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);

    /* Return once nothing more to do */
    if ((control & (ALTERA_AVALON_JTAG_UART_CONTROL_RI_MSK | ALTERA_AVALON_JTAG_UART_CONTROL_WI_MSK)) == 0)
      break;
 201f7d4:	0001883a 	nop
        /* Dummy read to ensure IRQ is cleared prior to ISR completion */
        IORD_ALTERA_AVALON_JTAG_UART_CONTROL(base);
      }
    }
  }
}
 201f7d8:	e037883a 	mov	sp,fp
 201f7dc:	dfc00117 	ldw	ra,4(sp)
 201f7e0:	df000017 	ldw	fp,0(sp)
 201f7e4:	dec00204 	addi	sp,sp,8
 201f7e8:	f800283a 	ret

0201f7ec <altera_avalon_jtag_uart_timeout>:
 * Timeout routine is called every second
 */

static alt_u32 
altera_avalon_jtag_uart_timeout(void* context) 
{
 201f7ec:	defff904 	addi	sp,sp,-28
 201f7f0:	dfc00615 	stw	ra,24(sp)
 201f7f4:	df000515 	stw	fp,20(sp)
 201f7f8:	df000504 	addi	fp,sp,20
 201f7fc:	e13fff15 	stw	r4,-4(fp)
  altera_avalon_jtag_uart_state* sp = (altera_avalon_jtag_uart_state *) context;
 201f800:	e0bfff17 	ldw	r2,-4(fp)
 201f804:	e0bffb15 	stw	r2,-20(fp)

  unsigned int control = IORD_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base);
 201f808:	e0bffb17 	ldw	r2,-20(fp)
 201f80c:	10800017 	ldw	r2,0(r2)
 201f810:	10800104 	addi	r2,r2,4
 201f814:	10800037 	ldwio	r2,0(r2)
 201f818:	e0bffc15 	stw	r2,-16(fp)

  if (control & ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK)
 201f81c:	e0bffc17 	ldw	r2,-16(fp)
 201f820:	1081000c 	andi	r2,r2,1024
 201f824:	10000a26 	beq	r2,zero,201f850 <altera_avalon_jtag_uart_timeout+0x64>
  {
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable | ALTERA_AVALON_JTAG_UART_CONTROL_AC_MSK);
 201f828:	e0bffb17 	ldw	r2,-20(fp)
 201f82c:	10800017 	ldw	r2,0(r2)
 201f830:	10800104 	addi	r2,r2,4
 201f834:	e0fffb17 	ldw	r3,-20(fp)
 201f838:	18c00817 	ldw	r3,32(r3)
 201f83c:	18c10014 	ori	r3,r3,1024
 201f840:	10c00035 	stwio	r3,0(r2)
    sp->host_inactive = 0;
 201f844:	e0bffb17 	ldw	r2,-20(fp)
 201f848:	10000915 	stw	zero,36(r2)
 201f84c:	00002206 	br	201f8d8 <altera_avalon_jtag_uart_timeout+0xec>
  }
  else if (sp->host_inactive < INT_MAX - 2) {
 201f850:	e0bffb17 	ldw	r2,-20(fp)
 201f854:	10800917 	ldw	r2,36(r2)
 201f858:	00e00034 	movhi	r3,32768
 201f85c:	18ffff04 	addi	r3,r3,-4
 201f860:	18801d36 	bltu	r3,r2,201f8d8 <altera_avalon_jtag_uart_timeout+0xec>
    sp->host_inactive++;
 201f864:	e0bffb17 	ldw	r2,-20(fp)
 201f868:	10800917 	ldw	r2,36(r2)
 201f86c:	10c00044 	addi	r3,r2,1
 201f870:	e0bffb17 	ldw	r2,-20(fp)
 201f874:	10c00915 	stw	r3,36(r2)
    
    if (sp->host_inactive >= sp->timeout) {
 201f878:	e0bffb17 	ldw	r2,-20(fp)
 201f87c:	10c00917 	ldw	r3,36(r2)
 201f880:	e0bffb17 	ldw	r2,-20(fp)
 201f884:	10800117 	ldw	r2,4(r2)
 201f888:	18801336 	bltu	r3,r2,201f8d8 <altera_avalon_jtag_uart_timeout+0xec>
      /* Post an event to indicate host is inactive (for jtag_uart_read */
      ALT_FLAG_POST (sp->events, ALT_JTAG_UART_TIMEOUT, OS_FLAG_SET);
 201f88c:	e0bffb17 	ldw	r2,-20(fp)
 201f890:	10800c17 	ldw	r2,48(r2)
 201f894:	e0bffd15 	stw	r2,-12(fp)
 201f898:	00800104 	movi	r2,4
 201f89c:	e0bffe0d 	sth	r2,-8(fp)
 201f8a0:	00800044 	movi	r2,1
 201f8a4:	e0bffe85 	stb	r2,-6(fp)
                   OS_FLAGS     flags, 
                   INT8U        opt)
{
  INT8U err;

  if (OSRunning)
 201f8a8:	00808174 	movhi	r2,517
 201f8ac:	10909b44 	addi	r2,r2,17005
 201f8b0:	10800003 	ldbu	r2,0(r2)
 201f8b4:	10803fcc 	andi	r2,r2,255
 201f8b8:	10000726 	beq	r2,zero,201f8d8 <altera_avalon_jtag_uart_timeout+0xec>
  {
    OSFlagPost (group, flags, opt, &err);
 201f8bc:	e17ffe0b 	ldhu	r5,-8(fp)
 201f8c0:	e0fffe83 	ldbu	r3,-6(fp)
 201f8c4:	e0bffec4 	addi	r2,fp,-5
 201f8c8:	e13ffd17 	ldw	r4,-12(fp)
 201f8cc:	180d883a 	mov	r6,r3
 201f8d0:	100f883a 	mov	r7,r2
 201f8d4:	2018e040 	call	2018e04 <OSFlagPost>
 201f8d8:	00808174 	movhi	r2,517
 201f8dc:	10909504 	addi	r2,r2,16980
 201f8e0:	10800017 	ldw	r2,0(r2)
    }
  }

  return alt_ticks_per_second();
}
 201f8e4:	e037883a 	mov	sp,fp
 201f8e8:	dfc00117 	ldw	ra,4(sp)
 201f8ec:	df000017 	ldw	fp,0(sp)
 201f8f0:	dec00204 	addi	sp,sp,8
 201f8f4:	f800283a 	ret

0201f8f8 <altera_avalon_jtag_uart_close>:
 * The close routine is not implemented for the small driver; instead it will
 * map to null. This is because the small driver simply waits while characters
 * are transmitted; there is no interrupt-serviced buffer to empty 
 */
int altera_avalon_jtag_uart_close(altera_avalon_jtag_uart_state* sp, int flags)
{
 201f8f8:	defffd04 	addi	sp,sp,-12
 201f8fc:	df000215 	stw	fp,8(sp)
 201f900:	df000204 	addi	fp,sp,8
 201f904:	e13ffe15 	stw	r4,-8(fp)
 201f908:	e17fff15 	stw	r5,-4(fp)
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 201f90c:	00000506 	br	201f924 <altera_avalon_jtag_uart_close+0x2c>
    if (flags & O_NONBLOCK) {
 201f910:	e0bfff17 	ldw	r2,-4(fp)
 201f914:	1090000c 	andi	r2,r2,16384
 201f918:	10000226 	beq	r2,zero,201f924 <altera_avalon_jtag_uart_close+0x2c>
      return -EWOULDBLOCK; 
 201f91c:	00bffd44 	movi	r2,-11
 201f920:	00000b06 	br	201f950 <altera_avalon_jtag_uart_close+0x58>
{
  /* 
   * Wait for all transmit data to be emptied by the JTAG UART ISR, or
   * for a host-inactivity timeout, in which case transmit data will be lost
   */
  while ( (sp->tx_out != sp->tx_in) && (sp->host_inactive < sp->timeout) ) {
 201f924:	e0bffe17 	ldw	r2,-8(fp)
 201f928:	10c01017 	ldw	r3,64(r2)
 201f92c:	e0bffe17 	ldw	r2,-8(fp)
 201f930:	10800f17 	ldw	r2,60(r2)
 201f934:	18800526 	beq	r3,r2,201f94c <altera_avalon_jtag_uart_close+0x54>
 201f938:	e0bffe17 	ldw	r2,-8(fp)
 201f93c:	10c00917 	ldw	r3,36(r2)
 201f940:	e0bffe17 	ldw	r2,-8(fp)
 201f944:	10800117 	ldw	r2,4(r2)
 201f948:	18bff136 	bltu	r3,r2,201f910 <altera_avalon_jtag_uart_close+0x18>
    if (flags & O_NONBLOCK) {
      return -EWOULDBLOCK; 
    }
  }

  return 0;
 201f94c:	0005883a 	mov	r2,zero
}
 201f950:	e037883a 	mov	sp,fp
 201f954:	df000017 	ldw	fp,0(sp)
 201f958:	dec00104 	addi	sp,sp,4
 201f95c:	f800283a 	ret

0201f960 <altera_avalon_jtag_uart_ioctl>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_ioctl(altera_avalon_jtag_uart_state* sp, int req,
  void* arg)
{
 201f960:	defffa04 	addi	sp,sp,-24
 201f964:	df000515 	stw	fp,20(sp)
 201f968:	df000504 	addi	fp,sp,20
 201f96c:	e13ffd15 	stw	r4,-12(fp)
 201f970:	e17ffe15 	stw	r5,-8(fp)
 201f974:	e1bfff15 	stw	r6,-4(fp)
  int rc = -ENOTTY;
 201f978:	00bff9c4 	movi	r2,-25
 201f97c:	e0bffb15 	stw	r2,-20(fp)

  switch (req)
 201f980:	e0bffe17 	ldw	r2,-8(fp)
 201f984:	10da8060 	cmpeqi	r3,r2,27137
 201f988:	1800031e 	bne	r3,zero,201f998 <altera_avalon_jtag_uart_ioctl+0x38>
 201f98c:	109a80a0 	cmpeqi	r2,r2,27138
 201f990:	1000181e 	bne	r2,zero,201f9f4 <altera_avalon_jtag_uart_ioctl+0x94>
 201f994:	00002606 	br	201fa30 <altera_avalon_jtag_uart_ioctl+0xd0>
  {
  case TIOCSTIMEOUT:
    /* Set the time to wait until assuming host is not connected */
    if (sp->timeout != INT_MAX)
 201f998:	e0bffd17 	ldw	r2,-12(fp)
 201f99c:	10c00117 	ldw	r3,4(r2)
 201f9a0:	00a00034 	movhi	r2,32768
 201f9a4:	10bfffc4 	addi	r2,r2,-1
 201f9a8:	18802226 	beq	r3,r2,201fa34 <altera_avalon_jtag_uart_ioctl+0xd4>
    {
      int timeout = *((int *)arg);
 201f9ac:	e0bfff17 	ldw	r2,-4(fp)
 201f9b0:	10800017 	ldw	r2,0(r2)
 201f9b4:	e0bffc15 	stw	r2,-16(fp)
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
 201f9b8:	e0bffc17 	ldw	r2,-16(fp)
 201f9bc:	10800090 	cmplti	r2,r2,2
 201f9c0:	1000061e 	bne	r2,zero,201f9dc <altera_avalon_jtag_uart_ioctl+0x7c>
 201f9c4:	e0fffc17 	ldw	r3,-16(fp)
 201f9c8:	00a00034 	movhi	r2,32768
 201f9cc:	10bfffc4 	addi	r2,r2,-1
 201f9d0:	18800226 	beq	r3,r2,201f9dc <altera_avalon_jtag_uart_ioctl+0x7c>
 201f9d4:	e0bffc17 	ldw	r2,-16(fp)
 201f9d8:	00000206 	br	201f9e4 <altera_avalon_jtag_uart_ioctl+0x84>
 201f9dc:	00a00034 	movhi	r2,32768
 201f9e0:	10bfff84 	addi	r2,r2,-2
 201f9e4:	e0fffd17 	ldw	r3,-12(fp)
 201f9e8:	18800115 	stw	r2,4(r3)
      rc = 0;
 201f9ec:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 201f9f0:	00001006 	br	201fa34 <altera_avalon_jtag_uart_ioctl+0xd4>

  case TIOCGCONNECTED:
    /* Find out whether host is connected */
    if (sp->timeout != INT_MAX)
 201f9f4:	e0bffd17 	ldw	r2,-12(fp)
 201f9f8:	10c00117 	ldw	r3,4(r2)
 201f9fc:	00a00034 	movhi	r2,32768
 201fa00:	10bfffc4 	addi	r2,r2,-1
 201fa04:	18800d26 	beq	r3,r2,201fa3c <altera_avalon_jtag_uart_ioctl+0xdc>
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
 201fa08:	e0bffd17 	ldw	r2,-12(fp)
 201fa0c:	10c00917 	ldw	r3,36(r2)
 201fa10:	e0bffd17 	ldw	r2,-12(fp)
 201fa14:	10800117 	ldw	r2,4(r2)
 201fa18:	1885803a 	cmpltu	r2,r3,r2
 201fa1c:	10c03fcc 	andi	r3,r2,255
 201fa20:	e0bfff17 	ldw	r2,-4(fp)
 201fa24:	10c00015 	stw	r3,0(r2)
      rc = 0;
 201fa28:	e03ffb15 	stw	zero,-20(fp)
    }
    break;
 201fa2c:	00000306 	br	201fa3c <altera_avalon_jtag_uart_ioctl+0xdc>

  default:
    break;
 201fa30:	00000306 	br	201fa40 <altera_avalon_jtag_uart_ioctl+0xe0>
    {
      int timeout = *((int *)arg);
      sp->timeout = (timeout >= 2 && timeout < INT_MAX) ? timeout : INT_MAX - 1;
      rc = 0;
    }
    break;
 201fa34:	0001883a 	nop
 201fa38:	00000106 	br	201fa40 <altera_avalon_jtag_uart_ioctl+0xe0>
    if (sp->timeout != INT_MAX)
    {
      *((int *)arg) = (sp->host_inactive < sp->timeout) ? 1 : 0;
      rc = 0;
    }
    break;
 201fa3c:	0001883a 	nop

  default:
    break;
  }

  return rc;
 201fa40:	e0bffb17 	ldw	r2,-20(fp)
}
 201fa44:	e037883a 	mov	sp,fp
 201fa48:	df000017 	ldw	fp,0(sp)
 201fa4c:	dec00104 	addi	sp,sp,4
 201fa50:	f800283a 	ret

0201fa54 <altera_avalon_jtag_uart_read>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_read(altera_avalon_jtag_uart_state* sp, 
  char * buffer, int space, int flags)
{
 201fa54:	deffec04 	addi	sp,sp,-80
 201fa58:	dfc01315 	stw	ra,76(sp)
 201fa5c:	df001215 	stw	fp,72(sp)
 201fa60:	df001204 	addi	fp,sp,72
 201fa64:	e13ffc15 	stw	r4,-16(fp)
 201fa68:	e17ffd15 	stw	r5,-12(fp)
 201fa6c:	e1bffe15 	stw	r6,-8(fp)
 201fa70:	e1ffff15 	stw	r7,-4(fp)
  char * ptr = buffer;
 201fa74:	e0bffd17 	ldw	r2,-12(fp)
 201fa78:	e0bfef15 	stw	r2,-68(fp)

  /*
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);
 201fa7c:	e0bffc17 	ldw	r2,-16(fp)
 201fa80:	10800a17 	ldw	r2,40(r2)
 201fa84:	e0bff415 	stw	r2,-48(fp)
 201fa88:	e03ff50d 	sth	zero,-44(fp)

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sem_pend (OS_EVENT* sem, 
                  INT16U timeout)
{
  INT8U err;
  OSSemPend (sem, timeout, &err);
 201fa8c:	e0fff50b 	ldhu	r3,-44(fp)
 201fa90:	e0bffb04 	addi	r2,fp,-20
 201fa94:	e13ff417 	ldw	r4,-48(fp)
 201fa98:	180b883a 	mov	r5,r3
 201fa9c:	100d883a 	mov	r6,r2
 201faa0:	201c0180 	call	201c018 <OSSemPend>

  while (space > 0)
 201faa4:	00006406 	br	201fc38 <altera_avalon_jtag_uart_read+0x1e4>
    unsigned int in, out;

    /* Read as much data as possible */
    do
    {
      in  = sp->rx_in;
 201faa8:	e0bffc17 	ldw	r2,-16(fp)
 201faac:	10800d17 	ldw	r2,52(r2)
 201fab0:	e0bff115 	stw	r2,-60(fp)
      out = sp->rx_out;
 201fab4:	e0bffc17 	ldw	r2,-16(fp)
 201fab8:	10800e17 	ldw	r2,56(r2)
 201fabc:	e0bff215 	stw	r2,-56(fp)

      if (in >= out)
 201fac0:	e0fff117 	ldw	r3,-60(fp)
 201fac4:	e0bff217 	ldw	r2,-56(fp)
 201fac8:	18800536 	bltu	r3,r2,201fae0 <altera_avalon_jtag_uart_read+0x8c>
        n = in - out;
 201facc:	e0fff117 	ldw	r3,-60(fp)
 201fad0:	e0bff217 	ldw	r2,-56(fp)
 201fad4:	1885c83a 	sub	r2,r3,r2
 201fad8:	e0bff015 	stw	r2,-64(fp)
 201fadc:	00000406 	br	201faf0 <altera_avalon_jtag_uart_read+0x9c>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;
 201fae0:	00c20004 	movi	r3,2048
 201fae4:	e0bff217 	ldw	r2,-56(fp)
 201fae8:	1885c83a 	sub	r2,r3,r2
 201faec:	e0bff015 	stw	r2,-64(fp)

      if (n == 0)
 201faf0:	e0bff017 	ldw	r2,-64(fp)
 201faf4:	10001e26 	beq	r2,zero,201fb70 <altera_avalon_jtag_uart_read+0x11c>
        break; /* No more data available */

      if (n > space)
 201faf8:	e0fffe17 	ldw	r3,-8(fp)
 201fafc:	e0bff017 	ldw	r2,-64(fp)
 201fb00:	1880022e 	bgeu	r3,r2,201fb0c <altera_avalon_jtag_uart_read+0xb8>
        n = space;
 201fb04:	e0bffe17 	ldw	r2,-8(fp)
 201fb08:	e0bff015 	stw	r2,-64(fp)

      memcpy(ptr, sp->rx_buf + out, n);
 201fb0c:	e0bff217 	ldw	r2,-56(fp)
 201fb10:	10801104 	addi	r2,r2,68
 201fb14:	e0fffc17 	ldw	r3,-16(fp)
 201fb18:	1885883a 	add	r2,r3,r2
 201fb1c:	e13fef17 	ldw	r4,-68(fp)
 201fb20:	100b883a 	mov	r5,r2
 201fb24:	e1bff017 	ldw	r6,-64(fp)
 201fb28:	200660c0 	call	200660c <memcpy>
      ptr   += n;
 201fb2c:	e0ffef17 	ldw	r3,-68(fp)
 201fb30:	e0bff017 	ldw	r2,-64(fp)
 201fb34:	1885883a 	add	r2,r3,r2
 201fb38:	e0bfef15 	stw	r2,-68(fp)
      space -= n;
 201fb3c:	e0fffe17 	ldw	r3,-8(fp)
 201fb40:	e0bff017 	ldw	r2,-64(fp)
 201fb44:	1885c83a 	sub	r2,r3,r2
 201fb48:	e0bffe15 	stw	r2,-8(fp)

      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201fb4c:	e0fff217 	ldw	r3,-56(fp)
 201fb50:	e0bff017 	ldw	r2,-64(fp)
 201fb54:	1885883a 	add	r2,r3,r2
 201fb58:	10c1ffcc 	andi	r3,r2,2047
 201fb5c:	e0bffc17 	ldw	r2,-16(fp)
 201fb60:	10c00e15 	stw	r3,56(r2)
    }
    while (space > 0);
 201fb64:	e0bffe17 	ldw	r2,-8(fp)
 201fb68:	00bfcf16 	blt	zero,r2,201faa8 <altera_avalon_jtag_uart_read+0x54>
 201fb6c:	00000106 	br	201fb74 <altera_avalon_jtag_uart_read+0x120>
        n = in - out;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - out;

      if (n == 0)
        break; /* No more data available */
 201fb70:	0001883a 	nop
      sp->rx_out = (out + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
 201fb74:	e0ffef17 	ldw	r3,-68(fp)
 201fb78:	e0bffd17 	ldw	r2,-12(fp)
 201fb7c:	1880311e 	bne	r3,r2,201fc44 <altera_avalon_jtag_uart_read+0x1f0>
      break;

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
 201fb80:	e0bfff17 	ldw	r2,-4(fp)
 201fb84:	1090000c 	andi	r2,r2,16384
 201fb88:	1000301e 	bne	r2,zero,201fc4c <altera_avalon_jtag_uart_read+0x1f8>
      break;

#ifdef __ucosii__
    /* OS Present: Pend on a flag if the OS is running, otherwise spin */
    if(OSRunning == OS_TRUE) {
 201fb8c:	00808174 	movhi	r2,517
 201fb90:	10909b44 	addi	r2,r2,17005
 201fb94:	10800003 	ldbu	r2,0(r2)
 201fb98:	10803fcc 	andi	r2,r2,255
 201fb9c:	10800058 	cmpnei	r2,r2,1
 201fba0:	1000171e 	bne	r2,zero,201fc00 <altera_avalon_jtag_uart_read+0x1ac>
       * When running in a multi-threaded mode, we pend on the read event
       * flag set and timeout event flag set in the isr. This avoids wasting CPU
       * cycles waiting in this thread, when we could be doing something more
       * profitable elsewhere.
       */
      ALT_FLAG_PEND (sp->events,
 201fba4:	e0bffc17 	ldw	r2,-16(fp)
 201fba8:	10800c17 	ldw	r2,48(r2)
 201fbac:	e0bff615 	stw	r2,-40(fp)
 201fbb0:	00800144 	movi	r2,5
 201fbb4:	e0bff70d 	sth	r2,-36(fp)
 201fbb8:	00bfe0c4 	movi	r2,-125
 201fbbc:	e0bff785 	stb	r2,-34(fp)
 201fbc0:	e03ff80d 	sth	zero,-32(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 201fbc4:	00808174 	movhi	r2,517
 201fbc8:	10909b44 	addi	r2,r2,17005
 201fbcc:	10800003 	ldbu	r2,0(r2)
 201fbd0:	10803fcc 	andi	r2,r2,255
 201fbd4:	10001426 	beq	r2,zero,201fc28 <altera_avalon_jtag_uart_read+0x1d4>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 201fbd8:	e17ff70b 	ldhu	r5,-36(fp)
 201fbdc:	e0fff783 	ldbu	r3,-34(fp)
 201fbe0:	e0bff80b 	ldhu	r2,-32(fp)
 201fbe4:	e13ffb44 	addi	r4,fp,-19
 201fbe8:	d9000015 	stw	r4,0(sp)
 201fbec:	e13ff617 	ldw	r4,-40(fp)
 201fbf0:	180d883a 	mov	r6,r3
 201fbf4:	100f883a 	mov	r7,r2
 201fbf8:	201879c0 	call	201879c <OSFlagPend>
 201fbfc:	00000a06 	br	201fc28 <altera_avalon_jtag_uart_read+0x1d4>
                     OS_FLAG_WAIT_SET_ANY + OS_FLAG_CONSUME,
                     0);
    }
    else {
      /* Spin until more data arrives or until host disconnects */
      while (in == sp->rx_in && sp->host_inactive < sp->timeout)
 201fc00:	0001883a 	nop
 201fc04:	e0bffc17 	ldw	r2,-16(fp)
 201fc08:	10c00d17 	ldw	r3,52(r2)
 201fc0c:	e0bff117 	ldw	r2,-60(fp)
 201fc10:	1880051e 	bne	r3,r2,201fc28 <altera_avalon_jtag_uart_read+0x1d4>
 201fc14:	e0bffc17 	ldw	r2,-16(fp)
 201fc18:	10c00917 	ldw	r3,36(r2)
 201fc1c:	e0bffc17 	ldw	r2,-16(fp)
 201fc20:	10800117 	ldw	r2,4(r2)
 201fc24:	18bff736 	bltu	r3,r2,201fc04 <altera_avalon_jtag_uart_read+0x1b0>
    /* No OS: Always spin */
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
 201fc28:	e0bffc17 	ldw	r2,-16(fp)
 201fc2c:	10c00d17 	ldw	r3,52(r2)
 201fc30:	e0bff117 	ldw	r2,-60(fp)
 201fc34:	18800726 	beq	r3,r2,201fc54 <altera_avalon_jtag_uart_read+0x200>
   * When running in a multi threaded environment, obtain the "read_lock"
   * semaphore. This ensures that reading from the device is thread-safe.
   */
  ALT_SEM_PEND (sp->read_lock, 0);

  while (space > 0)
 201fc38:	e0bffe17 	ldw	r2,-8(fp)
 201fc3c:	00bf9a16 	blt	zero,r2,201faa8 <altera_avalon_jtag_uart_read+0x54>
 201fc40:	00000506 	br	201fc58 <altera_avalon_jtag_uart_read+0x204>
    }
    while (space > 0);

    /* If we read any data then return it */
    if (ptr != buffer)
      break;
 201fc44:	0001883a 	nop
 201fc48:	00000306 	br	201fc58 <altera_avalon_jtag_uart_read+0x204>

    /* If in non-blocking mode then return error */
    if (flags & O_NONBLOCK)
      break;
 201fc4c:	0001883a 	nop
 201fc50:	00000106 	br	201fc58 <altera_avalon_jtag_uart_read+0x204>
    while (in == sp->rx_in && sp->host_inactive < sp->timeout)
      ;
#endif /* __ucosii__ */

    if (in == sp->rx_in)
      break;
 201fc54:	0001883a 	nop
  /*
   * Now that access to the circular buffer is complete, release the read
   * semaphore so that other threads can access the buffer.
   */

  ALT_SEM_POST (sp->read_lock);
 201fc58:	e0bffc17 	ldw	r2,-16(fp)
 201fc5c:	10800a17 	ldw	r2,40(r2)
 201fc60:	1009883a 	mov	r4,r2
 201fc64:	201c3f80 	call	201c3f8 <OSSemPost>

  if (ptr != buffer)
 201fc68:	e0ffef17 	ldw	r3,-68(fp)
 201fc6c:	e0bffd17 	ldw	r2,-12(fp)
 201fc70:	18801726 	beq	r3,r2,201fcd0 <altera_avalon_jtag_uart_read+0x27c>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201fc74:	0005303a 	rdctl	r2,status
 201fc78:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201fc7c:	e0fff917 	ldw	r3,-28(fp)
 201fc80:	00bfff84 	movi	r2,-2
 201fc84:	1884703a 	and	r2,r3,r2
 201fc88:	1001703a 	wrctl	status,r2
  
  return context;
 201fc8c:	e0bff917 	ldw	r2,-28(fp)
  {
    /* If we read any data then there is space in the buffer so enable interrupts */
    context = alt_irq_disable_all();
 201fc90:	e0bff315 	stw	r2,-52(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_RE_MSK;
 201fc94:	e0bffc17 	ldw	r2,-16(fp)
 201fc98:	10800817 	ldw	r2,32(r2)
 201fc9c:	10c00054 	ori	r3,r2,1
 201fca0:	e0bffc17 	ldw	r2,-16(fp)
 201fca4:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 201fca8:	e0bffc17 	ldw	r2,-16(fp)
 201fcac:	10800017 	ldw	r2,0(r2)
 201fcb0:	10800104 	addi	r2,r2,4
 201fcb4:	e0fffc17 	ldw	r3,-16(fp)
 201fcb8:	18c00817 	ldw	r3,32(r3)
 201fcbc:	10c00035 	stwio	r3,0(r2)
 201fcc0:	e0bff317 	ldw	r2,-52(fp)
 201fcc4:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201fcc8:	e0bffa17 	ldw	r2,-24(fp)
 201fccc:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(context);
  }

  if (ptr != buffer)
 201fcd0:	e0ffef17 	ldw	r3,-68(fp)
 201fcd4:	e0bffd17 	ldw	r2,-12(fp)
 201fcd8:	18800426 	beq	r3,r2,201fcec <altera_avalon_jtag_uart_read+0x298>
    return ptr - buffer;
 201fcdc:	e0ffef17 	ldw	r3,-68(fp)
 201fce0:	e0bffd17 	ldw	r2,-12(fp)
 201fce4:	1885c83a 	sub	r2,r3,r2
 201fce8:	00000606 	br	201fd04 <altera_avalon_jtag_uart_read+0x2b0>
  else if (flags & O_NONBLOCK)
 201fcec:	e0bfff17 	ldw	r2,-4(fp)
 201fcf0:	1090000c 	andi	r2,r2,16384
 201fcf4:	10000226 	beq	r2,zero,201fd00 <altera_avalon_jtag_uart_read+0x2ac>
    return -EWOULDBLOCK;
 201fcf8:	00bffd44 	movi	r2,-11
 201fcfc:	00000106 	br	201fd04 <altera_avalon_jtag_uart_read+0x2b0>
  else
    return -EIO;
 201fd00:	00bffec4 	movi	r2,-5
}
 201fd04:	e037883a 	mov	sp,fp
 201fd08:	dfc00117 	ldw	ra,4(sp)
 201fd0c:	df000017 	ldw	fp,0(sp)
 201fd10:	dec00204 	addi	sp,sp,8
 201fd14:	f800283a 	ret

0201fd18 <altera_avalon_jtag_uart_write>:
/* ----------------------------------------------------------- */

int 
altera_avalon_jtag_uart_write(altera_avalon_jtag_uart_state* sp, 
  const char * ptr, int count, int flags)
{
 201fd18:	deffed04 	addi	sp,sp,-76
 201fd1c:	dfc01215 	stw	ra,72(sp)
 201fd20:	df001115 	stw	fp,68(sp)
 201fd24:	df001104 	addi	fp,sp,68
 201fd28:	e13ffc15 	stw	r4,-16(fp)
 201fd2c:	e17ffd15 	stw	r5,-12(fp)
 201fd30:	e1bffe15 	stw	r6,-8(fp)
 201fd34:	e1ffff15 	stw	r7,-4(fp)
  /* Remove warning at optimisation level 03 by seting out to 0 */
  unsigned int in, out=0;
 201fd38:	e03ff015 	stw	zero,-64(fp)
  unsigned int n;
  alt_irq_context context;

  const char * start = ptr;
 201fd3c:	e0bffd17 	ldw	r2,-12(fp)
 201fd40:	e0bff215 	stw	r2,-56(fp)

  /*
   * When running in a multi threaded environment, obtain the "write_lock"
   * semaphore. This ensures that writing to the device is thread-safe.
   */
  ALT_SEM_PEND (sp->write_lock, 0);
 201fd44:	e0bffc17 	ldw	r2,-16(fp)
 201fd48:	10800b17 	ldw	r2,44(r2)
 201fd4c:	e0bff515 	stw	r2,-44(fp)
 201fd50:	e03ff60d 	sth	zero,-40(fp)
 201fd54:	e0fff60b 	ldhu	r3,-40(fp)
 201fd58:	e0bffbc4 	addi	r2,fp,-17
 201fd5c:	e13ff517 	ldw	r4,-44(fp)
 201fd60:	180b883a 	mov	r5,r3
 201fd64:	100d883a 	mov	r6,r2
 201fd68:	201c0180 	call	201c018 <OSSemPend>

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 201fd6c:	00003706 	br	201fe4c <altera_avalon_jtag_uart_write+0x134>
    {
      /* We need a stable value of the out pointer to calculate the space available */
      in  = sp->tx_in;
 201fd70:	e0bffc17 	ldw	r2,-16(fp)
 201fd74:	10800f17 	ldw	r2,60(r2)
 201fd78:	e0bff315 	stw	r2,-52(fp)
      out = sp->tx_out;
 201fd7c:	e0bffc17 	ldw	r2,-16(fp)
 201fd80:	10801017 	ldw	r2,64(r2)
 201fd84:	e0bff015 	stw	r2,-64(fp)

      if (in < out)
 201fd88:	e0fff317 	ldw	r3,-52(fp)
 201fd8c:	e0bff017 	ldw	r2,-64(fp)
 201fd90:	1880062e 	bgeu	r3,r2,201fdac <altera_avalon_jtag_uart_write+0x94>
        n = out - 1 - in;
 201fd94:	e0fff017 	ldw	r3,-64(fp)
 201fd98:	e0bff317 	ldw	r2,-52(fp)
 201fd9c:	1885c83a 	sub	r2,r3,r2
 201fda0:	10bfffc4 	addi	r2,r2,-1
 201fda4:	e0bff115 	stw	r2,-60(fp)
 201fda8:	00000b06 	br	201fdd8 <altera_avalon_jtag_uart_write+0xc0>
      else if (out > 0)
 201fdac:	e0bff017 	ldw	r2,-64(fp)
 201fdb0:	10000526 	beq	r2,zero,201fdc8 <altera_avalon_jtag_uart_write+0xb0>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
 201fdb4:	00c20004 	movi	r3,2048
 201fdb8:	e0bff317 	ldw	r2,-52(fp)
 201fdbc:	1885c83a 	sub	r2,r3,r2
 201fdc0:	e0bff115 	stw	r2,-60(fp)
 201fdc4:	00000406 	br	201fdd8 <altera_avalon_jtag_uart_write+0xc0>
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;
 201fdc8:	00c1ffc4 	movi	r3,2047
 201fdcc:	e0bff317 	ldw	r2,-52(fp)
 201fdd0:	1885c83a 	sub	r2,r3,r2
 201fdd4:	e0bff115 	stw	r2,-60(fp)

      if (n == 0)
 201fdd8:	e0bff117 	ldw	r2,-60(fp)
 201fddc:	10001e26 	beq	r2,zero,201fe58 <altera_avalon_jtag_uart_write+0x140>
        break;

      if (n > count)
 201fde0:	e0fffe17 	ldw	r3,-8(fp)
 201fde4:	e0bff117 	ldw	r2,-60(fp)
 201fde8:	1880022e 	bgeu	r3,r2,201fdf4 <altera_avalon_jtag_uart_write+0xdc>
        n = count;
 201fdec:	e0bffe17 	ldw	r2,-8(fp)
 201fdf0:	e0bff115 	stw	r2,-60(fp)

      memcpy(sp->tx_buf + in, ptr, n);
 201fdf4:	e0bff317 	ldw	r2,-52(fp)
 201fdf8:	10821104 	addi	r2,r2,2116
 201fdfc:	e0fffc17 	ldw	r3,-16(fp)
 201fe00:	1885883a 	add	r2,r3,r2
 201fe04:	1009883a 	mov	r4,r2
 201fe08:	e17ffd17 	ldw	r5,-12(fp)
 201fe0c:	e1bff117 	ldw	r6,-60(fp)
 201fe10:	200660c0 	call	200660c <memcpy>
      ptr   += n;
 201fe14:	e0fffd17 	ldw	r3,-12(fp)
 201fe18:	e0bff117 	ldw	r2,-60(fp)
 201fe1c:	1885883a 	add	r2,r3,r2
 201fe20:	e0bffd15 	stw	r2,-12(fp)
      count -= n;
 201fe24:	e0fffe17 	ldw	r3,-8(fp)
 201fe28:	e0bff117 	ldw	r2,-60(fp)
 201fe2c:	1885c83a 	sub	r2,r3,r2
 201fe30:	e0bffe15 	stw	r2,-8(fp)

      sp->tx_in = (in + n) % ALTERA_AVALON_JTAG_UART_BUF_LEN;
 201fe34:	e0fff317 	ldw	r3,-52(fp)
 201fe38:	e0bff117 	ldw	r2,-60(fp)
 201fe3c:	1885883a 	add	r2,r3,r2
 201fe40:	10c1ffcc 	andi	r3,r2,2047
 201fe44:	e0bffc17 	ldw	r2,-16(fp)
 201fe48:	10c00f15 	stw	r3,60(r2)
  ALT_SEM_PEND (sp->write_lock, 0);

  do
  {
    /* Copy as much as we can into the transmit buffer */
    while (count > 0)
 201fe4c:	e0bffe17 	ldw	r2,-8(fp)
 201fe50:	00bfc716 	blt	zero,r2,201fd70 <altera_avalon_jtag_uart_write+0x58>
 201fe54:	00000106 	br	201fe5c <altera_avalon_jtag_uart_write+0x144>
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - in;
      else
        n = ALTERA_AVALON_JTAG_UART_BUF_LEN - 1 - in;

      if (n == 0)
        break;
 201fe58:	0001883a 	nop
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 201fe5c:	0005303a 	rdctl	r2,status
 201fe60:	e0bff715 	stw	r2,-36(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 201fe64:	e0fff717 	ldw	r3,-36(fp)
 201fe68:	00bfff84 	movi	r2,-2
 201fe6c:	1884703a 	and	r2,r3,r2
 201fe70:	1001703a 	wrctl	status,r2
  
  return context;
 201fe74:	e0bff717 	ldw	r2,-36(fp)
     * to enable interrupts if there is no space left in the FIFO
     *
     * For now kick the interrupt routine every time to make it transmit 
     * the data 
     */
    context = alt_irq_disable_all();
 201fe78:	e0bff415 	stw	r2,-48(fp)
    sp->irq_enable |= ALTERA_AVALON_JTAG_UART_CONTROL_WE_MSK;
 201fe7c:	e0bffc17 	ldw	r2,-16(fp)
 201fe80:	10800817 	ldw	r2,32(r2)
 201fe84:	10c00094 	ori	r3,r2,2
 201fe88:	e0bffc17 	ldw	r2,-16(fp)
 201fe8c:	10c00815 	stw	r3,32(r2)
    IOWR_ALTERA_AVALON_JTAG_UART_CONTROL(sp->base, sp->irq_enable);
 201fe90:	e0bffc17 	ldw	r2,-16(fp)
 201fe94:	10800017 	ldw	r2,0(r2)
 201fe98:	10800104 	addi	r2,r2,4
 201fe9c:	e0fffc17 	ldw	r3,-16(fp)
 201fea0:	18c00817 	ldw	r3,32(r3)
 201fea4:	10c00035 	stwio	r3,0(r2)
 201fea8:	e0bff417 	ldw	r2,-48(fp)
 201feac:	e0bff815 	stw	r2,-32(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 201feb0:	e0bff817 	ldw	r2,-32(fp)
 201feb4:	1001703a 	wrctl	status,r2
    /* 
     * If there is any data left then either return now or block until 
     * some has been sent 
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
 201feb8:	e0bffe17 	ldw	r2,-8(fp)
 201febc:	00802e0e 	bge	zero,r2,201ff78 <altera_avalon_jtag_uart_write+0x260>
    {
      if (flags & O_NONBLOCK)
 201fec0:	e0bfff17 	ldw	r2,-4(fp)
 201fec4:	1090000c 	andi	r2,r2,16384
 201fec8:	10002e1e 	bne	r2,zero,201ff84 <altera_avalon_jtag_uart_write+0x26c>
        break;

#ifdef __ucosii__
      /* OS Present: Pend on a flag if the OS is running, otherwise spin */
      if(OSRunning == OS_TRUE) {
 201fecc:	00808174 	movhi	r2,517
 201fed0:	10909b44 	addi	r2,r2,17005
 201fed4:	10800003 	ldbu	r2,0(r2)
 201fed8:	10803fcc 	andi	r2,r2,255
 201fedc:	10800058 	cmpnei	r2,r2,1
 201fee0:	1000171e 	bne	r2,zero,201ff40 <altera_avalon_jtag_uart_write+0x228>
         * more profitable elsewhere.
         */
#ifdef ALTERA_AVALON_JTAG_UART_IGNORE_FIFO_FULL_ERROR
        if(!sp->host_inactive)
#endif
        ALT_FLAG_PEND (sp->events,
 201fee4:	e0bffc17 	ldw	r2,-16(fp)
 201fee8:	10800c17 	ldw	r2,48(r2)
 201feec:	e0bff915 	stw	r2,-28(fp)
 201fef0:	00800184 	movi	r2,6
 201fef4:	e0bffa0d 	sth	r2,-24(fp)
 201fef8:	00bfe0c4 	movi	r2,-125
 201fefc:	e0bffa85 	stb	r2,-22(fp)
 201ff00:	e03ffb0d 	sth	zero,-20(fp)
                   OS_FLAGS flags, 
                   INT8U wait_type, 
                   INT16U timeout)
{
  INT8U err;
  if (OSRunning)
 201ff04:	00808174 	movhi	r2,517
 201ff08:	10909b44 	addi	r2,r2,17005
 201ff0c:	10800003 	ldbu	r2,0(r2)
 201ff10:	10803fcc 	andi	r2,r2,255
 201ff14:	10001426 	beq	r2,zero,201ff68 <altera_avalon_jtag_uart_write+0x250>
  {
    OSFlagPend (group, flags, wait_type, timeout, &err);
 201ff18:	e17ffa0b 	ldhu	r5,-24(fp)
 201ff1c:	e0fffa83 	ldbu	r3,-22(fp)
 201ff20:	e0bffb0b 	ldhu	r2,-20(fp)
 201ff24:	e13ffb84 	addi	r4,fp,-18
 201ff28:	d9000015 	stw	r4,0(sp)
 201ff2c:	e13ff917 	ldw	r4,-28(fp)
 201ff30:	180d883a 	mov	r6,r3
 201ff34:	100f883a 	mov	r7,r2
 201ff38:	201879c0 	call	201879c <OSFlagPend>
 201ff3c:	00000a06 	br	201ff68 <altera_avalon_jtag_uart_write+0x250>
        /*
         * OS not running: Wait for data to be removed from buffer.
         * Once the interrupt routine has removed some data then we
         * will be able to insert some more.
         */
        while (out == sp->tx_out && sp->host_inactive < sp->timeout)
 201ff40:	0001883a 	nop
 201ff44:	e0bffc17 	ldw	r2,-16(fp)
 201ff48:	10c01017 	ldw	r3,64(r2)
 201ff4c:	e0bff017 	ldw	r2,-64(fp)
 201ff50:	1880051e 	bne	r3,r2,201ff68 <altera_avalon_jtag_uart_write+0x250>
 201ff54:	e0bffc17 	ldw	r2,-16(fp)
 201ff58:	10c00917 	ldw	r3,36(r2)
 201ff5c:	e0bffc17 	ldw	r2,-16(fp)
 201ff60:	10800117 	ldw	r2,4(r2)
 201ff64:	18bff736 	bltu	r3,r2,201ff44 <altera_avalon_jtag_uart_write+0x22c>
       */
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
 201ff68:	e0bffc17 	ldw	r2,-16(fp)
 201ff6c:	10c01017 	ldw	r3,64(r2)
 201ff70:	e0bff017 	ldw	r2,-64(fp)
 201ff74:	18800526 	beq	r3,r2,201ff8c <altera_avalon_jtag_uart_write+0x274>
         break;
    }
  }
  while (count > 0);
 201ff78:	e0bffe17 	ldw	r2,-8(fp)
 201ff7c:	00bfb316 	blt	zero,r2,201fe4c <altera_avalon_jtag_uart_write+0x134>
 201ff80:	00000306 	br	201ff90 <altera_avalon_jtag_uart_write+0x278>
     */
    /* consider: test whether there is anything there while doing this and delay for at most 2s. */
    if (count > 0)
    {
      if (flags & O_NONBLOCK)
        break;
 201ff84:	0001883a 	nop
 201ff88:	00000106 	br	201ff90 <altera_avalon_jtag_uart_write+0x278>
      while (out == sp->tx_out && sp->host_inactive < sp->timeout)
        ;
#endif /* __ucosii__ */

      if (out == sp->tx_out)
         break;
 201ff8c:	0001883a 	nop

  /*
   * Now that access to the circular buffer is complete, release the write
   * semaphore so that other threads can access the buffer.
   */
  ALT_SEM_POST (sp->write_lock);
 201ff90:	e0bffc17 	ldw	r2,-16(fp)
 201ff94:	10800b17 	ldw	r2,44(r2)
 201ff98:	1009883a 	mov	r4,r2
 201ff9c:	201c3f80 	call	201c3f8 <OSSemPost>

  if (ptr != start)
 201ffa0:	e0fffd17 	ldw	r3,-12(fp)
 201ffa4:	e0bff217 	ldw	r2,-56(fp)
 201ffa8:	18800426 	beq	r3,r2,201ffbc <altera_avalon_jtag_uart_write+0x2a4>
    return ptr - start;
 201ffac:	e0fffd17 	ldw	r3,-12(fp)
 201ffb0:	e0bff217 	ldw	r2,-56(fp)
 201ffb4:	1885c83a 	sub	r2,r3,r2
 201ffb8:	00000606 	br	201ffd4 <altera_avalon_jtag_uart_write+0x2bc>
  else if (flags & O_NONBLOCK)
 201ffbc:	e0bfff17 	ldw	r2,-4(fp)
 201ffc0:	1090000c 	andi	r2,r2,16384
 201ffc4:	10000226 	beq	r2,zero,201ffd0 <altera_avalon_jtag_uart_write+0x2b8>
    return -EWOULDBLOCK;
 201ffc8:	00bffd44 	movi	r2,-11
 201ffcc:	00000106 	br	201ffd4 <altera_avalon_jtag_uart_write+0x2bc>
    sp->tx_out = sp->tx_in = 0;
    return ptr - start + count;
  }
#endif
  else
    return -EIO; /* Host not connected */
 201ffd0:	00bffec4 	movi	r2,-5
}
 201ffd4:	e037883a 	mov	sp,fp
 201ffd8:	dfc00117 	ldw	ra,4(sp)
 201ffdc:	df000017 	ldw	fp,0(sp)
 201ffe0:	dec00204 	addi	sp,sp,8
 201ffe4:	f800283a 	ret

0201ffe8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 201ffe8:	defffe04 	addi	sp,sp,-8
 201ffec:	dfc00115 	stw	ra,4(sp)
 201fff0:	df000015 	stw	fp,0(sp)
 201fff4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 201fff8:	00808174 	movhi	r2,517
 201fffc:	10907704 	addi	r2,r2,16860
 2020000:	10800017 	ldw	r2,0(r2)
 2020004:	10000526 	beq	r2,zero,202001c <alt_get_errno+0x34>
 2020008:	00808174 	movhi	r2,517
 202000c:	10907704 	addi	r2,r2,16860
 2020010:	10800017 	ldw	r2,0(r2)
 2020014:	103ee83a 	callr	r2
 2020018:	00000206 	br	2020024 <alt_get_errno+0x3c>
 202001c:	00808174 	movhi	r2,517
 2020020:	10908b04 	addi	r2,r2,16940
}
 2020024:	e037883a 	mov	sp,fp
 2020028:	dfc00117 	ldw	ra,4(sp)
 202002c:	df000017 	ldw	fp,0(sp)
 2020030:	dec00204 	addi	sp,sp,8
 2020034:	f800283a 	ret

02020038 <alt_avalon_sgdma_do_async_transfer>:
 * - 0 for success, or various errors defined in <errno.h>
 */
int alt_avalon_sgdma_do_async_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 2020038:	defffc04 	addi	sp,sp,-16
 202003c:	df000315 	stw	fp,12(sp)
 2020040:	df000304 	addi	fp,sp,12
 2020044:	e13ffe15 	stw	r4,-8(fp)
 2020048:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  /* Return with error immediately if controller is busy */
  if( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 202004c:	e0bffe17 	ldw	r2,-8(fp)
 2020050:	10800317 	ldw	r2,12(r2)
 2020054:	10800037 	ldwio	r2,0(r2)
 2020058:	1080040c 	andi	r2,r2,16
 202005c:	10000226 	beq	r2,zero,2020068 <alt_avalon_sgdma_do_async_transfer+0x30>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    return -EBUSY;
 2020060:	00bffc04 	movi	r2,-16
 2020064:	00003906 	br	202014c <alt_avalon_sgdma_do_async_transfer+0x114>
  }

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2020068:	e0bffe17 	ldw	r2,-8(fp)
 202006c:	10800317 	ldw	r2,12(r2)
 2020070:	10800404 	addi	r2,r2,16
 2020074:	e0fffe17 	ldw	r3,-8(fp)
 2020078:	18c00317 	ldw	r3,12(r3)
 202007c:	18c00404 	addi	r3,r3,16
 2020080:	19000037 	ldwio	r4,0(r3)
 2020084:	00fff7c4 	movi	r3,-33
 2020088:	20c6703a 	and	r3,r4,r3
 202008c:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 2020090:	e0bffe17 	ldw	r2,-8(fp)
 2020094:	10800317 	ldw	r2,12(r2)
 2020098:	00c03fc4 	movi	r3,255
 202009c:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 20200a0:	e0bffe17 	ldw	r2,-8(fp)
 20200a4:	10800317 	ldw	r2,12(r2)
 20200a8:	10800804 	addi	r2,r2,32
 20200ac:	e0ffff17 	ldw	r3,-4(fp)
 20200b0:	10c00035 	stwio	r3,0(r2)
   *  - Stop on an error with any particular descriptor
   *  - Include any control register bits registered with along with
   *    the callback routine (effectively, interrupts are controlled
   *    via the control bits set during callback-register time).
   */
  if(dev->callback) {
 20200b4:	e0bffe17 	ldw	r2,-8(fp)
 20200b8:	10800917 	ldw	r2,36(r2)
 20200bc:	10001126 	beq	r2,zero,2020104 <alt_avalon_sgdma_do_async_transfer+0xcc>
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 20200c0:	e0bffe17 	ldw	r2,-8(fp)
 20200c4:	10800317 	ldw	r2,12(r2)
 20200c8:	10800404 	addi	r2,r2,16
 20200cc:	10800037 	ldwio	r2,0(r2)
 20200d0:	e0bffd15 	stw	r2,-12(fp)

    control |= (dev->chain_control                          |
 20200d4:	e0bffe17 	ldw	r2,-8(fp)
 20200d8:	10c00b17 	ldw	r3,44(r2)
 20200dc:	e0bffd17 	ldw	r2,-12(fp)
 20200e0:	1884b03a 	or	r2,r3,r2
 20200e4:	10801814 	ori	r2,r2,96
 20200e8:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK  );

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 20200ec:	e0bffe17 	ldw	r2,-8(fp)
 20200f0:	10800317 	ldw	r2,12(r2)
 20200f4:	10800404 	addi	r2,r2,16
 20200f8:	e0fffd17 	ldw	r3,-12(fp)
 20200fc:	10c00035 	stwio	r3,0(r2)
 2020100:	00001106 	br	2020148 <alt_avalon_sgdma_do_async_transfer+0x110>
   *   - Run
   *   - Stop on an error with any particular descriptor
   *   - Disable interrupt generation
   */
  else {
    control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2020104:	e0bffe17 	ldw	r2,-8(fp)
 2020108:	10800317 	ldw	r2,12(r2)
 202010c:	10800404 	addi	r2,r2,16
 2020110:	10800037 	ldwio	r2,0(r2)
 2020114:	e0bffd15 	stw	r2,-12(fp)

    control |= (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK         |
 2020118:	e0bffd17 	ldw	r2,-12(fp)
 202011c:	10801814 	ori	r2,r2,96
 2020120:	e0bffd15 	stw	r2,-12(fp)
                ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK );
    control &= ~ALTERA_AVALON_SGDMA_CONTROL_IE_GLOBAL_MSK;
 2020124:	e0fffd17 	ldw	r3,-12(fp)
 2020128:	00bffbc4 	movi	r2,-17
 202012c:	1884703a 	and	r2,r3,r2
 2020130:	e0bffd15 	stw	r2,-12(fp)

    IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2020134:	e0bffe17 	ldw	r2,-8(fp)
 2020138:	10800317 	ldw	r2,12(r2)
 202013c:	10800404 	addi	r2,r2,16
 2020140:	e0fffd17 	ldw	r3,-12(fp)
 2020144:	10c00035 	stwio	r3,0(r2)

  /*
   * Error detection/handling should be performed at the application
   * or callback level as appropriate.
   */
  return 0;
 2020148:	0005883a 	mov	r2,zero
}
 202014c:	e037883a 	mov	sp,fp
 2020150:	df000017 	ldw	fp,0(sp)
 2020154:	dec00104 	addi	sp,sp,4
 2020158:	f800283a 	ret

0202015c <alt_avalon_sgdma_do_sync_transfer>:
 * - status: Content of SGDMA status register.
 */
alt_u8 alt_avalon_sgdma_do_sync_transfer(
  alt_sgdma_dev *dev,
  alt_sgdma_descriptor *desc)
{
 202015c:	defffc04 	addi	sp,sp,-16
 2020160:	df000315 	stw	fp,12(sp)
 2020164:	df000304 	addi	fp,sp,12
 2020168:	e13ffe15 	stw	r4,-8(fp)
 202016c:	e17fff15 	stw	r5,-4(fp)
  alt_u8 status;

  /* Wait for any pending transfers to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 2020170:	0001883a 	nop
 2020174:	e0bffe17 	ldw	r2,-8(fp)
 2020178:	10800317 	ldw	r2,12(r2)
 202017c:	10800037 	ldwio	r2,0(r2)
 2020180:	1080040c 	andi	r2,r2,16
 2020184:	103ffb1e 	bne	r2,zero,2020174 <alt_avalon_sgdma_do_sync_transfer+0x18>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );


  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2020188:	e0bffe17 	ldw	r2,-8(fp)
 202018c:	10800317 	ldw	r2,12(r2)
 2020190:	10800404 	addi	r2,r2,16
 2020194:	e0fffe17 	ldw	r3,-8(fp)
 2020198:	18c00317 	ldw	r3,12(r3)
 202019c:	18c00404 	addi	r3,r3,16
 20201a0:	19000037 	ldwio	r4,0(r3)
 20201a4:	00fff7c4 	movi	r3,-33
 20201a8:	20c6703a 	and	r3,r4,r3
 20201ac:	10c00035 	stwio	r3,0(r2)

  /*
   * Clear any (previous) status register information
   * that might occlude our error checking later.
   */
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 20201b0:	e0bffe17 	ldw	r2,-8(fp)
 20201b4:	10800317 	ldw	r2,12(r2)
 20201b8:	00c03fc4 	movi	r3,255
 20201bc:	10c00035 	stwio	r3,0(r2)

  /* Point the controller at the descriptor */
  IOWR_ALTERA_AVALON_SGDMA_NEXT_DESC_POINTER(dev->base, (alt_u32) desc);
 20201c0:	e0bffe17 	ldw	r2,-8(fp)
 20201c4:	10800317 	ldw	r2,12(r2)
 20201c8:	10800804 	addi	r2,r2,32
 20201cc:	e0ffff17 	ldw	r3,-4(fp)
 20201d0:	10c00035 	stwio	r3,0(r2)
   * Set up SGDMA controller to:
   * - Disable interrupt generation
   * - Run once a valid descriptor is written to controller
   * - Stop on an error with any particular descriptor
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 20201d4:	e0bffe17 	ldw	r2,-8(fp)
 20201d8:	10800317 	ldw	r2,12(r2)
 20201dc:	10800404 	addi	r2,r2,16
 20201e0:	e0fffe17 	ldw	r3,-8(fp)
 20201e4:	18c00317 	ldw	r3,12(r3)
 20201e8:	18c00404 	addi	r3,r3,16
 20201ec:	18c00037 	ldwio	r3,0(r3)
 20201f0:	18c01814 	ori	r3,r3,96
 20201f4:	10c00035 	stwio	r3,0(r2)
    (ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK |
     ALTERA_AVALON_SGDMA_CONTROL_STOP_DMA_ER_MSK | 
     IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base)) );

  /* Wait for the descriptor (chain) to complete */
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base) &
 20201f8:	0001883a 	nop
 20201fc:	e0bffe17 	ldw	r2,-8(fp)
 2020200:	10800317 	ldw	r2,12(r2)
 2020204:	10800037 	ldwio	r2,0(r2)
 2020208:	1080040c 	andi	r2,r2,16
 202020c:	103ffb1e 	bne	r2,zero,20201fc <alt_avalon_sgdma_do_sync_transfer+0xa0>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) );

  /* Clear Run */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 2020210:	e0bffe17 	ldw	r2,-8(fp)
 2020214:	10800317 	ldw	r2,12(r2)
 2020218:	10800404 	addi	r2,r2,16
 202021c:	e0fffe17 	ldw	r3,-8(fp)
 2020220:	18c00317 	ldw	r3,12(r3)
 2020224:	18c00404 	addi	r3,r3,16
 2020228:	19000037 	ldwio	r4,0(r3)
 202022c:	00fff7c4 	movi	r3,-33
 2020230:	20c6703a 	and	r3,r4,r3
 2020234:	10c00035 	stwio	r3,0(r2)
    (IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) &
     ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK) );

  /* Get & clear status register contents */
  status = IORD_ALTERA_AVALON_SGDMA_STATUS(dev->base);
 2020238:	e0bffe17 	ldw	r2,-8(fp)
 202023c:	10800317 	ldw	r2,12(r2)
 2020240:	10800037 	ldwio	r2,0(r2)
 2020244:	e0bffd05 	stb	r2,-12(fp)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 2020248:	e0bffe17 	ldw	r2,-8(fp)
 202024c:	10800317 	ldw	r2,12(r2)
 2020250:	00c03fc4 	movi	r3,255
 2020254:	10c00035 	stwio	r3,0(r2)

  return status;
 2020258:	e0bffd03 	ldbu	r2,-12(fp)
}
 202025c:	e037883a 	mov	sp,fp
 2020260:	df000017 	ldw	fp,0(sp)
 2020264:	dec00104 	addi	sp,sp,4
 2020268:	f800283a 	ret

0202026c <alt_avalon_sgdma_construct_mem_to_mem_desc>:
  alt_u32              *read_addr,
  alt_u32              *write_addr,
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed)
{
 202026c:	defff404 	addi	sp,sp,-48
 2020270:	dfc00b15 	stw	ra,44(sp)
 2020274:	df000a15 	stw	fp,40(sp)
 2020278:	df000a04 	addi	fp,sp,40
 202027c:	e13ffb15 	stw	r4,-20(fp)
 2020280:	e17ffc15 	stw	r5,-16(fp)
 2020284:	e1bffd15 	stw	r6,-12(fp)
 2020288:	e1fffe15 	stw	r7,-8(fp)
 202028c:	e0800217 	ldw	r2,8(fp)
 2020290:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_mem_to_mem_desc_burst(desc, next, read_addr, 
 2020294:	e0bfff0b 	ldhu	r2,-4(fp)
 2020298:	d8800015 	stw	r2,0(sp)
 202029c:	e0800317 	ldw	r2,12(fp)
 20202a0:	d8800115 	stw	r2,4(sp)
 20202a4:	e0800417 	ldw	r2,16(fp)
 20202a8:	d8800215 	stw	r2,8(sp)
 20202ac:	d8000315 	stw	zero,12(sp)
 20202b0:	d8000415 	stw	zero,16(sp)
 20202b4:	e13ffb17 	ldw	r4,-20(fp)
 20202b8:	e17ffc17 	ldw	r5,-16(fp)
 20202bc:	e1bffd17 	ldw	r6,-12(fp)
 20202c0:	e1fffe17 	ldw	r7,-8(fp)
 20202c4:	20202dc0 	call	20202dc <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>
    write_addr, length, read_fixed, write_fixed, 0, 0);
}
 20202c8:	e037883a 	mov	sp,fp
 20202cc:	dfc00117 	ldw	ra,4(sp)
 20202d0:	df000017 	ldw	fp,0(sp)
 20202d4:	dec00204 	addi	sp,sp,8
 20202d8:	f800283a 	ret

020202dc <alt_avalon_sgdma_construct_mem_to_mem_desc_burst>:
  alt_u16               length,
  int                   read_fixed,
  int                   write_fixed,
  int                   read_burst,
  int                   write_burst)
{
 20202dc:	defff204 	addi	sp,sp,-56
 20202e0:	dfc00d15 	stw	ra,52(sp)
 20202e4:	df000c15 	stw	fp,48(sp)
 20202e8:	df000c04 	addi	fp,sp,48
 20202ec:	e13ffb15 	stw	r4,-20(fp)
 20202f0:	e17ffc15 	stw	r5,-16(fp)
 20202f4:	e1bffd15 	stw	r6,-12(fp)
 20202f8:	e1fffe15 	stw	r7,-8(fp)
 20202fc:	e0800217 	ldw	r2,8(fp)
 2020300:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 2020304:	e0bfff0b 	ldhu	r2,-4(fp)
 2020308:	d8800015 	stw	r2,0(sp)
 202030c:	d8000115 	stw	zero,4(sp)
 2020310:	e0800317 	ldw	r2,12(fp)
 2020314:	d8800215 	stw	r2,8(sp)
 2020318:	e0800417 	ldw	r2,16(fp)
 202031c:	d8800315 	stw	r2,12(sp)
 2020320:	e0800517 	ldw	r2,20(fp)
 2020324:	d8800415 	stw	r2,16(sp)
 2020328:	e0800617 	ldw	r2,24(fp)
 202032c:	d8800515 	stw	r2,20(sp)
 2020330:	d8000615 	stw	zero,24(sp)
 2020334:	e13ffb17 	ldw	r4,-20(fp)
 2020338:	e17ffc17 	ldw	r5,-16(fp)
 202033c:	e1bffd17 	ldw	r6,-12(fp)
 2020340:	e1fffe17 	ldw	r7,-8(fp)
 2020344:	20208480 	call	2020848 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    write_fixed,
    read_burst,
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in mem-to-mem mode
}
 2020348:	e037883a 	mov	sp,fp
 202034c:	dfc00117 	ldw	ra,4(sp)
 2020350:	df000017 	ldw	fp,0(sp)
 2020354:	dec00204 	addi	sp,sp,8
 2020358:	f800283a 	ret

0202035c <alt_avalon_sgdma_construct_stream_to_mem_desc>:
  alt_sgdma_descriptor *desc,
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed)
{
 202035c:	defff804 	addi	sp,sp,-32
 2020360:	dfc00715 	stw	ra,28(sp)
 2020364:	df000615 	stw	fp,24(sp)
 2020368:	df000604 	addi	fp,sp,24
 202036c:	e13ffc15 	stw	r4,-16(fp)
 2020370:	e17ffd15 	stw	r5,-12(fp)
 2020374:	e1bffe15 	stw	r6,-8(fp)
 2020378:	3805883a 	mov	r2,r7
 202037c:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_stream_to_mem_desc_burst(desc, next, write_addr, 
 2020380:	e0bfff0b 	ldhu	r2,-4(fp)
 2020384:	e0c00217 	ldw	r3,8(fp)
 2020388:	d8c00015 	stw	r3,0(sp)
 202038c:	d8000115 	stw	zero,4(sp)
 2020390:	e13ffc17 	ldw	r4,-16(fp)
 2020394:	e17ffd17 	ldw	r5,-12(fp)
 2020398:	e1bffe17 	ldw	r6,-8(fp)
 202039c:	100f883a 	mov	r7,r2
 20203a0:	20203b80 	call	20203b8 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>
    length_or_eop, write_fixed, 0);
}
 20203a4:	e037883a 	mov	sp,fp
 20203a8:	dfc00117 	ldw	ra,4(sp)
 20203ac:	df000017 	ldw	fp,0(sp)
 20203b0:	dec00204 	addi	sp,sp,8
 20203b4:	f800283a 	ret

020203b8 <alt_avalon_sgdma_construct_stream_to_mem_desc_burst>:
  alt_sgdma_descriptor *next,
  alt_u32              *write_addr,
  alt_u16               length_or_eop,
  int                   write_fixed,
  int                   write_burst)
{
 20203b8:	defff304 	addi	sp,sp,-52
 20203bc:	dfc00c15 	stw	ra,48(sp)
 20203c0:	df000b15 	stw	fp,44(sp)
 20203c4:	df000b04 	addi	fp,sp,44
 20203c8:	e13ffc15 	stw	r4,-16(fp)
 20203cc:	e17ffd15 	stw	r5,-12(fp)
 20203d0:	e1bffe15 	stw	r6,-8(fp)
 20203d4:	3805883a 	mov	r2,r7
 20203d8:	e0bfff0d 	sth	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 20203dc:	e0bfff0b 	ldhu	r2,-4(fp)
 20203e0:	d8800015 	stw	r2,0(sp)
 20203e4:	d8000115 	stw	zero,4(sp)
 20203e8:	d8000215 	stw	zero,8(sp)
 20203ec:	e0800217 	ldw	r2,8(fp)
 20203f0:	d8800315 	stw	r2,12(sp)
 20203f4:	d8000415 	stw	zero,16(sp)
 20203f8:	e0800317 	ldw	r2,12(fp)
 20203fc:	d8800515 	stw	r2,20(sp)
 2020400:	d8000615 	stw	zero,24(sp)
 2020404:	e13ffc17 	ldw	r4,-16(fp)
 2020408:	e17ffd17 	ldw	r5,-12(fp)
 202040c:	000d883a 	mov	r6,zero
 2020410:	e1fffe17 	ldw	r7,-8(fp)
 2020414:	20208480 	call	2020848 <alt_avalon_sgdma_construct_descriptor_burst>
    0x0,            // Read fixed: N/A in stream-to-mem mode
    write_fixed,
    0,              // Read_burst : N/A in stream-to-mem mode
    write_burst,
    (alt_u8) 0x0);  // Atlantic channel: N/A in stream-to-mem mode
}
 2020418:	e037883a 	mov	sp,fp
 202041c:	dfc00117 	ldw	ra,4(sp)
 2020420:	df000017 	ldw	fp,0(sp)
 2020424:	dec00204 	addi	sp,sp,8
 2020428:	f800283a 	ret

0202042c <alt_avalon_sgdma_construct_mem_to_stream_desc>:
  alt_u16               length,
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  alt_u8                atlantic_channel)
{
 202042c:	defff404 	addi	sp,sp,-48
 2020430:	dfc00b15 	stw	ra,44(sp)
 2020434:	df000a15 	stw	fp,40(sp)
 2020438:	df000a04 	addi	fp,sp,40
 202043c:	e13ffb15 	stw	r4,-20(fp)
 2020440:	e17ffc15 	stw	r5,-16(fp)
 2020444:	e1bffd15 	stw	r6,-12(fp)
 2020448:	3805883a 	mov	r2,r7
 202044c:	e0c00517 	ldw	r3,20(fp)
 2020450:	e0bffe0d 	sth	r2,-8(fp)
 2020454:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_mem_to_stream_desc_burst(desc, next, read_addr, 
 2020458:	e0bffe0b 	ldhu	r2,-8(fp)
 202045c:	e0ffff03 	ldbu	r3,-4(fp)
 2020460:	e1000217 	ldw	r4,8(fp)
 2020464:	d9000015 	stw	r4,0(sp)
 2020468:	e1000317 	ldw	r4,12(fp)
 202046c:	d9000115 	stw	r4,4(sp)
 2020470:	e1000417 	ldw	r4,16(fp)
 2020474:	d9000215 	stw	r4,8(sp)
 2020478:	d8000315 	stw	zero,12(sp)
 202047c:	d8c00415 	stw	r3,16(sp)
 2020480:	e13ffb17 	ldw	r4,-20(fp)
 2020484:	e17ffc17 	ldw	r5,-16(fp)
 2020488:	e1bffd17 	ldw	r6,-12(fp)
 202048c:	100f883a 	mov	r7,r2
 2020490:	20204a80 	call	20204a8 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>
    length, read_fixed, generate_sop, generate_eop, 0, atlantic_channel);

}
 2020494:	e037883a 	mov	sp,fp
 2020498:	dfc00117 	ldw	ra,4(sp)
 202049c:	df000017 	ldw	fp,0(sp)
 20204a0:	dec00204 	addi	sp,sp,8
 20204a4:	f800283a 	ret

020204a8 <alt_avalon_sgdma_construct_mem_to_stream_desc_burst>:
  int                   read_fixed,
  int                   generate_sop,
  int                   generate_eop,
  int                   read_burst,
  alt_u8                atlantic_channel)
{
 20204a8:	defff204 	addi	sp,sp,-56
 20204ac:	dfc00d15 	stw	ra,52(sp)
 20204b0:	df000c15 	stw	fp,48(sp)
 20204b4:	df000c04 	addi	fp,sp,48
 20204b8:	e13ffb15 	stw	r4,-20(fp)
 20204bc:	e17ffc15 	stw	r5,-16(fp)
 20204c0:	e1bffd15 	stw	r6,-12(fp)
 20204c4:	3805883a 	mov	r2,r7
 20204c8:	e0c00617 	ldw	r3,24(fp)
 20204cc:	e0bffe0d 	sth	r2,-8(fp)
 20204d0:	e0ffff05 	stb	r3,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(
 20204d4:	e0fffe0b 	ldhu	r3,-8(fp)
 20204d8:	e0bfff03 	ldbu	r2,-4(fp)
 20204dc:	d8c00015 	stw	r3,0(sp)
 20204e0:	e0c00417 	ldw	r3,16(fp)
 20204e4:	d8c00115 	stw	r3,4(sp)
 20204e8:	e0c00217 	ldw	r3,8(fp)
 20204ec:	d8c00215 	stw	r3,8(sp)
 20204f0:	e0c00317 	ldw	r3,12(fp)
 20204f4:	d8c00315 	stw	r3,12(sp)
 20204f8:	e0c00517 	ldw	r3,20(fp)
 20204fc:	d8c00415 	stw	r3,16(sp)
 2020500:	d8000515 	stw	zero,20(sp)
 2020504:	d8800615 	stw	r2,24(sp)
 2020508:	e13ffb17 	ldw	r4,-20(fp)
 202050c:	e17ffc17 	ldw	r5,-16(fp)
 2020510:	e1bffd17 	ldw	r6,-12(fp)
 2020514:	000f883a 	mov	r7,zero
 2020518:	20208480 	call	2020848 <alt_avalon_sgdma_construct_descriptor_burst>
    read_fixed,
    generate_sop,
    read_burst,
    0,                 // Write_burst : N/A in mem-to-stream mode
    atlantic_channel);
}
 202051c:	e037883a 	mov	sp,fp
 2020520:	dfc00117 	ldw	ra,4(sp)
 2020524:	df000017 	ldw	fp,0(sp)
 2020528:	dec00204 	addi	sp,sp,8
 202052c:	f800283a 	ret

02020530 <alt_avalon_sgdma_register_callback>:
void alt_avalon_sgdma_register_callback(
  alt_sgdma_dev *dev,
  alt_avalon_sgdma_callback callback,
  alt_u32 chain_control,
  void *context)
{
 2020530:	defffb04 	addi	sp,sp,-20
 2020534:	df000415 	stw	fp,16(sp)
 2020538:	df000404 	addi	fp,sp,16
 202053c:	e13ffc15 	stw	r4,-16(fp)
 2020540:	e17ffd15 	stw	r5,-12(fp)
 2020544:	e1bffe15 	stw	r6,-8(fp)
 2020548:	e1ffff15 	stw	r7,-4(fp)
  dev->callback         = callback;
 202054c:	e0bffc17 	ldw	r2,-16(fp)
 2020550:	e0fffd17 	ldw	r3,-12(fp)
 2020554:	10c00915 	stw	r3,36(r2)
  dev->callback_context = context;
 2020558:	e0bffc17 	ldw	r2,-16(fp)
 202055c:	e0ffff17 	ldw	r3,-4(fp)
 2020560:	10c00a15 	stw	r3,40(r2)
  dev->chain_control    = chain_control;
 2020564:	e0bffc17 	ldw	r2,-16(fp)
 2020568:	e0fffe17 	ldw	r3,-8(fp)
 202056c:	10c00b15 	stw	r3,44(r2)
}
 2020570:	e037883a 	mov	sp,fp
 2020574:	df000017 	ldw	fp,0(sp)
 2020578:	dec00104 	addi	sp,sp,4
 202057c:	f800283a 	ret

02020580 <alt_avalon_sgdma_start>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct.
 */
void alt_avalon_sgdma_start(alt_sgdma_dev *dev)
{
 2020580:	defffd04 	addi	sp,sp,-12
 2020584:	df000215 	stw	fp,8(sp)
 2020588:	df000204 	addi	fp,sp,8
 202058c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2020590:	e0bfff17 	ldw	r2,-4(fp)
 2020594:	10800317 	ldw	r2,12(r2)
 2020598:	10800404 	addi	r2,r2,16
 202059c:	10800037 	ldwio	r2,0(r2)
 20205a0:	e0bffe15 	stw	r2,-8(fp)
  control |= ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 20205a4:	e0bffe17 	ldw	r2,-8(fp)
 20205a8:	10800814 	ori	r2,r2,32
 20205ac:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 20205b0:	e0bfff17 	ldw	r2,-4(fp)
 20205b4:	10800317 	ldw	r2,12(r2)
 20205b8:	10800404 	addi	r2,r2,16
 20205bc:	e0fffe17 	ldw	r3,-8(fp)
 20205c0:	10c00035 	stwio	r3,0(r2)
}
 20205c4:	e037883a 	mov	sp,fp
 20205c8:	df000017 	ldw	fp,0(sp)
 20205cc:	dec00104 	addi	sp,sp,4
 20205d0:	f800283a 	ret

020205d4 <alt_avalon_sgdma_stop>:
 *
 * Arguments:
 * - *dev: Pointer to SGDMA device (instance) struct
 */
void alt_avalon_sgdma_stop(alt_sgdma_dev *dev)
{
 20205d4:	defffd04 	addi	sp,sp,-12
 20205d8:	df000215 	stw	fp,8(sp)
 20205dc:	df000204 	addi	fp,sp,8
 20205e0:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 20205e4:	e0bfff17 	ldw	r2,-4(fp)
 20205e8:	10800317 	ldw	r2,12(r2)
 20205ec:	10800404 	addi	r2,r2,16
 20205f0:	10800037 	ldwio	r2,0(r2)
 20205f4:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_RUN_MSK;
 20205f8:	e0fffe17 	ldw	r3,-8(fp)
 20205fc:	00bff7c4 	movi	r2,-33
 2020600:	1884703a 	and	r2,r3,r2
 2020604:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2020608:	e0bfff17 	ldw	r2,-4(fp)
 202060c:	10800317 	ldw	r2,12(r2)
 2020610:	10800404 	addi	r2,r2,16
 2020614:	e0fffe17 	ldw	r3,-8(fp)
 2020618:	10c00035 	stwio	r3,0(r2)
}
 202061c:	e037883a 	mov	sp,fp
 2020620:	df000017 	ldw	fp,0(sp)
 2020624:	dec00104 	addi	sp,sp,4
 2020628:	f800283a 	ret

0202062c <alt_avalon_sgdma_check_descriptor_status>:
 * - 0 if the descriptor is error-free, not "owned by hardware", or
 *   a previously requested transfer has appeared to have completed
 *   normally. Or, various error conditions defined in <errno.h>
 */
int alt_avalon_sgdma_check_descriptor_status(alt_sgdma_descriptor *desc)
{
 202062c:	defffe04 	addi	sp,sp,-8
 2020630:	df000115 	stw	fp,4(sp)
 2020634:	df000104 	addi	fp,sp,4
 2020638:	e13fff15 	stw	r4,-4(fp)
  /* Errors take precedence */
  if( IORD_8DIRECT(&desc->status, 0) &
 202063c:	e0bfff17 	ldw	r2,-4(fp)
 2020640:	10800784 	addi	r2,r2,30
 2020644:	10800023 	ldbuio	r2,0(r2)
 2020648:	10803fcc 	andi	r2,r2,255
 202064c:	10801fcc 	andi	r2,r2,127
 2020650:	10000226 	beq	r2,zero,202065c <alt_avalon_sgdma_check_descriptor_status+0x30>
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_OVERFLOW_MSK |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK     |
        ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) {
    return -EIO;
 2020654:	00bffec4 	movi	r2,-5
 2020658:	00000906 	br	2020680 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

  if( IORD_8DIRECT(&desc->control, 0) &
 202065c:	e0bfff17 	ldw	r2,-4(fp)
 2020660:	108007c4 	addi	r2,r2,31
 2020664:	10800023 	ldbuio	r2,0(r2)
 2020668:	10803fcc 	andi	r2,r2,255
 202066c:	1080200c 	andi	r2,r2,128
 2020670:	10000226 	beq	r2,zero,202067c <alt_avalon_sgdma_check_descriptor_status+0x50>
      ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK) {
    return -EINPROGRESS;
 2020674:	00bfe244 	movi	r2,-119
 2020678:	00000106 	br	2020680 <alt_avalon_sgdma_check_descriptor_status+0x54>
  }

    return 0;
 202067c:	0005883a 	mov	r2,zero
}
 2020680:	e037883a 	mov	sp,fp
 2020684:	df000017 	ldw	fp,0(sp)
 2020688:	dec00104 	addi	sp,sp,4
 202068c:	f800283a 	ret

02020690 <alt_avalon_sgdma_open>:
 * Returns:
 * - Pointer to SGDMA device instance struct, or null if the device
 *   could not be opened.
 */
alt_sgdma_dev* alt_avalon_sgdma_open (const char* name)
{
 2020690:	defffc04 	addi	sp,sp,-16
 2020694:	dfc00315 	stw	ra,12(sp)
 2020698:	df000215 	stw	fp,8(sp)
 202069c:	df000204 	addi	fp,sp,8
 20206a0:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev* dev;

  dev = (alt_sgdma_dev*) alt_find_dev (name, &alt_sgdma_list);
 20206a4:	e13fff17 	ldw	r4,-4(fp)
 20206a8:	d1603504 	addi	r5,gp,-32556
 20206ac:	20370780 	call	2037078 <alt_find_dev>
 20206b0:	e0bffe15 	stw	r2,-8(fp)

  if (NULL == dev) {
 20206b4:	e0bffe17 	ldw	r2,-8(fp)
 20206b8:	1000031e 	bne	r2,zero,20206c8 <alt_avalon_sgdma_open+0x38>
    ALT_ERRNO = ENODEV;
 20206bc:	201ffe80 	call	201ffe8 <alt_get_errno>
 20206c0:	00c004c4 	movi	r3,19
 20206c4:	10c00015 	stw	r3,0(r2)
  }

  return dev;
 20206c8:	e0bffe17 	ldw	r2,-8(fp)
}
 20206cc:	e037883a 	mov	sp,fp
 20206d0:	dfc00117 	ldw	ra,4(sp)
 20206d4:	df000017 	ldw	fp,0(sp)
 20206d8:	dec00204 	addi	sp,sp,8
 20206dc:	f800283a 	ret

020206e0 <alt_avalon_sgdma_construct_descriptor>:
  alt_u16               length_or_eop,
  int                   generate_eop,
  int                   read_fixed,
  int                   write_fixed_or_sop,
  alt_u8                atlantic_channel)
{
 20206e0:	defff104 	addi	sp,sp,-60
 20206e4:	dfc00e15 	stw	ra,56(sp)
 20206e8:	df000d15 	stw	fp,52(sp)
 20206ec:	df000d04 	addi	fp,sp,52
 20206f0:	e13ffa15 	stw	r4,-24(fp)
 20206f4:	e17ffb15 	stw	r5,-20(fp)
 20206f8:	e1bffc15 	stw	r6,-16(fp)
 20206fc:	e1fffd15 	stw	r7,-12(fp)
 2020700:	e0c00217 	ldw	r3,8(fp)
 2020704:	e0800617 	ldw	r2,24(fp)
 2020708:	e0fffe0d 	sth	r3,-8(fp)
 202070c:	e0bfff05 	stb	r2,-4(fp)
  alt_avalon_sgdma_construct_descriptor_burst(desc, next, read_addr, 
 2020710:	e0fffe0b 	ldhu	r3,-8(fp)
 2020714:	e0bfff03 	ldbu	r2,-4(fp)
 2020718:	d8c00015 	stw	r3,0(sp)
 202071c:	e0c00317 	ldw	r3,12(fp)
 2020720:	d8c00115 	stw	r3,4(sp)
 2020724:	e0c00417 	ldw	r3,16(fp)
 2020728:	d8c00215 	stw	r3,8(sp)
 202072c:	e0c00517 	ldw	r3,20(fp)
 2020730:	d8c00315 	stw	r3,12(sp)
 2020734:	d8000415 	stw	zero,16(sp)
 2020738:	d8000515 	stw	zero,20(sp)
 202073c:	d8800615 	stw	r2,24(sp)
 2020740:	e13ffa17 	ldw	r4,-24(fp)
 2020744:	e17ffb17 	ldw	r5,-20(fp)
 2020748:	e1bffc17 	ldw	r6,-16(fp)
 202074c:	e1fffd17 	ldw	r7,-12(fp)
 2020750:	20208480 	call	2020848 <alt_avalon_sgdma_construct_descriptor_burst>
    write_addr, length_or_eop, generate_eop, read_fixed, write_fixed_or_sop, 
    0, 0, atlantic_channel);
}
 2020754:	e037883a 	mov	sp,fp
 2020758:	dfc00117 	ldw	ra,4(sp)
 202075c:	df000017 	ldw	fp,0(sp)
 2020760:	dec00204 	addi	sp,sp,8
 2020764:	f800283a 	ret

02020768 <alt_avalon_sgdma_enable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_enable_desc_poll(alt_sgdma_dev *dev, alt_u32 frequency)
{
 2020768:	defffc04 	addi	sp,sp,-16
 202076c:	df000315 	stw	fp,12(sp)
 2020770:	df000304 	addi	fp,sp,12
 2020774:	e13ffe15 	stw	r4,-8(fp)
 2020778:	e17fff15 	stw	r5,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 202077c:	e0bffe17 	ldw	r2,-8(fp)
 2020780:	10800317 	ldw	r2,12(r2)
 2020784:	10800404 	addi	r2,r2,16
 2020788:	10800037 	ldwio	r2,0(r2)
 202078c:	e0bffd15 	stw	r2,-12(fp)
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
 2020790:	e0fffd17 	ldw	r3,-12(fp)
 2020794:	00a00434 	movhi	r2,32784
 2020798:	10bfffc4 	addi	r2,r2,-1
 202079c:	1884703a 	and	r2,r3,r2
 20207a0:	e0bffd15 	stw	r2,-12(fp)
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
 20207a4:	e0bfff17 	ldw	r2,-4(fp)
 20207a8:	1004953a 	slli	r2,r2,20
 20207ac:	10dffc2c 	andhi	r3,r2,32752

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
  /* Clear descriptor polling frequency */
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK;
  
  control |= ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK | 
 20207b0:	e0bffd17 	ldw	r2,-12(fp)
 20207b4:	1884b03a 	or	r2,r3,r2
 20207b8:	10800134 	orhi	r2,r2,4
 20207bc:	e0bffd15 	stw	r2,-12(fp)
            ((frequency << ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_OFST) & 
            ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_FREQ_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 20207c0:	e0bffe17 	ldw	r2,-8(fp)
 20207c4:	10800317 	ldw	r2,12(r2)
 20207c8:	10800404 	addi	r2,r2,16
 20207cc:	e0fffd17 	ldw	r3,-12(fp)
 20207d0:	10c00035 	stwio	r3,0(r2)
  
  return;
 20207d4:	0001883a 	nop
}
 20207d8:	e037883a 	mov	sp,fp
 20207dc:	df000017 	ldw	fp,0(sp)
 20207e0:	dec00104 	addi	sp,sp,4
 20207e4:	f800283a 	ret

020207e8 <alt_avalon_sgdma_disable_desc_poll>:
 *
 * Returns:
 * - None
 */
void alt_avalon_sgdma_disable_desc_poll(alt_sgdma_dev *dev)
{
 20207e8:	defffd04 	addi	sp,sp,-12
 20207ec:	df000215 	stw	fp,8(sp)
 20207f0:	df000204 	addi	fp,sp,8
 20207f4:	e13fff15 	stw	r4,-4(fp)
  alt_u32 control;

  control = IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 20207f8:	e0bfff17 	ldw	r2,-4(fp)
 20207fc:	10800317 	ldw	r2,12(r2)
 2020800:	10800404 	addi	r2,r2,16
 2020804:	10800037 	ldwio	r2,0(r2)
 2020808:	e0bffe15 	stw	r2,-8(fp)
  control &= ~ALTERA_AVALON_SGDMA_CONTROL_DESC_POLL_EN_MSK;
 202080c:	e0fffe17 	ldw	r3,-8(fp)
 2020810:	00bfff34 	movhi	r2,65532
 2020814:	10bfffc4 	addi	r2,r2,-1
 2020818:	1884703a 	and	r2,r3,r2
 202081c:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, control);
 2020820:	e0bfff17 	ldw	r2,-4(fp)
 2020824:	10800317 	ldw	r2,12(r2)
 2020828:	10800404 	addi	r2,r2,16
 202082c:	e0fffe17 	ldw	r3,-8(fp)
 2020830:	10c00035 	stwio	r3,0(r2)
  
  return;
 2020834:	0001883a 	nop
}
 2020838:	e037883a 	mov	sp,fp
 202083c:	df000017 	ldw	fp,0(sp)
 2020840:	dec00104 	addi	sp,sp,4
 2020844:	f800283a 	ret

02020848 <alt_avalon_sgdma_construct_descriptor_burst>:
  int                   read_fixed,
  int                   write_fixed_or_sop,
  int                   read_burst,
  int                   write_burst,
  alt_u8                atlantic_channel)
{
 2020848:	defff804 	addi	sp,sp,-32
 202084c:	dfc00715 	stw	ra,28(sp)
 2020850:	df000615 	stw	fp,24(sp)
 2020854:	df000604 	addi	fp,sp,24
 2020858:	e13ffa15 	stw	r4,-24(fp)
 202085c:	e17ffb15 	stw	r5,-20(fp)
 2020860:	e1bffc15 	stw	r6,-16(fp)
 2020864:	e1fffd15 	stw	r7,-12(fp)
 2020868:	e0c00217 	ldw	r3,8(fp)
 202086c:	e0800817 	ldw	r2,32(fp)
 2020870:	e0fffe0d 	sth	r3,-8(fp)
 2020874:	e0bfff05 	stb	r2,-4(fp)
   * The SGDMA controller from continuing to process the chain. This is
   * done as a single IO write to bypass cache, without flushing
   * the entire descriptor, since only the 8-bit descriptor status must
   * be flushed.
   */
  IOWR_8DIRECT(&next->control, 0,
 2020878:	e0bffb17 	ldw	r2,-20(fp)
 202087c:	108007c4 	addi	r2,r2,31
 2020880:	e0fffb17 	ldw	r3,-20(fp)
 2020884:	18c007c3 	ldbu	r3,31(r3)
 2020888:	19003fcc 	andi	r4,r3,255
 202088c:	00ffdfc4 	movi	r3,-129
 2020890:	20c6703a 	and	r3,r4,r3
 2020894:	10c00025 	stbio	r3,0(r2)
    (next->control & ~ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_OWNED_BY_HW_MSK));

  desc->read_addr                = read_addr;
 2020898:	e0bffa17 	ldw	r2,-24(fp)
 202089c:	e0fffc17 	ldw	r3,-16(fp)
 20208a0:	18c03fcc 	andi	r3,r3,255
 20208a4:	11000003 	ldbu	r4,0(r2)
 20208a8:	2008703a 	and	r4,r4,zero
 20208ac:	20c6b03a 	or	r3,r4,r3
 20208b0:	10c00005 	stb	r3,0(r2)
 20208b4:	e0fffc17 	ldw	r3,-16(fp)
 20208b8:	1806d23a 	srli	r3,r3,8
 20208bc:	18c03fcc 	andi	r3,r3,255
 20208c0:	11000043 	ldbu	r4,1(r2)
 20208c4:	2008703a 	and	r4,r4,zero
 20208c8:	20c6b03a 	or	r3,r4,r3
 20208cc:	10c00045 	stb	r3,1(r2)
 20208d0:	e0fffc17 	ldw	r3,-16(fp)
 20208d4:	1806d43a 	srli	r3,r3,16
 20208d8:	18c03fcc 	andi	r3,r3,255
 20208dc:	11000083 	ldbu	r4,2(r2)
 20208e0:	2008703a 	and	r4,r4,zero
 20208e4:	20c6b03a 	or	r3,r4,r3
 20208e8:	10c00085 	stb	r3,2(r2)
 20208ec:	e0fffc17 	ldw	r3,-16(fp)
 20208f0:	1806d63a 	srli	r3,r3,24
 20208f4:	110000c3 	ldbu	r4,3(r2)
 20208f8:	2008703a 	and	r4,r4,zero
 20208fc:	20c6b03a 	or	r3,r4,r3
 2020900:	10c000c5 	stb	r3,3(r2)
  desc->write_addr               = write_addr;
 2020904:	e0bffa17 	ldw	r2,-24(fp)
 2020908:	e0fffd17 	ldw	r3,-12(fp)
 202090c:	18c03fcc 	andi	r3,r3,255
 2020910:	11000203 	ldbu	r4,8(r2)
 2020914:	2008703a 	and	r4,r4,zero
 2020918:	20c6b03a 	or	r3,r4,r3
 202091c:	10c00205 	stb	r3,8(r2)
 2020920:	e0fffd17 	ldw	r3,-12(fp)
 2020924:	1806d23a 	srli	r3,r3,8
 2020928:	18c03fcc 	andi	r3,r3,255
 202092c:	11000243 	ldbu	r4,9(r2)
 2020930:	2008703a 	and	r4,r4,zero
 2020934:	20c6b03a 	or	r3,r4,r3
 2020938:	10c00245 	stb	r3,9(r2)
 202093c:	e0fffd17 	ldw	r3,-12(fp)
 2020940:	1806d43a 	srli	r3,r3,16
 2020944:	18c03fcc 	andi	r3,r3,255
 2020948:	11000283 	ldbu	r4,10(r2)
 202094c:	2008703a 	and	r4,r4,zero
 2020950:	20c6b03a 	or	r3,r4,r3
 2020954:	10c00285 	stb	r3,10(r2)
 2020958:	e0fffd17 	ldw	r3,-12(fp)
 202095c:	1806d63a 	srli	r3,r3,24
 2020960:	110002c3 	ldbu	r4,11(r2)
 2020964:	2008703a 	and	r4,r4,zero
 2020968:	20c6b03a 	or	r3,r4,r3
 202096c:	10c002c5 	stb	r3,11(r2)
  desc->next                     = (alt_u32 *) next;
 2020970:	e0bffa17 	ldw	r2,-24(fp)
 2020974:	e0fffb17 	ldw	r3,-20(fp)
 2020978:	18c03fcc 	andi	r3,r3,255
 202097c:	11000403 	ldbu	r4,16(r2)
 2020980:	2008703a 	and	r4,r4,zero
 2020984:	20c6b03a 	or	r3,r4,r3
 2020988:	10c00405 	stb	r3,16(r2)
 202098c:	e0fffb17 	ldw	r3,-20(fp)
 2020990:	1806d23a 	srli	r3,r3,8
 2020994:	18c03fcc 	andi	r3,r3,255
 2020998:	11000443 	ldbu	r4,17(r2)
 202099c:	2008703a 	and	r4,r4,zero
 20209a0:	20c6b03a 	or	r3,r4,r3
 20209a4:	10c00445 	stb	r3,17(r2)
 20209a8:	e0fffb17 	ldw	r3,-20(fp)
 20209ac:	1806d43a 	srli	r3,r3,16
 20209b0:	18c03fcc 	andi	r3,r3,255
 20209b4:	11000483 	ldbu	r4,18(r2)
 20209b8:	2008703a 	and	r4,r4,zero
 20209bc:	20c6b03a 	or	r3,r4,r3
 20209c0:	10c00485 	stb	r3,18(r2)
 20209c4:	e0fffb17 	ldw	r3,-20(fp)
 20209c8:	1806d63a 	srli	r3,r3,24
 20209cc:	110004c3 	ldbu	r4,19(r2)
 20209d0:	2008703a 	and	r4,r4,zero
 20209d4:	20c6b03a 	or	r3,r4,r3
 20209d8:	10c004c5 	stb	r3,19(r2)
  desc->read_addr_pad            = 0x0;
 20209dc:	e0bffa17 	ldw	r2,-24(fp)
 20209e0:	10c00103 	ldbu	r3,4(r2)
 20209e4:	1806703a 	and	r3,r3,zero
 20209e8:	10c00105 	stb	r3,4(r2)
 20209ec:	10c00143 	ldbu	r3,5(r2)
 20209f0:	1806703a 	and	r3,r3,zero
 20209f4:	10c00145 	stb	r3,5(r2)
 20209f8:	10c00183 	ldbu	r3,6(r2)
 20209fc:	1806703a 	and	r3,r3,zero
 2020a00:	10c00185 	stb	r3,6(r2)
 2020a04:	10c001c3 	ldbu	r3,7(r2)
 2020a08:	1806703a 	and	r3,r3,zero
 2020a0c:	10c001c5 	stb	r3,7(r2)
  desc->write_addr_pad           = 0x0;
 2020a10:	e0bffa17 	ldw	r2,-24(fp)
 2020a14:	10c00303 	ldbu	r3,12(r2)
 2020a18:	1806703a 	and	r3,r3,zero
 2020a1c:	10c00305 	stb	r3,12(r2)
 2020a20:	10c00343 	ldbu	r3,13(r2)
 2020a24:	1806703a 	and	r3,r3,zero
 2020a28:	10c00345 	stb	r3,13(r2)
 2020a2c:	10c00383 	ldbu	r3,14(r2)
 2020a30:	1806703a 	and	r3,r3,zero
 2020a34:	10c00385 	stb	r3,14(r2)
 2020a38:	10c003c3 	ldbu	r3,15(r2)
 2020a3c:	1806703a 	and	r3,r3,zero
 2020a40:	10c003c5 	stb	r3,15(r2)
  desc->next_pad                 = 0x0;
 2020a44:	e0bffa17 	ldw	r2,-24(fp)
 2020a48:	10c00503 	ldbu	r3,20(r2)
 2020a4c:	1806703a 	and	r3,r3,zero
 2020a50:	10c00505 	stb	r3,20(r2)
 2020a54:	10c00543 	ldbu	r3,21(r2)
 2020a58:	1806703a 	and	r3,r3,zero
 2020a5c:	10c00545 	stb	r3,21(r2)
 2020a60:	10c00583 	ldbu	r3,22(r2)
 2020a64:	1806703a 	and	r3,r3,zero
 2020a68:	10c00585 	stb	r3,22(r2)
 2020a6c:	10c005c3 	ldbu	r3,23(r2)
 2020a70:	1806703a 	and	r3,r3,zero
 2020a74:	10c005c5 	stb	r3,23(r2)
  desc->bytes_to_transfer        = length_or_eop;
 2020a78:	e0bffa17 	ldw	r2,-24(fp)
 2020a7c:	e0fffe0b 	ldhu	r3,-8(fp)
 2020a80:	18c03fcc 	andi	r3,r3,255
 2020a84:	11000603 	ldbu	r4,24(r2)
 2020a88:	2008703a 	and	r4,r4,zero
 2020a8c:	20c6b03a 	or	r3,r4,r3
 2020a90:	10c00605 	stb	r3,24(r2)
 2020a94:	e0fffe0b 	ldhu	r3,-8(fp)
 2020a98:	1806d23a 	srli	r3,r3,8
 2020a9c:	18ffffcc 	andi	r3,r3,65535
 2020aa0:	11000643 	ldbu	r4,25(r2)
 2020aa4:	2008703a 	and	r4,r4,zero
 2020aa8:	20c6b03a 	or	r3,r4,r3
 2020aac:	10c00645 	stb	r3,25(r2)
  desc->actual_bytes_transferred = 0;
 2020ab0:	e0bffa17 	ldw	r2,-24(fp)
 2020ab4:	10c00703 	ldbu	r3,28(r2)
 2020ab8:	1806703a 	and	r3,r3,zero
 2020abc:	10c00705 	stb	r3,28(r2)
 2020ac0:	10c00743 	ldbu	r3,29(r2)
 2020ac4:	1806703a 	and	r3,r3,zero
 2020ac8:	10c00745 	stb	r3,29(r2)
  desc->status                   = 0x0;
 2020acc:	e0bffa17 	ldw	r2,-24(fp)
 2020ad0:	10000785 	stb	zero,30(r2)

  /* SGDMA burst not currently supported */
  desc->read_burst               = read_burst;
 2020ad4:	e0800617 	ldw	r2,24(fp)
 2020ad8:	1007883a 	mov	r3,r2
 2020adc:	e0bffa17 	ldw	r2,-24(fp)
 2020ae0:	10c00685 	stb	r3,26(r2)
  desc->write_burst              = write_burst;
 2020ae4:	e0800717 	ldw	r2,28(fp)
 2020ae8:	1007883a 	mov	r3,r2
 2020aec:	e0bffa17 	ldw	r2,-24(fp)
 2020af0:	10c006c5 	stb	r3,27(r2)
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 2020af4:	e0800317 	ldw	r2,12(fp)
 2020af8:	10000226 	beq	r2,zero,2020b04 <alt_avalon_sgdma_construct_descriptor_burst+0x2bc>
 2020afc:	00ffe044 	movi	r3,-127
 2020b00:	00000106 	br	2020b08 <alt_avalon_sgdma_construct_descriptor_burst+0x2c0>
 2020b04:	00ffe004 	movi	r3,-128
 2020b08:	e0800417 	ldw	r2,16(fp)
 2020b0c:	10000226 	beq	r2,zero,2020b18 <alt_avalon_sgdma_construct_descriptor_burst+0x2d0>
 2020b10:	00800084 	movi	r2,2
 2020b14:	00000106 	br	2020b1c <alt_avalon_sgdma_construct_descriptor_burst+0x2d4>
 2020b18:	0005883a 	mov	r2,zero
 2020b1c:	1884b03a 	or	r2,r3,r2
 2020b20:	1007883a 	mov	r3,r2
 2020b24:	e0800517 	ldw	r2,20(fp)
 2020b28:	10000226 	beq	r2,zero,2020b34 <alt_avalon_sgdma_construct_descriptor_burst+0x2ec>
 2020b2c:	00800104 	movi	r2,4
 2020b30:	00000106 	br	2020b38 <alt_avalon_sgdma_construct_descriptor_burst+0x2f0>
 2020b34:	0005883a 	mov	r2,zero
 2020b38:	1884b03a 	or	r2,r3,r2
 2020b3c:	1007883a 	mov	r3,r2
 2020b40:	e0bfff03 	ldbu	r2,-4(fp)
 2020b44:	10000426 	beq	r2,zero,2020b58 <alt_avalon_sgdma_construct_descriptor_burst+0x310>
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_GENERATE_EOP_MSK : 0x0)        |
    (read_fixed ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_READ_FIXED_ADDRESS_MSK : 0x0)  |
    (write_fixed_or_sop ?
       ALTERA_AVALON_SGDMA_DESCRIPTOR_CONTROL_WRITE_FIXED_ADDRESS_MSK : 0x0) |
    (atlantic_channel ? ( (atlantic_channel & 0x0F) << 3) : 0)
 2020b48:	e0bfff03 	ldbu	r2,-4(fp)
 2020b4c:	108003cc 	andi	r2,r2,15
 2020b50:	100490fa 	slli	r2,r2,3
 2020b54:	00000106 	br	2020b5c <alt_avalon_sgdma_construct_descriptor_burst+0x314>
   * Note that this step is performed after all other descriptor information
   * has been filled out so that, if the controller already happens to be
   * pointing at this descriptor, it will not run (via the "owned by hardware"
   * bit) until all other descriptor information has been set up.
   */
  desc->control = (
 2020b58:	0005883a 	mov	r2,zero
 2020b5c:	1884b03a 	or	r2,r3,r2
 2020b60:	1007883a 	mov	r3,r2
 2020b64:	e0bffa17 	ldw	r2,-24(fp)
 2020b68:	10c007c5 	stb	r3,31(r2)
  /*
   * Flush completed buffer out of cache. This is done rather than
   * individual cache-bypassed writes to take advantage of any
   * burst-capabilities in the memory we're writing to
   */
  alt_remap_uncached(desc, sizeof(alt_sgdma_descriptor));
 2020b6c:	e13ffa17 	ldw	r4,-24(fp)
 2020b70:	01400804 	movi	r5,32
 2020b74:	20379100 	call	2037910 <alt_remap_uncached>
}
 2020b78:	e037883a 	mov	sp,fp
 2020b7c:	dfc00117 	ldw	ra,4(sp)
 2020b80:	df000017 	ldw	fp,0(sp)
 2020b84:	dec00204 	addi	sp,sp,8
 2020b88:	f800283a 	ret

02020b8c <alt_avalon_sgdma_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_sgdma_irq(void *context)
#else
static void alt_avalon_sgdma_irq(void *context, alt_u32 id)
#endif
{
 2020b8c:	defff904 	addi	sp,sp,-28
 2020b90:	dfc00615 	stw	ra,24(sp)
 2020b94:	df000515 	stw	fp,20(sp)
 2020b98:	df000504 	addi	fp,sp,20
 2020b9c:	e13fff15 	stw	r4,-4(fp)
  alt_sgdma_dev *dev = (alt_sgdma_dev *) context;
 2020ba0:	e0bfff17 	ldw	r2,-4(fp)
 2020ba4:	e0bffb15 	stw	r2,-20(fp)
   * Note: This is explicitly done before calling user interrupt-handling
   * code rather than after; if user ISR code initiates another SGDMA
   * transfer which completes quickly, reading the control register after
   * the callback routine may result in a lost interrupt.
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 
 2020ba8:	e0bffb17 	ldw	r2,-20(fp)
 2020bac:	10800317 	ldw	r2,12(r2)
 2020bb0:	10800404 	addi	r2,r2,16
 2020bb4:	e0fffb17 	ldw	r3,-20(fp)
 2020bb8:	18c00317 	ldw	r3,12(r3)
 2020bbc:	18c00404 	addi	r3,r3,16
 2020bc0:	18c00037 	ldwio	r3,0(r3)
 2020bc4:	18e00034 	orhi	r3,r3,32768
 2020bc8:	10c00035 	stwio	r3,0(r2)
    IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base) | 0x80000000);
  
  /* Dummy read to ensure IRQ is negated before the ISR returns */
  IORD_ALTERA_AVALON_SGDMA_CONTROL(dev->base);
 2020bcc:	e0bffb17 	ldw	r2,-20(fp)
 2020bd0:	10800317 	ldw	r2,12(r2)
 2020bd4:	10800404 	addi	r2,r2,16
 2020bd8:	10800037 	ldwio	r2,0(r2)
   * Other interrupts are explicitly disabled if callbacks
   * are registered because there is no guarantee that they are 
   * preemption-safe. This allows the driver to support 
   * interrupt preemption.
   */
  if(dev->callback) {
 2020bdc:	e0bffb17 	ldw	r2,-20(fp)
 2020be0:	10800917 	ldw	r2,36(r2)
 2020be4:	10001226 	beq	r2,zero,2020c30 <alt_avalon_sgdma_irq+0xa4>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2020be8:	0005303a 	rdctl	r2,status
 2020bec:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2020bf0:	e0fffd17 	ldw	r3,-12(fp)
 2020bf4:	00bfff84 	movi	r2,-2
 2020bf8:	1884703a 	and	r2,r3,r2
 2020bfc:	1001703a 	wrctl	status,r2
  
  return context;
 2020c00:	e0bffd17 	ldw	r2,-12(fp)
    cpu_sr = alt_irq_disable_all();
 2020c04:	e0bffc15 	stw	r2,-16(fp)
    (dev->callback)(dev->callback_context);
 2020c08:	e0bffb17 	ldw	r2,-20(fp)
 2020c0c:	10c00917 	ldw	r3,36(r2)
 2020c10:	e0bffb17 	ldw	r2,-20(fp)
 2020c14:	10800a17 	ldw	r2,40(r2)
 2020c18:	1009883a 	mov	r4,r2
 2020c1c:	183ee83a 	callr	r3
 2020c20:	e0bffc17 	ldw	r2,-16(fp)
 2020c24:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2020c28:	e0bffe17 	ldw	r2,-8(fp)
 2020c2c:	1001703a 	wrctl	status,r2
    alt_irq_enable_all(cpu_sr);
  }
}
 2020c30:	e037883a 	mov	sp,fp
 2020c34:	dfc00117 	ldw	ra,4(sp)
 2020c38:	df000017 	ldw	fp,0(sp)
 2020c3c:	dec00204 	addi	sp,sp,8
 2020c40:	f800283a 	ret

02020c44 <alt_avalon_sgdma_init>:
 * This routine disables interrupts, future descriptor processing,
 * registers a specific instance of the device with the HAL,
 * and installs an interrupt handler for the device.
 */
void alt_avalon_sgdma_init (alt_sgdma_dev *dev, alt_u32 ic_id, alt_u32 irq)
{
 2020c44:	defffa04 	addi	sp,sp,-24
 2020c48:	dfc00515 	stw	ra,20(sp)
 2020c4c:	df000415 	stw	fp,16(sp)
 2020c50:	df000404 	addi	fp,sp,16
 2020c54:	e13ffd15 	stw	r4,-12(fp)
 2020c58:	e17ffe15 	stw	r5,-8(fp)
 2020c5c:	e1bfff15 	stw	r6,-4(fp)

  /* 
   * Halt any current transactions (reset the device)
   * SW reset is written twice per SGDMA documentation 
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2020c60:	e0bffd17 	ldw	r2,-12(fp)
 2020c64:	10800317 	ldw	r2,12(r2)
 2020c68:	10800404 	addi	r2,r2,16
 2020c6c:	00c00074 	movhi	r3,1
 2020c70:	10c00035 	stwio	r3,0(r2)
    ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base,
 2020c74:	e0bffd17 	ldw	r2,-12(fp)
 2020c78:	10800317 	ldw	r2,12(r2)
 2020c7c:	10800404 	addi	r2,r2,16
 2020c80:	00c00074 	movhi	r3,1
 2020c84:	10c00035 	stwio	r3,0(r2)

  /*
   * Disable interrupts, halt future descriptor processing,
   * and clear status register content
   */
  IOWR_ALTERA_AVALON_SGDMA_CONTROL(dev->base, 0x0);
 2020c88:	e0bffd17 	ldw	r2,-12(fp)
 2020c8c:	10800317 	ldw	r2,12(r2)
 2020c90:	10800404 	addi	r2,r2,16
 2020c94:	0007883a 	mov	r3,zero
 2020c98:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS(dev->base, 0xFF);
 2020c9c:	e0bffd17 	ldw	r2,-12(fp)
 2020ca0:	10800317 	ldw	r2,12(r2)
 2020ca4:	00c03fc4 	movi	r3,255
 2020ca8:	10c00035 	stwio	r3,0(r2)

  /* Register this instance of the SGDMA controller with HAL */
  alt_dev_llist_insert((alt_dev_llist*) dev, &alt_sgdma_list);
 2020cac:	e13ffd17 	ldw	r4,-12(fp)
 2020cb0:	d1603504 	addi	r5,gp,-32556
 2020cb4:	2036f200 	call	2036f20 <alt_dev_llist_insert>

  /* Install IRQ handler */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(ic_id, irq, alt_avalon_sgdma_irq, dev, 0x0);
 2020cb8:	d8000015 	stw	zero,0(sp)
 2020cbc:	e13ffe17 	ldw	r4,-8(fp)
 2020cc0:	e17fff17 	ldw	r5,-4(fp)
 2020cc4:	018080b4 	movhi	r6,514
 2020cc8:	3182e304 	addi	r6,r6,2956
 2020ccc:	e1fffd17 	ldw	r7,-12(fp)
 2020cd0:	203739c0 	call	203739c <alt_ic_isr_register>
#else
  alt_irq_register(irq, dev, alt_avalon_sgdma_irq);
#endif  
}
 2020cd4:	e037883a 	mov	sp,fp
 2020cd8:	dfc00117 	ldw	ra,4(sp)
 2020cdc:	df000017 	ldw	fp,0(sp)
 2020ce0:	dec00204 	addi	sp,sp,8
 2020ce4:	f800283a 	ret

02020ce8 <alt_avalon_timer_sc_irq>:
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
static void alt_avalon_timer_sc_irq (void* base)
#else
static void alt_avalon_timer_sc_irq (void* base, alt_u32 id)
#endif
{
 2020ce8:	defffa04 	addi	sp,sp,-24
 2020cec:	dfc00515 	stw	ra,20(sp)
 2020cf0:	df000415 	stw	fp,16(sp)
 2020cf4:	df000404 	addi	fp,sp,16
 2020cf8:	e13fff15 	stw	r4,-4(fp)
  alt_irq_context cpu_sr;
  
  /* clear the interrupt */
  IOWR_ALTERA_AVALON_TIMER_STATUS (base, 0);
 2020cfc:	0007883a 	mov	r3,zero
 2020d00:	e0bfff17 	ldw	r2,-4(fp)
 2020d04:	10c00035 	stwio	r3,0(r2)
  /* 
   * Dummy read to ensure IRQ is negated before the ISR returns.
   * The control register is read because reading the status
   * register has side-effects per the register map documentation.
   */
  IORD_ALTERA_AVALON_TIMER_CONTROL (base);
 2020d08:	e0bfff17 	ldw	r2,-4(fp)
 2020d0c:	10800104 	addi	r2,r2,4
 2020d10:	10800037 	ldwio	r2,0(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2020d14:	0005303a 	rdctl	r2,status
 2020d18:	e0bffd15 	stw	r2,-12(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2020d1c:	e0fffd17 	ldw	r3,-12(fp)
 2020d20:	00bfff84 	movi	r2,-2
 2020d24:	1884703a 	and	r2,r3,r2
 2020d28:	1001703a 	wrctl	status,r2
  
  return context;
 2020d2c:	e0bffd17 	ldw	r2,-12(fp)

  /* 
   * Notify the system of a clock tick. disable interrupts 
   * during this time to safely support ISR preemption
   */
  cpu_sr = alt_irq_disable_all();
 2020d30:	e0bffc15 	stw	r2,-16(fp)
  alt_tick ();
 2020d34:	20158d00 	call	20158d0 <alt_tick>
 2020d38:	e0bffc17 	ldw	r2,-16(fp)
 2020d3c:	e0bffe15 	stw	r2,-8(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2020d40:	e0bffe17 	ldw	r2,-8(fp)
 2020d44:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(cpu_sr);
}
 2020d48:	e037883a 	mov	sp,fp
 2020d4c:	dfc00117 	ldw	ra,4(sp)
 2020d50:	df000017 	ldw	fp,0(sp)
 2020d54:	dec00204 	addi	sp,sp,8
 2020d58:	f800283a 	ret

02020d5c <alt_avalon_timer_sc_init>:
 * auto-generated alt_sys_init() function.
 */

void alt_avalon_timer_sc_init (void* base, alt_u32 irq_controller_id, 
                                alt_u32 irq, alt_u32 freq)
{
 2020d5c:	defff804 	addi	sp,sp,-32
 2020d60:	dfc00715 	stw	ra,28(sp)
 2020d64:	df000615 	stw	fp,24(sp)
 2020d68:	df000604 	addi	fp,sp,24
 2020d6c:	e13ffc15 	stw	r4,-16(fp)
 2020d70:	e17ffd15 	stw	r5,-12(fp)
 2020d74:	e1bffe15 	stw	r6,-8(fp)
 2020d78:	e1ffff15 	stw	r7,-4(fp)
 2020d7c:	e0bfff17 	ldw	r2,-4(fp)
 2020d80:	e0bffb15 	stw	r2,-20(fp)
 * in order to initialise the value of the clock frequency.
 */

static ALT_INLINE int ALT_ALWAYS_INLINE alt_sysclk_init (alt_u32 nticks)
{
  if (! _alt_tick_rate)
 2020d84:	00808174 	movhi	r2,517
 2020d88:	10909504 	addi	r2,r2,16980
 2020d8c:	10800017 	ldw	r2,0(r2)
 2020d90:	1000041e 	bne	r2,zero,2020da4 <alt_avalon_timer_sc_init+0x48>
  {
    _alt_tick_rate = nticks;
 2020d94:	00808174 	movhi	r2,517
 2020d98:	10909504 	addi	r2,r2,16980
 2020d9c:	e0fffb17 	ldw	r3,-20(fp)
 2020da0:	10c00015 	stw	r3,0(r2)
  
  alt_sysclk_init (freq);
  
  /* set to free running mode */
  
  IOWR_ALTERA_AVALON_TIMER_CONTROL (base, 
 2020da4:	e0bffc17 	ldw	r2,-16(fp)
 2020da8:	10800104 	addi	r2,r2,4
 2020dac:	00c001c4 	movi	r3,7
 2020db0:	10c00035 	stwio	r3,0(r2)
            ALTERA_AVALON_TIMER_CONTROL_CONT_MSK |
            ALTERA_AVALON_TIMER_CONTROL_START_MSK);

  /* register the interrupt handler, and enable the interrupt */
#ifdef ALT_ENHANCED_INTERRUPT_API_PRESENT
  alt_ic_isr_register(irq_controller_id, irq, alt_avalon_timer_sc_irq, 
 2020db4:	d8000015 	stw	zero,0(sp)
 2020db8:	e13ffd17 	ldw	r4,-12(fp)
 2020dbc:	e17ffe17 	ldw	r5,-8(fp)
 2020dc0:	018080b4 	movhi	r6,514
 2020dc4:	31833a04 	addi	r6,r6,3304
 2020dc8:	e1fffc17 	ldw	r7,-16(fp)
 2020dcc:	203739c0 	call	203739c <alt_ic_isr_register>
                      base, NULL);
#else
  alt_irq_register (irq, base, alt_avalon_timer_sc_irq);
#endif  
}
 2020dd0:	e037883a 	mov	sp,fp
 2020dd4:	dfc00117 	ldw	ra,4(sp)
 2020dd8:	df000017 	ldw	fp,0(sp)
 2020ddc:	dec00204 	addi	sp,sp,8
 2020de0:	f800283a 	ret

02020de4 <read_word>:
* reads a word from an address in flash
* this is necessary as we can't do 
* unaligned from an unaligned boundary in Nios II
*/
static alt_u32 read_word(alt_u8* current_ptr)
{
 2020de4:	defffa04 	addi	sp,sp,-24
 2020de8:	dfc00515 	stw	ra,20(sp)
 2020dec:	df000415 	stw	fp,16(sp)
 2020df0:	df000404 	addi	fp,sp,16
 2020df4:	e13fff15 	stw	r4,-4(fp)
    alt_u32 RetValue;

    if (ALTERA_RO_ZIPFS_BASE == EPCS_FLASH_CONTROLLER_BASE)  
    {
        /* serial flash */
        alt_u32 Offset = (current_ptr - ALTERA_RO_ZIPFS_BASE);
 2020df8:	e0bfff17 	ldw	r2,-4(fp)
 2020dfc:	e0bffc15 	stw	r2,-16(fp)
        alt_flash_dev *dev = alt_flash_open_dev("/dev/epcs_flash_controller\0");
 2020e00:	01008174 	movhi	r4,517
 2020e04:	2138c504 	addi	r4,r4,-7404
 2020e08:	20150280 	call	2015028 <alt_flash_open_dev>
 2020e0c:	e0bffd15 	stw	r2,-12(fp)
        // TODO should check for open and read errors
        // Do EPCS Flash Read
        alt_epcs_flash_read(dev, Offset, (void*)&RetValue, 4);
 2020e10:	e0fffc17 	ldw	r3,-16(fp)
 2020e14:	e0bffe04 	addi	r2,fp,-8
 2020e18:	e13ffd17 	ldw	r4,-12(fp)
 2020e1c:	180b883a 	mov	r5,r3
 2020e20:	100d883a 	mov	r6,r2
 2020e24:	01c00104 	movi	r7,4
 2020e28:	201f2080 	call	201f208 <alt_epcs_flash_read>
        alt_flash_close_dev(dev);
 2020e2c:	e13ffd17 	ldw	r4,-12(fp)
 2020e30:	20150900 	call	2015090 <alt_flash_close_dev>
        RetValue = (alt_u32)(*current_ptr |
                   (*(current_ptr+1) << 8) |
                   (*(current_ptr+2) << 16) |
                   (*(current_ptr+3) << 24 ));
    }
    return RetValue;
 2020e34:	e0bffe17 	ldw	r2,-8(fp)
}
 2020e38:	e037883a 	mov	sp,fp
 2020e3c:	dfc00117 	ldw	ra,4(sp)
 2020e40:	df000017 	ldw	fp,0(sp)
 2020e44:	dec00204 	addi	sp,sp,8
 2020e48:	f800283a 	ret

02020e4c <read_word_inc>:
* reads a word from an address in flash, and increments the ptr
* this is necessary as we can't do 
* unaligned from an unaligned boundary in Nios II
*/
static alt_u32 read_word_inc(alt_u8** current_ptr)
{
 2020e4c:	defffc04 	addi	sp,sp,-16
 2020e50:	dfc00315 	stw	ra,12(sp)
 2020e54:	df000215 	stw	fp,8(sp)
 2020e58:	df000204 	addi	fp,sp,8
 2020e5c:	e13fff15 	stw	r4,-4(fp)
  alt_u32 value = read_word(*current_ptr);
 2020e60:	e0bfff17 	ldw	r2,-4(fp)
 2020e64:	10800017 	ldw	r2,0(r2)
 2020e68:	1009883a 	mov	r4,r2
 2020e6c:	2020de40 	call	2020de4 <read_word>
 2020e70:	e0bffe15 	stw	r2,-8(fp)
  *current_ptr += 4;
 2020e74:	e0bfff17 	ldw	r2,-4(fp)
 2020e78:	10800017 	ldw	r2,0(r2)
 2020e7c:	10c00104 	addi	r3,r2,4
 2020e80:	e0bfff17 	ldw	r2,-4(fp)
 2020e84:	10c00015 	stw	r3,0(r2)
  return value;
 2020e88:	e0bffe17 	ldw	r2,-8(fp)
}
 2020e8c:	e037883a 	mov	sp,fp
 2020e90:	dfc00117 	ldw	ra,4(sp)
 2020e94:	df000017 	ldw	fp,0(sp)
 2020e98:	dec00204 	addi	sp,sp,8
 2020e9c:	f800283a 	ret

02020ea0 <read_half_word>:
* reads a half word from an address in flash
* this is necessary as we can't do 
* unaligned from an unaligned boundary in Nios II
*/
static alt_u16 read_half_word(alt_u8* current_ptr)
{
 2020ea0:	defffa04 	addi	sp,sp,-24
 2020ea4:	dfc00515 	stw	ra,20(sp)
 2020ea8:	df000415 	stw	fp,16(sp)
 2020eac:	df000404 	addi	fp,sp,16
 2020eb0:	e13fff15 	stw	r4,-4(fp)
        alt_u16 RetValue;
    if (ALTERA_RO_ZIPFS_BASE == EPCS_FLASH_CONTROLLER_BASE)
    {
        alt_u32 Offset = (current_ptr - ALTERA_RO_ZIPFS_BASE);
 2020eb4:	e0bfff17 	ldw	r2,-4(fp)
 2020eb8:	e0bffc15 	stw	r2,-16(fp)
        alt_flash_dev *dev = alt_flash_open_dev("/dev/epcs_flash_controller\0");
 2020ebc:	01008174 	movhi	r4,517
 2020ec0:	2138c504 	addi	r4,r4,-7404
 2020ec4:	20150280 	call	2015028 <alt_flash_open_dev>
 2020ec8:	e0bffd15 	stw	r2,-12(fp)
        // TODO should check for open and read errors
        // Do EPCS Flash Read
        alt_epcs_flash_read(dev, Offset, (void*)&RetValue, 2);
 2020ecc:	e0fffc17 	ldw	r3,-16(fp)
 2020ed0:	e0bffe04 	addi	r2,fp,-8
 2020ed4:	e13ffd17 	ldw	r4,-12(fp)
 2020ed8:	180b883a 	mov	r5,r3
 2020edc:	100d883a 	mov	r6,r2
 2020ee0:	01c00084 	movi	r7,2
 2020ee4:	201f2080 	call	201f208 <alt_epcs_flash_read>
        alt_flash_close_dev(dev);
 2020ee8:	e13ffd17 	ldw	r4,-12(fp)
 2020eec:	20150900 	call	2015090 <alt_flash_close_dev>
    else
    {
        RetValue = (alt_u16)(*current_ptr |
                 (*(current_ptr+1) << 8));
    }
    return RetValue;
 2020ef0:	e0bffe0b 	ldhu	r2,-8(fp)
}
 2020ef4:	e037883a 	mov	sp,fp
 2020ef8:	dfc00117 	ldw	ra,4(sp)
 2020efc:	df000017 	ldw	fp,0(sp)
 2020f00:	dec00204 	addi	sp,sp,8
 2020f04:	f800283a 	ret

02020f08 <read_half_word_inc>:
* reads a half word from an address in flash, and increment the ptr
* this is necessary as we can't do 
* unaligned from an unaligned boundary in Nios II
*/
static alt_u16 read_half_word_inc(alt_u8** current_ptr)
{
 2020f08:	defffc04 	addi	sp,sp,-16
 2020f0c:	dfc00315 	stw	ra,12(sp)
 2020f10:	df000215 	stw	fp,8(sp)
 2020f14:	df000204 	addi	fp,sp,8
 2020f18:	e13fff15 	stw	r4,-4(fp)
  alt_u16 value = read_half_word(*current_ptr);
 2020f1c:	e0bfff17 	ldw	r2,-4(fp)
 2020f20:	10800017 	ldw	r2,0(r2)
 2020f24:	1009883a 	mov	r4,r2
 2020f28:	2020ea00 	call	2020ea0 <read_half_word>
 2020f2c:	e0bffe0d 	sth	r2,-8(fp)
  *current_ptr += 2;
 2020f30:	e0bfff17 	ldw	r2,-4(fp)
 2020f34:	10800017 	ldw	r2,0(r2)
 2020f38:	10c00084 	addi	r3,r2,2
 2020f3c:	e0bfff17 	ldw	r2,-4(fp)
 2020f40:	10c00015 	stw	r3,0(r2)
  return value;
 2020f44:	e0bffe0b 	ldhu	r2,-8(fp)
}
 2020f48:	e037883a 	mov	sp,fp
 2020f4c:	dfc00117 	ldw	ra,4(sp)
 2020f50:	df000017 	ldw	fp,0(sp)
 2020f54:	dec00204 	addi	sp,sp,8
 2020f58:	f800283a 	ret

02020f5c <check_file_header>:
*
* Check that this is a file header we can cope with and inrement the current ptr 
* accordingly
*/
static int check_file_header(alt_u8** current_ptr)
{
 2020f5c:	defff704 	addi	sp,sp,-36
 2020f60:	dfc00815 	stw	ra,32(sp)
 2020f64:	df000715 	stw	fp,28(sp)
 2020f68:	df000704 	addi	fp,sp,28
 2020f6c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = -ENOENT;
 2020f70:	00bfff84 	movi	r2,-2
 2020f74:	e0bff915 	stw	r2,-28(fp)
  alt_u16 name_len, extra_len, version, flags, compression;
  alt_u32 uncompressed_len, compressed_len;

  version = read_half_word_inc(current_ptr);
 2020f78:	e13fff17 	ldw	r4,-4(fp)
 2020f7c:	2020f080 	call	2020f08 <read_half_word_inc>
 2020f80:	e0bffa0d 	sth	r2,-24(fp)

  /* We can parse files designed for version 10 */
  if (version > 10)
 2020f84:	e0bffa0b 	ldhu	r2,-24(fp)
 2020f88:	108002f0 	cmpltui	r2,r2,11
 2020f8c:	10003226 	beq	r2,zero,2021058 <check_file_header+0xfc>
  {
    goto exit;
  }

  /* Read the flags, right now any flags are an error */
  flags = read_half_word_inc(current_ptr);
 2020f90:	e13fff17 	ldw	r4,-4(fp)
 2020f94:	2020f080 	call	2020f08 <read_half_word_inc>
 2020f98:	e0bffa8d 	sth	r2,-22(fp)

  if (flags )
 2020f9c:	e0bffa8b 	ldhu	r2,-22(fp)
 2020fa0:	10002f1e 	bne	r2,zero,2021060 <check_file_header+0x104>
  {
    goto exit;
  }

  compression = read_half_word_inc(current_ptr);
 2020fa4:	e13fff17 	ldw	r4,-4(fp)
 2020fa8:	2020f080 	call	2020f08 <read_half_word_inc>
 2020fac:	e0bffb0d 	sth	r2,-20(fp)

  /* Skip the mod times and the CRC */
  *current_ptr += 8;
 2020fb0:	e0bfff17 	ldw	r2,-4(fp)
 2020fb4:	10800017 	ldw	r2,0(r2)
 2020fb8:	10c00204 	addi	r3,r2,8
 2020fbc:	e0bfff17 	ldw	r2,-4(fp)
 2020fc0:	10c00015 	stw	r3,0(r2)

  /* Read the compressed and uncompressed lengths, these should be the same */
  compressed_len = read_word_inc(current_ptr);
 2020fc4:	e13fff17 	ldw	r4,-4(fp)
 2020fc8:	2020e4c0 	call	2020e4c <read_word_inc>
 2020fcc:	e0bffc15 	stw	r2,-16(fp)
  uncompressed_len = read_word_inc(current_ptr);
 2020fd0:	e13fff17 	ldw	r4,-4(fp)
 2020fd4:	2020e4c0 	call	2020e4c <read_word_inc>
 2020fd8:	e0bffd15 	stw	r2,-12(fp)

  if ((compression) || (compressed_len != uncompressed_len))
 2020fdc:	e0bffb0b 	ldhu	r2,-20(fp)
 2020fe0:	1000201e 	bne	r2,zero,2021064 <check_file_header+0x108>
 2020fe4:	e0fffc17 	ldw	r3,-16(fp)
 2020fe8:	e0bffd17 	ldw	r2,-12(fp)
 2020fec:	18801d1e 	bne	r3,r2,2021064 <check_file_header+0x108>
  {
    goto exit;
  }

  /* Read the length of the name and extra fields */
  name_len = read_half_word_inc(current_ptr);
 2020ff0:	e13fff17 	ldw	r4,-4(fp)
 2020ff4:	2020f080 	call	2020f08 <read_half_word_inc>
 2020ff8:	e0bffe0d 	sth	r2,-8(fp)
  extra_len = read_half_word_inc(current_ptr);
 2020ffc:	e13fff17 	ldw	r4,-4(fp)
 2021000:	2020f080 	call	2020f08 <read_half_word_inc>
 2021004:	e0bffe8d 	sth	r2,-6(fp)

  /* Skip the name and extra fields */
  *current_ptr += name_len;
 2021008:	e0bfff17 	ldw	r2,-4(fp)
 202100c:	10c00017 	ldw	r3,0(r2)
 2021010:	e0bffe0b 	ldhu	r2,-8(fp)
 2021014:	1887883a 	add	r3,r3,r2
 2021018:	e0bfff17 	ldw	r2,-4(fp)
 202101c:	10c00015 	stw	r3,0(r2)
  *current_ptr += extra_len;
 2021020:	e0bfff17 	ldw	r2,-4(fp)
 2021024:	10c00017 	ldw	r3,0(r2)
 2021028:	e0bffe8b 	ldhu	r2,-6(fp)
 202102c:	1887883a 	add	r3,r3,r2
 2021030:	e0bfff17 	ldw	r2,-4(fp)
 2021034:	10c00015 	stw	r3,0(r2)

  *current_ptr += compressed_len;
 2021038:	e0bfff17 	ldw	r2,-4(fp)
 202103c:	10c00017 	ldw	r3,0(r2)
 2021040:	e0bffc17 	ldw	r2,-16(fp)
 2021044:	1887883a 	add	r3,r3,r2
 2021048:	e0bfff17 	ldw	r2,-4(fp)
 202104c:	10c00015 	stw	r3,0(r2)

  ret_code = 0;
 2021050:	e03ff915 	stw	zero,-28(fp)
 2021054:	00000306 	br	2021064 <check_file_header+0x108>
  version = read_half_word_inc(current_ptr);

  /* We can parse files designed for version 10 */
  if (version > 10)
  {
    goto exit;
 2021058:	0001883a 	nop
 202105c:	00000106 	br	2021064 <check_file_header+0x108>
  /* Read the flags, right now any flags are an error */
  flags = read_half_word_inc(current_ptr);

  if (flags )
  {
    goto exit;
 2021060:	0001883a 	nop
  *current_ptr += compressed_len;

  ret_code = 0;

exit:
  return ret_code;
 2021064:	e0bff917 	ldw	r2,-28(fp)
}
 2021068:	e037883a 	mov	sp,fp
 202106c:	dfc00117 	ldw	ra,4(sp)
 2021070:	df000017 	ldw	fp,0(sp)
 2021074:	dec00204 	addi	sp,sp,8
 2021078:	f800283a 	ret

0202107c <check_directory_header>:
* Sanity check an entry in the directory structure
* 
* returns 0 for success -ENOENT if not
*/
int check_directory_header(alt_u8** current_ptr)
{
 202107c:	defff604 	addi	sp,sp,-40
 2021080:	dfc00915 	stw	ra,36(sp)
 2021084:	df000815 	stw	fp,32(sp)
 2021088:	df000804 	addi	fp,sp,32
 202108c:	e13fff15 	stw	r4,-4(fp)
  int ret_code = -ENOENT;
 2021090:	00bfff84 	movi	r2,-2
 2021094:	e0bff815 	stw	r2,-32(fp)
  alt_u16 version, flags, compression, name_len, extra_len, comment_len;
  alt_u32 compressed_len, uncompressed_len;

  /* We don't care what version made this file */
  *current_ptr += 2;
 2021098:	e0bfff17 	ldw	r2,-4(fp)
 202109c:	10800017 	ldw	r2,0(r2)
 20210a0:	10c00084 	addi	r3,r2,2
 20210a4:	e0bfff17 	ldw	r2,-4(fp)
 20210a8:	10c00015 	stw	r3,0(r2)

  /* We can parse files designed for version 10 */
  version = read_half_word_inc(current_ptr);
 20210ac:	e13fff17 	ldw	r4,-4(fp)
 20210b0:	2020f080 	call	2020f08 <read_half_word_inc>
 20210b4:	e0bff90d 	sth	r2,-28(fp)
  if (version > 10)
 20210b8:	e0bff90b 	ldhu	r2,-28(fp)
 20210bc:	108002f0 	cmpltui	r2,r2,11
 20210c0:	10003226 	beq	r2,zero,202118c <check_directory_header+0x110>
  {
    goto exit;
  }

  /* Read the flags, any set are an error */
  flags = read_half_word_inc(current_ptr);
 20210c4:	e13fff17 	ldw	r4,-4(fp)
 20210c8:	2020f080 	call	2020f08 <read_half_word_inc>
 20210cc:	e0bff98d 	sth	r2,-26(fp)

  if (flags )
 20210d0:	e0bff98b 	ldhu	r2,-26(fp)
 20210d4:	10002f1e 	bne	r2,zero,2021194 <check_directory_header+0x118>
  {
    goto exit;
  }

  compression = read_half_word_inc(current_ptr);
 20210d8:	e13fff17 	ldw	r4,-4(fp)
 20210dc:	2020f080 	call	2020f08 <read_half_word_inc>
 20210e0:	e0bffa0d 	sth	r2,-24(fp)


  /* Skip the mod times and the CRC */
  *current_ptr += 8;
 20210e4:	e0bfff17 	ldw	r2,-4(fp)
 20210e8:	10800017 	ldw	r2,0(r2)
 20210ec:	10c00204 	addi	r3,r2,8
 20210f0:	e0bfff17 	ldw	r2,-4(fp)
 20210f4:	10c00015 	stw	r3,0(r2)

  /* Read the compressed and uncompressed lengths,these should be the same */
  compressed_len = read_word_inc(current_ptr);
 20210f8:	e13fff17 	ldw	r4,-4(fp)
 20210fc:	2020e4c0 	call	2020e4c <read_word_inc>
 2021100:	e0bffb15 	stw	r2,-20(fp)
  uncompressed_len = read_word_inc(current_ptr);
 2021104:	e13fff17 	ldw	r4,-4(fp)
 2021108:	2020e4c0 	call	2020e4c <read_word_inc>
 202110c:	e0bffc15 	stw	r2,-16(fp)

  if ((compression) || (compressed_len != uncompressed_len))
 2021110:	e0bffa0b 	ldhu	r2,-24(fp)
 2021114:	1000201e 	bne	r2,zero,2021198 <check_directory_header+0x11c>
 2021118:	e0fffb17 	ldw	r3,-20(fp)
 202111c:	e0bffc17 	ldw	r2,-16(fp)
 2021120:	18801d1e 	bne	r3,r2,2021198 <check_directory_header+0x11c>
  {
    goto exit;
  }

  /* Read the length of the name, extra fields and comment fields*/
  name_len = read_half_word_inc(current_ptr);
 2021124:	e13fff17 	ldw	r4,-4(fp)
 2021128:	2020f080 	call	2020f08 <read_half_word_inc>
 202112c:	e0bffd0d 	sth	r2,-12(fp)
  extra_len = read_half_word_inc(current_ptr);
 2021130:	e13fff17 	ldw	r4,-4(fp)
 2021134:	2020f080 	call	2020f08 <read_half_word_inc>
 2021138:	e0bffd8d 	sth	r2,-10(fp)
  comment_len = read_half_word_inc(current_ptr);
 202113c:	e13fff17 	ldw	r4,-4(fp)
 2021140:	2020f080 	call	2020f08 <read_half_word_inc>
 2021144:	e0bffe0d 	sth	r2,-8(fp)

  /* We don't care about the disk number, the file attributes or the offset */
  *current_ptr += 12;
 2021148:	e0bfff17 	ldw	r2,-4(fp)
 202114c:	10800017 	ldw	r2,0(r2)
 2021150:	10c00304 	addi	r3,r2,12
 2021154:	e0bfff17 	ldw	r2,-4(fp)
 2021158:	10c00015 	stw	r3,0(r2)

  *current_ptr += (name_len + extra_len + comment_len);
 202115c:	e0bfff17 	ldw	r2,-4(fp)
 2021160:	10c00017 	ldw	r3,0(r2)
 2021164:	e13ffd0b 	ldhu	r4,-12(fp)
 2021168:	e0bffd8b 	ldhu	r2,-10(fp)
 202116c:	2089883a 	add	r4,r4,r2
 2021170:	e0bffe0b 	ldhu	r2,-8(fp)
 2021174:	2085883a 	add	r2,r4,r2
 2021178:	1887883a 	add	r3,r3,r2
 202117c:	e0bfff17 	ldw	r2,-4(fp)
 2021180:	10c00015 	stw	r3,0(r2)

  ret_code = 0;
 2021184:	e03ff815 	stw	zero,-32(fp)
 2021188:	00000306 	br	2021198 <check_directory_header+0x11c>

  /* We can parse files designed for version 10 */
  version = read_half_word_inc(current_ptr);
  if (version > 10)
  {
    goto exit;
 202118c:	0001883a 	nop
 2021190:	00000106 	br	2021198 <check_directory_header+0x11c>
  /* Read the flags, any set are an error */
  flags = read_half_word_inc(current_ptr);

  if (flags )
  {
    goto exit;
 2021194:	0001883a 	nop

  *current_ptr += (name_len + extra_len + comment_len);

  ret_code = 0;
exit:
  return ret_code;
 2021198:	e0bff817 	ldw	r2,-32(fp)
}
 202119c:	e037883a 	mov	sp,fp
 20211a0:	dfc00117 	ldw	ra,4(sp)
 20211a4:	df000017 	ldw	fp,0(sp)
 20211a8:	dec00204 	addi	sp,sp,8
 20211ac:	f800283a 	ret

020211b0 <check_directory_table>:
* tokens are in the right place, none of the files are compressed etc.
* 
* returns 0 for success -ENOENT if not
*/
static int check_directory_table(alt_ro_zipfs_dev* dev)
{
 20211b0:	defffa04 	addi	sp,sp,-24
 20211b4:	dfc00515 	stw	ra,20(sp)
 20211b8:	df000415 	stw	fp,16(sp)
 20211bc:	df000404 	addi	fp,sp,16
 20211c0:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 20211c4:	e03ffc15 	stw	zero,-16(fp)
  alt_u8* current_ptr = (alt_u8*)dev->directory;
 20211c8:	e0bfff17 	ldw	r2,-4(fp)
 20211cc:	10800b17 	ldw	r2,44(r2)
 20211d0:	e0bffe15 	stw	r2,-8(fp)
  alt_u32 token;

  while(1)
  {
    token = read_word_inc(&current_ptr);
 20211d4:	e0bffe04 	addi	r2,fp,-8
 20211d8:	1009883a 	mov	r4,r2
 20211dc:	2020e4c0 	call	2020e4c <read_word_inc>
 20211e0:	e0bffd15 	stw	r2,-12(fp)

    switch(token)
 20211e4:	e0bffd17 	ldw	r2,-12(fp)
 20211e8:	00c08074 	movhi	r3,513
 20211ec:	18d2d404 	addi	r3,r3,19280
 20211f0:	10c00426 	beq	r2,r3,2021204 <check_directory_table+0x54>
 20211f4:	00c18174 	movhi	r3,1541
 20211f8:	18d2d404 	addi	r3,r3,19280
 20211fc:	10c00826 	beq	r2,r3,2021220 <check_directory_table+0x70>
 2021200:	00000906 	br	2021228 <check_directory_table+0x78>
    {
    case ZIP_DIRECTORY_RECORD:
      {
        ret_code = check_directory_header(&current_ptr);
 2021204:	e0bffe04 	addi	r2,fp,-8
 2021208:	1009883a 	mov	r4,r2
 202120c:	202107c0 	call	202107c <check_directory_header>
 2021210:	e0bffc15 	stw	r2,-16(fp)
        if (ret_code)
 2021214:	e0bffc17 	ldw	r2,-16(fp)
 2021218:	10000626 	beq	r2,zero,2021234 <check_directory_table+0x84>
        {
          goto exit;
 202121c:	00000706 	br	202123c <check_directory_table+0x8c>
        }
        break;
      }
    case ZIP_END_OF_DIRECTORY_RECORD:
      {
        ret_code = 0;
 2021220:	e03ffc15 	stw	zero,-16(fp)
        goto exit;
 2021224:	00000506 	br	202123c <check_directory_table+0x8c>
      }
    default:
      {
        ret_code = -ENOENT;
 2021228:	00bfff84 	movi	r2,-2
 202122c:	e0bffc15 	stw	r2,-16(fp)
        goto exit;
 2021230:	00000206 	br	202123c <check_directory_table+0x8c>
        ret_code = check_directory_header(&current_ptr);
        if (ret_code)
        {
          goto exit;
        }
        break;
 2021234:	0001883a 	nop
      {
        ret_code = -ENOENT;
        goto exit;
      }
    }
  }
 2021238:	003fe606 	br	20211d4 <check_directory_table+0x24>

exit:
  return ret_code;
 202123c:	e0bffc17 	ldw	r2,-16(fp)
}
 2021240:	e037883a 	mov	sp,fp
 2021244:	dfc00117 	ldw	ra,4(sp)
 2021248:	df000017 	ldw	fp,0(sp)
 202124c:	dec00204 	addi	sp,sp,8
 2021250:	f800283a 	ret

02021254 <find_directory_entry>:
* tokens are in the right place, none of the files are comrpessed etc.
* 
* returns 0 for success -ENOENT if not
*/
static int find_directory_entry(alt_ro_zipfs_dev* dev)
{
 2021254:	defffa04 	addi	sp,sp,-24
 2021258:	dfc00515 	stw	ra,20(sp)
 202125c:	df000415 	stw	fp,16(sp)
 2021260:	df000404 	addi	fp,sp,16
 2021264:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 2021268:	e03ffc15 	stw	zero,-16(fp)
  alt_u32 token;
  alt_u8* current_ptr = dev->base;
 202126c:	e0bfff17 	ldw	r2,-4(fp)
 2021270:	10800a17 	ldw	r2,40(r2)
 2021274:	e0bffe15 	stw	r2,-8(fp)

  while(1)
  {
    token = read_word_inc(&current_ptr);
 2021278:	e0bffe04 	addi	r2,fp,-8
 202127c:	1009883a 	mov	r4,r2
 2021280:	2020e4c0 	call	2020e4c <read_word_inc>
 2021284:	e0bffd15 	stw	r2,-12(fp)

    switch(token)
 2021288:	e0bffd17 	ldw	r2,-12(fp)
 202128c:	00c08074 	movhi	r3,513
 2021290:	18d2d404 	addi	r3,r3,19280
 2021294:	10c00a26 	beq	r2,r3,20212c0 <find_directory_entry+0x6c>
 2021298:	00c100f4 	movhi	r3,1027
 202129c:	18d2d404 	addi	r3,r3,19280
 20212a0:	10c00c1e 	bne	r2,r3,20212d4 <find_directory_entry+0x80>
    {
    case ZIP_FILE_RECORD:
      {
        ret_code = check_file_header(&current_ptr);
 20212a4:	e0bffe04 	addi	r2,fp,-8
 20212a8:	1009883a 	mov	r4,r2
 20212ac:	2020f5c0 	call	2020f5c <check_file_header>
 20212b0:	e0bffc15 	stw	r2,-16(fp)
        if(ret_code)
 20212b4:	e0bffc17 	ldw	r2,-16(fp)
 20212b8:	10000926 	beq	r2,zero,20212e0 <find_directory_entry+0x8c>
        {
          goto exit;
 20212bc:	00000a06 	br	20212e8 <find_directory_entry+0x94>
        }
        break;
      }
    case ZIP_DIRECTORY_RECORD:
      {
        dev->directory = current_ptr - 4;
 20212c0:	e0bffe17 	ldw	r2,-8(fp)
 20212c4:	10ffff04 	addi	r3,r2,-4
 20212c8:	e0bfff17 	ldw	r2,-4(fp)
 20212cc:	10c00b15 	stw	r3,44(r2)
        goto exit;
 20212d0:	00000506 	br	20212e8 <find_directory_entry+0x94>
      }
    default:
      {
        ret_code = -ENOENT;
 20212d4:	00bfff84 	movi	r2,-2
 20212d8:	e0bffc15 	stw	r2,-16(fp)
        goto exit;
 20212dc:	00000206 	br	20212e8 <find_directory_entry+0x94>
        ret_code = check_file_header(&current_ptr);
        if(ret_code)
        {
          goto exit;
        }
        break;
 20212e0:	0001883a 	nop
      {
        ret_code = -ENOENT;
        goto exit;
      }
    }
  }
 20212e4:	003fe406 	br	2021278 <find_directory_entry+0x24>
exit:
  return ret_code;
 20212e8:	e0bffc17 	ldw	r2,-16(fp)
}
 20212ec:	e037883a 	mov	sp,fp
 20212f0:	dfc00117 	ldw	ra,4(sp)
 20212f4:	df000017 	ldw	fp,0(sp)
 20212f8:	dec00204 	addi	sp,sp,8
 20212fc:	f800283a 	ret

02021300 <find_file_entry_by_name>:
*
* returns -ENOENT if fails
*/
static int find_file_entry_by_name( alt_ro_zipfs_dev* dev, alt_fd* fd, 
                                    const alt_u8* name)
{
 2021300:	deffe204 	addi	sp,sp,-120
 2021304:	dfc01d15 	stw	ra,116(sp)
 2021308:	df001c15 	stw	fp,112(sp)
 202130c:	df001c04 	addi	fp,sp,112
 2021310:	e13ffd15 	stw	r4,-12(fp)
 2021314:	e17ffe15 	stw	r5,-8(fp)
 2021318:	e1bfff15 	stw	r6,-4(fp)
  int ret_code = -ENOENT;
 202131c:	00bfff84 	movi	r2,-2
 2021320:	e0bfe415 	stw	r2,-112(fp)
  alt_u32 token;
  alt_u8* current_ptr = dev->directory;
 2021324:	e0bffd17 	ldw	r2,-12(fp)
 2021328:	10800b17 	ldw	r2,44(r2)
 202132c:	e0bfe515 	stw	r2,-108(fp)
  alt_u8 NameStr[64];
  alt_u8 *NamePtr;
  alt_u8 *ReadPtr;
  int loop;

  current_ptr = dev->directory;
 2021330:	e0bffd17 	ldw	r2,-12(fp)
 2021334:	10800b17 	ldw	r2,44(r2)
 2021338:	e0bfe515 	stw	r2,-108(fp)

  while(1)
  {
    token = read_word(current_ptr);
 202133c:	e13fe517 	ldw	r4,-108(fp)
 2021340:	2020de40 	call	2020de4 <read_word>
 2021344:	e0bfe915 	stw	r2,-92(fp)

    if(token != ZIP_DIRECTORY_RECORD)
 2021348:	e0ffe917 	ldw	r3,-92(fp)
 202134c:	00808074 	movhi	r2,513
 2021350:	1092d404 	addi	r2,r2,19280
 2021354:	1880561e 	bne	r3,r2,20214b0 <find_file_entry_by_name+0x1b0>
    {
      break;
    }

    offset = read_word(current_ptr + ZIP_DIR_OFFSET);
 2021358:	e0bfe517 	ldw	r2,-108(fp)
 202135c:	10800a84 	addi	r2,r2,42
 2021360:	1009883a 	mov	r4,r2
 2021364:	2020de40 	call	2020de4 <read_word>
 2021368:	e0bfea15 	stw	r2,-88(fp)
    name_len = read_half_word(current_ptr + ZIP_DIR_NAME_LEN);
 202136c:	e0bfe517 	ldw	r2,-108(fp)
 2021370:	10800704 	addi	r2,r2,28
 2021374:	1009883a 	mov	r4,r2
 2021378:	2020ea00 	call	2020ea0 <read_half_word>
 202137c:	e0bfeb0d 	sth	r2,-84(fp)
    extra_len = read_half_word(current_ptr + ZIP_DIR_EXTRA_LEN);
 2021380:	e0bfe517 	ldw	r2,-108(fp)
 2021384:	10800784 	addi	r2,r2,30
 2021388:	1009883a 	mov	r4,r2
 202138c:	2020ea00 	call	2020ea0 <read_half_word>
 2021390:	e0bfeb8d 	sth	r2,-82(fp)
    comment_len = read_half_word(current_ptr + ZIP_DIR_COMMENT_LEN);
 2021394:	e0bfe517 	ldw	r2,-108(fp)
 2021398:	10800804 	addi	r2,r2,32
 202139c:	1009883a 	mov	r4,r2
 20213a0:	2020ea00 	call	2020ea0 <read_half_word>
 20213a4:	e0bfec0d 	sth	r2,-80(fp)

    //we have to Read the String from 32 bit reads
    ReadPtr = current_ptr;
 20213a8:	e0bfe517 	ldw	r2,-108(fp)
 20213ac:	e0bfe715 	stw	r2,-100(fp)
    NamePtr = NameStr;
 20213b0:	e0bfed04 	addi	r2,fp,-76
 20213b4:	e0bfe615 	stw	r2,-104(fp)
    loop = name_len;
 20213b8:	e0bfeb0b 	ldhu	r2,-84(fp)
 20213bc:	e0bfe815 	stw	r2,-96(fp)
    while (loop > 0)
 20213c0:	00000f06 	br	2021400 <find_file_entry_by_name+0x100>
    {
        *(alt_u32*)NamePtr = read_word(ReadPtr + ZIP_DIR_HEADER_SIZE);
 20213c4:	e0bfe717 	ldw	r2,-100(fp)
 20213c8:	10800b84 	addi	r2,r2,46
 20213cc:	1009883a 	mov	r4,r2
 20213d0:	2020de40 	call	2020de4 <read_word>
 20213d4:	e0ffe617 	ldw	r3,-104(fp)
 20213d8:	18800015 	stw	r2,0(r3)
        NamePtr+=4;
 20213dc:	e0bfe617 	ldw	r2,-104(fp)
 20213e0:	10800104 	addi	r2,r2,4
 20213e4:	e0bfe615 	stw	r2,-104(fp)
        ReadPtr+=4;
 20213e8:	e0bfe717 	ldw	r2,-100(fp)
 20213ec:	10800104 	addi	r2,r2,4
 20213f0:	e0bfe715 	stw	r2,-100(fp)
        loop-=4;
 20213f4:	e0bfe817 	ldw	r2,-96(fp)
 20213f8:	10bfff04 	addi	r2,r2,-4
 20213fc:	e0bfe815 	stw	r2,-96(fp)

    //we have to Read the String from 32 bit reads
    ReadPtr = current_ptr;
    NamePtr = NameStr;
    loop = name_len;
    while (loop > 0)
 2021400:	e0bfe817 	ldw	r2,-96(fp)
 2021404:	00bfef16 	blt	zero,r2,20213c4 <find_file_entry_by_name+0xc4>
        NamePtr+=4;
        ReadPtr+=4;
        loop-=4;
    }

    if ((strlen((const char *)name) == name_len) && 
 2021408:	e13fff17 	ldw	r4,-4(fp)
 202140c:	2007c640 	call	2007c64 <strlen>
 2021410:	e0ffeb0b 	ldhu	r3,-84(fp)
 2021414:	10c01c1e 	bne	r2,r3,2021488 <find_file_entry_by_name+0x188>
    (!strncmp((const char *)NameStr, (const char *)name, name_len)))
 2021418:	e0bfeb0b 	ldhu	r2,-84(fp)
 202141c:	e0ffed04 	addi	r3,fp,-76
 2021420:	1809883a 	mov	r4,r3
 2021424:	e17fff17 	ldw	r5,-4(fp)
 2021428:	100d883a 	mov	r6,r2
 202142c:	2007cf00 	call	2007cf0 <strncmp>
        NamePtr+=4;
        ReadPtr+=4;
        loop-=4;
    }

    if ((strlen((const char *)name) == name_len) && 
 2021430:	1000151e 	bne	r2,zero,2021488 <find_file_entry_by_name+0x188>
    (!strncmp((const char *)NameStr, (const char *)name, name_len)))
    {
      extra_file_len = read_half_word(dev->base + offset + ZIP_FILE_EXTRA_LEN); 
 2021434:	e0bffd17 	ldw	r2,-12(fp)
 2021438:	10c00a17 	ldw	r3,40(r2)
 202143c:	e0bfea17 	ldw	r2,-88(fp)
 2021440:	10800704 	addi	r2,r2,28
 2021444:	1885883a 	add	r2,r3,r2
 2021448:	1009883a 	mov	r4,r2
 202144c:	2020ea00 	call	2020ea0 <read_half_word>
 2021450:	e0bfec8d 	sth	r2,-78(fp)
      fd->priv = dev->base + ZIP_FILE_HEADER_SIZE 
 2021454:	e0bffd17 	ldw	r2,-12(fp)
 2021458:	10c00a17 	ldw	r3,40(r2)
                  + offset + extra_file_len + name_len;
 202145c:	e13fec8b 	ldhu	r4,-78(fp)
 2021460:	e0bfea17 	ldw	r2,-88(fp)
 2021464:	2089883a 	add	r4,r4,r2
 2021468:	e0bfeb0b 	ldhu	r2,-84(fp)
 202146c:	2085883a 	add	r2,r4,r2
 2021470:	10800784 	addi	r2,r2,30
 2021474:	1887883a 	add	r3,r3,r2

    if ((strlen((const char *)name) == name_len) && 
    (!strncmp((const char *)NameStr, (const char *)name, name_len)))
    {
      extra_file_len = read_half_word(dev->base + offset + ZIP_FILE_EXTRA_LEN); 
      fd->priv = dev->base + ZIP_FILE_HEADER_SIZE 
 2021478:	e0bffe17 	ldw	r2,-8(fp)
 202147c:	10c00115 	stw	r3,4(r2)
                  + offset + extra_file_len + name_len;
      ret_code = 0;
 2021480:	e03fe415 	stw	zero,-112(fp)
      break;
 2021484:	00000b06 	br	20214b4 <find_file_entry_by_name+0x1b4>
    }
    current_ptr += ZIP_DIR_HEADER_SIZE + name_len + extra_len + comment_len;
 2021488:	e0bfeb0b 	ldhu	r2,-84(fp)
 202148c:	10c00b84 	addi	r3,r2,46
 2021490:	e0bfeb8b 	ldhu	r2,-82(fp)
 2021494:	1887883a 	add	r3,r3,r2
 2021498:	e0bfec0b 	ldhu	r2,-80(fp)
 202149c:	1885883a 	add	r2,r3,r2
 20214a0:	e0ffe517 	ldw	r3,-108(fp)
 20214a4:	1885883a 	add	r2,r3,r2
 20214a8:	e0bfe515 	stw	r2,-108(fp)
  }
 20214ac:	003fa306 	br	202133c <find_file_entry_by_name+0x3c>
  {
    token = read_word(current_ptr);

    if(token != ZIP_DIRECTORY_RECORD)
    {
      break;
 20214b0:	0001883a 	nop
      break;
    }
    current_ptr += ZIP_DIR_HEADER_SIZE + name_len + extra_len + comment_len;
  }

  return ret_code;
 20214b4:	e0bfe417 	ldw	r2,-112(fp)
}
 20214b8:	e037883a 	mov	sp,fp
 20214bc:	dfc00117 	ldw	ra,4(sp)
 20214c0:	df000017 	ldw	fp,0(sp)
 20214c4:	dec00204 	addi	sp,sp,8
 20214c8:	f800283a 	ret

020214cc <find_file_entry>:
*
* returns -EBADF if fails
*/
static int find_file_entry( alt_ro_zipfs_dev* dev, alt_fd* fd, 
                            alt_u8** start, alt_u32* len)
{
 20214cc:	defff304 	addi	sp,sp,-52
 20214d0:	dfc00c15 	stw	ra,48(sp)
 20214d4:	df000b15 	stw	fp,44(sp)
 20214d8:	df000b04 	addi	fp,sp,44
 20214dc:	e13ffc15 	stw	r4,-16(fp)
 20214e0:	e17ffd15 	stw	r5,-12(fp)
 20214e4:	e1bffe15 	stw	r6,-8(fp)
 20214e8:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = -EBADF;
 20214ec:	00bffdc4 	movi	r2,-9
 20214f0:	e0bff515 	stw	r2,-44(fp)
  alt_u32 token;
  alt_u8* current_ptr = (alt_u8*)dev->directory;
 20214f4:	e0bffc17 	ldw	r2,-16(fp)
 20214f8:	10800b17 	ldw	r2,44(r2)
 20214fc:	e0bff615 	stw	r2,-40(fp)
  alt_u8* end;
  alt_u16 name_len, extra_len, comment_len, extra_file_len;
  alt_u32 offset;

  current_ptr = dev->directory;
 2021500:	e0bffc17 	ldw	r2,-16(fp)
 2021504:	10800b17 	ldw	r2,44(r2)
 2021508:	e0bff615 	stw	r2,-40(fp)
 202150c:	00000106 	br	2021514 <find_file_entry+0x48>
        (fd->priv <= end))
    {
      ret_code = 0;
      break;
    }
  }
 2021510:	0001883a 	nop

  current_ptr = dev->directory;

  while(1)
  {
    token = read_word(current_ptr);
 2021514:	e13ff617 	ldw	r4,-40(fp)
 2021518:	2020de40 	call	2020de4 <read_word>
 202151c:	e0bff715 	stw	r2,-36(fp)

    if(token != ZIP_DIRECTORY_RECORD)
 2021520:	e0fff717 	ldw	r3,-36(fp)
 2021524:	00808074 	movhi	r2,513
 2021528:	1092d404 	addi	r2,r2,19280
 202152c:	1880471e 	bne	r3,r2,202164c <find_file_entry+0x180>
    {
      break;
    }
    
    *len = read_word(current_ptr + ZIP_DIR_UNCOMPRESSED_LEN);
 2021530:	e0bff617 	ldw	r2,-40(fp)
 2021534:	10800604 	addi	r2,r2,24
 2021538:	1009883a 	mov	r4,r2
 202153c:	2020de40 	call	2020de4 <read_word>
 2021540:	e0ffff17 	ldw	r3,-4(fp)
 2021544:	18800015 	stw	r2,0(r3)
    offset = read_word(current_ptr + ZIP_DIR_OFFSET);
 2021548:	e0bff617 	ldw	r2,-40(fp)
 202154c:	10800a84 	addi	r2,r2,42
 2021550:	1009883a 	mov	r4,r2
 2021554:	2020de40 	call	2020de4 <read_word>
 2021558:	e0bff815 	stw	r2,-32(fp)
    name_len = read_half_word(current_ptr + ZIP_DIR_NAME_LEN);
 202155c:	e0bff617 	ldw	r2,-40(fp)
 2021560:	10800704 	addi	r2,r2,28
 2021564:	1009883a 	mov	r4,r2
 2021568:	2020ea00 	call	2020ea0 <read_half_word>
 202156c:	e0bff90d 	sth	r2,-28(fp)
    extra_len = read_half_word(current_ptr + ZIP_DIR_EXTRA_LEN);
 2021570:	e0bff617 	ldw	r2,-40(fp)
 2021574:	10800784 	addi	r2,r2,30
 2021578:	1009883a 	mov	r4,r2
 202157c:	2020ea00 	call	2020ea0 <read_half_word>
 2021580:	e0bff98d 	sth	r2,-26(fp)
    comment_len = read_half_word(current_ptr + ZIP_DIR_COMMENT_LEN);
 2021584:	e0bff617 	ldw	r2,-40(fp)
 2021588:	10800804 	addi	r2,r2,32
 202158c:	1009883a 	mov	r4,r2
 2021590:	2020ea00 	call	2020ea0 <read_half_word>
 2021594:	e0bffa0d 	sth	r2,-24(fp)
    current_ptr += ZIP_DIR_HEADER_SIZE + name_len + extra_len + comment_len;
 2021598:	e0bff90b 	ldhu	r2,-28(fp)
 202159c:	10c00b84 	addi	r3,r2,46
 20215a0:	e0bff98b 	ldhu	r2,-26(fp)
 20215a4:	1887883a 	add	r3,r3,r2
 20215a8:	e0bffa0b 	ldhu	r2,-24(fp)
 20215ac:	1885883a 	add	r2,r3,r2
 20215b0:	e0fff617 	ldw	r3,-40(fp)
 20215b4:	1885883a 	add	r2,r3,r2
 20215b8:	e0bff615 	stw	r2,-40(fp)

    extra_file_len = read_half_word(dev->base + offset + ZIP_FILE_EXTRA_LEN); 
 20215bc:	e0bffc17 	ldw	r2,-16(fp)
 20215c0:	10c00a17 	ldw	r3,40(r2)
 20215c4:	e0bff817 	ldw	r2,-32(fp)
 20215c8:	10800704 	addi	r2,r2,28
 20215cc:	1885883a 	add	r2,r3,r2
 20215d0:	1009883a 	mov	r4,r2
 20215d4:	2020ea00 	call	2020ea0 <read_half_word>
 20215d8:	e0bffa8d 	sth	r2,-22(fp)

    *start = dev->base + ZIP_FILE_HEADER_SIZE + offset + extra_file_len + name_len;
 20215dc:	e0bffc17 	ldw	r2,-16(fp)
 20215e0:	10c00a17 	ldw	r3,40(r2)
 20215e4:	e13ffa8b 	ldhu	r4,-22(fp)
 20215e8:	e0bff817 	ldw	r2,-32(fp)
 20215ec:	2089883a 	add	r4,r4,r2
 20215f0:	e0bff90b 	ldhu	r2,-28(fp)
 20215f4:	2085883a 	add	r2,r4,r2
 20215f8:	10800784 	addi	r2,r2,30
 20215fc:	1887883a 	add	r3,r3,r2
 2021600:	e0bffe17 	ldw	r2,-8(fp)
 2021604:	10c00015 	stw	r3,0(r2)

    /* The plus 1 is for the End of file condition */
    end = *start + *len;
 2021608:	e0bffe17 	ldw	r2,-8(fp)
 202160c:	10c00017 	ldw	r3,0(r2)
 2021610:	e0bfff17 	ldw	r2,-4(fp)
 2021614:	10800017 	ldw	r2,0(r2)
 2021618:	1885883a 	add	r2,r3,r2
 202161c:	e0bffb15 	stw	r2,-20(fp)
    if ((fd->priv >= *start ) &&
 2021620:	e0bffd17 	ldw	r2,-12(fp)
 2021624:	10c00117 	ldw	r3,4(r2)
 2021628:	e0bffe17 	ldw	r2,-8(fp)
 202162c:	10800017 	ldw	r2,0(r2)
 2021630:	18bfb736 	bltu	r3,r2,2021510 <find_file_entry+0x44>
        (fd->priv <= end))
 2021634:	e0bffd17 	ldw	r2,-12(fp)
 2021638:	10800117 	ldw	r2,4(r2)

    *start = dev->base + ZIP_FILE_HEADER_SIZE + offset + extra_file_len + name_len;

    /* The plus 1 is for the End of file condition */
    end = *start + *len;
    if ((fd->priv >= *start ) &&
 202163c:	e0fffb17 	ldw	r3,-20(fp)
 2021640:	18bfb336 	bltu	r3,r2,2021510 <find_file_entry+0x44>
        (fd->priv <= end))
    {
      ret_code = 0;
 2021644:	e03ff515 	stw	zero,-44(fp)
      break;
 2021648:	00000106 	br	2021650 <find_file_entry+0x184>
  {
    token = read_word(current_ptr);

    if(token != ZIP_DIRECTORY_RECORD)
    {
      break;
 202164c:	0001883a 	nop
      ret_code = 0;
      break;
    }
  }

  return ret_code;
 2021650:	e0bff517 	ldw	r2,-44(fp)
}
 2021654:	e037883a 	mov	sp,fp
 2021658:	dfc00117 	ldw	ra,4(sp)
 202165c:	df000017 	ldw	fp,0(sp)
 2021660:	dec00204 	addi	sp,sp,8
 2021664:	f800283a 	ret

02021668 <alt_ro_zipfs_open>:
* Find the Central dircetory and then find the pointer to this file
* from that.
*
*/
int alt_ro_zipfs_open(alt_fd* fd, const char* name, int flags, int mode)
{
 2021668:	defff804 	addi	sp,sp,-32
 202166c:	dfc00715 	stw	ra,28(sp)
 2021670:	df000615 	stw	fp,24(sp)
 2021674:	df000604 	addi	fp,sp,24
 2021678:	e13ffc15 	stw	r4,-16(fp)
 202167c:	e17ffd15 	stw	r5,-12(fp)
 2021680:	e1bffe15 	stw	r6,-8(fp)
 2021684:	e1ffff15 	stw	r7,-4(fp)
  int ret_code = -EROFS;
 2021688:	00bff884 	movi	r2,-30
 202168c:	e0bffa15 	stw	r2,-24(fp)
  alt_ro_zipfs_dev* dev= (alt_ro_zipfs_dev*)fd->dev;
 2021690:	e0bffc17 	ldw	r2,-16(fp)
 2021694:	10800017 	ldw	r2,0(r2)
 2021698:	e0bffb15 	stw	r2,-20(fp)

#ifdef ALT_USE_DIRECT_DRIVERS
  ALT_LINK_ERROR("Error: Read-only ZIP filesystem not supported when direct drivers are used.");
#endif

  if (flags == O_RDONLY )
 202169c:	e0bffe17 	ldw	r2,-8(fp)
 20216a0:	10000f1e 	bne	r2,zero,20216e0 <alt_ro_zipfs_open+0x78>
  {
    if (dev->directory != NULL)
 20216a4:	e0bffb17 	ldw	r2,-20(fp)
 20216a8:	10800b17 	ldw	r2,44(r2)
 20216ac:	10000c26 	beq	r2,zero,20216e0 <alt_ro_zipfs_open+0x78>
    {
      ret_code = find_file_entry_by_name( dev, fd, 
                                          (const alt_u8*)(name+strlen(dev->fs_dev.name)+1));
 20216b0:	e0bffb17 	ldw	r2,-20(fp)
 20216b4:	10800217 	ldw	r2,8(r2)
 20216b8:	1009883a 	mov	r4,r2
 20216bc:	2007c640 	call	2007c64 <strlen>
 20216c0:	10800044 	addi	r2,r2,1
 20216c4:	e0fffd17 	ldw	r3,-12(fp)
 20216c8:	1885883a 	add	r2,r3,r2

  if (flags == O_RDONLY )
  {
    if (dev->directory != NULL)
    {
      ret_code = find_file_entry_by_name( dev, fd, 
 20216cc:	e13ffb17 	ldw	r4,-20(fp)
 20216d0:	e17ffc17 	ldw	r5,-16(fp)
 20216d4:	100d883a 	mov	r6,r2
 20216d8:	20213000 	call	2021300 <find_file_entry_by_name>
 20216dc:	e0bffa15 	stw	r2,-24(fp)
                                          (const alt_u8*)(name+strlen(dev->fs_dev.name)+1));
    }
  }

  return ret_code;
 20216e0:	e0bffa17 	ldw	r2,-24(fp)
}
 20216e4:	e037883a 	mov	sp,fp
 20216e8:	dfc00117 	ldw	ra,4(sp)
 20216ec:	df000017 	ldw	fp,0(sp)
 20216f0:	dec00204 	addi	sp,sp,8
 20216f4:	f800283a 	ret

020216f8 <alt_ro_zipfs_read>:
* alt_ro_zipfs_read
*
* Read the file
*/
int alt_ro_zipfs_read(alt_fd* fd, char* ptr, int len)
{
 20216f8:	defff104 	addi	sp,sp,-60
 20216fc:	dfc00e15 	stw	ra,56(sp)
 2021700:	df000d15 	stw	fp,52(sp)
 2021704:	df000d04 	addi	fp,sp,52
 2021708:	e13ffd15 	stw	r4,-12(fp)
 202170c:	e17ffe15 	stw	r5,-8(fp)
 2021710:	e1bfff15 	stw	r6,-4(fp)
  alt_ro_zipfs_dev* dev= (alt_ro_zipfs_dev*)fd->dev;
 2021714:	e0bffd17 	ldw	r2,-12(fp)
 2021718:	10800017 	ldw	r2,0(r2)
 202171c:	e0bff315 	stw	r2,-52(fp)
  alt_u8 *start, *current;
  alt_u32 file_len;
  int amount_to_copy;
  alt_irq_context context;

  find_file_entry(dev, fd, &start, &file_len);
 2021720:	e0fffb04 	addi	r3,fp,-20
 2021724:	e0bffc04 	addi	r2,fp,-16
 2021728:	e13ff317 	ldw	r4,-52(fp)
 202172c:	e17ffd17 	ldw	r5,-12(fp)
 2021730:	180d883a 	mov	r6,r3
 2021734:	100f883a 	mov	r7,r2
 2021738:	20214cc0 	call	20214cc <find_file_entry>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 202173c:	0005303a 	rdctl	r2,status
 2021740:	e0bff915 	stw	r2,-28(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2021744:	e0fff917 	ldw	r3,-28(fp)
 2021748:	00bfff84 	movi	r2,-2
 202174c:	1884703a 	and	r2,r3,r2
 2021750:	1001703a 	wrctl	status,r2
  
  return context;
 2021754:	e0bff917 	ldw	r2,-28(fp)
  *
  * We could use a Mutex or a binary semaphore, but those would have 
  * a much bigger code footprint and disable interrupts for as many 
  * instructions anyway
  */
  context = alt_irq_disable_all();
 2021758:	e0bff415 	stw	r2,-48(fp)
  current = fd->priv;
 202175c:	e0bffd17 	ldw	r2,-12(fp)
 2021760:	10800117 	ldw	r2,4(r2)
 2021764:	e0bff515 	stw	r2,-44(fp)
  amount_to_copy = MIN(len, file_len - (current - start));
 2021768:	e0bffb17 	ldw	r2,-20(fp)
 202176c:	1007883a 	mov	r3,r2
 2021770:	e0bff517 	ldw	r2,-44(fp)
 2021774:	1885c83a 	sub	r2,r3,r2
 2021778:	1007883a 	mov	r3,r2
 202177c:	e0bffc17 	ldw	r2,-16(fp)
 2021780:	1885883a 	add	r2,r3,r2
 2021784:	e0ffff17 	ldw	r3,-4(fp)
 2021788:	1880012e 	bgeu	r3,r2,2021790 <alt_ro_zipfs_read+0x98>
 202178c:	1805883a 	mov	r2,r3
 2021790:	e0bff615 	stw	r2,-40(fp)
  fd->priv += amount_to_copy;
 2021794:	e0bffd17 	ldw	r2,-12(fp)
 2021798:	10c00117 	ldw	r3,4(r2)
 202179c:	e0bff617 	ldw	r2,-40(fp)
 20217a0:	1887883a 	add	r3,r3,r2
 20217a4:	e0bffd17 	ldw	r2,-12(fp)
 20217a8:	10c00115 	stw	r3,4(r2)
 20217ac:	e0bff417 	ldw	r2,-48(fp)
 20217b0:	e0bffa15 	stw	r2,-24(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 20217b4:	e0bffa17 	ldw	r2,-24(fp)
 20217b8:	1001703a 	wrctl	status,r2
  alt_irq_enable_all(context);

  if (ALTERA_RO_ZIPFS_BASE == EPCS_FLASH_CONTROLLER_BASE)  /* i.e. if serial flash */
    {
        /* serial flash */
        alt_u32 Offset = (current - ALTERA_RO_ZIPFS_BASE);
 20217bc:	e0bff517 	ldw	r2,-44(fp)
 20217c0:	e0bff715 	stw	r2,-36(fp)
        alt_flash_dev *fdev = alt_flash_open_dev("/dev/epcs_flash_controller\0");
 20217c4:	01008174 	movhi	r4,517
 20217c8:	2138c504 	addi	r4,r4,-7404
 20217cc:	20150280 	call	2015028 <alt_flash_open_dev>
 20217d0:	e0bff815 	stw	r2,-32(fp)
        // TODO should check for open and read errors
        // Do EPCS Flash Read 
        alt_epcs_flash_read(fdev, Offset, (char*)ptr , amount_to_copy);
 20217d4:	e0bff717 	ldw	r2,-36(fp)
 20217d8:	e13ff817 	ldw	r4,-32(fp)
 20217dc:	100b883a 	mov	r5,r2
 20217e0:	e1bffe17 	ldw	r6,-8(fp)
 20217e4:	e1fff617 	ldw	r7,-40(fp)
 20217e8:	201f2080 	call	201f208 <alt_epcs_flash_read>
        alt_flash_close_dev(fdev);
 20217ec:	e13ff817 	ldw	r4,-32(fp)
 20217f0:	20150900 	call	2015090 <alt_flash_close_dev>
    else   /* memory mapped i.e. parallel flash */
    {
        memcpy(ptr, current, amount_to_copy);
    }

  return amount_to_copy;
 20217f4:	e0bff617 	ldw	r2,-40(fp)
}
 20217f8:	e037883a 	mov	sp,fp
 20217fc:	dfc00117 	ldw	ra,4(sp)
 2021800:	df000017 	ldw	fp,0(sp)
 2021804:	dec00204 	addi	sp,sp,8
 2021808:	f800283a 	ret

0202180c <alt_ro_zipfs_seek>:
* Move around within a file
*
* returns -EROFS for a seek beyond the end of the file
*/
int alt_ro_zipfs_seek(alt_fd* fd, int ptr, int dir)
{
 202180c:	defff704 	addi	sp,sp,-36
 2021810:	dfc00815 	stw	ra,32(sp)
 2021814:	df000715 	stw	fp,28(sp)
 2021818:	df000704 	addi	fp,sp,28
 202181c:	e13ffd15 	stw	r4,-12(fp)
 2021820:	e17ffe15 	stw	r5,-8(fp)
 2021824:	e1bfff15 	stw	r6,-4(fp)
  int ret_code;
  alt_ro_zipfs_dev* dev= (alt_ro_zipfs_dev*)fd->dev;
 2021828:	e0bffd17 	ldw	r2,-12(fp)
 202182c:	10800017 	ldw	r2,0(r2)
 2021830:	e0bffa15 	stw	r2,-24(fp)
  alt_u8* start;
  alt_u32 len;

  find_file_entry(dev, fd, &start, &len);
 2021834:	e0fffb04 	addi	r3,fp,-20
 2021838:	e0bffc04 	addi	r2,fp,-16
 202183c:	e13ffa17 	ldw	r4,-24(fp)
 2021840:	e17ffd17 	ldw	r5,-12(fp)
 2021844:	180d883a 	mov	r6,r3
 2021848:	100f883a 	mov	r7,r2
 202184c:	20214cc0 	call	20214cc <find_file_entry>

  switch(dir)
 2021850:	e0bfff17 	ldw	r2,-4(fp)
 2021854:	10c00060 	cmpeqi	r3,r2,1
 2021858:	1800041e 	bne	r3,zero,202186c <alt_ro_zipfs_seek+0x60>
 202185c:	10c000a0 	cmpeqi	r3,r2,2
 2021860:	1800201e 	bne	r3,zero,20218e4 <alt_ro_zipfs_seek+0xd8>
 2021864:	10001326 	beq	r2,zero,20218b4 <alt_ro_zipfs_seek+0xa8>
 2021868:	00002b06 	br	2021918 <alt_ro_zipfs_seek+0x10c>
  {

  case SEEK_CUR:
    {
      /* Seek from current position */
      if ((fd->priv + ptr) > (start +len))
 202186c:	e0bffd17 	ldw	r2,-12(fp)
 2021870:	10c00117 	ldw	r3,4(r2)
 2021874:	e0bffe17 	ldw	r2,-8(fp)
 2021878:	1885883a 	add	r2,r3,r2
 202187c:	e13ffb17 	ldw	r4,-20(fp)
 2021880:	e0fffc17 	ldw	r3,-16(fp)
 2021884:	20c7883a 	add	r3,r4,r3
 2021888:	1880032e 	bgeu	r3,r2,2021898 <alt_ro_zipfs_seek+0x8c>
      {
        ret_code = -EINVAL;
 202188c:	00bffa84 	movi	r2,-22
 2021890:	e0bff915 	stw	r2,-28(fp)
        goto exit;
 2021894:	00002606 	br	2021930 <alt_ro_zipfs_seek+0x124>
      }

      fd->priv += ptr;
 2021898:	e0bffd17 	ldw	r2,-12(fp)
 202189c:	10c00117 	ldw	r3,4(r2)
 20218a0:	e0bffe17 	ldw	r2,-8(fp)
 20218a4:	1887883a 	add	r3,r3,r2
 20218a8:	e0bffd17 	ldw	r2,-12(fp)
 20218ac:	10c00115 	stw	r3,4(r2)
      break;
 20218b0:	00001906 	br	2021918 <alt_ro_zipfs_seek+0x10c>
    }
  case SEEK_SET:
    {
      /* Seek from the beginning */
      if (ptr > len)
 20218b4:	e0bffe17 	ldw	r2,-8(fp)
 20218b8:	e0fffc17 	ldw	r3,-16(fp)
 20218bc:	1880032e 	bgeu	r3,r2,20218cc <alt_ro_zipfs_seek+0xc0>
      {
        ret_code = -EINVAL;
 20218c0:	00bffa84 	movi	r2,-22
 20218c4:	e0bff915 	stw	r2,-28(fp)
        goto exit;
 20218c8:	00001906 	br	2021930 <alt_ro_zipfs_seek+0x124>
      }

      fd->priv = start + ptr;
 20218cc:	e0fffb17 	ldw	r3,-20(fp)
 20218d0:	e0bffe17 	ldw	r2,-8(fp)
 20218d4:	1887883a 	add	r3,r3,r2
 20218d8:	e0bffd17 	ldw	r2,-12(fp)
 20218dc:	10c00115 	stw	r3,4(r2)
      break;
 20218e0:	00000d06 	br	2021918 <alt_ro_zipfs_seek+0x10c>
    }
  case SEEK_END:
    {
      if(ptr > 0)
 20218e4:	e0bffe17 	ldw	r2,-8(fp)
 20218e8:	0080030e 	bge	zero,r2,20218f8 <alt_ro_zipfs_seek+0xec>
      {
        ret_code = -EINVAL;
 20218ec:	00bffa84 	movi	r2,-22
 20218f0:	e0bff915 	stw	r2,-28(fp)
        goto exit;
 20218f4:	00000e06 	br	2021930 <alt_ro_zipfs_seek+0x124>
      }

      fd->priv = start + ptr + len;
 20218f8:	e0fffb17 	ldw	r3,-20(fp)
 20218fc:	e13ffe17 	ldw	r4,-8(fp)
 2021900:	e0bffc17 	ldw	r2,-16(fp)
 2021904:	2085883a 	add	r2,r4,r2
 2021908:	1887883a 	add	r3,r3,r2
 202190c:	e0bffd17 	ldw	r2,-12(fp)
 2021910:	10c00115 	stw	r3,4(r2)
      break;
 2021914:	0001883a 	nop
    }
  }
  ret_code = (int)(fd->priv - start);
 2021918:	e0bffd17 	ldw	r2,-12(fp)
 202191c:	10800117 	ldw	r2,4(r2)
 2021920:	1007883a 	mov	r3,r2
 2021924:	e0bffb17 	ldw	r2,-20(fp)
 2021928:	1885c83a 	sub	r2,r3,r2
 202192c:	e0bff915 	stw	r2,-28(fp)

exit:
  return ret_code;
 2021930:	e0bff917 	ldw	r2,-28(fp)
}
 2021934:	e037883a 	mov	sp,fp
 2021938:	dfc00117 	ldw	ra,4(sp)
 202193c:	df000017 	ldw	fp,0(sp)
 2021940:	dec00204 	addi	sp,sp,8
 2021944:	f800283a 	ret

02021948 <alt_ro_zipfs_fstat>:
* 
* Return the file status information, the only fields we fill in are
* the size and that this really is a file, not a device
*/
int alt_ro_zipfs_fstat(alt_fd* fd, struct stat* buf)
{
 2021948:	defff804 	addi	sp,sp,-32
 202194c:	dfc00715 	stw	ra,28(sp)
 2021950:	df000615 	stw	fp,24(sp)
 2021954:	df000604 	addi	fp,sp,24
 2021958:	e13ffe15 	stw	r4,-8(fp)
 202195c:	e17fff15 	stw	r5,-4(fp)
  alt_ro_zipfs_dev* dev= (alt_ro_zipfs_dev*)fd->dev;
 2021960:	e0bffe17 	ldw	r2,-8(fp)
 2021964:	10800017 	ldw	r2,0(r2)
 2021968:	e0bffa15 	stw	r2,-24(fp)
  alt_u8* start;
  alt_u32 len;
  int ret_code = 0;
 202196c:	e03ffb15 	stw	zero,-20(fp)

  find_file_entry(dev, fd, &start, &len);
 2021970:	e0fffc04 	addi	r3,fp,-16
 2021974:	e0bffd04 	addi	r2,fp,-12
 2021978:	e13ffa17 	ldw	r4,-24(fp)
 202197c:	e17ffe17 	ldw	r5,-8(fp)
 2021980:	180d883a 	mov	r6,r3
 2021984:	100f883a 	mov	r7,r2
 2021988:	20214cc0 	call	20214cc <find_file_entry>
  buf->st_mode = S_IFREG;
 202198c:	e0bfff17 	ldw	r2,-4(fp)
 2021990:	00e00014 	movui	r3,32768
 2021994:	10c00115 	stw	r3,4(r2)
  buf->st_size = (off_t)len;
 2021998:	e0bffd17 	ldw	r2,-12(fp)
 202199c:	1007883a 	mov	r3,r2
 20219a0:	e0bfff17 	ldw	r2,-4(fp)
 20219a4:	10c00415 	stw	r3,16(r2)

  return ret_code;
 20219a8:	e0bffb17 	ldw	r2,-20(fp)
}
 20219ac:	e037883a 	mov	sp,fp
 20219b0:	dfc00117 	ldw	ra,4(sp)
 20219b4:	df000017 	ldw	fp,0(sp)
 20219b8:	dec00204 	addi	sp,sp,8
 20219bc:	f800283a 	ret

020219c0 <alt_ro_zipfs_check_valid>:
* check that the file system is a valid zip file
* if so return 1
*
*/
int alt_ro_zipfs_check_valid(alt_ro_zipfs_dev* dev)
{
 20219c0:	defffc04 	addi	sp,sp,-16
 20219c4:	dfc00315 	stw	ra,12(sp)
 20219c8:	df000215 	stw	fp,8(sp)
 20219cc:	df000204 	addi	fp,sp,8
 20219d0:	e13fff15 	stw	r4,-4(fp)
  int ret_code = 0;
 20219d4:	e03ffe15 	stw	zero,-8(fp)
  if (find_directory_entry(dev) != -ENOENT)
 20219d8:	e13fff17 	ldw	r4,-4(fp)
 20219dc:	20212540 	call	2021254 <find_directory_entry>
 20219e0:	10bfffa0 	cmpeqi	r2,r2,-2
 20219e4:	1000061e 	bne	r2,zero,2021a00 <alt_ro_zipfs_check_valid+0x40>
  {
    if (check_directory_table(dev) != -ENOENT)
 20219e8:	e13fff17 	ldw	r4,-4(fp)
 20219ec:	20211b00 	call	20211b0 <check_directory_table>
 20219f0:	10bfffa0 	cmpeqi	r2,r2,-2
 20219f4:	1000021e 	bne	r2,zero,2021a00 <alt_ro_zipfs_check_valid+0x40>
    {
      ret_code = 1;
 20219f8:	00800044 	movi	r2,1
 20219fc:	e0bffe15 	stw	r2,-8(fp)
    }
  }

  return ret_code;
 2021a00:	e0bffe17 	ldw	r2,-8(fp)
}
 2021a04:	e037883a 	mov	sp,fp
 2021a08:	dfc00117 	ldw	ra,4(sp)
 2021a0c:	df000017 	ldw	fp,0(sp)
 2021a10:	dec00204 	addi	sp,sp,8
 2021a14:	f800283a 	ret

02021a18 <epcs_read_status_register>:
#include "alt_types.h"
#include "epcs_commands.h"
#include "altera_avalon_spi.h"

alt_u8 epcs_read_status_register(alt_u32 base)
{
 2021a18:	defff904 	addi	sp,sp,-28
 2021a1c:	dfc00615 	stw	ra,24(sp)
 2021a20:	df000515 	stw	fp,20(sp)
 2021a24:	df000504 	addi	fp,sp,20
 2021a28:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rdsr = epcs_rdsr;
 2021a2c:	00800144 	movi	r2,5
 2021a30:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 status;
  alt_avalon_spi_command(
 2021a34:	00800044 	movi	r2,1
 2021a38:	d8800015 	stw	r2,0(sp)
 2021a3c:	e0bffe44 	addi	r2,fp,-7
 2021a40:	d8800115 	stw	r2,4(sp)
 2021a44:	d8000215 	stw	zero,8(sp)
 2021a48:	e13fff17 	ldw	r4,-4(fp)
 2021a4c:	000b883a 	mov	r5,zero
 2021a50:	01800044 	movi	r6,1
 2021a54:	e1fffe04 	addi	r7,fp,-8
 2021a58:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    1,
    &status,
    0
  );

  return status;
 2021a5c:	e0bffe43 	ldbu	r2,-7(fp)
}
 2021a60:	e037883a 	mov	sp,fp
 2021a64:	dfc00117 	ldw	ra,4(sp)
 2021a68:	df000017 	ldw	fp,0(sp)
 2021a6c:	dec00204 	addi	sp,sp,8
 2021a70:	f800283a 	ret

02021a74 <epcs_test_wip>:

static ALT_INLINE int epcs_test_wip(alt_u32 base)
{
 2021a74:	defffd04 	addi	sp,sp,-12
 2021a78:	dfc00215 	stw	ra,8(sp)
 2021a7c:	df000115 	stw	fp,4(sp)
 2021a80:	df000104 	addi	fp,sp,4
 2021a84:	e13fff15 	stw	r4,-4(fp)
  return epcs_read_status_register(base) & 1;
 2021a88:	e13fff17 	ldw	r4,-4(fp)
 2021a8c:	2021a180 	call	2021a18 <epcs_read_status_register>
 2021a90:	10803fcc 	andi	r2,r2,255
 2021a94:	1080004c 	andi	r2,r2,1
}
 2021a98:	e037883a 	mov	sp,fp
 2021a9c:	dfc00117 	ldw	ra,4(sp)
 2021aa0:	df000017 	ldw	fp,0(sp)
 2021aa4:	dec00204 	addi	sp,sp,8
 2021aa8:	f800283a 	ret

02021aac <epcs_await_wip_released>:

static ALT_INLINE void epcs_await_wip_released(alt_u32 base)
{
 2021aac:	defffd04 	addi	sp,sp,-12
 2021ab0:	dfc00215 	stw	ra,8(sp)
 2021ab4:	df000115 	stw	fp,4(sp)
 2021ab8:	df000104 	addi	fp,sp,4
 2021abc:	e13fff15 	stw	r4,-4(fp)
  /* Wait until the WIP bit goes low. */
  while (epcs_test_wip(base))
 2021ac0:	0001883a 	nop
 2021ac4:	e13fff17 	ldw	r4,-4(fp)
 2021ac8:	2021a740 	call	2021a74 <epcs_test_wip>
 2021acc:	103ffd1e 	bne	r2,zero,2021ac4 <epcs_await_wip_released+0x18>
  {
  }
}
 2021ad0:	e037883a 	mov	sp,fp
 2021ad4:	dfc00117 	ldw	ra,4(sp)
 2021ad8:	df000017 	ldw	fp,0(sp)
 2021adc:	dec00204 	addi	sp,sp,8
 2021ae0:	f800283a 	ret

02021ae4 <epcs_sector_erase>:

void epcs_sector_erase(alt_u32 base, alt_u32 offset, alt_u32 four_bytes_mode)
{
 2021ae4:	defff604 	addi	sp,sp,-40
 2021ae8:	dfc00915 	stw	ra,36(sp)
 2021aec:	df000815 	stw	fp,32(sp)
 2021af0:	df000804 	addi	fp,sp,32
 2021af4:	e13ffd15 	stw	r4,-12(fp)
 2021af8:	e17ffe15 	stw	r5,-8(fp)
 2021afc:	e1bfff15 	stw	r6,-4(fp)
  alt_u8 se[5];
  alt_u8 len;
  
  if(four_bytes_mode)
 2021b00:	e0bfff17 	ldw	r2,-4(fp)
 2021b04:	10001226 	beq	r2,zero,2021b50 <epcs_sector_erase+0x6c>
  {
      se[0] = epcs_se;  /* Note: Use epcs_se for Micron EPCS256 */
 2021b08:	00bff604 	movi	r2,-40
 2021b0c:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 24) & 0xFF;
 2021b10:	e0bffe17 	ldw	r2,-8(fp)
 2021b14:	1004d63a 	srli	r2,r2,24
 2021b18:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 16) & 0xFF;
 2021b1c:	e0bffe17 	ldw	r2,-8(fp)
 2021b20:	1004d43a 	srli	r2,r2,16
 2021b24:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = (offset >> 8) & 0xFF;
 2021b28:	e0bffe17 	ldw	r2,-8(fp)
 2021b2c:	1004d23a 	srli	r2,r2,8
 2021b30:	e0bffc05 	stb	r2,-16(fp)
      se[4] = offset & 0xFF;
 2021b34:	e0bffe17 	ldw	r2,-8(fp)
 2021b38:	e0bffc45 	stb	r2,-15(fp)
      len   = 5;
 2021b3c:	00800144 	movi	r2,5
 2021b40:	e0bffb05 	stb	r2,-20(fp)
      epcs_enter_4_bytes_mode(base);
 2021b44:	e13ffd17 	ldw	r4,-12(fp)
 2021b48:	2021f8c0 	call	2021f8c <epcs_enter_4_bytes_mode>
 2021b4c:	00000c06 	br	2021b80 <epcs_sector_erase+0x9c>
  }
  else
  {
      se[0] = epcs_se;
 2021b50:	00bff604 	movi	r2,-40
 2021b54:	e0bffb45 	stb	r2,-19(fp)
      se[1] = (offset >> 16) & 0xFF;
 2021b58:	e0bffe17 	ldw	r2,-8(fp)
 2021b5c:	1004d43a 	srli	r2,r2,16
 2021b60:	e0bffb85 	stb	r2,-18(fp)
      se[2] = (offset >> 8) & 0xFF;
 2021b64:	e0bffe17 	ldw	r2,-8(fp)
 2021b68:	1004d23a 	srli	r2,r2,8
 2021b6c:	e0bffbc5 	stb	r2,-17(fp)
      se[3] = offset & 0xFF;
 2021b70:	e0bffe17 	ldw	r2,-8(fp)
 2021b74:	e0bffc05 	stb	r2,-16(fp)
      len   = 4;
 2021b78:	00800104 	movi	r2,4
 2021b7c:	e0bffb05 	stb	r2,-20(fp)
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);
 2021b80:	e13ffd17 	ldw	r4,-12(fp)
 2021b84:	2021cd00 	call	2021cd0 <epcs_write_enable>

  alt_avalon_spi_command(
 2021b88:	e0fffb03 	ldbu	r3,-20(fp)
    base,
    0,
    len,
    se,
 2021b8c:	e0bffb44 	addi	r2,fp,-19
  }

  /* Execute a WREN instruction */
  epcs_write_enable(base);

  alt_avalon_spi_command(
 2021b90:	d8000015 	stw	zero,0(sp)
 2021b94:	d8000115 	stw	zero,4(sp)
 2021b98:	d8000215 	stw	zero,8(sp)
 2021b9c:	e13ffd17 	ldw	r4,-12(fp)
 2021ba0:	000b883a 	mov	r5,zero
 2021ba4:	180d883a 	mov	r6,r3
 2021ba8:	100f883a 	mov	r7,r2
 2021bac:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 2021bb0:	e13ffd17 	ldw	r4,-12(fp)
 2021bb4:	2021aac0 	call	2021aac <epcs_await_wip_released>

  if(four_bytes_mode)
 2021bb8:	e0bfff17 	ldw	r2,-4(fp)
 2021bbc:	10000226 	beq	r2,zero,2021bc8 <epcs_sector_erase+0xe4>
  {
    epcs_exit_4_bytes_mode(base);
 2021bc0:	e13ffd17 	ldw	r4,-12(fp)
 2021bc4:	2021fe40 	call	2021fe4 <epcs_exit_4_bytes_mode>
  }
}
 2021bc8:	e037883a 	mov	sp,fp
 2021bcc:	dfc00117 	ldw	ra,4(sp)
 2021bd0:	df000017 	ldw	fp,0(sp)
 2021bd4:	dec00204 	addi	sp,sp,8
 2021bd8:	f800283a 	ret

02021bdc <epcs_read_buffer>:

alt_32 epcs_read_buffer(alt_u32 base, int offset, alt_u8 *dest_addr, int length,
                        alt_u32 four_bytes_mode)
{
 2021bdc:	defff404 	addi	sp,sp,-48
 2021be0:	dfc00b15 	stw	ra,44(sp)
 2021be4:	df000a15 	stw	fp,40(sp)
 2021be8:	df000a04 	addi	fp,sp,40
 2021bec:	e13ffc15 	stw	r4,-16(fp)
 2021bf0:	e17ffd15 	stw	r5,-12(fp)
 2021bf4:	e1bffe15 	stw	r6,-8(fp)
 2021bf8:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 read_command[5];
  alt_u32 cmd_len;

  read_command[0] = epcs_read;
 2021bfc:	008000c4 	movi	r2,3
 2021c00:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 2021c04:	e0800217 	ldw	r2,8(fp)
 2021c08:	10001026 	beq	r2,zero,2021c4c <epcs_read_buffer+0x70>
  {
        read_command[1] = (offset >> 24) & 0xFF;
 2021c0c:	e0bffd17 	ldw	r2,-12(fp)
 2021c10:	1004d63a 	srli	r2,r2,24
 2021c14:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 16) & 0xFF;
 2021c18:	e0bffd17 	ldw	r2,-12(fp)
 2021c1c:	1005d43a 	srai	r2,r2,16
 2021c20:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = (offset >> 8) & 0xFF;
 2021c24:	e0bffd17 	ldw	r2,-12(fp)
 2021c28:	1005d23a 	srai	r2,r2,8
 2021c2c:	e0bffac5 	stb	r2,-21(fp)
        read_command[4] = offset & 0xFF;
 2021c30:	e0bffd17 	ldw	r2,-12(fp)
 2021c34:	e0bffb05 	stb	r2,-20(fp)
        cmd_len = 5;
 2021c38:	00800144 	movi	r2,5
 2021c3c:	e0bff915 	stw	r2,-28(fp)
        epcs_enter_4_bytes_mode(base);
 2021c40:	e13ffc17 	ldw	r4,-16(fp)
 2021c44:	2021f8c0 	call	2021f8c <epcs_enter_4_bytes_mode>
 2021c48:	00000a06 	br	2021c74 <epcs_read_buffer+0x98>
  }
  else
  {
        read_command[1] = (offset >> 16) & 0xFF;
 2021c4c:	e0bffd17 	ldw	r2,-12(fp)
 2021c50:	1005d43a 	srai	r2,r2,16
 2021c54:	e0bffa45 	stb	r2,-23(fp)
        read_command[2] = (offset >> 8) & 0xFF;
 2021c58:	e0bffd17 	ldw	r2,-12(fp)
 2021c5c:	1005d23a 	srai	r2,r2,8
 2021c60:	e0bffa85 	stb	r2,-22(fp)
        read_command[3] = offset & 0xFF;
 2021c64:	e0bffd17 	ldw	r2,-12(fp)
 2021c68:	e0bffac5 	stb	r2,-21(fp)
        cmd_len = 4;
 2021c6c:	00800104 	movi	r2,4
 2021c70:	e0bff915 	stw	r2,-28(fp)
  }

  epcs_await_wip_released(base);
 2021c74:	e13ffc17 	ldw	r4,-16(fp)
 2021c78:	2021aac0 	call	2021aac <epcs_await_wip_released>

  alt_avalon_spi_command(
 2021c7c:	e0ffff17 	ldw	r3,-4(fp)
    base,
    0,
    cmd_len,
    read_command,
 2021c80:	e0bffa04 	addi	r2,fp,-24
        cmd_len = 4;
  }

  epcs_await_wip_released(base);

  alt_avalon_spi_command(
 2021c84:	d8c00015 	stw	r3,0(sp)
 2021c88:	e0fffe17 	ldw	r3,-8(fp)
 2021c8c:	d8c00115 	stw	r3,4(sp)
 2021c90:	d8000215 	stw	zero,8(sp)
 2021c94:	e13ffc17 	ldw	r4,-16(fp)
 2021c98:	000b883a 	mov	r5,zero
 2021c9c:	e1bff917 	ldw	r6,-28(fp)
 2021ca0:	100f883a 	mov	r7,r2
 2021ca4:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    length,
    (alt_u8*)dest_addr,
    0
  );

  if(four_bytes_mode)
 2021ca8:	e0800217 	ldw	r2,8(fp)
 2021cac:	10000226 	beq	r2,zero,2021cb8 <epcs_read_buffer+0xdc>
  {
    epcs_exit_4_bytes_mode(base);
 2021cb0:	e13ffc17 	ldw	r4,-16(fp)
 2021cb4:	2021fe40 	call	2021fe4 <epcs_exit_4_bytes_mode>
  }

  return length;
 2021cb8:	e0bfff17 	ldw	r2,-4(fp)
}
 2021cbc:	e037883a 	mov	sp,fp
 2021cc0:	dfc00117 	ldw	ra,4(sp)
 2021cc4:	df000017 	ldw	fp,0(sp)
 2021cc8:	dec00204 	addi	sp,sp,8
 2021ccc:	f800283a 	ret

02021cd0 <epcs_write_enable>:

void epcs_write_enable(alt_u32 base)
{
 2021cd0:	defff904 	addi	sp,sp,-28
 2021cd4:	dfc00615 	stw	ra,24(sp)
 2021cd8:	df000515 	stw	fp,20(sp)
 2021cdc:	df000504 	addi	fp,sp,20
 2021ce0:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 wren = epcs_wren;
 2021ce4:	00800184 	movi	r2,6
 2021ce8:	e0bffe05 	stb	r2,-8(fp)
  alt_avalon_spi_command(
 2021cec:	d8000015 	stw	zero,0(sp)
 2021cf0:	d8000115 	stw	zero,4(sp)
 2021cf4:	d8000215 	stw	zero,8(sp)
 2021cf8:	e13fff17 	ldw	r4,-4(fp)
 2021cfc:	000b883a 	mov	r5,zero
 2021d00:	01800044 	movi	r6,1
 2021d04:	e1fffe04 	addi	r7,fp,-8
 2021d08:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    &wren,
    0,
    (alt_u8*)0,
    0
  );
}
 2021d0c:	e037883a 	mov	sp,fp
 2021d10:	dfc00117 	ldw	ra,4(sp)
 2021d14:	df000017 	ldw	fp,0(sp)
 2021d18:	dec00204 	addi	sp,sp,8
 2021d1c:	f800283a 	ret

02021d20 <epcs_write_status_register>:

void epcs_write_status_register(alt_u32 base, alt_u8 value)
{
 2021d20:	defff804 	addi	sp,sp,-32
 2021d24:	dfc00715 	stw	ra,28(sp)
 2021d28:	df000615 	stw	fp,24(sp)
 2021d2c:	df000604 	addi	fp,sp,24
 2021d30:	e13ffe15 	stw	r4,-8(fp)
 2021d34:	2805883a 	mov	r2,r5
 2021d38:	e0bfff05 	stb	r2,-4(fp)
  alt_u8 wrsr[2];
  
  wrsr[0] = epcs_wrsr;
 2021d3c:	00800044 	movi	r2,1
 2021d40:	e0bffd05 	stb	r2,-12(fp)
  wrsr[1] = value;
 2021d44:	e0bfff03 	ldbu	r2,-4(fp)
 2021d48:	e0bffd45 	stb	r2,-11(fp)

  alt_avalon_spi_command(
 2021d4c:	d8000015 	stw	zero,0(sp)
 2021d50:	d8000115 	stw	zero,4(sp)
 2021d54:	d8000215 	stw	zero,8(sp)
 2021d58:	e13ffe17 	ldw	r4,-8(fp)
 2021d5c:	000b883a 	mov	r5,zero
 2021d60:	01800084 	movi	r6,2
 2021d64:	e1fffd04 	addi	r7,fp,-12
 2021d68:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    0,
    (alt_u8*)0,
    0
  );

  epcs_await_wip_released(base);
 2021d6c:	e13ffe17 	ldw	r4,-8(fp)
 2021d70:	2021aac0 	call	2021aac <epcs_await_wip_released>
}
 2021d74:	e037883a 	mov	sp,fp
 2021d78:	dfc00117 	ldw	ra,4(sp)
 2021d7c:	df000017 	ldw	fp,0(sp)
 2021d80:	dec00204 	addi	sp,sp,8
 2021d84:	f800283a 	ret

02021d88 <epcs_write_buffer>:

/* Write a partial or full page, assuming that page has been erased */
alt_32 epcs_write_buffer(alt_u32 base, int offset, const alt_u8* src_addr, 
                         int length, alt_u32 four_bytes_mode)
{
 2021d88:	defff404 	addi	sp,sp,-48
 2021d8c:	dfc00b15 	stw	ra,44(sp)
 2021d90:	df000a15 	stw	fp,40(sp)
 2021d94:	df000a04 	addi	fp,sp,40
 2021d98:	e13ffc15 	stw	r4,-16(fp)
 2021d9c:	e17ffd15 	stw	r5,-12(fp)
 2021da0:	e1bffe15 	stw	r6,-8(fp)
 2021da4:	e1ffff15 	stw	r7,-4(fp)
  alt_u8 pp[5];
  alt_u32 cmd_len;
  
  pp[0] = epcs_pp;
 2021da8:	00800084 	movi	r2,2
 2021dac:	e0bffa05 	stb	r2,-24(fp)
  
  if(four_bytes_mode)
 2021db0:	e0800217 	ldw	r2,8(fp)
 2021db4:	10001026 	beq	r2,zero,2021df8 <epcs_write_buffer+0x70>
  {
      pp[1] = (offset >> 24) & 0xFF;
 2021db8:	e0bffd17 	ldw	r2,-12(fp)
 2021dbc:	1004d63a 	srli	r2,r2,24
 2021dc0:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 16) & 0xFF;
 2021dc4:	e0bffd17 	ldw	r2,-12(fp)
 2021dc8:	1005d43a 	srai	r2,r2,16
 2021dcc:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = (offset >> 8) & 0xFF;
 2021dd0:	e0bffd17 	ldw	r2,-12(fp)
 2021dd4:	1005d23a 	srai	r2,r2,8
 2021dd8:	e0bffac5 	stb	r2,-21(fp)
      pp[4] = offset & 0xFF;
 2021ddc:	e0bffd17 	ldw	r2,-12(fp)
 2021de0:	e0bffb05 	stb	r2,-20(fp)
      cmd_len = 5;
 2021de4:	00800144 	movi	r2,5
 2021de8:	e0bff915 	stw	r2,-28(fp)
      epcs_enter_4_bytes_mode(base);
 2021dec:	e13ffc17 	ldw	r4,-16(fp)
 2021df0:	2021f8c0 	call	2021f8c <epcs_enter_4_bytes_mode>
 2021df4:	00000a06 	br	2021e20 <epcs_write_buffer+0x98>
  }
  else
  {
      pp[1] = (offset >> 16) & 0xFF;
 2021df8:	e0bffd17 	ldw	r2,-12(fp)
 2021dfc:	1005d43a 	srai	r2,r2,16
 2021e00:	e0bffa45 	stb	r2,-23(fp)
      pp[2] = (offset >> 8) & 0xFF;
 2021e04:	e0bffd17 	ldw	r2,-12(fp)
 2021e08:	1005d23a 	srai	r2,r2,8
 2021e0c:	e0bffa85 	stb	r2,-22(fp)
      pp[3] = offset & 0xFF;
 2021e10:	e0bffd17 	ldw	r2,-12(fp)
 2021e14:	e0bffac5 	stb	r2,-21(fp)
      cmd_len = 4;
 2021e18:	00800104 	movi	r2,4
 2021e1c:	e0bff915 	stw	r2,-28(fp)
  }

  /* First, WREN */
  epcs_write_enable(base);
 2021e20:	e13ffc17 	ldw	r4,-16(fp)
 2021e24:	2021cd00 	call	2021cd0 <epcs_write_enable>
  /* Send the PP command */
  alt_avalon_spi_command(
    base,
    0,
    cmd_len,
    pp,
 2021e28:	e0bffa04 	addi	r2,fp,-24

  /* First, WREN */
  epcs_write_enable(base);

  /* Send the PP command */
  alt_avalon_spi_command(
 2021e2c:	d8000015 	stw	zero,0(sp)
 2021e30:	d8000115 	stw	zero,4(sp)
 2021e34:	00c00044 	movi	r3,1
 2021e38:	d8c00215 	stw	r3,8(sp)
 2021e3c:	e13ffc17 	ldw	r4,-16(fp)
 2021e40:	000b883a 	mov	r5,zero
 2021e44:	e1bff917 	ldw	r6,-28(fp)
 2021e48:	100f883a 	mov	r7,r2
 2021e4c:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    (alt_u8*)0,
    ALT_AVALON_SPI_COMMAND_MERGE
  );

  /* Send the user's buffer */
  alt_avalon_spi_command(
 2021e50:	e0bfff17 	ldw	r2,-4(fp)
 2021e54:	d8000015 	stw	zero,0(sp)
 2021e58:	d8000115 	stw	zero,4(sp)
 2021e5c:	d8000215 	stw	zero,8(sp)
 2021e60:	e13ffc17 	ldw	r4,-16(fp)
 2021e64:	000b883a 	mov	r5,zero
 2021e68:	100d883a 	mov	r6,r2
 2021e6c:	e1fffe17 	ldw	r7,-8(fp)
 2021e70:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
   * if the user's going to go off and ignore the flash for
   * a while, its writes could occur in parallel with user code
   * execution.  Unfortunately, I have to guard all reads/writes
   * with wip-tests, to make that happen.
   */
  epcs_await_wip_released(base);
 2021e74:	e13ffc17 	ldw	r4,-16(fp)
 2021e78:	2021aac0 	call	2021aac <epcs_await_wip_released>

  if(four_bytes_mode)
 2021e7c:	e0800217 	ldw	r2,8(fp)
 2021e80:	10000226 	beq	r2,zero,2021e8c <epcs_write_buffer+0x104>
  {
    epcs_exit_4_bytes_mode(base);
 2021e84:	e13ffc17 	ldw	r4,-16(fp)
 2021e88:	2021fe40 	call	2021fe4 <epcs_exit_4_bytes_mode>
  }

  return length;
 2021e8c:	e0bfff17 	ldw	r2,-4(fp)
}
 2021e90:	e037883a 	mov	sp,fp
 2021e94:	dfc00117 	ldw	ra,4(sp)
 2021e98:	df000017 	ldw	fp,0(sp)
 2021e9c:	dec00204 	addi	sp,sp,8
 2021ea0:	f800283a 	ret

02021ea4 <epcs_read_electronic_signature>:


alt_u8 epcs_read_electronic_signature(alt_u32 base)
{
 2021ea4:	defff804 	addi	sp,sp,-32
 2021ea8:	dfc00715 	stw	ra,28(sp)
 2021eac:	df000615 	stw	fp,24(sp)
 2021eb0:	df000604 	addi	fp,sp,24
 2021eb4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 res_cmd[] = {epcs_res, 0, 0, 0};
 2021eb8:	00bfeac4 	movi	r2,-85
 2021ebc:	e0bffd05 	stb	r2,-12(fp)
 2021ec0:	e03ffd45 	stb	zero,-11(fp)
 2021ec4:	e03ffd85 	stb	zero,-10(fp)
 2021ec8:	e03ffdc5 	stb	zero,-9(fp)
  alt_u8 res;

  alt_avalon_spi_command(
 2021ecc:	00800044 	movi	r2,1
 2021ed0:	d8800015 	stw	r2,0(sp)
 2021ed4:	e0bffe04 	addi	r2,fp,-8
 2021ed8:	d8800115 	stw	r2,4(sp)
 2021edc:	d8000215 	stw	zero,8(sp)
 2021ee0:	e13fff17 	ldw	r4,-4(fp)
 2021ee4:	000b883a 	mov	r5,zero
 2021ee8:	01800104 	movi	r6,4
 2021eec:	e1fffd04 	addi	r7,fp,-12
 2021ef0:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    1,
    &res,
    0
  );

  return res;
 2021ef4:	e0bffe03 	ldbu	r2,-8(fp)
}
 2021ef8:	e037883a 	mov	sp,fp
 2021efc:	dfc00117 	ldw	ra,4(sp)
 2021f00:	df000017 	ldw	fp,0(sp)
 2021f04:	dec00204 	addi	sp,sp,8
 2021f08:	f800283a 	ret

02021f0c <epcs_read_device_id>:

alt_u32 epcs_read_device_id(alt_u32 base)
{
 2021f0c:	defff904 	addi	sp,sp,-28
 2021f10:	dfc00615 	stw	ra,24(sp)
 2021f14:	df000515 	stw	fp,20(sp)
 2021f18:	df000504 	addi	fp,sp,20
 2021f1c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
 2021f20:	00bfe7c4 	movi	r2,-97
 2021f24:	e0bffe05 	stb	r2,-8(fp)
  alt_u8 id[3];

  alt_avalon_spi_command(
 2021f28:	008000c4 	movi	r2,3
 2021f2c:	d8800015 	stw	r2,0(sp)
    base,
    0,
    sizeof(rd_id_cmd) / sizeof(*rd_id_cmd),
    rd_id_cmd,
    3,
    id,
 2021f30:	e0bffe44 	addi	r2,fp,-7
alt_u32 epcs_read_device_id(alt_u32 base)
{
  const alt_u8 rd_id_cmd[] = {epcs_rdid};
  alt_u8 id[3];

  alt_avalon_spi_command(
 2021f34:	d8800115 	stw	r2,4(sp)
 2021f38:	d8000215 	stw	zero,8(sp)
 2021f3c:	e13fff17 	ldw	r4,-4(fp)
 2021f40:	000b883a 	mov	r5,zero
 2021f44:	01800044 	movi	r6,1
 2021f48:	e1fffe04 	addi	r7,fp,-8
 2021f4c:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    3,
    id,
    0
  );

  return (alt_u32) ((id[0] << 16) | (id[1] << 8) | id[2]);
 2021f50:	e0bffe43 	ldbu	r2,-7(fp)
 2021f54:	10803fcc 	andi	r2,r2,255
 2021f58:	1006943a 	slli	r3,r2,16
 2021f5c:	e0bffe83 	ldbu	r2,-6(fp)
 2021f60:	10803fcc 	andi	r2,r2,255
 2021f64:	1004923a 	slli	r2,r2,8
 2021f68:	1886b03a 	or	r3,r3,r2
 2021f6c:	e0bffec3 	ldbu	r2,-5(fp)
 2021f70:	10803fcc 	andi	r2,r2,255
 2021f74:	1884b03a 	or	r2,r3,r2
}
 2021f78:	e037883a 	mov	sp,fp
 2021f7c:	dfc00117 	ldw	ra,4(sp)
 2021f80:	df000017 	ldw	fp,0(sp)
 2021f84:	dec00204 	addi	sp,sp,8
 2021f88:	f800283a 	ret

02021f8c <epcs_enter_4_bytes_mode>:

void epcs_enter_4_bytes_mode(alt_u32 base)
{
 2021f8c:	defff904 	addi	sp,sp,-28
 2021f90:	dfc00615 	stw	ra,24(sp)
 2021f94:	df000515 	stw	fp,20(sp)
 2021f98:	df000504 	addi	fp,sp,20
 2021f9c:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 en4b_cmd = epcs_en4b;
 2021fa0:	00bfedc4 	movi	r2,-73
 2021fa4:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 2021fa8:	e13fff17 	ldw	r4,-4(fp)
 2021fac:	2021cd00 	call	2021cd0 <epcs_write_enable>

  alt_avalon_spi_command(
 2021fb0:	d8000015 	stw	zero,0(sp)
 2021fb4:	d8000115 	stw	zero,4(sp)
 2021fb8:	d8000215 	stw	zero,8(sp)
 2021fbc:	e13fff17 	ldw	r4,-4(fp)
 2021fc0:	000b883a 	mov	r5,zero
 2021fc4:	01800044 	movi	r6,1
 2021fc8:	e1fffe04 	addi	r7,fp,-8
 2021fcc:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
 2021fd0:	e037883a 	mov	sp,fp
 2021fd4:	dfc00117 	ldw	ra,4(sp)
 2021fd8:	df000017 	ldw	fp,0(sp)
 2021fdc:	dec00204 	addi	sp,sp,8
 2021fe0:	f800283a 	ret

02021fe4 <epcs_exit_4_bytes_mode>:

void epcs_exit_4_bytes_mode(alt_u32 base)
{
 2021fe4:	defff904 	addi	sp,sp,-28
 2021fe8:	dfc00615 	stw	ra,24(sp)
 2021fec:	df000515 	stw	fp,20(sp)
 2021ff0:	df000504 	addi	fp,sp,20
 2021ff4:	e13fff15 	stw	r4,-4(fp)
  const alt_u8 exit4b_cmd = epcs_dis4b;
 2021ff8:	00bffa44 	movi	r2,-23
 2021ffc:	e0bffe05 	stb	r2,-8(fp)

  /* First, WREN */
  epcs_write_enable(base);
 2022000:	e13fff17 	ldw	r4,-4(fp)
 2022004:	2021cd00 	call	2021cd0 <epcs_write_enable>

  alt_avalon_spi_command(
 2022008:	d8000015 	stw	zero,0(sp)
 202200c:	d8000115 	stw	zero,4(sp)
 2022010:	d8000215 	stw	zero,8(sp)
 2022014:	e13fff17 	ldw	r4,-4(fp)
 2022018:	000b883a 	mov	r5,zero
 202201c:	01800044 	movi	r6,1
 2022020:	e1fffe04 	addi	r7,fp,-8
 2022024:	2037fdc0 	call	2037fdc <alt_avalon_spi_command>
    (alt_u8*)0,
    0
  );

  return;
}
 2022028:	e037883a 	mov	sp,fp
 202202c:	dfc00117 	ldw	ra,4(sp)
 2022030:	df000017 	ldw	fp,0(sp)
 2022034:	dec00204 	addi	sp,sp,8
 2022038:	f800283a 	ret

0202203c <altera_eth_tse_init>:
 * @Return ENP_HARDWARE on error, otherwise return SUCCESS
 */

error_t altera_eth_tse_init(
    alt_iniche_dev              *p_dev)
{
 202203c:	defffa04 	addi	sp,sp,-24
 2022040:	dfc00515 	stw	ra,20(sp)
 2022044:	df000415 	stw	fp,16(sp)
 2022048:	df000404 	addi	fp,sp,16
 202204c:	e13fff15 	stw	r4,-4(fp)
    int i;
    
    alt_tse_iniche_dev_driver_data *p_driver_data = 0;
 2022050:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_system_info *psys_info = 0;
 2022054:	e03ffe15 	stw	zero,-8(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 2022058:	e03ffc15 	stw	zero,-16(fp)
 202205c:	00001106 	br	20220a4 <altera_eth_tse_init+0x68>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
 2022060:	00c09934 	movhi	r3,612
 2022064:	18f4a404 	addi	r3,r3,-11632
 2022068:	e0bffc17 	ldw	r2,-16(fp)
 202206c:	10800324 	muli	r2,r2,12
 2022070:	1885883a 	add	r2,r3,r2
 2022074:	10c00017 	ldw	r3,0(r2)
 2022078:	e0bfff17 	ldw	r2,-4(fp)
 202207c:	1880061e 	bne	r3,r2,2022098 <altera_eth_tse_init+0x5c>
            p_driver_data = &tse_iniche_dev_driver_data[i];
 2022080:	e0bffc17 	ldw	r2,-16(fp)
 2022084:	10c00324 	muli	r3,r2,12
 2022088:	00809934 	movhi	r2,612
 202208c:	10b4a404 	addi	r2,r2,-11632
 2022090:	1885883a 	add	r2,r3,r2
 2022094:	e0bffd15 	stw	r2,-12(fp)
    #ifdef PRINTIF
        dprintf("altera_eth_tse_init %d\n", p_dev->if_num);
    #endif

    /* Get the pointer to the alt_tse_iniche_dev_driver_data structure from the global array */
    for(i = 0; i < number_of_tse_mac; i++) {
 2022098:	e0bffc17 	ldw	r2,-16(fp)
 202209c:	10800044 	addi	r2,r2,1
 20220a0:	e0bffc15 	stw	r2,-16(fp)
 20220a4:	d0a08503 	ldbu	r2,-32236(gp)
 20220a8:	10803fcc 	andi	r2,r2,255
 20220ac:	e0fffc17 	ldw	r3,-16(fp)
 20220b0:	18bfeb16 	blt	r3,r2,2022060 <altera_eth_tse_init+0x24>
        if(tse_iniche_dev_driver_data[i].p_dev == p_dev) {
            p_driver_data = &tse_iniche_dev_driver_data[i];
        }
    }
    /* If pointer could not found */
    if(p_driver_data == 0) {
 20220b4:	e0bffd17 	ldw	r2,-12(fp)
 20220b8:	1000021e 	bne	r2,zero,20220c4 <altera_eth_tse_init+0x88>
        return ENP_HARDWARE;
 20220bc:	00bff744 	movi	r2,-35
 20220c0:	00002a06 	br	202216c <altera_eth_tse_init+0x130>
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 20220c4:	e03ffc15 	stw	zero,-16(fp)
 20220c8:	00001206 	br	2022114 <altera_eth_tse_init+0xd8>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
 20220cc:	00c08174 	movhi	r3,517
 20220d0:	18cf7e04 	addi	r3,r3,15864
 20220d4:	e0bffc17 	ldw	r2,-16(fp)
 20220d8:	10801224 	muli	r2,r2,72
 20220dc:	1885883a 	add	r2,r3,r2
 20220e0:	10c00017 	ldw	r3,0(r2)
 20220e4:	e0bffd17 	ldw	r2,-12(fp)
 20220e8:	10800117 	ldw	r2,4(r2)
 20220ec:	1880061e 	bne	r3,r2,2022108 <altera_eth_tse_init+0xcc>
            psys_info = &tse_mac_device[i];
 20220f0:	e0bffc17 	ldw	r2,-16(fp)
 20220f4:	10c01224 	muli	r3,r2,72
 20220f8:	00808174 	movhi	r2,517
 20220fc:	108f7e04 	addi	r2,r2,15864
 2022100:	1885883a 	add	r2,r3,r2
 2022104:	e0bffe15 	stw	r2,-8(fp)
    if(p_driver_data == 0) {
        return ENP_HARDWARE;
    }
    
    /* Get the pointer to the alt_tse_system_info structure from the global array */
    for(i = 0; i < max_mac_system; i++) {
 2022108:	e0bffc17 	ldw	r2,-16(fp)
 202210c:	10800044 	addi	r2,r2,1
 2022110:	e0bffc15 	stw	r2,-16(fp)
 2022114:	00808174 	movhi	r2,517
 2022118:	10907904 	addi	r2,r2,16868
 202211c:	10800003 	ldbu	r2,0(r2)
 2022120:	10803fcc 	andi	r2,r2,255
 2022124:	e0fffc17 	ldw	r3,-16(fp)
 2022128:	18bfe816 	blt	r3,r2,20220cc <altera_eth_tse_init+0x90>
        if(tse_mac_device[i].tse_mac_base == p_driver_data->hw_mac_base_addr) {
            psys_info = &tse_mac_device[i];
        }
    }
    /* If pointer could not found */
    if(psys_info == 0) {
 202212c:	e0bffe17 	ldw	r2,-8(fp)
 2022130:	1000021e 	bne	r2,zero,202213c <altera_eth_tse_init+0x100>
        return ENP_HARDWARE;
 2022134:	00bff744 	movi	r2,-35
 2022138:	00000c06 	br	202216c <altera_eth_tse_init+0x130>
    }
    
    prep_tse_mac(p_dev->if_num, psys_info + p_driver_data->hw_channel_number);
 202213c:	e0bfff17 	ldw	r2,-4(fp)
 2022140:	10c00517 	ldw	r3,20(r2)
 2022144:	e0bffd17 	ldw	r2,-12(fp)
 2022148:	10800203 	ldbu	r2,8(r2)
 202214c:	10803fcc 	andi	r2,r2,255
 2022150:	10801224 	muli	r2,r2,72
 2022154:	e13ffe17 	ldw	r4,-8(fp)
 2022158:	2085883a 	add	r2,r4,r2
 202215c:	1809883a 	mov	r4,r3
 2022160:	100b883a 	mov	r5,r2
 2022164:	20221800 	call	2022180 <prep_tse_mac>
    
    return SUCCESS;
 2022168:	0005883a 	mov	r2,zero
}
 202216c:	e037883a 	mov	sp,fp
 2022170:	dfc00117 	ldw	ra,4(sp)
 2022174:	df000017 	ldw	fp,0(sp)
 2022178:	dec00204 	addi	sp,sp,8
 202217c:	f800283a 	ret

02022180 <prep_tse_mac>:
 * @Param index     index of the NET structure associated with TSE instance
 * @Param psys_info pointer to the TSE hardware info structure
 * @Return next index of NET
 */
int prep_tse_mac(int index, alt_tse_system_info *psys_info)
{
 2022180:	defffa04 	addi	sp,sp,-24
 2022184:	dfc00515 	stw	ra,20(sp)
 2022188:	df000415 	stw	fp,16(sp)
 202218c:	dc000315 	stw	r16,12(sp)
 2022190:	df000304 	addi	fp,sp,12
 2022194:	e13ffe15 	stw	r4,-8(fp)
 2022198:	e17fff15 	stw	r5,-4(fp)
    NET ifp;
    dprintf("prep_tse_mac %d\n", index);
 202219c:	01008174 	movhi	r4,517
 20221a0:	2138cc04 	addi	r4,r4,-7376
 20221a4:	e17ffe17 	ldw	r5,-8(fp)
 20221a8:	2006a240 	call	2006a24 <printf>
    {
        tse[index].sem = 0; /*Tx IDLE*/
 20221ac:	00c09934 	movhi	r3,612
 20221b0:	18f4b004 	addi	r3,r3,-11584
 20221b4:	e0bffe17 	ldw	r2,-8(fp)
 20221b8:	10801324 	muli	r2,r2,76
 20221bc:	1885883a 	add	r2,r3,r2
 20221c0:	10800c04 	addi	r2,r2,48
 20221c4:	10000015 	stw	zero,0(r2)
        tse[index].tse = (void *)psys_info;
 20221c8:	00c09934 	movhi	r3,612
 20221cc:	18f4b004 	addi	r3,r3,-11584
 20221d0:	e0bffe17 	ldw	r2,-8(fp)
 20221d4:	10801324 	muli	r2,r2,76
 20221d8:	1885883a 	add	r2,r3,r2
 20221dc:	10801204 	addi	r2,r2,72
 20221e0:	e0ffff17 	ldw	r3,-4(fp)
 20221e4:	10c00015 	stw	r3,0(r2)

        ifp = nets[index];
 20221e8:	00c09934 	movhi	r3,612
 20221ec:	18f5c104 	addi	r3,r3,-10492
 20221f0:	e0bffe17 	ldw	r2,-8(fp)
 20221f4:	1085883a 	add	r2,r2,r2
 20221f8:	1085883a 	add	r2,r2,r2
 20221fc:	1885883a 	add	r2,r3,r2
 2022200:	10800017 	ldw	r2,0(r2)
 2022204:	e0bffd15 	stw	r2,-12(fp)
        ifp->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN; /* status = down */
 2022208:	e0bffd17 	ldw	r2,-12(fp)
 202220c:	10802717 	ldw	r2,156(r2)
 2022210:	00c00084 	movi	r3,2
 2022214:	10c00615 	stw	r3,24(r2)
        ifp->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_DOWN;   
 2022218:	e0bffd17 	ldw	r2,-12(fp)
 202221c:	10802717 	ldw	r2,156(r2)
 2022220:	00c00084 	movi	r3,2
 2022224:	10c00715 	stw	r3,28(r2)
        ifp->n_mib->ifLastChange =  cticks * (100/TPS);
 2022228:	e0bffd17 	ldw	r2,-12(fp)
 202222c:	14002717 	ldw	r16,156(r2)
 2022230:	00808174 	movhi	r2,517
 2022234:	1090c904 	addi	r2,r2,17188
 2022238:	10800017 	ldw	r2,0(r2)
 202223c:	1009883a 	mov	r4,r2
 2022240:	20145600 	call	2014560 <__floatunsidf>
 2022244:	100b883a 	mov	r5,r2
 2022248:	180d883a 	mov	r6,r3
 202224c:	2809883a 	mov	r4,r5
 2022250:	300b883a 	mov	r5,r6
 2022254:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 2022258:	80800815 	stw	r2,32(r16)
        ifp->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;
 202225c:	e0bffd17 	ldw	r2,-12(fp)
 2022260:	10802717 	ldw	r2,156(r2)
 2022264:	e0fffe17 	ldw	r3,-8(fp)
 2022268:	18c01324 	muli	r3,r3,76
 202226c:	19000604 	addi	r4,r3,24
 2022270:	00c09934 	movhi	r3,612
 2022274:	18f4b004 	addi	r3,r3,-11584
 2022278:	20c7883a 	add	r3,r4,r3
 202227c:	10c00515 	stw	r3,20(r2)
        ifp->n_mib->ifDescr =       (u_char*)"Altera TSE MAC ethernet";
 2022280:	e0bffd17 	ldw	r2,-12(fp)
 2022284:	10802717 	ldw	r2,156(r2)
 2022288:	00c08174 	movhi	r3,517
 202228c:	18f8d104 	addi	r3,r3,-7356
 2022290:	10c00115 	stw	r3,4(r2)
        ifp->n_lnh =                ETHHDR_SIZE; /* ethernet header size. was:14 */
 2022294:	e0bffd17 	ldw	r2,-12(fp)
 2022298:	00c00404 	movi	r3,16
 202229c:	10c00815 	stw	r3,32(r2)
        ifp->n_hal =                ALTERA_TSE_HAL_ADDR_LEN;  /* hardware address length */
 20222a0:	e0bffd17 	ldw	r2,-12(fp)
 20222a4:	00c00184 	movi	r3,6
 20222a8:	10c01115 	stw	r3,68(r2)
        ifp->n_mib->ifType =        ETHERNET;   /* device type */
 20222ac:	e0bffd17 	ldw	r2,-12(fp)
 20222b0:	10802717 	ldw	r2,156(r2)
 20222b4:	00c00184 	movi	r3,6
 20222b8:	10c00215 	stw	r3,8(r2)
        ifp->n_mtu =                ALTERA_TSE_MAX_MTU_SIZE;  /* max frame size */
 20222bc:	e0bffd17 	ldw	r2,-12(fp)
 20222c0:	00c17a84 	movi	r3,1514
 20222c4:	10c00915 	stw	r3,36(r2)
    
        /* install our hardware driver routines */
        ifp->n_init =       tse_mac_init;
 20222c8:	e0bffd17 	ldw	r2,-12(fp)
 20222cc:	00c080b4 	movhi	r3,514
 20222d0:	18c90104 	addi	r3,r3,9220
 20222d4:	10c00215 	stw	r3,8(r2)
        ifp->pkt_send =     NULL;
 20222d8:	e0bffd17 	ldw	r2,-12(fp)
 20222dc:	10000415 	stw	zero,16(r2)
        ifp->raw_send =     tse_mac_raw_send;
 20222e0:	e0bffd17 	ldw	r2,-12(fp)
 20222e4:	00c080b4 	movhi	r3,514
 20222e8:	18cba204 	addi	r3,r3,11912
 20222ec:	10c00315 	stw	r3,12(r2)
        ifp->n_close =      tse_mac_close;
 20222f0:	e0bffd17 	ldw	r2,-12(fp)
 20222f4:	00c080b4 	movhi	r3,514
 20222f8:	18cd9904 	addi	r3,r3,13924
 20222fc:	10c00515 	stw	r3,20(r2)
        ifp->n_stats =      (void(*)(void *, int))tse_mac_stats; 
 2022300:	e0bffd17 	ldw	r2,-12(fp)
 2022304:	00c080b4 	movhi	r3,514
 2022308:	18cd8904 	addi	r3,r3,13860
 202230c:	10c00715 	stw	r3,28(r2)
    
    #ifdef IP_V6
        ifp->n_flags |= (NF_NBPROT | NF_IPV6);
    #else
        ifp->n_flags |= NF_NBPROT;
 2022310:	e0bffd17 	ldw	r2,-12(fp)
 2022314:	10802a17 	ldw	r2,168(r2)
 2022318:	10c00214 	ori	r3,r2,8
 202231c:	e0bffd17 	ldw	r2,-12(fp)
 2022320:	10c02a15 	stw	r3,168(r2)
    #endif
    
        nets[index]->n_mib->ifPhysAddress = (u_char*)tse[index].mac_addr;   /* ptr to MAC address */
 2022324:	00c09934 	movhi	r3,612
 2022328:	18f5c104 	addi	r3,r3,-10492
 202232c:	e0bffe17 	ldw	r2,-8(fp)
 2022330:	1085883a 	add	r2,r2,r2
 2022334:	1085883a 	add	r2,r2,r2
 2022338:	1885883a 	add	r2,r3,r2
 202233c:	10800017 	ldw	r2,0(r2)
 2022340:	10802717 	ldw	r2,156(r2)
 2022344:	e0fffe17 	ldw	r3,-8(fp)
 2022348:	18c01324 	muli	r3,r3,76
 202234c:	19000604 	addi	r4,r3,24
 2022350:	00c09934 	movhi	r3,612
 2022354:	18f4b004 	addi	r3,r3,-11584
 2022358:	20c7883a 	add	r3,r4,r3
 202235c:	10c00515 	stw	r3,20(r2)
    
    #ifdef ALT_INICHE
        /* get the MAC address. */
        get_mac_addr(ifp, (unsigned char *)tse[index].mac_addr);
 2022360:	e0bffe17 	ldw	r2,-8(fp)
 2022364:	10801324 	muli	r2,r2,76
 2022368:	10c00604 	addi	r3,r2,24
 202236c:	00809934 	movhi	r2,612
 2022370:	10b4b004 	addi	r2,r2,-11584
 2022374:	1885883a 	add	r2,r3,r2
 2022378:	e13ffd17 	ldw	r4,-12(fp)
 202237c:	100b883a 	mov	r5,r2
 2022380:	20036940 	call	2003694 <get_mac_addr>
    #endif /* ALT_INICHE */
    
        /* set cross-pointers between iface and tse structs */
        tse[index].index = index;
 2022384:	00c09934 	movhi	r3,612
 2022388:	18f4b004 	addi	r3,r3,-11584
 202238c:	e0bffe17 	ldw	r2,-8(fp)
 2022390:	10801324 	muli	r2,r2,76
 2022394:	1885883a 	add	r2,r3,r2
 2022398:	e0fffe17 	ldw	r3,-8(fp)
 202239c:	10c00015 	stw	r3,0(r2)
        tse[index].netp = ifp;
 20223a0:	00c09934 	movhi	r3,612
 20223a4:	18f4b004 	addi	r3,r3,-11584
 20223a8:	e0bffe17 	ldw	r2,-8(fp)
 20223ac:	10801324 	muli	r2,r2,76
 20223b0:	1885883a 	add	r2,r3,r2
 20223b4:	10800804 	addi	r2,r2,32
 20223b8:	e0fffd17 	ldw	r3,-12(fp)
 20223bc:	10c00015 	stw	r3,0(r2)
        ifp->n_local = (void*)(&tse[index]);
 20223c0:	e0bffe17 	ldw	r2,-8(fp)
 20223c4:	10c01324 	muli	r3,r2,76
 20223c8:	00809934 	movhi	r2,612
 20223cc:	10b4b004 	addi	r2,r2,-11584
 20223d0:	1887883a 	add	r3,r3,r2
 20223d4:	e0bffd17 	ldw	r2,-12(fp)
 20223d8:	10c02815 	stw	r3,160(r2)
    
        index++;
 20223dc:	e0bffe17 	ldw	r2,-8(fp)
 20223e0:	10800044 	addi	r2,r2,1
 20223e4:	e0bffe15 	stw	r2,-8(fp)
   }
 
   return index;
 20223e8:	e0bffe17 	ldw	r2,-8(fp)
}
 20223ec:	e037883a 	mov	sp,fp
 20223f0:	dfc00217 	ldw	ra,8(sp)
 20223f4:	df000117 	ldw	fp,4(sp)
 20223f8:	dc000017 	ldw	r16,0(sp)
 20223fc:	dec00304 	addi	sp,sp,12
 2022400:	f800283a 	ret

02022404 <tse_mac_init>:
 * @API TYPE: Internal
 * @Param iface index of the NET structure associated with TSE instance
 * @Return 0 if ok, else -1 if error
 */
int tse_mac_init(int iface)
{
 2022404:	deffef04 	addi	sp,sp,-68
 2022408:	dfc01015 	stw	ra,64(sp)
 202240c:	df000f15 	stw	fp,60(sp)
 2022410:	df000f04 	addi	fp,sp,60
 2022414:	e13fff15 	stw	r4,-4(fp)
   int dat;
   int speed, duplex, result, x;
   int status = SUCCESS;
 2022418:	e03ff715 	stw	zero,-36(fp)
   
   NET ifp;
   alt_sgdma_dev *sgdma_tx_dev;
   alt_sgdma_dev *sgdma_rx_dev;
   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse[iface].tse;
 202241c:	00c09934 	movhi	r3,612
 2022420:	18f4b004 	addi	r3,r3,-11584
 2022424:	e0bfff17 	ldw	r2,-4(fp)
 2022428:	10801324 	muli	r2,r2,76
 202242c:	1885883a 	add	r2,r3,r2
 2022430:	10801204 	addi	r2,r2,72
 2022434:	10800017 	ldw	r2,0(r2)
 2022438:	e0bff815 	stw	r2,-32(fp)
   
   dprintf("[tse_mac_init]\n");
 202243c:	01008174 	movhi	r4,517
 2022440:	2138d704 	addi	r4,r4,-7332
 2022444:	2006cb40 	call	2006cb4 <puts>
#ifdef PRINTIF
    dprintf("tse_mac_init %d\n", iface);
#endif    

    if (tse_hw->ext_desc_mem == 1) {
 2022448:	e0bff817 	ldw	r2,-32(fp)
 202244c:	10800783 	ldbu	r2,30(r2)
 2022450:	10803fcc 	andi	r2,r2,255
 2022454:	10800058 	cmpnei	r2,r2,1
 2022458:	10000b1e 	bne	r2,zero,2022488 <tse_mac_init+0x84>
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
 202245c:	e0bff817 	ldw	r2,-32(fp)
 2022460:	10800817 	ldw	r2,32(r2)
 2022464:	1007883a 	mov	r3,r2
 2022468:	01009934 	movhi	r4,612
 202246c:	2134b004 	addi	r4,r4,-11584
 2022470:	e0bfff17 	ldw	r2,-4(fp)
 2022474:	10801324 	muli	r2,r2,76
 2022478:	2085883a 	add	r2,r4,r2
 202247c:	10800f04 	addi	r2,r2,60
 2022480:	10c00015 	stw	r3,0(r2)
 2022484:	00001206 	br	20224d0 <tse_mac_init+0xcc>
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
 2022488:	01002804 	movi	r4,160
 202248c:	20379500 	call	2037950 <alt_uncached_malloc>
 2022490:	e0bff415 	stw	r2,-48(fp)
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 2022494:	00000306 	br	20224a4 <tse_mac_init+0xa0>
        {
            temp_desc++;
 2022498:	e0bff417 	ldw	r2,-48(fp)
 202249c:	10800044 	addi	r2,r2,1
 20224a0:	e0bff415 	stw	r2,-48(fp)
        tse[iface].desc = (alt_sgdma_descriptor *) tse_hw->desc_mem_base;
    }
    else {
        unsigned char *temp_desc = (unsigned char *)alt_uncached_malloc((4+ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE)*(sizeof(alt_sgdma_descriptor)));
    
        while ((((alt_u32)temp_desc) % ALTERA_AVALON_SGDMA_DESCRIPTOR_SIZE) != 0)
 20224a4:	e0bff417 	ldw	r2,-48(fp)
 20224a8:	108007cc 	andi	r2,r2,31
 20224ac:	103ffa1e 	bne	r2,zero,2022498 <tse_mac_init+0x94>
        {
            temp_desc++;
        }
        tse[iface].desc = (alt_sgdma_descriptor *) temp_desc;
 20224b0:	00c09934 	movhi	r3,612
 20224b4:	18f4b004 	addi	r3,r3,-11584
 20224b8:	e0bfff17 	ldw	r2,-4(fp)
 20224bc:	10801324 	muli	r2,r2,76
 20224c0:	1885883a 	add	r2,r3,r2
 20224c4:	10800f04 	addi	r2,r2,60
 20224c8:	e0fff417 	ldw	r3,-48(fp)
 20224cc:	10c00015 	stw	r3,0(r2)
    }

   
   /* Get the Rx and Tx SGDMA addresses */
   sgdma_tx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_tx);
 20224d0:	e0bff817 	ldw	r2,-32(fp)
 20224d4:	10800517 	ldw	r2,20(r2)
 20224d8:	1009883a 	mov	r4,r2
 20224dc:	20206900 	call	2020690 <alt_avalon_sgdma_open>
 20224e0:	e0bff915 	stw	r2,-28(fp)
   
   if(!sgdma_tx_dev) {
 20224e4:	e0bff917 	ldw	r2,-28(fp)
 20224e8:	1000051e 	bne	r2,zero,2022500 <tse_mac_init+0xfc>
      dprintf("[altera_eth_tse_init] Error opening TX SGDMA\n");
 20224ec:	01008174 	movhi	r4,517
 20224f0:	2138db04 	addi	r4,r4,-7316
 20224f4:	2006cb40 	call	2006cb4 <puts>
      return ENP_RESOURCE;
 20224f8:	00bffa84 	movi	r2,-22
 20224fc:	00025d06 	br	2022e74 <tse_mac_init+0xa70>
   }
  
   sgdma_rx_dev = alt_avalon_sgdma_open(tse_hw->tse_sgdma_rx);
 2022500:	e0bff817 	ldw	r2,-32(fp)
 2022504:	10800617 	ldw	r2,24(r2)
 2022508:	1009883a 	mov	r4,r2
 202250c:	20206900 	call	2020690 <alt_avalon_sgdma_open>
 2022510:	e0bffa15 	stw	r2,-24(fp)
   if(!sgdma_rx_dev) {
 2022514:	e0bffa17 	ldw	r2,-24(fp)
 2022518:	1000051e 	bne	r2,zero,2022530 <tse_mac_init+0x12c>
      dprintf("[altera_eth_tse_init] Error opening RX SGDMA\n");
 202251c:	01008174 	movhi	r4,517
 2022520:	2138e704 	addi	r4,r4,-7268
 2022524:	2006cb40 	call	2006cb4 <puts>
      return ENP_RESOURCE;
 2022528:	00bffa84 	movi	r2,-22
 202252c:	00025106 	br	2022e74 <tse_mac_init+0xa70>
   }

   /* Initialize mtip_mac_trans_info structure with values from <system.h>*/
   tse_mac_initTransInfo2(&tse[iface].mi, (int)tse_hw->tse_mac_base,
 2022530:	e0bfff17 	ldw	r2,-4(fp)
 2022534:	10801324 	muli	r2,r2,76
 2022538:	10c00104 	addi	r3,r2,4
 202253c:	00809934 	movhi	r2,612
 2022540:	10b4b004 	addi	r2,r2,-11584
 2022544:	1889883a 	add	r4,r3,r2
 2022548:	e0bff817 	ldw	r2,-32(fp)
 202254c:	11400017 	ldw	r5,0(r2)
 2022550:	e0fff917 	ldw	r3,-28(fp)
 2022554:	e0bffa17 	ldw	r2,-24(fp)
 2022558:	d8000015 	stw	zero,0(sp)
 202255c:	180d883a 	mov	r6,r3
 2022560:	100f883a 	mov	r7,r2
 2022564:	20382100 	call	2038210 <tse_mac_initTransInfo2>
                                   (unsigned int)sgdma_tx_dev,            
                                   (unsigned int)sgdma_rx_dev,
                                   0);

   /* Reset RX-side SGDMA */
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base,
 2022568:	00c09934 	movhi	r3,612
 202256c:	18f4b004 	addi	r3,r3,-11584
 2022570:	e0bfff17 	ldw	r2,-4(fp)
 2022574:	10801324 	muli	r2,r2,76
 2022578:	1885883a 	add	r2,r3,r2
 202257c:	10800304 	addi	r2,r2,12
 2022580:	10800017 	ldw	r2,0(r2)
 2022584:	10800317 	ldw	r2,12(r2)
 2022588:	10800404 	addi	r2,r2,16
 202258c:	00c00074 	movhi	r3,1
 2022590:	10c00035 	stwio	r3,0(r2)
     ALTERA_AVALON_SGDMA_CONTROL_SOFTWARERESET_MSK);
   IOWR_ALTERA_AVALON_SGDMA_CONTROL(tse[iface].mi.rx_sgdma->base, 0x0);
 2022594:	00c09934 	movhi	r3,612
 2022598:	18f4b004 	addi	r3,r3,-11584
 202259c:	e0bfff17 	ldw	r2,-4(fp)
 20225a0:	10801324 	muli	r2,r2,76
 20225a4:	1885883a 	add	r2,r3,r2
 20225a8:	10800304 	addi	r2,r2,12
 20225ac:	10800017 	ldw	r2,0(r2)
 20225b0:	10800317 	ldw	r2,12(r2)
 20225b4:	10800404 	addi	r2,r2,16
 20225b8:	0007883a 	mov	r3,zero
 20225bc:	10c00035 	stwio	r3,0(r2)
   
   tse[iface].interruptNR = tse_hw->tse_sgdma_rx_irq;
 20225c0:	e0bff817 	ldw	r2,-32(fp)
 20225c4:	1080070b 	ldhu	r2,28(r2)
 20225c8:	10ffffcc 	andi	r3,r2,65535
 20225cc:	01009934 	movhi	r4,612
 20225d0:	2134b004 	addi	r4,r4,-11584
 20225d4:	e0bfff17 	ldw	r2,-4(fp)
 20225d8:	10801324 	muli	r2,r2,76
 20225dc:	2085883a 	add	r2,r4,r2
 20225e0:	10800904 	addi	r2,r2,36
 20225e4:	10c00015 	stw	r3,0(r2)
   ifp = tse[iface].netp;
 20225e8:	00c09934 	movhi	r3,612
 20225ec:	18f4b004 	addi	r3,r3,-11584
 20225f0:	e0bfff17 	ldw	r2,-4(fp)
 20225f4:	10801324 	muli	r2,r2,76
 20225f8:	1885883a 	add	r2,r3,r2
 20225fc:	10800804 	addi	r2,r2,32
 2022600:	10800017 	ldw	r2,0(r2)
 2022604:	e0bffb15 	stw	r2,-20(fp)

   /* reset the PHY if necessary */   
   result = getPHYSpeed(tse[iface].mi.base);
 2022608:	00c09934 	movhi	r3,612
 202260c:	18f4b004 	addi	r3,r3,-11584
 2022610:	e0bfff17 	ldw	r2,-4(fp)
 2022614:	10801324 	muli	r2,r2,76
 2022618:	1885883a 	add	r2,r3,r2
 202261c:	10800104 	addi	r2,r2,4
 2022620:	10800017 	ldw	r2,0(r2)
 2022624:	1009883a 	mov	r4,r2
 2022628:	20396900 	call	2039690 <getPHYSpeed>
 202262c:	e0bffc15 	stw	r2,-16(fp)
   speed = (result >> 1) & 0x07;
 2022630:	e0bffc17 	ldw	r2,-16(fp)
 2022634:	1005d07a 	srai	r2,r2,1
 2022638:	108001cc 	andi	r2,r2,7
 202263c:	e0bffd15 	stw	r2,-12(fp)
   duplex = result & 0x01;
 2022640:	e0bffc17 	ldw	r2,-16(fp)
 2022644:	1080004c 	andi	r2,r2,1
 2022648:	e0bffe15 	stw	r2,-8(fp)
    
   /* reset the mac */ 
   IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,
 202264c:	00c09934 	movhi	r3,612
 2022650:	18f4b004 	addi	r3,r3,-11584
 2022654:	e0bfff17 	ldw	r2,-4(fp)
 2022658:	10801324 	muli	r2,r2,76
 202265c:	1885883a 	add	r2,r3,r2
 2022660:	10800104 	addi	r2,r2,4
 2022664:	10800017 	ldw	r2,0(r2)
 2022668:	10800204 	addi	r2,r2,8
 202266c:	00c800c4 	movi	r3,8195
 2022670:	10c00035 	stwio	r3,0(r2)
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
 2022674:	e03ff315 	stw	zero,-52(fp)
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 2022678:	00000706 	br	2022698 <tse_mac_init+0x294>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
 202267c:	e0bff317 	ldw	r2,-52(fp)
 2022680:	1089c448 	cmpgei	r2,r2,10001
 2022684:	e0fff317 	ldw	r3,-52(fp)
 2022688:	18c00044 	addi	r3,r3,1
 202268c:	e0fff315 	stw	r3,-52(fp)
 2022690:	10803fcc 	andi	r2,r2,255
 2022694:	10000c1e 	bne	r2,zero,20226c8 <tse_mac_init+0x2c4>
                             mmac_cc_SW_RESET_mask | 
                             mmac_cc_TX_ENA_mask | 
                             mmac_cc_RX_ENA_mask);
  
   x=0;
   while(IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base) & 
 2022698:	00c09934 	movhi	r3,612
 202269c:	18f4b004 	addi	r3,r3,-11584
 20226a0:	e0bfff17 	ldw	r2,-4(fp)
 20226a4:	10801324 	muli	r2,r2,76
 20226a8:	1885883a 	add	r2,r3,r2
 20226ac:	10800104 	addi	r2,r2,4
 20226b0:	10800017 	ldw	r2,0(r2)
 20226b4:	10800204 	addi	r2,r2,8
 20226b8:	10800037 	ldwio	r2,0(r2)
 20226bc:	1088000c 	andi	r2,r2,8192
 20226c0:	103fee1e 	bne	r2,zero,202267c <tse_mac_init+0x278>
 20226c4:	00000106 	br	20226cc <tse_mac_init+0x2c8>
         ALTERA_TSEMAC_CMD_SW_RESET_MSK) {
     if( x++ > 10000 ) {
       break;
 20226c8:	0001883a 	nop
     }
   }
   if(x >= 10000) {
 20226cc:	e0bff317 	ldw	r2,-52(fp)
 20226d0:	1089c410 	cmplti	r2,r2,10000
 20226d4:	1000031e 	bne	r2,zero,20226e4 <tse_mac_init+0x2e0>
     dprintf("TSEMAC SW reset bit never cleared!\n");
 20226d8:	01008174 	movhi	r4,517
 20226dc:	2138f304 	addi	r4,r4,-7220
 20226e0:	2006cb40 	call	2006cb4 <puts>
   }

   dat = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 20226e4:	00c09934 	movhi	r3,612
 20226e8:	18f4b004 	addi	r3,r3,-11584
 20226ec:	e0bfff17 	ldw	r2,-4(fp)
 20226f0:	10801324 	muli	r2,r2,76
 20226f4:	1885883a 	add	r2,r3,r2
 20226f8:	10800104 	addi	r2,r2,4
 20226fc:	10800017 	ldw	r2,0(r2)
 2022700:	10800204 	addi	r2,r2,8
 2022704:	10800037 	ldwio	r2,0(r2)
 2022708:	e0bff215 	stw	r2,-56(fp)
   if( (dat & 0x03) != 0 ) {
 202270c:	e0bff217 	ldw	r2,-56(fp)
 2022710:	108000cc 	andi	r2,r2,3
 2022714:	10000526 	beq	r2,zero,202272c <tse_mac_init+0x328>
     dprintf("WARN: RX/TX not disabled after reset... missing PHY clock? CMD_CONFIG=0x%08x\n", dat);
 2022718:	01008174 	movhi	r4,517
 202271c:	2138fc04 	addi	r4,r4,-7184
 2022720:	e17ff217 	ldw	r5,-56(fp)
 2022724:	2006a240 	call	2006a24 <printf>
 2022728:	00000506 	br	2022740 <tse_mac_init+0x33c>
   } 
   else {
     dprintf("OK, x=%d, CMD_CONFIG=0x%08x\n", x, dat);
 202272c:	01008174 	movhi	r4,517
 2022730:	21391004 	addi	r4,r4,-7104
 2022734:	e17ff317 	ldw	r5,-52(fp)
 2022738:	e1bff217 	ldw	r6,-56(fp)
 202273c:	2006a240 	call	2006a24 <printf>
  
    /* Hack code to determine the Channel number <- Someone please fix this ugly code in the future */
    extern alt_u8 mac_group_count;
    extern alt_tse_mac_group *pmac_groups[TSE_MAX_MAC_IN_SYSTEM];
      
    if(tse_hw->use_shared_fifo == 1) {
 2022740:	e0bff817 	ldw	r2,-32(fp)
 2022744:	10800903 	ldbu	r2,36(r2)
 2022748:	10803fcc 	andi	r2,r2,255
 202274c:	10800058 	cmpnei	r2,r2,1
 2022750:	1000351e 	bne	r2,zero,2022828 <tse_mac_init+0x424>
      int channel_loop = 0;
 2022754:	e03ff515 	stw	zero,-44(fp)
      int mac_loop = 0;
 2022758:	e03ff615 	stw	zero,-40(fp)
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 202275c:	e03ff515 	stw	zero,-44(fp)
 2022760:	00002b06 	br	2022810 <tse_mac_init+0x40c>
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 2022764:	e03ff615 	stw	zero,-40(fp)
 2022768:	00001b06 	br	20227d8 <tse_mac_init+0x3d4>
          if (pmac_groups[channel_loop]->pmac_info[mac_loop]->psys_info == tse_hw) {
 202276c:	00c09934 	movhi	r3,612
 2022770:	18f76d04 	addi	r3,r3,-8780
 2022774:	e0bff517 	ldw	r2,-44(fp)
 2022778:	1085883a 	add	r2,r2,r2
 202277c:	1085883a 	add	r2,r2,r2
 2022780:	1885883a 	add	r2,r3,r2
 2022784:	10c00017 	ldw	r3,0(r2)
 2022788:	e0bff617 	ldw	r2,-40(fp)
 202278c:	10800044 	addi	r2,r2,1
 2022790:	1085883a 	add	r2,r2,r2
 2022794:	1085883a 	add	r2,r2,r2
 2022798:	1885883a 	add	r2,r3,r2
 202279c:	10800017 	ldw	r2,0(r2)
 20227a0:	10c00217 	ldw	r3,8(r2)
 20227a4:	e0bff817 	ldw	r2,-32(fp)
 20227a8:	1880081e 	bne	r3,r2,20227cc <tse_mac_init+0x3c8>
            tse[iface].channel = mac_loop;
 20227ac:	00c09934 	movhi	r3,612
 20227b0:	18f4b004 	addi	r3,r3,-11584
 20227b4:	e0bfff17 	ldw	r2,-4(fp)
 20227b8:	10801324 	muli	r2,r2,76
 20227bc:	1885883a 	add	r2,r3,r2
 20227c0:	10800d04 	addi	r2,r2,52
 20227c4:	e0fff617 	ldw	r3,-40(fp)
 20227c8:	10c00015 	stw	r3,0(r2)
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
        for (mac_loop = 0; mac_loop < pmac_groups[channel_loop]->channel; mac_loop ++) {
 20227cc:	e0bff617 	ldw	r2,-40(fp)
 20227d0:	10800044 	addi	r2,r2,1
 20227d4:	e0bff615 	stw	r2,-40(fp)
 20227d8:	00c09934 	movhi	r3,612
 20227dc:	18f76d04 	addi	r3,r3,-8780
 20227e0:	e0bff517 	ldw	r2,-44(fp)
 20227e4:	1085883a 	add	r2,r2,r2
 20227e8:	1085883a 	add	r2,r2,r2
 20227ec:	1885883a 	add	r2,r3,r2
 20227f0:	10800017 	ldw	r2,0(r2)
 20227f4:	10800003 	ldbu	r2,0(r2)
 20227f8:	10803fcc 	andi	r2,r2,255
 20227fc:	e0fff617 	ldw	r3,-40(fp)
 2022800:	18bfda16 	blt	r3,r2,202276c <tse_mac_init+0x368>
      
    if(tse_hw->use_shared_fifo == 1) {
      int channel_loop = 0;
      int mac_loop = 0;
         
      for (channel_loop = 0; channel_loop < mac_group_count; channel_loop ++) {
 2022804:	e0bff517 	ldw	r2,-44(fp)
 2022808:	10800044 	addi	r2,r2,1
 202280c:	e0bff515 	stw	r2,-44(fp)
 2022810:	00808174 	movhi	r2,517
 2022814:	1090d944 	addi	r2,r2,17253
 2022818:	10800003 	ldbu	r2,0(r2)
 202281c:	10803fcc 	andi	r2,r2,255
 2022820:	e0fff517 	ldw	r3,-44(fp)
 2022824:	18bfcf16 	blt	r3,r2,2022764 <tse_mac_init+0x360>
        }
      }
    }
    /* End of Hack code */
  
  if(tse_hw->use_shared_fifo == 1) {
 2022828:	e0bff817 	ldw	r2,-32(fp)
 202282c:	10800903 	ldbu	r2,36(r2)
 2022830:	10803fcc 	andi	r2,r2,255
 2022834:	10800058 	cmpnei	r2,r2,1
 2022838:	10000d1e 	bne	r2,zero,2022870 <tse_mac_init+0x46c>
      IOWR_ALTERA_MULTI_CHAN_FIFO_SEC_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,tse_hw->tse_shared_fifo_rx_depth);
 202283c:	e0bff817 	ldw	r2,-32(fp)
 2022840:	10800d17 	ldw	r2,52(r2)
 2022844:	e0fff817 	ldw	r3,-32(fp)
 2022848:	18c00f17 	ldw	r3,60(r3)
 202284c:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_MULTI_CHAN_FIFO_ALMOST_FULL_THRESHOLD(tse_hw->tse_shared_fifo_rx_ctrl_base,((tse_hw->tse_shared_fifo_rx_depth) - 140));
 2022850:	e0bff817 	ldw	r2,-32(fp)
 2022854:	10800d17 	ldw	r2,52(r2)
 2022858:	10800204 	addi	r2,r2,8
 202285c:	e0fff817 	ldw	r3,-32(fp)
 2022860:	18c00f17 	ldw	r3,60(r3)
 2022864:	18ffdd04 	addi	r3,r3,-140
 2022868:	10c00035 	stwio	r3,0(r2)
 202286c:	00006006 	br	20229f0 <tse_mac_init+0x5ec>
  }
  else {
      /* Initialize MAC registers */
      IOWR_ALTERA_TSEMAC_FRM_LENGTH(tse[iface].mi.base, ALTERA_TSE_MAC_MAX_FRAME_LENGTH); 
 2022870:	00c09934 	movhi	r3,612
 2022874:	18f4b004 	addi	r3,r3,-11584
 2022878:	e0bfff17 	ldw	r2,-4(fp)
 202287c:	10801324 	muli	r2,r2,76
 2022880:	1885883a 	add	r2,r3,r2
 2022884:	10800104 	addi	r2,r2,4
 2022888:	10800017 	ldw	r2,0(r2)
 202288c:	10800504 	addi	r2,r2,20
 2022890:	00c17b84 	movi	r3,1518
 2022894:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 2022898:	00c09934 	movhi	r3,612
 202289c:	18f4b004 	addi	r3,r3,-11584
 20228a0:	e0bfff17 	ldw	r2,-4(fp)
 20228a4:	10801324 	muli	r2,r2,76
 20228a8:	1885883a 	add	r2,r3,r2
 20228ac:	10800104 	addi	r2,r2,4
 20228b0:	10800017 	ldw	r2,0(r2)
 20228b4:	10800b04 	addi	r2,r2,44
 20228b8:	00c00204 	movi	r3,8
 20228bc:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_ALMOST_FULL(tse[iface].mi.base, 8);
 20228c0:	00c09934 	movhi	r3,612
 20228c4:	18f4b004 	addi	r3,r3,-11584
 20228c8:	e0bfff17 	ldw	r2,-4(fp)
 20228cc:	10801324 	muli	r2,r2,76
 20228d0:	1885883a 	add	r2,r3,r2
 20228d4:	10800104 	addi	r2,r2,4
 20228d8:	10800017 	ldw	r2,0(r2)
 20228dc:	10800c04 	addi	r2,r2,48
 20228e0:	00c00204 	movi	r3,8
 20228e4:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_EMPTY(tse[iface].mi.base, 8);
 20228e8:	00c09934 	movhi	r3,612
 20228ec:	18f4b004 	addi	r3,r3,-11584
 20228f0:	e0bfff17 	ldw	r2,-4(fp)
 20228f4:	10801324 	muli	r2,r2,76
 20228f8:	1885883a 	add	r2,r3,r2
 20228fc:	10800104 	addi	r2,r2,4
 2022900:	10800017 	ldw	r2,0(r2)
 2022904:	10800d04 	addi	r2,r2,52
 2022908:	00c00204 	movi	r3,8
 202290c:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_ALMOST_FULL(tse[iface].mi.base,  3);
 2022910:	00c09934 	movhi	r3,612
 2022914:	18f4b004 	addi	r3,r3,-11584
 2022918:	e0bfff17 	ldw	r2,-4(fp)
 202291c:	10801324 	muli	r2,r2,76
 2022920:	1885883a 	add	r2,r3,r2
 2022924:	10800104 	addi	r2,r2,4
 2022928:	10800017 	ldw	r2,0(r2)
 202292c:	10800e04 	addi	r2,r2,56
 2022930:	00c000c4 	movi	r3,3
 2022934:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_tx_depth - 16); //1024/4;  
 2022938:	00c09934 	movhi	r3,612
 202293c:	18f4b004 	addi	r3,r3,-11584
 2022940:	e0bfff17 	ldw	r2,-4(fp)
 2022944:	10801324 	muli	r2,r2,76
 2022948:	1885883a 	add	r2,r3,r2
 202294c:	10800104 	addi	r2,r2,4
 2022950:	10800017 	ldw	r2,0(r2)
 2022954:	10800904 	addi	r2,r2,36
 2022958:	e0fff817 	ldw	r3,-32(fp)
 202295c:	18c0010b 	ldhu	r3,4(r3)
 2022960:	18ffffcc 	andi	r3,r3,65535
 2022964:	18fffc04 	addi	r3,r3,-16
 2022968:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_TX_SECTION_FULL(tse[iface].mi.base,  0); //32/4; // start transmit when there are 48 bytes
 202296c:	00c09934 	movhi	r3,612
 2022970:	18f4b004 	addi	r3,r3,-11584
 2022974:	e0bfff17 	ldw	r2,-4(fp)
 2022978:	10801324 	muli	r2,r2,76
 202297c:	1885883a 	add	r2,r3,r2
 2022980:	10800104 	addi	r2,r2,4
 2022984:	10800017 	ldw	r2,0(r2)
 2022988:	10800a04 	addi	r2,r2,40
 202298c:	0007883a 	mov	r3,zero
 2022990:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_EMPTY(tse[iface].mi.base, tse_hw->tse_rx_depth - 16); //4000/4);
 2022994:	00c09934 	movhi	r3,612
 2022998:	18f4b004 	addi	r3,r3,-11584
 202299c:	e0bfff17 	ldw	r2,-4(fp)
 20229a0:	10801324 	muli	r2,r2,76
 20229a4:	1885883a 	add	r2,r3,r2
 20229a8:	10800104 	addi	r2,r2,4
 20229ac:	10800017 	ldw	r2,0(r2)
 20229b0:	10800704 	addi	r2,r2,28
 20229b4:	e0fff817 	ldw	r3,-32(fp)
 20229b8:	18c0018b 	ldhu	r3,6(r3)
 20229bc:	18ffffcc 	andi	r3,r3,65535
 20229c0:	18fffc04 	addi	r3,r3,-16
 20229c4:	10c00035 	stwio	r3,0(r2)
      IOWR_ALTERA_TSEMAC_RX_SECTION_FULL(tse[iface].mi.base,  0);
 20229c8:	00c09934 	movhi	r3,612
 20229cc:	18f4b004 	addi	r3,r3,-11584
 20229d0:	e0bfff17 	ldw	r2,-4(fp)
 20229d4:	10801324 	muli	r2,r2,76
 20229d8:	1885883a 	add	r2,r3,r2
 20229dc:	10800104 	addi	r2,r2,4
 20229e0:	10800017 	ldw	r2,0(r2)
 20229e4:	10800804 	addi	r2,r2,32
 20229e8:	0007883a 	mov	r3,zero
 20229ec:	10c00035 	stwio	r3,0(r2)
      tse[iface].rxShift16OK = 0;
    }
  } /* if(ETHHDR_BIAS == 0) */
 
  if(ETHHDR_BIAS == 2) {
    IOWR_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK);
 20229f0:	00c09934 	movhi	r3,612
 20229f4:	18f4b004 	addi	r3,r3,-11584
 20229f8:	e0bfff17 	ldw	r2,-4(fp)
 20229fc:	10801324 	muli	r2,r2,76
 2022a00:	1885883a 	add	r2,r3,r2
 2022a04:	10800104 	addi	r2,r2,4
 2022a08:	10800017 	ldw	r2,0(r2)
 2022a0c:	10803a04 	addi	r2,r2,232
 2022a10:	00c00134 	movhi	r3,4
 2022a14:	10c00035 	stwio	r3,0(r2)
 
    /*
     * check if the MAC supports the 16-bit shift option allowing us
     * to send BIASed frames without copying. Used by the send function later.
     */
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
 2022a18:	00c09934 	movhi	r3,612
 2022a1c:	18f4b004 	addi	r3,r3,-11584
 2022a20:	e0bfff17 	ldw	r2,-4(fp)
 2022a24:	10801324 	muli	r2,r2,76
 2022a28:	1885883a 	add	r2,r3,r2
 2022a2c:	10800104 	addi	r2,r2,4
 2022a30:	10800017 	ldw	r2,0(r2)
 2022a34:	10803a04 	addi	r2,r2,232
 2022a38:	10800037 	ldwio	r2,0(r2)
 2022a3c:	1080012c 	andhi	r2,r2,4
 2022a40:	10001e26 	beq	r2,zero,2022abc <tse_mac_init+0x6b8>
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
 2022a44:	00c09934 	movhi	r3,612
 2022a48:	18f4b004 	addi	r3,r3,-11584
 2022a4c:	e0bfff17 	ldw	r2,-4(fp)
 2022a50:	10801324 	muli	r2,r2,76
 2022a54:	1885883a 	add	r2,r3,r2
 2022a58:	10800a04 	addi	r2,r2,40
 2022a5c:	00c00044 	movi	r3,1
 2022a60:	10c00015 	stw	r3,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
      return ENP_LOGIC;
    }
  
    /* Enable RX shift 16 for alignment of all received frames on 16-bit start address */
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 2022a64:	00c09934 	movhi	r3,612
 2022a68:	18f4b004 	addi	r3,r3,-11584
 2022a6c:	e0bfff17 	ldw	r2,-4(fp)
 2022a70:	10801324 	muli	r2,r2,76
 2022a74:	1885883a 	add	r2,r3,r2
 2022a78:	10800104 	addi	r2,r2,4
 2022a7c:	10800017 	ldw	r2,0(r2)
 2022a80:	10803b04 	addi	r2,r2,236
 2022a84:	00c08034 	movhi	r3,512
 2022a88:	10c00035 	stwio	r3,0(r2)
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
 2022a8c:	00c09934 	movhi	r3,612
 2022a90:	18f4b004 	addi	r3,r3,-11584
 2022a94:	e0bfff17 	ldw	r2,-4(fp)
 2022a98:	10801324 	muli	r2,r2,76
 2022a9c:	1885883a 	add	r2,r3,r2
 2022aa0:	10800104 	addi	r2,r2,4
 2022aa4:	10800017 	ldw	r2,0(r2)
 2022aa8:	10803b04 	addi	r2,r2,236
 2022aac:	10800037 	ldwio	r2,0(r2)
 2022ab0:	1080802c 	andhi	r2,r2,512
 2022ab4:	10000e1e 	bne	r2,zero,2022af0 <tse_mac_init+0x6ec>
 2022ab8:	00001c06 	br	2022b2c <tse_mac_init+0x728>
    if(IORD_ALTERA_TSEMAC_TX_CMD_STAT(tse[iface].mi.base) &
      ALTERA_TSEMAC_TX_CMD_STAT_TXSHIFT16_MSK) {
      tse[iface].txShift16OK = 1;
    } 
    else {
      tse[iface].txShift16OK = 0;
 2022abc:	00c09934 	movhi	r3,612
 2022ac0:	18f4b004 	addi	r3,r3,-11584
 2022ac4:	e0bfff17 	ldw	r2,-4(fp)
 2022ac8:	10801324 	muli	r2,r2,76
 2022acc:	1885883a 	add	r2,r3,r2
 2022ad0:	10800a04 	addi	r2,r2,40
 2022ad4:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with TX_CMD_STAT register return TxShift16 value. \n",ETHHDR_BIAS);
 2022ad8:	01008174 	movhi	r4,517
 2022adc:	21391804 	addi	r4,r4,-7072
 2022ae0:	01400084 	movi	r5,2
 2022ae4:	2006a240 	call	2006a24 <printf>
      return ENP_LOGIC;
 2022ae8:	00bffd44 	movi	r2,-11
 2022aec:	0000e106 	br	2022e74 <tse_mac_init+0xa70>
    IOWR_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base,ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK);
 
    /* check if the MAC supports the 16-bit shift option at the RX CMD STATUS Register  */ 
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
 2022af0:	00c09934 	movhi	r3,612
 2022af4:	18f4b004 	addi	r3,r3,-11584
 2022af8:	e0bfff17 	ldw	r2,-4(fp)
 2022afc:	10801324 	muli	r2,r2,76
 2022b00:	1885883a 	add	r2,r3,r2
 2022b04:	10800b04 	addi	r2,r2,44
 2022b08:	00c00044 	movi	r3,1
 2022b0c:	10c00015 	stw	r3,0(r2)
      return ENP_LOGIC;
    }
  } /* if(ETHHDR_BIAS == 2) */
  
  /* enable MAC */
  dat = ALTERA_TSEMAC_CMD_TX_ENA_MSK       |
 2022b10:	00810034 	movhi	r2,1024
 2022b14:	108080c4 	addi	r2,r2,515
 2022b18:	e0bff215 	stw	r2,-56(fp)
        ALTERA_TSEMAC_CMD_TX_ADDR_INS_MSK  |
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
 2022b1c:	e0bffd17 	ldw	r2,-12(fp)
 2022b20:	10800060 	cmpeqi	r2,r2,1
 2022b24:	10000e1e 	bne	r2,zero,2022b60 <tse_mac_init+0x75c>
 2022b28:	00001606 	br	2022b84 <tse_mac_init+0x780>
    if(IORD_ALTERA_TSEMAC_RX_CMD_STAT(tse[iface].mi.base) & ALTERA_TSEMAC_RX_CMD_STAT_RXSHIFT16_MSK)
    {
      tse[iface].rxShift16OK = 1;
    } 
    else {
      tse[iface].rxShift16OK = 0;
 2022b2c:	00c09934 	movhi	r3,612
 2022b30:	18f4b004 	addi	r3,r3,-11584
 2022b34:	e0bfff17 	ldw	r2,-4(fp)
 2022b38:	10801324 	muli	r2,r2,76
 2022b3c:	1885883a 	add	r2,r3,r2
 2022b40:	10800b04 	addi	r2,r2,44
 2022b44:	10000015 	stw	zero,0(r2)
      dprintf("[tse_mac_init] Error: Incompatible %d value with RX_CMD_STAT register return RxShift16 value. \n",ETHHDR_BIAS);
 2022b48:	01008174 	movhi	r4,517
 2022b4c:	21393004 	addi	r4,r4,-6976
 2022b50:	01400084 	movi	r5,2
 2022b54:	2006a240 	call	2006a24 <printf>
      return ENP_LOGIC;
 2022b58:	00bffd44 	movi	r2,-11
 2022b5c:	0000c506 	br	2022e74 <tse_mac_init+0xa70>
        ALTERA_TSEMAC_CMD_RX_ERR_DISC_MSK;  /* automatically discard frames with CRC errors */
    
  
  /* 1000 Mbps */
  if(speed == 0x01) {
    dat |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2022b60:	e0bff217 	ldw	r2,-56(fp)
 2022b64:	10800214 	ori	r2,r2,8
 2022b68:	e0bff215 	stw	r2,-56(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2022b6c:	e0fff217 	ldw	r3,-56(fp)
 2022b70:	00bf8034 	movhi	r2,65024
 2022b74:	10bfffc4 	addi	r2,r2,-1
 2022b78:	1884703a 	and	r2,r3,r2
 2022b7c:	e0bff215 	stw	r2,-56(fp)
 2022b80:	00002106 	br	2022c08 <tse_mac_init+0x804>
  }
  /* 100 Mbps */
  else if(speed == 0x02) {
 2022b84:	e0bffd17 	ldw	r2,-12(fp)
 2022b88:	10800098 	cmpnei	r2,r2,2
 2022b8c:	10000a1e 	bne	r2,zero,2022bb8 <tse_mac_init+0x7b4>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2022b90:	e0fff217 	ldw	r3,-56(fp)
 2022b94:	00bffdc4 	movi	r2,-9
 2022b98:	1884703a 	and	r2,r3,r2
 2022b9c:	e0bff215 	stw	r2,-56(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2022ba0:	e0fff217 	ldw	r3,-56(fp)
 2022ba4:	00bf8034 	movhi	r2,65024
 2022ba8:	10bfffc4 	addi	r2,r2,-1
 2022bac:	1884703a 	and	r2,r3,r2
 2022bb0:	e0bff215 	stw	r2,-56(fp)
 2022bb4:	00001406 	br	2022c08 <tse_mac_init+0x804>
  }
  /* 10 Mbps */
  else if(speed == 0x04) {
 2022bb8:	e0bffd17 	ldw	r2,-12(fp)
 2022bbc:	10800118 	cmpnei	r2,r2,4
 2022bc0:	1000081e 	bne	r2,zero,2022be4 <tse_mac_init+0x7e0>
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2022bc4:	e0fff217 	ldw	r3,-56(fp)
 2022bc8:	00bffdc4 	movi	r2,-9
 2022bcc:	1884703a 	and	r2,r3,r2
 2022bd0:	e0bff215 	stw	r2,-56(fp)
	dat |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2022bd4:	e0bff217 	ldw	r2,-56(fp)
 2022bd8:	10808034 	orhi	r2,r2,512
 2022bdc:	e0bff215 	stw	r2,-56(fp)
 2022be0:	00000906 	br	2022c08 <tse_mac_init+0x804>
  }
  /* default to 100 Mbps if returned invalid speed */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2022be4:	e0fff217 	ldw	r3,-56(fp)
 2022be8:	00bffdc4 	movi	r2,-9
 2022bec:	1884703a 	and	r2,r3,r2
 2022bf0:	e0bff215 	stw	r2,-56(fp)
	dat &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2022bf4:	e0fff217 	ldw	r3,-56(fp)
 2022bf8:	00bf8034 	movhi	r2,65024
 2022bfc:	10bfffc4 	addi	r2,r2,-1
 2022c00:	1884703a 	and	r2,r3,r2
 2022c04:	e0bff215 	stw	r2,-56(fp)
  }
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 2022c08:	e0bffe17 	ldw	r2,-8(fp)
 2022c0c:	1000041e 	bne	r2,zero,2022c20 <tse_mac_init+0x81c>
    dat |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 2022c10:	e0bff217 	ldw	r2,-56(fp)
 2022c14:	10810014 	ori	r2,r2,1024
 2022c18:	e0bff215 	stw	r2,-56(fp)
 2022c1c:	00000406 	br	2022c30 <tse_mac_init+0x82c>
  }
  /* Full Duplex */
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 2022c20:	e0fff217 	ldw	r3,-56(fp)
 2022c24:	00beffc4 	movi	r2,-1025
 2022c28:	1884703a 	and	r2,r3,r2
 2022c2c:	e0bff215 	stw	r2,-56(fp)
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
 2022c30:	00c09934 	movhi	r3,612
 2022c34:	18f4b004 	addi	r3,r3,-11584
 2022c38:	e0bfff17 	ldw	r2,-4(fp)
 2022c3c:	10801324 	muli	r2,r2,76
 2022c40:	1885883a 	add	r2,r3,r2
 2022c44:	10800104 	addi	r2,r2,4
 2022c48:	10800017 	ldw	r2,0(r2)
 2022c4c:	10800204 	addi	r2,r2,8
 2022c50:	e0fff217 	ldw	r3,-56(fp)
 2022c54:	10c00035 	stwio	r3,0(r2)
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
 2022c58:	00c09934 	movhi	r3,612
 2022c5c:	18f4b004 	addi	r3,r3,-11584
 2022c60:	e0bfff17 	ldw	r2,-4(fp)
 2022c64:	10801324 	muli	r2,r2,76
 2022c68:	1885883a 	add	r2,r3,r2
 2022c6c:	10800104 	addi	r2,r2,4
 2022c70:	10800017 	ldw	r2,0(r2)
  else {
    dat &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
  }
          
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base, dat);
  dprintf("\nMAC post-initialization: CMD_CONFIG=0x%08x\n", 
 2022c74:	10800204 	addi	r2,r2,8
 2022c78:	10800037 	ldwio	r2,0(r2)
 2022c7c:	01008174 	movhi	r4,517
 2022c80:	21394804 	addi	r4,r4,-6880
 2022c84:	100b883a 	mov	r5,r2
 2022c88:	2006a240 	call	2006a24 <printf>
  IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base));
  
                          
#ifdef ALT_INICHE
   /* Set the MAC address */  
   IOWR_ALTERA_TSEMAC_MAC_0(tse[iface].mi.base,
 2022c8c:	00c09934 	movhi	r3,612
 2022c90:	18f4b004 	addi	r3,r3,-11584
 2022c94:	e0bfff17 	ldw	r2,-4(fp)
 2022c98:	10801324 	muli	r2,r2,76
 2022c9c:	1885883a 	add	r2,r3,r2
 2022ca0:	10800104 	addi	r2,r2,4
 2022ca4:	10800017 	ldw	r2,0(r2)
 2022ca8:	10800304 	addi	r2,r2,12
 2022cac:	01009934 	movhi	r4,612
 2022cb0:	2134b004 	addi	r4,r4,-11584
 2022cb4:	e0ffff17 	ldw	r3,-4(fp)
 2022cb8:	18c01324 	muli	r3,r3,76
 2022cbc:	20c7883a 	add	r3,r4,r3
 2022cc0:	18c00604 	addi	r3,r3,24
 2022cc4:	18c00003 	ldbu	r3,0(r3)
 2022cc8:	19003fcc 	andi	r4,r3,255
 2022ccc:	01409934 	movhi	r5,612
 2022cd0:	2974b004 	addi	r5,r5,-11584
 2022cd4:	e0ffff17 	ldw	r3,-4(fp)
 2022cd8:	18c01324 	muli	r3,r3,76
 2022cdc:	28c7883a 	add	r3,r5,r3
 2022ce0:	18c00644 	addi	r3,r3,25
 2022ce4:	18c00003 	ldbu	r3,0(r3)
 2022ce8:	18c03fcc 	andi	r3,r3,255
 2022cec:	1806923a 	slli	r3,r3,8
 2022cf0:	20c8b03a 	or	r4,r4,r3
 2022cf4:	01409934 	movhi	r5,612
 2022cf8:	2974b004 	addi	r5,r5,-11584
 2022cfc:	e0ffff17 	ldw	r3,-4(fp)
 2022d00:	18c01324 	muli	r3,r3,76
 2022d04:	28c7883a 	add	r3,r5,r3
 2022d08:	18c00684 	addi	r3,r3,26
 2022d0c:	18c00003 	ldbu	r3,0(r3)
 2022d10:	18c03fcc 	andi	r3,r3,255
 2022d14:	1806943a 	slli	r3,r3,16
 2022d18:	20c8b03a 	or	r4,r4,r3
 2022d1c:	01409934 	movhi	r5,612
 2022d20:	2974b004 	addi	r5,r5,-11584
 2022d24:	e0ffff17 	ldw	r3,-4(fp)
 2022d28:	18c01324 	muli	r3,r3,76
 2022d2c:	28c7883a 	add	r3,r5,r3
 2022d30:	18c006c4 	addi	r3,r3,27
 2022d34:	18c00003 	ldbu	r3,0(r3)
 2022d38:	18c03fcc 	andi	r3,r3,255
 2022d3c:	1806963a 	slli	r3,r3,24
 2022d40:	20c6b03a 	or	r3,r4,r3
 2022d44:	10c00035 	stwio	r3,0(r2)
                           ((int)((unsigned char) tse[iface].mac_addr[0]) | 
                            (int)((unsigned char) tse[iface].mac_addr[1] <<  8) |
                            (int)((unsigned char) tse[iface].mac_addr[2] << 16) | 
                            (int)((unsigned char) tse[iface].mac_addr[3] << 24)));
  
   IOWR_ALTERA_TSEMAC_MAC_1(tse[iface].mi.base, 
 2022d48:	00c09934 	movhi	r3,612
 2022d4c:	18f4b004 	addi	r3,r3,-11584
 2022d50:	e0bfff17 	ldw	r2,-4(fp)
 2022d54:	10801324 	muli	r2,r2,76
 2022d58:	1885883a 	add	r2,r3,r2
 2022d5c:	10800104 	addi	r2,r2,4
 2022d60:	10800017 	ldw	r2,0(r2)
 2022d64:	10800404 	addi	r2,r2,16
 2022d68:	01009934 	movhi	r4,612
 2022d6c:	2134b004 	addi	r4,r4,-11584
 2022d70:	e0ffff17 	ldw	r3,-4(fp)
 2022d74:	18c01324 	muli	r3,r3,76
 2022d78:	20c7883a 	add	r3,r4,r3
 2022d7c:	18c00704 	addi	r3,r3,28
 2022d80:	18c00003 	ldbu	r3,0(r3)
 2022d84:	19003fcc 	andi	r4,r3,255
 2022d88:	01409934 	movhi	r5,612
 2022d8c:	2974b004 	addi	r5,r5,-11584
 2022d90:	e0ffff17 	ldw	r3,-4(fp)
 2022d94:	18c01324 	muli	r3,r3,76
 2022d98:	28c7883a 	add	r3,r5,r3
 2022d9c:	18c00744 	addi	r3,r3,29
 2022da0:	18c00003 	ldbu	r3,0(r3)
 2022da4:	18c03fcc 	andi	r3,r3,255
 2022da8:	1806923a 	slli	r3,r3,8
 2022dac:	20c6b03a 	or	r3,r4,r3
 2022db0:	18ffffcc 	andi	r3,r3,65535
 2022db4:	10c00035 	stwio	r3,0(r2)
   tse[iface].mac_addr[5] = 0xBA;

#endif /* not ALT_INICHE */

   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
 2022db8:	00c09934 	movhi	r3,612
 2022dbc:	18f5c104 	addi	r3,r3,-10492
 2022dc0:	e0bfff17 	ldw	r2,-4(fp)
 2022dc4:	1085883a 	add	r2,r2,r2
 2022dc8:	1085883a 	add	r2,r2,r2
 2022dcc:	1885883a 	add	r2,r3,r2
 2022dd0:	10800017 	ldw	r2,0(r2)
 2022dd4:	10802717 	ldw	r2,156(r2)
 2022dd8:	00c00044 	movi	r3,1
 2022ddc:	10c00615 	stw	r3,24(r2)
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
 2022de0:	00c09934 	movhi	r3,612
 2022de4:	18f5c104 	addi	r3,r3,-10492
 2022de8:	e0bfff17 	ldw	r2,-4(fp)
 2022dec:	1085883a 	add	r2,r2,r2
 2022df0:	1085883a 	add	r2,r2,r2
 2022df4:	1885883a 	add	r2,r3,r2
 2022df8:	10800017 	ldw	r2,0(r2)
 2022dfc:	10802717 	ldw	r2,156(r2)
 2022e00:	00c00044 	movi	r3,1
 2022e04:	10c00715 	stw	r3,28(r2)
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 2022e08:	00c09934 	movhi	r3,612
 2022e0c:	18f4b004 	addi	r3,r3,-11584
 2022e10:	e0bfff17 	ldw	r2,-4(fp)
 2022e14:	10801324 	muli	r2,r2,76
 2022e18:	1885883a 	add	r2,r3,r2
 2022e1c:	10800304 	addi	r2,r2,12
 2022e20:	10c00017 	ldw	r3,0(r2)
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
 2022e24:	e0bfff17 	ldw	r2,-4(fp)
 2022e28:	11001324 	muli	r4,r2,76
 2022e2c:	00809934 	movhi	r2,612
 2022e30:	10b4b004 	addi	r2,r2,-11584
 2022e34:	2085883a 	add	r2,r4,r2
   /* status = UP */ 
   nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_UP;    
   nets[iface]->n_mib->ifOperStatus =  ALTERA_TSE_ADMIN_STATUS_UP;
   
   /* Install SGDMA (RX) interrupt handler */
   alt_avalon_sgdma_register_callback(
 2022e38:	1809883a 	mov	r4,r3
 2022e3c:	014080b4 	movhi	r5,514
 2022e40:	294c6004 	addi	r5,r5,12672
 2022e44:	01800604 	movi	r6,24
 2022e48:	100f883a 	mov	r7,r2
 2022e4c:	20205300 	call	2020530 <alt_avalon_sgdma_register_callback>
        tse[iface].mi.rx_sgdma,
        (alt_avalon_sgdma_callback)&tse_sgdmaRx_isr,
        (alt_u16)ALTERA_TSE_SGDMA_INTR_MASK,
        (void*)(&tse[iface]));
    
  status = tse_sgdma_read_init(&tse[iface]);
 2022e50:	e0bfff17 	ldw	r2,-4(fp)
 2022e54:	10c01324 	muli	r3,r2,76
 2022e58:	00809934 	movhi	r2,612
 2022e5c:	10b4b004 	addi	r2,r2,-11584
 2022e60:	1885883a 	add	r2,r3,r2
 2022e64:	1009883a 	mov	r4,r2
 2022e68:	20232300 	call	2023230 <tse_sgdma_read_init>
 2022e6c:	e0bff715 	stw	r2,-36(fp)
  
  return status;
 2022e70:	e0bff717 	ldw	r2,-36(fp)
}
 2022e74:	e037883a 	mov	sp,fp
 2022e78:	dfc00117 	ldw	ra,4(sp)
 2022e7c:	df000017 	ldw	fp,0(sp)
 2022e80:	dec00204 	addi	sp,sp,8
 2022e84:	f800283a 	ret

02022e88 <tse_mac_raw_send>:
 * @param  data - pointer to the data payload
 * @param  data_bytes - number of bytes of the data payload to be sent to the MAC
 * @return SUCCESS if success, else a negative value
 */
int tse_mac_raw_send(NET net, char * data, unsigned data_bytes)
{
 2022e88:	defe6404 	addi	sp,sp,-1648
 2022e8c:	dfc19b15 	stw	ra,1644(sp)
 2022e90:	df019a15 	stw	fp,1640(sp)
 2022e94:	df019a04 	addi	fp,sp,1640
 2022e98:	e13ffd15 	stw	r4,-12(fp)
 2022e9c:	e17ffe15 	stw	r5,-8(fp)
 2022ea0:	e1bfff15 	stw	r6,-4(fp)
   int result,i,tx_length;
   unsigned len = data_bytes;
 2022ea4:	e0bfff17 	ldw	r2,-4(fp)
 2022ea8:	e0be6d15 	stw	r2,-1612(fp)

   ins_tse_info* tse_ptr = (ins_tse_info*) net->n_local;
 2022eac:	e0bffd17 	ldw	r2,-12(fp)
 2022eb0:	10802817 	ldw	r2,160(r2)
 2022eb4:	e0be6e15 	stw	r2,-1608(fp)

   alt_tse_system_info* tse_hw = (alt_tse_system_info *) tse_ptr->tse;
 2022eb8:	e0be6e17 	ldw	r2,-1608(fp)
 2022ebc:	10801217 	ldw	r2,72(r2)
 2022ec0:	e0be6f15 	stw	r2,-1604(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2022ec4:	0005303a 	rdctl	r2,status
 2022ec8:	e0be7315 	stw	r2,-1588(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2022ecc:	e0fe7317 	ldw	r3,-1588(fp)
 2022ed0:	00bfff84 	movi	r2,-2
 2022ed4:	1884703a 	and	r2,r3,r2
 2022ed8:	1001703a 	wrctl	status,r2
  
  return context;
 2022edc:	e0be7317 	ldw	r2,-1588(fp)
   unsigned int* ActualData;
   int cpu_sr;
   /* Intermediate buffers used for temporary copy of frames that cannot be directrly DMA'ed*/
   char buf2[1560];

   OS_ENTER_CRITICAL();
 2022ee0:	e0be7015 	stw	r2,-1600(fp)
   mi = &tse_ptr->mi;
 2022ee4:	e0be6e17 	ldw	r2,-1608(fp)
 2022ee8:	10800104 	addi	r2,r2,4
 2022eec:	e0be7115 	stw	r2,-1596(fp)
   
   if(tse_ptr->sem!=0) /* Tx is busy*/
 2022ef0:	e0be6e17 	ldw	r2,-1608(fp)
 2022ef4:	10800c17 	ldw	r2,48(r2)
 2022ef8:	10000926 	beq	r2,zero,2022f20 <tse_mac_raw_send+0x98>
   {
      dprintf("raw_send CALLED AGAIN!!!\n");
 2022efc:	01008174 	movhi	r4,517
 2022f00:	21395404 	addi	r4,r4,-6832
 2022f04:	2006cb40 	call	2006cb4 <puts>
 2022f08:	e0be7017 	ldw	r2,-1600(fp)
 2022f0c:	e0be7415 	stw	r2,-1584(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2022f10:	e0be7417 	ldw	r2,-1584(fp)
 2022f14:	1001703a 	wrctl	status,r2
      OS_EXIT_CRITICAL();
      return ENP_RESOURCE;
 2022f18:	00bffa84 	movi	r2,-22
 2022f1c:	00009306 	br	202316c <tse_mac_raw_send+0x2e4>
   }
 
   tse_ptr->sem = 1;  
 2022f20:	e0be6e17 	ldw	r2,-1608(fp)
 2022f24:	00c00044 	movi	r3,1
 2022f28:	10c00c15 	stw	r3,48(r2)

   if(((unsigned long)data & 0x03) == 0) 
 2022f2c:	e0bffe17 	ldw	r2,-8(fp)
 2022f30:	108000cc 	andi	r2,r2,3
 2022f34:	1000031e 	bne	r2,zero,2022f44 <tse_mac_raw_send+0xbc>
   { 
      /* 32-bit aligned start, then header starts ETHHDR_BIAS later => 16 bit shift is ok */    
      ActualData = (unsigned int*)data;  /* base driver will detect 16-bit shift. */
 2022f38:	e0bffe17 	ldw	r2,-8(fp)
 2022f3c:	e0be6c15 	stw	r2,-1616(fp)
 2022f40:	00001406 	br	2022f94 <tse_mac_raw_send+0x10c>
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 2022f44:	e03e6b15 	stw	zero,-1620(fp)
 2022f48:	00000d06 	br	2022f80 <tse_mac_raw_send+0xf8>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
 2022f4c:	e0be6b17 	ldw	r2,-1620(fp)
 2022f50:	e0fffe17 	ldw	r3,-8(fp)
 2022f54:	1885883a 	add	r2,r3,r2
 2022f58:	10800023 	ldbuio	r2,0(r2)
 2022f5c:	10803fcc 	andi	r2,r2,255
 2022f60:	1007883a 	mov	r3,r2
 2022f64:	e13e7704 	addi	r4,fp,-1572
 2022f68:	e0be6b17 	ldw	r2,-1620(fp)
 2022f6c:	2085883a 	add	r2,r4,r2
 2022f70:	10c00005 	stb	r3,0(r2)
      /* 
       * Copy data to temporary buffer <buf2>. This is done because of allignment 
       * issues. The SGDMA cannot copy the data directly from (data + ETHHDR_BIAS)
       * because it needs a 32-bit alligned address space. 
       */
      for(i=0;i<len;i++) {
 2022f74:	e0be6b17 	ldw	r2,-1620(fp)
 2022f78:	10800044 	addi	r2,r2,1
 2022f7c:	e0be6b15 	stw	r2,-1620(fp)
 2022f80:	e0fe6b17 	ldw	r3,-1620(fp)
 2022f84:	e0be6d17 	ldw	r2,-1612(fp)
 2022f88:	18bff036 	bltu	r3,r2,2022f4c <tse_mac_raw_send+0xc4>
         buf2[i] = IORD_8DIRECT(&data[i], 0);
      }
      ActualData = (unsigned int*)buf2;
 2022f8c:	e0be7704 	addi	r2,fp,-1572
 2022f90:	e0be6c15 	stw	r2,-1616(fp)
   }  
   
     // clear bit-31 before passing it to SGDMA Driver
    ActualData = (unsigned int*)alt_remap_cached ((volatile void*) ActualData, 4);
 2022f94:	e13e6c17 	ldw	r4,-1616(fp)
 2022f98:	01400104 	movi	r5,4
 2022f9c:	20378dc0 	call	20378dc <alt_remap_cached>
 2022fa0:	e0be6c15 	stw	r2,-1616(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
 2022fa4:	e0be6f17 	ldw	r2,-1604(fp)
 2022fa8:	10800903 	ldbu	r2,36(r2)
 2022fac:	10803fcc 	andi	r2,r2,255
 2022fb0:	10800058 	cmpnei	r2,r2,1
 2022fb4:	1000271e 	bne	r2,zero,2023054 <tse_mac_raw_send+0x1cc>
 2022fb8:	e0be6d17 	ldw	r2,-1612(fp)
 2022fbc:	108003f0 	cmpltui	r2,r2,15
 2022fc0:	1000241e 	bne	r2,zero,2023054 <tse_mac_raw_send+0x1cc>
 2022fc4:	e0be6e17 	ldw	r2,-1608(fp)
 2022fc8:	10800d17 	ldw	r2,52(r2)
 2022fcc:	1085883a 	add	r2,r2,r2
 2022fd0:	1085883a 	add	r2,r2,r2
 2022fd4:	1007883a 	mov	r3,r2
 2022fd8:	e0be6f17 	ldw	r2,-1604(fp)
 2022fdc:	10800b17 	ldw	r2,44(r2)
 2022fe0:	1885883a 	add	r2,r3,r2
 2022fe4:	10800037 	ldwio	r2,0(r2)
 2022fe8:	10800388 	cmpgei	r2,r2,14
 2022fec:	1000191e 	bne	r2,zero,2023054 <tse_mac_raw_send+0x1cc>
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
 2022ff0:	e0be6e17 	ldw	r2,-1608(fp)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 2022ff4:	11000f17 	ldw	r4,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 2022ff8:	e0be6e17 	ldw	r2,-1608(fp)
 2022ffc:	10800f17 	ldw	r2,60(r2)

   /* Write data to Tx FIFO using the DMA */
   if((tse_hw->use_shared_fifo == 1) && (( len > ALTERA_TSE_MIN_MTU_SIZE )) && (IORD_ALTERA_MULTI_CHAN_FILL_LEVEL(tse_hw->tse_shared_fifo_tx_stat_base, tse_ptr->channel) < ALTERA_TSE_MIN_MTU_SIZE))
   {
        /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 2023000:	10c00804 	addi	r3,r2,32
 2023004:	e0be6d17 	ldw	r2,-1612(fp)
 2023008:	10bfffcc 	andi	r2,r2,65535
 202300c:	d8000015 	stw	zero,0(sp)
 2023010:	01400044 	movi	r5,1
 2023014:	d9400115 	stw	r5,4(sp)
 2023018:	01400044 	movi	r5,1
 202301c:	d9400215 	stw	r5,8(sp)
 2023020:	d8000315 	stw	zero,12(sp)
 2023024:	180b883a 	mov	r5,r3
 2023028:	e1be6c17 	ldw	r6,-1616(fp)
 202302c:	100f883a 	mov	r7,r2
 2023030:	202042c0 	call	202042c <alt_avalon_sgdma_construct_mem_to_stream_desc>
           0,                                        // don't read from constant address
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)

        tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 2023034:	e0be6e17 	ldw	r2,-1608(fp)
 2023038:	10800f17 	ldw	r2,60(r2)
 202303c:	e13e7117 	ldw	r4,-1596(fp)
 2023040:	100b883a 	mov	r5,r2
 2023044:	20382700 	call	2038270 <tse_mac_sTxWrite>
 2023048:	e0be7215 	stw	r2,-1592(fp)
        result = 0;
 202304c:	e03e6a15 	stw	zero,-1624(fp)
 2023050:	00001e06 	br	20230cc <tse_mac_raw_send+0x244>
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    
 2023054:	e0be6d17 	ldw	r2,-1612(fp)
 2023058:	108003f0 	cmpltui	r2,r2,15
 202305c:	1000191e 	bne	r2,zero,20230c4 <tse_mac_raw_send+0x23c>

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
 2023060:	e0be6e17 	ldw	r2,-1608(fp)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 2023064:	11000f17 	ldw	r4,60(r2)
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_FIRST_TX_SGDMA_DESC_OFST], // descriptor I want to work with
           (alt_sgdma_descriptor *) &tse_ptr->desc[ALTERA_TSE_SECOND_TX_SGDMA_DESC_OFST],// pointer to "next"
 2023068:	e0be6e17 	ldw	r2,-1608(fp)
 202306c:	10800f17 	ldw	r2,60(r2)
        result = 0;
   }
   else if( len > ALTERA_TSE_MIN_MTU_SIZE ) {    

       /* make sure there is room in the FIFO.        */
        alt_avalon_sgdma_construct_mem_to_stream_desc(
 2023070:	10c00804 	addi	r3,r2,32
 2023074:	e0be6d17 	ldw	r2,-1612(fp)
 2023078:	10bfffcc 	andi	r2,r2,65535
 202307c:	d8000015 	stw	zero,0(sp)
 2023080:	01400044 	movi	r5,1
 2023084:	d9400115 	stw	r5,4(sp)
 2023088:	01400044 	movi	r5,1
 202308c:	d9400215 	stw	r5,8(sp)
 2023090:	d8000315 	stw	zero,12(sp)
 2023094:	180b883a 	mov	r5,r3
 2023098:	e1be6c17 	ldw	r6,-1616(fp)
 202309c:	100f883a 	mov	r7,r2
 20230a0:	202042c0 	call	202042c <alt_avalon_sgdma_construct_mem_to_stream_desc>
           1,                                        // generate sop
           1,                                        // generate endofpacket signal
           0);                                       // atlantic channel (don't know/don't care: set to 0)
                  
    
       tx_length = tse_mac_sTxWrite(mi,tse_ptr->desc);
 20230a4:	e0be6e17 	ldw	r2,-1608(fp)
 20230a8:	10800f17 	ldw	r2,60(r2)
 20230ac:	e13e7117 	ldw	r4,-1596(fp)
 20230b0:	100b883a 	mov	r5,r2
 20230b4:	20382700 	call	2038270 <tse_mac_sTxWrite>
 20230b8:	e0be7215 	stw	r2,-1592(fp)
       result = 0;
 20230bc:	e03e6a15 	stw	zero,-1624(fp)
 20230c0:	00000206 	br	20230cc <tse_mac_raw_send+0x244>

   } else {
       result = -3;
 20230c4:	00bfff44 	movi	r2,-3
 20230c8:	e0be6a15 	stw	r2,-1624(fp)
   }

   if(result < 0)   /* SGDMA not available */
 20230cc:	e0be6a17 	ldw	r2,-1624(fp)
 20230d0:	1000120e 	bge	r2,zero,202311c <tse_mac_raw_send+0x294>
   {
      dprintf("raw_send() SGDMA not available, ret=%d, len=%d\n",result, len);
 20230d4:	01008174 	movhi	r4,517
 20230d8:	21395b04 	addi	r4,r4,-6804
 20230dc:	e17e6a17 	ldw	r5,-1624(fp)
 20230e0:	e1be6d17 	ldw	r6,-1612(fp)
 20230e4:	2006a240 	call	2006a24 <printf>
      net->n_mib->ifOutDiscards++;
 20230e8:	e0bffd17 	ldw	r2,-12(fp)
 20230ec:	10802717 	ldw	r2,156(r2)
 20230f0:	10c01217 	ldw	r3,72(r2)
 20230f4:	18c00044 	addi	r3,r3,1
 20230f8:	10c01215 	stw	r3,72(r2)
      tse_ptr->sem = 0;
 20230fc:	e0be6e17 	ldw	r2,-1608(fp)
 2023100:	10000c15 	stw	zero,48(r2)
 2023104:	e0be7017 	ldw	r2,-1600(fp)
 2023108:	e0be7515 	stw	r2,-1580(fp)
 202310c:	e0be7517 	ldw	r2,-1580(fp)
 2023110:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SEND_DROPPED;   /* ENP_RESOURCE and SEND_DROPPED have the same value! */
 2023114:	00bffa84 	movi	r2,-22
 2023118:	00001406 	br	202316c <tse_mac_raw_send+0x2e4>
   }
   else   /* = 0, success */
   {
      net->n_mib->ifOutOctets += data_bytes;
 202311c:	e0bffd17 	ldw	r2,-12(fp)
 2023120:	10802717 	ldw	r2,156(r2)
 2023124:	e0fffd17 	ldw	r3,-12(fp)
 2023128:	18c02717 	ldw	r3,156(r3)
 202312c:	19000f17 	ldw	r4,60(r3)
 2023130:	e0ffff17 	ldw	r3,-4(fp)
 2023134:	20c7883a 	add	r3,r4,r3
 2023138:	10c00f15 	stw	r3,60(r2)
      /* we dont know whether it was unicast or not, we count both in <ifOutUcastPkts> */
      net->n_mib->ifOutUcastPkts++;
 202313c:	e0bffd17 	ldw	r2,-12(fp)
 2023140:	10802717 	ldw	r2,156(r2)
 2023144:	10c01017 	ldw	r3,64(r2)
 2023148:	18c00044 	addi	r3,r3,1
 202314c:	10c01015 	stw	r3,64(r2)
      tse_ptr->sem = 0;
 2023150:	e0be6e17 	ldw	r2,-1608(fp)
 2023154:	10000c15 	stw	zero,48(r2)
 2023158:	e0be7017 	ldw	r2,-1600(fp)
 202315c:	e0be7615 	stw	r2,-1576(fp)
 2023160:	e0be7617 	ldw	r2,-1576(fp)
 2023164:	1001703a 	wrctl	status,r2

      OS_EXIT_CRITICAL();
      return SUCCESS;  /*success */
 2023168:	0005883a 	mov	r2,zero
   }
}
 202316c:	e037883a 	mov	sp,fp
 2023170:	dfc00117 	ldw	ra,4(sp)
 2023174:	df000017 	ldw	fp,0(sp)
 2023178:	dec00204 	addi	sp,sp,8
 202317c:	f800283a 	ret

02023180 <tse_sgdmaRx_isr>:
 * @API TYPE - callback
 * @param  context  - context of the TSE MAC instance
 * @param  intnum - temporary storage
 */
void tse_sgdmaRx_isr(void * context)
{
 2023180:	defffa04 	addi	sp,sp,-24
 2023184:	dfc00515 	stw	ra,20(sp)
 2023188:	df000415 	stw	fp,16(sp)
 202318c:	df000404 	addi	fp,sp,16
 2023190:	e13fff15 	stw	r4,-4(fp)
  ins_tse_info* tse_ptr = (ins_tse_info *) context; 
 2023194:	e0bfff17 	ldw	r2,-4(fp)
 2023198:	e0bffc15 	stw	r2,-16(fp)
  alt_u8 sgdma_status;
  
  /* Capture whether there are existing packets on stack rcv queue */
  int initial_rcvdq_len = rcvdq.q_len;
 202319c:	00809934 	movhi	r2,612
 20231a0:	10b4fc04 	addi	r2,r2,-11280
 20231a4:	10800217 	ldw	r2,8(r2)
 20231a8:	e0bffd15 	stw	r2,-12(fp)
   * IO read to peripheral that generated the IRQ is done after IO write
   * to negate the interrupt request. This ensures at the IO write reaches 
   * the peripheral (through any high-latency hardware in the system)
   * before the ISR exits.
   */   
  sgdma_status = IORD_ALTERA_AVALON_SGDMA_STATUS(tse_ptr->mi.rx_sgdma->base);
 20231ac:	e0bffc17 	ldw	r2,-16(fp)
 20231b0:	10800317 	ldw	r2,12(r2)
 20231b4:	10800317 	ldw	r2,12(r2)
 20231b8:	10800037 	ldwio	r2,0(r2)
 20231bc:	e0bffe05 	stb	r2,-8(fp)
  
  /* Why are we here; should we be? */
  if(sgdma_status & (ALTERA_AVALON_SGDMA_STATUS_CHAIN_COMPLETED_MSK | 
 20231c0:	e0bffe03 	ldbu	r2,-8(fp)
 20231c4:	1080030c 	andi	r2,r2,12
 20231c8:	10001426 	beq	r2,zero,202321c <tse_sgdmaRx_isr+0x9c>
                     ALTERA_AVALON_SGDMA_STATUS_DESC_COMPLETED_MSK) ) {
    /* Handle received packet(s) */
    tse_mac_rcv(tse_ptr); 
 20231cc:	e13ffc17 	ldw	r4,-16(fp)
 20231d0:	20233e00 	call	20233e0 <tse_mac_rcv>
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
      tse_ptr->mi.rx_sgdma, 
 20231d4:	e0bffc17 	ldw	r2,-16(fp)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 20231d8:	10c00317 	ldw	r3,12(r2)
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
 20231dc:	e0bffc17 	ldw	r2,-16(fp)
 20231e0:	10800f17 	ldw	r2,60(r2)
        tse_ptr->mi.rx_sgdma, 
        &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
    }
#else
    /* Re-start SGDMA (always, if we have a single descriptor) */
    alt_avalon_sgdma_do_async_transfer(
 20231e4:	10801004 	addi	r2,r2,64
 20231e8:	1809883a 	mov	r4,r3
 20231ec:	100b883a 	mov	r5,r2
 20231f0:	20200380 	call	2020038 <alt_avalon_sgdma_do_async_transfer>
      tse_ptr->mi.rx_sgdma, 
      &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST]);
#endif
  
    /* Wake up Niche stack if there are new packets are on queue */
    if ((rcvdq.q_len) > initial_rcvdq_len) {
 20231f4:	00809934 	movhi	r2,612
 20231f8:	10b4fc04 	addi	r2,r2,-11280
 20231fc:	10800217 	ldw	r2,8(r2)
 2023200:	e0fffd17 	ldw	r3,-12(fp)
 2023204:	1880050e 	bge	r3,r2,202321c <tse_sgdmaRx_isr+0x9c>
      SignalPktDemux();
 2023208:	00808174 	movhi	r2,517
 202320c:	1090cc04 	addi	r2,r2,17200
 2023210:	10800017 	ldw	r2,0(r2)
 2023214:	1009883a 	mov	r4,r2
 2023218:	201c3f80 	call	201c3f8 <OSSemPost>
    }  
  } /* if (valid SGDMA interrupt) */
}
 202321c:	e037883a 	mov	sp,fp
 2023220:	dfc00117 	ldw	ra,4(sp)
 2023224:	df000017 	ldw	fp,0(sp)
 2023228:	dec00204 	addi	sp,sp,8
 202322c:	f800283a 	ret

02023230 <tse_sgdma_read_init>:
 * 
 * @API TYPE - Internal
 * @return SUCCESS on success 
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
 2023230:	defffa04 	addi	sp,sp,-24
 2023234:	dfc00515 	stw	ra,20(sp)
 2023238:	df000415 	stw	fp,16(sp)
 202323c:	dc000315 	stw	r16,12(sp)
 2023240:	df000304 	addi	fp,sp,12
 2023244:	e13fff15 	stw	r4,-4(fp)
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 2023248:	e0bfff17 	ldw	r2,-4(fp)
 202324c:	10000e15 	stw	zero,56(r2)
 2023250:	00004506 	br	2023368 <tse_sgdma_read_init+0x138>
  { 
    tse_ptr->pkt_array[tse_ptr->chain_loop] = pk_alloc(ALTERA_TSE_PKT_INIT_LEN+4);
 2023254:	e0bfff17 	ldw	r2,-4(fp)
 2023258:	14000e17 	ldw	r16,56(r2)
 202325c:	01017f04 	movi	r4,1532
 2023260:	2027cec0 	call	2027cec <pk_alloc>
 2023264:	1007883a 	mov	r3,r2
 2023268:	e13fff17 	ldw	r4,-4(fp)
 202326c:	80800444 	addi	r2,r16,17
 2023270:	1085883a 	add	r2,r2,r2
 2023274:	1085883a 	add	r2,r2,r2
 2023278:	2085883a 	add	r2,r4,r2
 202327c:	10c00015 	stw	r3,0(r2)
    
    if (!tse_ptr->pkt_array[tse_ptr->chain_loop])   /* couldn't get a free buffer for rx */
 2023280:	e0bfff17 	ldw	r2,-4(fp)
 2023284:	10800e17 	ldw	r2,56(r2)
 2023288:	e0ffff17 	ldw	r3,-4(fp)
 202328c:	10800444 	addi	r2,r2,17
 2023290:	1085883a 	add	r2,r2,r2
 2023294:	1085883a 	add	r2,r2,r2
 2023298:	1885883a 	add	r2,r3,r2
 202329c:	10800017 	ldw	r2,0(r2)
 20232a0:	10000b1e 	bne	r2,zero,20232d0 <tse_sgdma_read_init+0xa0>
    {
      dprintf("[tse_sgdma_read_init] Fatal error: No free packet buffers for RX\n");
 20232a4:	01008174 	movhi	r4,517
 20232a8:	21396704 	addi	r4,r4,-6756
 20232ac:	2006cb40 	call	2006cb4 <puts>
      tse_ptr->netp->n_mib->ifInDiscards++;
 20232b0:	e0bfff17 	ldw	r2,-4(fp)
 20232b4:	10800817 	ldw	r2,32(r2)
 20232b8:	10802717 	ldw	r2,156(r2)
 20232bc:	10c00c17 	ldw	r3,48(r2)
 20232c0:	18c00044 	addi	r3,r3,1
 20232c4:	10c00c15 	stw	r3,48(r2)
      
      return ENP_NOBUFFER;
 20232c8:	00bffac4 	movi	r2,-21
 20232cc:	00003e06 	br	20233c8 <tse_sgdma_read_init+0x198>
    }
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 20232d0:	e0bfff17 	ldw	r2,-4(fp)
 20232d4:	10800e17 	ldw	r2,56(r2)
 20232d8:	e0ffff17 	ldw	r3,-4(fp)
 20232dc:	10800444 	addi	r2,r2,17
 20232e0:	1085883a 	add	r2,r2,r2
 20232e4:	1085883a 	add	r2,r2,r2
 20232e8:	1885883a 	add	r2,r3,r2
 20232ec:	10800017 	ldw	r2,0(r2)
 20232f0:	10800117 	ldw	r2,4(r2)
 20232f4:	1009883a 	mov	r4,r2
 20232f8:	01400104 	movi	r5,4
 20232fc:	20378dc0 	call	20378dc <alt_remap_cached>
 2023300:	e0bffe15 	stw	r2,-8(fp)

    alt_avalon_sgdma_construct_stream_to_mem_desc(
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
 2023304:	e0bfff17 	ldw	r2,-4(fp)
 2023308:	10c00f17 	ldw	r3,60(r2)
 202330c:	e0bfff17 	ldw	r2,-4(fp)
 2023310:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 2023314:	10800084 	addi	r2,r2,2
 2023318:	1004917a 	slli	r2,r2,5
 202331c:	1887883a 	add	r3,r3,r2
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST],  // descriptor I want to work with
            (alt_sgdma_descriptor *) &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_SECOND_RX_SGDMA_DESC_OFST], // pointer to "next"
 2023320:	e0bfff17 	ldw	r2,-4(fp)
 2023324:	11000f17 	ldw	r4,60(r2)
 2023328:	e0bfff17 	ldw	r2,-4(fp)
 202332c:	10800e17 	ldw	r2,56(r2)
    
    // ensure bit-31 of tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff is clear before passing
    // to SGDMA Driver
    uncached_packet_payload = (alt_u32 *)alt_remap_cached ((volatile void*) tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);

    alt_avalon_sgdma_construct_stream_to_mem_desc(
 2023330:	108000c4 	addi	r2,r2,3
 2023334:	1004917a 	slli	r2,r2,5
 2023338:	2085883a 	add	r2,r4,r2
 202333c:	d8000015 	stw	zero,0(sp)
 2023340:	1809883a 	mov	r4,r3
 2023344:	100b883a 	mov	r5,r2
 2023348:	e1bffe17 	ldw	r6,-8(fp)
 202334c:	000f883a 	mov	r7,zero
 2023350:	202035c0 	call	202035c <alt_avalon_sgdma_construct_stream_to_mem_desc>
 */
int tse_sgdma_read_init(ins_tse_info* tse_ptr)
{     
  alt_u32 *uncached_packet_payload;
  
  for(tse_ptr->chain_loop = 0; tse_ptr->chain_loop < ALTERA_TSE_SGDMA_RX_DESC_CHAIN_SIZE; tse_ptr->chain_loop++)
 2023354:	e0bfff17 	ldw	r2,-4(fp)
 2023358:	10800e17 	ldw	r2,56(r2)
 202335c:	10c00044 	addi	r3,r2,1
 2023360:	e0bfff17 	ldw	r2,-4(fp)
 2023364:	10c00e15 	stw	r3,56(r2)
 2023368:	e0bfff17 	ldw	r2,-4(fp)
 202336c:	10800e17 	ldw	r2,56(r2)
 2023370:	00bfb80e 	bge	zero,r2,2023254 <tse_sgdma_read_init+0x24>
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
    tse_ptr->chain_loop);
 2023374:	e0bfff17 	ldw	r2,-4(fp)
            0,                          // read until EOP
            0);                         // don't write to constant address

  } // for

  dprintf("[tse_sgdma_read_init] RX descriptor chain desc (%d depth) created\n", 
 2023378:	10800e17 	ldw	r2,56(r2)
 202337c:	01008174 	movhi	r4,517
 2023380:	21397804 	addi	r4,r4,-6688
 2023384:	100b883a 	mov	r5,r2
 2023388:	2006a240 	call	2006a24 <printf>
    tse_ptr->chain_loop);
   
  tse_ptr->chain_loop = 0;
 202338c:	e0bfff17 	ldw	r2,-4(fp)
 2023390:	10000e15 	stw	zero,56(r2)
  tse_ptr->currdescriptor_ptr =  &tse_ptr->desc[ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 2023394:	e0bfff17 	ldw	r2,-4(fp)
 2023398:	10800f17 	ldw	r2,60(r2)
 202339c:	10c01004 	addi	r3,r2,64
 20233a0:	e0bfff17 	ldw	r2,-4(fp)
 20233a4:	10c01015 	stw	r3,64(r2)

  tse_mac_aRxRead( &tse_ptr->mi, tse_ptr->currdescriptor_ptr);
 20233a8:	e0bfff17 	ldw	r2,-4(fp)
 20233ac:	10c00104 	addi	r3,r2,4
 20233b0:	e0bfff17 	ldw	r2,-4(fp)
 20233b4:	10801017 	ldw	r2,64(r2)
 20233b8:	1809883a 	mov	r4,r3
 20233bc:	100b883a 	mov	r5,r2
 20233c0:	20383500 	call	2038350 <tse_mac_aRxRead>
  
  return SUCCESS;
 20233c4:	0005883a 	mov	r2,zero
}
 20233c8:	e037883a 	mov	sp,fp
 20233cc:	dfc00217 	ldw	ra,8(sp)
 20233d0:	df000117 	ldw	fp,4(sp)
 20233d4:	dc000017 	ldw	r16,0(sp)
 20233d8:	dec00304 	addi	sp,sp,12
 20233dc:	f800283a 	ret

020233e0 <tse_mac_rcv>:
 * @API TYPE        - callback internal function
 * @return SUCCESS on success
 */

ALT_INLINE void tse_mac_rcv(ins_tse_info* tse_ptr)
{     
 20233e0:	defff704 	addi	sp,sp,-36
 20233e4:	dfc00815 	stw	ra,32(sp)
 20233e8:	df000715 	stw	fp,28(sp)
 20233ec:	df000704 	addi	fp,sp,28
 20233f0:	e13fff15 	stw	r4,-4(fp)
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
 20233f4:	e0bfff17 	ldw	r2,-4(fp)
 20233f8:	10c00f17 	ldw	r3,60(r2)
 20233fc:	e0bfff17 	ldw	r2,-4(fp)
 2023400:	10800e17 	ldw	r2,56(r2)
 2023404:	10800084 	addi	r2,r2,2
 2023408:	1004917a 	slli	r2,r2,5
 202340c:	1887883a 	add	r3,r3,r2
  PACKET replacement_pkt;
  PACKET rx_packet;
  alt_u32 *uncached_packet_payload;
  alt_u8 desc_status;

  tse_ptr->currdescriptor_ptr = 
 2023410:	e0bfff17 	ldw	r2,-4(fp)
 2023414:	10c01015 	stw	r3,64(r2)
    &tse_ptr->desc[tse_ptr->chain_loop+ALTERA_TSE_FIRST_RX_SGDMA_DESC_OFST];
  
  /* Grab status bits from descriptor under test. Bypass cache */
  desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
 2023418:	e0bfff17 	ldw	r2,-4(fp)
 202341c:	10801017 	ldw	r2,64(r2)
 2023420:	10800704 	addi	r2,r2,28
 2023424:	10800037 	ldwio	r2,0(r2)
 2023428:	1005d43a 	srai	r2,r2,16
 202342c:	e0bff905 	stb	r2,-28(fp)
  while ( desc_status & 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_TERMINATED_BY_EOP_MSK )
#endif
{      
    /* Correct frame length to actual (this is different from TX side) */
    pklen = IORD_16DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0) - 2;
 2023430:	e0bfff17 	ldw	r2,-4(fp)
 2023434:	10801017 	ldw	r2,64(r2)
 2023438:	10800704 	addi	r2,r2,28
 202343c:	1080002b 	ldhuio	r2,0(r2)
 2023440:	10bfffcc 	andi	r2,r2,65535
 2023444:	10bfff84 	addi	r2,r2,-2
 2023448:	e0bffa15 	stw	r2,-24(fp)
    tse_ptr->netp->n_mib->ifInOctets += (u_long)pklen;
 202344c:	e0bfff17 	ldw	r2,-4(fp)
 2023450:	10800817 	ldw	r2,32(r2)
 2023454:	10802717 	ldw	r2,156(r2)
 2023458:	e0ffff17 	ldw	r3,-4(fp)
 202345c:	18c00817 	ldw	r3,32(r3)
 2023460:	18c02717 	ldw	r3,156(r3)
 2023464:	19000917 	ldw	r4,36(r3)
 2023468:	e0fffa17 	ldw	r3,-24(fp)
 202346c:	20c7883a 	add	r3,r4,r3
 2023470:	10c00915 	stw	r3,36(r2)
  
    rx_packet = tse_ptr->pkt_array[tse_ptr->chain_loop];   
 2023474:	e0bfff17 	ldw	r2,-4(fp)
 2023478:	10800e17 	ldw	r2,56(r2)
 202347c:	e0ffff17 	ldw	r3,-4(fp)
 2023480:	10800444 	addi	r2,r2,17
 2023484:	1085883a 	add	r2,r2,r2
 2023488:	1085883a 	add	r2,r2,r2
 202348c:	1885883a 	add	r2,r3,r2
 2023490:	10800017 	ldw	r2,0(r2)
 2023494:	e0bffb15 	stw	r2,-20(fp)
    
    rx_packet->nb_prot = rx_packet->nb_buff + ETHHDR_SIZE;
 2023498:	e0bffb17 	ldw	r2,-20(fp)
 202349c:	10800117 	ldw	r2,4(r2)
 20234a0:	10c00404 	addi	r3,r2,16
 20234a4:	e0bffb17 	ldw	r2,-20(fp)
 20234a8:	10c00315 	stw	r3,12(r2)
    rx_packet->nb_plen = pklen - 14;
 20234ac:	e0bffa17 	ldw	r2,-24(fp)
 20234b0:	10bffc84 	addi	r2,r2,-14
 20234b4:	1007883a 	mov	r3,r2
 20234b8:	e0bffb17 	ldw	r2,-20(fp)
 20234bc:	10c00415 	stw	r3,16(r2)
    rx_packet->nb_tstamp = cticks;
 20234c0:	00808174 	movhi	r2,517
 20234c4:	1090c904 	addi	r2,r2,17188
 20234c8:	10800017 	ldw	r2,0(r2)
 20234cc:	1007883a 	mov	r3,r2
 20234d0:	e0bffb17 	ldw	r2,-20(fp)
 20234d4:	10c00515 	stw	r3,20(r2)
    rx_packet->net = tse_ptr->netp;
 20234d8:	e0bfff17 	ldw	r2,-4(fp)
 20234dc:	10c00817 	ldw	r3,32(r2)
 20234e0:	e0bffb17 	ldw	r2,-20(fp)
 20234e4:	10c00615 	stw	r3,24(r2)
    
    // set packet type for demux routine
    eth = (struct ethhdr *)(rx_packet->nb_buff + ETHHDR_BIAS);
 20234e8:	e0bffb17 	ldw	r2,-20(fp)
 20234ec:	10800117 	ldw	r2,4(r2)
 20234f0:	10800084 	addi	r2,r2,2
 20234f4:	e0bffc15 	stw	r2,-16(fp)
    rx_packet->type = eth->e_type;
 20234f8:	e0bffc17 	ldw	r2,-16(fp)
 20234fc:	10c0030b 	ldhu	r3,12(r2)
 2023500:	e0bffb17 	ldw	r2,-20(fp)
 2023504:	10c0080d 	sth	r3,32(r2)
    
    if( (desc_status & 
 2023508:	e0bff903 	ldbu	r2,-28(fp)
 202350c:	10801fcc 	andi	r2,r2,127
 2023510:	1000251e 	bne	r2,zero,20235a8 <tse_mac_rcv+0x1c8>
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_SYNC_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_UEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MEOP_MSK | 
           ALTERA_AVALON_SGDMA_DESCRIPTOR_STATUS_E_MSOP_MSK ) ) == 0)
    {
      replacement_pkt = pk_alloc(ALTERA_TSE_PKT_INIT_LEN + 4);
 2023514:	01017f04 	movi	r4,1532
 2023518:	2027cec0 	call	2027cec <pk_alloc>
 202351c:	e0bffd15 	stw	r2,-12(fp)
      if (!replacement_pkt) { /* couldn't get a free buffer for rx */
 2023520:	e0bffd17 	ldw	r2,-12(fp)
 2023524:	10000a1e 	bne	r2,zero,2023550 <tse_mac_rcv+0x170>
        dprintf("No free buffers for rx\n");
 2023528:	01008174 	movhi	r4,517
 202352c:	21398904 	addi	r4,r4,-6620
 2023530:	2006cb40 	call	2006cb4 <puts>
        tse_ptr->netp->n_mib->ifInDiscards++;
 2023534:	e0bfff17 	ldw	r2,-4(fp)
 2023538:	10800817 	ldw	r2,32(r2)
 202353c:	10802717 	ldw	r2,156(r2)
 2023540:	10c00c17 	ldw	r3,48(r2)
 2023544:	18c00044 	addi	r3,r3,1
 2023548:	10c00c15 	stw	r3,48(r2)
 202354c:	00001906 	br	20235b4 <tse_mac_rcv+0x1d4>
      }
      else {
        putq(&rcvdq, tse_ptr->pkt_array[tse_ptr->chain_loop]);
 2023550:	e0bfff17 	ldw	r2,-4(fp)
 2023554:	10800e17 	ldw	r2,56(r2)
 2023558:	e0ffff17 	ldw	r3,-4(fp)
 202355c:	10800444 	addi	r2,r2,17
 2023560:	1085883a 	add	r2,r2,r2
 2023564:	1085883a 	add	r2,r2,r2
 2023568:	1885883a 	add	r2,r3,r2
 202356c:	10800017 	ldw	r2,0(r2)
 2023570:	01009934 	movhi	r4,612
 2023574:	2134fc04 	addi	r4,r4,-11280
 2023578:	100b883a 	mov	r5,r2
 202357c:	20282880 	call	2028288 <putq>
        tse_ptr->pkt_array[tse_ptr->chain_loop] = replacement_pkt;
 2023580:	e0bfff17 	ldw	r2,-4(fp)
 2023584:	10800e17 	ldw	r2,56(r2)
 2023588:	e0ffff17 	ldw	r3,-4(fp)
 202358c:	10800444 	addi	r2,r2,17
 2023590:	1085883a 	add	r2,r2,r2
 2023594:	1085883a 	add	r2,r2,r2
 2023598:	1885883a 	add	r2,r3,r2
 202359c:	e0fffd17 	ldw	r3,-12(fp)
 20235a0:	10c00015 	stw	r3,0(r2)
 20235a4:	00000306 	br	20235b4 <tse_mac_rcv+0x1d4>
      }
    } /* if(descriptor had no errors) */ 
    else {
      dprintf("RX descriptor reported error. packet dropped\n");
 20235a8:	01008174 	movhi	r4,517
 20235ac:	21398f04 	addi	r4,r4,-6596
 20235b0:	2006cb40 	call	2006cb4 <puts>
    }     
             
    uncached_packet_payload = (alt_u32 *)alt_remap_cached(tse_ptr->pkt_array[tse_ptr->chain_loop]->nb_buff, 4);
 20235b4:	e0bfff17 	ldw	r2,-4(fp)
 20235b8:	10800e17 	ldw	r2,56(r2)
 20235bc:	e0ffff17 	ldw	r3,-4(fp)
 20235c0:	10800444 	addi	r2,r2,17
 20235c4:	1085883a 	add	r2,r2,r2
 20235c8:	1085883a 	add	r2,r2,r2
 20235cc:	1885883a 	add	r2,r3,r2
 20235d0:	10800017 	ldw	r2,0(r2)
 20235d4:	10800117 	ldw	r2,4(r2)
 20235d8:	1009883a 	mov	r4,r2
 20235dc:	01400104 	movi	r5,4
 20235e0:	20378dc0 	call	20378dc <alt_remap_cached>
 20235e4:	e0bffe15 	stw	r2,-8(fp)
    /* 
     * Re-cycle previously constructed SGDMA buffer directly rather
     * than calling the SGDMA utility routines. This saves some call/return
     * overhead and only does cache-bypass writes of what we need
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->write_addr, 0, 
 20235e8:	e0bfff17 	ldw	r2,-4(fp)
 20235ec:	10801017 	ldw	r2,64(r2)
 20235f0:	10800204 	addi	r2,r2,8
 20235f4:	e0fffe17 	ldw	r3,-8(fp)
 20235f8:	10c00035 	stwio	r3,0(r2)
     *   |31...24|23..16|15.....................0|
     *   |control|status|actual_bytes_transferred|
     * 
     * Set relevant control bits and ensure the rest are cleared.
     */
    IOWR_32DIRECT(&tse_ptr->currdescriptor_ptr->actual_bytes_transferred, 0, 
 20235fc:	e0bfff17 	ldw	r2,-4(fp)
 2023600:	10801017 	ldw	r2,64(r2)
 2023604:	10800704 	addi	r2,r2,28
 2023608:	00e04034 	movhi	r3,33024
 202360c:	10c00035 	stwio	r3,0(r2)
    
    /* Grab next descriptor status */
    desc_status = IORD_ALTERA_TSE_SGDMA_DESC_STATUS(tse_ptr->currdescriptor_ptr);
#endif
  } /* while (descriptor terminated by EOP) */
} 
 2023610:	e037883a 	mov	sp,fp
 2023614:	dfc00117 	ldw	ra,4(sp)
 2023618:	df000017 	ldw	fp,0(sp)
 202361c:	dec00204 	addi	sp,sp,8
 2023620:	f800283a 	ret

02023624 <tse_mac_stats>:

int tse_mac_stats(void * pio, int iface)
{
 2023624:	defffc04 	addi	sp,sp,-16
 2023628:	dfc00315 	stw	ra,12(sp)
 202362c:	df000215 	stw	fp,8(sp)
 2023630:	df000204 	addi	fp,sp,8
 2023634:	e13ffe15 	stw	r4,-8(fp)
 2023638:	e17fff15 	stw	r5,-4(fp)
   ns_printf(pio, "tse_mac_stats(), stats will be added later!\n");
 202363c:	e13ffe17 	ldw	r4,-8(fp)
 2023640:	01408174 	movhi	r5,517
 2023644:	29799b04 	addi	r5,r5,-6548
 2023648:	2026e100 	call	2026e10 <ns_printf>
   return SUCCESS;
 202364c:	0005883a 	mov	r2,zero
}
 2023650:	e037883a 	mov	sp,fp
 2023654:	dfc00117 	ldw	ra,4(sp)
 2023658:	df000017 	ldw	fp,0(sp)
 202365c:	dec00204 	addi	sp,sp,8
 2023660:	f800283a 	ret

02023664 <tse_mac_close>:
 * @API TYPE - Public
 * @param  iface    index of the NET interface associated with the TSE MAC.
 * @return SUCCESS
 */
int tse_mac_close(int iface)
{
 2023664:	defffc04 	addi	sp,sp,-16
 2023668:	dfc00315 	stw	ra,12(sp)
 202366c:	df000215 	stw	fp,8(sp)
 2023670:	df000204 	addi	fp,sp,8
 2023674:	e13fff15 	stw	r4,-4(fp)
  int state;
   
  /* status = down */
  nets[iface]->n_mib->ifAdminStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;    
 2023678:	00c09934 	movhi	r3,612
 202367c:	18f5c104 	addi	r3,r3,-10492
 2023680:	e0bfff17 	ldw	r2,-4(fp)
 2023684:	1085883a 	add	r2,r2,r2
 2023688:	1085883a 	add	r2,r2,r2
 202368c:	1885883a 	add	r2,r3,r2
 2023690:	10800017 	ldw	r2,0(r2)
 2023694:	10802717 	ldw	r2,156(r2)
 2023698:	00c00084 	movi	r3,2
 202369c:	10c00615 	stw	r3,24(r2)

  /* disable the interrupt in the OS*/
  alt_avalon_sgdma_register_callback(tse[iface].mi.rx_sgdma, 0, 0, 0);
 20236a0:	00c09934 	movhi	r3,612
 20236a4:	18f4b004 	addi	r3,r3,-11584
 20236a8:	e0bfff17 	ldw	r2,-4(fp)
 20236ac:	10801324 	muli	r2,r2,76
 20236b0:	1885883a 	add	r2,r3,r2
 20236b4:	10800304 	addi	r2,r2,12
 20236b8:	10800017 	ldw	r2,0(r2)
 20236bc:	1009883a 	mov	r4,r2
 20236c0:	000b883a 	mov	r5,zero
 20236c4:	000d883a 	mov	r6,zero
 20236c8:	000f883a 	mov	r7,zero
 20236cc:	20205300 	call	2020530 <alt_avalon_sgdma_register_callback>
   
  /* Disable Receive path on the device*/
  state = IORD_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base);
 20236d0:	00c09934 	movhi	r3,612
 20236d4:	18f4b004 	addi	r3,r3,-11584
 20236d8:	e0bfff17 	ldw	r2,-4(fp)
 20236dc:	10801324 	muli	r2,r2,76
 20236e0:	1885883a 	add	r2,r3,r2
 20236e4:	10800104 	addi	r2,r2,4
 20236e8:	10800017 	ldw	r2,0(r2)
 20236ec:	10800204 	addi	r2,r2,8
 20236f0:	10800037 	ldwio	r2,0(r2)
 20236f4:	e0bffe15 	stw	r2,-8(fp)
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(tse[iface].mi.base,state & ~ALTERA_TSEMAC_CMD_RX_ENA_MSK); 
 20236f8:	00c09934 	movhi	r3,612
 20236fc:	18f4b004 	addi	r3,r3,-11584
 2023700:	e0bfff17 	ldw	r2,-4(fp)
 2023704:	10801324 	muli	r2,r2,76
 2023708:	1885883a 	add	r2,r3,r2
 202370c:	10800104 	addi	r2,r2,4
 2023710:	10800017 	ldw	r2,0(r2)
 2023714:	10800204 	addi	r2,r2,8
 2023718:	e13ffe17 	ldw	r4,-8(fp)
 202371c:	00ffff44 	movi	r3,-3
 2023720:	20c6703a 	and	r3,r4,r3
 2023724:	10c00035 	stwio	r3,0(r2)
  
  /* status = down */                                     
  nets[iface]->n_mib->ifOperStatus = ALTERA_TSE_ADMIN_STATUS_DOWN;     
 2023728:	00c09934 	movhi	r3,612
 202372c:	18f5c104 	addi	r3,r3,-10492
 2023730:	e0bfff17 	ldw	r2,-4(fp)
 2023734:	1085883a 	add	r2,r2,r2
 2023738:	1085883a 	add	r2,r2,r2
 202373c:	1885883a 	add	r2,r3,r2
 2023740:	10800017 	ldw	r2,0(r2)
 2023744:	10802717 	ldw	r2,156(r2)
 2023748:	00c00084 	movi	r3,2
 202374c:	10c00715 	stw	r3,28(r2)

  return SUCCESS;
 2023750:	0005883a 	mov	r2,zero
}
 2023754:	e037883a 	mov	sp,fp
 2023758:	dfc00117 	ldw	ra,4(sp)
 202375c:	df000017 	ldw	fp,0(sp)
 2023760:	dec00204 	addi	sp,sp,8
 2023764:	f800283a 	ret

02023768 <close>:
 * (for files and device drivers) or the InterNiche soclose() function for
 * sockets.
 */
 
int close (int fd)
{
 2023768:	defffd04 	addi	sp,sp,-12
 202376c:	dfc00215 	stw	ra,8(sp)
 2023770:	df000115 	stw	fp,4(sp)
 2023774:	df000104 	addi	fp,sp,4
 2023778:	e13fff15 	stw	r4,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_close (fd) : t_socketclose ((long) fd);
 202377c:	e0bfff17 	ldw	r2,-4(fp)
 2023780:	10800808 	cmpgei	r2,r2,32
 2023784:	1000031e 	bne	r2,zero,2023794 <close+0x2c>
 2023788:	e13fff17 	ldw	r4,-4(fp)
 202378c:	2036ddc0 	call	2036ddc <alt_close>
 2023790:	00000206 	br	202379c <close+0x34>
 2023794:	e13fff17 	ldw	r4,-4(fp)
 2023798:	202c8ac0 	call	202c8ac <t_socketclose>
}
 202379c:	e037883a 	mov	sp,fp
 20237a0:	dfc00117 	ldw	ra,4(sp)
 20237a4:	df000017 	ldw	fp,0(sp)
 20237a8:	dec00204 	addi	sp,sp,8
 20237ac:	f800283a 	ret

020237b0 <iniche_devices_init>:
 * total number of interfaces after initialization.
 */

int iniche_devices_init(
    int                         if_count)
{
 20237b0:	defff504 	addi	sp,sp,-44
 20237b4:	dfc00a15 	stw	ra,40(sp)
 20237b8:	df000915 	stw	fp,36(sp)
 20237bc:	df000904 	addi	fp,sp,36
 20237c0:	e13fff15 	stw	r4,-4(fp)
                                netmask,
                                gw;
    int                         use_dhcp;

    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
 20237c4:	d0a03717 	ldw	r2,-32548(gp)
 20237c8:	e0bff815 	stw	r2,-32(fp)
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));
 20237cc:	d0a03704 	addi	r2,gp,-32548
 20237d0:	e0bff915 	stw	r2,-28(fp)

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 20237d4:	00003706 	br	20238b4 <iniche_devices_init+0x104>
    {
        /* Initialize the InterNiche device data record. */
        p_dev->p_driver_data = p_dev;
 20237d8:	e0bff817 	ldw	r2,-32(fp)
 20237dc:	e0fff817 	ldw	r3,-32(fp)
 20237e0:	10c00415 	stw	r3,16(r2)
        p_dev->if_num = if_count;
 20237e4:	e0bff817 	ldw	r2,-32(fp)
 20237e8:	e0ffff17 	ldw	r3,-4(fp)
 20237ec:	10c00515 	stw	r3,20(r2)
        p_dev->p_net = nets[p_dev->if_num];
 20237f0:	e0bff817 	ldw	r2,-32(fp)
 20237f4:	10800517 	ldw	r2,20(r2)
 20237f8:	00c09934 	movhi	r3,612
 20237fc:	18f5c104 	addi	r3,r3,-10492
 2023800:	1085883a 	add	r2,r2,r2
 2023804:	1085883a 	add	r2,r2,r2
 2023808:	1885883a 	add	r2,r3,r2
 202380c:	10c00017 	ldw	r3,0(r2)
 2023810:	e0bff817 	ldw	r2,-32(fp)
 2023814:	10c00615 	stw	r3,24(r2)

        /* Perform device specific initialization. */
        (*(p_dev->init_func))(p_dev);
 2023818:	e0bff817 	ldw	r2,-32(fp)
 202381c:	10800317 	ldw	r2,12(r2)
 2023820:	e13ff817 	ldw	r4,-32(fp)
 2023824:	103ee83a 	callr	r2

        /* Get the interface IP address. */
        p_net = p_dev->p_net;
 2023828:	e0bff817 	ldw	r2,-32(fp)
 202382c:	10800617 	ldw	r2,24(r2)
 2023830:	e0bffa15 	stw	r2,-24(fp)
                
        if (get_ip_addr(p_dev, &ipaddr, &netmask, &gw, &use_dhcp))
 2023834:	e17ffb04 	addi	r5,fp,-20
 2023838:	e0fffc04 	addi	r3,fp,-16
 202383c:	e0bffd04 	addi	r2,fp,-12
 2023840:	e13ffe04 	addi	r4,fp,-8
 2023844:	d9000015 	stw	r4,0(sp)
 2023848:	e13ff817 	ldw	r4,-32(fp)
 202384c:	180d883a 	mov	r6,r3
 2023850:	100f883a 	mov	r7,r2
 2023854:	20036e80 	call	20036e8 <get_ip_addr>
 2023858:	10001026 	beq	r2,zero,202389c <iniche_devices_init+0xec>
             */
            if (use_dhcp) {
                p_net->n_flags |= NF_DHCPC;
            }
#endif
            p_net->n_ipaddr = ipaddr;
 202385c:	e0fffb17 	ldw	r3,-20(fp)
 2023860:	e0bffa17 	ldw	r2,-24(fp)
 2023864:	10c00a15 	stw	r3,40(r2)
            p_net->snmask = netmask;
 2023868:	e0fffc17 	ldw	r3,-16(fp)
 202386c:	e0bffa17 	ldw	r2,-24(fp)
 2023870:	10c00c15 	stw	r3,48(r2)
            p_net->n_defgw = gw;
 2023874:	e0fffd17 	ldw	r3,-12(fp)
 2023878:	e0bffa17 	ldw	r2,-24(fp)
 202387c:	10c00d15 	stw	r3,52(r2)
#ifdef IP_MULTICAST
	    p_net->n_mcastlist = mcastlist;
 2023880:	e0bffa17 	ldw	r2,-24(fp)
 2023884:	00c08134 	movhi	r3,516
 2023888:	18f56504 	addi	r3,r3,-10860
 202388c:	10c02b15 	stw	r3,172(r2)
#if defined (IGMP_V1) || defined (IGMP_V2)
            p_net->igmp_oper_mode = IGMP_MODE_DEFAULT;
 2023890:	e0bffa17 	ldw	r2,-24(fp)
 2023894:	00c00084 	movi	r3,2
 2023898:	10c02f05 	stb	r3,188(r2)
#endif  /* IGMPv1 or IGMPv2 */
#endif  /* IP_MULTICAST */
        }

        /* Initialize next device. */
        if_count++;
 202389c:	e0bfff17 	ldw	r2,-4(fp)
 20238a0:	10800044 	addi	r2,r2,1
 20238a4:	e0bfff15 	stw	r2,-4(fp)
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
 20238a8:	e0bff817 	ldw	r2,-32(fp)
 20238ac:	10800017 	ldw	r2,0(r2)
 20238b0:	e0bff815 	stw	r2,-32(fp)
    /* Get the InterNiche device list. */
    p_dev = (alt_iniche_dev *) (alt_iniche_dev_list.next);
    p_dev_list_end = (alt_iniche_dev *) (&(alt_iniche_dev_list.next));

    /* Initialize each InterNiche device. */
    while (p_dev != p_dev_list_end)
 20238b4:	e0fff817 	ldw	r3,-32(fp)
 20238b8:	e0bff917 	ldw	r2,-28(fp)
 20238bc:	18bfc61e 	bne	r3,r2,20237d8 <iniche_devices_init+0x28>
        /* Initialize next device. */
        if_count++;
        p_dev = (alt_iniche_dev *) p_dev->llist.next;
    }

    return (if_count);
 20238c0:	e0bfff17 	ldw	r2,-4(fp)
}
 20238c4:	e037883a 	mov	sp,fp
 20238c8:	dfc00117 	ldw	ra,4(sp)
 20238cc:	df000017 	ldw	fp,0(sp)
 20238d0:	dec00204 	addi	sp,sp,8
 20238d4:	f800283a 	ret

020238d8 <read>:
 * (for files and device drivers) or the InterNiche recvfrom() function for
 * sockets.
 */

int read (int fd, void *ptr, size_t len)
{
 20238d8:	defff904 	addi	sp,sp,-28
 20238dc:	dfc00615 	stw	ra,24(sp)
 20238e0:	df000515 	stw	fp,20(sp)
 20238e4:	df000504 	addi	fp,sp,20
 20238e8:	e13ffd15 	stw	r4,-12(fp)
 20238ec:	e17ffe15 	stw	r5,-8(fp)
 20238f0:	e1bfff15 	stw	r6,-4(fp)
  return (fd < ALT_MAX_FD) ? alt_read (fd, ptr, len)
                           : recvfrom(fd, ptr, len, 0, NULL, NULL);
 20238f4:	e0bffd17 	ldw	r2,-12(fp)
 20238f8:	10800808 	cmpgei	r2,r2,32
 20238fc:	1000051e 	bne	r2,zero,2023914 <read+0x3c>
 2023900:	e13ffd17 	ldw	r4,-12(fp)
 2023904:	e17ffe17 	ldw	r5,-8(fp)
 2023908:	e1bfff17 	ldw	r6,-4(fp)
 202390c:	20377ec0 	call	20377ec <alt_read>
 2023910:	00000806 	br	2023934 <read+0x5c>
 2023914:	e0bfff17 	ldw	r2,-4(fp)
 2023918:	d8000015 	stw	zero,0(sp)
 202391c:	d8000115 	stw	zero,4(sp)
 2023920:	e13ffd17 	ldw	r4,-12(fp)
 2023924:	e17ffe17 	ldw	r5,-8(fp)
 2023928:	100d883a 	mov	r6,r2
 202392c:	000f883a 	mov	r7,zero
 2023930:	20263800 	call	2026380 <bsd_recvfrom>
}
 2023934:	e037883a 	mov	sp,fp
 2023938:	dfc00117 	ldw	ra,4(sp)
 202393c:	df000017 	ldw	fp,0(sp)
 2023940:	dec00204 	addi	sp,sp,8
 2023944:	f800283a 	ret

02023948 <write>:
 * This implementation vectors requests to either the HAL alt_write() function 
 * (for files and device drivers) or the InterNiche send() function for sockets.
 */

int write (int fd, const void *ptr, size_t len)
{
 2023948:	defffb04 	addi	sp,sp,-20
 202394c:	dfc00415 	stw	ra,16(sp)
 2023950:	df000315 	stw	fp,12(sp)
 2023954:	df000304 	addi	fp,sp,12
 2023958:	e13ffd15 	stw	r4,-12(fp)
 202395c:	e17ffe15 	stw	r5,-8(fp)
 2023960:	e1bfff15 	stw	r6,-4(fp)
  if (fd < ALT_MAX_FD)
 2023964:	e0bffd17 	ldw	r2,-12(fp)
 2023968:	10800808 	cmpgei	r2,r2,32
 202396c:	1000051e 	bne	r2,zero,2023984 <write+0x3c>
  {
    return alt_write (fd, ptr, len);
 2023970:	e13ffd17 	ldw	r4,-12(fp)
 2023974:	e17ffe17 	ldw	r5,-8(fp)
 2023978:	e1bfff17 	ldw	r6,-4(fp)
 202397c:	20379f80 	call	20379f8 <alt_write>
 2023980:	00000606 	br	202399c <write+0x54>
  }
  else
  { 
    return send (fd, (void*) ptr, len, 0);
 2023984:	e0bfff17 	ldw	r2,-4(fp)
 2023988:	e13ffd17 	ldw	r4,-12(fp)
 202398c:	e17ffe17 	ldw	r5,-8(fp)
 2023990:	100d883a 	mov	r6,r2
 2023994:	000f883a 	mov	r7,zero
 2023998:	202c5d80 	call	202c5d8 <t_send>
  }  
}
 202399c:	e037883a 	mov	sp,fp
 20239a0:	dfc00117 	ldw	ra,4(sp)
 20239a4:	df000017 	ldw	fp,0(sp)
 20239a8:	dec00204 	addi	sp,sp,8
 20239ac:	f800283a 	ret

020239b0 <Netinit>:
 * a non-zero error code
 */

int
Netinit()
{
 20239b0:	defffc04 	addi	sp,sp,-16
 20239b4:	dfc00315 	stw	ra,12(sp)
 20239b8:	df000215 	stw	fp,8(sp)
 20239bc:	df000204 	addi	fp,sp,8
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 20239c0:	e03ffe15 	stw	zero,-8(fp)
 20239c4:	00004a06 	br	2023af0 <Netinit+0x140>
   {
      /* sanity check on mtu, et.al. We added this because earlier 
       * drivers were sloppy about setting them, but new
       * logic depends on these sizes.
       */
      if (nets[i]->n_mib->ifType == ETHERNET)   /* ethernet? */
 20239c8:	00c09934 	movhi	r3,612
 20239cc:	18f5c104 	addi	r3,r3,-10492
 20239d0:	e0bffe17 	ldw	r2,-8(fp)
 20239d4:	1085883a 	add	r2,r2,r2
 20239d8:	1085883a 	add	r2,r2,r2
 20239dc:	1885883a 	add	r2,r3,r2
 20239e0:	10800017 	ldw	r2,0(r2)
 20239e4:	10802717 	ldw	r2,156(r2)
 20239e8:	10800217 	ldw	r2,8(r2)
 20239ec:	10800198 	cmpnei	r2,r2,6
 20239f0:	1000241e 	bne	r2,zero,2023a84 <Netinit+0xd4>
      {
         if (nets[i]->n_mtu == 0)   /* let device code override */
 20239f4:	00c09934 	movhi	r3,612
 20239f8:	18f5c104 	addi	r3,r3,-10492
 20239fc:	e0bffe17 	ldw	r2,-8(fp)
 2023a00:	1085883a 	add	r2,r2,r2
 2023a04:	1085883a 	add	r2,r2,r2
 2023a08:	1885883a 	add	r2,r3,r2
 2023a0c:	10800017 	ldw	r2,0(r2)
 2023a10:	10800917 	ldw	r2,36(r2)
 2023a14:	1000091e 	bne	r2,zero,2023a3c <Netinit+0x8c>
            nets[i]->n_mtu = 1514;
 2023a18:	00c09934 	movhi	r3,612
 2023a1c:	18f5c104 	addi	r3,r3,-10492
 2023a20:	e0bffe17 	ldw	r2,-8(fp)
 2023a24:	1085883a 	add	r2,r2,r2
 2023a28:	1085883a 	add	r2,r2,r2
 2023a2c:	1885883a 	add	r2,r3,r2
 2023a30:	10800017 	ldw	r2,0(r2)
 2023a34:	00c17a84 	movi	r3,1514
 2023a38:	10c00915 	stw	r3,36(r2)

         if (nets[i]->n_lnh == 0)
 2023a3c:	00c09934 	movhi	r3,612
 2023a40:	18f5c104 	addi	r3,r3,-10492
 2023a44:	e0bffe17 	ldw	r2,-8(fp)
 2023a48:	1085883a 	add	r2,r2,r2
 2023a4c:	1085883a 	add	r2,r2,r2
 2023a50:	1885883a 	add	r2,r3,r2
 2023a54:	10800017 	ldw	r2,0(r2)
 2023a58:	10800817 	ldw	r2,32(r2)
 2023a5c:	1000091e 	bne	r2,zero,2023a84 <Netinit+0xd4>
         {
#ifdef IEEE_802_3
            nets[i]->n_lnh = ETHHDR_SIZE + sizeof(struct snap_hdr);
#else
            nets[i]->n_lnh = ETHHDR_SIZE;
 2023a60:	00c09934 	movhi	r3,612
 2023a64:	18f5c104 	addi	r3,r3,-10492
 2023a68:	e0bffe17 	ldw	r2,-8(fp)
 2023a6c:	1085883a 	add	r2,r2,r2
 2023a70:	1085883a 	add	r2,r2,r2
 2023a74:	1885883a 	add	r2,r3,r2
 2023a78:	10800017 	ldw	r2,0(r2)
 2023a7c:	00c00404 	movi	r3,16
 2023a80:	10c00815 	stw	r3,32(r2)
      {
         continue;
      }
#endif   /* IP_V6 */

      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
 2023a84:	00c09934 	movhi	r3,612
 2023a88:	18f5c104 	addi	r3,r3,-10492
 2023a8c:	e0bffe17 	ldw	r2,-8(fp)
 2023a90:	1085883a 	add	r2,r2,r2
 2023a94:	1085883a 	add	r2,r2,r2
 2023a98:	1885883a 	add	r2,r3,r2
 2023a9c:	10800017 	ldw	r2,0(r2)
 2023aa0:	10800817 	ldw	r2,32(r2)
 2023aa4:	d0e08617 	ldw	r3,-32232(gp)
 2023aa8:	10c0010e 	bge	r2,r3,2023ab0 <Netinit+0x100>
 2023aac:	1805883a 	mov	r2,r3
 2023ab0:	d0a08615 	stw	r2,-32232(gp)
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
 2023ab4:	00c09934 	movhi	r3,612
 2023ab8:	18f5c104 	addi	r3,r3,-10492
 2023abc:	e0bffe17 	ldw	r2,-8(fp)
 2023ac0:	1085883a 	add	r2,r2,r2
 2023ac4:	1085883a 	add	r2,r2,r2
 2023ac8:	1885883a 	add	r2,r3,r2
 2023acc:	10800017 	ldw	r2,0(r2)
 2023ad0:	10800917 	ldw	r2,36(r2)
 2023ad4:	d0e08717 	ldw	r3,-32228(gp)
 2023ad8:	10c0010e 	bge	r2,r3,2023ae0 <Netinit+0x130>
 2023adc:	1805883a 	mov	r2,r3
 2023ae0:	d0a08715 	stw	r2,-32228(gp)
#ifndef MULTI_HOMED
   ifNumber = 1;     /* prevents weird behavior below... */
#endif

   /* set our largest header size and frames size */
   for (i = 0; i < (int)ifNumber; i++)
 2023ae4:	e0bffe17 	ldw	r2,-8(fp)
 2023ae8:	10800044 	addi	r2,r2,1
 2023aec:	e0bffe15 	stw	r2,-8(fp)
 2023af0:	00808174 	movhi	r2,517
 2023af4:	1090b304 	addi	r2,r2,17100
 2023af8:	10800017 	ldw	r2,0(r2)
 2023afc:	e0fffe17 	ldw	r3,-8(fp)
 2023b00:	18bfb116 	blt	r3,r2,20239c8 <Netinit+0x18>
      MaxLnh = max(MaxLnh, nets[i]->n_lnh);
      MaxMtu = max(MaxMtu, nets[i]->n_mtu);
   }

   /* set up the received packet queue */
   rcvdq.q_head = rcvdq.q_tail = NULL;
 2023b04:	00809934 	movhi	r2,612
 2023b08:	10b4fc04 	addi	r2,r2,-11280
 2023b0c:	10000115 	stw	zero,4(r2)
 2023b10:	00809934 	movhi	r2,612
 2023b14:	10b4fc04 	addi	r2,r2,-11280
 2023b18:	10c00117 	ldw	r3,4(r2)
 2023b1c:	00809934 	movhi	r2,612
 2023b20:	10b4fc04 	addi	r2,r2,-11280
 2023b24:	10c00015 	stw	r3,0(r2)
   rcvdq.q_max = rcvdq.q_min = rcvdq.q_len = 0;
 2023b28:	00809934 	movhi	r2,612
 2023b2c:	10b4fc04 	addi	r2,r2,-11280
 2023b30:	10000215 	stw	zero,8(r2)
 2023b34:	00809934 	movhi	r2,612
 2023b38:	10b4fc04 	addi	r2,r2,-11280
 2023b3c:	10c00217 	ldw	r3,8(r2)
 2023b40:	00809934 	movhi	r2,612
 2023b44:	10b4fc04 	addi	r2,r2,-11280
 2023b48:	10c00415 	stw	r3,16(r2)
 2023b4c:	00809934 	movhi	r2,612
 2023b50:	10b4fc04 	addi	r2,r2,-11280
 2023b54:	10c00417 	ldw	r3,16(r2)
 2023b58:	00809934 	movhi	r2,612
 2023b5c:	10b4fc04 	addi	r2,r2,-11280
 2023b60:	10c00315 	stw	r3,12(r2)

   /* initialize freeq */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2023b64:	01000084 	movi	r4,2
 2023b68:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   e = pk_init();
 2023b6c:	2027a580 	call	2027a58 <pk_init>
 2023b70:	e0bfff15 	stw	r2,-4(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2023b74:	01000084 	movi	r4,2
 2023b78:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (e)   /* report error (memory ran out?) */
 2023b7c:	e0bfff17 	ldw	r2,-4(fp)
 2023b80:	10000226 	beq	r2,zero,2023b8c <Netinit+0x1dc>
      return e;
 2023b84:	e0bfff17 	ldw	r2,-4(fp)
 2023b88:	00010006 	br	2023f8c <Netinit+0x5dc>

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */
 2023b8c:	010080b4 	movhi	r4,514
 2023b90:	21103e04 	addi	r4,r4,16632
 2023b94:	2024a740 	call	2024a74 <exit_hook>

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 2023b98:	e03ffe15 	stw	zero,-8(fp)
 2023b9c:	0000f506 	br	2023f74 <Netinit+0x5c4>
   {
      if (nets[i]->n_init != NULL)  /* If iface has init routine... */
 2023ba0:	00c09934 	movhi	r3,612
 2023ba4:	18f5c104 	addi	r3,r3,-10492
 2023ba8:	e0bffe17 	ldw	r2,-8(fp)
 2023bac:	1085883a 	add	r2,r2,r2
 2023bb0:	1085883a 	add	r2,r2,r2
 2023bb4:	1885883a 	add	r2,r3,r2
 2023bb8:	10800017 	ldw	r2,0(r2)
 2023bbc:	10800217 	ldw	r2,8(r2)
 2023bc0:	10009126 	beq	r2,zero,2023e08 <Netinit+0x458>
      {
         if ((e = (*nets[i]->n_init)(i)) != 0)  /* call init routine */
 2023bc4:	00c09934 	movhi	r3,612
 2023bc8:	18f5c104 	addi	r3,r3,-10492
 2023bcc:	e0bffe17 	ldw	r2,-8(fp)
 2023bd0:	1085883a 	add	r2,r2,r2
 2023bd4:	1085883a 	add	r2,r2,r2
 2023bd8:	1885883a 	add	r2,r3,r2
 2023bdc:	10800017 	ldw	r2,0(r2)
 2023be0:	10800217 	ldw	r2,8(r2)
 2023be4:	e13ffe17 	ldw	r4,-8(fp)
 2023be8:	103ee83a 	callr	r2
 2023bec:	e0bfff15 	stw	r2,-4(fp)
 2023bf0:	e0bfff17 	ldw	r2,-4(fp)
 2023bf4:	10001026 	beq	r2,zero,2023c38 <Netinit+0x288>
         {
            dprintf("init error %d on net[%d]\n", e, i);
 2023bf8:	01008174 	movhi	r4,517
 2023bfc:	2139a704 	addi	r4,r4,-6500
 2023c00:	e17fff17 	ldw	r5,-4(fp)
 2023c04:	e1bffe17 	ldw	r6,-8(fp)
 2023c08:	2006a240 	call	2006a24 <printf>
            nets[i]->n_mib->ifOperStatus = NI_DOWN;
 2023c0c:	00c09934 	movhi	r3,612
 2023c10:	18f5c104 	addi	r3,r3,-10492
 2023c14:	e0bffe17 	ldw	r2,-8(fp)
 2023c18:	1085883a 	add	r2,r2,r2
 2023c1c:	1085883a 	add	r2,r2,r2
 2023c20:	1885883a 	add	r2,r3,r2
 2023c24:	10800017 	ldw	r2,0(r2)
 2023c28:	10802717 	ldw	r2,156(r2)
 2023c2c:	00c00084 	movi	r3,2
 2023c30:	10c00715 	stw	r3,28(r2)
            continue;   /* ignore ifaces which fail */
 2023c34:	0000cc06 	br	2023f68 <Netinit+0x5b8>
         }
         /* If interface is ethernet, set bcast flag bit. This
          * should really be done by the init routine, but we handle it
          * here to support MAC drivers which predate the flags field.
          */
         if(nets[i]->n_mib->ifType == ETHERNET)
 2023c38:	00c09934 	movhi	r3,612
 2023c3c:	18f5c104 	addi	r3,r3,-10492
 2023c40:	e0bffe17 	ldw	r2,-8(fp)
 2023c44:	1085883a 	add	r2,r2,r2
 2023c48:	1085883a 	add	r2,r2,r2
 2023c4c:	1885883a 	add	r2,r3,r2
 2023c50:	10800017 	ldw	r2,0(r2)
 2023c54:	10802717 	ldw	r2,156(r2)
 2023c58:	10800217 	ldw	r2,8(r2)
 2023c5c:	10800198 	cmpnei	r2,r2,6
 2023c60:	1000111e 	bne	r2,zero,2023ca8 <Netinit+0x2f8>
            nets[i]->n_flags |= NF_BCAST;
 2023c64:	00c09934 	movhi	r3,612
 2023c68:	18f5c104 	addi	r3,r3,-10492
 2023c6c:	e0bffe17 	ldw	r2,-8(fp)
 2023c70:	1085883a 	add	r2,r2,r2
 2023c74:	1085883a 	add	r2,r2,r2
 2023c78:	1885883a 	add	r2,r3,r2
 2023c7c:	10c00017 	ldw	r3,0(r2)
 2023c80:	01009934 	movhi	r4,612
 2023c84:	2135c104 	addi	r4,r4,-10492
 2023c88:	e0bffe17 	ldw	r2,-8(fp)
 2023c8c:	1085883a 	add	r2,r2,r2
 2023c90:	1085883a 	add	r2,r2,r2
 2023c94:	2085883a 	add	r2,r4,r2
 2023c98:	10800017 	ldw	r2,0(r2)
 2023c9c:	10802a17 	ldw	r2,168(r2)
 2023ca0:	10800054 	ori	r2,r2,1
 2023ca4:	18802a15 	stw	r2,168(r3)

         /* set ifAdminStatus in case init() routine forgot to. IfOperStatus
          * is not nessecarily up at this point, as in the case of a modem which
          * is now in autoanswer mode.
          */
         nets[i]->n_mib->ifAdminStatus = NI_UP;
 2023ca8:	00c09934 	movhi	r3,612
 2023cac:	18f5c104 	addi	r3,r3,-10492
 2023cb0:	e0bffe17 	ldw	r2,-8(fp)
 2023cb4:	1085883a 	add	r2,r2,r2
 2023cb8:	1085883a 	add	r2,r2,r2
 2023cbc:	1885883a 	add	r2,r3,r2
 2023cc0:	10800017 	ldw	r2,0(r2)
 2023cc4:	10802717 	ldw	r2,156(r2)
 2023cc8:	00c00044 	movi	r3,1
 2023ccc:	10c00615 	stw	r3,24(r2)

         /* assign default names to unnamed ifaces */
         if(nets[i]->name[0] == 0)     /* no name set by prep or init */
 2023cd0:	00c09934 	movhi	r3,612
 2023cd4:	18f5c104 	addi	r3,r3,-10492
 2023cd8:	e0bffe17 	ldw	r2,-8(fp)
 2023cdc:	1085883a 	add	r2,r2,r2
 2023ce0:	1085883a 	add	r2,r2,r2
 2023ce4:	1885883a 	add	r2,r3,r2
 2023ce8:	10800017 	ldw	r2,0(r2)
 2023cec:	10800103 	ldbu	r2,4(r2)
 2023cf0:	10803fcc 	andi	r2,r2,255
 2023cf4:	1080201c 	xori	r2,r2,128
 2023cf8:	10bfe004 	addi	r2,r2,-128
 2023cfc:	1000421e 	bne	r2,zero,2023e08 <Netinit+0x458>
         {
            if(nets[i]->n_mib->ifType == ETHERNET)
 2023d00:	00c09934 	movhi	r3,612
 2023d04:	18f5c104 	addi	r3,r3,-10492
 2023d08:	e0bffe17 	ldw	r2,-8(fp)
 2023d0c:	1085883a 	add	r2,r2,r2
 2023d10:	1085883a 	add	r2,r2,r2
 2023d14:	1885883a 	add	r2,r3,r2
 2023d18:	10800017 	ldw	r2,0(r2)
 2023d1c:	10802717 	ldw	r2,156(r2)
 2023d20:	10800217 	ldw	r2,8(r2)
 2023d24:	10800198 	cmpnei	r2,r2,6
 2023d28:	1000131e 	bne	r2,zero,2023d78 <Netinit+0x3c8>
            {
               nets[i]->name[0] = 'e';    /* "et1", "et2", etc. */
 2023d2c:	00c09934 	movhi	r3,612
 2023d30:	18f5c104 	addi	r3,r3,-10492
 2023d34:	e0bffe17 	ldw	r2,-8(fp)
 2023d38:	1085883a 	add	r2,r2,r2
 2023d3c:	1085883a 	add	r2,r2,r2
 2023d40:	1885883a 	add	r2,r3,r2
 2023d44:	10800017 	ldw	r2,0(r2)
 2023d48:	00c01944 	movi	r3,101
 2023d4c:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 't';
 2023d50:	00c09934 	movhi	r3,612
 2023d54:	18f5c104 	addi	r3,r3,-10492
 2023d58:	e0bffe17 	ldw	r2,-8(fp)
 2023d5c:	1085883a 	add	r2,r2,r2
 2023d60:	1085883a 	add	r2,r2,r2
 2023d64:	1885883a 	add	r2,r3,r2
 2023d68:	10800017 	ldw	r2,0(r2)
 2023d6c:	00c01d04 	movi	r3,116
 2023d70:	10c00145 	stb	r3,5(r2)
 2023d74:	00001206 	br	2023dc0 <Netinit+0x410>
            }
            else
            {
               nets[i]->name[0] = 'i';    /* "if1", "if2", etc. */
 2023d78:	00c09934 	movhi	r3,612
 2023d7c:	18f5c104 	addi	r3,r3,-10492
 2023d80:	e0bffe17 	ldw	r2,-8(fp)
 2023d84:	1085883a 	add	r2,r2,r2
 2023d88:	1085883a 	add	r2,r2,r2
 2023d8c:	1885883a 	add	r2,r3,r2
 2023d90:	10800017 	ldw	r2,0(r2)
 2023d94:	00c01a44 	movi	r3,105
 2023d98:	10c00105 	stb	r3,4(r2)
               nets[i]->name[1] = 'f';
 2023d9c:	00c09934 	movhi	r3,612
 2023da0:	18f5c104 	addi	r3,r3,-10492
 2023da4:	e0bffe17 	ldw	r2,-8(fp)
 2023da8:	1085883a 	add	r2,r2,r2
 2023dac:	1085883a 	add	r2,r2,r2
 2023db0:	1885883a 	add	r2,r3,r2
 2023db4:	10800017 	ldw	r2,0(r2)
 2023db8:	00c01984 	movi	r3,102
 2023dbc:	10c00145 	stb	r3,5(r2)
            }
            nets[i]->name[2] = (char)(i + '1');
 2023dc0:	00c09934 	movhi	r3,612
 2023dc4:	18f5c104 	addi	r3,r3,-10492
 2023dc8:	e0bffe17 	ldw	r2,-8(fp)
 2023dcc:	1085883a 	add	r2,r2,r2
 2023dd0:	1085883a 	add	r2,r2,r2
 2023dd4:	1885883a 	add	r2,r3,r2
 2023dd8:	10800017 	ldw	r2,0(r2)
 2023ddc:	e0fffe17 	ldw	r3,-8(fp)
 2023de0:	18c00c44 	addi	r3,r3,49
 2023de4:	10c00185 	stb	r3,6(r2)
            nets[i]->name[3] = '\0';
 2023de8:	00c09934 	movhi	r3,612
 2023dec:	18f5c104 	addi	r3,r3,-10492
 2023df0:	e0bffe17 	ldw	r2,-8(fp)
 2023df4:	1085883a 	add	r2,r2,r2
 2023df8:	1085883a 	add	r2,r2,r2
 2023dfc:	1885883a 	add	r2,r3,r2
 2023e00:	10800017 	ldw	r2,0(r2)
 2023e04:	100001c5 	stb	zero,7(r2)
         }
      }
      /* check on subnet routing - if no mask then make one */
      fixup_subnet_mask(i);      /* make mask for this net */
 2023e08:	e13ffe17 	ldw	r4,-8(fp)
 2023e0c:	2023fa00 	call	2023fa0 <fixup_subnet_mask>

      /* build broadcast addresses */
      if(nets[i]->n_ipaddr != 0)
 2023e10:	00c09934 	movhi	r3,612
 2023e14:	18f5c104 	addi	r3,r3,-10492
 2023e18:	e0bffe17 	ldw	r2,-8(fp)
 2023e1c:	1085883a 	add	r2,r2,r2
 2023e20:	1085883a 	add	r2,r2,r2
 2023e24:	1885883a 	add	r2,r3,r2
 2023e28:	10800017 	ldw	r2,0(r2)
 2023e2c:	10800a17 	ldw	r2,40(r2)
 2023e30:	10004d26 	beq	r2,zero,2023f68 <Netinit+0x5b8>
      {
         nets[i]->n_netbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 2023e34:	00c09934 	movhi	r3,612
 2023e38:	18f5c104 	addi	r3,r3,-10492
 2023e3c:	e0bffe17 	ldw	r2,-8(fp)
 2023e40:	1085883a 	add	r2,r2,r2
 2023e44:	1085883a 	add	r2,r2,r2
 2023e48:	1885883a 	add	r2,r3,r2
 2023e4c:	10c00017 	ldw	r3,0(r2)
 2023e50:	01009934 	movhi	r4,612
 2023e54:	2135c104 	addi	r4,r4,-10492
 2023e58:	e0bffe17 	ldw	r2,-8(fp)
 2023e5c:	1085883a 	add	r2,r2,r2
 2023e60:	1085883a 	add	r2,r2,r2
 2023e64:	2085883a 	add	r2,r4,r2
 2023e68:	10800017 	ldw	r2,0(r2)
 2023e6c:	11000a17 	ldw	r4,40(r2)
 2023e70:	01409934 	movhi	r5,612
 2023e74:	2975c104 	addi	r5,r5,-10492
 2023e78:	e0bffe17 	ldw	r2,-8(fp)
 2023e7c:	1085883a 	add	r2,r2,r2
 2023e80:	1085883a 	add	r2,r2,r2
 2023e84:	2885883a 	add	r2,r5,r2
 2023e88:	10800017 	ldw	r2,0(r2)
 2023e8c:	10800c17 	ldw	r2,48(r2)
 2023e90:	0084303a 	nor	r2,zero,r2
 2023e94:	2084b03a 	or	r2,r4,r2
 2023e98:	18800e15 	stw	r2,56(r3)
         nets[i]->n_netbr42 = nets[i]->n_ipaddr & nets[i]->snmask;
 2023e9c:	00c09934 	movhi	r3,612
 2023ea0:	18f5c104 	addi	r3,r3,-10492
 2023ea4:	e0bffe17 	ldw	r2,-8(fp)
 2023ea8:	1085883a 	add	r2,r2,r2
 2023eac:	1085883a 	add	r2,r2,r2
 2023eb0:	1885883a 	add	r2,r3,r2
 2023eb4:	10c00017 	ldw	r3,0(r2)
 2023eb8:	01009934 	movhi	r4,612
 2023ebc:	2135c104 	addi	r4,r4,-10492
 2023ec0:	e0bffe17 	ldw	r2,-8(fp)
 2023ec4:	1085883a 	add	r2,r2,r2
 2023ec8:	1085883a 	add	r2,r2,r2
 2023ecc:	2085883a 	add	r2,r4,r2
 2023ed0:	10800017 	ldw	r2,0(r2)
 2023ed4:	11000a17 	ldw	r4,40(r2)
 2023ed8:	01409934 	movhi	r5,612
 2023edc:	2975c104 	addi	r5,r5,-10492
 2023ee0:	e0bffe17 	ldw	r2,-8(fp)
 2023ee4:	1085883a 	add	r2,r2,r2
 2023ee8:	1085883a 	add	r2,r2,r2
 2023eec:	2885883a 	add	r2,r5,r2
 2023ef0:	10800017 	ldw	r2,0(r2)
 2023ef4:	10800c17 	ldw	r2,48(r2)
 2023ef8:	2084703a 	and	r2,r4,r2
 2023efc:	18800f15 	stw	r2,60(r3)
         nets[i]->n_subnetbr = nets[i]->n_ipaddr | ~nets[i]->snmask;
 2023f00:	00c09934 	movhi	r3,612
 2023f04:	18f5c104 	addi	r3,r3,-10492
 2023f08:	e0bffe17 	ldw	r2,-8(fp)
 2023f0c:	1085883a 	add	r2,r2,r2
 2023f10:	1085883a 	add	r2,r2,r2
 2023f14:	1885883a 	add	r2,r3,r2
 2023f18:	10c00017 	ldw	r3,0(r2)
 2023f1c:	01009934 	movhi	r4,612
 2023f20:	2135c104 	addi	r4,r4,-10492
 2023f24:	e0bffe17 	ldw	r2,-8(fp)
 2023f28:	1085883a 	add	r2,r2,r2
 2023f2c:	1085883a 	add	r2,r2,r2
 2023f30:	2085883a 	add	r2,r4,r2
 2023f34:	10800017 	ldw	r2,0(r2)
 2023f38:	11000a17 	ldw	r4,40(r2)
 2023f3c:	01409934 	movhi	r5,612
 2023f40:	2975c104 	addi	r5,r5,-10492
 2023f44:	e0bffe17 	ldw	r2,-8(fp)
 2023f48:	1085883a 	add	r2,r2,r2
 2023f4c:	1085883a 	add	r2,r2,r2
 2023f50:	2885883a 	add	r2,r5,r2
 2023f54:	10800017 	ldw	r2,0(r2)
 2023f58:	10800c17 	ldw	r2,48(r2)
 2023f5c:	0084303a 	nor	r2,zero,r2
 2023f60:	2084b03a 	or	r2,r4,r2
 2023f64:	18801015 	stw	r2,64(r3)

   /* packet buffers in freeq are now all set. */
   exit_hook(netclose);       /* Clean up nets when we are unloaded */

   /* now do the per-IP interface initializations */
   for (i = 0; i < (int)ifNumber; i++)
 2023f68:	e0bffe17 	ldw	r2,-8(fp)
 2023f6c:	10800044 	addi	r2,r2,1
 2023f70:	e0bffe15 	stw	r2,-8(fp)
 2023f74:	00808174 	movhi	r2,517
 2023f78:	1090b304 	addi	r2,r2,17100
 2023f7c:	10800017 	ldw	r2,0(r2)
 2023f80:	e0fffe17 	ldw	r3,-8(fp)
 2023f84:	18bf0616 	blt	r3,r2,2023ba0 <Netinit+0x1f0>
#if defined(DYNAMIC_IFACES) && defined(IN_MENUS)
   /* Install dynamic iface menu */
   install_menu(&dynif_menu[0]);
#endif /* DYNAMIC_IFACES && IN_MENUS */

   return(0);
 2023f88:	0005883a 	mov	r2,zero
}
 2023f8c:	e037883a 	mov	sp,fp
 2023f90:	dfc00117 	ldw	ra,4(sp)
 2023f94:	df000017 	ldw	fp,0(sp)
 2023f98:	dec00204 	addi	sp,sp,8
 2023f9c:	f800283a 	ret

02023fa0 <fixup_subnet_mask>:
 * RETURNS: 
 */

void
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
 2023fa0:	defffc04 	addi	sp,sp,-16
 2023fa4:	dfc00315 	stw	ra,12(sp)
 2023fa8:	df000215 	stw	fp,8(sp)
 2023fac:	df000204 	addi	fp,sp,8
 2023fb0:	e13fff15 	stw	r4,-4(fp)
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
 2023fb4:	00c09934 	movhi	r3,612
 2023fb8:	18f5c104 	addi	r3,r3,-10492
 2023fbc:	e0bfff17 	ldw	r2,-4(fp)
 2023fc0:	1085883a 	add	r2,r2,r2
 2023fc4:	1085883a 	add	r2,r2,r2
 2023fc8:	1885883a 	add	r2,r3,r2
 2023fcc:	10800017 	ldw	r2,0(r2)
 2023fd0:	10800c17 	ldw	r2,48(r2)
 2023fd4:	1000421e 	bne	r2,zero,20240e0 <fixup_subnet_mask+0x140>
      return;

   /* things depending on IP address class: */
   if ((nets[netnum]->n_ipaddr & AMASK) == AADDR)
 2023fd8:	00c09934 	movhi	r3,612
 2023fdc:	18f5c104 	addi	r3,r3,-10492
 2023fe0:	e0bfff17 	ldw	r2,-4(fp)
 2023fe4:	1085883a 	add	r2,r2,r2
 2023fe8:	1085883a 	add	r2,r2,r2
 2023fec:	1885883a 	add	r2,r3,r2
 2023ff0:	10800017 	ldw	r2,0(r2)
 2023ff4:	10800a17 	ldw	r2,40(r2)
 2023ff8:	1080200c 	andi	r2,r2,128
 2023ffc:	1000031e 	bne	r2,zero,202400c <fixup_subnet_mask+0x6c>
      smask = 0xFF000000L;
 2024000:	00bfc034 	movhi	r2,65280
 2024004:	e0bffe15 	stw	r2,-8(fp)
 2024008:	00001f06 	br	2024088 <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & BMASK) == BADDR)
 202400c:	00c09934 	movhi	r3,612
 2024010:	18f5c104 	addi	r3,r3,-10492
 2024014:	e0bfff17 	ldw	r2,-4(fp)
 2024018:	1085883a 	add	r2,r2,r2
 202401c:	1085883a 	add	r2,r2,r2
 2024020:	1885883a 	add	r2,r3,r2
 2024024:	10800017 	ldw	r2,0(r2)
 2024028:	10800a17 	ldw	r2,40(r2)
 202402c:	1080300c 	andi	r2,r2,192
 2024030:	10802018 	cmpnei	r2,r2,128
 2024034:	1000031e 	bne	r2,zero,2024044 <fixup_subnet_mask+0xa4>
      smask = 0xFFFF0000L;
 2024038:	00bffff4 	movhi	r2,65535
 202403c:	e0bffe15 	stw	r2,-8(fp)
 2024040:	00001106 	br	2024088 <fixup_subnet_mask+0xe8>
   else if((nets[netnum]->n_ipaddr & CMASK) == CADDR)
 2024044:	00c09934 	movhi	r3,612
 2024048:	18f5c104 	addi	r3,r3,-10492
 202404c:	e0bfff17 	ldw	r2,-4(fp)
 2024050:	1085883a 	add	r2,r2,r2
 2024054:	1085883a 	add	r2,r2,r2
 2024058:	1885883a 	add	r2,r3,r2
 202405c:	10800017 	ldw	r2,0(r2)
 2024060:	10800a17 	ldw	r2,40(r2)
 2024064:	1080380c 	andi	r2,r2,224
 2024068:	10803018 	cmpnei	r2,r2,192
 202406c:	1000031e 	bne	r2,zero,202407c <fixup_subnet_mask+0xdc>
      smask = 0xFFFFFF00L;
 2024070:	00bfc004 	movi	r2,-256
 2024074:	e0bffe15 	stw	r2,-8(fp)
 2024078:	00000306 	br	2024088 <fixup_subnet_mask+0xe8>
   else
   {
      dtrap();    /* bad logic or setup values */
 202407c:	20285c80 	call	20285c8 <dtrap>
      smask = 0xFFFFFF00L;
 2024080:	00bfc004 	movi	r2,-256
 2024084:	e0bffe15 	stw	r2,-8(fp)
   }
   nets[netnum]->snmask = htonl(smask);
 2024088:	00c09934 	movhi	r3,612
 202408c:	18f5c104 	addi	r3,r3,-10492
 2024090:	e0bfff17 	ldw	r2,-4(fp)
 2024094:	1085883a 	add	r2,r2,r2
 2024098:	1085883a 	add	r2,r2,r2
 202409c:	1885883a 	add	r2,r3,r2
 20240a0:	10800017 	ldw	r2,0(r2)
 20240a4:	e0fffe17 	ldw	r3,-8(fp)
 20240a8:	1808d63a 	srli	r4,r3,24
 20240ac:	e0fffe17 	ldw	r3,-8(fp)
 20240b0:	1806d23a 	srli	r3,r3,8
 20240b4:	18ffc00c 	andi	r3,r3,65280
 20240b8:	20c8b03a 	or	r4,r4,r3
 20240bc:	e0fffe17 	ldw	r3,-8(fp)
 20240c0:	18ffc00c 	andi	r3,r3,65280
 20240c4:	1806923a 	slli	r3,r3,8
 20240c8:	20c8b03a 	or	r4,r4,r3
 20240cc:	e0fffe17 	ldw	r3,-8(fp)
 20240d0:	1806963a 	slli	r3,r3,24
 20240d4:	20c6b03a 	or	r3,r4,r3
 20240d8:	10c00c15 	stw	r3,48(r2)
 20240dc:	00000106 	br	20240e4 <fixup_subnet_mask+0x144>
fixup_subnet_mask(int netnum)      /* which of the nets[] to do. */
{
   u_long   smask;

   if (nets[netnum]->snmask)  /* if mask is already set, don't bother */
      return;
 20240e0:	0001883a 	nop
   {
      dtrap();    /* bad logic or setup values */
      smask = 0xFFFFFF00L;
   }
   nets[netnum]->snmask = htonl(smask);
}
 20240e4:	e037883a 	mov	sp,fp
 20240e8:	dfc00117 	ldw	ra,4(sp)
 20240ec:	df000017 	ldw	fp,0(sp)
 20240f0:	dec00204 	addi	sp,sp,8
 20240f4:	f800283a 	ret

020240f8 <netclose>:
 * RETURNS: 
 */

void
netclose()
{
 20240f8:	defffc04 	addi	sp,sp,-16
 20240fc:	dfc00315 	stw	ra,12(sp)
 2024100:	df000215 	stw	fp,8(sp)
 2024104:	df000204 	addi	fp,sp,8
   NET ifp;
   int index = 0;
 2024108:	e03fff15 	stw	zero,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
 202410c:	d0a08817 	ldw	r2,-32224(gp)
 2024110:	1080010c 	andi	r2,r2,4
 2024114:	10000326 	beq	r2,zero,2024124 <netclose+0x2c>
 2024118:	01008174 	movhi	r4,517
 202411c:	2139ae04 	addi	r4,r4,-6472
 2024120:	2006cb40 	call	2006cb4 <puts>
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 2024124:	00809934 	movhi	r2,612
 2024128:	10b7ce04 	addi	r2,r2,-8392
 202412c:	10800017 	ldw	r2,0(r2)
 2024130:	e0bffe15 	stw	r2,-8(fp)
 2024134:	00002206 	br	20241c0 <netclose+0xc8>
   {
      if (ifp->n_close)
 2024138:	e0bffe17 	ldw	r2,-8(fp)
 202413c:	10800517 	ldw	r2,20(r2)
 2024140:	10001026 	beq	r2,zero,2024184 <netclose+0x8c>
      {
         dprintf("netclose: closing iface %s\n", ifp->n_mib->ifDescr);
 2024144:	e0bffe17 	ldw	r2,-8(fp)
 2024148:	10802717 	ldw	r2,156(r2)
 202414c:	10800117 	ldw	r2,4(r2)
 2024150:	01008174 	movhi	r4,517
 2024154:	2139b304 	addi	r4,r4,-6452
 2024158:	100b883a 	mov	r5,r2
 202415c:	2006a240 	call	2006a24 <printf>
         (*(ifp->n_close))(index++);
 2024160:	e0bffe17 	ldw	r2,-8(fp)
 2024164:	10c00517 	ldw	r3,20(r2)
 2024168:	e0bfff17 	ldw	r2,-4(fp)
 202416c:	e13fff17 	ldw	r4,-4(fp)
 2024170:	21000044 	addi	r4,r4,1
 2024174:	e13fff15 	stw	r4,-4(fp)
 2024178:	1009883a 	mov	r4,r2
 202417c:	183ee83a 	callr	r3
 2024180:	00000c06 	br	20241b4 <netclose+0xbc>
      }
      else
      {
#ifdef NPDEBUG
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
 2024184:	d0a08817 	ldw	r2,-32224(gp)
 2024188:	1080010c 	andi	r2,r2,4
 202418c:	10000626 	beq	r2,zero,20241a8 <netclose+0xb0>
 2024190:	e0bffe17 	ldw	r2,-8(fp)
 2024194:	10800104 	addi	r2,r2,4
 2024198:	01008174 	movhi	r4,517
 202419c:	2139ba04 	addi	r4,r4,-6424
 20241a0:	100b883a 	mov	r5,r2
 20241a4:	2006a240 	call	2006a24 <printf>
#endif
         index++;
 20241a8:	e0bfff17 	ldw	r2,-4(fp)
 20241ac:	10800044 	addi	r2,r2,1
 20241b0:	e0bfff15 	stw	r2,-4(fp)

#ifdef NPDEBUG
   if (NDEBUG & INFOMSG)   dprintf("netclose() called\n");
#endif

   for (ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next)
 20241b4:	e0bffe17 	ldw	r2,-8(fp)
 20241b8:	10800017 	ldw	r2,0(r2)
 20241bc:	e0bffe15 	stw	r2,-8(fp)
 20241c0:	e0bffe17 	ldw	r2,-8(fp)
 20241c4:	103fdc1e 	bne	r2,zero,2024138 <netclose+0x40>
         if (NDEBUG & INFOMSG) dprintf("net %s: no close routine!\n", ifp->name);
#endif
         index++;
      }
   }
}
 20241c8:	e037883a 	mov	sp,fp
 20241cc:	dfc00117 	ldw	ra,4(sp)
 20241d0:	df000017 	ldw	fp,0(sp)
 20241d4:	dec00204 	addi	sp,sp,8
 20241d8:	f800283a 	ret

020241dc <pktdemux>:
 * RETURNS: void
 */

void
pktdemux()
{
 20241dc:	defff904 	addi	sp,sp,-28
 20241e0:	dfc00615 	stw	ra,24(sp)
 20241e4:	df000515 	stw	fp,20(sp)
 20241e8:	df000504 	addi	fp,sp,20
   NET      ifc;                /* interface packet came from */
   IFMIB    mib;
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */
 20241ec:	e03ffb15 	stw	zero,-20(fp)

   while (rcvdq.q_len)
 20241f0:	0000dc06 	br	2024564 <pktdemux+0x388>
   {
      /* If we are low on free packets, don't hog CPU cycles */
      if (pkts++ > bigfreeq.q_len)
 20241f4:	00809934 	movhi	r2,612
 20241f8:	10b62c04 	addi	r2,r2,-10064
 20241fc:	10c00217 	ldw	r3,8(r2)
 2024200:	e0bffb17 	ldw	r2,-20(fp)
 2024204:	1884803a 	cmplt	r2,r3,r2
 2024208:	e0fffb17 	ldw	r3,-20(fp)
 202420c:	18c00044 	addi	r3,r3,1
 2024210:	e0fffb15 	stw	r3,-20(fp)
 2024214:	10803fcc 	andi	r2,r2,255
 2024218:	10000226 	beq	r2,zero,2024224 <pktdemux+0x48>
      {
#ifdef SUPERLOOP
         return;        /* don't hog stack on superloop */
#else    /* SUPERLOOP */
         tk_yield(); /* let application tasks process received packets */
 202421c:	20278080 	call	2027808 <tk_yield>
         pkts = 0;   /* reset counter */
 2024220:	e03ffb15 	stw	zero,-20(fp)
#endif   /* SUPERLOOP else */
      }

      /* If we get receive interupt from the net during this
      lock, the MAC driver needs to wait or reschedule */
      LOCK_NET_RESOURCE(RXQ_RESID);
 2024224:	01000044 	movi	r4,1
 2024228:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pkt = (PACKET)q_deq(&rcvdq);
 202422c:	01009934 	movhi	r4,612
 2024230:	2134fc04 	addi	r4,r4,-11280
 2024234:	20281d00 	call	20281d0 <getq>
 2024238:	e0bffc15 	stw	r2,-16(fp)
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 202423c:	01000044 	movi	r4,1
 2024240:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      if (!pkt) panic("pktdemux: got null pkt");
 2024244:	e0bffc17 	ldw	r2,-16(fp)
 2024248:	1000031e 	bne	r2,zero,2024258 <pktdemux+0x7c>
 202424c:	01008174 	movhi	r4,517
 2024250:	2139c104 	addi	r4,r4,-6396
 2024254:	2026bf80 	call	2026bf8 <panic>
      ifc = pkt->net;
 2024258:	e0bffc17 	ldw	r2,-16(fp)
 202425c:	10800617 	ldw	r2,24(r2)
 2024260:	e0bffd15 	stw	r2,-12(fp)

      mib = ifc->n_mib;
 2024264:	e0bffd17 	ldw	r2,-12(fp)
 2024268:	10802717 	ldw	r2,156(r2)
 202426c:	e0bffe15 	stw	r2,-8(fp)
      /* maintain mib stats for unicast and broadcast */
      if (isbcast(ifc, (u_char*)pkt->nb_buff + ETHHDR_BIAS))
 2024270:	e0bffc17 	ldw	r2,-16(fp)
 2024274:	10800117 	ldw	r2,4(r2)
 2024278:	10800084 	addi	r2,r2,2
 202427c:	e13ffd17 	ldw	r4,-12(fp)
 2024280:	100b883a 	mov	r5,r2
 2024284:	203f1d80 	call	203f1d8 <isbcast>
 2024288:	10000626 	beq	r2,zero,20242a4 <pktdemux+0xc8>
         mib->ifInNUcastPkts++;
 202428c:	e0bffe17 	ldw	r2,-8(fp)
 2024290:	10800b17 	ldw	r2,44(r2)
 2024294:	10c00044 	addi	r3,r2,1
 2024298:	e0bffe17 	ldw	r2,-8(fp)
 202429c:	10c00b15 	stw	r3,44(r2)
 20242a0:	00000506 	br	20242b8 <pktdemux+0xdc>
      else
         mib->ifInUcastPkts++;
 20242a4:	e0bffe17 	ldw	r2,-8(fp)
 20242a8:	10800a17 	ldw	r2,40(r2)
 20242ac:	10c00044 	addi	r3,r2,1
 20242b0:	e0bffe17 	ldw	r2,-8(fp)
 20242b4:	10c00a15 	stw	r3,40(r2)

      if(mib->ifAdminStatus == NI_DOWN)
 20242b8:	e0bffe17 	ldw	r2,-8(fp)
 20242bc:	10800617 	ldw	r2,24(r2)
 20242c0:	10800098 	cmpnei	r2,r2,2
 20242c4:	10000c1e 	bne	r2,zero,20242f8 <pktdemux+0x11c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 20242c8:	01000084 	movi	r4,2
 20242cc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(pkt);  /* dump packet from downed interface */
 20242d0:	e13ffc17 	ldw	r4,-16(fp)
 20242d4:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20242d8:	01000084 	movi	r4,2
 20242dc:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         mib->ifInDiscards++;
 20242e0:	e0bffe17 	ldw	r2,-8(fp)
 20242e4:	10800c17 	ldw	r2,48(r2)
 20242e8:	10c00044 	addi	r3,r2,1
 20242ec:	e0bffe17 	ldw	r2,-8(fp)
 20242f0:	10c00c15 	stw	r3,48(r2)
         continue;      /* next packet */
 20242f4:	00009b06 	br	2024564 <pktdemux+0x388>
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 20242f8:	e0bffc17 	ldw	r2,-16(fp)
 20242fc:	10800117 	ldw	r2,4(r2)
 2024300:	10bfff04 	addi	r2,r2,-4
 2024304:	10800003 	ldbu	r2,0(r2)
 2024308:	10803fcc 	andi	r2,r2,255
 202430c:	1080201c 	xori	r2,r2,128
 2024310:	10bfe004 	addi	r2,r2,-128
 2024314:	10801358 	cmpnei	r2,r2,77
 2024318:	10000b1e 	bne	r2,zero,2024348 <pktdemux+0x16c>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
 202431c:	e0bffc17 	ldw	r2,-16(fp)
 2024320:	10c00117 	ldw	r3,4(r2)
 2024324:	e0bffc17 	ldw	r2,-16(fp)
 2024328:	10800217 	ldw	r2,8(r2)
 202432c:	1885883a 	add	r2,r3,r2
 2024330:	10800003 	ldbu	r2,0(r2)
         mib->ifInDiscards++;
         continue;      /* next packet */
      }

#ifdef NPDEBUG
      if (*(pkt->nb_buff - ALIGN_TYPE) != 'M' ||
 2024334:	10803fcc 	andi	r2,r2,255
 2024338:	1080201c 	xori	r2,r2,128
 202433c:	10bfe004 	addi	r2,r2,-128
 2024340:	10801360 	cmpeqi	r2,r2,77
 2024344:	1000041e 	bne	r2,zero,2024358 <pktdemux+0x17c>
          *(pkt->nb_buff + pkt->nb_blen) != 'M')
      {
         dtrap();
 2024348:	20285c80 	call	20285c8 <dtrap>
         panic("pktdemux: corrupt pkt");
 202434c:	01008174 	movhi	r4,517
 2024350:	2139c704 	addi	r4,r4,-6372
 2024354:	2026bf80 	call	2026bf8 <panic>
         }
      }
#endif   /* LOSSY_IO */

      /* see if driver set pkt->nb_prot and pkt->type */
      if((ifc->n_flags & NF_NBPROT) == 0)
 2024358:	e0bffd17 	ldw	r2,-12(fp)
 202435c:	10802a17 	ldw	r2,168(r2)
 2024360:	1080020c 	andi	r2,r2,8
 2024364:	1000491e 	bne	r2,zero,202448c <pktdemux+0x2b0>
          * probably the right thing to do, but because of this historic
          * inconsistency we don't try to fix it here - the longer size
          * turns out to be harmless since the IP layer fixes the size
          * based on the IP header length field.
          */
         switch(ifc->n_mib->ifType)
 2024368:	e0bffd17 	ldw	r2,-12(fp)
 202436c:	10802717 	ldw	r2,156(r2)
 2024370:	10800217 	ldw	r2,8(r2)
 2024374:	108001a0 	cmpeqi	r2,r2,6
 2024378:	10003626 	beq	r2,zero,2024454 <pktdemux+0x278>
         {
         case ETHERNET:
            /* get pointer to ethernet header */
            eth = (pkt->nb_buff + ETHHDR_BIAS);
 202437c:	e0bffc17 	ldw	r2,-16(fp)
 2024380:	10800117 	ldw	r2,4(r2)
 2024384:	10800084 	addi	r2,r2,2
 2024388:	e0bfff15 	stw	r2,-4(fp)
            {
               pkt->type = htons((unshort)ET_TYPE_GET(eth));
               pkt->nb_prot = pkt->nb_buff + ETHHDR_SIZE;
            }
#else
            pkt->type = htons((unshort)ET_TYPE_GET(eth));
 202438c:	e0bfff17 	ldw	r2,-4(fp)
 2024390:	10800304 	addi	r2,r2,12
 2024394:	10800003 	ldbu	r2,0(r2)
 2024398:	10803fcc 	andi	r2,r2,255
 202439c:	1080201c 	xori	r2,r2,128
 20243a0:	10bfe004 	addi	r2,r2,-128
 20243a4:	1004923a 	slli	r2,r2,8
 20243a8:	1007883a 	mov	r3,r2
 20243ac:	e0bfff17 	ldw	r2,-4(fp)
 20243b0:	10800344 	addi	r2,r2,13
 20243b4:	10800003 	ldbu	r2,0(r2)
 20243b8:	10803fcc 	andi	r2,r2,255
 20243bc:	1080201c 	xori	r2,r2,128
 20243c0:	10bfe004 	addi	r2,r2,-128
 20243c4:	10803fcc 	andi	r2,r2,255
 20243c8:	1885883a 	add	r2,r3,r2
 20243cc:	10bfffcc 	andi	r2,r2,65535
 20243d0:	1004d23a 	srli	r2,r2,8
 20243d4:	1007883a 	mov	r3,r2
 20243d8:	e0bfff17 	ldw	r2,-4(fp)
 20243dc:	10800304 	addi	r2,r2,12
 20243e0:	10800003 	ldbu	r2,0(r2)
 20243e4:	10803fcc 	andi	r2,r2,255
 20243e8:	1080201c 	xori	r2,r2,128
 20243ec:	10bfe004 	addi	r2,r2,-128
 20243f0:	1004923a 	slli	r2,r2,8
 20243f4:	1009883a 	mov	r4,r2
 20243f8:	e0bfff17 	ldw	r2,-4(fp)
 20243fc:	10800344 	addi	r2,r2,13
 2024400:	10800003 	ldbu	r2,0(r2)
 2024404:	10803fcc 	andi	r2,r2,255
 2024408:	1080201c 	xori	r2,r2,128
 202440c:	10bfe004 	addi	r2,r2,-128
 2024410:	10803fcc 	andi	r2,r2,255
 2024414:	2085883a 	add	r2,r4,r2
 2024418:	10bfffcc 	andi	r2,r2,65535
 202441c:	1004923a 	slli	r2,r2,8
 2024420:	1884b03a 	or	r2,r3,r2
 2024424:	1007883a 	mov	r3,r2
 2024428:	e0bffc17 	ldw	r2,-16(fp)
 202442c:	10c0080d 	sth	r3,32(r2)
            pkt->nb_prot = pkt->nb_buff + pkt->net->n_lnh;
 2024430:	e0bffc17 	ldw	r2,-16(fp)
 2024434:	10c00117 	ldw	r3,4(r2)
 2024438:	e0bffc17 	ldw	r2,-16(fp)
 202443c:	10800617 	ldw	r2,24(r2)
 2024440:	10800817 	ldw	r2,32(r2)
 2024444:	1887883a 	add	r3,r3,r2
 2024448:	e0bffc17 	ldw	r2,-16(fp)
 202444c:	10c00315 	stw	r3,12(r2)
#endif   /* IEEE_802_3 */
            break;
 2024450:	00000e06 	br	202448c <pktdemux+0x2b0>
         case PPPOE:
            /* do not change type yet, for PPPoE */
            break;
#endif   /* USE_PPPOE */
         default:    /* driver bug? */
            dprintf("pktdemux: bad Iface type %ld\n",ifc->n_mib->ifType);
 2024454:	e0bffd17 	ldw	r2,-12(fp)
 2024458:	10802717 	ldw	r2,156(r2)
 202445c:	10800217 	ldw	r2,8(r2)
 2024460:	01008174 	movhi	r4,517
 2024464:	2139cd04 	addi	r4,r4,-6348
 2024468:	100b883a 	mov	r5,r2
 202446c:	2006a240 	call	2006a24 <printf>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 2024470:	01000084 	movi	r4,2
 2024474:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(pkt);
 2024478:	e13ffc17 	ldw	r4,-16(fp)
 202447c:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2024480:	01000084 	movi	r4,2
 2024484:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            continue;
 2024488:	00003606 	br	2024564 <pktdemux+0x388>
         }
      }

      /* pkt->nb_prot and pkt->type are now set. pass pkt to upper layer */
      switch(pkt->type)
 202448c:	e0bffc17 	ldw	r2,-16(fp)
 2024490:	1080080b 	ldhu	r2,32(r2)
 2024494:	10bfffcc 	andi	r2,r2,65535
 2024498:	10c00220 	cmpeqi	r3,r2,8
 202449c:	1800031e 	bne	r3,zero,20244ac <pktdemux+0x2d0>
 20244a0:	10818220 	cmpeqi	r2,r2,1544
 20244a4:	1000081e 	bne	r2,zero,20244c8 <pktdemux+0x2ec>
 20244a8:	00000e06 	br	20244e4 <pktdemux+0x308>
      {
      case IPTP:     /* IP type */
         LOCK_NET_RESOURCE(NET_RESID);
 20244ac:	0009883a 	mov	r4,zero
 20244b0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
#ifdef SHARED_IPADDRS
         add_share_route(pkt);
#endif /* SHARED_IPADDRS */
#ifdef IP_V4
         ip_rcv(pkt);
 20244b4:	e13ffc17 	ldw	r4,-16(fp)
 20244b8:	20430d40 	call	20430d4 <ip_rcv>
            /* don't care, it's IPv4 */
            LOCK_NET_RESOURCE(FREEQ_RESID);
            pk_free(pkt);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif
		UNLOCK_NET_RESOURCE(NET_RESID);
 20244bc:	0009883a 	mov	r4,zero
 20244c0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         break;
 20244c4:	00002606 	br	2024560 <pktdemux+0x384>
#ifdef INCLUDE_ARP
      case ARPTP:       /* ARP type */
         LOCK_NET_RESOURCE(NET_RESID);
 20244c8:	0009883a 	mov	r4,zero
 20244cc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         arprcv(pkt);
 20244d0:	e13ffc17 	ldw	r4,-16(fp)
 20244d4:	203e93c0 	call	203e93c <arprcv>
         UNLOCK_NET_RESOURCE(NET_RESID);
 20244d8:	0009883a 	mov	r4,zero
 20244dc:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         break;
 20244e0:	00001f06 	br	2024560 <pktdemux+0x384>
         UNLOCK_NET_RESOURCE(NET_RESID);
         break;
#endif
      default:
#ifdef NPDEBUG
         if (NDEBUG & UPCTRACE)
 20244e4:	d0a08817 	ldw	r2,-32224(gp)
 20244e8:	1081000c 	andi	r2,r2,1024
 20244ec:	10001026 	beq	r2,zero,2024530 <pktdemux+0x354>
            dprintf("pktdemux: bad pkt type 0x%04x\n", ntohs(pkt->type));
 20244f0:	e0bffc17 	ldw	r2,-16(fp)
 20244f4:	1080080b 	ldhu	r2,32(r2)
 20244f8:	10bfffcc 	andi	r2,r2,65535
 20244fc:	1004d23a 	srli	r2,r2,8
 2024500:	10bfffcc 	andi	r2,r2,65535
 2024504:	10c03fcc 	andi	r3,r2,255
 2024508:	e0bffc17 	ldw	r2,-16(fp)
 202450c:	1080080b 	ldhu	r2,32(r2)
 2024510:	10bfffcc 	andi	r2,r2,65535
 2024514:	1004923a 	slli	r2,r2,8
 2024518:	10bfffcc 	andi	r2,r2,65535
 202451c:	1884b03a 	or	r2,r3,r2
 2024520:	01008174 	movhi	r4,517
 2024524:	2139d504 	addi	r4,r4,-6316
 2024528:	100b883a 	mov	r5,r2
 202452c:	2006a240 	call	2006a24 <printf>
#endif   /* NPDEBUG */
         ifc->n_mib->ifInUnknownProtos++;
 2024530:	e0bffd17 	ldw	r2,-12(fp)
 2024534:	10802717 	ldw	r2,156(r2)
 2024538:	10c00e17 	ldw	r3,56(r2)
 202453c:	18c00044 	addi	r3,r3,1
 2024540:	10c00e15 	stw	r3,56(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 2024544:	01000084 	movi	r4,2
 2024548:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(pkt);           /* return to free buffer */
 202454c:	e13ffc17 	ldw	r4,-16(fp)
 2024550:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2024554:	01000084 	movi	r4,2
 2024558:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         break;
 202455c:	0001883a 	nop
      }
      continue;
 2024560:	0001883a 	nop
   int      pkts;
   char *   eth;

   pkts = 0;   /* packets per loop */

   while (rcvdq.q_len)
 2024564:	00809934 	movhi	r2,612
 2024568:	10b4fc04 	addi	r2,r2,-11280
 202456c:	10800217 	ldw	r2,8(r2)
 2024570:	103f201e 	bne	r2,zero,20241f4 <pktdemux+0x18>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         break;
      }
      continue;
   }
}
 2024574:	e037883a 	mov	sp,fp
 2024578:	dfc00117 	ldw	ra,4(sp)
 202457c:	df000017 	ldw	fp,0(sp)
 2024580:	dec00204 	addi	sp,sp,8
 2024584:	f800283a 	ret

02024588 <c_older>:
 * RETURNS: the older of the two passed tick counts
 */

u_long
c_older(u_long ct1, u_long ct2)
{
 2024588:	defffd04 	addi	sp,sp,-12
 202458c:	df000215 	stw	fp,8(sp)
 2024590:	df000204 	addi	fp,sp,8
 2024594:	e13ffe15 	stw	r4,-8(fp)
 2024598:	e17fff15 	stw	r5,-4(fp)

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 202459c:	00808174 	movhi	r2,517
 20245a0:	1090c904 	addi	r2,r2,17188
 20245a4:	10800017 	ldw	r2,0(r2)
 20245a8:	1000140e 	bge	r2,zero,20245fc <c_older+0x74>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 20245ac:	00808174 	movhi	r2,517
 20245b0:	1090c904 	addi	r2,r2,17188
 20245b4:	10c00017 	ldw	r3,0(r2)

u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
 20245b8:	e0bffe17 	ldw	r2,-8(fp)
 20245bc:	18800536 	bltu	r3,r2,20245d4 <c_older+0x4c>
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 20245c0:	00808174 	movhi	r2,517
 20245c4:	1090c904 	addi	r2,r2,17188
 20245c8:	10c00017 	ldw	r3,0(r2)
 20245cc:	e0bfff17 	ldw	r2,-4(fp)
 20245d0:	18800a2e 	bgeu	r3,r2,20245fc <c_older+0x74>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 20245d4:	00808174 	movhi	r2,517
 20245d8:	1090c904 	addi	r2,r2,17188
 20245dc:	10800017 	ldw	r2,0(r2)
u_long
c_older(u_long ct1, u_long ct2)
{

   if (!(cticks & 0x80000000) || /* cticks has not wrapped recently, or */
       (ct1 <= cticks && ct2 <= cticks) || /* both are below cticks or */
 20245e0:	e0fffe17 	ldw	r3,-8(fp)
 20245e4:	18800c36 	bltu	r3,r2,2024618 <c_older+0x90>
       (ct1 >= cticks && ct2 >= cticks))   /* both are above cticks */
 20245e8:	00808174 	movhi	r2,517
 20245ec:	1090c904 	addi	r2,r2,17188
 20245f0:	10800017 	ldw	r2,0(r2)
 20245f4:	e0ffff17 	ldw	r3,-4(fp)
 20245f8:	18800736 	bltu	r3,r2,2024618 <c_older+0x90>
   {
      if (ct1 < ct2)
 20245fc:	e0fffe17 	ldw	r3,-8(fp)
 2024600:	e0bfff17 	ldw	r2,-4(fp)
 2024604:	1880022e 	bgeu	r3,r2,2024610 <c_older+0x88>
         return(ct1);      /* then smaller is oldest */
 2024608:	e0bffe17 	ldw	r2,-8(fp)
 202460c:	00000806 	br	2024630 <c_older+0xa8>
      else 
         return(ct2);
 2024610:	e0bfff17 	ldw	r2,-4(fp)
 2024614:	00000606 	br	2024630 <c_older+0xa8>
   }

   /* else one is less than cticks, and one is greater.
   the larger value is then the oldest */
   if (ct1 >= ct2)
 2024618:	e0fffe17 	ldw	r3,-8(fp)
 202461c:	e0bfff17 	ldw	r2,-4(fp)
 2024620:	18800236 	bltu	r3,r2,202462c <c_older+0xa4>
      return(ct1);
 2024624:	e0bffe17 	ldw	r2,-8(fp)
 2024628:	00000106 	br	2024630 <c_older+0xa8>
   else
      return(ct2);
 202462c:	e0bfff17 	ldw	r2,-4(fp)
}
 2024630:	e037883a 	mov	sp,fp
 2024634:	df000017 	ldw	fp,0(sp)
 2024638:	dec00104 	addi	sp,sp,4
 202463c:	f800283a 	ret

02024640 <ip2mac>:
 */

int
ip2mac(PACKET pkt,         /* the packet itself, all set but for dest MAC address */
   ip_addr  dest_ip)    /* the IP host or gateway to get MAC addr for */
{
 2024640:	defffb04 	addi	sp,sp,-20
 2024644:	dfc00415 	stw	ra,16(sp)
 2024648:	df000315 	stw	fp,12(sp)
 202464c:	df000304 	addi	fp,sp,12
 2024650:	e13ffe15 	stw	r4,-8(fp)
 2024654:	e17fff15 	stw	r5,-4(fp)
   IFMIB ifmib = pkt->net->n_mib;   /* mib info for this interface */
 2024658:	e0bffe17 	ldw	r2,-8(fp)
 202465c:	10800617 	ldw	r2,24(r2)
 2024660:	10802717 	ldw	r2,156(r2)
 2024664:	e0bffd15 	stw	r2,-12(fp)

   /* Always punt if iface ifAdminStatus is DOWN. ifOperStatus may 
    * be down too, but our packet may be the event required to bring 
    * it up - so don't worry about ifOperStatus here.
    */
   if(ifmib->ifAdminStatus == NI_DOWN)
 2024668:	e0bffd17 	ldw	r2,-12(fp)
 202466c:	10800617 	ldw	r2,24(r2)
 2024670:	10800098 	cmpnei	r2,r2,2
 2024674:	1000081e 	bne	r2,zero,2024698 <ip2mac+0x58>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2024678:	01000084 	movi	r4,2
 202467c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 2024680:	e13ffe17 	ldw	r4,-8(fp)
 2024684:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2024688:	01000084 	movi	r4,2
 202468c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return(ENP_NO_ROUTE);
 2024690:	00bff7c4 	movi	r2,-33
 2024694:	00004906 	br	20247bc <ip2mac+0x17c>
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 2024698:	e0bffe17 	ldw	r2,-8(fp)
 202469c:	10800617 	ldw	r2,24(r2)
 20246a0:	10800817 	ldw	r2,32(r2)
 20246a4:	10000826 	beq	r2,zero,20246c8 <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 20246a8:	e0bffd17 	ldw	r2,-12(fp)
 20246ac:	10800217 	ldw	r2,8(r2)
         return ENP_NOBUFFER;
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
 20246b0:	108005e0 	cmpeqi	r2,r2,23
 20246b4:	1000041e 	bne	r2,zero,20246c8 <ip2mac+0x88>
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
       (ifmib->ifType == SLIP))
 20246b8:	e0bffd17 	ldw	r2,-12(fp)
 20246bc:	10800217 	ldw	r2,8(r2)
   }
#endif   /* LINKED_PKTS */

   /* some interfaces (ie SLIP) just get the raw IP frame - no ARP needed */
   if ((pkt->net->n_lnh == 0) ||    /* no MAC header */
       (ifmib->ifType == PPP) ||     /* or PPP or SLIP... */
 20246c0:	10800718 	cmpnei	r2,r2,28
 20246c4:	10002a1e 	bne	r2,zero,2024770 <ip2mac+0x130>
       (ifmib->ifType == SLIP))
   {
      ifmib->ifOutUcastPkts++;   /* maintain MIB counters */
 20246c8:	e0bffd17 	ldw	r2,-12(fp)
 20246cc:	10801017 	ldw	r2,64(r2)
 20246d0:	10c00044 	addi	r3,r2,1
 20246d4:	e0bffd17 	ldw	r2,-12(fp)
 20246d8:	10c01015 	stw	r3,64(r2)
      ifmib->ifOutOctets += pkt->nb_plen;
 20246dc:	e0bffd17 	ldw	r2,-12(fp)
 20246e0:	10c00f17 	ldw	r3,60(r2)
 20246e4:	e0bffe17 	ldw	r2,-8(fp)
 20246e8:	10800417 	ldw	r2,16(r2)
 20246ec:	1887883a 	add	r3,r3,r2
 20246f0:	e0bffd17 	ldw	r2,-12(fp)
 20246f4:	10c00f15 	stw	r3,60(r2)

      /* send packet on media */
      if (pkt->net->pkt_send) /* favor using packet send */
 20246f8:	e0bffe17 	ldw	r2,-8(fp)
 20246fc:	10800617 	ldw	r2,24(r2)
 2024700:	10800417 	ldw	r2,16(r2)
 2024704:	10000626 	beq	r2,zero,2024720 <ip2mac+0xe0>
         pkt->net->pkt_send(pkt);   /* pkt will be freed by MAC code */
 2024708:	e0bffe17 	ldw	r2,-8(fp)
 202470c:	10800617 	ldw	r2,24(r2)
 2024710:	10800417 	ldw	r2,16(r2)
 2024714:	e13ffe17 	ldw	r4,-8(fp)
 2024718:	103ee83a 	callr	r2
 202471c:	00001206 	br	2024768 <ip2mac+0x128>
      else  /* no packet send; try raw send */
      {
         pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 2024720:	e0bffe17 	ldw	r2,-8(fp)
 2024724:	10800617 	ldw	r2,24(r2)
 2024728:	11c00317 	ldw	r7,12(r2)
 202472c:	e0bffe17 	ldw	r2,-8(fp)
 2024730:	11000617 	ldw	r4,24(r2)
 2024734:	e0bffe17 	ldw	r2,-8(fp)
 2024738:	10c00317 	ldw	r3,12(r2)
 202473c:	e0bffe17 	ldw	r2,-8(fp)
 2024740:	10800417 	ldw	r2,16(r2)
 2024744:	180b883a 	mov	r5,r3
 2024748:	100d883a 	mov	r6,r2
 202474c:	383ee83a 	callr	r7
         LOCK_NET_RESOURCE(FREEQ_RESID);
 2024750:	01000084 	movi	r4,2
 2024754:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 2024758:	e13ffe17 	ldw	r4,-8(fp)
 202475c:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2024760:	01000084 	movi	r4,2
 2024764:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      }
      return(SUCCESS);
 2024768:	0005883a 	mov	r2,zero
 202476c:	00001306 	br	20247bc <ip2mac+0x17c>
   }

   /* don't allow unicast sends if NIC iface has no IP address. This
    * is to prevent DHCP clients from sending prior to assignment.
    */
   if (pkt->net->n_ipaddr == 0L)
 2024770:	e0bffe17 	ldw	r2,-8(fp)
 2024774:	10800617 	ldw	r2,24(r2)
 2024778:	10800a17 	ldw	r2,40(r2)
 202477c:	10000c1e 	bne	r2,zero,20247b0 <ip2mac+0x170>
   {
      if (pkt->fhost != 0xFFFFFFFF) /* check for broadcast packet */
 2024780:	e0bffe17 	ldw	r2,-8(fp)
 2024784:	10800717 	ldw	r2,28(r2)
 2024788:	10bfffe0 	cmpeqi	r2,r2,-1
 202478c:	1000081e 	bne	r2,zero,20247b0 <ip2mac+0x170>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 2024790:	01000084 	movi	r4,2
 2024794:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 2024798:	e13ffe17 	ldw	r4,-8(fp)
 202479c:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20247a0:	01000084 	movi	r4,2
 20247a4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return ENP_SENDERR;
 20247a8:	00bff884 	movi	r2,-30
 20247ac:	00000306 	br	20247bc <ip2mac+0x17c>
      }
   }

#ifdef INCLUDE_ARP   /* must be ethernet or token ring */
   return(send_via_arp(pkt, dest_ip));
 20247b0:	e13ffe17 	ldw	r4,-8(fp)
 20247b4:	e17fff17 	ldw	r5,-4(fp)
 20247b8:	203eba80 	call	203eba8 <send_via_arp>
#else
   dtrap();    /* Bad option combination? */
   return ENP_NO_IFACE; /* sent to unknown interface type */
#endif   /* INCLUDE_ARP */
}
 20247bc:	e037883a 	mov	sp,fp
 20247c0:	dfc00117 	ldw	ra,4(sp)
 20247c4:	df000017 	ldw	fp,0(sp)
 20247c8:	dec00204 	addi	sp,sp,8
 20247cc:	f800283a 	ret

020247d0 <ip_startup>:
 * RETURNS: returns NULL if OK, or text of an error message 
 */

char *   
ip_startup()
{
 20247d0:	defffc04 	addi	sp,sp,-16
 20247d4:	dfc00315 	stw	ra,12(sp)
 20247d8:	df000215 	stw	fp,8(sp)
 20247dc:	df000204 	addi	fp,sp,8
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 20247e0:	e03ffe15 	stw	zero,-8(fp)
 20247e4:	00002a06 	br	2024890 <ip_startup+0xc0>
   {
      nets[i] = &netstatic[i];   /* set up array of pointers */
 20247e8:	e0bffe17 	ldw	r2,-8(fp)
 20247ec:	10c03024 	muli	r3,r2,192
 20247f0:	00809934 	movhi	r2,612
 20247f4:	10b50104 	addi	r2,r2,-11260
 20247f8:	1887883a 	add	r3,r3,r2
 20247fc:	01009934 	movhi	r4,612
 2024800:	2135c104 	addi	r4,r4,-10492
 2024804:	e0bffe17 	ldw	r2,-8(fp)
 2024808:	1085883a 	add	r2,r2,r2
 202480c:	1085883a 	add	r2,r2,r2
 2024810:	2085883a 	add	r2,r4,r2
 2024814:	10c00015 	stw	r3,0(r2)
      nets[i]->n_mib = &nets[i]->mib;   /* set mib pointer */
 2024818:	00c09934 	movhi	r3,612
 202481c:	18f5c104 	addi	r3,r3,-10492
 2024820:	e0bffe17 	ldw	r2,-8(fp)
 2024824:	1085883a 	add	r2,r2,r2
 2024828:	1085883a 	add	r2,r2,r2
 202482c:	1885883a 	add	r2,r3,r2
 2024830:	10c00017 	ldw	r3,0(r2)
 2024834:	01009934 	movhi	r4,612
 2024838:	2135c104 	addi	r4,r4,-10492
 202483c:	e0bffe17 	ldw	r2,-8(fp)
 2024840:	1085883a 	add	r2,r2,r2
 2024844:	1085883a 	add	r2,r2,r2
 2024848:	2085883a 	add	r2,r4,r2
 202484c:	10800017 	ldw	r2,0(r2)
 2024850:	10801204 	addi	r2,r2,72
 2024854:	18802715 	stw	r2,156(r3)

      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
 2024858:	00c09934 	movhi	r3,612
 202485c:	18f5c104 	addi	r3,r3,-10492
 2024860:	e0bffe17 	ldw	r2,-8(fp)
 2024864:	1085883a 	add	r2,r2,r2
 2024868:	1085883a 	add	r2,r2,r2
 202486c:	1885883a 	add	r2,r3,r2
 2024870:	10800017 	ldw	r2,0(r2)
 2024874:	01009934 	movhi	r4,612
 2024878:	2137ce04 	addi	r4,r4,-8392
 202487c:	100b883a 	mov	r5,r2
 2024880:	20282880 	call	2028288 <putq>
{
   int   e; /* error holder */
   int   i;

   /* thread nets[] and attach mib data to nets[] arrays */
   for (i = 0; i < STATIC_NETS; i++)
 2024884:	e0bffe17 	ldw	r2,-8(fp)
 2024888:	10800044 	addi	r2,r2,1
 202488c:	e0bffe15 	stw	r2,-8(fp)
 2024890:	e0bffe17 	ldw	r2,-8(fp)
 2024894:	10800110 	cmplti	r2,r2,4
 2024898:	103fd31e 	bne	r2,zero,20247e8 <ip_startup+0x18>
      /* add static iface to end of nets list */
      putq(&netlist, nets[i]);
   }

   /* call port routine to locate and init network interfaces. */
   ifNumber = (unsigned)prep_ifaces(ifNumber);
 202489c:	d0a08917 	ldw	r2,-32220(gp)
 20248a0:	1009883a 	mov	r4,r2
 20248a4:	20441480 	call	2044148 <prep_ifaces>
 20248a8:	d0a08915 	stw	r2,-32220(gp)

   if (ifNumber < 1)    /* no static interfaces? */
 20248ac:	d0a08917 	ldw	r2,-32220(gp)
 20248b0:	1000031e 	bne	r2,zero,20248c0 <ip_startup+0xf0>
#ifdef DYNAMIC_IFACES
      /* print a debug message and hope user knows what he's doing */
      dprintf("unable to find any working interfaces");
#else /* static ifaces only */
      /* no static and no dynamic interfaces is probably a bug... */
      return("unable to find any working interfaces");
 20248b4:	00808174 	movhi	r2,517
 20248b8:	10b9e604 	addi	r2,r2,-6248
 20248bc:	00006806 	br	2024a60 <ip_startup+0x290>
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 20248c0:	d0a08917 	ldw	r2,-32220(gp)
 20248c4:	e0bffe15 	stw	r2,-8(fp)
 20248c8:	00001506 	br	2024920 <ip_startup+0x150>
   {
      qdel(&netlist, (qp)nets[i]);  /* remove from queue */
 20248cc:	00c09934 	movhi	r3,612
 20248d0:	18f5c104 	addi	r3,r3,-10492
 20248d4:	e0bffe17 	ldw	r2,-8(fp)
 20248d8:	1085883a 	add	r2,r2,r2
 20248dc:	1085883a 	add	r2,r2,r2
 20248e0:	1885883a 	add	r2,r3,r2
 20248e4:	10800017 	ldw	r2,0(r2)
 20248e8:	01009934 	movhi	r4,612
 20248ec:	2137ce04 	addi	r4,r4,-8392
 20248f0:	100b883a 	mov	r5,r2
 20248f4:	20283340 	call	2028334 <qdel>
      nets[i] = NULL;               /* remove from array */
 20248f8:	00c09934 	movhi	r3,612
 20248fc:	18f5c104 	addi	r3,r3,-10492
 2024900:	e0bffe17 	ldw	r2,-8(fp)
 2024904:	1085883a 	add	r2,r2,r2
 2024908:	1085883a 	add	r2,r2,r2
 202490c:	1885883a 	add	r2,r3,r2
 2024910:	10000015 	stw	zero,0(r2)
      return("unable to find any working interfaces");
#endif   /* DYNAMIC_IFACES */
   }

   /* throw away any unused static nets */
   for (i = ifNumber; i < STATIC_NETS; i++)
 2024914:	e0bffe17 	ldw	r2,-8(fp)
 2024918:	10800044 	addi	r2,r2,1
 202491c:	e0bffe15 	stw	r2,-8(fp)
 2024920:	e0bffe17 	ldw	r2,-8(fp)
 2024924:	10800110 	cmplti	r2,r2,4
 2024928:	103fe81e 	bne	r2,zero,20248cc <ip_startup+0xfc>
   /* The sequence of events when initing the net & interface systems 
    * is very important. Be very carefull about altering the order of 
    * the following statements. 
    */
   /* once these are done, we should call ip_exit before quiting IP */
   clock_init();           /* start clock system */
 202492c:	20286f80 	call	20286f8 <clock_init>
   exit_hook(clock_c);
 2024930:	010080f4 	movhi	r4,515
 2024934:	2121cd04 	addi	r4,r4,-30924
 2024938:	2024a740 	call	2024a74 <exit_hook>

   e = Netinit();    /* start net interface(s) */
 202493c:	20239b00 	call	20239b0 <Netinit>
 2024940:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 2024944:	e0bfff17 	ldw	r2,-4(fp)
 2024948:	10000326 	beq	r2,zero,2024958 <ip_startup+0x188>
   {
      return("unable to initialize net");
 202494c:	00808174 	movhi	r2,517
 2024950:	10b9f004 	addi	r2,r2,-6208
 2024954:	00004206 	br	2024a60 <ip_startup+0x290>
   }

#ifdef INCLUDE_ARP
   e = etainit();          /* startup ARP layer */
 2024958:	203dca40 	call	203dca4 <etainit>
 202495c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 2024960:	e0bfff17 	ldw	r2,-4(fp)
 2024964:	10000426 	beq	r2,zero,2024978 <ip_startup+0x1a8>
   {
      ip_exit();
 2024968:	2024ae00 	call	2024ae0 <ip_exit>
      return("unable to initialize arp");
 202496c:	00808174 	movhi	r2,517
 2024970:	10b9f704 	addi	r2,r2,-6180
 2024974:	00003a06 	br	2024a60 <ip_startup+0x290>
   }
#endif

#ifdef IP_V4
   e = ip_init();       /* start up IP layer */
 2024978:	203f3cc0 	call	203f3cc <ip_init>
 202497c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 2024980:	e0bfff17 	ldw	r2,-4(fp)
 2024984:	10000426 	beq	r2,zero,2024998 <ip_startup+0x1c8>
   {
      ip_exit();
 2024988:	2024ae00 	call	2024ae0 <ip_exit>
      return("unable to initialize IP");
 202498c:	00808174 	movhi	r2,517
 2024990:	10b9fe04 	addi	r2,r2,-6152
 2024994:	00003206 	br	2024a60 <ip_startup+0x290>

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Join the All hosts group on every interface that IP multicast is
    * supported
    */
   e = igmp_init();         /* Initialize igmp */
 2024998:	2024c300 	call	2024c30 <igmp_init>
 202499c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 20249a0:	e0bfff17 	ldw	r2,-4(fp)
 20249a4:	10000326 	beq	r2,zero,20249b4 <ip_startup+0x1e4>
   {
      ip_exit();
 20249a8:	2024ae00 	call	2024ae0 <ip_exit>
      return(ipmcfail_str);
 20249ac:	d0a03917 	ldw	r2,-32540(gp)
 20249b0:	00002b06 	br	2024a60 <ip_startup+0x290>
   }

   for (i = 0; i < (int)ifNumber; i++)
 20249b4:	e03ffe15 	stw	zero,-8(fp)
 20249b8:	00001c06 	br	2024a2c <ip_startup+0x25c>
   {
      if (nets[i]->n_mcastlist != NULL)
 20249bc:	00c09934 	movhi	r3,612
 20249c0:	18f5c104 	addi	r3,r3,-10492
 20249c4:	e0bffe17 	ldw	r2,-8(fp)
 20249c8:	1085883a 	add	r2,r2,r2
 20249cc:	1085883a 	add	r2,r2,r2
 20249d0:	1885883a 	add	r2,r3,r2
 20249d4:	10800017 	ldw	r2,0(r2)
 20249d8:	10802b17 	ldw	r2,172(r2)
 20249dc:	10001026 	beq	r2,zero,2024a20 <ip_startup+0x250>
         if ((in_addmulti(&igmp_all_hosts_group, nets[i], 4) == NULL))
 20249e0:	00c09934 	movhi	r3,612
 20249e4:	18f5c104 	addi	r3,r3,-10492
 20249e8:	e0bffe17 	ldw	r2,-8(fp)
 20249ec:	1085883a 	add	r2,r2,r2
 20249f0:	1085883a 	add	r2,r2,r2
 20249f4:	1885883a 	add	r2,r3,r2
 20249f8:	10800017 	ldw	r2,0(r2)
 20249fc:	01008174 	movhi	r4,517
 2024a00:	2110b704 	addi	r4,r4,17116
 2024a04:	100b883a 	mov	r5,r2
 2024a08:	01800104 	movi	r6,4
 2024a0c:	2043e900 	call	2043e90 <in_addmulti>
 2024a10:	1000031e 	bne	r2,zero,2024a20 <ip_startup+0x250>
      {
         ip_exit();
 2024a14:	2024ae00 	call	2024ae0 <ip_exit>
         return(ipmcfail_str);
 2024a18:	d0a03917 	ldw	r2,-32540(gp)
 2024a1c:	00001006 	br	2024a60 <ip_startup+0x290>
   {
      ip_exit();
      return(ipmcfail_str);
   }

   for (i = 0; i < (int)ifNumber; i++)
 2024a20:	e0bffe17 	ldw	r2,-8(fp)
 2024a24:	10800044 	addi	r2,r2,1
 2024a28:	e0bffe15 	stw	r2,-8(fp)
 2024a2c:	d0a08917 	ldw	r2,-32220(gp)
 2024a30:	e0fffe17 	ldw	r3,-8(fp)
 2024a34:	18bfe116 	blt	r3,r2,20249bc <ip_startup+0x1ec>
      }
   }
#endif /* IP_MULTICAST and (IGMPv1 or IGMPv2) */   

#ifdef INCLUDE_TCP
   e = tcpinit();
 2024a38:	20360480 	call	2036048 <tcpinit>
 2024a3c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 2024a40:	e0bfff17 	ldw	r2,-4(fp)
 2024a44:	10000426 	beq	r2,zero,2024a58 <ip_startup+0x288>
   {
      ip_exit();
 2024a48:	2024ae00 	call	2024ae0 <ip_exit>
      return("unable to initialize TCP");
 2024a4c:	00808174 	movhi	r2,517
 2024a50:	10ba0404 	addi	r2,r2,-6128
 2024a54:	00000206 	br	2024a60 <ip_startup+0x290>
   /* setup event map for (UDP and TCP) socket library's events (such as 
    * those used by tcp_sleep () and tcp_wakeup ()).  These events either 
    * map into operating system primitives such as events or semaphores, 
    * or into task suspend and task resume mechanisms.
    */
   evtmap_setup ();
 2024a58:	20441f80 	call	20441f8 <evtmap_setup>
      return("unable to initialize IP Filter table");
   else
      exit_hook(ipf_cleanup);
#endif

   return(NULL);     /* we got through with no errors */
 2024a5c:	0005883a 	mov	r2,zero
}
 2024a60:	e037883a 	mov	sp,fp
 2024a64:	dfc00117 	ldw	ra,4(sp)
 2024a68:	df000017 	ldw	fp,0(sp)
 2024a6c:	dec00204 	addi	sp,sp,8
 2024a70:	f800283a 	ret

02024a74 <exit_hook>:
 * RETURNS: 
 */

void
exit_hook(void (*func)(void))
{
 2024a74:	defffd04 	addi	sp,sp,-12
 2024a78:	dfc00215 	stw	ra,8(sp)
 2024a7c:	df000115 	stw	fp,4(sp)
 2024a80:	df000104 	addi	fp,sp,4
 2024a84:	e13fff15 	stw	r4,-4(fp)
   if (nclosers >= (NUMCLOSERS-1))
 2024a88:	d0a08a17 	ldw	r2,-32216(gp)
 2024a8c:	10800390 	cmplti	r2,r2,14
 2024a90:	1000031e 	bne	r2,zero,2024aa0 <exit_hook+0x2c>
      panic("exit_hook");
 2024a94:	01008174 	movhi	r4,517
 2024a98:	213a0b04 	addi	r4,r4,-6100
 2024a9c:	2026bf80 	call	2026bf8 <panic>

   closers[++nclosers] = func;
 2024aa0:	d0a08a17 	ldw	r2,-32216(gp)
 2024aa4:	10800044 	addi	r2,r2,1
 2024aa8:	d0a08a15 	stw	r2,-32216(gp)
 2024aac:	d0a08a17 	ldw	r2,-32216(gp)
 2024ab0:	00c081b4 	movhi	r3,518
 2024ab4:	18c3cc04 	addi	r3,r3,3888
 2024ab8:	1085883a 	add	r2,r2,r2
 2024abc:	1085883a 	add	r2,r2,r2
 2024ac0:	1885883a 	add	r2,r3,r2
 2024ac4:	e0ffff17 	ldw	r3,-4(fp)
 2024ac8:	10c00015 	stw	r3,0(r2)
}
 2024acc:	e037883a 	mov	sp,fp
 2024ad0:	dfc00117 	ldw	ra,4(sp)
 2024ad4:	df000017 	ldw	fp,0(sp)
 2024ad8:	dec00204 	addi	sp,sp,8
 2024adc:	f800283a 	ret

02024ae0 <ip_exit>:
 * RETURNS: void
 */

void
ip_exit()
{
 2024ae0:	defffd04 	addi	sp,sp,-12
 2024ae4:	dfc00215 	stw	ra,8(sp)
 2024ae8:	df000115 	stw	fp,4(sp)
 2024aec:	df000104 	addi	fp,sp,4
   int   n;

   for (n=nclosers; n; n--)
 2024af0:	d0a08a17 	ldw	r2,-32216(gp)
 2024af4:	e0bfff15 	stw	r2,-4(fp)
 2024af8:	00002506 	br	2024b90 <ip_exit+0xb0>
   {
#ifdef NPDEBUG
      dprintf("ip_exit: calling func %p\n", closers[n]);
 2024afc:	00c081b4 	movhi	r3,518
 2024b00:	18c3cc04 	addi	r3,r3,3888
 2024b04:	e0bfff17 	ldw	r2,-4(fp)
 2024b08:	1085883a 	add	r2,r2,r2
 2024b0c:	1085883a 	add	r2,r2,r2
 2024b10:	1885883a 	add	r2,r3,r2
 2024b14:	10800017 	ldw	r2,0(r2)
 2024b18:	01008174 	movhi	r4,517
 2024b1c:	213a0e04 	addi	r4,r4,-6088
 2024b20:	100b883a 	mov	r5,r2
 2024b24:	2006a240 	call	2006a24 <printf>
#endif
      if(closers[n])
 2024b28:	00c081b4 	movhi	r3,518
 2024b2c:	18c3cc04 	addi	r3,r3,3888
 2024b30:	e0bfff17 	ldw	r2,-4(fp)
 2024b34:	1085883a 	add	r2,r2,r2
 2024b38:	1085883a 	add	r2,r2,r2
 2024b3c:	1885883a 	add	r2,r3,r2
 2024b40:	10800017 	ldw	r2,0(r2)
 2024b44:	10000f26 	beq	r2,zero,2024b84 <ip_exit+0xa4>
      {
         (*closers[n])();
 2024b48:	00c081b4 	movhi	r3,518
 2024b4c:	18c3cc04 	addi	r3,r3,3888
 2024b50:	e0bfff17 	ldw	r2,-4(fp)
 2024b54:	1085883a 	add	r2,r2,r2
 2024b58:	1085883a 	add	r2,r2,r2
 2024b5c:	1885883a 	add	r2,r3,r2
 2024b60:	10800017 	ldw	r2,0(r2)
 2024b64:	103ee83a 	callr	r2
         closers[n] = NULL;
 2024b68:	00c081b4 	movhi	r3,518
 2024b6c:	18c3cc04 	addi	r3,r3,3888
 2024b70:	e0bfff17 	ldw	r2,-4(fp)
 2024b74:	1085883a 	add	r2,r2,r2
 2024b78:	1085883a 	add	r2,r2,r2
 2024b7c:	1885883a 	add	r2,r3,r2
 2024b80:	10000015 	stw	zero,0(r2)
void
ip_exit()
{
   int   n;

   for (n=nclosers; n; n--)
 2024b84:	e0bfff17 	ldw	r2,-4(fp)
 2024b88:	10bfffc4 	addi	r2,r2,-1
 2024b8c:	e0bfff15 	stw	r2,-4(fp)
 2024b90:	e0bfff17 	ldw	r2,-4(fp)
 2024b94:	103fd91e 	bne	r2,zero,2024afc <ip_exit+0x1c>
      {
         (*closers[n])();
         closers[n] = NULL;
      }
   }
}
 2024b98:	e037883a 	mov	sp,fp
 2024b9c:	dfc00117 	ldw	ra,4(sp)
 2024ba0:	df000017 	ldw	fp,0(sp)
 2024ba4:	dec00204 	addi	sp,sp,8
 2024ba8:	f800283a 	ret

02024bac <if_netnumber>:
 * RETURNS: net index for passed net pointer
 */

int
if_netnumber(NET nptr)
{
 2024bac:	defffb04 	addi	sp,sp,-20
 2024bb0:	dfc00415 	stw	ra,16(sp)
 2024bb4:	df000315 	stw	fp,12(sp)
 2024bb8:	df000304 	addi	fp,sp,12
 2024bbc:	e13fff15 	stw	r4,-4(fp)
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 2024bc0:	00809934 	movhi	r2,612
 2024bc4:	10b7ce04 	addi	r2,r2,-8392
 2024bc8:	10800017 	ldw	r2,0(r2)
 2024bcc:	e0bffe15 	stw	r2,-8(fp)
 2024bd0:	e03ffd15 	stw	zero,-12(fp)
 2024bd4:	00000b06 	br	2024c04 <if_netnumber+0x58>
   {
      if(ifp == nptr)
 2024bd8:	e0fffe17 	ldw	r3,-8(fp)
 2024bdc:	e0bfff17 	ldw	r2,-4(fp)
 2024be0:	1880021e 	bne	r3,r2,2024bec <if_netnumber+0x40>
        return (int)i;
 2024be4:	e0bffd17 	ldw	r2,-12(fp)
 2024be8:	00000c06 	br	2024c1c <if_netnumber+0x70>
if_netnumber(NET nptr)
{
   unsigned i;
   NET ifp;

   for(ifp = (NET)(netlist.q_head), i = 0; ifp; ifp = ifp->n_next, i++)
 2024bec:	e0bffe17 	ldw	r2,-8(fp)
 2024bf0:	10800017 	ldw	r2,0(r2)
 2024bf4:	e0bffe15 	stw	r2,-8(fp)
 2024bf8:	e0bffd17 	ldw	r2,-12(fp)
 2024bfc:	10800044 	addi	r2,r2,1
 2024c00:	e0bffd15 	stw	r2,-12(fp)
 2024c04:	e0bffe17 	ldw	r2,-8(fp)
 2024c08:	103ff31e 	bne	r2,zero,2024bd8 <if_netnumber+0x2c>
   {
      if(ifp == nptr)
        return (int)i;
   }

   panic("bad net ptr");
 2024c0c:	01008174 	movhi	r4,517
 2024c10:	213a1504 	addi	r4,r4,-6060
 2024c14:	2026bf80 	call	2026bf8 <panic>
   return 0;
 2024c18:	0005883a 	mov	r2,zero
}
 2024c1c:	e037883a 	mov	sp,fp
 2024c20:	dfc00117 	ldw	ra,4(sp)
 2024c24:	df000017 	ldw	fp,0(sp)
 2024c28:	dec00204 	addi	sp,sp,8
 2024c2c:	f800283a 	ret

02024c30 <igmp_init>:
 *
 * OUTPUT: None.
 */

int igmp_init(void)
{
 2024c30:	defffd04 	addi	sp,sp,-12
 2024c34:	dfc00215 	stw	ra,8(sp)
 2024c38:	df000115 	stw	fp,4(sp)
 2024c3c:	df000104 	addi	fp,sp,4
   NET ifp;

   /*
    * To avoid byte-swapping the same value over and over again.
    */
   igmp_all_hosts_group = htonl(INADDR_ALLHOSTS_GROUP);
 2024c40:	00804034 	movhi	r2,256
 2024c44:	10803804 	addi	r2,r2,224
 2024c48:	d0a08d15 	stw	r2,-32204(gp)
   igmp_all_rtrs_group = htonl(INADDR_ALLRTRS_GROUP);
 2024c4c:	00808034 	movhi	r2,512
 2024c50:	10803804 	addi	r2,r2,224
 2024c54:	d0a08e15 	stw	r2,-32200(gp)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 2024c58:	00809934 	movhi	r2,612
 2024c5c:	10b7ce04 	addi	r2,r2,-8392
 2024c60:	10800017 	ldw	r2,0(r2)
 2024c64:	e0bfff15 	stw	r2,-4(fp)
 2024c68:	00001006 	br	2024cac <igmp_init+0x7c>
   {
      if (ifp->igmp_oper_mode == IGMP_MODE_V1)
 2024c6c:	e0bfff17 	ldw	r2,-4(fp)
 2024c70:	10802f03 	ldbu	r2,188(r2)
 2024c74:	10803fcc 	andi	r2,r2,255
 2024c78:	10800058 	cmpnei	r2,r2,1
 2024c7c:	1000041e 	bne	r2,zero,2024c90 <igmp_init+0x60>
      {
         ifp->igmpv1_rtr_present = 1;
 2024c80:	e0bfff17 	ldw	r2,-4(fp)
 2024c84:	00c00044 	movi	r3,1
 2024c88:	10c02d05 	stb	r3,180(r2)
 2024c8c:	00000406 	br	2024ca0 <igmp_init+0x70>
      }
      else
      {
         ifp->igmpv1_rtr_present = 0;
 2024c90:	e0bfff17 	ldw	r2,-4(fp)
 2024c94:	10002d05 	stb	zero,180(r2)
         /* not really required, only referred to if IGMPv1 router is 
          * "present" */
         ifp->igmpv1_query_rcvd_time = 0;
 2024c98:	e0bfff17 	ldw	r2,-4(fp)
 2024c9c:	10002e15 	stw	zero,184(r2)
   /* note that the IGMP operational mode configuration for a
    * given link (i.e., whether it should run IGMPv1 or IGMPv2)
    * has already been validated, so no additional checks are 
    * required here. 
    */
   for (ifp = (NET) netlist.q_head; ifp; ifp = ifp->n_next)
 2024ca0:	e0bfff17 	ldw	r2,-4(fp)
 2024ca4:	10800017 	ldw	r2,0(r2)
 2024ca8:	e0bfff15 	stw	r2,-4(fp)
 2024cac:	e0bfff17 	ldw	r2,-4(fp)
 2024cb0:	103fee1e 	bne	r2,zero,2024c6c <igmp_init+0x3c>
   }

   /*
    * Call igmp_fasttimo PR_FASTHZ (5) times per second
    */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 2024cb4:	00808174 	movhi	r2,517
 2024cb8:	1090c904 	addi	r2,r2,17188
 2024cbc:	10800017 	ldw	r2,0(r2)
 2024cc0:	1009883a 	mov	r4,r2
 2024cc4:	20145600 	call	2014560 <__floatunsidf>
 2024cc8:	100b883a 	mov	r5,r2
 2024ccc:	180d883a 	mov	r6,r3
 2024cd0:	2809883a 	mov	r4,r5
 2024cd4:	300b883a 	mov	r5,r6
 2024cd8:	000d883a 	mov	r6,zero
 2024cdc:	01d00d34 	movhi	r7,16436
 2024ce0:	2013bd40 	call	2013bd4 <__adddf3>
 2024ce4:	1009883a 	mov	r4,r2
 2024ce8:	180b883a 	mov	r5,r3
 2024cec:	2005883a 	mov	r2,r4
 2024cf0:	2807883a 	mov	r3,r5
 2024cf4:	1009883a 	mov	r4,r2
 2024cf8:	180b883a 	mov	r5,r3
 2024cfc:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 2024d00:	d0a08c15 	stw	r2,-32208(gp)

   /* there are no timers running initially */
   igmp_timers_are_running = 0;
 2024d04:	d0208b15 	stw	zero,-32212(gp)

   return IGMP_OK;
 2024d08:	0005883a 	mov	r2,zero
}
 2024d0c:	e037883a 	mov	sp,fp
 2024d10:	dfc00117 	ldw	ra,4(sp)
 2024d14:	df000017 	ldw	fp,0(sp)
 2024d18:	dec00204 	addi	sp,sp,8
 2024d1c:	f800283a 	ret

02024d20 <igmp_input>:
 * returned if the operating mode is not correctly configured
 * to a valid IGMP operating mode.
 */

int igmp_input (PACKET p)
{
 2024d20:	defffb04 	addi	sp,sp,-20
 2024d24:	dfc00415 	stw	ra,16(sp)
 2024d28:	df000315 	stw	fp,12(sp)
 2024d2c:	df000304 	addi	fp,sp,12
 2024d30:	e13fff15 	stw	r4,-4(fp)
   u_char mode;
   int rc;
     
   ++igmpstats.igmp_total_rcvd;
 2024d34:	00809934 	movhi	r2,612
 2024d38:	10b5c504 	addi	r2,r2,-10476
 2024d3c:	10800017 	ldw	r2,0(r2)
 2024d40:	10c00044 	addi	r3,r2,1
 2024d44:	00809934 	movhi	r2,612
 2024d48:	10b5c504 	addi	r2,r2,-10476
 2024d4c:	10c00015 	stw	r3,0(r2)
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 2024d50:	e13fff17 	ldw	r4,-4(fp)
 2024d54:	20255a40 	call	20255a4 <igmp_validate>
 2024d58:	e0bffd15 	stw	r2,-12(fp)
 2024d5c:	e0bffd17 	ldw	r2,-12(fp)
 2024d60:	10001a1e 	bne	r2,zero,2024dcc <igmp_input+0xac>

   /* determine the operating mode for IGMP on the ingress link */
   mode = p->net->igmp_oper_mode;
 2024d64:	e0bfff17 	ldw	r2,-4(fp)
 2024d68:	10800617 	ldw	r2,24(r2)
 2024d6c:	10802f03 	ldbu	r2,188(r2)
 2024d70:	e0bffe05 	stb	r2,-8(fp)
   
   /* feed packet to IGMPv1 or IGMPv2 code based on the operating
    * mode of the ingress link */
   switch (mode)
 2024d74:	e0bffe03 	ldbu	r2,-8(fp)
 2024d78:	10c00060 	cmpeqi	r3,r2,1
 2024d7c:	1800031e 	bne	r3,zero,2024d8c <igmp_input+0x6c>
 2024d80:	108000a0 	cmpeqi	r2,r2,2
 2024d84:	1000041e 	bne	r2,zero,2024d98 <igmp_input+0x78>
 2024d88:	00000606 	br	2024da4 <igmp_input+0x84>
   {
#ifdef IGMP_V1   
      case IGMP_MODE_V1:   
         return (igmpv1_input (p)); 
 2024d8c:	e13fff17 	ldw	r4,-4(fp)
 2024d90:	2045b6c0 	call	2045b6c <igmpv1_input>
 2024d94:	00001506 	br	2024dec <igmp_input+0xcc>
#endif
#ifdef IGMP_V2         
      case IGMP_MODE_V2:       
         return (igmpv2_input (p));
 2024d98:	e13fff17 	ldw	r4,-4(fp)
 2024d9c:	2045e380 	call	2045e38 <igmpv2_input>
 2024da0:	00001206 	br	2024dec <igmp_input+0xcc>
#endif
      default:
         ++igmpstats.igmp_bad_oper_mode;     
 2024da4:	00809934 	movhi	r2,612
 2024da8:	10b5c504 	addi	r2,r2,-10476
 2024dac:	10800d17 	ldw	r2,52(r2)
 2024db0:	10c00044 	addi	r3,r2,1
 2024db4:	00809934 	movhi	r2,612
 2024db8:	10b5c504 	addi	r2,r2,-10476
 2024dbc:	10c00d15 	stw	r3,52(r2)
         rc = IGMP_ERR;
 2024dc0:	00bfffc4 	movi	r2,-1
 2024dc4:	e0bffd15 	stw	r2,-12(fp)
         break;
 2024dc8:	00000106 	br	2024dd0 <igmp_input+0xb0>
     
   ++igmpstats.igmp_total_rcvd;
   
   /* validate the received packet; if validation fails,
    * drop the packet and return */
   if ((rc = igmp_validate (p)) != IGMP_OK) goto end;
 2024dcc:	0001883a 	nop
         break;
   }
   
end:   
   /* return packet buffer back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2024dd0:	01000084 	movi	r4,2
 2024dd4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 2024dd8:	e13fff17 	ldw	r4,-4(fp)
 2024ddc:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2024de0:	01000084 	movi	r4,2
 2024de4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      
   return rc;
 2024de8:	e0bffd17 	ldw	r2,-12(fp)
}
 2024dec:	e037883a 	mov	sp,fp
 2024df0:	dfc00117 	ldw	ra,4(sp)
 2024df4:	df000017 	ldw	fp,0(sp)
 2024df8:	dec00204 	addi	sp,sp,8
 2024dfc:	f800283a 	ret

02024e00 <igmp_fasttimo>:
 *
 * OUTPUT: None.
 */

void igmp_fasttimo (void)
{
 2024e00:	defffa04 	addi	sp,sp,-24
 2024e04:	dfc00515 	stw	ra,20(sp)
 2024e08:	df000415 	stw	fp,16(sp)
 2024e0c:	dc400315 	stw	r17,12(sp)
 2024e10:	dc000215 	stw	r16,8(sp)
 2024e14:	df000204 	addi	fp,sp,8
   struct in_multi * inm;
   NET ifp;
     
   LOCK_NET_RESOURCE (NET_RESID);
 2024e18:	0009883a 	mov	r4,zero
 2024e1c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   
   /*
    * Quick check to see if any work needs to be done, in order
    * to minimize the overhead of fasttimo processing.
    */
   if (!igmp_timers_are_running)
 2024e20:	d0a08b17 	ldw	r2,-32212(gp)
 2024e24:	1000031e 	bne	r2,zero,2024e34 <igmp_fasttimo+0x34>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
 2024e28:	0009883a 	mov	r4,zero
 2024e2c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return;
 2024e30:	00007506 	br	2025008 <igmp_fasttimo+0x208>
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 2024e34:	00809934 	movhi	r2,612
 2024e38:	10b7ce04 	addi	r2,r2,-8392
 2024e3c:	10800017 	ldw	r2,0(r2)
 2024e40:	e0bfff15 	stw	r2,-4(fp)
 2024e44:	00005706 	br	2024fa4 <igmp_fasttimo+0x1a4>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 2024e48:	e0bfff17 	ldw	r2,-4(fp)
 2024e4c:	10802c17 	ldw	r2,176(r2)
 2024e50:	e0bffe15 	stw	r2,-8(fp)
 2024e54:	00004e06 	br	2024f90 <igmp_fasttimo+0x190>
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
 2024e58:	e0bffe17 	ldw	r2,-8(fp)
 2024e5c:	10800017 	ldw	r2,0(r2)
 2024e60:	10004726 	beq	r2,zero,2024f80 <igmp_fasttimo+0x180>
               continue;

         if (inm->inm_timer == 0)   /* timer not set */
 2024e64:	e0bffe17 	ldw	r2,-8(fp)
 2024e68:	10800317 	ldw	r2,12(r2)
 2024e6c:	10004526 	beq	r2,zero,2024f84 <igmp_fasttimo+0x184>
         {
            /* do nothing */
         }
         else if (--inm->inm_timer == 0)  /* timer expired */
 2024e70:	e0bffe17 	ldw	r2,-8(fp)
 2024e74:	10800317 	ldw	r2,12(r2)
 2024e78:	10ffffc4 	addi	r3,r2,-1
 2024e7c:	e0bffe17 	ldw	r2,-8(fp)
 2024e80:	10c00315 	stw	r3,12(r2)
 2024e84:	e0bffe17 	ldw	r2,-8(fp)
 2024e88:	10800317 	ldw	r2,12(r2)
 2024e8c:	10003d1e 	bne	r2,zero,2024f84 <igmp_fasttimo+0x184>
         {
            /* send membership report in appropriate format */
            if (ifp->igmpv1_rtr_present)
 2024e90:	e0bfff17 	ldw	r2,-4(fp)
 2024e94:	10802d03 	ldbu	r2,180(r2)
 2024e98:	10803fcc 	andi	r2,r2,255
 2024e9c:	10000426 	beq	r2,zero,2024eb0 <igmp_fasttimo+0xb0>
            {
               /* always true for IGMPv1, may be true for IGMPv2 */
               igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 2024ea0:	01000484 	movi	r4,18
 2024ea4:	e17ffe17 	ldw	r5,-8(fp)
 2024ea8:	20250240 	call	2025024 <igmp_send>
 2024eac:	00000306 	br	2024ebc <igmp_fasttimo+0xbc>
            }
            else
            {
               igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 2024eb0:	01000584 	movi	r4,22
 2024eb4:	e17ffe17 	ldw	r5,-8(fp)
 2024eb8:	20250240 	call	2025024 <igmp_send>

            /* for IGMPv2, indicate that we were the last to send 
             * a Report for this multicast group (relevant for 
             * IGMPv2 only).  also check to see if we should mark 
             * the IGMPv1 router as "absent". */
            if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 2024ebc:	e0bfff17 	ldw	r2,-4(fp)
 2024ec0:	10802f03 	ldbu	r2,188(r2)
 2024ec4:	10803fcc 	andi	r2,r2,255
 2024ec8:	10800098 	cmpnei	r2,r2,2
 2024ecc:	1000281e 	bne	r2,zero,2024f70 <igmp_fasttimo+0x170>
            {
               inm->last2send_report = IGMP_TRUE;
 2024ed0:	e0bffe17 	ldw	r2,-8(fp)
 2024ed4:	00c00044 	movi	r3,1
 2024ed8:	10c00405 	stb	r3,16(r2)
               
               if (ifp->igmpv1_rtr_present)
 2024edc:	e0bfff17 	ldw	r2,-4(fp)
 2024ee0:	10802d03 	ldbu	r2,180(r2)
 2024ee4:	10803fcc 	andi	r2,r2,255
 2024ee8:	10002126 	beq	r2,zero,2024f70 <igmp_fasttimo+0x170>
               {
                  if (cticks > (ifp->igmpv1_query_rcvd_time + (IGMPv1_RTR_PRESENT_TMO * TPS)))
 2024eec:	00808174 	movhi	r2,517
 2024ef0:	1090c904 	addi	r2,r2,17188
 2024ef4:	10800017 	ldw	r2,0(r2)
 2024ef8:	1009883a 	mov	r4,r2
 2024efc:	20145600 	call	2014560 <__floatunsidf>
 2024f00:	1021883a 	mov	r16,r2
 2024f04:	1823883a 	mov	r17,r3
 2024f08:	e0bfff17 	ldw	r2,-4(fp)
 2024f0c:	10802e17 	ldw	r2,184(r2)
 2024f10:	1009883a 	mov	r4,r2
 2024f14:	20145600 	call	2014560 <__floatunsidf>
 2024f18:	100b883a 	mov	r5,r2
 2024f1c:	180d883a 	mov	r6,r3
 2024f20:	2809883a 	mov	r4,r5
 2024f24:	300b883a 	mov	r5,r6
 2024f28:	000d883a 	mov	r6,zero
 2024f2c:	01d03934 	movhi	r7,16612
 2024f30:	39e20004 	addi	r7,r7,-30720
 2024f34:	2013bd40 	call	2013bd4 <__adddf3>
 2024f38:	1009883a 	mov	r4,r2
 2024f3c:	180b883a 	mov	r5,r3
 2024f40:	2005883a 	mov	r2,r4
 2024f44:	2807883a 	mov	r3,r5
 2024f48:	8009883a 	mov	r4,r16
 2024f4c:	880b883a 	mov	r5,r17
 2024f50:	100d883a 	mov	r6,r2
 2024f54:	180f883a 	mov	r7,r3
 2024f58:	20141d80 	call	20141d8 <__gtdf2>
 2024f5c:	0080040e 	bge	zero,r2,2024f70 <igmp_fasttimo+0x170>
                     /* we haven't heard from the IGMPv1 router for a duration
                      * greater than or equal to Version 1 Router Present Timeout 
                      * (400 seconds), and will now update the igmpv1_rtr_present 
                      * variable to reflect that.
                      */
                     ifp->igmpv1_rtr_present = IGMP_FALSE;
 2024f60:	e0bfff17 	ldw	r2,-4(fp)
 2024f64:	10002d05 	stb	zero,180(r2)
                     ifp->igmpv1_query_rcvd_time = 0;
 2024f68:	e0bfff17 	ldw	r2,-4(fp)
 2024f6c:	10002e15 	stw	zero,184(r2)
                  }
               }  
            }

            /* decrement the count of running IGMP timers */
            --igmp_timers_are_running;
 2024f70:	d0a08b17 	ldw	r2,-32212(gp)
 2024f74:	10bfffc4 	addi	r2,r2,-1
 2024f78:	d0a08b15 	stw	r2,-32212(gp)
 2024f7c:	00000106 	br	2024f84 <igmp_fasttimo+0x184>
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip IPv6 entries */
         if (inm->inm_addr == 0) 
               continue;
 2024f80:	0001883a 	nop
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      for (inm = ifp->mc_list; inm; inm = inm->inm_next)
 2024f84:	e0bffe17 	ldw	r2,-8(fp)
 2024f88:	10800517 	ldw	r2,20(r2)
 2024f8c:	e0bffe15 	stw	r2,-8(fp)
 2024f90:	e0bffe17 	ldw	r2,-8(fp)
 2024f94:	103fb01e 	bne	r2,zero,2024e58 <igmp_fasttimo+0x58>
   {
      UNLOCK_NET_RESOURCE (NET_RESID);
      return;
   }

   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 2024f98:	e0bfff17 	ldw	r2,-4(fp)
 2024f9c:	10800017 	ldw	r2,0(r2)
 2024fa0:	e0bfff15 	stw	r2,-4(fp)
 2024fa4:	e0bfff17 	ldw	r2,-4(fp)
 2024fa8:	103fa71e 	bne	r2,zero,2024e48 <igmp_fasttimo+0x48>
      }     
   }

   /* Setup time for the next call into igmp_fasttimo ()
    * (200 ms later). */
   igmp_cticks = cticks + TPS/PR_FASTHZ;
 2024fac:	00808174 	movhi	r2,517
 2024fb0:	1090c904 	addi	r2,r2,17188
 2024fb4:	10800017 	ldw	r2,0(r2)
 2024fb8:	1009883a 	mov	r4,r2
 2024fbc:	20145600 	call	2014560 <__floatunsidf>
 2024fc0:	100b883a 	mov	r5,r2
 2024fc4:	180d883a 	mov	r6,r3
 2024fc8:	2809883a 	mov	r4,r5
 2024fcc:	300b883a 	mov	r5,r6
 2024fd0:	000d883a 	mov	r6,zero
 2024fd4:	01d00d34 	movhi	r7,16436
 2024fd8:	2013bd40 	call	2013bd4 <__adddf3>
 2024fdc:	1009883a 	mov	r4,r2
 2024fe0:	180b883a 	mov	r5,r3
 2024fe4:	2005883a 	mov	r2,r4
 2024fe8:	2807883a 	mov	r3,r5
 2024fec:	1009883a 	mov	r4,r2
 2024ff0:	180b883a 	mov	r5,r3
 2024ff4:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 2024ff8:	d0a08c15 	stw	r2,-32208(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 2024ffc:	0009883a 	mov	r4,zero
 2025000:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   
   return;
 2025004:	0001883a 	nop
}
 2025008:	e037883a 	mov	sp,fp
 202500c:	dfc00317 	ldw	ra,12(sp)
 2025010:	df000217 	ldw	fp,8(sp)
 2025014:	dc400117 	ldw	r17,4(sp)
 2025018:	dc000017 	ldw	r16,0(sp)
 202501c:	dec00404 	addi	sp,sp,16
 2025020:	f800283a 	ret

02025024 <igmp_send>:
 *
 * OUTPUT: None.
 */

void igmp_send (u_char type, struct in_multi * inm)
{
 2025024:	deffdd04 	addi	sp,sp,-140
 2025028:	dfc02215 	stw	ra,136(sp)
 202502c:	df002115 	stw	fp,132(sp)
 2025030:	df002104 	addi	fp,sp,132
 2025034:	2005883a 	mov	r2,r4
 2025038:	e17fff15 	stw	r5,-4(fp)
 202503c:	e0bffe05 	stb	r2,-8(fp)
   struct ip_moptions * imop;
   struct ip_moptions simo;
   struct ip * pip;
   int i;
   u_char * tmpp;
   u_char opts [2] = {IP_RTR_ALERT_OPT, EOL_OPT};
 2025040:	00800504 	movi	r2,20
 2025044:	e0bffd05 	stb	r2,-12(fp)
 2025048:	e03ffd45 	stb	zero,-11(fp)
   u_char reqd_len;

   /* compute length of buffer required for outgoing packet.
    * also account for the length of the IP Router Alert 
    * option, if required. */   
   reqd_len = MaxLnh + sizeof (struct ip) + sizeof (struct igmp);
 202504c:	00808174 	movhi	r2,517
 2025050:	1090b004 	addi	r2,r2,17088
 2025054:	10800017 	ldw	r2,0(r2)
 2025058:	10800704 	addi	r2,r2,28
 202505c:	e0bfe105 	stb	r2,-124(fp)
   if ((type == IGMPv2_LEAVE_GROUP) || 
 2025060:	e0bffe03 	ldbu	r2,-8(fp)
 2025064:	108005e0 	cmpeqi	r2,r2,23
 2025068:	1000031e 	bne	r2,zero,2025078 <igmp_send+0x54>
 202506c:	e0bffe03 	ldbu	r2,-8(fp)
 2025070:	10800598 	cmpnei	r2,r2,22
 2025074:	1000031e 	bne	r2,zero,2025084 <igmp_send+0x60>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      reqd_len += IP_RTR_ALERT_OPT_SIZE;
 2025078:	e0bfe103 	ldbu	r2,-124(fp)
 202507c:	10800104 	addi	r2,r2,4
 2025080:	e0bfe105 	stb	r2,-124(fp)
   }

   /* obtain a packet to send the IGMP message */
   LOCK_NET_RESOURCE (FREEQ_RESID);
 2025084:	01000084 	movi	r4,2
 2025088:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   p = pk_alloc (reqd_len);
 202508c:	e0bfe103 	ldbu	r2,-124(fp)
 2025090:	1009883a 	mov	r4,r2
 2025094:	2027cec0 	call	2027cec <pk_alloc>
 2025098:	e0bfe215 	stw	r2,-120(fp)
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 202509c:	01000084 	movi	r4,2
 20250a0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   
   /* log an error and return if the allocation fails */   
   if (!p)
 20250a4:	e0bfe217 	ldw	r2,-120(fp)
 20250a8:	1000081e 	bne	r2,zero,20250cc <igmp_send+0xa8>
   {
      ++igmpstats.igmp_pkt_alloc_fail;
 20250ac:	00809934 	movhi	r2,612
 20250b0:	10b5c504 	addi	r2,r2,-10476
 20250b4:	10800c17 	ldw	r2,48(r2)
 20250b8:	10c00044 	addi	r3,r2,1
 20250bc:	00809934 	movhi	r2,612
 20250c0:	10b5c504 	addi	r2,r2,-10476
 20250c4:	10c00c15 	stw	r3,48(r2)
 20250c8:	00007b06 	br	20252b8 <igmp_send+0x294>
      return;
   }

   /* Need to fill in the source and destination ip addresses */
   pip = (struct ip *) p->nb_prot;
 20250cc:	e0bfe217 	ldw	r2,-120(fp)
 20250d0:	10800317 	ldw	r2,12(r2)
 20250d4:	e0bfe315 	stw	r2,-116(fp)
   pip->ip_src = inm->inm_netp->n_ipaddr;
 20250d8:	e0bfff17 	ldw	r2,-4(fp)
 20250dc:	10800117 	ldw	r2,4(r2)
 20250e0:	10c00a17 	ldw	r3,40(r2)
 20250e4:	e0bfe317 	ldw	r2,-116(fp)
 20250e8:	10c00315 	stw	r3,12(r2)
   /* Leave Group messages are sent to the all-routers multicast group */
   if (type == IGMPv2_LEAVE_GROUP)
 20250ec:	e0bffe03 	ldbu	r2,-8(fp)
 20250f0:	108005d8 	cmpnei	r2,r2,23
 20250f4:	1000041e 	bne	r2,zero,2025108 <igmp_send+0xe4>
   {
      /* igmp_all_rtrs_group is already in network byte order */
      pip->ip_dest = igmp_all_rtrs_group;
 20250f8:	d0e08e17 	ldw	r3,-32200(gp)
 20250fc:	e0bfe317 	ldw	r2,-116(fp)
 2025100:	10c00415 	stw	r3,16(r2)
 2025104:	00000406 	br	2025118 <igmp_send+0xf4>
   }
   else
      pip->ip_dest = inm->inm_addr;
 2025108:	e0bfff17 	ldw	r2,-4(fp)
 202510c:	10c00017 	ldw	r3,0(r2)
 2025110:	e0bfe317 	ldw	r2,-116(fp)
 2025114:	10c00415 	stw	r3,16(r2)
   
   p->fhost = pip->ip_dest;
 2025118:	e0bfe317 	ldw	r2,-116(fp)
 202511c:	10c00417 	ldw	r3,16(r2)
 2025120:	e0bfe217 	ldw	r2,-120(fp)
 2025124:	10c00715 	stw	r3,28(r2)

   tmpp = (((u_char *) p->nb_prot) + sizeof (struct ip));
 2025128:	e0bfe217 	ldw	r2,-120(fp)
 202512c:	10800317 	ldw	r2,12(r2)
 2025130:	10800504 	addi	r2,r2,20
 2025134:	e0bfdf15 	stw	r2,-132(fp)

   /* when transmitting an IGMP packet, our IGMP module will insert
    * data for the Router Alert option in the following types of
    * packets: Version 2 Membership Report (0x16) and Leave Group 
    * (0x17) */
   if ((type == IGMPv2_LEAVE_GROUP) || 
 2025138:	e0bffe03 	ldbu	r2,-8(fp)
 202513c:	108005e0 	cmpeqi	r2,r2,23
 2025140:	1000031e 	bne	r2,zero,2025150 <igmp_send+0x12c>
 2025144:	e0bffe03 	ldbu	r2,-8(fp)
 2025148:	10800598 	cmpnei	r2,r2,22
 202514c:	1000061e 	bne	r2,zero,2025168 <igmp_send+0x144>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      /* provide space for ip_write2 () to write option-related data */
      tmpp += IP_RTR_ALERT_OPT_SIZE;
 2025150:	e0bfdf17 	ldw	r2,-132(fp)
 2025154:	10800104 	addi	r2,r2,4
 2025158:	e0bfdf15 	stw	r2,-132(fp)
      optp = &(opts [0]); /* one option (IP Router Alert) */
 202515c:	e0bffd04 	addi	r2,fp,-12
 2025160:	e0bfe015 	stw	r2,-128(fp)
 2025164:	00000306 	br	2025174 <igmp_send+0x150>
   }
   /* outgoing packet does not require any options */
   else 
      optp = &(opts [1]);
 2025168:	e0bffd04 	addi	r2,fp,-12
 202516c:	10800044 	addi	r2,r2,1
 2025170:	e0bfe015 	stw	r2,-128(fp)
   /* point to the start of the IGMP header */
   igmp = (struct igmp *) tmpp;
 2025174:	e0bfdf17 	ldw	r2,-132(fp)
 2025178:	e0bfe415 	stw	r2,-112(fp)
   
   igmp->igmp_type = type;
 202517c:	e0bfe417 	ldw	r2,-112(fp)
 2025180:	e0fffe03 	ldbu	r3,-8(fp)
 2025184:	10c00005 	stb	r3,0(r2)
   igmp->igmp_code = 0;
 2025188:	e0bfe417 	ldw	r2,-112(fp)
 202518c:	10000045 	stb	zero,1(r2)
   
   /* all messages (Report or Leave) have Group Address field 
    * set to the group being reported or left */
   igmp->igmp_group = inm->inm_addr;
 2025190:	e0bfff17 	ldw	r2,-4(fp)
 2025194:	10c00017 	ldw	r3,0(r2)
 2025198:	e0bfe417 	ldw	r2,-112(fp)
 202519c:	10c00115 	stw	r3,4(r2)
   igmp->igmp_cksum = 0;
 20251a0:	e0bfe417 	ldw	r2,-112(fp)
 20251a4:	1000008d 	sth	zero,2(r2)
   igmp->igmp_cksum = ~cksum((void*)igmp, IGMP_MINLEN>>1);
 20251a8:	e13fe417 	ldw	r4,-112(fp)
 20251ac:	01400104 	movi	r5,4
 20251b0:	20268040 	call	2026804 <cksum>
 20251b4:	0084303a 	nor	r2,zero,r2
 20251b8:	1007883a 	mov	r3,r2
 20251bc:	e0bfe417 	ldw	r2,-112(fp)
 20251c0:	10c0008d 	sth	r3,2(r2)

   imop = &simo;
 20251c4:	e0bfe704 	addi	r2,fp,-100
 20251c8:	e0bfe515 	stw	r2,-108(fp)
   MEMSET(imop, 0, sizeof(simo));
 20251cc:	e13fe517 	ldw	r4,-108(fp)
 20251d0:	000b883a 	mov	r5,zero
 20251d4:	01801604 	movi	r6,88
 20251d8:	200682c0 	call	200682c <memset>
   imop->imo_multicast_netp = inm->inm_netp;
 20251dc:	e0bfff17 	ldw	r2,-4(fp)
 20251e0:	10c00117 	ldw	r3,4(r2)
 20251e4:	e0bfe517 	ldw	r2,-108(fp)
 20251e8:	10c00015 	stw	r3,0(r2)
   imop->imo_multicast_ttl = 1;
 20251ec:	e0bfe517 	ldw	r2,-108(fp)
 20251f0:	00c00044 	movi	r3,1
 20251f4:	10c00105 	stb	r3,4(r2)
   /* we do not want our own reports to be looped back */
   imop->imo_multicast_loop = 0;
 20251f8:	e0bfe517 	ldw	r2,-108(fp)
 20251fc:	10000145 	stb	zero,5(r2)

   /* set nb_prot to point to the beginning of the IGMP data,
    * and nb_plen to the length of the IGMP data, and attach
    * the multicast options structure to the outgoing packet */
   p->nb_prot = (char *) tmpp;
 2025200:	e0bfe217 	ldw	r2,-120(fp)
 2025204:	e0ffdf17 	ldw	r3,-132(fp)
 2025208:	10c00315 	stw	r3,12(r2)
   p->nb_plen = sizeof(struct igmp);
 202520c:	e0bfe217 	ldw	r2,-120(fp)
 2025210:	00c00204 	movi	r3,8
 2025214:	10c00415 	stw	r3,16(r2)
   p->imo = imop;
 2025218:	e0bfe217 	ldw	r2,-120(fp)
 202521c:	e0ffe517 	ldw	r3,-108(fp)
 2025220:	10c00b15 	stw	r3,44(r2)
   
   i = ip_write2 (IGMP_PROT, p, optp);
 2025224:	01000084 	movi	r4,2
 2025228:	e17fe217 	ldw	r5,-120(fp)
 202522c:	e1bfe017 	ldw	r6,-128(fp)
 2025230:	203ff900 	call	203ff90 <ip_write2>
 2025234:	e0bfe615 	stw	r2,-104(fp)

   if (type == IGMPv2_LEAVE_GROUP)
 2025238:	e0bffe03 	ldbu	r2,-8(fp)
 202523c:	108005d8 	cmpnei	r2,r2,23
 2025240:	1000081e 	bne	r2,zero,2025264 <igmp_send+0x240>
      ++igmpstats.igmpv2mode_v2_leave_msgs_sent;
 2025244:	00809934 	movhi	r2,612
 2025248:	10b5c504 	addi	r2,r2,-10476
 202524c:	10801717 	ldw	r2,92(r2)
 2025250:	10c00044 	addi	r3,r2,1
 2025254:	00809934 	movhi	r2,612
 2025258:	10b5c504 	addi	r2,r2,-10476
 202525c:	10c01715 	stw	r3,92(r2)
 2025260:	00001506 	br	20252b8 <igmp_send+0x294>
   else if (type == IGMPv2_MEMBERSHIP_REPORT)
 2025264:	e0bffe03 	ldbu	r2,-8(fp)
 2025268:	10800598 	cmpnei	r2,r2,22
 202526c:	1000081e 	bne	r2,zero,2025290 <igmp_send+0x26c>
      ++igmpstats.igmpv2mode_v2_reports_sent;
 2025270:	00809934 	movhi	r2,612
 2025274:	10b5c504 	addi	r2,r2,-10476
 2025278:	10801817 	ldw	r2,96(r2)
 202527c:	10c00044 	addi	r3,r2,1
 2025280:	00809934 	movhi	r2,612
 2025284:	10b5c504 	addi	r2,r2,-10476
 2025288:	10c01815 	stw	r3,96(r2)
 202528c:	00000a06 	br	20252b8 <igmp_send+0x294>
   else if (type == IGMP_HOST_MEMBERSHIP_REPORT)
 2025290:	e0bffe03 	ldbu	r2,-8(fp)
 2025294:	10800498 	cmpnei	r2,r2,18
 2025298:	1000071e 	bne	r2,zero,20252b8 <igmp_send+0x294>
      ++igmpstats.igmp_v1_reports_sent;
 202529c:	00809934 	movhi	r2,612
 20252a0:	10b5c504 	addi	r2,r2,-10476
 20252a4:	10801617 	ldw	r2,88(r2)
 20252a8:	10c00044 	addi	r3,r2,1
 20252ac:	00809934 	movhi	r2,612
 20252b0:	10b5c504 	addi	r2,r2,-10476
 20252b4:	10c01615 	stw	r3,88(r2)
}
 20252b8:	e037883a 	mov	sp,fp
 20252bc:	dfc00117 	ldw	ra,4(sp)
 20252c0:	df000017 	ldw	fp,0(sp)
 20252c4:	dec00204 	addi	sp,sp,8
 20252c8:	f800283a 	ret

020252cc <igmp_joingroup>:
 *
 * OUTPUT: None.
 */
 
void igmp_joingroup(struct in_multi * inm)
{
 20252cc:	defffc04 	addi	sp,sp,-16
 20252d0:	dfc00315 	stw	ra,12(sp)
 20252d4:	df000215 	stw	fp,8(sp)
 20252d8:	df000204 	addi	fp,sp,8
 20252dc:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   /* extract the network interface to which this multicast
    * address is "attached" */
   ifp = inm->inm_netp;
 20252e0:	e0bfff17 	ldw	r2,-4(fp)
 20252e4:	10800117 	ldw	r2,4(r2)
 20252e8:	e0bffe15 	stw	r2,-8(fp)

   if (inm->inm_addr == igmp_all_hosts_group)
 20252ec:	e0bfff17 	ldw	r2,-4(fp)
 20252f0:	10c00017 	ldw	r3,0(r2)
 20252f4:	d0a08d17 	ldw	r2,-32204(gp)
 20252f8:	1880031e 	bne	r3,r2,2025308 <igmp_joingroup+0x3c>
   {
      inm->inm_timer = 0;
 20252fc:	e0bfff17 	ldw	r2,-4(fp)
 2025300:	10000315 	stw	zero,12(r2)
      }

      ++igmp_timers_are_running;
   }
   
   return;
 2025304:	00008206 	br	2025510 <igmp_joingroup+0x244>
      inm->inm_timer = 0;
   }
   else 
   {
      /* send unsolicited membership report in appropriate format */
      if (ifp->igmpv1_rtr_present)
 2025308:	e0bffe17 	ldw	r2,-8(fp)
 202530c:	10802d03 	ldbu	r2,180(r2)
 2025310:	10803fcc 	andi	r2,r2,255
 2025314:	10003a26 	beq	r2,zero,2025400 <igmp_joingroup+0x134>
      {
         /* always true for IGMPv1, may be true for IGMPv2 */
         igmp_send (IGMP_HOST_MEMBERSHIP_REPORT, inm);
 2025318:	01000484 	movi	r4,18
 202531c:	e17fff17 	ldw	r5,-4(fp)
 2025320:	20250240 	call	2025024 <igmp_send>
         /* set a delay timer (with a duration of 
          * IGMP_MAX_HOST_REPORT_DELAY) for a second unsolicited report */
         inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 2025324:	00809934 	movhi	r2,612
 2025328:	10b7d304 	addi	r2,r2,-8372
 202532c:	10c00217 	ldw	r3,8(r2)
 2025330:	00809934 	movhi	r2,612
 2025334:	10b5c104 	addi	r2,r2,-10492
 2025338:	10800017 	ldw	r2,0(r2)
 202533c:	10800a17 	ldw	r2,40(r2)
 2025340:	1008d63a 	srli	r4,r2,24
 2025344:	00809934 	movhi	r2,612
 2025348:	10b5c104 	addi	r2,r2,-10492
 202534c:	10800017 	ldw	r2,0(r2)
 2025350:	10800a17 	ldw	r2,40(r2)
 2025354:	1004d23a 	srli	r2,r2,8
 2025358:	10bfc00c 	andi	r2,r2,65280
 202535c:	2088b03a 	or	r4,r4,r2
 2025360:	00809934 	movhi	r2,612
 2025364:	10b5c104 	addi	r2,r2,-10492
 2025368:	10800017 	ldw	r2,0(r2)
 202536c:	10800a17 	ldw	r2,40(r2)
 2025370:	10bfc00c 	andi	r2,r2,65280
 2025374:	1004923a 	slli	r2,r2,8
 2025378:	2088b03a 	or	r4,r4,r2
 202537c:	00809934 	movhi	r2,612
 2025380:	10b5c104 	addi	r2,r2,-10492
 2025384:	10800017 	ldw	r2,0(r2)
 2025388:	10800a17 	ldw	r2,40(r2)
 202538c:	1004963a 	slli	r2,r2,24
 2025390:	2084b03a 	or	r2,r4,r2
 2025394:	1887883a 	add	r3,r3,r2
 2025398:	e0bfff17 	ldw	r2,-4(fp)
 202539c:	10800017 	ldw	r2,0(r2)
 20253a0:	1008d63a 	srli	r4,r2,24
 20253a4:	e0bfff17 	ldw	r2,-4(fp)
 20253a8:	10800017 	ldw	r2,0(r2)
 20253ac:	1004d23a 	srli	r2,r2,8
 20253b0:	10bfc00c 	andi	r2,r2,65280
 20253b4:	2088b03a 	or	r4,r4,r2
 20253b8:	e0bfff17 	ldw	r2,-4(fp)
 20253bc:	10800017 	ldw	r2,0(r2)
 20253c0:	10bfc00c 	andi	r2,r2,65280
 20253c4:	1004923a 	slli	r2,r2,8
 20253c8:	2088b03a 	or	r4,r4,r2
 20253cc:	e0bfff17 	ldw	r2,-4(fp)
 20253d0:	10800017 	ldw	r2,0(r2)
 20253d4:	1004963a 	slli	r2,r2,24
 20253d8:	2084b03a 	or	r2,r4,r2
 20253dc:	1885883a 	add	r2,r3,r2
 20253e0:	00c00c84 	movi	r3,50
 20253e4:	10c7203a 	divu	r3,r2,r3
 20253e8:	18c00ca4 	muli	r3,r3,50
 20253ec:	10c5c83a 	sub	r2,r2,r3
 20253f0:	10c00044 	addi	r3,r2,1
 20253f4:	e0bfff17 	ldw	r2,-4(fp)
 20253f8:	10c00315 	stw	r3,12(r2)
 20253fc:	00003906 	br	20254e4 <igmp_joingroup+0x218>
      }
      else
      {
         igmp_send (IGMPv2_MEMBERSHIP_REPORT, inm);
 2025400:	01000584 	movi	r4,22
 2025404:	e17fff17 	ldw	r5,-4(fp)
 2025408:	20250240 	call	2025024 <igmp_send>
         /* the delay time duration is the Unsolicited Report Interval */
         inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY ((UNSOLIC_RPT_INTERVAL * PR_FASTHZ), inm->inm_addr);
 202540c:	00809934 	movhi	r2,612
 2025410:	10b7d304 	addi	r2,r2,-8372
 2025414:	10c00217 	ldw	r3,8(r2)
 2025418:	00809934 	movhi	r2,612
 202541c:	10b5c104 	addi	r2,r2,-10492
 2025420:	10800017 	ldw	r2,0(r2)
 2025424:	10800a17 	ldw	r2,40(r2)
 2025428:	1008d63a 	srli	r4,r2,24
 202542c:	00809934 	movhi	r2,612
 2025430:	10b5c104 	addi	r2,r2,-10492
 2025434:	10800017 	ldw	r2,0(r2)
 2025438:	10800a17 	ldw	r2,40(r2)
 202543c:	1004d23a 	srli	r2,r2,8
 2025440:	10bfc00c 	andi	r2,r2,65280
 2025444:	2088b03a 	or	r4,r4,r2
 2025448:	00809934 	movhi	r2,612
 202544c:	10b5c104 	addi	r2,r2,-10492
 2025450:	10800017 	ldw	r2,0(r2)
 2025454:	10800a17 	ldw	r2,40(r2)
 2025458:	10bfc00c 	andi	r2,r2,65280
 202545c:	1004923a 	slli	r2,r2,8
 2025460:	2088b03a 	or	r4,r4,r2
 2025464:	00809934 	movhi	r2,612
 2025468:	10b5c104 	addi	r2,r2,-10492
 202546c:	10800017 	ldw	r2,0(r2)
 2025470:	10800a17 	ldw	r2,40(r2)
 2025474:	1004963a 	slli	r2,r2,24
 2025478:	2084b03a 	or	r2,r4,r2
 202547c:	1887883a 	add	r3,r3,r2
 2025480:	e0bfff17 	ldw	r2,-4(fp)
 2025484:	10800017 	ldw	r2,0(r2)
 2025488:	1008d63a 	srli	r4,r2,24
 202548c:	e0bfff17 	ldw	r2,-4(fp)
 2025490:	10800017 	ldw	r2,0(r2)
 2025494:	1004d23a 	srli	r2,r2,8
 2025498:	10bfc00c 	andi	r2,r2,65280
 202549c:	2088b03a 	or	r4,r4,r2
 20254a0:	e0bfff17 	ldw	r2,-4(fp)
 20254a4:	10800017 	ldw	r2,0(r2)
 20254a8:	10bfc00c 	andi	r2,r2,65280
 20254ac:	1004923a 	slli	r2,r2,8
 20254b0:	2088b03a 	or	r4,r4,r2
 20254b4:	e0bfff17 	ldw	r2,-4(fp)
 20254b8:	10800017 	ldw	r2,0(r2)
 20254bc:	1004963a 	slli	r2,r2,24
 20254c0:	2084b03a 	or	r2,r4,r2
 20254c4:	1885883a 	add	r2,r3,r2
 20254c8:	00c00c84 	movi	r3,50
 20254cc:	10c7203a 	divu	r3,r2,r3
 20254d0:	18c00ca4 	muli	r3,r3,50
 20254d4:	10c5c83a 	sub	r2,r2,r3
 20254d8:	10c00044 	addi	r3,r2,1
 20254dc:	e0bfff17 	ldw	r2,-4(fp)
 20254e0:	10c00315 	stw	r3,12(r2)
      }
      
      /* for IGMPv2, indicate that we were the last to send 
       * a Report for this multicast group (relevant for 
       * IGMPv2 only). */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 20254e4:	e0bffe17 	ldw	r2,-8(fp)
 20254e8:	10802f03 	ldbu	r2,188(r2)
 20254ec:	10803fcc 	andi	r2,r2,255
 20254f0:	10800098 	cmpnei	r2,r2,2
 20254f4:	1000031e 	bne	r2,zero,2025504 <igmp_joingroup+0x238>
      {
         inm->last2send_report = IGMP_TRUE;
 20254f8:	e0bfff17 	ldw	r2,-4(fp)
 20254fc:	00c00044 	movi	r3,1
 2025500:	10c00405 	stb	r3,16(r2)
      }

      ++igmp_timers_are_running;
 2025504:	d0a08b17 	ldw	r2,-32212(gp)
 2025508:	10800044 	addi	r2,r2,1
 202550c:	d0a08b15 	stw	r2,-32212(gp)
   }
   
   return;
 2025510:	0001883a 	nop
}     
 2025514:	e037883a 	mov	sp,fp
 2025518:	dfc00117 	ldw	ra,4(sp)
 202551c:	df000017 	ldw	fp,0(sp)
 2025520:	dec00204 	addi	sp,sp,8
 2025524:	f800283a 	ret

02025528 <igmp_leavegroup>:
 *
 * OUTPUT: None.
 */

void igmp_leavegroup (struct in_multi * inm)
{
 2025528:	defffc04 	addi	sp,sp,-16
 202552c:	dfc00315 	stw	ra,12(sp)
 2025530:	df000215 	stw	fp,8(sp)
 2025534:	df000204 	addi	fp,sp,8
 2025538:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = inm->inm_netp;
 202553c:	e0bfff17 	ldw	r2,-4(fp)
 2025540:	10800117 	ldw	r2,4(r2)
 2025544:	e0bffe15 	stw	r2,-8(fp)

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 2025548:	e0bffe17 	ldw	r2,-8(fp)
 202554c:	10802f03 	ldbu	r2,188(r2)
 2025550:	10803fcc 	andi	r2,r2,255
 2025554:	10800098 	cmpnei	r2,r2,2
 2025558:	10000c1e 	bne	r2,zero,202558c <igmp_leavegroup+0x64>
       !ifp->igmpv1_rtr_present)
 202555c:	e0bffe17 	ldw	r2,-8(fp)
 2025560:	10802d03 	ldbu	r2,180(r2)
{
   NET ifp;

   ifp = inm->inm_netp;

   if ((ifp->igmp_oper_mode == IGMP_MODE_V2) && 
 2025564:	10803fcc 	andi	r2,r2,255
 2025568:	1000081e 	bne	r2,zero,202558c <igmp_leavegroup+0x64>
       !ifp->igmpv1_rtr_present)
   {
      if (inm->last2send_report == IGMP_TRUE)
 202556c:	e0bfff17 	ldw	r2,-4(fp)
 2025570:	10800403 	ldbu	r2,16(r2)
 2025574:	10803fcc 	andi	r2,r2,255
 2025578:	10800058 	cmpnei	r2,r2,1
 202557c:	1000031e 	bne	r2,zero,202558c <igmp_leavegroup+0x64>
         igmp_send (IGMPv2_LEAVE_GROUP, inm);
 2025580:	010005c4 	movi	r4,23
 2025584:	e17fff17 	ldw	r5,-4(fp)
 2025588:	20250240 	call	2025024 <igmp_send>
   }
   
   return;
 202558c:	0001883a 	nop
}
 2025590:	e037883a 	mov	sp,fp
 2025594:	dfc00117 	ldw	ra,4(sp)
 2025598:	df000017 	ldw	fp,0(sp)
 202559c:	dec00204 	addi	sp,sp,8
 20255a0:	f800283a 	ret

020255a4 <igmp_validate>:
 *         validation fails; otherwise, it returns
 *         IGMP_OK.
 */

int igmp_validate (PACKET p)
{
 20255a4:	defff604 	addi	sp,sp,-40
 20255a8:	dfc00915 	stw	ra,36(sp)
 20255ac:	df000815 	stw	fp,32(sp)
 20255b0:	df000804 	addi	fp,sp,32
 20255b4:	e13fff15 	stw	r4,-4(fp)
   u_short xsum;  
   u_char type;
   ip_addr mcgrp_addr;
   u_char resp_time;

   pip = ip_head (p);
 20255b8:	e0bfff17 	ldw	r2,-4(fp)
 20255bc:	10800317 	ldw	r2,12(r2)
 20255c0:	e0bff815 	stw	r2,-32(fp)

   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */
   igmplen = p->nb_plen - ip_hlen (pip);
 20255c4:	e0bfff17 	ldw	r2,-4(fp)
 20255c8:	10c00417 	ldw	r3,16(r2)
 20255cc:	e0bff817 	ldw	r2,-32(fp)
 20255d0:	10800003 	ldbu	r2,0(r2)
 20255d4:	10803fcc 	andi	r2,r2,255
 20255d8:	108003cc 	andi	r2,r2,15
 20255dc:	1085883a 	add	r2,r2,r2
 20255e0:	1085883a 	add	r2,r2,r2
 20255e4:	1885c83a 	sub	r2,r3,r2
 20255e8:	e0bff915 	stw	r2,-28(fp)

   /* validate length (IGMP_MINLEN is 8 bytes) */
   if (igmplen != IGMP_MINLEN) 
 20255ec:	e0bff917 	ldw	r2,-28(fp)
 20255f0:	10800220 	cmpeqi	r2,r2,8
 20255f4:	1000091e 	bne	r2,zero,202561c <igmp_validate+0x78>
   {
      ++igmpstats.igmp_badlen_rcvd;
 20255f8:	00809934 	movhi	r2,612
 20255fc:	10b5c504 	addi	r2,r2,-10476
 2025600:	10800a17 	ldw	r2,40(r2)
 2025604:	10c00044 	addi	r3,r2,1
 2025608:	00809934 	movhi	r2,612
 202560c:	10b5c504 	addi	r2,r2,-10476
 2025610:	10c00a15 	stw	r3,40(r2)
      return ENP_BAD_HEADER;
 2025614:	00bff804 	movi	r2,-32
 2025618:	0000a206 	br	20258a4 <igmp_validate+0x300>
   }

   /* validate checksum */
   igmp = (struct igmp *) (ip_data (pip));
 202561c:	e0bff817 	ldw	r2,-32(fp)
 2025620:	10800003 	ldbu	r2,0(r2)
 2025624:	10803fcc 	andi	r2,r2,255
 2025628:	108003cc 	andi	r2,r2,15
 202562c:	1085883a 	add	r2,r2,r2
 2025630:	1085883a 	add	r2,r2,r2
 2025634:	e0fff817 	ldw	r3,-32(fp)
 2025638:	1885883a 	add	r2,r3,r2
 202563c:	e0bffa15 	stw	r2,-24(fp)
   osum = igmp->igmp_cksum;
 2025640:	e0bffa17 	ldw	r2,-24(fp)
 2025644:	1080008b 	ldhu	r2,2(r2)
 2025648:	e0bffb0d 	sth	r2,-20(fp)
   igmp->igmp_cksum = 0;
 202564c:	e0bffa17 	ldw	r2,-24(fp)
 2025650:	1000008d 	sth	zero,2(r2)
   xsum = ~cksum(igmp, igmplen>>1);
 2025654:	e0bff917 	ldw	r2,-28(fp)
 2025658:	1005d07a 	srai	r2,r2,1
 202565c:	e13ffa17 	ldw	r4,-24(fp)
 2025660:	100b883a 	mov	r5,r2
 2025664:	20268040 	call	2026804 <cksum>
 2025668:	0084303a 	nor	r2,zero,r2
 202566c:	e0bffb8d 	sth	r2,-18(fp)
   if (xsum != osum)
 2025670:	e0fffb8b 	ldhu	r3,-18(fp)
 2025674:	e0bffb0b 	ldhu	r2,-20(fp)
 2025678:	18800c26 	beq	r3,r2,20256ac <igmp_validate+0x108>
   {
      igmp->igmp_cksum = osum;
 202567c:	e0bffa17 	ldw	r2,-24(fp)
 2025680:	e0fffb0b 	ldhu	r3,-20(fp)
 2025684:	10c0008d 	sth	r3,2(r2)
      ++igmpstats.igmp_badsum_rcvd;
 2025688:	00809934 	movhi	r2,612
 202568c:	10b5c504 	addi	r2,r2,-10476
 2025690:	10800b17 	ldw	r2,44(r2)
 2025694:	10c00044 	addi	r3,r2,1
 2025698:	00809934 	movhi	r2,612
 202569c:	10b5c504 	addi	r2,r2,-10476
 20256a0:	10c00b15 	stw	r3,44(r2)
      return ENP_BAD_HEADER;
 20256a4:	00bff804 	movi	r2,-32
 20256a8:	00007e06 	br	20258a4 <igmp_validate+0x300>
   }
   
   /* extract the IGMP packet type, Group Address, and Max Response Time 
    * (unused for IGMPv1) fields from received packet */
   type = igmp->igmp_type;
 20256ac:	e0bffa17 	ldw	r2,-24(fp)
 20256b0:	10800003 	ldbu	r2,0(r2)
 20256b4:	e0bffc05 	stb	r2,-16(fp)
   mcgrp_addr = ntohl(igmp->igmp_group); 
 20256b8:	e0bffa17 	ldw	r2,-24(fp)
 20256bc:	10800117 	ldw	r2,4(r2)
 20256c0:	1006d63a 	srli	r3,r2,24
 20256c4:	e0bffa17 	ldw	r2,-24(fp)
 20256c8:	10800117 	ldw	r2,4(r2)
 20256cc:	1004d23a 	srli	r2,r2,8
 20256d0:	10bfc00c 	andi	r2,r2,65280
 20256d4:	1886b03a 	or	r3,r3,r2
 20256d8:	e0bffa17 	ldw	r2,-24(fp)
 20256dc:	10800117 	ldw	r2,4(r2)
 20256e0:	10bfc00c 	andi	r2,r2,65280
 20256e4:	1004923a 	slli	r2,r2,8
 20256e8:	1886b03a 	or	r3,r3,r2
 20256ec:	e0bffa17 	ldw	r2,-24(fp)
 20256f0:	10800117 	ldw	r2,4(r2)
 20256f4:	1004963a 	slli	r2,r2,24
 20256f8:	1884b03a 	or	r2,r3,r2
 20256fc:	e0bffd15 	stw	r2,-12(fp)
   resp_time = igmp->igmp_code;
 2025700:	e0bffa17 	ldw	r2,-24(fp)
 2025704:	10800043 	ldbu	r2,1(r2)
 2025708:	e0bffe05 	stb	r2,-8(fp)
      
   if (type == IGMP_HOST_MEMBERSHIP_QUERY)
 202570c:	e0bffc03 	ldbu	r2,-16(fp)
 2025710:	10800458 	cmpnei	r2,r2,17
 2025714:	1000301e 	bne	r2,zero,20257d8 <igmp_validate+0x234>
   {
      if ((resp_time == 0) || /* IGMPv1 Query */
 2025718:	e0bffe03 	ldbu	r2,-8(fp)
 202571c:	10000426 	beq	r2,zero,2025730 <igmp_validate+0x18c>
 2025720:	e0bffe03 	ldbu	r2,-8(fp)
 2025724:	10000f26 	beq	r2,zero,2025764 <igmp_validate+0x1c0>
          ((resp_time > 0) && (mcgrp_addr == 0))) /* IGMPv2 General Query */     
 2025728:	e0bffd17 	ldw	r2,-12(fp)
 202572c:	10000d1e 	bne	r2,zero,2025764 <igmp_validate+0x1c0>
      {
         /* if this is a IGMPv1 Host Membership Query or a IGMPv2 
          * General Query, it must be addressed to the all-hosts 
          * group */
         if (pip->ip_dest != igmp_all_hosts_group) 
 2025730:	e0bff817 	ldw	r2,-32(fp)
 2025734:	10c00417 	ldw	r3,16(r2)
 2025738:	d0a08d17 	ldw	r2,-32204(gp)
 202573c:	18800926 	beq	r3,r2,2025764 <igmp_validate+0x1c0>
         {
            ++igmpstats.igmp_bad_queries_rcvd;
 2025740:	00809934 	movhi	r2,612
 2025744:	10b5c504 	addi	r2,r2,-10476
 2025748:	10800e17 	ldw	r2,56(r2)
 202574c:	10c00044 	addi	r3,r2,1
 2025750:	00809934 	movhi	r2,612
 2025754:	10b5c504 	addi	r2,r2,-10476
 2025758:	10c00e15 	stw	r3,56(r2)
            return ENP_BAD_HEADER;
 202575c:	00bff804 	movi	r2,-32
 2025760:	00005006 	br	20258a4 <igmp_validate+0x300>
         }     
      }
      
      if ((resp_time > 0) && (mcgrp_addr != 0))
 2025764:	e0bffe03 	ldbu	r2,-8(fp)
 2025768:	10001b26 	beq	r2,zero,20257d8 <igmp_validate+0x234>
 202576c:	e0bffd17 	ldw	r2,-12(fp)
 2025770:	10001926 	beq	r2,zero,20257d8 <igmp_validate+0x234>
      {
         /* this is a IGMPv2 Group-Specific Query. */
         if (p->net->igmp_oper_mode == IGMP_MODE_V1)
 2025774:	e0bfff17 	ldw	r2,-4(fp)
 2025778:	10800617 	ldw	r2,24(r2)
 202577c:	10802f03 	ldbu	r2,188(r2)
 2025780:	10803fcc 	andi	r2,r2,255
 2025784:	10800058 	cmpnei	r2,r2,1
 2025788:	1000021e 	bne	r2,zero,2025794 <igmp_validate+0x1f0>
         {
            /* IGMPv1 code does not understand a IGMPv2 Group-
             * Specific Query */
            return ENP_BAD_HEADER; 
 202578c:	00bff804 	movi	r2,-32
 2025790:	00004406 	br	20258a4 <igmp_validate+0x300>
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 2025794:	e0bffd17 	ldw	r2,-12(fp)
 2025798:	10fc002c 	andhi	r3,r2,61440
 202579c:	00b80034 	movhi	r2,57344
 20257a0:	1880041e 	bne	r3,r2,20257b4 <igmp_validate+0x210>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
 20257a4:	e0bffa17 	ldw	r2,-24(fp)
 20257a8:	10c00117 	ldw	r3,4(r2)
 20257ac:	d0a08d17 	ldw	r2,-32204(gp)
         /* check to make sure that the group address field carries
          * a valid multicast address; if it doesn't, we
          * drop the packet.  Also drop packets that
          * carry the multicast address for the all-hosts
          * group. */
         if ((!IN_MULTICAST(mcgrp_addr)) ||
 20257b0:	1880091e 	bne	r3,r2,20257d8 <igmp_validate+0x234>
             /* igmp_all_hosts_group is already in network byte order */
             (igmp->igmp_group == igmp_all_hosts_group))
         {
            ++igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd;
 20257b4:	00809934 	movhi	r2,612
 20257b8:	10b5c504 	addi	r2,r2,-10476
 20257bc:	10801117 	ldw	r2,68(r2)
 20257c0:	10c00044 	addi	r3,r2,1
 20257c4:	00809934 	movhi	r2,612
 20257c8:	10b5c504 	addi	r2,r2,-10476
 20257cc:	10c01115 	stw	r3,68(r2)
            /* caller will free received packet */
            return ENP_BAD_HEADER;
 20257d0:	00bff804 	movi	r2,-32
 20257d4:	00003306 	br	20258a4 <igmp_validate+0x300>
   
   /* check to ensure that a received IGMPv1 or v2 Report has the 
    * same IP host group address in its IP destination field and 
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
 20257d8:	e0bffc03 	ldbu	r2,-16(fp)
 20257dc:	108004a0 	cmpeqi	r2,r2,18
 20257e0:	1000031e 	bne	r2,zero,20257f0 <igmp_validate+0x24c>
 20257e4:	e0bffc03 	ldbu	r2,-16(fp)
 20257e8:	10800598 	cmpnei	r2,r2,22
 20257ec:	1000121e 	bne	r2,zero,2025838 <igmp_validate+0x294>
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 20257f0:	e0bffa17 	ldw	r2,-24(fp)
 20257f4:	10c00117 	ldw	r3,4(r2)
 20257f8:	e0bff817 	ldw	r2,-32(fp)
 20257fc:	10800417 	ldw	r2,16(r2)
 2025800:	1880041e 	bne	r3,r2,2025814 <igmp_validate+0x270>
          (!IN_MULTICAST(mcgrp_addr)))
 2025804:	e0bffd17 	ldw	r2,-12(fp)
 2025808:	10fc002c 	andhi	r3,r2,61440
    * its IGMP group address field, and that the group address is
    * a valid multicast address */
   if ((type == IGMP_HOST_MEMBERSHIP_REPORT) ||
       (type == IGMPv2_MEMBERSHIP_REPORT))
   {
      if ((igmp->igmp_group != pip->ip_dest) ||
 202580c:	00b80034 	movhi	r2,57344
 2025810:	18800926 	beq	r3,r2,2025838 <igmp_validate+0x294>
          (!IN_MULTICAST(mcgrp_addr)))
      {
         ++igmpstats.igmp_bad_reports_rcvd;
 2025814:	00809934 	movhi	r2,612
 2025818:	10b5c504 	addi	r2,r2,-10476
 202581c:	10800f17 	ldw	r2,60(r2)
 2025820:	10c00044 	addi	r3,r2,1
 2025824:	00809934 	movhi	r2,612
 2025828:	10b5c504 	addi	r2,r2,-10476
 202582c:	10c00f15 	stw	r3,60(r2)
         return ENP_BAD_HEADER;    
 2025830:	00bff804 	movi	r2,-32
 2025834:	00001b06 	br	20258a4 <igmp_validate+0x300>

    * Version 1 Host Membership Reports and Version 1 Host Membership Query
    * packets will not be checked for the IP Router Alert option.
    */
#ifdef IGMP_V2    
   if ((type == IGMPv2_LEAVE_GROUP) || 
 2025838:	e0bffc03 	ldbu	r2,-16(fp)
 202583c:	108005e0 	cmpeqi	r2,r2,23
 2025840:	10000a1e 	bne	r2,zero,202586c <igmp_validate+0x2c8>
 2025844:	e0bffc03 	ldbu	r2,-16(fp)
 2025848:	108005a0 	cmpeqi	r2,r2,22
 202584c:	1000071e 	bne	r2,zero,202586c <igmp_validate+0x2c8>
       (type == IGMPv2_MEMBERSHIP_REPORT) ||
 2025850:	e0bffc03 	ldbu	r2,-16(fp)
 2025854:	10800458 	cmpnei	r2,r2,17
 2025858:	1000111e 	bne	r2,zero,20258a0 <igmp_validate+0x2fc>
       ((type == IGMP_HOST_MEMBERSHIP_QUERY) && (igmp->igmp_code > 0)))
 202585c:	e0bffa17 	ldw	r2,-24(fp)
 2025860:	10800043 	ldbu	r2,1(r2)
 2025864:	10803fcc 	andi	r2,r2,255
 2025868:	10000d26 	beq	r2,zero,20258a0 <igmp_validate+0x2fc>
       
   {
      if (!igmpv2_chk4_rtr_alert_opt (pip))
 202586c:	e13ff817 	ldw	r4,-32(fp)
 2025870:	20464440 	call	2046444 <igmpv2_chk4_rtr_alert_opt>
 2025874:	10803fcc 	andi	r2,r2,255
 2025878:	1000091e 	bne	r2,zero,20258a0 <igmp_validate+0x2fc>
      { 
         ++igmpstats.igmpv2mode_v2_rtr_alert_missing;
 202587c:	00809934 	movhi	r2,612
 2025880:	10b5c504 	addi	r2,r2,-10476
 2025884:	10801417 	ldw	r2,80(r2)
 2025888:	10c00044 	addi	r3,r2,1
 202588c:	00809934 	movhi	r2,612
 2025890:	10b5c504 	addi	r2,r2,-10476
 2025894:	10c01415 	stw	r3,80(r2)
         return ENP_BAD_HEADER;
 2025898:	00bff804 	movi	r2,-32
 202589c:	00000106 	br	20258a4 <igmp_validate+0x300>
      }
   }
#endif   

   /* validation successful */
   return IGMP_OK;
 20258a0:	0005883a 	mov	r2,zero
}
 20258a4:	e037883a 	mov	sp,fp
 20258a8:	dfc00117 	ldw	ra,4(sp)
 20258ac:	df000017 	ldw	fp,0(sp)
 20258b0:	dec00204 	addi	sp,sp,8
 20258b4:	f800283a 	ret

020258b8 <igmp_print_stats>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */
   
int igmp_print_stats (void * pio)
{  
 20258b8:	defffa04 	addi	sp,sp,-24
 20258bc:	dfc00515 	stw	ra,20(sp)
 20258c0:	df000415 	stw	fp,16(sp)
 20258c4:	df000404 	addi	fp,sp,16
 20258c8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 20258cc:	00809934 	movhi	r2,612
 20258d0:	10b7ce04 	addi	r2,r2,-8392
 20258d4:	10800017 	ldw	r2,0(r2)
 20258d8:	e0bffe15 	stw	r2,-8(fp)
 20258dc:	00003c06 	br	20259d0 <igmp_print_stats+0x118>
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
                 ifp->name, 
 20258e0:	e0bffe17 	ldw	r2,-8(fp)
 20258e4:	11800104 	addi	r6,r2,4
                 ifp->igmp_oper_mode, 
 20258e8:	e0bffe17 	ldw	r2,-8(fp)
 20258ec:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 20258f0:	10c03fcc 	andi	r3,r2,255
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
 20258f4:	e0bffe17 	ldw	r2,-8(fp)
 20258f8:	10802f03 	ldbu	r2,188(r2)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
   {
      ns_printf (pio, "%s: mode: %u [%s] ", 
 20258fc:	10803fcc 	andi	r2,r2,255
 2025900:	10800058 	cmpnei	r2,r2,1
 2025904:	1000031e 	bne	r2,zero,2025914 <igmp_print_stats+0x5c>
 2025908:	00808174 	movhi	r2,517
 202590c:	10ba1804 	addi	r2,r2,-6048
 2025910:	00000206 	br	202591c <igmp_print_stats+0x64>
 2025914:	00808174 	movhi	r2,517
 2025918:	10ba1904 	addi	r2,r2,-6044
 202591c:	d8800015 	stw	r2,0(sp)
 2025920:	e13fff17 	ldw	r4,-4(fp)
 2025924:	01408174 	movhi	r5,517
 2025928:	297a1a04 	addi	r5,r5,-6040
 202592c:	180f883a 	mov	r7,r3
 2025930:	2026e100 	call	2026e10 <ns_printf>
                 ifp->name, 
                 ifp->igmp_oper_mode, 
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
 2025934:	e0bffe17 	ldw	r2,-8(fp)
 2025938:	10802f03 	ldbu	r2,188(r2)
 202593c:	10803fcc 	andi	r2,r2,255
 2025940:	10800098 	cmpnei	r2,r2,2
 2025944:	10001b1e 	bne	r2,zero,20259b4 <igmp_print_stats+0xfc>
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
                    ifp->igmpv1_rtr_present,
 2025948:	e0bffe17 	ldw	r2,-8(fp)
 202594c:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 2025950:	10c03fcc 	andi	r3,r2,255
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
 2025954:	e0bffe17 	ldw	r2,-8(fp)
 2025958:	10802d03 	ldbu	r2,180(r2)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 202595c:	10803fcc 	andi	r2,r2,255
 2025960:	10800058 	cmpnei	r2,r2,1
 2025964:	1000031e 	bne	r2,zero,2025974 <igmp_print_stats+0xbc>
 2025968:	00808174 	movhi	r2,517
 202596c:	10ba1f04 	addi	r2,r2,-6020
 2025970:	00000206 	br	202597c <igmp_print_stats+0xc4>
 2025974:	00808174 	movhi	r2,517
 2025978:	10ba2104 	addi	r2,r2,-6012
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
 202597c:	e13ffe17 	ldw	r4,-8(fp)
                 ((ifp->igmp_oper_mode == IGMP_MODE_V1)? "v1":"v2"));
      /* if a link has been configured for IGMPv2, display the status
       * of the v1 router-related variables too */
      if (ifp->igmp_oper_mode == IGMP_MODE_V2)
      {           
         ns_printf (pio, "v1 rtr: %u [%s] v1 last query: %x [now %x]\n",
 2025980:	21402e17 	ldw	r5,184(r4)
 2025984:	01008174 	movhi	r4,517
 2025988:	2110c904 	addi	r4,r4,17188
 202598c:	21000017 	ldw	r4,0(r4)
 2025990:	d9400015 	stw	r5,0(sp)
 2025994:	d9000115 	stw	r4,4(sp)
 2025998:	e13fff17 	ldw	r4,-4(fp)
 202599c:	01408174 	movhi	r5,517
 20259a0:	297a2304 	addi	r5,r5,-6004
 20259a4:	180d883a 	mov	r6,r3
 20259a8:	100f883a 	mov	r7,r2
 20259ac:	2026e100 	call	2026e10 <ns_printf>
 20259b0:	00000406 	br	20259c4 <igmp_print_stats+0x10c>
                    ifp->igmpv1_rtr_present,
                    ((ifp->igmpv1_rtr_present == IGMP_TRUE)? "present" : "absent"),
                    ifp->igmpv1_query_rcvd_time,
                    cticks);
      }
      else ns_printf (pio, "\n");
 20259b4:	e13fff17 	ldw	r4,-4(fp)
 20259b8:	01408174 	movhi	r5,517
 20259bc:	297a2e04 	addi	r5,r5,-5960
 20259c0:	2026e100 	call	2026e10 <ns_printf>
   
int igmp_print_stats (void * pio)
{  
   NET ifp;
  
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 20259c4:	e0bffe17 	ldw	r2,-8(fp)
 20259c8:	10800017 	ldw	r2,0(r2)
 20259cc:	e0bffe15 	stw	r2,-8(fp)
 20259d0:	e0bffe17 	ldw	r2,-8(fp)
 20259d4:	103fc21e 	bne	r2,zero,20258e0 <igmp_print_stats+0x28>
      }
      else ns_printf (pio, "\n");
   }   

   /* rx and timer statistics */
   ns_printf (pio, "[Rx ] IGMP messages rcvd: %lu, timers running: %lu\n", igmpstats.igmp_total_rcvd, igmp_timers_are_running);
 20259d8:	00809934 	movhi	r2,612
 20259dc:	10b5c504 	addi	r2,r2,-10476
 20259e0:	10c00017 	ldw	r3,0(r2)
 20259e4:	d0a08b17 	ldw	r2,-32212(gp)
 20259e8:	e13fff17 	ldw	r4,-4(fp)
 20259ec:	01408174 	movhi	r5,517
 20259f0:	297a2f04 	addi	r5,r5,-5956
 20259f4:	180d883a 	mov	r6,r3
 20259f8:	100f883a 	mov	r7,r2
 20259fc:	2026e100 	call	2026e10 <ns_printf>
   
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v1-mode links): %lu\n", igmpstats.igmpv1mode_v1_queries_rcvd);
 2025a00:	00809934 	movhi	r2,612
 2025a04:	10b5c504 	addi	r2,r2,-10476
 2025a08:	10800117 	ldw	r2,4(r2)
 2025a0c:	e13fff17 	ldw	r4,-4(fp)
 2025a10:	01408174 	movhi	r5,517
 2025a14:	297a3c04 	addi	r5,r5,-5904
 2025a18:	100d883a 	mov	r6,r2
 2025a1c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Reports rcvd: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd);
 2025a20:	00809934 	movhi	r2,612
 2025a24:	10b5c504 	addi	r2,r2,-10476
 2025a28:	10800217 	ldw	r2,8(r2)
 2025a2c:	e13fff17 	ldw	r4,-4(fp)
 2025a30:	01408174 	movhi	r5,517
 2025a34:	297a4d04 	addi	r5,r5,-5836
 2025a38:	100d883a 	mov	r6,r2
 2025a3c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer);
 2025a40:	00809934 	movhi	r2,612
 2025a44:	10b5c504 	addi	r2,r2,-10476
 2025a48:	10800317 	ldw	r2,12(r2)
 2025a4c:	e13fff17 	ldw	r4,-4(fp)
 2025a50:	01408174 	movhi	r5,517
 2025a54:	297a5904 	addi	r5,r5,-5788
 2025a58:	100d883a 	mov	r6,r2
 2025a5c:	2026e100 	call	2026e10 <ns_printf>
      
   ns_printf (pio, "[Rx ] IGMPv1 Host Membership Queries rcvd (by v2-mode links): %lu\n", igmpstats.igmpv2mode_v1_queries_rcvd);
 2025a60:	00809934 	movhi	r2,612
 2025a64:	10b5c504 	addi	r2,r2,-10476
 2025a68:	10800417 	ldw	r2,16(r2)
 2025a6c:	e13fff17 	ldw	r4,-4(fp)
 2025a70:	01408174 	movhi	r5,517
 2025a74:	297a6c04 	addi	r5,r5,-5712
 2025a78:	100d883a 	mov	r6,r2
 2025a7c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 General Queries rcvd: %lu, Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_general_queries_rcvd, igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd);
 2025a80:	00809934 	movhi	r2,612
 2025a84:	10b5c504 	addi	r2,r2,-10476
 2025a88:	10c00517 	ldw	r3,20(r2)
 2025a8c:	00809934 	movhi	r2,612
 2025a90:	10b5c504 	addi	r2,r2,-10476
 2025a94:	10800617 	ldw	r2,24(r2)
 2025a98:	e13fff17 	ldw	r4,-4(fp)
 2025a9c:	01408174 	movhi	r5,517
 2025aa0:	297a7d04 	addi	r5,r5,-5644
 2025aa4:	180d883a 	mov	r6,r3
 2025aa8:	100f883a 	mov	r7,r2
 2025aac:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd causing timer cancellation: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer);   
 2025ab0:	00809934 	movhi	r2,612
 2025ab4:	10b5c504 	addi	r2,r2,-10476
 2025ab8:	10800717 	ldw	r2,28(r2)
 2025abc:	e13fff17 	ldw	r4,-4(fp)
 2025ac0:	01408174 	movhi	r5,517
 2025ac4:	297a5904 	addi	r5,r5,-5788
 2025ac8:	100d883a 	mov	r6,r2
 2025acc:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Rx ] IGMP Host Membership Reports rcvd with no local timer: %lu\n", igmpstats.igmpv2mode_v12_reports_rcvd_no_timer);
 2025ad0:	00809934 	movhi	r2,612
 2025ad4:	10b5c504 	addi	r2,r2,-10476
 2025ad8:	10800817 	ldw	r2,32(r2)
 2025adc:	e13fff17 	ldw	r4,-4(fp)
 2025ae0:	01408174 	movhi	r5,517
 2025ae4:	297a9004 	addi	r5,r5,-5568
 2025ae8:	100d883a 	mov	r6,r2
 2025aec:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Rx ] IGMPv2 Leave Group messages rcvd: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_rcvd);
 2025af0:	00809934 	movhi	r2,612
 2025af4:	10b5c504 	addi	r2,r2,-10476
 2025af8:	10800917 	ldw	r2,36(r2)
 2025afc:	e13fff17 	ldw	r4,-4(fp)
 2025b00:	01408174 	movhi	r5,517
 2025b04:	297aa104 	addi	r5,r5,-5500
 2025b08:	100d883a 	mov	r6,r2
 2025b0c:	2026e100 	call	2026e10 <ns_printf>
   
   /* tx statistics */
   ns_printf (pio, "[Tx ] IGMPv2 Leave Group messages sent: %lu, Membership Reports sent: %lu\n", igmpstats.igmpv2mode_v2_leave_msgs_sent, igmpstats.igmpv2mode_v2_reports_sent);
 2025b10:	00809934 	movhi	r2,612
 2025b14:	10b5c504 	addi	r2,r2,-10476
 2025b18:	10c01717 	ldw	r3,92(r2)
 2025b1c:	00809934 	movhi	r2,612
 2025b20:	10b5c504 	addi	r2,r2,-10476
 2025b24:	10801817 	ldw	r2,96(r2)
 2025b28:	e13fff17 	ldw	r4,-4(fp)
 2025b2c:	01408174 	movhi	r5,517
 2025b30:	297aad04 	addi	r5,r5,-5452
 2025b34:	180d883a 	mov	r6,r3
 2025b38:	100f883a 	mov	r7,r2
 2025b3c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Tx ] IGMPv1 Host Membership Reports sent: %lu\n", igmpstats.igmp_v1_reports_sent);
 2025b40:	00809934 	movhi	r2,612
 2025b44:	10b5c504 	addi	r2,r2,-10476
 2025b48:	10801617 	ldw	r2,88(r2)
 2025b4c:	e13fff17 	ldw	r4,-4(fp)
 2025b50:	01408174 	movhi	r5,517
 2025b54:	297ac004 	addi	r5,r5,-5376
 2025b58:	100d883a 	mov	r6,r2
 2025b5c:	2026e100 	call	2026e10 <ns_printf>

   /* error statistics */
   ns_printf (pio, "[Err] IGMP packets rcvd with bad length: %lu\n", igmpstats.igmp_badlen_rcvd);
 2025b60:	00809934 	movhi	r2,612
 2025b64:	10b5c504 	addi	r2,r2,-10476
 2025b68:	10800a17 	ldw	r2,40(r2)
 2025b6c:	e13fff17 	ldw	r4,-4(fp)
 2025b70:	01408174 	movhi	r5,517
 2025b74:	297acc04 	addi	r5,r5,-5328
 2025b78:	100d883a 	mov	r6,r2
 2025b7c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets rcvd with bad checksum: %lu\n", igmpstats.igmp_badsum_rcvd);
 2025b80:	00809934 	movhi	r2,612
 2025b84:	10b5c504 	addi	r2,r2,-10476
 2025b88:	10800b17 	ldw	r2,44(r2)
 2025b8c:	e13fff17 	ldw	r4,-4(fp)
 2025b90:	01408174 	movhi	r5,517
 2025b94:	297ad804 	addi	r5,r5,-5280
 2025b98:	100d883a 	mov	r6,r2
 2025b9c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] Packet buffer allocation failures: %lu, Bad IGMP Oper Mode config: %lu\n",igmpstats.igmp_pkt_alloc_fail, igmpstats.igmp_bad_oper_mode);
 2025ba0:	00809934 	movhi	r2,612
 2025ba4:	10b5c504 	addi	r2,r2,-10476
 2025ba8:	10c00c17 	ldw	r3,48(r2)
 2025bac:	00809934 	movhi	r2,612
 2025bb0:	10b5c504 	addi	r2,r2,-10476
 2025bb4:	10800d17 	ldw	r2,52(r2)
 2025bb8:	e13fff17 	ldw	r4,-4(fp)
 2025bbc:	01408174 	movhi	r5,517
 2025bc0:	297ae404 	addi	r5,r5,-5232
 2025bc4:	180d883a 	mov	r6,r3
 2025bc8:	100f883a 	mov	r7,r2
 2025bcc:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMP Queries rcvd: %lu, Bad IGMP Reports rcvd: %lu\n", igmpstats.igmp_bad_queries_rcvd, igmpstats.igmp_bad_reports_rcvd); 
 2025bd0:	00809934 	movhi	r2,612
 2025bd4:	10b5c504 	addi	r2,r2,-10476
 2025bd8:	10c00e17 	ldw	r3,56(r2)
 2025bdc:	00809934 	movhi	r2,612
 2025be0:	10b5c504 	addi	r2,r2,-10476
 2025be4:	10800f17 	ldw	r2,60(r2)
 2025be8:	e13fff17 	ldw	r4,-4(fp)
 2025bec:	01408174 	movhi	r5,517
 2025bf0:	297af804 	addi	r5,r5,-5152
 2025bf4:	180d883a 	mov	r6,r3
 2025bf8:	100f883a 	mov	r7,r2
 2025bfc:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] Bad IGMPv2 Group-Specific Queries rcvd: %lu\n", igmpstats.igmpv2mode_v2_bad_grp_specific_queries_rcvd);
 2025c00:	00809934 	movhi	r2,612
 2025c04:	10b5c504 	addi	r2,r2,-10476
 2025c08:	10801117 	ldw	r2,68(r2)
 2025c0c:	e13fff17 	ldw	r4,-4(fp)
 2025c10:	01408174 	movhi	r5,517
 2025c14:	297b0804 	addi	r5,r5,-5088
 2025c18:	100d883a 	mov	r6,r2
 2025c1c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] IGMPv2 Group-Specific Queries rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd);
 2025c20:	00809934 	movhi	r2,612
 2025c24:	10b5c504 	addi	r2,r2,-10476
 2025c28:	10801217 	ldw	r2,72(r2)
 2025c2c:	e13fff17 	ldw	r4,-4(fp)
 2025c30:	01408174 	movhi	r5,517
 2025c34:	297b1504 	addi	r5,r5,-5036
 2025c38:	100d883a 	mov	r6,r2
 2025c3c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] IGMP Membership Reports rcvd with unknown Group Address: %lu\n", igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd);
 2025c40:	00809934 	movhi	r2,612
 2025c44:	10b5c504 	addi	r2,r2,-10476
 2025c48:	10801317 	ldw	r2,76(r2)
 2025c4c:	e13fff17 	ldw	r4,-4(fp)
 2025c50:	01408174 	movhi	r5,517
 2025c54:	297b2804 	addi	r5,r5,-4960
 2025c58:	100d883a 	mov	r6,r2
 2025c5c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] Number of IGMPv2 messages rcvd without Router Alert option: %lu\n", igmpstats.igmpv2mode_v2_rtr_alert_missing); 
 2025c60:	00809934 	movhi	r2,612
 2025c64:	10b5c504 	addi	r2,r2,-10476
 2025c68:	10801417 	ldw	r2,80(r2)
 2025c6c:	e13fff17 	ldw	r4,-4(fp)
 2025c70:	01408174 	movhi	r5,517
 2025c74:	297b3904 	addi	r5,r5,-4892
 2025c78:	100d883a 	mov	r6,r2
 2025c7c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v1-mode links: %lu\n", igmpstats.igmpv1mode_unknown_pkttype);
 2025c80:	00809934 	movhi	r2,612
 2025c84:	10b5c504 	addi	r2,r2,-10476
 2025c88:	10801017 	ldw	r2,64(r2)
 2025c8c:	e13fff17 	ldw	r4,-4(fp)
 2025c90:	01408174 	movhi	r5,517
 2025c94:	297b4b04 	addi	r5,r5,-4820
 2025c98:	100d883a 	mov	r6,r2
 2025c9c:	2026e100 	call	2026e10 <ns_printf>
   ns_printf (pio, "[Err] IGMP packets of unknown type rcvd by v2-mode links: %lu\n", igmpstats.igmpv2mode_unknown_pkttype);
 2025ca0:	00809934 	movhi	r2,612
 2025ca4:	10b5c504 	addi	r2,r2,-10476
 2025ca8:	10801517 	ldw	r2,84(r2)
 2025cac:	e13fff17 	ldw	r4,-4(fp)
 2025cb0:	01408174 	movhi	r5,517
 2025cb4:	297b5b04 	addi	r5,r5,-4756
 2025cb8:	100d883a 	mov	r6,r2
 2025cbc:	2026e100 	call	2026e10 <ns_printf>
   
   return IGMP_OK;
 2025cc0:	0005883a 	mov	r2,zero
}
 2025cc4:	e037883a 	mov	sp,fp
 2025cc8:	dfc00117 	ldw	ra,4(sp)
 2025ccc:	df000017 	ldw	fp,0(sp)
 2025cd0:	dec00204 	addi	sp,sp,8
 2025cd4:	f800283a 	ret

02025cd8 <bsd_accept>:
 *          The error is available via bsd_errno(s).
 */
BSD_SOCKET
bsd_accept(BSD_SOCKET s,
           struct sockaddr * addr, int * addrlen)
{
 2025cd8:	defff404 	addi	sp,sp,-48
 2025cdc:	dfc00b15 	stw	ra,44(sp)
 2025ce0:	df000a15 	stw	fp,40(sp)
 2025ce4:	df000a04 	addi	fp,sp,40
 2025ce8:	e13ffd15 	stw	r4,-12(fp)
 2025cec:	e17ffe15 	stw	r5,-8(fp)
 2025cf0:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr laddr;
   long lret;

   so = LONG2SO(s);
 2025cf4:	e0bffd17 	ldw	r2,-12(fp)
 2025cf8:	10bff804 	addi	r2,r2,-32
 2025cfc:	1085883a 	add	r2,r2,r2
 2025d00:	1085883a 	add	r2,r2,r2
 2025d04:	e0bff715 	stw	r2,-36(fp)
   SOC_CHECK(so);
 2025d08:	00809934 	movhi	r2,612
 2025d0c:	10b6c204 	addi	r2,r2,-9464
 2025d10:	e0bff615 	stw	r2,-40(fp)
 2025d14:	00000606 	br	2025d30 <bsd_accept+0x58>
 2025d18:	e0fff617 	ldw	r3,-40(fp)
 2025d1c:	e0bff717 	ldw	r2,-36(fp)
 2025d20:	18800526 	beq	r3,r2,2025d38 <bsd_accept+0x60>
 2025d24:	e0bff617 	ldw	r2,-40(fp)
 2025d28:	10800017 	ldw	r2,0(r2)
 2025d2c:	e0bff615 	stw	r2,-40(fp)
 2025d30:	e0bff617 	ldw	r2,-40(fp)
 2025d34:	103ff81e 	bne	r2,zero,2025d18 <bsd_accept+0x40>
 2025d38:	e0fff617 	ldw	r3,-40(fp)
 2025d3c:	e0bff717 	ldw	r2,-36(fp)
 2025d40:	18800326 	beq	r3,r2,2025d50 <bsd_accept+0x78>
 2025d44:	20285c80 	call	20285c8 <dtrap>
 2025d48:	00bfffc4 	movi	r2,-1
 2025d4c:	00002306 	br	2025ddc <bsd_accept+0x104>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (addr != NULL)
 2025d50:	e0bffe17 	ldw	r2,-8(fp)
 2025d54:	10000726 	beq	r2,zero,2025d74 <bsd_accept+0x9c>
   {
      if (addrlen == 0)
 2025d58:	e0bfff17 	ldw	r2,-4(fp)
 2025d5c:	1000051e 	bne	r2,zero,2025d74 <bsd_accept+0x9c>
      {
         so->so_error = EFAULT;
 2025d60:	e0bff717 	ldw	r2,-36(fp)
 2025d64:	00c00384 	movi	r3,14
 2025d68:	10c00615 	stw	r3,24(r2)
         return -1;
 2025d6c:	00bfffc4 	movi	r2,-1
 2025d70:	00001a06 	br	2025ddc <bsd_accept+0x104>
      }
   }

   lret = t_accept(s, &laddr, addrlen);
 2025d74:	e0bff904 	addi	r2,fp,-28
 2025d78:	e13ffd17 	ldw	r4,-12(fp)
 2025d7c:	100b883a 	mov	r5,r2
 2025d80:	e1bfff17 	ldw	r6,-4(fp)
 2025d84:	202b78c0 	call	202b78c <t_accept>
 2025d88:	e0bff815 	stw	r2,-32(fp)
    * address: copy the peer's address back into the buffer, but limit
    * the copy to the lesser of the buffer's length and sizeof(struct
    * sockaddr_in), which is all that t_accept() can return as a peer
    * address.  
    */
   if ((lret != -1) && (addr != NULL))
 2025d8c:	e0bff817 	ldw	r2,-32(fp)
 2025d90:	10bfffe0 	cmpeqi	r2,r2,-1
 2025d94:	1000101e 	bne	r2,zero,2025dd8 <bsd_accept+0x100>
 2025d98:	e0bffe17 	ldw	r2,-8(fp)
 2025d9c:	10000e26 	beq	r2,zero,2025dd8 <bsd_accept+0x100>
   {
      if (*addrlen > sizeof(struct sockaddr_in))
 2025da0:	e0bfff17 	ldw	r2,-4(fp)
 2025da4:	10800017 	ldw	r2,0(r2)
 2025da8:	10800470 	cmpltui	r2,r2,17
 2025dac:	1000031e 	bne	r2,zero,2025dbc <bsd_accept+0xe4>
         *addrlen = sizeof(struct sockaddr_in);
 2025db0:	e0bfff17 	ldw	r2,-4(fp)
 2025db4:	00c00404 	movi	r3,16
 2025db8:	10c00015 	stw	r3,0(r2)
      MEMCPY(addr, &laddr, *addrlen);
 2025dbc:	e0bfff17 	ldw	r2,-4(fp)
 2025dc0:	10800017 	ldw	r2,0(r2)
 2025dc4:	e0fff904 	addi	r3,fp,-28
 2025dc8:	e13ffe17 	ldw	r4,-8(fp)
 2025dcc:	180b883a 	mov	r5,r3
 2025dd0:	100d883a 	mov	r6,r2
 2025dd4:	200660c0 	call	200660c <memcpy>
   }

   return lret;
 2025dd8:	e0bff817 	ldw	r2,-32(fp)
}
 2025ddc:	e037883a 	mov	sp,fp
 2025de0:	dfc00117 	ldw	ra,4(sp)
 2025de4:	df000017 	ldw	fp,0(sp)
 2025de8:	dec00204 	addi	sp,sp,8
 2025dec:	f800283a 	ret

02025df0 <bsd_getpeername>:
 *          available via bsd_errno(s).
 */
int
bsd_getpeername(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 2025df0:	defff304 	addi	sp,sp,-52
 2025df4:	dfc00c15 	stw	ra,48(sp)
 2025df8:	df000b15 	stw	fp,44(sp)
 2025dfc:	df000b04 	addi	fp,sp,44
 2025e00:	e13ffd15 	stw	r4,-12(fp)
 2025e04:	e17ffe15 	stw	r5,-8(fp)
 2025e08:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 2025e0c:	e0bffd17 	ldw	r2,-12(fp)
 2025e10:	10bff804 	addi	r2,r2,-32
 2025e14:	1085883a 	add	r2,r2,r2
 2025e18:	1085883a 	add	r2,r2,r2
 2025e1c:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 2025e20:	00809934 	movhi	r2,612
 2025e24:	10b6c204 	addi	r2,r2,-9464
 2025e28:	e0bff515 	stw	r2,-44(fp)
 2025e2c:	00000606 	br	2025e48 <bsd_getpeername+0x58>
 2025e30:	e0fff517 	ldw	r3,-44(fp)
 2025e34:	e0bff617 	ldw	r2,-40(fp)
 2025e38:	18800526 	beq	r3,r2,2025e50 <bsd_getpeername+0x60>
 2025e3c:	e0bff517 	ldw	r2,-44(fp)
 2025e40:	10800017 	ldw	r2,0(r2)
 2025e44:	e0bff515 	stw	r2,-44(fp)
 2025e48:	e0bff517 	ldw	r2,-44(fp)
 2025e4c:	103ff81e 	bne	r2,zero,2025e30 <bsd_getpeername+0x40>
 2025e50:	e0fff517 	ldw	r3,-44(fp)
 2025e54:	e0bff617 	ldw	r2,-40(fp)
 2025e58:	18800326 	beq	r3,r2,2025e68 <bsd_getpeername+0x78>
 2025e5c:	20285c80 	call	20285c8 <dtrap>
 2025e60:	00bfffc4 	movi	r2,-1
 2025e64:	00002306 	br	2025ef4 <bsd_getpeername+0x104>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 2025e68:	e0bfff17 	ldw	r2,-4(fp)
 2025e6c:	1000051e 	bne	r2,zero,2025e84 <bsd_getpeername+0x94>
   {
      so->so_error = EFAULT;
 2025e70:	e0bff617 	ldw	r2,-40(fp)
 2025e74:	00c00384 	movi	r3,14
 2025e78:	10c00615 	stw	r3,24(r2)
      return -1;
 2025e7c:	00bfffc4 	movi	r2,-1
 2025e80:	00001c06 	br	2025ef4 <bsd_getpeername+0x104>
   }
   lnamelen = *namelen;
 2025e84:	e0bfff17 	ldw	r2,-4(fp)
 2025e88:	10800017 	ldw	r2,0(r2)
 2025e8c:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getpeername(s, &lname, &lnamelen);
 2025e90:	e0fff804 	addi	r3,fp,-32
 2025e94:	e0bffc04 	addi	r2,fp,-16
 2025e98:	e13ffd17 	ldw	r4,-12(fp)
 2025e9c:	180b883a 	mov	r5,r3
 2025ea0:	100d883a 	mov	r6,r2
 2025ea4:	202bc400 	call	202bc40 <t_getpeername>
 2025ea8:	e0bff715 	stw	r2,-36(fp)
    * t_getpeername() can return as a peer address, and pass the
    * copied length back to the caller.  
    * For IPV6 addresses, or for dual IPV4/IPV6 stack, 
    * the max size is sizeof(struct sockaddr_in6)
    */
   if (lret != -1)
 2025eac:	e0bff717 	ldw	r2,-36(fp)
 2025eb0:	10bfffe0 	cmpeqi	r2,r2,-1
 2025eb4:	10000e1e 	bne	r2,zero,2025ef0 <bsd_getpeername+0x100>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 2025eb8:	e0bffc17 	ldw	r2,-16(fp)
 2025ebc:	10800470 	cmpltui	r2,r2,17
 2025ec0:	1000021e 	bne	r2,zero,2025ecc <bsd_getpeername+0xdc>
         lnamelen = sizeof(struct sockaddr_in);
 2025ec4:	00800404 	movi	r2,16
 2025ec8:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(name, &lname, lnamelen);
 2025ecc:	e0bffc17 	ldw	r2,-16(fp)
 2025ed0:	e0fff804 	addi	r3,fp,-32
 2025ed4:	e13ffe17 	ldw	r4,-8(fp)
 2025ed8:	180b883a 	mov	r5,r3
 2025edc:	100d883a 	mov	r6,r2
 2025ee0:	200660c0 	call	200660c <memcpy>
      *namelen = lnamelen;
 2025ee4:	e0fffc17 	ldw	r3,-16(fp)
 2025ee8:	e0bfff17 	ldw	r2,-4(fp)
 2025eec:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 2025ef0:	e0bff717 	ldw	r2,-36(fp)
}
 2025ef4:	e037883a 	mov	sp,fp
 2025ef8:	dfc00117 	ldw	ra,4(sp)
 2025efc:	df000017 	ldw	fp,0(sp)
 2025f00:	dec00204 	addi	sp,sp,8
 2025f04:	f800283a 	ret

02025f08 <bsd_getsockname>:
 *          available via bsd_errno(s).
 */
int
bsd_getsockname(BSD_SOCKET s,
                struct sockaddr * name, int * namelen)
{
 2025f08:	defff304 	addi	sp,sp,-52
 2025f0c:	dfc00c15 	stw	ra,48(sp)
 2025f10:	df000b15 	stw	fp,44(sp)
 2025f14:	df000b04 	addi	fp,sp,44
 2025f18:	e13ffd15 	stw	r4,-12(fp)
 2025f1c:	e17ffe15 	stw	r5,-8(fp)
 2025f20:	e1bfff15 	stw	r6,-4(fp)
   struct socket * so;
   struct sockaddr lname;
   int lnamelen;
   int lret;

   so = LONG2SO(s);
 2025f24:	e0bffd17 	ldw	r2,-12(fp)
 2025f28:	10bff804 	addi	r2,r2,-32
 2025f2c:	1085883a 	add	r2,r2,r2
 2025f30:	1085883a 	add	r2,r2,r2
 2025f34:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 2025f38:	00809934 	movhi	r2,612
 2025f3c:	10b6c204 	addi	r2,r2,-9464
 2025f40:	e0bff515 	stw	r2,-44(fp)
 2025f44:	00000606 	br	2025f60 <bsd_getsockname+0x58>
 2025f48:	e0fff517 	ldw	r3,-44(fp)
 2025f4c:	e0bff617 	ldw	r2,-40(fp)
 2025f50:	18800526 	beq	r3,r2,2025f68 <bsd_getsockname+0x60>
 2025f54:	e0bff517 	ldw	r2,-44(fp)
 2025f58:	10800017 	ldw	r2,0(r2)
 2025f5c:	e0bff515 	stw	r2,-44(fp)
 2025f60:	e0bff517 	ldw	r2,-44(fp)
 2025f64:	103ff81e 	bne	r2,zero,2025f48 <bsd_getsockname+0x40>
 2025f68:	e0fff517 	ldw	r3,-44(fp)
 2025f6c:	e0bff617 	ldw	r2,-40(fp)
 2025f70:	18800326 	beq	r3,r2,2025f80 <bsd_getsockname+0x78>
 2025f74:	20285c80 	call	20285c8 <dtrap>
 2025f78:	00bfffc4 	movi	r2,-1
 2025f7c:	00002306 	br	202600c <bsd_getsockname+0x104>

   /* if the buffer length is bogus, fail */
   if (namelen == NULL)
 2025f80:	e0bfff17 	ldw	r2,-4(fp)
 2025f84:	1000051e 	bne	r2,zero,2025f9c <bsd_getsockname+0x94>
   {
      so->so_error = EFAULT;
 2025f88:	e0bff617 	ldw	r2,-40(fp)
 2025f8c:	00c00384 	movi	r3,14
 2025f90:	10c00615 	stw	r3,24(r2)
      return -1;
 2025f94:	00bfffc4 	movi	r2,-1
 2025f98:	00001c06 	br	202600c <bsd_getsockname+0x104>
   }
   lnamelen = *namelen;
 2025f9c:	e0bfff17 	ldw	r2,-4(fp)
 2025fa0:	10800017 	ldw	r2,0(r2)
 2025fa4:	e0bffc15 	stw	r2,-16(fp)

   lret = t_getsockname(s, &lname, &lnamelen);
 2025fa8:	e0fff804 	addi	r3,fp,-32
 2025fac:	e0bffc04 	addi	r2,fp,-16
 2025fb0:	e13ffd17 	ldw	r4,-12(fp)
 2025fb4:	180b883a 	mov	r5,r3
 2025fb8:	100d883a 	mov	r6,r2
 2025fbc:	202bc840 	call	202bc84 <t_getsockname>
 2025fc0:	e0bff715 	stw	r2,-36(fp)
    * copied length back to the caller.  
    * For IPV6 addresses, or for a dual IPV4/IPV6 stack, 
    * the max size copied is sizeof(struct sockaddr_in6)
    *
    */
   if (lret != -1)
 2025fc4:	e0bff717 	ldw	r2,-36(fp)
 2025fc8:	10bfffe0 	cmpeqi	r2,r2,-1
 2025fcc:	10000e1e 	bne	r2,zero,2026008 <bsd_getsockname+0x100>
   {
#ifndef IP_V6
      if (lnamelen > sizeof(struct sockaddr_in))
 2025fd0:	e0bffc17 	ldw	r2,-16(fp)
 2025fd4:	10800470 	cmpltui	r2,r2,17
 2025fd8:	1000021e 	bne	r2,zero,2025fe4 <bsd_getsockname+0xdc>
         lnamelen = sizeof(struct sockaddr_in);
 2025fdc:	00800404 	movi	r2,16
 2025fe0:	e0bffc15 	stw	r2,-16(fp)
#else
      if (lnamelen > sizeof(struct sockaddr_in6))
         lnamelen = sizeof(struct sockaddr_in6);
#endif
      MEMCPY(name, &lname, lnamelen);
 2025fe4:	e0bffc17 	ldw	r2,-16(fp)
 2025fe8:	e0fff804 	addi	r3,fp,-32
 2025fec:	e13ffe17 	ldw	r4,-8(fp)
 2025ff0:	180b883a 	mov	r5,r3
 2025ff4:	100d883a 	mov	r6,r2
 2025ff8:	200660c0 	call	200660c <memcpy>
      *namelen = lnamelen;
 2025ffc:	e0fffc17 	ldw	r3,-16(fp)
 2026000:	e0bfff17 	ldw	r2,-4(fp)
 2026004:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 2026008:	e0bff717 	ldw	r2,-36(fp)
}
 202600c:	e037883a 	mov	sp,fp
 2026010:	dfc00117 	ldw	ra,4(sp)
 2026014:	df000017 	ldw	fp,0(sp)
 2026018:	dec00204 	addi	sp,sp,8
 202601c:	f800283a 	ret

02026020 <bsd_i_sockoptlen>:
 * RETURNS: minimum length of the named socket option, in bytes
 */
int 
bsd_i_sockoptlen(int level,
                 int name)
{
 2026020:	defffd04 	addi	sp,sp,-12
 2026024:	df000215 	stw	fp,8(sp)
 2026028:	df000204 	addi	fp,sp,8
 202602c:	e13ffe15 	stw	r4,-8(fp)
 2026030:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(level);

   switch (name)
 2026034:	e0bfff17 	ldw	r2,-4(fp)
 2026038:	10c02020 	cmpeqi	r3,r2,128
 202603c:	1800341e 	bne	r3,zero,2026110 <bsd_i_sockoptlen+0xf0>
 2026040:	10c02048 	cmpgei	r3,r2,129
 2026044:	18001a1e 	bne	r3,zero,20260b0 <bsd_i_sockoptlen+0x90>
 2026048:	10c00308 	cmpgei	r3,r2,12
 202604c:	18000e1e 	bne	r3,zero,2026088 <bsd_i_sockoptlen+0x68>
 2026050:	10c00288 	cmpgei	r3,r2,10
 2026054:	1800361e 	bne	r3,zero,2026130 <bsd_i_sockoptlen+0x110>
 2026058:	10c00120 	cmpeqi	r3,r2,4
 202605c:	1800301e 	bne	r3,zero,2026120 <bsd_i_sockoptlen+0x100>
 2026060:	10c00148 	cmpgei	r3,r2,5
 2026064:	1800031e 	bne	r3,zero,2026074 <bsd_i_sockoptlen+0x54>
 2026068:	108000e0 	cmpeqi	r2,r2,3
 202606c:	1000341e 	bne	r2,zero,2026140 <bsd_i_sockoptlen+0x120>
 2026070:	00003506 	br	2026148 <bsd_i_sockoptlen+0x128>
 2026074:	10c00220 	cmpeqi	r3,r2,8
 2026078:	1800291e 	bne	r3,zero,2026120 <bsd_i_sockoptlen+0x100>
 202607c:	10800260 	cmpeqi	r2,r2,9
 2026080:	1000291e 	bne	r2,zero,2026128 <bsd_i_sockoptlen+0x108>
 2026084:	00003006 	br	2026148 <bsd_i_sockoptlen+0x128>
 2026088:	10c00420 	cmpeqi	r3,r2,16
 202608c:	1800241e 	bne	r3,zero,2026120 <bsd_i_sockoptlen+0x100>
 2026090:	10c00448 	cmpgei	r3,r2,17
 2026094:	1800031e 	bne	r3,zero,20260a4 <bsd_i_sockoptlen+0x84>
 2026098:	10800388 	cmpgei	r2,r2,14
 202609c:	10002a1e 	bne	r2,zero,2026148 <bsd_i_sockoptlen+0x128>
 20260a0:	00002506 	br	2026138 <bsd_i_sockoptlen+0x118>
 20260a4:	10800820 	cmpeqi	r2,r2,32
 20260a8:	10001d1e 	bne	r2,zero,2026120 <bsd_i_sockoptlen+0x100>
 20260ac:	00002606 	br	2026148 <bsd_i_sockoptlen+0x128>
 20260b0:	10c401c8 	cmpgei	r3,r2,4103
 20260b4:	18000a1e 	bne	r3,zero,20260e0 <bsd_i_sockoptlen+0xc0>
 20260b8:	10c40148 	cmpgei	r3,r2,4101
 20260bc:	1800161e 	bne	r3,zero,2026118 <bsd_i_sockoptlen+0xf8>
 20260c0:	10c04020 	cmpeqi	r3,r2,256
 20260c4:	1800161e 	bne	r3,zero,2026120 <bsd_i_sockoptlen+0x100>
 20260c8:	10c04010 	cmplti	r3,r2,256
 20260cc:	18001e1e 	bne	r3,zero,2026148 <bsd_i_sockoptlen+0x128>
 20260d0:	10bbffc4 	addi	r2,r2,-4097
 20260d4:	108000a8 	cmpgeui	r2,r2,2
 20260d8:	10001b1e 	bne	r2,zero,2026148 <bsd_i_sockoptlen+0x128>
 20260dc:	00001006 	br	2026120 <bsd_i_sockoptlen+0x100>
 20260e0:	10c40588 	cmpgei	r3,r2,4118
 20260e4:	1800051e 	bne	r3,zero,20260fc <bsd_i_sockoptlen+0xdc>
 20260e8:	10c40508 	cmpgei	r3,r2,4116
 20260ec:	1800061e 	bne	r3,zero,2026108 <bsd_i_sockoptlen+0xe8>
 20260f0:	10840248 	cmpgei	r2,r2,4105
 20260f4:	1000141e 	bne	r2,zero,2026148 <bsd_i_sockoptlen+0x128>
 20260f8:	00000906 	br	2026120 <bsd_i_sockoptlen+0x100>
 20260fc:	108405a0 	cmpeqi	r2,r2,4118
 2026100:	1000071e 	bne	r2,zero,2026120 <bsd_i_sockoptlen+0x100>
 2026104:	00001006 	br	2026148 <bsd_i_sockoptlen+0x128>
   {
   case SO_BIO:
   case SO_NBIO:
      /* these don't use an option value */
      return 0;
 2026108:	0005883a 	mov	r2,zero
 202610c:	00000f06 	br	202614c <bsd_i_sockoptlen+0x12c>
   case SO_LINGER:
      /* this option is a struct linger */
      return sizeof(struct linger);
 2026110:	00800204 	movi	r2,8
 2026114:	00000d06 	br	202614c <bsd_i_sockoptlen+0x12c>
   case SO_RCVTIMEO:
   case SO_SNDTIMEO:
      /* these options are type short */
      return sizeof(short);
 2026118:	00800084 	movi	r2,2
 202611c:	00000b06 	br	202614c <bsd_i_sockoptlen+0x12c>
   case SO_RCVBUF:
   case SO_NONBLOCK:
   case SO_ERROR:
   case SO_TYPE:
      /* these options are type int */
      return sizeof(int);
 2026120:	00800104 	movi	r2,4
 2026124:	00000906 	br	202614c <bsd_i_sockoptlen+0x12c>
      return sizeof(int (*)());
#endif /* TCP_ZEROCOPY */
#ifdef IP_MULTICAST
   case IP_MULTICAST_IF:
      /* this option is type ip_addr */
      return sizeof(ip_addr);
 2026128:	00800104 	movi	r2,4
 202612c:	00000706 	br	202614c <bsd_i_sockoptlen+0x12c>
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      /* these options are type u_char */
      return sizeof(u_char);
 2026130:	00800044 	movi	r2,1
 2026134:	00000506 	br	202614c <bsd_i_sockoptlen+0x12c>
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      /* these options are struct ip_mreq */
      return sizeof(struct ip_mreq);
 2026138:	00800204 	movi	r2,8
 202613c:	00000306 	br	202614c <bsd_i_sockoptlen+0x12c>
 * IP_TTL_OPT == SOREUSEADDR. This causes a build erro
 * due to duplicate cases. Removing this one. They both
 * return the same value (sizeof(int)).
 */
  // case IP_TTL_OPT:
      return sizeof(int);
 2026140:	00800104 	movi	r2,4
 2026144:	00000106 	br	202614c <bsd_i_sockoptlen+0x12c>
   default:
      /* we don't know what type these options are */
      return 0;
 2026148:	0005883a 	mov	r2,zero
   }
   
}
 202614c:	e037883a 	mov	sp,fp
 2026150:	df000017 	ldw	fp,0(sp)
 2026154:	dec00104 	addi	sp,sp,4
 2026158:	f800283a 	ret

0202615c <bsd_getsockopt>:
int
bsd_getsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int * optlen)
{
 202615c:	defff504 	addi	sp,sp,-44
 2026160:	dfc00a15 	stw	ra,40(sp)
 2026164:	df000915 	stw	fp,36(sp)
 2026168:	df000904 	addi	fp,sp,36
 202616c:	e13ffc15 	stw	r4,-16(fp)
 2026170:	e17ffd15 	stw	r5,-12(fp)
 2026174:	e1bffe15 	stw	r6,-8(fp)
 2026178:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   int loptlen;
   int e;

   so = LONG2SO(s);
 202617c:	e0bffc17 	ldw	r2,-16(fp)
 2026180:	10bff804 	addi	r2,r2,-32
 2026184:	1085883a 	add	r2,r2,r2
 2026188:	1085883a 	add	r2,r2,r2
 202618c:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 2026190:	00809934 	movhi	r2,612
 2026194:	10b6c204 	addi	r2,r2,-9464
 2026198:	e0bff815 	stw	r2,-32(fp)
 202619c:	00000606 	br	20261b8 <bsd_getsockopt+0x5c>
 20261a0:	e0fff817 	ldw	r3,-32(fp)
 20261a4:	e0bff917 	ldw	r2,-28(fp)
 20261a8:	18800526 	beq	r3,r2,20261c0 <bsd_getsockopt+0x64>
 20261ac:	e0bff817 	ldw	r2,-32(fp)
 20261b0:	10800017 	ldw	r2,0(r2)
 20261b4:	e0bff815 	stw	r2,-32(fp)
 20261b8:	e0bff817 	ldw	r2,-32(fp)
 20261bc:	103ff81e 	bne	r2,zero,20261a0 <bsd_getsockopt+0x44>
 20261c0:	e0fff817 	ldw	r3,-32(fp)
 20261c4:	e0bff917 	ldw	r2,-28(fp)
 20261c8:	18800326 	beq	r3,r2,20261d8 <bsd_getsockopt+0x7c>
 20261cc:	20285c80 	call	20285c8 <dtrap>
 20261d0:	00bfffc4 	movi	r2,-1
 20261d4:	00001d06 	br	202624c <bsd_getsockopt+0xf0>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   loptlen = bsd_i_sockoptlen(level, name);
 20261d8:	e13ffd17 	ldw	r4,-12(fp)
 20261dc:	e17ffe17 	ldw	r5,-8(fp)
 20261e0:	20260200 	call	2026020 <bsd_i_sockoptlen>
 20261e4:	e0bffa15 	stw	r2,-24(fp)
   if ((optlen == NULL) || (*optlen < loptlen))
 20261e8:	e0800217 	ldw	r2,8(fp)
 20261ec:	10000426 	beq	r2,zero,2026200 <bsd_getsockopt+0xa4>
 20261f0:	e0800217 	ldw	r2,8(fp)
 20261f4:	10c00017 	ldw	r3,0(r2)
 20261f8:	e0bffa17 	ldw	r2,-24(fp)
 20261fc:	1880050e 	bge	r3,r2,2026214 <bsd_getsockopt+0xb8>
   {
      so->so_error = EFAULT;
 2026200:	e0bff917 	ldw	r2,-28(fp)
 2026204:	00c00384 	movi	r3,14
 2026208:	10c00615 	stw	r3,24(r2)
      return -1;
 202620c:	00bfffc4 	movi	r2,-1
 2026210:	00000e06 	br	202624c <bsd_getsockopt+0xf0>
   }

   e = t_getsockopt(s, level, name, opt, loptlen);
 2026214:	e0bffa17 	ldw	r2,-24(fp)
 2026218:	d8800015 	stw	r2,0(sp)
 202621c:	e13ffc17 	ldw	r4,-16(fp)
 2026220:	e17ffd17 	ldw	r5,-12(fp)
 2026224:	e1bffe17 	ldw	r6,-8(fp)
 2026228:	e1ffff17 	ldw	r7,-4(fp)
 202622c:	202c0500 	call	202c050 <t_getsockopt>
 2026230:	e0bffb15 	stw	r2,-20(fp)

   /* if it worked, copy the option length back for the caller's use */
   if (e == 0)
 2026234:	e0bffb17 	ldw	r2,-20(fp)
 2026238:	1000031e 	bne	r2,zero,2026248 <bsd_getsockopt+0xec>
   {
      *optlen = loptlen;
 202623c:	e0800217 	ldw	r2,8(fp)
 2026240:	e0fffa17 	ldw	r3,-24(fp)
 2026244:	10c00015 	stw	r3,0(r2)
   }

   return e;
 2026248:	e0bffb17 	ldw	r2,-20(fp)
   
}
 202624c:	e037883a 	mov	sp,fp
 2026250:	dfc00117 	ldw	ra,4(sp)
 2026254:	df000017 	ldw	fp,0(sp)
 2026258:	dec00204 	addi	sp,sp,8
 202625c:	f800283a 	ret

02026260 <bsd_ioctl>:
 *          available via bsd_errno(s).
 */
int
bsd_ioctl(BSD_SOCKET s, 
          unsigned long request, ...)
{
 2026260:	defff504 	addi	sp,sp,-44
 2026264:	dfc00815 	stw	ra,32(sp)
 2026268:	df000715 	stw	fp,28(sp)
 202626c:	df000704 	addi	fp,sp,28
 2026270:	e13ffe15 	stw	r4,-8(fp)
 2026274:	e1800215 	stw	r6,8(fp)
 2026278:	e1c00315 	stw	r7,12(fp)
 202627c:	e17fff15 	stw	r5,-4(fp)
   struct socket * so;
   va_list argptr;
   int iarg;

   so = LONG2SO(s);
 2026280:	e0bffe17 	ldw	r2,-8(fp)
 2026284:	10bff804 	addi	r2,r2,-32
 2026288:	1085883a 	add	r2,r2,r2
 202628c:	1085883a 	add	r2,r2,r2
 2026290:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 2026294:	00809934 	movhi	r2,612
 2026298:	10b6c204 	addi	r2,r2,-9464
 202629c:	e0bffa15 	stw	r2,-24(fp)
 20262a0:	00000606 	br	20262bc <bsd_ioctl+0x5c>
 20262a4:	e0fffa17 	ldw	r3,-24(fp)
 20262a8:	e0bffb17 	ldw	r2,-20(fp)
 20262ac:	18800526 	beq	r3,r2,20262c4 <bsd_ioctl+0x64>
 20262b0:	e0bffa17 	ldw	r2,-24(fp)
 20262b4:	10800017 	ldw	r2,0(r2)
 20262b8:	e0bffa15 	stw	r2,-24(fp)
 20262bc:	e0bffa17 	ldw	r2,-24(fp)
 20262c0:	103ff81e 	bne	r2,zero,20262a4 <bsd_ioctl+0x44>
 20262c4:	e0fffa17 	ldw	r3,-24(fp)
 20262c8:	e0bffb17 	ldw	r2,-20(fp)
 20262cc:	18800326 	beq	r3,r2,20262dc <bsd_ioctl+0x7c>
 20262d0:	20285c80 	call	20285c8 <dtrap>
 20262d4:	00bfffc4 	movi	r2,-1
 20262d8:	00001706 	br	2026338 <bsd_ioctl+0xd8>

   va_start(argptr, request);
 20262dc:	e0800204 	addi	r2,fp,8
 20262e0:	e0bffc15 	stw	r2,-16(fp)

   switch (request)
 20262e4:	e0bfff17 	ldw	r2,-4(fp)
 20262e8:	108405a0 	cmpeqi	r2,r2,4118
 20262ec:	10000e26 	beq	r2,zero,2026328 <bsd_ioctl+0xc8>
   {
   case FIONBIO:
      iarg = va_arg(argptr, int);
 20262f0:	e0bffc17 	ldw	r2,-16(fp)
 20262f4:	10c00104 	addi	r3,r2,4
 20262f8:	e0fffc15 	stw	r3,-16(fp)
 20262fc:	10800017 	ldw	r2,0(r2)
 2026300:	e0bffd15 	stw	r2,-12(fp)
      va_end(argptr);
      return t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, &iarg, sizeof(iarg));
 2026304:	e0bffd04 	addi	r2,fp,-12
 2026308:	00c00104 	movi	r3,4
 202630c:	d8c00015 	stw	r3,0(sp)
 2026310:	e13ffe17 	ldw	r4,-8(fp)
 2026314:	017fffc4 	movi	r5,-1
 2026318:	01840584 	movi	r6,4118
 202631c:	100f883a 	mov	r7,r2
 2026320:	202be9c0 	call	202be9c <t_setsockopt>
 2026324:	00000406 	br	2026338 <bsd_ioctl+0xd8>
   default:
      so->so_error = EINVAL;
 2026328:	e0bffb17 	ldw	r2,-20(fp)
 202632c:	00c00584 	movi	r3,22
 2026330:	10c00615 	stw	r3,24(r2)
      return -1;
 2026334:	00bfffc4 	movi	r2,-1
   }
}
 2026338:	e037883a 	mov	sp,fp
 202633c:	dfc00117 	ldw	ra,4(sp)
 2026340:	df000017 	ldw	fp,0(sp)
 2026344:	dec00404 	addi	sp,sp,16
 2026348:	f800283a 	ret

0202634c <bsd_inet_ntoa>:
 * RETURNS: pointer to null-terminated string containing dotted-decimal
 *          printable representation of in
 */
char *
bsd_inet_ntoa(struct in_addr in)
{
 202634c:	defffd04 	addi	sp,sp,-12
 2026350:	dfc00215 	stw	ra,8(sp)
 2026354:	df000115 	stw	fp,4(sp)
 2026358:	df000104 	addi	fp,sp,4
 202635c:	e13fff15 	stw	r4,-4(fp)
   return print_ipad(in.s_addr);
 2026360:	e0bfff17 	ldw	r2,-4(fp)
 2026364:	1009883a 	mov	r4,r2
 2026368:	2026a400 	call	2026a40 <print_ipad>
}
 202636c:	e037883a 	mov	sp,fp
 2026370:	dfc00117 	ldw	ra,4(sp)
 2026374:	df000017 	ldw	fp,0(sp)
 2026378:	dec00204 	addi	sp,sp,8
 202637c:	f800283a 	ret

02026380 <bsd_recvfrom>:
bsd_recvfrom(BSD_SOCKET s,
             void * buf,
             BSD_SIZE_T len,
             int flags,
             struct sockaddr * from, int * fromlen)
{
 2026380:	defff004 	addi	sp,sp,-64
 2026384:	dfc00f15 	stw	ra,60(sp)
 2026388:	df000e15 	stw	fp,56(sp)
 202638c:	df000e04 	addi	fp,sp,56
 2026390:	e13ffc15 	stw	r4,-16(fp)
 2026394:	e17ffd15 	stw	r5,-12(fp)
 2026398:	e1bffe15 	stw	r6,-8(fp)
 202639c:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;
   struct sockaddr lfrom;
   int lfromlen = 0;
 20263a0:	e03ffb15 	stw	zero,-20(fp)
   int lret;

   so = LONG2SO(s);
 20263a4:	e0bffc17 	ldw	r2,-16(fp)
 20263a8:	10bff804 	addi	r2,r2,-32
 20263ac:	1085883a 	add	r2,r2,r2
 20263b0:	1085883a 	add	r2,r2,r2
 20263b4:	e0bff515 	stw	r2,-44(fp)
   SOC_CHECK(so);
 20263b8:	00809934 	movhi	r2,612
 20263bc:	10b6c204 	addi	r2,r2,-9464
 20263c0:	e0bff415 	stw	r2,-48(fp)
 20263c4:	00000606 	br	20263e0 <bsd_recvfrom+0x60>
 20263c8:	e0fff417 	ldw	r3,-48(fp)
 20263cc:	e0bff517 	ldw	r2,-44(fp)
 20263d0:	18800526 	beq	r3,r2,20263e8 <bsd_recvfrom+0x68>
 20263d4:	e0bff417 	ldw	r2,-48(fp)
 20263d8:	10800017 	ldw	r2,0(r2)
 20263dc:	e0bff415 	stw	r2,-48(fp)
 20263e0:	e0bff417 	ldw	r2,-48(fp)
 20263e4:	103ff81e 	bne	r2,zero,20263c8 <bsd_recvfrom+0x48>
 20263e8:	e0fff417 	ldw	r3,-48(fp)
 20263ec:	e0bff517 	ldw	r2,-44(fp)
 20263f0:	18800326 	beq	r3,r2,2026400 <bsd_recvfrom+0x80>
 20263f4:	20285c80 	call	20285c8 <dtrap>
 20263f8:	00bfffc4 	movi	r2,-1
 20263fc:	00002a06 	br	20264a8 <bsd_recvfrom+0x128>

   /* if we were given a buffer for the peer's address, also get the
    * buffer's length 
    */
   if (from != NULL)
 2026400:	e0800217 	ldw	r2,8(fp)
 2026404:	10000a26 	beq	r2,zero,2026430 <bsd_recvfrom+0xb0>
   {
      if (fromlen == NULL)
 2026408:	e0800317 	ldw	r2,12(fp)
 202640c:	1000051e 	bne	r2,zero,2026424 <bsd_recvfrom+0xa4>
      {
         so->so_error = EFAULT;
 2026410:	e0bff517 	ldw	r2,-44(fp)
 2026414:	00c00384 	movi	r3,14
 2026418:	10c00615 	stw	r3,24(r2)
         return -1;
 202641c:	00bfffc4 	movi	r2,-1
 2026420:	00002106 	br	20264a8 <bsd_recvfrom+0x128>
      }
      lfromlen = *fromlen;
 2026424:	e0800317 	ldw	r2,12(fp)
 2026428:	10800017 	ldw	r2,0(r2)
 202642c:	e0bffb15 	stw	r2,-20(fp)
   }

   lret = t_recvfrom(s, (char *)buf, len, flags, &lfrom, &lfromlen );
 2026430:	e0bff704 	addi	r2,fp,-36
 2026434:	d8800015 	stw	r2,0(sp)
 2026438:	e0bffb04 	addi	r2,fp,-20
 202643c:	d8800115 	stw	r2,4(sp)
 2026440:	e13ffc17 	ldw	r4,-16(fp)
 2026444:	e17ffd17 	ldw	r5,-12(fp)
 2026448:	e1bffe17 	ldw	r6,-8(fp)
 202644c:	e1ffff17 	ldw	r7,-4(fp)
 2026450:	202c2b40 	call	202c2b4 <t_recvfrom>
 2026454:	e0bff615 	stw	r2,-40(fp)
    * sockaddr_in), which is all that t_recvfrom() can return as a peer
    * name.
    * For IPV6 addresses or dual IPV4/IPV6 stack, the max size copied
    * is sizeof(struct sockaddr_in6)
    */
   if ((lret != -1) && (from != NULL))
 2026458:	e0bff617 	ldw	r2,-40(fp)
 202645c:	10bfffe0 	cmpeqi	r2,r2,-1
 2026460:	1000101e 	bne	r2,zero,20264a4 <bsd_recvfrom+0x124>
 2026464:	e0800217 	ldw	r2,8(fp)
 2026468:	10000e26 	beq	r2,zero,20264a4 <bsd_recvfrom+0x124>
   {
#ifndef IP_V6
      if (lfromlen > sizeof(struct sockaddr_in))
 202646c:	e0bffb17 	ldw	r2,-20(fp)
 2026470:	10800470 	cmpltui	r2,r2,17
 2026474:	1000021e 	bne	r2,zero,2026480 <bsd_recvfrom+0x100>
         lfromlen = sizeof(struct sockaddr_in);
 2026478:	00800404 	movi	r2,16
 202647c:	e0bffb15 	stw	r2,-20(fp)
#else
      if (lfromlen > sizeof(struct sockaddr_in6))
         lfromlen = sizeof(struct sockaddr_in6);

#endif
      MEMCPY(from, &lfrom, lfromlen);
 2026480:	e0bffb17 	ldw	r2,-20(fp)
 2026484:	e0fff704 	addi	r3,fp,-36
 2026488:	e1000217 	ldw	r4,8(fp)
 202648c:	180b883a 	mov	r5,r3
 2026490:	100d883a 	mov	r6,r2
 2026494:	200660c0 	call	200660c <memcpy>
      *fromlen = lfromlen;
 2026498:	e0fffb17 	ldw	r3,-20(fp)
 202649c:	e0800317 	ldw	r2,12(fp)
 20264a0:	10c00015 	stw	r3,0(r2)
   }

   return lret;
 20264a4:	e0bff617 	ldw	r2,-40(fp)
}
 20264a8:	e037883a 	mov	sp,fp
 20264ac:	dfc00117 	ldw	ra,4(sp)
 20264b0:	df000017 	ldw	fp,0(sp)
 20264b4:	dec00204 	addi	sp,sp,8
 20264b8:	f800283a 	ret

020264bc <bsd_select>:
bsd_select(int nfds,
           fd_set * readfds,
           fd_set * writefds,
           fd_set * exceptfds,
           BSD_TIMEVAL_T * timeout)
{
 20264bc:	defff604 	addi	sp,sp,-40
 20264c0:	dfc00915 	stw	ra,36(sp)
 20264c4:	df000815 	stw	fp,32(sp)
 20264c8:	dc400715 	stw	r17,28(sp)
 20264cc:	dc000615 	stw	r16,24(sp)
 20264d0:	df000604 	addi	fp,sp,24
 20264d4:	e13ffc15 	stw	r4,-16(fp)
 20264d8:	e17ffd15 	stw	r5,-12(fp)
 20264dc:	e1bffe15 	stw	r6,-8(fp)
 20264e0:	e1ffff15 	stw	r7,-4(fp)
   long ltv;    /* timeout expressed in ticks */
   long tps;    /* local copy of TPS */

   USE_ARG(nfds);

   if (timeout != NULL)
 20264e4:	e0800417 	ldw	r2,16(fp)
 20264e8:	10005926 	beq	r2,zero,2026650 <bsd_select+0x194>
       * million (i.e. any number of microseconds up to one second).
       * So we scale tv_usec from microseconds to something reasonable
       * based on TPS, multiply it by TPS, then scale it the rest of
       * the way to ticks-per-second.
       */
      tps = TPS;
 20264ec:	00801904 	movi	r2,100
 20264f0:	e0bffb15 	stw	r2,-20(fp)
      if (tps >= 1000)
 20264f4:	e0bffb17 	ldw	r2,-20(fp)
 20264f8:	1080fa10 	cmplti	r2,r2,1000
 20264fc:	10000b1e 	bne	r2,zero,202652c <bsd_select+0x70>
      {
         ltv = (((timeout->tv_usec + 50) / 100) * tps) / 10000;
 2026500:	e0800417 	ldw	r2,16(fp)
 2026504:	10800117 	ldw	r2,4(r2)
 2026508:	10c00c84 	addi	r3,r2,50
 202650c:	00801904 	movi	r2,100
 2026510:	1887283a 	div	r3,r3,r2
 2026514:	e0bffb17 	ldw	r2,-20(fp)
 2026518:	1887383a 	mul	r3,r3,r2
 202651c:	0089c404 	movi	r2,10000
 2026520:	1885283a 	div	r2,r3,r2
 2026524:	e0bffa15 	stw	r2,-24(fp)
 2026528:	00002806 	br	20265cc <bsd_select+0x110>
      }
      else if (tps >= 100)
 202652c:	e0bffb17 	ldw	r2,-20(fp)
 2026530:	10801910 	cmplti	r2,r2,100
 2026534:	10000b1e 	bne	r2,zero,2026564 <bsd_select+0xa8>
      {
         ltv = (((timeout->tv_usec + 500) / 1000) * tps) / 1000;
 2026538:	e0800417 	ldw	r2,16(fp)
 202653c:	10800117 	ldw	r2,4(r2)
 2026540:	10c07d04 	addi	r3,r2,500
 2026544:	0080fa04 	movi	r2,1000
 2026548:	1887283a 	div	r3,r3,r2
 202654c:	e0bffb17 	ldw	r2,-20(fp)
 2026550:	1887383a 	mul	r3,r3,r2
 2026554:	0080fa04 	movi	r2,1000
 2026558:	1885283a 	div	r2,r3,r2
 202655c:	e0bffa15 	stw	r2,-24(fp)
 2026560:	00001a06 	br	20265cc <bsd_select+0x110>
      }
      else if (tps >= 10)
 2026564:	e0bffb17 	ldw	r2,-20(fp)
 2026568:	10800290 	cmplti	r2,r2,10
 202656c:	10000b1e 	bne	r2,zero,202659c <bsd_select+0xe0>
      {
         ltv = (((timeout->tv_usec + 5000) / 10000) * tps) / 100;
 2026570:	e0800417 	ldw	r2,16(fp)
 2026574:	10800117 	ldw	r2,4(r2)
 2026578:	10c4e204 	addi	r3,r2,5000
 202657c:	0089c404 	movi	r2,10000
 2026580:	1887283a 	div	r3,r3,r2
 2026584:	e0bffb17 	ldw	r2,-20(fp)
 2026588:	1887383a 	mul	r3,r3,r2
 202658c:	00801904 	movi	r2,100
 2026590:	1885283a 	div	r2,r3,r2
 2026594:	e0bffa15 	stw	r2,-24(fp)
 2026598:	00000c06 	br	20265cc <bsd_select+0x110>
      }
      else
      {
         ltv = (((timeout->tv_usec + 50000) / 100000) * tps) / 10;
 202659c:	e0800417 	ldw	r2,16(fp)
 20265a0:	10c00117 	ldw	r3,4(r2)
 20265a4:	00b0d414 	movui	r2,50000
 20265a8:	1887883a 	add	r3,r3,r2
 20265ac:	008000b4 	movhi	r2,2
 20265b0:	10a1a804 	addi	r2,r2,-31072
 20265b4:	1887283a 	div	r3,r3,r2
 20265b8:	e0bffb17 	ldw	r2,-20(fp)
 20265bc:	1887383a 	mul	r3,r3,r2
 20265c0:	00800284 	movi	r2,10
 20265c4:	1885283a 	div	r2,r3,r2
 20265c8:	e0bffa15 	stw	r2,-24(fp)
      }
      ltv += (timeout->tv_sec * TPS);
 20265cc:	e13ffa17 	ldw	r4,-24(fp)
 20265d0:	20143580 	call	2014358 <__floatsidf>
 20265d4:	1021883a 	mov	r16,r2
 20265d8:	1823883a 	mov	r17,r3
 20265dc:	e0800417 	ldw	r2,16(fp)
 20265e0:	10800017 	ldw	r2,0(r2)
 20265e4:	1009883a 	mov	r4,r2
 20265e8:	20143580 	call	2014358 <__floatsidf>
 20265ec:	100b883a 	mov	r5,r2
 20265f0:	180d883a 	mov	r6,r3
 20265f4:	2809883a 	mov	r4,r5
 20265f8:	300b883a 	mov	r5,r6
 20265fc:	000d883a 	mov	r6,zero
 2026600:	01d01674 	movhi	r7,16473
 2026604:	2013c880 	call	2013c88 <__muldf3>
 2026608:	1009883a 	mov	r4,r2
 202660c:	180b883a 	mov	r5,r3
 2026610:	2005883a 	mov	r2,r4
 2026614:	2807883a 	mov	r3,r5
 2026618:	8009883a 	mov	r4,r16
 202661c:	880b883a 	mov	r5,r17
 2026620:	100d883a 	mov	r6,r2
 2026624:	180f883a 	mov	r7,r3
 2026628:	2013bd40 	call	2013bd4 <__adddf3>
 202662c:	1009883a 	mov	r4,r2
 2026630:	180b883a 	mov	r5,r3
 2026634:	2005883a 	mov	r2,r4
 2026638:	2807883a 	mov	r3,r5
 202663c:	1009883a 	mov	r4,r2
 2026640:	180b883a 	mov	r5,r3
 2026644:	201442c0 	call	201442c <__fixdfsi>
 2026648:	e0bffa15 	stw	r2,-24(fp)
 202664c:	00000206 	br	2026658 <bsd_select+0x19c>
   }
   else {
      /*
       * NULL timeout: wait indefinitely in t_select()
       */
      ltv = -1;
 2026650:	00bfffc4 	movi	r2,-1
 2026654:	e0bffa15 	stw	r2,-24(fp)
   }

   return (t_select(readfds, writefds, exceptfds, ltv));
 2026658:	e13ffd17 	ldw	r4,-12(fp)
 202665c:	e17ffe17 	ldw	r5,-8(fp)
 2026660:	e1bfff17 	ldw	r6,-4(fp)
 2026664:	e1fffa17 	ldw	r7,-24(fp)
 2026668:	202fdd40 	call	202fdd4 <t_select>
}
 202666c:	e037883a 	mov	sp,fp
 2026670:	dfc00317 	ldw	ra,12(sp)
 2026674:	df000217 	ldw	fp,8(sp)
 2026678:	dc400117 	ldw	r17,4(sp)
 202667c:	dc000017 	ldw	r16,0(sp)
 2026680:	dec00404 	addi	sp,sp,16
 2026684:	f800283a 	ret

02026688 <bsd_setsockopt>:
int 
bsd_setsockopt(BSD_SOCKET s,
               int level,
               int name,
               void * opt, int optlen)
{
 2026688:	defff704 	addi	sp,sp,-36
 202668c:	dfc00815 	stw	ra,32(sp)
 2026690:	df000715 	stw	fp,28(sp)
 2026694:	df000704 	addi	fp,sp,28
 2026698:	e13ffc15 	stw	r4,-16(fp)
 202669c:	e17ffd15 	stw	r5,-12(fp)
 20266a0:	e1bffe15 	stw	r6,-8(fp)
 20266a4:	e1ffff15 	stw	r7,-4(fp)
   struct socket * so;

   so = LONG2SO(s);
 20266a8:	e0bffc17 	ldw	r2,-16(fp)
 20266ac:	10bff804 	addi	r2,r2,-32
 20266b0:	1085883a 	add	r2,r2,r2
 20266b4:	1085883a 	add	r2,r2,r2
 20266b8:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 20266bc:	00809934 	movhi	r2,612
 20266c0:	10b6c204 	addi	r2,r2,-9464
 20266c4:	e0bffa15 	stw	r2,-24(fp)
 20266c8:	00000606 	br	20266e4 <bsd_setsockopt+0x5c>
 20266cc:	e0fffa17 	ldw	r3,-24(fp)
 20266d0:	e0bffb17 	ldw	r2,-20(fp)
 20266d4:	18800526 	beq	r3,r2,20266ec <bsd_setsockopt+0x64>
 20266d8:	e0bffa17 	ldw	r2,-24(fp)
 20266dc:	10800017 	ldw	r2,0(r2)
 20266e0:	e0bffa15 	stw	r2,-24(fp)
 20266e4:	e0bffa17 	ldw	r2,-24(fp)
 20266e8:	103ff81e 	bne	r2,zero,20266cc <bsd_setsockopt+0x44>
 20266ec:	e0fffa17 	ldw	r3,-24(fp)
 20266f0:	e0bffb17 	ldw	r2,-20(fp)
 20266f4:	18800326 	beq	r3,r2,2026704 <bsd_setsockopt+0x7c>
 20266f8:	20285c80 	call	20285c8 <dtrap>
 20266fc:	00bfffc4 	movi	r2,-1
 2026700:	00001106 	br	2026748 <bsd_setsockopt+0xc0>

   /* make sure supplied option value is big enough for the 
    * named option, else fail w/error EFAULT
    */
   if (optlen < bsd_i_sockoptlen(level, name))
 2026704:	e13ffd17 	ldw	r4,-12(fp)
 2026708:	e17ffe17 	ldw	r5,-8(fp)
 202670c:	20260200 	call	2026020 <bsd_i_sockoptlen>
 2026710:	e0c00217 	ldw	r3,8(fp)
 2026714:	1880050e 	bge	r3,r2,202672c <bsd_setsockopt+0xa4>
   {
      so->so_error = EFAULT;
 2026718:	e0bffb17 	ldw	r2,-20(fp)
 202671c:	00c00384 	movi	r3,14
 2026720:	10c00615 	stw	r3,24(r2)
      return -1;
 2026724:	00bfffc4 	movi	r2,-1
 2026728:	00000706 	br	2026748 <bsd_setsockopt+0xc0>
   }

   return t_setsockopt(s, level, name, opt, optlen);
 202672c:	e0800217 	ldw	r2,8(fp)
 2026730:	d8800015 	stw	r2,0(sp)
 2026734:	e13ffc17 	ldw	r4,-16(fp)
 2026738:	e17ffd17 	ldw	r5,-12(fp)
 202673c:	e1bffe17 	ldw	r6,-8(fp)
 2026740:	e1ffff17 	ldw	r7,-4(fp)
 2026744:	202be9c0 	call	202be9c <t_setsockopt>
}
 2026748:	e037883a 	mov	sp,fp
 202674c:	dfc00117 	ldw	ra,4(sp)
 2026750:	df000017 	ldw	fp,0(sp)
 2026754:	dec00204 	addi	sp,sp,8
 2026758:	f800283a 	ret

0202675c <ccksum>:
 * be done in 16-bit chunks.
 */

unsigned short
ccksum (void *ptr, unsigned words)
{
 202675c:	defffa04 	addi	sp,sp,-24
 2026760:	df000515 	stw	fp,20(sp)
 2026764:	df000504 	addi	fp,sp,20
 2026768:	e13ffe15 	stw	r4,-8(fp)
 202676c:	e17fff15 	stw	r5,-4(fp)
   unsigned short *addr = (unsigned short *)ptr;
 2026770:	e0bffe17 	ldw	r2,-8(fp)
 2026774:	e0bffb15 	stw	r2,-20(fp)
   unsigned long sum = 0;
 2026778:	e03ffc15 	stw	zero,-16(fp)
   int count = (int)words;
 202677c:	e0bfff17 	ldw	r2,-4(fp)
 2026780:	e0bffd15 	stw	r2,-12(fp)

   while (--count >= 0)
 2026784:	00000906 	br	20267ac <ccksum+0x50>
   {
      /*  This is the inner loop */
      sum += *addr++;
 2026788:	e0bffb17 	ldw	r2,-20(fp)
 202678c:	1080000b 	ldhu	r2,0(r2)
 2026790:	10bfffcc 	andi	r2,r2,65535
 2026794:	e0fffc17 	ldw	r3,-16(fp)
 2026798:	1885883a 	add	r2,r3,r2
 202679c:	e0bffc15 	stw	r2,-16(fp)
 20267a0:	e0bffb17 	ldw	r2,-20(fp)
 20267a4:	10800084 	addi	r2,r2,2
 20267a8:	e0bffb15 	stw	r2,-20(fp)
{
   unsigned short *addr = (unsigned short *)ptr;
   unsigned long sum = 0;
   int count = (int)words;

   while (--count >= 0)
 20267ac:	e0bffd17 	ldw	r2,-12(fp)
 20267b0:	10bfffc4 	addi	r2,r2,-1
 20267b4:	e0bffd15 	stw	r2,-12(fp)
 20267b8:	e0bffd17 	ldw	r2,-12(fp)
 20267bc:	103ff20e 	bge	r2,zero,2026788 <ccksum+0x2c>
      /*  This is the inner loop */
      sum += *addr++;
   }

   /*  Fold 32-bit sum to 16 bits */
   sum = (sum & 0xffff) + (sum >> 16);
 20267c0:	e0bffc17 	ldw	r2,-16(fp)
 20267c4:	10ffffcc 	andi	r3,r2,65535
 20267c8:	e0bffc17 	ldw	r2,-16(fp)
 20267cc:	1004d43a 	srli	r2,r2,16
 20267d0:	1885883a 	add	r2,r3,r2
 20267d4:	e0bffc15 	stw	r2,-16(fp)
   sum = (sum & 0xffff) + (sum >> 16);
 20267d8:	e0bffc17 	ldw	r2,-16(fp)
 20267dc:	10ffffcc 	andi	r3,r2,65535
 20267e0:	e0bffc17 	ldw	r2,-16(fp)
 20267e4:	1004d43a 	srli	r2,r2,16
 20267e8:	1885883a 	add	r2,r3,r2
 20267ec:	e0bffc15 	stw	r2,-16(fp)

   /* checksum = ~sum; *//* removed for MIT IP stack */
   return ((unsigned short)sum);
 20267f0:	e0bffc17 	ldw	r2,-16(fp)
}
 20267f4:	e037883a 	mov	sp,fp
 20267f8:	df000017 	ldw	fp,0(sp)
 20267fc:	dec00104 	addi	sp,sp,4
 2026800:	f800283a 	ret

02026804 <cksum>:
 *    3 = user-supplied alternate implementation
 */

unsigned short
cksum (void *ptr, unsigned count)
{
 2026804:	defffc04 	addi	sp,sp,-16
 2026808:	dfc00315 	stw	ra,12(sp)
 202680c:	df000215 	stw	fp,8(sp)
 2026810:	df000204 	addi	fp,sp,8
 2026814:	e13ffe15 	stw	r4,-8(fp)
 2026818:	e17fff15 	stw	r5,-4(fp)
   switch (cksum_select)
 202681c:	d0a03a17 	ldw	r2,-32536(gp)
 2026820:	108000a0 	cmpeqi	r2,r2,2
 2026824:	1000041e 	bne	r2,zero,2026838 <cksum+0x34>
   {
      case 1:
      default:
         return (ccksum(ptr, count));
 2026828:	e13ffe17 	ldw	r4,-8(fp)
 202682c:	e17fff17 	ldw	r5,-4(fp)
 2026830:	202675c0 	call	202675c <ccksum>
 2026834:	00000306 	br	2026844 <cksum+0x40>
 #ifndef C_CHECKSUM
      case 2:
         return (asm_cksum(ptr, count));
 2026838:	e13ffe17 	ldw	r4,-8(fp)
 202683c:	e17fff17 	ldw	r5,-4(fp)
 2026840:	20284340 	call	2028434 <asm_cksum>
#else
#endif
         return (alt_cksum(ptr, count));
#endif
   }
}
 2026844:	e037883a 	mov	sp,fp
 2026848:	dfc00117 	ldw	ra,4(sp)
 202684c:	df000017 	ldw	fp,0(sp)
 2026850:	dec00204 	addi	sp,sp,8
 2026854:	f800283a 	ret

02026858 <do_trap>:
 * RETURNS: 0
 */

int
do_trap(void)
{
 2026858:	defffe04 	addi	sp,sp,-8
 202685c:	dfc00115 	stw	ra,4(sp)
 2026860:	df000015 	stw	fp,0(sp)
 2026864:	d839883a 	mov	fp,sp
   dtrap();
 2026868:	20285c80 	call	20285c8 <dtrap>
   return 0;
 202686c:	0005883a 	mov	r2,zero
}
 2026870:	e037883a 	mov	sp,fp
 2026874:	dfc00117 	ldw	ra,4(sp)
 2026878:	df000017 	ldw	fp,0(sp)
 202687c:	dec00204 	addi	sp,sp,8
 2026880:	f800283a 	ret

02026884 <nextarg>:
 * RETURNS:  pointer to next arg in string 
 */

char *   
nextarg(char * argp)
{
 2026884:	defffe04 	addi	sp,sp,-8
 2026888:	df000115 	stw	fp,4(sp)
 202688c:	df000104 	addi	fp,sp,4
 2026890:	e13fff15 	stw	r4,-4(fp)
   while (*argp > ' ')argp++; /* scan past current arg */
 2026894:	00000306 	br	20268a4 <nextarg+0x20>
 2026898:	e0bfff17 	ldw	r2,-4(fp)
 202689c:	10800044 	addi	r2,r2,1
 20268a0:	e0bfff15 	stw	r2,-4(fp)
 20268a4:	e0bfff17 	ldw	r2,-4(fp)
 20268a8:	10800003 	ldbu	r2,0(r2)
 20268ac:	10803fcc 	andi	r2,r2,255
 20268b0:	1080201c 	xori	r2,r2,128
 20268b4:	10bfe004 	addi	r2,r2,-128
 20268b8:	10800848 	cmpgei	r2,r2,33
 20268bc:	103ff61e 	bne	r2,zero,2026898 <nextarg+0x14>
      while (*argp == ' ')argp++;   /* scan past spaces */
 20268c0:	00000306 	br	20268d0 <nextarg+0x4c>
 20268c4:	e0bfff17 	ldw	r2,-4(fp)
 20268c8:	10800044 	addi	r2,r2,1
 20268cc:	e0bfff15 	stw	r2,-4(fp)
 20268d0:	e0bfff17 	ldw	r2,-4(fp)
 20268d4:	10800003 	ldbu	r2,0(r2)
 20268d8:	10803fcc 	andi	r2,r2,255
 20268dc:	1080201c 	xori	r2,r2,128
 20268e0:	10bfe004 	addi	r2,r2,-128
 20268e4:	10800820 	cmpeqi	r2,r2,32
 20268e8:	103ff61e 	bne	r2,zero,20268c4 <nextarg+0x40>
      return (argp);
 20268ec:	e0bfff17 	ldw	r2,-4(fp)
}
 20268f0:	e037883a 	mov	sp,fp
 20268f4:	df000017 	ldw	fp,0(sp)
 20268f8:	dec00104 	addi	sp,sp,4
 20268fc:	f800283a 	ret

02026900 <hexdump>:

#define  HEX_BYTES_PER_LINE   16

void
hexdump(void * pio, void * buffer, unsigned len)
{
 2026900:	defff804 	addi	sp,sp,-32
 2026904:	dfc00715 	stw	ra,28(sp)
 2026908:	df000615 	stw	fp,24(sp)
 202690c:	df000604 	addi	fp,sp,24
 2026910:	e13ffd15 	stw	r4,-12(fp)
 2026914:	e17ffe15 	stw	r5,-8(fp)
 2026918:	e1bfff15 	stw	r6,-4(fp)
   u_char * data  =  (u_char *)buffer;
 202691c:	e0bffe17 	ldw	r2,-8(fp)
 2026920:	e0bffa15 	stw	r2,-24(fp)
   unsigned int count;
   char  c;

   while (len)
 2026924:	00003f06 	br	2026a24 <hexdump+0x124>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 2026928:	e03ffb15 	stw	zero,-20(fp)
 202692c:	00000d06 	br	2026964 <hexdump+0x64>
         ns_printf(pio, "%02x ", *(data + count));
 2026930:	e0fffa17 	ldw	r3,-24(fp)
 2026934:	e0bffb17 	ldw	r2,-20(fp)
 2026938:	1885883a 	add	r2,r3,r2
 202693c:	10800003 	ldbu	r2,0(r2)
 2026940:	10803fcc 	andi	r2,r2,255
 2026944:	e13ffd17 	ldw	r4,-12(fp)
 2026948:	01408174 	movhi	r5,517
 202694c:	297b6b04 	addi	r5,r5,-4692
 2026950:	100d883a 	mov	r6,r2
 2026954:	2026e100 	call	2026e10 <ns_printf>
   char  c;

   while (len)
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 2026958:	e0bffb17 	ldw	r2,-20(fp)
 202695c:	10800044 	addi	r2,r2,1
 2026960:	e0bffb15 	stw	r2,-20(fp)
 2026964:	e0bffb17 	ldw	r2,-20(fp)
 2026968:	10800428 	cmpgeui	r2,r2,16
 202696c:	1000031e 	bne	r2,zero,202697c <hexdump+0x7c>
 2026970:	e0fffb17 	ldw	r3,-20(fp)
 2026974:	e0bfff17 	ldw	r2,-4(fp)
 2026978:	18bfed36 	bltu	r3,r2,2026930 <hexdump+0x30>
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 202697c:	e03ffb15 	stw	zero,-20(fp)
 2026980:	00001606 	br	20269dc <hexdump+0xdc>
      {
         c = *(data + count);
 2026984:	e0fffa17 	ldw	r3,-24(fp)
 2026988:	e0bffb17 	ldw	r2,-20(fp)
 202698c:	1885883a 	add	r2,r3,r2
 2026990:	10800003 	ldbu	r2,0(r2)
 2026994:	e0bffc05 	stb	r2,-16(fp)
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
 2026998:	e0bffc07 	ldb	r2,-16(fp)
 202699c:	10800810 	cmplti	r2,r2,32
 20269a0:	1000051e 	bne	r2,zero,20269b8 <hexdump+0xb8>
 20269a4:	e0bffc07 	ldb	r2,-16(fp)
 20269a8:	10801fe0 	cmpeqi	r2,r2,127
 20269ac:	1000021e 	bne	r2,zero,20269b8 <hexdump+0xb8>
 20269b0:	e0bffc07 	ldb	r2,-16(fp)
 20269b4:	00000106 	br	20269bc <hexdump+0xbc>
 20269b8:	00800b84 	movi	r2,46
 20269bc:	e13ffd17 	ldw	r4,-12(fp)
 20269c0:	01408174 	movhi	r5,517
 20269c4:	297b6d04 	addi	r5,r5,-4684
 20269c8:	100d883a 	mov	r6,r2
 20269cc:	2026e100 	call	2026e10 <ns_printf>
   {
      /* display data in hex */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
         ns_printf(pio, "%02x ", *(data + count));
      /* display data in ascii */
      for (count = 0; (count < HEX_BYTES_PER_LINE) && (count < len); ++count)
 20269d0:	e0bffb17 	ldw	r2,-20(fp)
 20269d4:	10800044 	addi	r2,r2,1
 20269d8:	e0bffb15 	stw	r2,-20(fp)
 20269dc:	e0bffb17 	ldw	r2,-20(fp)
 20269e0:	10800428 	cmpgeui	r2,r2,16
 20269e4:	1000031e 	bne	r2,zero,20269f4 <hexdump+0xf4>
 20269e8:	e0fffb17 	ldw	r3,-20(fp)
 20269ec:	e0bfff17 	ldw	r2,-4(fp)
 20269f0:	18bfe436 	bltu	r3,r2,2026984 <hexdump+0x84>
      {
         c = *(data + count);
         ns_printf(pio, "%c", ((c >= 0x20) && (c < 0x7f)) ? c : '.');
      }
      ns_printf(pio,"\n");
 20269f4:	e13ffd17 	ldw	r4,-12(fp)
 20269f8:	01408174 	movhi	r5,517
 20269fc:	297b6e04 	addi	r5,r5,-4680
 2026a00:	2026e100 	call	2026e10 <ns_printf>
      len -= count;
 2026a04:	e0ffff17 	ldw	r3,-4(fp)
 2026a08:	e0bffb17 	ldw	r2,-20(fp)
 2026a0c:	1885c83a 	sub	r2,r3,r2
 2026a10:	e0bfff15 	stw	r2,-4(fp)
      data += count;
 2026a14:	e0fffa17 	ldw	r3,-24(fp)
 2026a18:	e0bffb17 	ldw	r2,-20(fp)
 2026a1c:	1885883a 	add	r2,r3,r2
 2026a20:	e0bffa15 	stw	r2,-24(fp)
{
   u_char * data  =  (u_char *)buffer;
   unsigned int count;
   char  c;

   while (len)
 2026a24:	e0bfff17 	ldw	r2,-4(fp)
 2026a28:	103fbf1e 	bne	r2,zero,2026928 <hexdump+0x28>
      }
      ns_printf(pio,"\n");
      len -= count;
      data += count;
   }
}
 2026a2c:	e037883a 	mov	sp,fp
 2026a30:	dfc00117 	ldw	ra,4(sp)
 2026a34:	df000017 	ldw	fp,0(sp)
 2026a38:	dec00204 	addi	sp,sp,8
 2026a3c:	f800283a 	ret

02026a40 <print_ipad>:

char     ipreturn[18];     /* buffer for return */

char *   
print_ipad(unsigned long ipaddr)
{
 2026a40:	defffa04 	addi	sp,sp,-24
 2026a44:	dfc00515 	stw	ra,20(sp)
 2026a48:	df000415 	stw	fp,16(sp)
 2026a4c:	df000404 	addi	fp,sp,16
 2026a50:	e13fff15 	stw	r4,-4(fp)
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
 2026a54:	e0bfff17 	ldw	r2,-4(fp)
 2026a58:	e0bffe15 	stw	r2,-8(fp)
   sprintf(ipreturn, "%u.%u.%u.%u", 
    ip.ip.ipchar[0],
 2026a5c:	e0bffe03 	ldbu	r2,-8(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 2026a60:	10c03fcc 	andi	r3,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
 2026a64:	e0bffe43 	ldbu	r2,-7(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 2026a68:	10803fcc 	andi	r2,r2,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
 2026a6c:	e13ffe83 	ldbu	r4,-6(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 2026a70:	21403fcc 	andi	r5,r4,255
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);
 2026a74:	e13ffec3 	ldbu	r4,-5(fp)
print_ipad(unsigned long ipaddr)
{
   struct l2b  ip;

   ip.ip.iplong = ipaddr;
   sprintf(ipreturn, "%u.%u.%u.%u", 
 2026a78:	21003fcc 	andi	r4,r4,255
 2026a7c:	d9400015 	stw	r5,0(sp)
 2026a80:	d9000115 	stw	r4,4(sp)
 2026a84:	01009934 	movhi	r4,612
 2026a88:	2135e284 	addi	r4,r4,-10358
 2026a8c:	01408174 	movhi	r5,517
 2026a90:	297b6f04 	addi	r5,r5,-4676
 2026a94:	180d883a 	mov	r6,r3
 2026a98:	100f883a 	mov	r7,r2
 2026a9c:	2006fec0 	call	2006fec <sprintf>
    ip.ip.ipchar[0],
    ip.ip.ipchar[1],
    ip.ip.ipchar[2],
    ip.ip.ipchar[3]);

   return ipreturn;
 2026aa0:	00809934 	movhi	r2,612
 2026aa4:	10b5e284 	addi	r2,r2,-10358
}
 2026aa8:	e037883a 	mov	sp,fp
 2026aac:	dfc00117 	ldw	ra,4(sp)
 2026ab0:	df000017 	ldw	fp,0(sp)
 2026ab4:	dec00204 	addi	sp,sp,8
 2026ab8:	f800283a 	ret

02026abc <print_uptime>:

static char tistring[24];     /* buffer for return */

char *   
print_uptime(unsigned long timetick)
{
 2026abc:	defff804 	addi	sp,sp,-32
 2026ac0:	dfc00715 	stw	ra,28(sp)
 2026ac4:	df000615 	stw	fp,24(sp)
 2026ac8:	df000604 	addi	fp,sp,24
 2026acc:	e13fff15 	stw	r4,-4(fp)
   unsigned seconds, minutes, hours;

   timetick = timetick/100;   /* turn timetick into seconds */
 2026ad0:	e0ffff17 	ldw	r3,-4(fp)
 2026ad4:	00801904 	movi	r2,100
 2026ad8:	1885203a 	divu	r2,r3,r2
 2026adc:	e0bfff15 	stw	r2,-4(fp)
   seconds = (unsigned)(timetick%60);
 2026ae0:	e0bfff17 	ldw	r2,-4(fp)
 2026ae4:	00c00f04 	movi	r3,60
 2026ae8:	10c7203a 	divu	r3,r2,r3
 2026aec:	18c00f24 	muli	r3,r3,60
 2026af0:	10c5c83a 	sub	r2,r2,r3
 2026af4:	e0bffc15 	stw	r2,-16(fp)
   timetick = timetick/60;    /* turn timetick into minutes */
 2026af8:	e0ffff17 	ldw	r3,-4(fp)
 2026afc:	00800f04 	movi	r2,60
 2026b00:	1885203a 	divu	r2,r3,r2
 2026b04:	e0bfff15 	stw	r2,-4(fp)
   minutes = (unsigned)(timetick%60);
 2026b08:	e0bfff17 	ldw	r2,-4(fp)
 2026b0c:	00c00f04 	movi	r3,60
 2026b10:	10c7203a 	divu	r3,r2,r3
 2026b14:	18c00f24 	muli	r3,r3,60
 2026b18:	10c5c83a 	sub	r2,r2,r3
 2026b1c:	e0bffd15 	stw	r2,-12(fp)
   timetick = timetick/60;    /* turn timetick into hours */
 2026b20:	e0ffff17 	ldw	r3,-4(fp)
 2026b24:	00800f04 	movi	r2,60
 2026b28:	1885203a 	divu	r2,r3,r2
 2026b2c:	e0bfff15 	stw	r2,-4(fp)
   hours = (unsigned)(timetick%24);
 2026b30:	e0bfff17 	ldw	r2,-4(fp)
 2026b34:	00c00604 	movi	r3,24
 2026b38:	10c7203a 	divu	r3,r2,r3
 2026b3c:	18c00624 	muli	r3,r3,24
 2026b40:	10c5c83a 	sub	r2,r2,r3
 2026b44:	e0bffe15 	stw	r2,-8(fp)
   timetick = timetick/24;    /* turn timetick into days */
 2026b48:	e0ffff17 	ldw	r3,-4(fp)
 2026b4c:	00800604 	movi	r2,24
 2026b50:	1885203a 	divu	r2,r3,r2
 2026b54:	e0bfff15 	stw	r2,-4(fp)

   if (timetick)  /* Is there a whole number of days? */
 2026b58:	e0bfff17 	ldw	r2,-4(fp)
 2026b5c:	10000c26 	beq	r2,zero,2026b90 <print_uptime+0xd4>
      sprintf(tistring, "%ld days, %dh:%dm:%ds", 
 2026b60:	e0bffd17 	ldw	r2,-12(fp)
 2026b64:	d8800015 	stw	r2,0(sp)
 2026b68:	e0bffc17 	ldw	r2,-16(fp)
 2026b6c:	d8800115 	stw	r2,4(sp)
 2026b70:	010081b4 	movhi	r4,518
 2026b74:	2103db04 	addi	r4,r4,3948
 2026b78:	01408174 	movhi	r5,517
 2026b7c:	297b7204 	addi	r5,r5,-4664
 2026b80:	e1bfff17 	ldw	r6,-4(fp)
 2026b84:	e1fffe17 	ldw	r7,-8(fp)
 2026b88:	2006fec0 	call	2006fec <sprintf>
 2026b8c:	00001306 	br	2026bdc <print_uptime+0x120>
    timetick, hours, minutes, seconds);
   else if (hours)
 2026b90:	e0bffe17 	ldw	r2,-8(fp)
 2026b94:	10000a26 	beq	r2,zero,2026bc0 <print_uptime+0x104>
      sprintf(tistring, "%d hours, %dm:%ds", hours, minutes, seconds);
 2026b98:	e0bffc17 	ldw	r2,-16(fp)
 2026b9c:	d8800015 	stw	r2,0(sp)
 2026ba0:	010081b4 	movhi	r4,518
 2026ba4:	2103db04 	addi	r4,r4,3948
 2026ba8:	01408174 	movhi	r5,517
 2026bac:	297b7804 	addi	r5,r5,-4640
 2026bb0:	e1bffe17 	ldw	r6,-8(fp)
 2026bb4:	e1fffd17 	ldw	r7,-12(fp)
 2026bb8:	2006fec0 	call	2006fec <sprintf>
 2026bbc:	00000706 	br	2026bdc <print_uptime+0x120>
   else
      sprintf(tistring, "%d minutes, %d sec.", minutes, seconds);
 2026bc0:	010081b4 	movhi	r4,518
 2026bc4:	2103db04 	addi	r4,r4,3948
 2026bc8:	01408174 	movhi	r5,517
 2026bcc:	297b7d04 	addi	r5,r5,-4620
 2026bd0:	e1bffd17 	ldw	r6,-12(fp)
 2026bd4:	e1fffc17 	ldw	r7,-16(fp)
 2026bd8:	2006fec0 	call	2006fec <sprintf>
   return tistring;
 2026bdc:	008081b4 	movhi	r2,518
 2026be0:	1083db04 	addi	r2,r2,3948
}
 2026be4:	e037883a 	mov	sp,fp
 2026be8:	dfc00117 	ldw	ra,4(sp)
 2026bec:	df000017 	ldw	fp,0(sp)
 2026bf0:	dec00204 	addi	sp,sp,8
 2026bf4:	f800283a 	ret

02026bf8 <panic>:
/* allow to be ifdeffed out on systems which already have a panic */
#ifndef PANIC_ALREADY

void
panic(char * msg)
{
 2026bf8:	defffd04 	addi	sp,sp,-12
 2026bfc:	dfc00215 	stw	ra,8(sp)
 2026c00:	df000115 	stw	fp,4(sp)
 2026c04:	df000104 	addi	fp,sp,4
 2026c08:	e13fff15 	stw	r4,-4(fp)
   dprintf("panic: %s\n", msg);
 2026c0c:	01008174 	movhi	r4,517
 2026c10:	213b8204 	addi	r4,r4,-4600
 2026c14:	e17fff17 	ldw	r5,-4(fp)
 2026c18:	2006a240 	call	2006a24 <printf>
   dtrap();                   /* try to hook debugger */
 2026c1c:	20285c80 	call	20285c8 <dtrap>
   netexit(1);                /* try to clean up */
 2026c20:	01000044 	movi	r4,1
 2026c24:	20441d00 	call	20441d0 <netexit>
}
 2026c28:	e037883a 	mov	sp,fp
 2026c2c:	dfc00117 	ldw	ra,4(sp)
 2026c30:	df000017 	ldw	fp,0(sp)
 2026c34:	dec00204 	addi	sp,sp,8
 2026c38:	f800283a 	ret

02026c3c <print_eth>:

char     eth_prt_buf[18];  /* buffer for return */

char *   
print_eth(char * addr, char spacer)
{
 2026c3c:	defffb04 	addi	sp,sp,-20
 2026c40:	df000415 	stw	fp,16(sp)
 2026c44:	df000404 	addi	fp,sp,16
 2026c48:	e13ffe15 	stw	r4,-8(fp)
 2026c4c:	2805883a 	mov	r2,r5
 2026c50:	e0bfff05 	stb	r2,-4(fp)
   int   i;
   char *   out   =  eth_prt_buf;
 2026c54:	00809934 	movhi	r2,612
 2026c58:	10b5de04 	addi	r2,r2,-10376
 2026c5c:	e0bffd15 	stw	r2,-12(fp)

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 2026c60:	e03ffc15 	stw	zero,-16(fp)
 2026c64:	00004006 	br	2026d68 <print_eth+0x12c>
   {
      /* high nibble */
      *out = (char)(((*addr >> 4) & 0x0f) + 0x30);
 2026c68:	e0bffe17 	ldw	r2,-8(fp)
 2026c6c:	10800003 	ldbu	r2,0(r2)
 2026c70:	10803fcc 	andi	r2,r2,255
 2026c74:	1004d13a 	srli	r2,r2,4
 2026c78:	10800c04 	addi	r2,r2,48
 2026c7c:	1007883a 	mov	r3,r2
 2026c80:	e0bffd17 	ldw	r2,-12(fp)
 2026c84:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 2026c88:	e0bffd17 	ldw	r2,-12(fp)
 2026c8c:	10800003 	ldbu	r2,0(r2)
 2026c90:	10803fcc 	andi	r2,r2,255
 2026c94:	1080201c 	xori	r2,r2,128
 2026c98:	10bfe004 	addi	r2,r2,-128
 2026c9c:	10800e90 	cmplti	r2,r2,58
 2026ca0:	1000061e 	bne	r2,zero,2026cbc <print_eth+0x80>
         (*out) += 7;
 2026ca4:	e0bffd17 	ldw	r2,-12(fp)
 2026ca8:	10800003 	ldbu	r2,0(r2)
 2026cac:	108001c4 	addi	r2,r2,7
 2026cb0:	1007883a 	mov	r3,r2
 2026cb4:	e0bffd17 	ldw	r2,-12(fp)
 2026cb8:	10c00005 	stb	r3,0(r2)
      out++;
 2026cbc:	e0bffd17 	ldw	r2,-12(fp)
 2026cc0:	10800044 	addi	r2,r2,1
 2026cc4:	e0bffd15 	stw	r2,-12(fp)

      /* low nibble */
      *out = (char)((*addr & 0x0f) + 0x30);  /* low nibble to digit */
 2026cc8:	e0bffe17 	ldw	r2,-8(fp)
 2026ccc:	10800003 	ldbu	r2,0(r2)
 2026cd0:	108003cc 	andi	r2,r2,15
 2026cd4:	10800c04 	addi	r2,r2,48
 2026cd8:	1007883a 	mov	r3,r2
 2026cdc:	e0bffd17 	ldw	r2,-12(fp)
 2026ce0:	10c00005 	stb	r3,0(r2)
      if (*out > '9')   /* need to make it A-F? */
 2026ce4:	e0bffd17 	ldw	r2,-12(fp)
 2026ce8:	10800003 	ldbu	r2,0(r2)
 2026cec:	10803fcc 	andi	r2,r2,255
 2026cf0:	1080201c 	xori	r2,r2,128
 2026cf4:	10bfe004 	addi	r2,r2,-128
 2026cf8:	10800e90 	cmplti	r2,r2,58
 2026cfc:	1000061e 	bne	r2,zero,2026d18 <print_eth+0xdc>
         (*out) += 7;   /* eg 0x3a -> 0x41 ('A') */
 2026d00:	e0bffd17 	ldw	r2,-12(fp)
 2026d04:	10800003 	ldbu	r2,0(r2)
 2026d08:	108001c4 	addi	r2,r2,7
 2026d0c:	1007883a 	mov	r3,r2
 2026d10:	e0bffd17 	ldw	r2,-12(fp)
 2026d14:	10c00005 	stb	r3,0(r2)
      out++;
 2026d18:	e0bffd17 	ldw	r2,-12(fp)
 2026d1c:	10800044 	addi	r2,r2,1
 2026d20:	e0bffd15 	stw	r2,-12(fp)

      /* optional spacer character */
      if (spacer && i < 5)
 2026d24:	e0bfff07 	ldb	r2,-4(fp)
 2026d28:	10000926 	beq	r2,zero,2026d50 <print_eth+0x114>
 2026d2c:	e0bffc17 	ldw	r2,-16(fp)
 2026d30:	10800148 	cmpgei	r2,r2,5
 2026d34:	1000061e 	bne	r2,zero,2026d50 <print_eth+0x114>
         *out++ = spacer;
 2026d38:	e0bffd17 	ldw	r2,-12(fp)
 2026d3c:	e0ffff03 	ldbu	r3,-4(fp)
 2026d40:	10c00005 	stb	r3,0(r2)
 2026d44:	e0bffd17 	ldw	r2,-12(fp)
 2026d48:	10800044 	addi	r2,r2,1
 2026d4c:	e0bffd15 	stw	r2,-12(fp)
      addr++;
 2026d50:	e0bffe17 	ldw	r2,-8(fp)
 2026d54:	10800044 	addi	r2,r2,1
 2026d58:	e0bffe15 	stw	r2,-8(fp)
{
   int   i;
   char *   out   =  eth_prt_buf;

   /* loop through 6 bytes of ethernet address */
   for (i = 0; i < 6; i++)
 2026d5c:	e0bffc17 	ldw	r2,-16(fp)
 2026d60:	10800044 	addi	r2,r2,1
 2026d64:	e0bffc15 	stw	r2,-16(fp)
 2026d68:	e0bffc17 	ldw	r2,-16(fp)
 2026d6c:	10800190 	cmplti	r2,r2,6
 2026d70:	103fbd1e 	bne	r2,zero,2026c68 <print_eth+0x2c>
      /* optional spacer character */
      if (spacer && i < 5)
         *out++ = spacer;
      addr++;
   }
   *out = 0;
 2026d74:	e0bffd17 	ldw	r2,-12(fp)
 2026d78:	10000005 	stb	zero,0(r2)
   return eth_prt_buf;
 2026d7c:	00809934 	movhi	r2,612
 2026d80:	10b5de04 	addi	r2,r2,-10376
}
 2026d84:	e037883a 	mov	sp,fp
 2026d88:	df000017 	ldw	fp,0(sp)
 2026d8c:	dec00104 	addi	sp,sp,4
 2026d90:	f800283a 	ret

02026d94 <uslash>:
 * RETURNS:  pointer to formatted text
 */

char *   
uslash(char * path)
{
 2026d94:	defffd04 	addi	sp,sp,-12
 2026d98:	df000215 	stw	fp,8(sp)
 2026d9c:	df000204 	addi	fp,sp,8
 2026da0:	e13fff15 	stw	r4,-4(fp)
   char *   cp;

   for (cp = path; *cp; cp++)
 2026da4:	e0bfff17 	ldw	r2,-4(fp)
 2026da8:	e0bffe15 	stw	r2,-8(fp)
 2026dac:	00000d06 	br	2026de4 <uslash+0x50>
      if (*cp == '\\')
 2026db0:	e0bffe17 	ldw	r2,-8(fp)
 2026db4:	10800003 	ldbu	r2,0(r2)
 2026db8:	10803fcc 	andi	r2,r2,255
 2026dbc:	1080201c 	xori	r2,r2,128
 2026dc0:	10bfe004 	addi	r2,r2,-128
 2026dc4:	10801718 	cmpnei	r2,r2,92
 2026dc8:	1000031e 	bne	r2,zero,2026dd8 <uslash+0x44>
      *cp = '/';
 2026dcc:	e0bffe17 	ldw	r2,-8(fp)
 2026dd0:	00c00bc4 	movi	r3,47
 2026dd4:	10c00005 	stb	r3,0(r2)
char *   
uslash(char * path)
{
   char *   cp;

   for (cp = path; *cp; cp++)
 2026dd8:	e0bffe17 	ldw	r2,-8(fp)
 2026ddc:	10800044 	addi	r2,r2,1
 2026de0:	e0bffe15 	stw	r2,-8(fp)
 2026de4:	e0bffe17 	ldw	r2,-8(fp)
 2026de8:	10800003 	ldbu	r2,0(r2)
 2026dec:	10803fcc 	andi	r2,r2,255
 2026df0:	1080201c 	xori	r2,r2,128
 2026df4:	10bfe004 	addi	r2,r2,-128
 2026df8:	103fed1e 	bne	r2,zero,2026db0 <uslash+0x1c>
      if (*cp == '\\')
      *cp = '/';
   return path;
 2026dfc:	e0bfff17 	ldw	r2,-4(fp)
}
 2026e00:	e037883a 	mov	sp,fp
 2026e04:	df000017 	ldw	fp,0(sp)
 2026e08:	dec00104 	addi	sp,sp,4
 2026e0c:	f800283a 	ret

02026e10 <ns_printf>:
 */
#ifndef ns_printf

int 
ns_printf(void * vio, char * format, ...)
{
 2026e10:	defff304 	addi	sp,sp,-52
 2026e14:	dfc00a15 	stw	ra,40(sp)
 2026e18:	df000915 	stw	fp,36(sp)
 2026e1c:	dc400815 	stw	r17,32(sp)
 2026e20:	dc000715 	stw	r16,28(sp)
 2026e24:	df000704 	addi	fp,sp,28
 2026e28:	e13ffe15 	stw	r4,-8(fp)
 2026e2c:	e1800415 	stw	r6,16(fp)
 2026e30:	e1c00515 	stw	r7,20(fp)
 2026e34:	e17fff15 	stw	r5,-4(fp)
   char *   outbuf=NULL;
 2026e38:	e03ffa15 	stw	zero,-24(fp)
   int   ret_value   ;
   int   buf_size =  MAXIOSIZE   ;
 2026e3c:	00802704 	movi	r2,156
 2026e40:	e0bff915 	stw	r2,-28(fp)
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 2026e44:	e0bffe17 	ldw	r2,-8(fp)
 2026e48:	e0bffb15 	stw	r2,-20(fp)
   int * next_arg=(int *)  &format;
   next_arg +=  sizeof(char *)/sizeof(int) ;
#endif   /* NATIVE_PRINTF || PRINTF_STRING */

   /* a NULL pio means just dump the output to stdout */
   if (pio == NULL)
 2026e4c:	e0bffb17 	ldw	r2,-20(fp)
 2026e50:	1000091e 	bne	r2,zero,2026e78 <ns_printf+0x68>
   {
#ifdef NATIVE_PRINTF
      /* use the target system's ANSI routines */
      va_start(argList,format);
 2026e54:	e0800404 	addi	r2,fp,16
 2026e58:	e0bffd15 	stw	r2,-12(fp)
      ret_value = vprintf(format,argList);
 2026e5c:	e0bffd17 	ldw	r2,-12(fp)
 2026e60:	e13fff17 	ldw	r4,-4(fp)
 2026e64:	100b883a 	mov	r5,r2
 2026e68:	204bd6c0 	call	204bd6c <vprintf>
 2026e6c:	e0bffc15 	stw	r2,-16(fp)
      va_end(argList);
      return ret_value;
 2026e70:	e0bffc17 	ldw	r2,-16(fp)
 2026e74:	00003a06 	br	2026f60 <ns_printf+0x150>
      return strlen(format);
#endif   /* NATIVE_PRINTF */
   }

   /* Check if the output function is set */
   if (pio->out == NULL)
 2026e78:	e0bffb17 	ldw	r2,-20(fp)
 2026e7c:	10800117 	ldw	r2,4(r2)
 2026e80:	1000021e 	bne	r2,zero,2026e8c <ns_printf+0x7c>
   {
      /* Programming mistake. Output function not set. */
      return -1;
 2026e84:	00bfffc4 	movi	r2,-1
 2026e88:	00003506 	br	2026f60 <ns_printf+0x150>

   /* Allocate memory for the output string 
    * If the format string is greater than MAXIOSIZE, then
    * we surely need to allocate a bigger block
    */
   ret_value = strlen(format); 
 2026e8c:	e13fff17 	ldw	r4,-4(fp)
 2026e90:	2007c640 	call	2007c64 <strlen>
 2026e94:	e0bffc15 	stw	r2,-16(fp)
   if (ret_value >= MAXIOSIZE)
 2026e98:	e0bffc17 	ldw	r2,-16(fp)
 2026e9c:	10802710 	cmplti	r2,r2,156
 2026ea0:	1000041e 	bne	r2,zero,2026eb4 <ns_printf+0xa4>
   {
      buf_size += ret_value ;
 2026ea4:	e0fff917 	ldw	r3,-28(fp)
 2026ea8:	e0bffc17 	ldw	r2,-16(fp)
 2026eac:	1885883a 	add	r2,r3,r2
 2026eb0:	e0bff915 	stw	r2,-28(fp)
   }

   outbuf=(char *)npalloc(buf_size); 
 2026eb4:	e0bff917 	ldw	r2,-28(fp)
 2026eb8:	1009883a 	mov	r4,r2
 2026ebc:	20290400 	call	2029040 <npalloc>
 2026ec0:	e0bffa15 	stw	r2,-24(fp)

   if (outbuf == NULL)
 2026ec4:	e0bffa17 	ldw	r2,-24(fp)
 2026ec8:	1000021e 	bne	r2,zero,2026ed4 <ns_printf+0xc4>
   {
      return -2;
 2026ecc:	00bfff84 	movi	r2,-2
 2026ed0:	00002306 	br	2026f60 <ns_printf+0x150>

   /* Now populate the output string */

#ifdef NATIVE_PRINTF
   /* use the target system's ANSI routines */
   va_start(argList,format);
 2026ed4:	e0800404 	addi	r2,fp,16
 2026ed8:	e0bffd15 	stw	r2,-12(fp)
   ret_value = vsprintf(outbuf,format,argList);
 2026edc:	e0bffd17 	ldw	r2,-12(fp)
 2026ee0:	e13ffa17 	ldw	r4,-24(fp)
 2026ee4:	e17fff17 	ldw	r5,-4(fp)
 2026ee8:	100d883a 	mov	r6,r2
 2026eec:	204bdf00 	call	204bdf0 <vsprintf>
 2026ef0:	e0bffc15 	stw	r2,-16(fp)
#endif   /* PRINTF_STDARG */
#endif   /* NATIVE_PRINTF */

#ifdef NATIVE_PRINTF
   /* Check if we have overwritten the output buffer */
   if ((int)strlen(outbuf) > buf_size)
 2026ef4:	e13ffa17 	ldw	r4,-24(fp)
 2026ef8:	2007c640 	call	2007c64 <strlen>
 2026efc:	e0fff917 	ldw	r3,-28(fp)
 2026f00:	1880080e 	bge	r3,r2,2026f24 <ns_printf+0x114>
       */
      /* Yes , we have overwritten. Truncate the output string.
       * Some memory in the heap has been corrupted, but it is too
       * late to rectify.
       */
      panic("ns_printf:Buffer overflow");
 2026f04:	01008174 	movhi	r4,517
 2026f08:	213b8504 	addi	r4,r4,-4588
 2026f0c:	2026bf80 	call	2026bf8 <panic>
      outbuf[buf_size-1]=0;   /* Null terminate the string */
 2026f10:	e0bff917 	ldw	r2,-28(fp)
 2026f14:	10bfffc4 	addi	r2,r2,-1
 2026f18:	e0fffa17 	ldw	r3,-24(fp)
 2026f1c:	1885883a 	add	r2,r3,r2
 2026f20:	10000005 	stb	zero,0(r2)
   }
#endif

   ret_value =(pio->out)(pio->id,outbuf,strlen(outbuf)) ;
 2026f24:	e0bffb17 	ldw	r2,-20(fp)
 2026f28:	14400117 	ldw	r17,4(r2)
 2026f2c:	e0bffb17 	ldw	r2,-20(fp)
 2026f30:	14000217 	ldw	r16,8(r2)
 2026f34:	e13ffa17 	ldw	r4,-24(fp)
 2026f38:	2007c640 	call	2007c64 <strlen>
 2026f3c:	8009883a 	mov	r4,r16
 2026f40:	e17ffa17 	ldw	r5,-24(fp)
 2026f44:	100d883a 	mov	r6,r2
 2026f48:	883ee83a 	callr	r17
 2026f4c:	e0bffc15 	stw	r2,-16(fp)

   /* Free memory for the output string */
   npfree(outbuf); 
 2026f50:	e13ffa17 	ldw	r4,-24(fp)
 2026f54:	202912c0 	call	202912c <npfree>

   /* since ns_printf() can get called repeatedly down in the bowels 
    * of a single command interpretting function, spin tk_yield() so 
    * that some packets get a chance to get received 
    */
   tk_yield();
 2026f58:	20278080 	call	2027808 <tk_yield>

   return ret_value ;
 2026f5c:	e0bffc17 	ldw	r2,-16(fp)
}
 2026f60:	e037883a 	mov	sp,fp
 2026f64:	dfc00317 	ldw	ra,12(sp)
 2026f68:	df000217 	ldw	fp,8(sp)
 2026f6c:	dc400117 	ldw	r17,4(sp)
 2026f70:	dc000017 	ldw	r16,0(sp)
 2026f74:	dec00604 	addi	sp,sp,24
 2026f78:	f800283a 	ret

02026f7c <std_out>:
 *
 * RETURNS: Number of bytes send to standard output. 
 */

int std_out(long s, char * buf, int len)
{
 2026f7c:	defffb04 	addi	sp,sp,-20
 2026f80:	dfc00415 	stw	ra,16(sp)
 2026f84:	df000315 	stw	fp,12(sp)
 2026f88:	df000304 	addi	fp,sp,12
 2026f8c:	e13ffd15 	stw	r4,-12(fp)
 2026f90:	e17ffe15 	stw	r5,-8(fp)
 2026f94:	e1bfff15 	stw	r6,-4(fp)
   /* puts(buf); - This does newline expansion return 
    * write(0,buf,len); - This doesn't printf(buf); - This has 
    * problems when printf format strings (eg %s) is part of data. 
    */
   printf("%s",buf);
 2026f98:	01008174 	movhi	r4,517
 2026f9c:	213b8c04 	addi	r4,r4,-4560
 2026fa0:	e17ffe17 	ldw	r5,-8(fp)
 2026fa4:	2006a240 	call	2006a24 <printf>
   USE_ARG(s);
   return len;
 2026fa8:	e0bfff17 	ldw	r2,-4(fp)
}
 2026fac:	e037883a 	mov	sp,fp
 2026fb0:	dfc00117 	ldw	ra,4(sp)
 2026fb4:	df000017 	ldw	fp,0(sp)
 2026fb8:	dec00204 	addi	sp,sp,8
 2026fbc:	f800283a 	ret

02026fc0 <con_page>:
 * RETURNS: 1 if we got a break, 0 to keep printing
 */

int
con_page(void * vio, int lines)
{
 2026fc0:	defffa04 	addi	sp,sp,-24
 2026fc4:	dfc00515 	stw	ra,20(sp)
 2026fc8:	df000415 	stw	fp,16(sp)
 2026fcc:	df000404 	addi	fp,sp,16
 2026fd0:	e13ffe15 	stw	r4,-8(fp)
 2026fd4:	e17fff15 	stw	r5,-4(fp)
   int   ch;
   GEN_IO pio = (GEN_IO)vio;  /* convert void* to our IO device type */
 2026fd8:	e0bffe17 	ldw	r2,-8(fp)
 2026fdc:	e0bffc15 	stw	r2,-16(fp)

   if (lines % 20 == 0)   /* Time to get user input */
 2026fe0:	e0bfff17 	ldw	r2,-4(fp)
 2026fe4:	00c00504 	movi	r3,20
 2026fe8:	10c7283a 	div	r3,r2,r3
 2026fec:	18c00524 	muli	r3,r3,20
 2026ff0:	10c5c83a 	sub	r2,r2,r3
 2026ff4:	1000231e 	bne	r2,zero,2027084 <con_page+0xc4>
   {
      if (pio && pio->getch)   /*if i/p func is supplied*/
 2026ff8:	e0bffc17 	ldw	r2,-16(fp)
 2026ffc:	10002126 	beq	r2,zero,2027084 <con_page+0xc4>
 2027000:	e0bffc17 	ldw	r2,-16(fp)
 2027004:	10800317 	ldw	r2,12(r2)
 2027008:	10001e26 	beq	r2,zero,2027084 <con_page+0xc4>
      {
         ns_printf(pio,"....press any key for more (ESC to break)....");
 202700c:	e13ffc17 	ldw	r4,-16(fp)
 2027010:	01408174 	movhi	r5,517
 2027014:	297b8d04 	addi	r5,r5,-4556
 2027018:	2026e100 	call	2026e10 <ns_printf>

         do 
         {
            ch = (pio->getch)(pio->id);
 202701c:	e0bffc17 	ldw	r2,-16(fp)
 2027020:	10c00317 	ldw	r3,12(r2)
 2027024:	e0bffc17 	ldw	r2,-16(fp)
 2027028:	10800217 	ldw	r2,8(r2)
 202702c:	1009883a 	mov	r4,r2
 2027030:	183ee83a 	callr	r3
 2027034:	e0bffd15 	stw	r2,-12(fp)
            if (ch == 0)
 2027038:	e0bffd17 	ldw	r2,-12(fp)
 202703c:	1000011e 	bne	r2,zero,2027044 <con_page+0x84>
               tk_yield();    /* Give timeslice to other processes */
 2027040:	20278080 	call	2027808 <tk_yield>
         } while (ch == 0) ;
 2027044:	e0bffd17 	ldw	r2,-12(fp)
 2027048:	103ff426 	beq	r2,zero,202701c <con_page+0x5c>

            /* if there is fatal error, we don't want to do any I/O */
         if (ch == -1)   /* fatal error */
 202704c:	e0bffd17 	ldw	r2,-12(fp)
 2027050:	10bfffd8 	cmpnei	r2,r2,-1
 2027054:	1000021e 	bne	r2,zero,2027060 <con_page+0xa0>
            return 1 ;
 2027058:	00800044 	movi	r2,1
 202705c:	00000a06 	br	2027088 <con_page+0xc8>

         ns_printf(pio,"\n");
 2027060:	e13ffc17 	ldw	r4,-16(fp)
 2027064:	01408174 	movhi	r5,517
 2027068:	297b6e04 	addi	r5,r5,-4680
 202706c:	2026e100 	call	2026e10 <ns_printf>
         if (ch == 27)   /* ESC key pressed */
 2027070:	e0bffd17 	ldw	r2,-12(fp)
 2027074:	108006d8 	cmpnei	r2,r2,27
 2027078:	1000021e 	bne	r2,zero,2027084 <con_page+0xc4>
            return 1 ;
 202707c:	00800044 	movi	r2,1
 2027080:	00000106 	br	2027088 <con_page+0xc8>
      }
   }
   return  0;
 2027084:	0005883a 	mov	r2,zero
}
 2027088:	e037883a 	mov	sp,fp
 202708c:	dfc00117 	ldw	ra,4(sp)
 2027090:	df000017 	ldw	fp,0(sp)
 2027094:	dec00204 	addi	sp,sp,8
 2027098:	f800283a 	ret

0202709c <parse_args>:

char **parse_args(char *buf, int argc, int *pargc_index)
{
 202709c:	defff704 	addi	sp,sp,-36
 20270a0:	dfc00815 	stw	ra,32(sp)
 20270a4:	df000715 	stw	fp,28(sp)
 20270a8:	df000704 	addi	fp,sp,28
 20270ac:	e13ffd15 	stw	r4,-12(fp)
 20270b0:	e17ffe15 	stw	r5,-8(fp)
 20270b4:	e1bfff15 	stw	r6,-4(fp)
   /* This routine assumes buf is a null terminated string */
   int i;
   int len;
   char *bp = buf;
 20270b8:	e0bffd17 	ldw	r2,-12(fp)
 20270bc:	e0bffa15 	stw	r2,-24(fp)
   char **pargv = NULL;
 20270c0:	e03ffb15 	stw	zero,-20(fp)
   *pargc_index = 0;
 20270c4:	e0bfff17 	ldw	r2,-4(fp)
 20270c8:	10000015 	stw	zero,0(r2)
   if (buf == NULL)
 20270cc:	e0bffd17 	ldw	r2,-12(fp)
 20270d0:	1000021e 	bne	r2,zero,20270dc <parse_args+0x40>
   {
      return (NULL);
 20270d4:	0005883a 	mov	r2,zero
 20270d8:	00006f06 	br	2027298 <parse_args+0x1fc>
   }
   len = strlen(buf);
 20270dc:	e13ffd17 	ldw	r4,-12(fp)
 20270e0:	2007c640 	call	2007c64 <strlen>
 20270e4:	e0bffc15 	stw	r2,-16(fp)
   if (len <= 0)
 20270e8:	e0bffc17 	ldw	r2,-16(fp)
 20270ec:	00800216 	blt	zero,r2,20270f8 <parse_args+0x5c>
   {
      return (NULL);
 20270f0:	0005883a 	mov	r2,zero
 20270f4:	00006806 	br	2027298 <parse_args+0x1fc>
   }
   pargv = (char **) npalloc(argc * sizeof(char *));
 20270f8:	e0bffe17 	ldw	r2,-8(fp)
 20270fc:	1085883a 	add	r2,r2,r2
 2027100:	1085883a 	add	r2,r2,r2
 2027104:	1009883a 	mov	r4,r2
 2027108:	20290400 	call	2029040 <npalloc>
 202710c:	e0bffb15 	stw	r2,-20(fp)
   if (pargv == NULL)
 2027110:	e0bffb17 	ldw	r2,-20(fp)
 2027114:	1000061e 	bne	r2,zero,2027130 <parse_args+0x94>
   {
      return (NULL);
 2027118:	0005883a 	mov	r2,zero
 202711c:	00005e06 	br	2027298 <parse_args+0x1fc>
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
 2027120:	e0bffa17 	ldw	r2,-24(fp)
 2027124:	10800044 	addi	r2,r2,1
 2027128:	e0bffa15 	stw	r2,-24(fp)
 202712c:	00000106 	br	2027134 <parse_args+0x98>
   if (pargv == NULL)
   {
      return (NULL);
   }
   /* skip the initial blanks if any */
   while (*bp == ' ')
 2027130:	0001883a 	nop
 2027134:	e0bffa17 	ldw	r2,-24(fp)
 2027138:	10800003 	ldbu	r2,0(r2)
 202713c:	10803fcc 	andi	r2,r2,255
 2027140:	1080201c 	xori	r2,r2,128
 2027144:	10bfe004 	addi	r2,r2,-128
 2027148:	10800820 	cmpeqi	r2,r2,32
 202714c:	103ff41e 	bne	r2,zero,2027120 <parse_args+0x84>
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 2027150:	00003106 	br	2027218 <parse_args+0x17c>
   {
      pargv[(*pargc_index)] = bp;
 2027154:	e0bfff17 	ldw	r2,-4(fp)
 2027158:	10800017 	ldw	r2,0(r2)
 202715c:	1085883a 	add	r2,r2,r2
 2027160:	1085883a 	add	r2,r2,r2
 2027164:	e0fffb17 	ldw	r3,-20(fp)
 2027168:	1885883a 	add	r2,r3,r2
 202716c:	e0fffa17 	ldw	r3,-24(fp)
 2027170:	10c00015 	stw	r3,0(r2)
      (*pargc_index)++;
 2027174:	e0bfff17 	ldw	r2,-4(fp)
 2027178:	10800017 	ldw	r2,0(r2)
 202717c:	10c00044 	addi	r3,r2,1
 2027180:	e0bfff17 	ldw	r2,-4(fp)
 2027184:	10c00015 	stw	r3,0(r2)
      while (*bp != ' ' && *bp != '\0')
 2027188:	00000306 	br	2027198 <parse_args+0xfc>
      {
         bp++; 
 202718c:	e0bffa17 	ldw	r2,-24(fp)
 2027190:	10800044 	addi	r2,r2,1
 2027194:	e0bffa15 	stw	r2,-24(fp)
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
   {
      pargv[(*pargc_index)] = bp;
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
 2027198:	e0bffa17 	ldw	r2,-24(fp)
 202719c:	10800003 	ldbu	r2,0(r2)
 20271a0:	10803fcc 	andi	r2,r2,255
 20271a4:	1080201c 	xori	r2,r2,128
 20271a8:	10bfe004 	addi	r2,r2,-128
 20271ac:	10800820 	cmpeqi	r2,r2,32
 20271b0:	10000b1e 	bne	r2,zero,20271e0 <parse_args+0x144>
 20271b4:	e0bffa17 	ldw	r2,-24(fp)
 20271b8:	10800003 	ldbu	r2,0(r2)
 20271bc:	10803fcc 	andi	r2,r2,255
 20271c0:	1080201c 	xori	r2,r2,128
 20271c4:	10bfe004 	addi	r2,r2,-128
 20271c8:	103ff01e 	bne	r2,zero,202718c <parse_args+0xf0>
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 20271cc:	00000406 	br	20271e0 <parse_args+0x144>
      {
         bp++; 
 20271d0:	e0bffa17 	ldw	r2,-24(fp)
 20271d4:	10800044 	addi	r2,r2,1
 20271d8:	e0bffa15 	stw	r2,-24(fp)
 20271dc:	00000106 	br	20271e4 <parse_args+0x148>
      (*pargc_index)++;
      while (*bp != ' ' && *bp != '\0')
      {
         bp++; 
      }
      while (*bp == ' ' && *bp != '\0')
 20271e0:	0001883a 	nop
 20271e4:	e0bffa17 	ldw	r2,-24(fp)
 20271e8:	10800003 	ldbu	r2,0(r2)
 20271ec:	10803fcc 	andi	r2,r2,255
 20271f0:	1080201c 	xori	r2,r2,128
 20271f4:	10bfe004 	addi	r2,r2,-128
 20271f8:	10800818 	cmpnei	r2,r2,32
 20271fc:	1000061e 	bne	r2,zero,2027218 <parse_args+0x17c>
 2027200:	e0bffa17 	ldw	r2,-24(fp)
 2027204:	10800003 	ldbu	r2,0(r2)
 2027208:	10803fcc 	andi	r2,r2,255
 202720c:	1080201c 	xori	r2,r2,128
 2027210:	10bfe004 	addi	r2,r2,-128
 2027214:	103fee1e 	bne	r2,zero,20271d0 <parse_args+0x134>
   /* skip the initial blanks if any */
   while (*bp == ' ')
   {
      bp++;
   }
   while ((*bp != '\0') && ((*pargc_index) < argc))
 2027218:	e0bffa17 	ldw	r2,-24(fp)
 202721c:	10800003 	ldbu	r2,0(r2)
 2027220:	10803fcc 	andi	r2,r2,255
 2027224:	1080201c 	xori	r2,r2,128
 2027228:	10bfe004 	addi	r2,r2,-128
 202722c:	10000426 	beq	r2,zero,2027240 <parse_args+0x1a4>
 2027230:	e0bfff17 	ldw	r2,-4(fp)
 2027234:	10c00017 	ldw	r3,0(r2)
 2027238:	e0bffe17 	ldw	r2,-8(fp)
 202723c:	18bfc516 	blt	r3,r2,2027154 <parse_args+0xb8>
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 2027240:	e03ff915 	stw	zero,-28(fp)
 2027244:	00001006 	br	2027288 <parse_args+0x1ec>
   {
      if (buf[i] == ' ')
 2027248:	e0bff917 	ldw	r2,-28(fp)
 202724c:	e0fffd17 	ldw	r3,-12(fp)
 2027250:	1885883a 	add	r2,r3,r2
 2027254:	10800003 	ldbu	r2,0(r2)
 2027258:	10803fcc 	andi	r2,r2,255
 202725c:	1080201c 	xori	r2,r2,128
 2027260:	10bfe004 	addi	r2,r2,-128
 2027264:	10800818 	cmpnei	r2,r2,32
 2027268:	1000041e 	bne	r2,zero,202727c <parse_args+0x1e0>
         buf[i] = '\0';
 202726c:	e0bff917 	ldw	r2,-28(fp)
 2027270:	e0fffd17 	ldw	r3,-12(fp)
 2027274:	1885883a 	add	r2,r3,r2
 2027278:	10000005 	stb	zero,0(r2)
      while (*bp == ' ' && *bp != '\0')
      {
         bp++; 
      }
   }
   for (i = 0; i < len; i++)
 202727c:	e0bff917 	ldw	r2,-28(fp)
 2027280:	10800044 	addi	r2,r2,1
 2027284:	e0bff915 	stw	r2,-28(fp)
 2027288:	e0fff917 	ldw	r3,-28(fp)
 202728c:	e0bffc17 	ldw	r2,-16(fp)
 2027290:	18bfed16 	blt	r3,r2,2027248 <parse_args+0x1ac>
   {
      printf("pargv[%d] = %s\n", i, pargv[i]);
   }
#endif

   return (pargv);
 2027294:	e0bffb17 	ldw	r2,-20(fp)
}
 2027298:	e037883a 	mov	sp,fp
 202729c:	dfc00117 	ldw	ra,4(sp)
 20272a0:	df000017 	ldw	fp,0(sp)
 20272a4:	dec00204 	addi	sp,sp,8
 20272a8:	f800283a 	ret

020272ac <netmain>:
 * RETURNS: 
 */

int
netmain(void)
{
 20272ac:	defffc04 	addi	sp,sp,-16
 20272b0:	dfc00315 	stw	ra,12(sp)
 20272b4:	df000215 	stw	fp,8(sp)
 20272b8:	df000204 	addi	fp,sp,8
   int   i;
   int   e;

   iniche_net_ready = FALSE;
 20272bc:	d0209115 	stw	zero,-32188(gp)

   e = prep_modules();
 20272c0:	203d5b80 	call	203d5b8 <prep_modules>
 20272c4:	e0bfff15 	stw	r2,-4(fp)

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 20272c8:	e03ffe15 	stw	zero,-8(fp)
 20272cc:	00001a06 	br	2027338 <netmain+0x8c>
   {
      e = TK_NEWTASK(&nettasks[i]);
 20272d0:	e0bffe17 	ldw	r2,-8(fp)
 20272d4:	10c00624 	muli	r3,r2,24
 20272d8:	00808174 	movhi	r2,517
 20272dc:	108ef004 	addi	r2,r2,15296
 20272e0:	1885883a 	add	r2,r3,r2
 20272e4:	1009883a 	mov	r4,r2
 20272e8:	20289e00 	call	20289e0 <TK_NEWTASK>
 20272ec:	e0bfff15 	stw	r2,-4(fp)
      if (e != 0)
 20272f0:	e0bfff17 	ldw	r2,-4(fp)
 20272f4:	10000d26 	beq	r2,zero,202732c <netmain+0x80>
      {
         dprintf("task create error\n");
 20272f8:	01008174 	movhi	r4,517
 20272fc:	213b9f04 	addi	r4,r4,-4484
 2027300:	2006cb40 	call	2006cb4 <puts>
         panic((char *)&nettasks[i].name);
 2027304:	e0bffe17 	ldw	r2,-8(fp)
 2027308:	10800624 	muli	r2,r2,24
 202730c:	10c00104 	addi	r3,r2,4
 2027310:	00808174 	movhi	r2,517
 2027314:	108ef004 	addi	r2,r2,15296
 2027318:	1885883a 	add	r2,r3,r2
 202731c:	1009883a 	mov	r4,r2
 2027320:	2026bf80 	call	2026bf8 <panic>
         return -1;  /* compiler warnings */
 2027324:	00bfffc4 	movi	r2,-1
 2027328:	00001306 	br	2027378 <netmain+0xcc>
   iniche_net_ready = FALSE;

   e = prep_modules();

   /* Create the threads for net, timer, and apps */
   for (i = 0; i < num_net_tasks; i++)
 202732c:	e0bffe17 	ldw	r2,-8(fp)
 2027330:	10800044 	addi	r2,r2,1
 2027334:	e0bffe15 	stw	r2,-8(fp)
 2027338:	d0a03b17 	ldw	r2,-32532(gp)
 202733c:	e0fffe17 	ldw	r3,-8(fp)
 2027340:	18bfe316 	blt	r3,r2,20272d0 <netmain+0x24>
         panic((char *)&nettasks[i].name);
         return -1;  /* compiler warnings */
      }
   }
   
   e = create_apptasks();
 2027344:	203db580 	call	203db58 <create_apptasks>
 2027348:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0) 
 202734c:	e0bfff17 	ldw	r2,-4(fp)
 2027350:	10000826 	beq	r2,zero,2027374 <netmain+0xc8>
   {
      dprintf("task create error\n");
 2027354:	01008174 	movhi	r4,517
 2027358:	213b9f04 	addi	r4,r4,-4484
 202735c:	2006cb40 	call	2006cb4 <puts>
      panic("netmain");
 2027360:	01008174 	movhi	r4,517
 2027364:	213ba404 	addi	r4,r4,-4464
 2027368:	2026bf80 	call	2026bf8 <panic>
      return -1;  /* compiler warnings */
 202736c:	00bfffc4 	movi	r2,-1
 2027370:	00000106 	br	2027378 <netmain+0xcc>
#ifdef MAIN_TASK_IS_NET
   tk_netmain(TK_NETMAINPARM);
   panic("net task return");
   return -1;
#else
   return 0;
 2027374:	0005883a 	mov	r2,zero
#endif
#endif   /* NO_INET_STACK */
}
 2027378:	e037883a 	mov	sp,fp
 202737c:	dfc00117 	ldw	ra,4(sp)
 2027380:	df000017 	ldw	fp,0(sp)
 2027384:	dec00204 	addi	sp,sp,8
 2027388:	f800283a 	ret

0202738c <tk_netmain>:
 * RETURNS: n/a
 */

#ifndef NO_INET_STACK
TK_ENTRY(tk_netmain)
{
 202738c:	defffc04 	addi	sp,sp,-16
 2027390:	dfc00315 	stw	ra,12(sp)
 2027394:	df000215 	stw	fp,8(sp)
 2027398:	df000204 	addi	fp,sp,8
 202739c:	e13fff15 	stw	r4,-4(fp)
   netmain_init(); /* initialize all modules */
 20273a0:	203d18c0 	call	203d18c <netmain_init>

   iniche_net_ready = TRUE;    /* let the other threads spin */
 20273a4:	00800044 	movi	r2,1
 20273a8:	d0a09115 	stw	r2,-32188(gp)
 20273ac:	00000106 	br	20273b4 <tk_netmain+0x28>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 20273b0:	0001883a 	nop

   iniche_net_ready = TRUE;    /* let the other threads spin */

   for (;;)
   {
      TK_NETRX_BLOCK();
 20273b4:	00808174 	movhi	r2,517
 20273b8:	1090cc04 	addi	r2,r2,17200
 20273bc:	10800017 	ldw	r2,0(r2)
 20273c0:	1009883a 	mov	r4,r2
 20273c4:	01401904 	movi	r5,100
 20273c8:	e1bffe04 	addi	r6,fp,-8
 20273cc:	201c0180 	call	201c018 <OSSemPend>
 20273d0:	e0bffe03 	ldbu	r2,-8(fp)
 20273d4:	10803fcc 	andi	r2,r2,255
 20273d8:	10000526 	beq	r2,zero,20273f0 <tk_netmain+0x64>
 20273dc:	e0bffe03 	ldbu	r2,-8(fp)
 20273e0:	10803fcc 	andi	r2,r2,255
 20273e4:	108002a0 	cmpeqi	r2,r2,10
 20273e8:	1000011e 	bne	r2,zero,20273f0 <tk_netmain+0x64>
 20273ec:	20285c80 	call	20285c8 <dtrap>
      netmain_wakes++;  /* count wakeups */
 20273f0:	d0a08f17 	ldw	r2,-32196(gp)
 20273f4:	10800044 	addi	r2,r2,1
 20273f8:	d0a08f15 	stw	r2,-32196(gp)

      /* see if there's newly received network packets */
      if (rcvdq.q_len)
 20273fc:	00809934 	movhi	r2,612
 2027400:	10b4fc04 	addi	r2,r2,-11280
 2027404:	10800217 	ldw	r2,8(r2)
 2027408:	103fe926 	beq	r2,zero,20273b0 <tk_netmain+0x24>
         pktdemux();
 202740c:	20241dc0 	call	20241dc <pktdemux>
       * vital to a clean shutdown 
       */
#ifdef USE_LCD
      update_display();
#endif
   }
 2027410:	003fe706 	br	20273b0 <tk_netmain+0x24>

02027414 <tk_nettick>:
extern   int dhc_second(void);
#endif

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
 2027414:	defffd04 	addi	sp,sp,-12
 2027418:	dfc00215 	stw	ra,8(sp)
 202741c:	df000115 	stw	fp,4(sp)
 2027420:	df000104 	addi	fp,sp,4
 2027424:	e13fff15 	stw	r4,-4(fp)
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 2027428:	00000206 	br	2027434 <tk_nettick+0x20>
       * run to restart it.
       */
#ifdef DHCP_CLIENT
      dhc_second();
#endif
      TK_SLEEP(1);
 202742c:	01000084 	movi	r4,2
 2027430:	201e00c0 	call	201e00c <OSTimeDly>

#ifndef NO_INET_TICK
TK_ENTRY(tk_nettick)
{
   /* wait till the stack is initialized */
   while (!iniche_net_ready)
 2027434:	d0a09117 	ldw	r2,-32188(gp)
 2027438:	103ffc26 	beq	r2,zero,202742c <tk_nettick+0x18>
      TK_SLEEP(1);
   }

   for (;;)
   {
      TK_SLEEP(SYS_SHORT_SLEEP);
 202743c:	01000084 	movi	r4,2
 2027440:	201e00c0 	call	201e00c <OSTimeDly>
      nettick_wakes++;  /* count wakeups */
 2027444:	d0a09017 	ldw	r2,-32192(gp)
 2027448:	10800044 	addi	r2,r2,1
 202744c:	d0a09015 	stw	r2,-32192(gp)
      inet_timer();  /* let various timeouts occur */
 2027450:	203d60c0 	call	203d60c <inet_timer>
      /* do not kill timers on net_system_exit. They may be
       * vital to a clean shutdown 
       */
   }
 2027454:	003ff906 	br	202743c <tk_nettick+0x28>

02027458 <TK_OSTimeDly>:
u_char   TK_OSTaskQuery(void);



void TK_OSTimeDly(void)
{
 2027458:	defffe04 	addi	sp,sp,-8
 202745c:	dfc00115 	stw	ra,4(sp)
 2027460:	df000015 	stw	fp,0(sp)
 2027464:	d839883a 	mov	fp,sp
   OSTimeDly(2);
 2027468:	01000084 	movi	r4,2
 202746c:	201e00c0 	call	201e00c <OSTimeDly>
}
 2027470:	e037883a 	mov	sp,fp
 2027474:	dfc00117 	ldw	ra,4(sp)
 2027478:	df000017 	ldw	fp,0(sp)
 202747c:	dec00204 	addi	sp,sp,8
 2027480:	f800283a 	ret

02027484 <TK_OSTaskResume>:



void TK_OSTaskResume(u_char * Id)
{
 2027484:	defffc04 	addi	sp,sp,-16
 2027488:	dfc00315 	stw	ra,12(sp)
 202748c:	df000215 	stw	fp,8(sp)
 2027490:	df000204 	addi	fp,sp,8
 2027494:	e13fff15 	stw	r4,-4(fp)
INT8U err;

   err = OSTaskResume(*Id);
 2027498:	e0bfff17 	ldw	r2,-4(fp)
 202749c:	10800003 	ldbu	r2,0(r2)
 20274a0:	10803fcc 	andi	r2,r2,255
 20274a4:	1009883a 	mov	r4,r2
 20274a8:	201d8980 	call	201d898 <OSTaskResume>
 20274ac:	e0bffe05 	stb	r2,-8(fp)
   
#ifdef NPDEBUG
   if ((err != OS_NO_ERR) && (err != OS_TASK_NOT_SUSPENDED))
 20274b0:	e0bffe03 	ldbu	r2,-8(fp)
 20274b4:	10000a26 	beq	r2,zero,20274e0 <TK_OSTaskResume+0x5c>
 20274b8:	e0bffe03 	ldbu	r2,-8(fp)
 20274bc:	10801120 	cmpeqi	r2,r2,68
 20274c0:	1000071e 	bne	r2,zero,20274e0 <TK_OSTaskResume+0x5c>
   {
      dprintf("ChronOS API call failure, to Resume Suspended Task!\n");
 20274c4:	01008174 	movhi	r4,517
 20274c8:	213ba604 	addi	r4,r4,-4456
 20274cc:	2006cb40 	call	2006cb4 <puts>
      dtrap();
 20274d0:	20285c80 	call	20285c8 <dtrap>
      panic("TK_OSTaskResume");      
 20274d4:	01008174 	movhi	r4,517
 20274d8:	213bb304 	addi	r4,r4,-4404
 20274dc:	2026bf80 	call	2026bf8 <panic>
   }
#endif
}
 20274e0:	e037883a 	mov	sp,fp
 20274e4:	dfc00117 	ldw	ra,4(sp)
 20274e8:	df000017 	ldw	fp,0(sp)
 20274ec:	dec00204 	addi	sp,sp,8
 20274f0:	f800283a 	ret

020274f4 <tcp_sleep>:
 *
 * RETURN: none
 */
void
tcp_sleep(void * event)
{
 20274f4:	defffb04 	addi	sp,sp,-20
 20274f8:	dfc00415 	stw	ra,16(sp)
 20274fc:	df000315 	stw	fp,12(sp)
 2027500:	df000304 	addi	fp,sp,12
 2027504:	e13fff15 	stw	r4,-4(fp)
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 2027508:	e03ffd15 	stw	zero,-12(fp)
 202750c:	00005106 	br	2027654 <tcp_sleep+0x160>
   {
      if (global_TCPwakeup_set[i].soc_event == NULL)
 2027510:	00c09934 	movhi	r3,612
 2027514:	18f67004 	addi	r3,r3,-9792
 2027518:	e0bffd17 	ldw	r2,-12(fp)
 202751c:	10800324 	muli	r2,r2,12
 2027520:	1885883a 	add	r2,r3,r2
 2027524:	10800104 	addi	r2,r2,4
 2027528:	10800017 	ldw	r2,0(r2)
 202752c:	1000461e 	bne	r2,zero,2027648 <tcp_sleep+0x154>
      {
         global_TCPwakeup_set[i].soc_event = event;
 2027530:	00c09934 	movhi	r3,612
 2027534:	18f67004 	addi	r3,r3,-9792
 2027538:	e0bffd17 	ldw	r2,-12(fp)
 202753c:	10800324 	muli	r2,r2,12
 2027540:	1885883a 	add	r2,r3,r2
 2027544:	10800104 	addi	r2,r2,4
 2027548:	e0ffff17 	ldw	r3,-4(fp)
 202754c:	10c00015 	stw	r3,0(r2)
         global_TCPwakeup_set[i].ctick = cticks;
 2027550:	00808174 	movhi	r2,517
 2027554:	1090c904 	addi	r2,r2,17188
 2027558:	10c00017 	ldw	r3,0(r2)
 202755c:	01009934 	movhi	r4,612
 2027560:	21367004 	addi	r4,r4,-9792
 2027564:	e0bffd17 	ldw	r2,-12(fp)
 2027568:	10800324 	muli	r2,r2,12
 202756c:	2085883a 	add	r2,r4,r2
 2027570:	10c00015 	stw	r3,0(r2)
         if (i > global_TCPwakeup_setIndx)
 2027574:	00808174 	movhi	r2,517
 2027578:	1090c804 	addi	r2,r2,17184
 202757c:	10c00017 	ldw	r3,0(r2)
 2027580:	e0bffd17 	ldw	r2,-12(fp)
 2027584:	1880040e 	bge	r3,r2,2027598 <tcp_sleep+0xa4>
            global_TCPwakeup_setIndx = i;
 2027588:	00808174 	movhi	r2,517
 202758c:	1090c804 	addi	r2,r2,17184
 2027590:	e0fffd17 	ldw	r3,-12(fp)
 2027594:	10c00015 	stw	r3,0(r2)

         tcp_sleep_count++;
 2027598:	00808174 	movhi	r2,517
 202759c:	1090c404 	addi	r2,r2,17168
 20275a0:	10800017 	ldw	r2,0(r2)
 20275a4:	10c00044 	addi	r3,r2,1
 20275a8:	00808174 	movhi	r2,517
 20275ac:	1090c404 	addi	r2,r2,17168
 20275b0:	10c00015 	stw	r3,0(r2)

         /* Give up the lock before going to sleep. This can
          * potentially cause a context switch to the task
          * signaling the event.
          */
         UNLOCK_NET_RESOURCE(NET_RESID);
 20275b4:	0009883a 	mov	r4,zero
 20275b8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

         /* don't wait forever in case we miss the event */
         OSSemPend(global_TCPwakeup_set[i].semaphore, TPS, &err);
 20275bc:	00c09934 	movhi	r3,612
 20275c0:	18f67004 	addi	r3,r3,-9792
 20275c4:	e0bffd17 	ldw	r2,-12(fp)
 20275c8:	10800324 	muli	r2,r2,12
 20275cc:	1885883a 	add	r2,r3,r2
 20275d0:	10800204 	addi	r2,r2,8
 20275d4:	10c00017 	ldw	r3,0(r2)
 20275d8:	e0bffe04 	addi	r2,fp,-8
 20275dc:	1809883a 	mov	r4,r3
 20275e0:	01401904 	movi	r5,100
 20275e4:	100d883a 	mov	r6,r2
 20275e8:	201c0180 	call	201c018 <OSSemPend>
         if (err == 10)
 20275ec:	e0bffe03 	ldbu	r2,-8(fp)
 20275f0:	10803fcc 	andi	r2,r2,255
 20275f4:	10800298 	cmpnei	r2,r2,10
 20275f8:	1000101e 	bne	r2,zero,202763c <tcp_sleep+0x148>
         {
            ++tcp_sleep_timeout;
 20275fc:	d0a09317 	ldw	r2,-32180(gp)
 2027600:	10800044 	addi	r2,r2,1
 2027604:	d0a09315 	stw	r2,-32180(gp)

            /* clear the entry */
            global_TCPwakeup_set[i].ctick = 0;
 2027608:	00c09934 	movhi	r3,612
 202760c:	18f67004 	addi	r3,r3,-9792
 2027610:	e0bffd17 	ldw	r2,-12(fp)
 2027614:	10800324 	muli	r2,r2,12
 2027618:	1885883a 	add	r2,r3,r2
 202761c:	10000015 	stw	zero,0(r2)
            global_TCPwakeup_set[i].soc_event = NULL;
 2027620:	00c09934 	movhi	r3,612
 2027624:	18f67004 	addi	r3,r3,-9792
 2027628:	e0bffd17 	ldw	r2,-12(fp)
 202762c:	10800324 	muli	r2,r2,12
 2027630:	1885883a 	add	r2,r3,r2
 2027634:	10800104 	addi	r2,r2,4
 2027638:	10000015 	stw	zero,0(r2)
         }

         /* Regain the lock */
         LOCK_NET_RESOURCE(NET_RESID);
 202763c:	0009883a 	mov	r4,zero
 2027640:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
 2027644:	00000f06 	br	2027684 <tcp_sleep+0x190>
tcp_sleep(void * event)
{
   int i;
   INT8U err;

   for (i = 0; i < GLOBWAKE_SZ; i++)
 2027648:	e0bffd17 	ldw	r2,-12(fp)
 202764c:	10800044 	addi	r2,r2,1
 2027650:	e0bffd15 	stw	r2,-12(fp)
 2027654:	e0bffd17 	ldw	r2,-12(fp)
 2027658:	10800510 	cmplti	r2,r2,20
 202765c:	103fac1e 	bne	r2,zero,2027510 <tcp_sleep+0x1c>

   /* The table is full. Try calling TK_YIELD() and hope for the best.
    * The user should increase the size of the table.
    * We'll record the max index for debugging purposes.
    */
   global_TCPwakeup_setIndx = i;
 2027660:	00808174 	movhi	r2,517
 2027664:	1090c804 	addi	r2,r2,17184
 2027668:	e0fffd17 	ldw	r3,-12(fp)
 202766c:	10c00015 	stw	r3,0(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 2027670:	0009883a 	mov	r4,zero
 2027674:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   TK_YIELD();
 2027678:	20278080 	call	2027808 <tk_yield>
   LOCK_NET_RESOURCE(NET_RESID);
 202767c:	0009883a 	mov	r4,zero
 2027680:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
}
 2027684:	e037883a 	mov	sp,fp
 2027688:	dfc00117 	ldw	ra,4(sp)
 202768c:	df000017 	ldw	fp,0(sp)
 2027690:	dec00204 	addi	sp,sp,8
 2027694:	f800283a 	ret

02027698 <tcp_wakeup>:
 *
 * RETURN: none
 */
void
tcp_wakeup(void *event)
{
 2027698:	defffc04 	addi	sp,sp,-16
 202769c:	dfc00315 	stw	ra,12(sp)
 20276a0:	df000215 	stw	fp,8(sp)
 20276a4:	df000204 	addi	fp,sp,8
 20276a8:	e13fff15 	stw	r4,-4(fp)
   int i;

   OSSchedLock();
 20276ac:	20167380 	call	2016738 <OSSchedLock>

   for (i = 0; i < GLOBWAKE_SZ; i++)
 20276b0:	e03ffe15 	stw	zero,-8(fp)
 20276b4:	00003006 	br	2027778 <tcp_wakeup+0xe0>
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 20276b8:	00c09934 	movhi	r3,612
 20276bc:	18f67004 	addi	r3,r3,-9792
 20276c0:	e0bffe17 	ldw	r2,-8(fp)
 20276c4:	10800324 	muli	r2,r2,12
 20276c8:	1885883a 	add	r2,r3,r2
 20276cc:	10800017 	ldw	r2,0(r2)
 20276d0:	10002626 	beq	r2,zero,202776c <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
 20276d4:	00c09934 	movhi	r3,612
 20276d8:	18f67004 	addi	r3,r3,-9792
 20276dc:	e0bffe17 	ldw	r2,-8(fp)
 20276e0:	10800324 	muli	r2,r2,12
 20276e4:	1885883a 	add	r2,r3,r2
 20276e8:	10800104 	addi	r2,r2,4
 20276ec:	10c00017 	ldw	r3,0(r2)

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
   {
      if ((global_TCPwakeup_set[i].ctick != 0) &&
 20276f0:	e0bfff17 	ldw	r2,-4(fp)
 20276f4:	18801d1e 	bne	r3,r2,202776c <tcp_wakeup+0xd4>
          (global_TCPwakeup_set[i].soc_event == event))
      {
         /* signal the event */
         OSSemPost(global_TCPwakeup_set[i].semaphore);
 20276f8:	00c09934 	movhi	r3,612
 20276fc:	18f67004 	addi	r3,r3,-9792
 2027700:	e0bffe17 	ldw	r2,-8(fp)
 2027704:	10800324 	muli	r2,r2,12
 2027708:	1885883a 	add	r2,r3,r2
 202770c:	10800204 	addi	r2,r2,8
 2027710:	10800017 	ldw	r2,0(r2)
 2027714:	1009883a 	mov	r4,r2
 2027718:	201c3f80 	call	201c3f8 <OSSemPost>

         /* clear the entry */
         global_TCPwakeup_set[i].ctick = 0;
 202771c:	00c09934 	movhi	r3,612
 2027720:	18f67004 	addi	r3,r3,-9792
 2027724:	e0bffe17 	ldw	r2,-8(fp)
 2027728:	10800324 	muli	r2,r2,12
 202772c:	1885883a 	add	r2,r3,r2
 2027730:	10000015 	stw	zero,0(r2)
         global_TCPwakeup_set[i].soc_event = NULL;
 2027734:	00c09934 	movhi	r3,612
 2027738:	18f67004 	addi	r3,r3,-9792
 202773c:	e0bffe17 	ldw	r2,-8(fp)
 2027740:	10800324 	muli	r2,r2,12
 2027744:	1885883a 	add	r2,r3,r2
 2027748:	10800104 	addi	r2,r2,4
 202774c:	10000015 	stw	zero,0(r2)

         tcp_wakeup_count++;
 2027750:	00808174 	movhi	r2,517
 2027754:	1090c504 	addi	r2,r2,17172
 2027758:	10800017 	ldw	r2,0(r2)
 202775c:	10c00044 	addi	r3,r2,1
 2027760:	00808174 	movhi	r2,517
 2027764:	1090c504 	addi	r2,r2,17172
 2027768:	10c00015 	stw	r3,0(r2)
{
   int i;

   OSSchedLock();

   for (i = 0; i < GLOBWAKE_SZ; i++)
 202776c:	e0bffe17 	ldw	r2,-8(fp)
 2027770:	10800044 	addi	r2,r2,1
 2027774:	e0bffe15 	stw	r2,-8(fp)
 2027778:	e0bffe17 	ldw	r2,-8(fp)
 202777c:	10800510 	cmplti	r2,r2,20
 2027780:	103fcd1e 	bne	r2,zero,20276b8 <tcp_wakeup+0x20>

         tcp_wakeup_count++;
      }
   }

   OSSchedUnlock();
 2027784:	20167c00 	call	20167c0 <OSSchedUnlock>
}
 2027788:	e037883a 	mov	sp,fp
 202778c:	dfc00117 	ldw	ra,4(sp)
 2027790:	df000017 	ldw	fp,0(sp)
 2027794:	dec00204 	addi	sp,sp,8
 2027798:	f800283a 	ret

0202779c <TK_OSTaskQuery>:



u_char TK_OSTaskQuery(void)
{
 202779c:	deffe204 	addi	sp,sp,-120
 20277a0:	dfc01d15 	stw	ra,116(sp)
 20277a4:	df001c15 	stw	fp,112(sp)
 20277a8:	df001c04 	addi	fp,sp,112
   OS_TCB task_data;
   INT8U err, task_prio;

   err = OSTaskQuery(OS_PRIO_SELF, &task_data);
 20277ac:	e0bfe504 	addi	r2,fp,-108
 20277b0:	01003fc4 	movi	r4,255
 20277b4:	100b883a 	mov	r5,r2
 20277b8:	201de700 	call	201de70 <OSTaskQuery>
 20277bc:	e0bfe405 	stb	r2,-112(fp)

   if (err == OS_NO_ERR)
 20277c0:	e0bfe403 	ldbu	r2,-112(fp)
 20277c4:	1000041e 	bne	r2,zero,20277d8 <TK_OSTaskQuery+0x3c>
   {
      task_prio = task_data.OSTCBPrio;
 20277c8:	e0bff183 	ldbu	r2,-58(fp)
 20277cc:	e0bfe445 	stb	r2,-111(fp)
      dprintf("ChronOS API call failure, unable to identify task!");
      panic("TK_OSTaskQuery");
      return 0;
   }
   
   return task_prio;
 20277d0:	e0bfe443 	ldbu	r2,-111(fp)
 20277d4:	00000706 	br	20277f4 <TK_OSTaskQuery+0x58>
   {
      task_prio = task_data.OSTCBPrio;
   }
   else
   {
      dprintf("ChronOS API call failure, unable to identify task!");
 20277d8:	01008174 	movhi	r4,517
 20277dc:	213bb704 	addi	r4,r4,-4388
 20277e0:	2006a240 	call	2006a24 <printf>
      panic("TK_OSTaskQuery");
 20277e4:	01008174 	movhi	r4,517
 20277e8:	213bc404 	addi	r4,r4,-4336
 20277ec:	2026bf80 	call	2026bf8 <panic>
      return 0;
 20277f0:	0005883a 	mov	r2,zero
   }
   
   return task_prio;
}
 20277f4:	e037883a 	mov	sp,fp
 20277f8:	dfc00117 	ldw	ra,4(sp)
 20277fc:	df000017 	ldw	fp,0(sp)
 2027800:	dec00204 	addi	sp,sp,8
 2027804:	f800283a 	ret

02027808 <tk_yield>:



void
tk_yield(void)
{
 2027808:	defffe04 	addi	sp,sp,-8
 202780c:	dfc00115 	stw	ra,4(sp)
 2027810:	df000015 	stw	fp,0(sp)
 2027814:	d839883a 	mov	fp,sp
   /* To ensure cycles to the lower priority tasks we should really
    * delay by two ticks, but that really hurts performance on some
    * long-tick targets. One tick works better overall....
    */
   OSTimeDly(1);
 2027818:	01000044 	movi	r4,1
 202781c:	201e00c0 	call	201e00c <OSTimeDly>
}
 2027820:	e037883a 	mov	sp,fp
 2027824:	dfc00117 	ldw	ra,4(sp)
 2027828:	df000017 	ldw	fp,0(sp)
 202782c:	dec00204 	addi	sp,sp,8
 2027830:	f800283a 	ret

02027834 <tk_stats>:
extern struct inet_taskinfo * nettask;
extern int num_net_tasks;

int
tk_stats(void * pio)
{
 2027834:	deffef04 	addi	sp,sp,-68
 2027838:	dfc01015 	stw	ra,64(sp)
 202783c:	df000f15 	stw	fp,60(sp)
 2027840:	df000f04 	addi	fp,sp,60
 2027844:	e13fff15 	stw	r4,-4(fp)
   int      stackuse;
   char     name[OS_TASK_NAME_SIZE+1];
   INT8U    err;
   

   ns_printf(pio, "ChronOS RTOS stats:\n");
 2027848:	e13fff17 	ldw	r4,-4(fp)
 202784c:	01408174 	movhi	r5,517
 2027850:	297bc804 	addi	r5,r5,-4320
 2027854:	2026e100 	call	2026e10 <ns_printf>

#ifdef NO_INICHE_EXTENSIONS
   ns_printf(pio, "Context switches; Delay:  %lu\n",
 2027858:	00808174 	movhi	r2,517
 202785c:	1090a004 	addi	r2,r2,17024
 2027860:	10800017 	ldw	r2,0(r2)
 2027864:	e13fff17 	ldw	r4,-4(fp)
 2027868:	01408174 	movhi	r5,517
 202786c:	297bce04 	addi	r5,r5,-4296
 2027870:	100d883a 	mov	r6,r2
 2027874:	2026e100 	call	2026e10 <ns_printf>
#else
   ns_printf(pio, "Context switches; Delay:  %lu, Interrupt: %lu\n",
      OSCtxSwCtr, OSCtxIntCtr);
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");
 2027878:	e13fff17 	ldw	r4,-4(fp)
 202787c:	01408174 	movhi	r5,517
 2027880:	297bd604 	addi	r5,r5,-4264
 2027884:	2026e100 	call	2026e10 <ns_printf>

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 2027888:	e03ff215 	stw	zero,-56(fp)
 202788c:	00005306 	br	20279dc <tk_stats+0x1a8>
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
 2027890:	00c09934 	movhi	r3,612
 2027894:	18f45704 	addi	r3,r3,-11940
 2027898:	e0bff217 	ldw	r2,-56(fp)
 202789c:	1085883a 	add	r2,r2,r2
 20278a0:	1085883a 	add	r2,r2,r2
 20278a4:	1885883a 	add	r2,r3,r2
 20278a8:	10800017 	ldw	r2,0(r2)
 20278ac:	e0bff415 	stw	r2,-48(fp)
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
 20278b0:	e0bff417 	ldw	r2,-48(fp)
 20278b4:	10004526 	beq	r2,zero,20279cc <tk_stats+0x198>
 20278b8:	e0bff417 	ldw	r2,-48(fp)
 20278bc:	10800058 	cmpnei	r2,r2,1
 20278c0:	10004226 	beq	r2,zero,20279cc <tk_stats+0x198>
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);
 20278c4:	e0bff417 	ldw	r2,-48(fp)
 20278c8:	10800c83 	ldbu	r2,50(r2)
 20278cc:	11003fcc 	andi	r4,r2,255
 20278d0:	e0fff604 	addi	r3,fp,-40
 20278d4:	e0bffe44 	addi	r2,fp,-7
 20278d8:	180b883a 	mov	r5,r3
 20278dc:	100d883a 	mov	r6,r2
 20278e0:	201d52c0 	call	201d52c <OSTaskNameGet>

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 20278e4:	e0bff417 	ldw	r2,-48(fp)
 20278e8:	10800c83 	ldbu	r2,50(r2)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 20278ec:	10803fcc 	andi	r2,r2,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 20278f0:	e0fff417 	ldw	r3,-48(fp)
 20278f4:	18c00c03 	ldbu	r3,48(r3)
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 20278f8:	19003fcc 	andi	r4,r3,255
                     name, tcb->OSTCBPrio, tcb->OSTCBStat);
 20278fc:	e0fff604 	addi	r3,fp,-40
         continue;

      OSTaskNameGet(tcb->OSTCBPrio, (INT8U *)&name, &err);

#ifdef NO_INICHE_EXTENSIONS
      ns_printf(pio, "%15s %2d    0x%04x,    ---   ",
 2027900:	d9000015 	stw	r4,0(sp)
 2027904:	e13fff17 	ldw	r4,-4(fp)
 2027908:	01408174 	movhi	r5,517
 202790c:	297be604 	addi	r5,r5,-4200
 2027910:	180d883a 	mov	r6,r3
 2027914:	100f883a 	mov	r7,r2
 2027918:	2026e100 	call	2026e10 <ns_printf>
      /* Find lowest non-zero value in stack so we can estimate the
       * unused portion. Subtracting this from size gives us the used
       * portion of the stack.
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
 202791c:	e0bff417 	ldw	r2,-48(fp)
 2027920:	10800217 	ldw	r2,8(r2)
 2027924:	10002426 	beq	r2,zero,20279b8 <tk_stats+0x184>
 2027928:	e0bff417 	ldw	r2,-48(fp)
 202792c:	10800317 	ldw	r2,12(r2)
 2027930:	10002126 	beq	r2,zero,20279b8 <tk_stats+0x184>
      {
         sp = tcb->OSTCBStkBottom + 1;
 2027934:	e0bff417 	ldw	r2,-48(fp)
 2027938:	10800217 	ldw	r2,8(r2)
 202793c:	10800104 	addi	r2,r2,4
 2027940:	e0bff315 	stw	r2,-52(fp)
         while(*sp == 0)
 2027944:	00000306 	br	2027954 <tk_stats+0x120>
            sp++;
 2027948:	e0bff317 	ldw	r2,-52(fp)
 202794c:	10800104 	addi	r2,r2,4
 2027950:	e0bff315 	stw	r2,-52(fp)
       */
#if OS_TASK_CREATE_EXT_EN > 0
      if(tcb->OSTCBStkBottom && tcb->OSTCBStkSize)
      {
         sp = tcb->OSTCBStkBottom + 1;
         while(*sp == 0)
 2027954:	e0bff317 	ldw	r2,-52(fp)
 2027958:	10800017 	ldw	r2,0(r2)
 202795c:	103ffa26 	beq	r2,zero,2027948 <tk_stats+0x114>
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
 2027960:	e0bff417 	ldw	r2,-48(fp)
 2027964:	10c00317 	ldw	r3,12(r2)
 2027968:	e13ff317 	ldw	r4,-52(fp)
 202796c:	e0bff417 	ldw	r2,-48(fp)
 2027970:	10800217 	ldw	r2,8(r2)
 2027974:	2085c83a 	sub	r2,r4,r2
 2027978:	1005d0ba 	srai	r2,r2,2
 202797c:	1885c83a 	sub	r2,r3,r2
 2027980:	1085883a 	add	r2,r2,r2
 2027984:	1085883a 	add	r2,r2,r2
 2027988:	e0bff515 	stw	r2,-44(fp)
         ns_printf(pio, "%6d,      %6d\n",
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
 202798c:	e0bff417 	ldw	r2,-48(fp)
 2027990:	10800317 	ldw	r2,12(r2)
            sp++;
         /* This OS traditionally keeps the size in OS_STK (int) units rather
          * than bytes, so convert back to bytes for display.
          */
         stackuse = (tcb->OSTCBStkSize - (sp - tcb->OSTCBStkBottom)) * sizeof(OS_STK);
         ns_printf(pio, "%6d,      %6d\n",
 2027994:	1085883a 	add	r2,r2,r2
 2027998:	1085883a 	add	r2,r2,r2
 202799c:	e13fff17 	ldw	r4,-4(fp)
 20279a0:	01408174 	movhi	r5,517
 20279a4:	297bee04 	addi	r5,r5,-4168
 20279a8:	100d883a 	mov	r6,r2
 20279ac:	e1fff517 	ldw	r7,-44(fp)
 20279b0:	2026e100 	call	2026e10 <ns_printf>
 20279b4:	00000606 	br	20279d0 <tk_stats+0x19c>
            tcb->OSTCBStkSize * sizeof(OS_STK),  stackuse);
      }
      else
#endif
      {
         ns_printf(pio, "No stack data\n");
 20279b8:	e13fff17 	ldw	r4,-4(fp)
 20279bc:	01408174 	movhi	r5,517
 20279c0:	297bf204 	addi	r5,r5,-4152
 20279c4:	2026e100 	call	2026e10 <ns_printf>
 20279c8:	00000106 	br	20279d0 <tk_stats+0x19c>
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
   {
      /* get pointer to TCB and see if entry is in use and not a mutex */
      tcb = OSTCBPrioTbl[t];
      if ((tcb == NULL) || (tcb == (OS_TCB *)1))
         continue;
 20279cc:	0001883a 	nop
#endif

   ns_printf(pio, "       name     prio. state    wakeups stack-size stack-use \n");

   
   for (t = 0; t <= OS_LOWEST_PRIO ; t++)
 20279d0:	e0bff217 	ldw	r2,-56(fp)
 20279d4:	10800044 	addi	r2,r2,1
 20279d8:	e0bff215 	stw	r2,-56(fp)
 20279dc:	e0bff217 	ldw	r2,-56(fp)
 20279e0:	10800550 	cmplti	r2,r2,21
 20279e4:	103faa1e 	bne	r2,zero,2027890 <tk_stats+0x5c>
      {
         ns_printf(pio, "No stack data\n");
      }
   }

   ns_printf(pio, "tcp_sleep_count = %lu, tcp_wakeup_count = %lu\n",
 20279e8:	00808174 	movhi	r2,517
 20279ec:	1090c404 	addi	r2,r2,17168
 20279f0:	10c00017 	ldw	r3,0(r2)
 20279f4:	00808174 	movhi	r2,517
 20279f8:	1090c504 	addi	r2,r2,17172
 20279fc:	10800017 	ldw	r2,0(r2)
 2027a00:	e13fff17 	ldw	r4,-4(fp)
 2027a04:	01408174 	movhi	r5,517
 2027a08:	297bf604 	addi	r5,r5,-4136
 2027a0c:	180d883a 	mov	r6,r3
 2027a10:	100f883a 	mov	r7,r2
 2027a14:	2026e100 	call	2026e10 <ns_printf>
                  tcp_sleep_count, tcp_wakeup_count);
   ns_printf(pio, "global_TCPwakeup_setIndx = %d, tcp_sleep_timeout = %lu\n",
 2027a18:	00808174 	movhi	r2,517
 2027a1c:	1090c804 	addi	r2,r2,17184
 2027a20:	10c00017 	ldw	r3,0(r2)
 2027a24:	d0a09317 	ldw	r2,-32180(gp)
 2027a28:	e13fff17 	ldw	r4,-4(fp)
 2027a2c:	01408174 	movhi	r5,517
 2027a30:	297c0204 	addi	r5,r5,-4088
 2027a34:	180d883a 	mov	r6,r3
 2027a38:	100f883a 	mov	r7,r2
 2027a3c:	2026e100 	call	2026e10 <ns_printf>
                  global_TCPwakeup_setIndx, tcp_sleep_timeout);

   return 0;
 2027a40:	0005883a 	mov	r2,zero
}
 2027a44:	e037883a 	mov	sp,fp
 2027a48:	dfc00117 	ldw	ra,4(sp)
 2027a4c:	df000017 	ldw	fp,0(sp)
 2027a50:	dec00204 	addi	sp,sp,8
 2027a54:	f800283a 	ret

02027a58 <pk_init>:
 * for a PACKET buffer or a data buffer fails, or if there is an inconsistency
 * between (bigbufs + lilbufs) and MAXPACKETS) it returns -1. 
 */

int pk_init (void)
{
 2027a58:	defff804 	addi	sp,sp,-32
 2027a5c:	dfc00715 	stw	ra,28(sp)
 2027a60:	df000615 	stw	fp,24(sp)
 2027a64:	df000604 	addi	fp,sp,24
   PACKET packet;
   unsigned i;
   unsigned numpkts = bigbufs + lilbufs;
 2027a68:	d0e03e17 	ldw	r3,-32520(gp)
 2027a6c:	d0a03c17 	ldw	r2,-32528(gp)
 2027a70:	1885883a 	add	r2,r3,r2
 2027a74:	e0bffd15 	stw	r2,-12(fp)
   u_char align_req;
   
#ifdef ALIGN_BUFS
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
 2027a78:	e03ffe05 	stb	zero,-8(fp)
#endif

   for (i = 0; i < numpkts; i++)
 2027a7c:	e03ffa15 	stw	zero,-24(fp)
 2027a80:	00007806 	br	2027c64 <pk_init+0x20c>
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
 2027a84:	01000d04 	movi	r4,52
 2027a88:	20290400 	call	2029040 <npalloc>
 2027a8c:	e0bfff15 	stw	r2,-4(fp)
      if (packet == NULL)
 2027a90:	e0bfff17 	ldw	r2,-4(fp)
 2027a94:	10008226 	beq	r2,zero,2027ca0 <pk_init+0x248>
         goto no_pkt_buf;

#ifdef NPDEBUG
      if (i >= MAXPACKETS)
 2027a98:	e0bffa17 	ldw	r2,-24(fp)
 2027a9c:	10800f30 	cmpltui	r2,r2,60
 2027aa0:	1000051e 	bne	r2,zero,2027ab8 <pk_init+0x60>
      {
         dprintf("pk_init: bad define\n");
 2027aa4:	01008174 	movhi	r4,517
 2027aa8:	213c1004 	addi	r4,r4,-4032
 2027aac:	2006cb40 	call	2006cb4 <puts>
         return -1;
 2027ab0:	00bfffc4 	movi	r2,-1
 2027ab4:	00008806 	br	2027cd8 <pk_init+0x280>
      }
      pktlog[i] = packet;     /* save for debugging */
 2027ab8:	00c09934 	movhi	r3,612
 2027abc:	18f5f004 	addi	r3,r3,-10304
 2027ac0:	e0bffa17 	ldw	r2,-24(fp)
 2027ac4:	1085883a 	add	r2,r2,r2
 2027ac8:	1085883a 	add	r2,r2,r2
 2027acc:	1885883a 	add	r2,r3,r2
 2027ad0:	e0ffff17 	ldw	r3,-4(fp)
 2027ad4:	10c00015 	stw	r3,0(r2)
#endif

      packet->nb_tstamp = 0L;
 2027ad8:	e0bfff17 	ldw	r2,-4(fp)
 2027adc:	10000515 	stw	zero,20(r2)

      if (i < bigbufs)
 2027ae0:	d0a03e17 	ldw	r2,-32520(gp)
 2027ae4:	e0fffa17 	ldw	r3,-24(fp)
 2027ae8:	18802e2e 	bgeu	r3,r2,2027ba4 <pk_init+0x14c>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
 2027aec:	d0a03f17 	ldw	r2,-32516(gp)
 2027af0:	10800144 	addi	r2,r2,5
 2027af4:	1009883a 	mov	r4,r2
 2027af8:	20291ec0 	call	20291ec <ncpalloc>
 2027afc:	e0ffff17 	ldw	r3,-4(fp)
 2027b00:	18800115 	stw	r2,4(r3)
            if (!(packet->nb_buff))
 2027b04:	e0bfff17 	ldw	r2,-4(fp)
 2027b08:	10800117 	ldw	r2,4(r2)
 2027b0c:	10006626 	beq	r2,zero,2027ca8 <pk_init+0x250>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 2027b10:	e03ffb15 	stw	zero,-20(fp)
 2027b14:	00000906 	br	2027b3c <pk_init+0xe4>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 2027b18:	e0bfff17 	ldw	r2,-4(fp)
 2027b1c:	10c00117 	ldw	r3,4(r2)
 2027b20:	e0bffb17 	ldw	r2,-20(fp)
 2027b24:	1885883a 	add	r2,r3,r2
 2027b28:	00c01344 	movi	r3,77
 2027b2c:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 2027b30:	e0bffb17 	ldw	r2,-20(fp)
 2027b34:	10800044 	addi	r2,r2,1
 2027b38:	e0bffb15 	stw	r2,-20(fp)
 2027b3c:	e0bffb17 	ldw	r2,-20(fp)
 2027b40:	10800110 	cmplti	r2,r2,4
 2027b44:	103ff41e 	bne	r2,zero,2027b18 <pk_init+0xc0>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + bigbufsiz + ALIGN_TYPE) = 'M';
 2027b48:	e0bfff17 	ldw	r2,-4(fp)
 2027b4c:	10c00117 	ldw	r3,4(r2)
 2027b50:	d0a03f17 	ldw	r2,-32516(gp)
 2027b54:	10800104 	addi	r2,r2,4
 2027b58:	1885883a 	add	r2,r3,r2
 2027b5c:	00c01344 	movi	r3,77
 2027b60:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;   /* bump buf past MMs */
 2027b64:	e0bfff17 	ldw	r2,-4(fp)
 2027b68:	10800117 	ldw	r2,4(r2)
 2027b6c:	10c00104 	addi	r3,r2,4
 2027b70:	e0bfff17 	ldw	r2,-4(fp)
 2027b74:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 2027b78:	e0bfff17 	ldw	r2,-4(fp)
 2027b7c:	10800117 	ldw	r2,4(r2)
 2027b80:	10004b26 	beq	r2,zero,2027cb0 <pk_init+0x258>
            goto no_pkt_buf;
         packet->nb_blen = bigbufsiz;
 2027b84:	d0e03f17 	ldw	r3,-32516(gp)
 2027b88:	e0bfff17 	ldw	r2,-4(fp)
 2027b8c:	10c00215 	stw	r3,8(r2)
         q_add(&bigfreeq, packet);        /* save it in big pkt free queue */
 2027b90:	01009934 	movhi	r4,612
 2027b94:	21362c04 	addi	r4,r4,-10064
 2027b98:	e17fff17 	ldw	r5,-4(fp)
 2027b9c:	20282880 	call	2028288 <putq>
 2027ba0:	00002d06 	br	2027c58 <pk_init+0x200>
#ifdef NPDEBUG
         {
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
 2027ba4:	d0a03d17 	ldw	r2,-32524(gp)
 2027ba8:	10800144 	addi	r2,r2,5
 2027bac:	1009883a 	mov	r4,r2
 2027bb0:	20291ec0 	call	20291ec <ncpalloc>
 2027bb4:	e0ffff17 	ldw	r3,-4(fp)
 2027bb8:	18800115 	stw	r2,4(r3)
            if (!(packet->nb_buff))
 2027bbc:	e0bfff17 	ldw	r2,-4(fp)
 2027bc0:	10800117 	ldw	r2,4(r2)
 2027bc4:	10003c26 	beq	r2,zero,2027cb8 <pk_init+0x260>
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 2027bc8:	e03ffc15 	stw	zero,-16(fp)
 2027bcc:	00000906 	br	2027bf4 <pk_init+0x19c>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */
 2027bd0:	e0bfff17 	ldw	r2,-4(fp)
 2027bd4:	10c00117 	ldw	r3,4(r2)
 2027bd8:	e0bffc17 	ldw	r2,-16(fp)
 2027bdc:	1885883a 	add	r2,r3,r2
 2027be0:	00c01344 	movi	r3,77
 2027be4:	10c00005 	stb	r3,0(r2)
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;

            /* Add memory markers for sanity check */
            for(j = 0; j < ALIGN_TYPE; j++)
 2027be8:	e0bffc17 	ldw	r2,-16(fp)
 2027bec:	10800044 	addi	r2,r2,1
 2027bf0:	e0bffc15 	stw	r2,-16(fp)
 2027bf4:	e0bffc17 	ldw	r2,-16(fp)
 2027bf8:	10800110 	cmplti	r2,r2,4
 2027bfc:	103ff41e 	bne	r2,zero,2027bd0 <pk_init+0x178>
               *(packet->nb_buff + j) = 'M'; /* MMs at start of buf */

            *(packet->nb_buff + lilbufsiz + ALIGN_TYPE) = 'M';
 2027c00:	e0bfff17 	ldw	r2,-4(fp)
 2027c04:	10c00117 	ldw	r3,4(r2)
 2027c08:	d0a03d17 	ldw	r2,-32524(gp)
 2027c0c:	10800104 	addi	r2,r2,4
 2027c10:	1885883a 	add	r2,r3,r2
 2027c14:	00c01344 	movi	r3,77
 2027c18:	10c00005 	stb	r3,0(r2)
            packet->nb_buff += ALIGN_TYPE;
 2027c1c:	e0bfff17 	ldw	r2,-4(fp)
 2027c20:	10800117 	ldw	r2,4(r2)
 2027c24:	10c00104 	addi	r3,r2,4
 2027c28:	e0bfff17 	ldw	r2,-4(fp)
 2027c2c:	10c00115 	stw	r3,4(r2)
#ifdef ALIGN_BUFS
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
 2027c30:	e0bfff17 	ldw	r2,-4(fp)
 2027c34:	10800117 	ldw	r2,4(r2)
 2027c38:	10002126 	beq	r2,zero,2027cc0 <pk_init+0x268>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
 2027c3c:	d0e03d17 	ldw	r3,-32524(gp)
 2027c40:	e0bfff17 	ldw	r2,-4(fp)
 2027c44:	10c00215 	stw	r3,8(r2)
         q_add(&lilfreeq, packet);        /* save it in little free queue */
 2027c48:	01009934 	movhi	r4,612
 2027c4c:	2135e704 	addi	r4,r4,-10340
 2027c50:	e17fff17 	ldw	r5,-4(fp)
 2027c54:	20282880 	call	2028288 <putq>
   align_req = ALIGN_BUFS;
#else
   align_req = 0;
#endif

   for (i = 0; i < numpkts; i++)
 2027c58:	e0bffa17 	ldw	r2,-24(fp)
 2027c5c:	10800044 	addi	r2,r2,1
 2027c60:	e0bffa15 	stw	r2,-24(fp)
 2027c64:	e0fffa17 	ldw	r3,-24(fp)
 2027c68:	e0bffd17 	ldw	r2,-12(fp)
 2027c6c:	18bf8536 	bltu	r3,r2,2027a84 <pk_init+0x2c>
            goto no_pkt_buf;
         packet->nb_blen = lilbufsiz;
         q_add(&lilfreeq, packet);        /* save it in little free queue */
      }
   }
   bigfreeq.q_min = bigbufs;
 2027c70:	d0a03e17 	ldw	r2,-32520(gp)
 2027c74:	1007883a 	mov	r3,r2
 2027c78:	00809934 	movhi	r2,612
 2027c7c:	10b62c04 	addi	r2,r2,-10064
 2027c80:	10c00415 	stw	r3,16(r2)
   lilfreeq.q_min = lilbufs;
 2027c84:	d0a03c17 	ldw	r2,-32528(gp)
 2027c88:	1007883a 	mov	r3,r2
 2027c8c:	00809934 	movhi	r2,612
 2027c90:	10b5e704 	addi	r2,r2,-10340
 2027c94:	10c00415 	stw	r3,16(r2)
   heap_curr_mem_hi_watermark = 0;
   /* set the heap's access type to blocking */
   heap_type = HEAP_ACCESS_BLOCKING;
#endif

   return 0;
 2027c98:	0005883a 	mov	r2,zero
 2027c9c:	00000e06 	br	2027cd8 <pk_init+0x280>

   for (i = 0; i < numpkts; i++)
   {
      packet = (PACKET)NB_ALLOC(sizeof(struct netbuf));
      if (packet == NULL)
         goto no_pkt_buf;
 2027ca0:	0001883a 	nop
 2027ca4:	00000706 	br	2027cc4 <pk_init+0x26c>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)BB_ALLOC(bigbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 2027ca8:	0001883a 	nop
 2027cac:	00000506 	br	2027cc4 <pk_init+0x26c>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 2027cb0:	0001883a 	nop
 2027cb4:	00000306 	br	2027cc4 <pk_init+0x26c>
            int j;

            /* for DEBUG compiles, bracket the data area with special chars */
            packet->nb_buff = (char *)LB_ALLOC(lilbufsiz+ALIGN_TYPE+1);
            if (!(packet->nb_buff))
               goto no_pkt_buf;
 2027cb8:	0001883a 	nop
 2027cbc:	00000106 	br	2027cc4 <pk_init+0x26c>
         /* align start of buffer pointer to desired offset */
         packet->nb_buff += (ALIGN_BUFS - (((u_long) packet->nb_buff) & (ALIGN_BUFS - 1)));
#endif
#endif
         if (!(packet->nb_buff))
            goto no_pkt_buf;
 2027cc0:	0001883a 	nop

   return 0;

no_pkt_buf:
#ifdef NPDEBUG
   dprintf("Netinit: calloc failed getting buffer %d\n", i);
 2027cc4:	01008174 	movhi	r4,517
 2027cc8:	213c1504 	addi	r4,r4,-4012
 2027ccc:	e17ffa17 	ldw	r5,-24(fp)
 2027cd0:	2006a240 	call	2006a24 <printf>
#endif
   return(-1);
 2027cd4:	00bfffc4 	movi	r2,-1
}
 2027cd8:	e037883a 	mov	sp,fp
 2027cdc:	dfc00117 	ldw	ra,4(sp)
 2027ce0:	df000017 	ldw	fp,0(sp)
 2027ce4:	dec00204 	addi	sp,sp,8
 2027ce8:	f800283a 	ret

02027cec <pk_alloc>:
 * OUTPUT: 0 if the request cannot be satisfied, or a pointer to the struct
 * netbuf structure that corresponds to the just allocated data buffer.
 */

PACKET pk_alloc(unsigned len)
{
 2027cec:	defffc04 	addi	sp,sp,-16
 2027cf0:	dfc00315 	stw	ra,12(sp)
 2027cf4:	df000215 	stw	fp,8(sp)
 2027cf8:	df000204 	addi	fp,sp,8
 2027cfc:	e13fff15 	stw	r4,-4(fp)
   PACKET p;

   if (len > bigbufsiz) /* caller wants oversize buffer? */
 2027d00:	d0e03f17 	ldw	r3,-32516(gp)
 2027d04:	e0bfff17 	ldw	r2,-4(fp)
 2027d08:	1880022e 	bgeu	r3,r2,2027d14 <pk_alloc+0x28>
   {
#ifdef HEAPBUFS
      if ((p = pk_alloc_heapbuf (len)) == NULL)
         return NULL;
#else
      return(NULL);
 2027d0c:	0005883a 	mov	r2,zero
 2027d10:	00002406 	br	2027da4 <pk_alloc+0xb8>
#endif
   }
   else
   {
      if ((len > lilbufsiz) || (lilfreeq.q_len == 0)) /* must use a big buffer */
 2027d14:	d0e03d17 	ldw	r3,-32524(gp)
 2027d18:	e0bfff17 	ldw	r2,-4(fp)
 2027d1c:	18800436 	bltu	r3,r2,2027d30 <pk_alloc+0x44>
 2027d20:	00809934 	movhi	r2,612
 2027d24:	10b5e704 	addi	r2,r2,-10340
 2027d28:	10800217 	ldw	r2,8(r2)
 2027d2c:	1000051e 	bne	r2,zero,2027d44 <pk_alloc+0x58>
         p = (PACKET)getq(&bigfreeq);
 2027d30:	01009934 	movhi	r4,612
 2027d34:	21362c04 	addi	r4,r4,-10064
 2027d38:	20281d00 	call	20281d0 <getq>
 2027d3c:	e0bffe15 	stw	r2,-8(fp)
 2027d40:	00000406 	br	2027d54 <pk_alloc+0x68>
      else
         p = (PACKET)getq(&lilfreeq);
 2027d44:	01009934 	movhi	r4,612
 2027d48:	2135e704 	addi	r4,r4,-10340
 2027d4c:	20281d00 	call	20281d0 <getq>
 2027d50:	e0bffe15 	stw	r2,-8(fp)

      if (!p)
 2027d54:	e0bffe17 	ldw	r2,-8(fp)
 2027d58:	1000021e 	bne	r2,zero,2027d64 <pk_alloc+0x78>
         return NULL;
 2027d5c:	0005883a 	mov	r2,zero
 2027d60:	00001006 	br	2027da4 <pk_alloc+0xb8>
   }

   p->nb_prot = p->nb_buff + MaxLnh;   /* point past biggest mac header */
 2027d64:	e0bffe17 	ldw	r2,-8(fp)
 2027d68:	10c00117 	ldw	r3,4(r2)
 2027d6c:	00808174 	movhi	r2,517
 2027d70:	1090b004 	addi	r2,r2,17088
 2027d74:	10800017 	ldw	r2,0(r2)
 2027d78:	1887883a 	add	r3,r3,r2
 2027d7c:	e0bffe17 	ldw	r2,-8(fp)
 2027d80:	10c00315 	stw	r3,12(r2)
   p->nb_plen = 0;   /* no protocol data there yet */
 2027d84:	e0bffe17 	ldw	r2,-8(fp)
 2027d88:	10000415 	stw	zero,16(r2)
   p->net = NULL;
 2027d8c:	e0bffe17 	ldw	r2,-8(fp)
 2027d90:	10000615 	stw	zero,24(r2)
   p->nexthop = NULL;      /* no next hop  */
   p->nb_pmtu = 1240;      /* Set minimum IPv6 Path MTU */
#endif   /* IP_V6 */
#endif /* LINKED_PKTS */

   p->inuse = 1;  /* initially buffer in use by 1 user */
 2027d94:	e0bffe17 	ldw	r2,-8(fp)
 2027d98:	00c00044 	movi	r3,1
 2027d9c:	10c00915 	stw	r3,36(r2)

   /* note that 'type' and 'fhost' fields are not set in pk_alloc () */
   return(p);
 2027da0:	e0bffe17 	ldw	r2,-8(fp)
}
 2027da4:	e037883a 	mov	sp,fp
 2027da8:	dfc00117 	ldw	ra,4(sp)
 2027dac:	df000017 	ldw	fp,0(sp)
 2027db0:	dec00204 	addi	sp,sp,8
 2027db4:	f800283a 	ret

02027db8 <pk_validate>:
 * OUTPUT: 0 if the buffer being freed was successfully validated, or
 * -1 if the validation failed.
 */

int pk_validate(PACKET pkt)   /* check if pk_free() can free the pkt */
{
 2027db8:	defffb04 	addi	sp,sp,-20
 2027dbc:	dfc00415 	stw	ra,16(sp)
 2027dc0:	df000315 	stw	fp,12(sp)
 2027dc4:	df000304 	addi	fp,sp,12
 2027dc8:	e13fff15 	stw	r4,-4(fp)
   /* If packet link is non-zero, then this packet is
    * part of a chain and deleted this packet would break
    * the chain and cause memory leak for subsequent pkts.
    * Note that heapbufs do not use the 'next' field at all.
    */
   if ((pkt->next) && (pkt->inuse >= 1))
 2027dcc:	e0bfff17 	ldw	r2,-4(fp)
 2027dd0:	10800017 	ldw	r2,0(r2)
 2027dd4:	10000e26 	beq	r2,zero,2027e10 <pk_validate+0x58>
 2027dd8:	e0bfff17 	ldw	r2,-4(fp)
 2027ddc:	10800917 	ldw	r2,36(r2)
 2027de0:	10000b26 	beq	r2,zero,2027e10 <pk_validate+0x58>
   {
      INCR_SHARED_VAR (memestats, INCONSISTENT_LOCATION_ERR, 1);   
 2027de4:	20287fc0 	call	20287fc <irq_Mask>
 2027de8:	00809934 	movhi	r2,612
 2027dec:	10b5ec04 	addi	r2,r2,-10320
 2027df0:	10800317 	ldw	r2,12(r2)
 2027df4:	10c00044 	addi	r3,r2,1
 2027df8:	00809934 	movhi	r2,612
 2027dfc:	10b5ec04 	addi	r2,r2,-10320
 2027e00:	10c00315 	stw	r3,12(r2)
 2027e04:	20288580 	call	2028858 <irq_Unmask>
      return -1;
 2027e08:	00bfffc4 	movi	r2,-1
 2027e0c:	00008806 	br	2028030 <pk_validate+0x278>
   }
   else  
#endif /* HEAPBUFS */
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
 2027e10:	e0bfff17 	ldw	r2,-4(fp)
 2027e14:	10c00217 	ldw	r3,8(r2)
 2027e18:	d0a03f17 	ldw	r2,-32516(gp)
 2027e1c:	1880201e 	bne	r3,r2,2027ea0 <pk_validate+0xe8>
      {
         ENTER_CRIT_SECTION(&bigfreeq);
 2027e20:	20287fc0 	call	20287fc <irq_Mask>
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 2027e24:	00809934 	movhi	r2,612
 2027e28:	10b62c04 	addi	r2,r2,-10064
 2027e2c:	10800017 	ldw	r2,0(r2)
 2027e30:	e0bffd15 	stw	r2,-12(fp)
 2027e34:	00001606 	br	2027e90 <pk_validate+0xd8>
            if (p == pkt)
 2027e38:	e0fffd17 	ldw	r3,-12(fp)
 2027e3c:	e0bfff17 	ldw	r2,-4(fp)
 2027e40:	1880101e 	bne	r3,r2,2027e84 <pk_validate+0xcc>
            {
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
 2027e44:	01008174 	movhi	r4,517
 2027e48:	213c2004 	addi	r4,r4,-3968
 2027e4c:	e17fff17 	ldw	r5,-4(fp)
 2027e50:	2006a240 	call	2006a24 <printf>
               EXIT_CRIT_SECTION(&bigfreeq);
 2027e54:	20288580 	call	2028858 <irq_Unmask>
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 2027e58:	20287fc0 	call	20287fc <irq_Mask>
 2027e5c:	00809934 	movhi	r2,612
 2027e60:	10b5ec04 	addi	r2,r2,-10320
 2027e64:	10800217 	ldw	r2,8(r2)
 2027e68:	10c00044 	addi	r3,r2,1
 2027e6c:	00809934 	movhi	r2,612
 2027e70:	10b5ec04 	addi	r2,r2,-10320
 2027e74:	10c00215 	stw	r3,8(r2)
 2027e78:	20288580 	call	2028858 <irq_Unmask>
               return -1;
 2027e7c:	00bfffc4 	movi	r2,-1
 2027e80:	00006b06 	br	2028030 <pk_validate+0x278>
   {
      /* check if the packet is already in a freeq */
      if (pkt->nb_blen == bigbufsiz)  /* check in bigfreeq */
      {
         ENTER_CRIT_SECTION(&bigfreeq);
         for (p=(PACKET)bigfreeq.q_head; p; p = p->next)
 2027e84:	e0bffd17 	ldw	r2,-12(fp)
 2027e88:	10800017 	ldw	r2,0(r2)
 2027e8c:	e0bffd15 	stw	r2,-12(fp)
 2027e90:	e0bffd17 	ldw	r2,-12(fp)
 2027e94:	103fe81e 	bne	r2,zero,2027e38 <pk_validate+0x80>
               dprintf("pk_free: buffer %p already in bigfreeq\n", pkt);
               EXIT_CRIT_SECTION(&bigfreeq);
               INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
               return -1;
            }
         EXIT_CRIT_SECTION(&bigfreeq);
 2027e98:	20288580 	call	2028858 <irq_Unmask>
 2027e9c:	00002f06 	br	2027f5c <pk_validate+0x1a4>
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
 2027ea0:	e0bfff17 	ldw	r2,-4(fp)
 2027ea4:	10c00217 	ldw	r3,8(r2)
 2027ea8:	d0a03d17 	ldw	r2,-32524(gp)
 2027eac:	1880201e 	bne	r3,r2,2027f30 <pk_validate+0x178>
      {
         ENTER_CRIT_SECTION(&lilfreeq);
 2027eb0:	20287fc0 	call	20287fc <irq_Mask>
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 2027eb4:	00809934 	movhi	r2,612
 2027eb8:	10b5e704 	addi	r2,r2,-10340
 2027ebc:	10800017 	ldw	r2,0(r2)
 2027ec0:	e0bffd15 	stw	r2,-12(fp)
 2027ec4:	00001606 	br	2027f20 <pk_validate+0x168>
            if (p == pkt)
 2027ec8:	e0fffd17 	ldw	r3,-12(fp)
 2027ecc:	e0bfff17 	ldw	r2,-4(fp)
 2027ed0:	1880101e 	bne	r3,r2,2027f14 <pk_validate+0x15c>
         {
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
 2027ed4:	01008174 	movhi	r4,517
 2027ed8:	213c2a04 	addi	r4,r4,-3928
 2027edc:	e17fff17 	ldw	r5,-4(fp)
 2027ee0:	2006a240 	call	2006a24 <printf>
            EXIT_CRIT_SECTION(&lilfreeq);
 2027ee4:	20288580 	call	2028858 <irq_Unmask>
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
 2027ee8:	20287fc0 	call	20287fc <irq_Mask>
 2027eec:	00809934 	movhi	r2,612
 2027ef0:	10b5ec04 	addi	r2,r2,-10320
 2027ef4:	10800217 	ldw	r2,8(r2)
 2027ef8:	10c00044 	addi	r3,r2,1
 2027efc:	00809934 	movhi	r2,612
 2027f00:	10b5ec04 	addi	r2,r2,-10320
 2027f04:	10c00215 	stw	r3,8(r2)
 2027f08:	20288580 	call	2028858 <irq_Unmask>
            return -1;
 2027f0c:	00bfffc4 	movi	r2,-1
 2027f10:	00004706 	br	2028030 <pk_validate+0x278>
         EXIT_CRIT_SECTION(&bigfreeq);
      }
      else if (pkt->nb_blen == lilbufsiz)  /* check in lilfreeq */
      {
         ENTER_CRIT_SECTION(&lilfreeq);
         for (p=(PACKET)lilfreeq.q_head; p; p = p->next)
 2027f14:	e0bffd17 	ldw	r2,-12(fp)
 2027f18:	10800017 	ldw	r2,0(r2)
 2027f1c:	e0bffd15 	stw	r2,-12(fp)
 2027f20:	e0bffd17 	ldw	r2,-12(fp)
 2027f24:	103fe81e 	bne	r2,zero,2027ec8 <pk_validate+0x110>
            dprintf("pk_free: buffer %p already in lilfreeq\n", pkt);
            EXIT_CRIT_SECTION(&lilfreeq);
            INCR_SHARED_VAR (memestats, MULTIPLE_FREE_ERR, 1);
            return -1;
         }
         EXIT_CRIT_SECTION(&lilfreeq);
 2027f28:	20288580 	call	2028858 <irq_Unmask>
 2027f2c:	00000b06 	br	2027f5c <pk_validate+0x1a4>
      }
      else
      {
         /* log an error */
         INCR_SHARED_VAR (memestats, BAD_REGULAR_BUF_LEN_ERR, 1);
 2027f30:	20287fc0 	call	20287fc <irq_Mask>
 2027f34:	00809934 	movhi	r2,612
 2027f38:	10b5ec04 	addi	r2,r2,-10320
 2027f3c:	10800017 	ldw	r2,0(r2)
 2027f40:	10c00044 	addi	r3,r2,1
 2027f44:	00809934 	movhi	r2,612
 2027f48:	10b5ec04 	addi	r2,r2,-10320
 2027f4c:	10c00015 	stw	r3,0(r2)
 2027f50:	20288580 	call	2028858 <irq_Unmask>
         return -1;
 2027f54:	00bfffc4 	movi	r2,-1
 2027f58:	00003506 	br	2028030 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 2027f5c:	00800104 	movi	r2,4
 2027f60:	e0bffe15 	stw	r2,-8(fp)
 2027f64:	00001906 	br	2027fcc <pk_validate+0x214>
   {
      if (*(pkt->nb_buff - j) != 'M')
 2027f68:	e0bfff17 	ldw	r2,-4(fp)
 2027f6c:	10c00117 	ldw	r3,4(r2)
 2027f70:	e0bffe17 	ldw	r2,-8(fp)
 2027f74:	0085c83a 	sub	r2,zero,r2
 2027f78:	1885883a 	add	r2,r3,r2
 2027f7c:	10800003 	ldbu	r2,0(r2)
 2027f80:	10803fcc 	andi	r2,r2,255
 2027f84:	1080201c 	xori	r2,r2,128
 2027f88:	10bfe004 	addi	r2,r2,-128
 2027f8c:	10801360 	cmpeqi	r2,r2,77
 2027f90:	10000b1e 	bne	r2,zero,2027fc0 <pk_validate+0x208>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 2027f94:	20287fc0 	call	20287fc <irq_Mask>
 2027f98:	00809934 	movhi	r2,612
 2027f9c:	10b5ec04 	addi	r2,r2,-10320
 2027fa0:	10800117 	ldw	r2,4(r2)
 2027fa4:	10c00044 	addi	r3,r2,1
 2027fa8:	00809934 	movhi	r2,612
 2027fac:	10b5ec04 	addi	r2,r2,-10320
 2027fb0:	10c00115 	stw	r3,4(r2)
 2027fb4:	20288580 	call	2028858 <irq_Unmask>
         return -1;
 2027fb8:	00bfffc4 	movi	r2,-1
 2027fbc:	00001c06 	br	2028030 <pk_validate+0x278>
   }

#ifdef NPDEBUG
   /* check for corruption of memory markers (the guard bands are only
    * present when NPDEBUG is defined) */
   for (j = ALIGN_TYPE; j > 0; j--)
 2027fc0:	e0bffe17 	ldw	r2,-8(fp)
 2027fc4:	10bfffc4 	addi	r2,r2,-1
 2027fc8:	e0bffe15 	stw	r2,-8(fp)
 2027fcc:	e0bffe17 	ldw	r2,-8(fp)
 2027fd0:	00bfe516 	blt	zero,r2,2027f68 <pk_validate+0x1b0>
      {
         INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
         return -1;
      }
   }
   if (*(pkt->nb_buff + pkt->nb_blen) != 'M')
 2027fd4:	e0bfff17 	ldw	r2,-4(fp)
 2027fd8:	10c00117 	ldw	r3,4(r2)
 2027fdc:	e0bfff17 	ldw	r2,-4(fp)
 2027fe0:	10800217 	ldw	r2,8(r2)
 2027fe4:	1885883a 	add	r2,r3,r2
 2027fe8:	10800003 	ldbu	r2,0(r2)
 2027fec:	10803fcc 	andi	r2,r2,255
 2027ff0:	1080201c 	xori	r2,r2,128
 2027ff4:	10bfe004 	addi	r2,r2,-128
 2027ff8:	10801360 	cmpeqi	r2,r2,77
 2027ffc:	10000b1e 	bne	r2,zero,202802c <pk_validate+0x274>
   {
      INCR_SHARED_VAR (memestats, GUARD_BAND_VIOLATED_ERR, 1);
 2028000:	20287fc0 	call	20287fc <irq_Mask>
 2028004:	00809934 	movhi	r2,612
 2028008:	10b5ec04 	addi	r2,r2,-10320
 202800c:	10800117 	ldw	r2,4(r2)
 2028010:	10c00044 	addi	r3,r2,1
 2028014:	00809934 	movhi	r2,612
 2028018:	10b5ec04 	addi	r2,r2,-10320
 202801c:	10c00115 	stw	r3,4(r2)
 2028020:	20288580 	call	2028858 <irq_Unmask>
      return -1;
 2028024:	00bfffc4 	movi	r2,-1
 2028028:	00000106 	br	2028030 <pk_validate+0x278>
   }
#endif /* NPDEBUG */

   return 0;
 202802c:	0005883a 	mov	r2,zero
}
 2028030:	e037883a 	mov	sp,fp
 2028034:	dfc00117 	ldw	ra,4(sp)
 2028038:	df000017 	ldw	fp,0(sp)
 202803c:	dec00204 	addi	sp,sp,8
 2028040:	f800283a 	ret

02028044 <pk_free>:
 *
 * OUTPUT: None.
 */

void pk_free(PACKET pkt)   /* PACKET to place in free queue */
{
 2028044:	defffc04 	addi	sp,sp,-16
 2028048:	dfc00315 	stw	ra,12(sp)
 202804c:	df000215 	stw	fp,8(sp)
 2028050:	df000204 	addi	fp,sp,8
 2028054:	e13fff15 	stw	r4,-4(fp)
      PACKET pknext;
      pknext = pkt->pk_next;
#endif /* LINKED_PKTS */

      /* validate the pkt before freeing */
      e = pk_validate(pkt);
 2028058:	e13fff17 	ldw	r4,-4(fp)
 202805c:	2027db80 	call	2027db8 <pk_validate>
 2028060:	e0bffe15 	stw	r2,-8(fp)
      if (e)
 2028064:	e0bffe17 	ldw	r2,-8(fp)
 2028068:	10001a1e 	bne	r2,zero,20280d4 <pk_free+0x90>
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
 202806c:	e0bfff17 	ldw	r2,-4(fp)
 2028070:	10800917 	ldw	r2,36(r2)
 2028074:	10c000a8 	cmpgeui	r3,r2,2
 2028078:	113fffc4 	addi	r4,r2,-1
 202807c:	e0bfff17 	ldw	r2,-4(fp)
 2028080:	11000915 	stw	r4,36(r2)
 2028084:	18803fcc 	andi	r2,r3,255
 2028088:	1000141e 	bne	r2,zero,20280dc <pk_free+0x98>
         pk_free_heapbuf (pkt);
      }
      else 
#endif /* HEAPBUFS */
      {
         if (pkt->nb_blen == bigbufsiz)
 202808c:	e0bfff17 	ldw	r2,-4(fp)
 2028090:	10c00217 	ldw	r3,8(r2)
 2028094:	d0a03f17 	ldw	r2,-32516(gp)
 2028098:	1880051e 	bne	r3,r2,20280b0 <pk_free+0x6c>
            q_add(&bigfreeq, (qp)pkt);
 202809c:	01009934 	movhi	r4,612
 20280a0:	21362c04 	addi	r4,r4,-10064
 20280a4:	e17fff17 	ldw	r5,-4(fp)
 20280a8:	20282880 	call	2028288 <putq>
 20280ac:	00000c06 	br	20280e0 <pk_free+0x9c>
         else if (pkt->nb_blen == lilbufsiz)
 20280b0:	e0bfff17 	ldw	r2,-4(fp)
 20280b4:	10c00217 	ldw	r3,8(r2)
 20280b8:	d0a03d17 	ldw	r2,-32524(gp)
 20280bc:	1880081e 	bne	r3,r2,20280e0 <pk_free+0x9c>
            q_add(&lilfreeq, (qp)pkt);
 20280c0:	01009934 	movhi	r4,612
 20280c4:	2135e704 	addi	r4,r4,-10340
 20280c8:	e17fff17 	ldw	r5,-4(fp)
 20280cc:	20282880 	call	2028288 <putq>
 20280d0:	00000306 	br	20280e0 <pk_free+0x9c>
         {
            pkt = pknext;
            continue; /* skip this pkt, examine the next pkt */
         }
#endif
         return;
 20280d4:	0001883a 	nop
 20280d8:	00000106 	br	20280e0 <pk_free+0x9c>
      }
      if (pkt->inuse-- > 1)   /* more than 1 owner? */
         return;  /* packet was cloned, don't delete yet */
 20280dc:	0001883a 	nop
#ifdef LINKED_PKTS
      pkt = pknext;
   }
#endif 

}
 20280e0:	e037883a 	mov	sp,fp
 20280e4:	dfc00117 	ldw	ra,4(sp)
 20280e8:	df000017 	ldw	fp,0(sp)
 20280ec:	dec00204 	addi	sp,sp,8
 20280f0:	f800283a 	ret

020280f4 <pk_get_max_intrsafe_buf_len>:
 *
 * OUTPUT: This function always returns the length of a big buffer (bigbufsiz).
 */

unsigned pk_get_max_intrsafe_buf_len(void)
{
 20280f4:	deffff04 	addi	sp,sp,-4
 20280f8:	df000015 	stw	fp,0(sp)
 20280fc:	d839883a 	mov	fp,sp
   return bigbufsiz;
 2028100:	d0a03f17 	ldw	r2,-32516(gp)
}
 2028104:	e037883a 	mov	sp,fp
 2028108:	df000017 	ldw	fp,0(sp)
 202810c:	dec00104 	addi	sp,sp,4
 2028110:	f800283a 	ret

02028114 <dump_buf_estats>:
 *
 * OUTPUT: This function always returns 0.
 */

int dump_buf_estats (void * pio)
{
 2028114:	defff904 	addi	sp,sp,-28
 2028118:	dfc00615 	stw	ra,24(sp)
 202811c:	df000515 	stw	fp,20(sp)
 2028120:	df000504 	addi	fp,sp,20
 2028124:	e13fff15 	stw	r4,-4(fp)
   u_long mlocal [MEMERR_NUM_STATS];

   LOCK_NET_RESOURCE(FREEQ_RESID);
 2028128:	01000084 	movi	r4,2
 202812c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   ENTER_CRIT_SECTION(&memestats);
 2028130:	20287fc0 	call	20287fc <irq_Mask>
   MEMCPY (&mlocal, &memestats, sizeof(memestats));
 2028134:	00809934 	movhi	r2,612
 2028138:	10b5ec04 	addi	r2,r2,-10320
 202813c:	10c00017 	ldw	r3,0(r2)
 2028140:	e0fffb15 	stw	r3,-20(fp)
 2028144:	10c00117 	ldw	r3,4(r2)
 2028148:	e0fffc15 	stw	r3,-16(fp)
 202814c:	10c00217 	ldw	r3,8(r2)
 2028150:	e0fffd15 	stw	r3,-12(fp)
 2028154:	10800317 	ldw	r2,12(r2)
 2028158:	e0bffe15 	stw	r2,-8(fp)
   EXIT_CRIT_SECTION(&memestats);
 202815c:	20288580 	call	2028858 <irq_Unmask>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2028160:	01000084 	movi	r4,2
 2028164:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   ns_printf(pio, "Regular buffer error statistics:\n");
 2028168:	e13fff17 	ldw	r4,-4(fp)
 202816c:	01408174 	movhi	r5,517
 2028170:	297c3404 	addi	r5,r5,-3888
 2028174:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio, "Bad buffer length %lu, Guard band violations %lu\n",mlocal[BAD_REGULAR_BUF_LEN_ERR],mlocal[GUARD_BAND_VIOLATED_ERR]);
 2028178:	e0fffb17 	ldw	r3,-20(fp)
 202817c:	e0bffc17 	ldw	r2,-16(fp)
 2028180:	e13fff17 	ldw	r4,-4(fp)
 2028184:	01408174 	movhi	r5,517
 2028188:	297c3d04 	addi	r5,r5,-3852
 202818c:	180d883a 	mov	r6,r3
 2028190:	100f883a 	mov	r7,r2
 2028194:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio, "Multiple frees %lu, Inconsistent location %lu\n",mlocal[MULTIPLE_FREE_ERR],mlocal[INCONSISTENT_LOCATION_ERR]);
 2028198:	e0fffd17 	ldw	r3,-12(fp)
 202819c:	e0bffe17 	ldw	r2,-8(fp)
 20281a0:	e13fff17 	ldw	r4,-4(fp)
 20281a4:	01408174 	movhi	r5,517
 20281a8:	297c4a04 	addi	r5,r5,-3800
 20281ac:	180d883a 	mov	r6,r3
 20281b0:	100f883a 	mov	r7,r2
 20281b4:	2026e100 	call	2026e10 <ns_printf>

   return 0;
 20281b8:	0005883a 	mov	r2,zero
}
 20281bc:	e037883a 	mov	sp,fp
 20281c0:	dfc00117 	ldw	ra,4(sp)
 20281c4:	df000017 	ldw	fp,0(sp)
 20281c8:	dec00204 	addi	sp,sp,8
 20281cc:	f800283a 	ret

020281d0 <getq>:
 * RETURNS: pointer to the first element if any, or 0 if the queue is empty.
 */

void*
getq(queue * q)
{
 20281d0:	defffc04 	addi	sp,sp,-16
 20281d4:	dfc00315 	stw	ra,12(sp)
 20281d8:	df000215 	stw	fp,8(sp)
 20281dc:	df000204 	addi	fp,sp,8
 20281e0:	e13fff15 	stw	r4,-4(fp)
   q_elt   temp;        /* temp for result */


   ENTER_CRIT_SECTION(q);     /* shut off ints, save old state */   
 20281e4:	20287fc0 	call	20287fc <irq_Mask>

   LOCKNET_CHECK(q);          /* make sure queue is protected */

   if ((temp = q->q_head) == 0)  /* queue empty? */
 20281e8:	e0bfff17 	ldw	r2,-4(fp)
 20281ec:	10800017 	ldw	r2,0(r2)
 20281f0:	e0bffe15 	stw	r2,-8(fp)
 20281f4:	e0bffe17 	ldw	r2,-8(fp)
 20281f8:	1000031e 	bne	r2,zero,2028208 <getq+0x38>
   {
      EXIT_CRIT_SECTION(q);
 20281fc:	20288580 	call	2028858 <irq_Unmask>
      return (0);             /* yes, show none */
 2028200:	0005883a 	mov	r2,zero
 2028204:	00001b06 	br	2028274 <getq+0xa4>
   }

   q->q_head = temp->qe_next; /* else unlink */
 2028208:	e0bffe17 	ldw	r2,-8(fp)
 202820c:	10c00017 	ldw	r3,0(r2)
 2028210:	e0bfff17 	ldw	r2,-4(fp)
 2028214:	10c00015 	stw	r3,0(r2)
   temp->qe_next = 0;         /* avoid dangling pointers */
 2028218:	e0bffe17 	ldw	r2,-8(fp)
 202821c:	10000015 	stw	zero,0(r2)
   if (q->q_head == 0)        /* queue empty? */
 2028220:	e0bfff17 	ldw	r2,-4(fp)
 2028224:	10800017 	ldw	r2,0(r2)
 2028228:	1000021e 	bne	r2,zero,2028234 <getq+0x64>
      q->q_tail = 0;          /* yes, update tail pointer too */
 202822c:	e0bfff17 	ldw	r2,-4(fp)
 2028230:	10000115 	stw	zero,4(r2)
   q->q_len--;                /* update queue length */
 2028234:	e0bfff17 	ldw	r2,-4(fp)
 2028238:	10800217 	ldw	r2,8(r2)
 202823c:	10ffffc4 	addi	r3,r2,-1
 2028240:	e0bfff17 	ldw	r2,-4(fp)
 2028244:	10c00215 	stw	r3,8(r2)
   if (q->q_len < q->q_min)
 2028248:	e0bfff17 	ldw	r2,-4(fp)
 202824c:	10c00217 	ldw	r3,8(r2)
 2028250:	e0bfff17 	ldw	r2,-4(fp)
 2028254:	10800417 	ldw	r2,16(r2)
 2028258:	1880040e 	bge	r3,r2,202826c <getq+0x9c>
      q->q_min = q->q_len;
 202825c:	e0bfff17 	ldw	r2,-4(fp)
 2028260:	10c00217 	ldw	r3,8(r2)
 2028264:	e0bfff17 	ldw	r2,-4(fp)
 2028268:	10c00415 	stw	r3,16(r2)

   QUEUE_CHECK(q);         /* make sure queue is not corrupted */

   EXIT_CRIT_SECTION(q);   /* restore caller's int state */
 202826c:	20288580 	call	2028858 <irq_Unmask>

   return ((void*)temp);
 2028270:	e0bffe17 	ldw	r2,-8(fp)
}
 2028274:	e037883a 	mov	sp,fp
 2028278:	dfc00117 	ldw	ra,4(sp)
 202827c:	df000017 	ldw	fp,0(sp)
 2028280:	dec00204 	addi	sp,sp,8
 2028284:	f800283a 	ret

02028288 <putq>:

void
putq(
   queue   *   q,       /* the queue */
   void *   elt)        /* element to delete */
{
 2028288:	defffc04 	addi	sp,sp,-16
 202828c:	dfc00315 	stw	ra,12(sp)
 2028290:	df000215 	stw	fp,8(sp)
 2028294:	df000204 	addi	fp,sp,8
 2028298:	e13ffe15 	stw	r4,-8(fp)
 202829c:	e17fff15 	stw	r5,-4(fp)
   ENTER_CRIT_SECTION(q);
 20282a0:	20287fc0 	call	20287fc <irq_Mask>
   LOCKNET_CHECK(q);       /* make sure queue is protected */
   q_addt(q, (qp)elt);     /* use macro to do work */
 20282a4:	e0bfff17 	ldw	r2,-4(fp)
 20282a8:	10000015 	stw	zero,0(r2)
 20282ac:	e0bffe17 	ldw	r2,-8(fp)
 20282b0:	10800017 	ldw	r2,0(r2)
 20282b4:	1000041e 	bne	r2,zero,20282c8 <putq+0x40>
 20282b8:	e0bffe17 	ldw	r2,-8(fp)
 20282bc:	e0ffff17 	ldw	r3,-4(fp)
 20282c0:	10c00015 	stw	r3,0(r2)
 20282c4:	00000406 	br	20282d8 <putq+0x50>
 20282c8:	e0bffe17 	ldw	r2,-8(fp)
 20282cc:	10800117 	ldw	r2,4(r2)
 20282d0:	e0ffff17 	ldw	r3,-4(fp)
 20282d4:	10c00015 	stw	r3,0(r2)
 20282d8:	e0bffe17 	ldw	r2,-8(fp)
 20282dc:	e0ffff17 	ldw	r3,-4(fp)
 20282e0:	10c00115 	stw	r3,4(r2)
 20282e4:	e0bffe17 	ldw	r2,-8(fp)
 20282e8:	10800217 	ldw	r2,8(r2)
 20282ec:	10c00044 	addi	r3,r2,1
 20282f0:	e0bffe17 	ldw	r2,-8(fp)
 20282f4:	10c00215 	stw	r3,8(r2)
 20282f8:	e0bffe17 	ldw	r2,-8(fp)
 20282fc:	10800217 	ldw	r2,8(r2)
 2028300:	e0fffe17 	ldw	r3,-8(fp)
 2028304:	18c00317 	ldw	r3,12(r3)
 2028308:	1880040e 	bge	r3,r2,202831c <putq+0x94>
 202830c:	e0bffe17 	ldw	r2,-8(fp)
 2028310:	10c00217 	ldw	r3,8(r2)
 2028314:	e0bffe17 	ldw	r2,-8(fp)
 2028318:	10c00315 	stw	r3,12(r2)
   QUEUE_CHECK(q);         /* make sure queue is not corrupted */
   EXIT_CRIT_SECTION(q);   /* restore int state */
 202831c:	20288580 	call	2028858 <irq_Unmask>
}
 2028320:	e037883a 	mov	sp,fp
 2028324:	dfc00117 	ldw	ra,4(sp)
 2028328:	df000017 	ldw	fp,0(sp)
 202832c:	dec00204 	addi	sp,sp,8
 2028330:	f800283a 	ret

02028334 <qdel>:
 * RETURNS: Return pointer to queue member if found, else NULL. 
 */

qp
qdel(queue * q, void * elt)
{
 2028334:	defffa04 	addi	sp,sp,-24
 2028338:	dfc00515 	stw	ra,20(sp)
 202833c:	df000415 	stw	fp,16(sp)
 2028340:	df000404 	addi	fp,sp,16
 2028344:	e13ffe15 	stw	r4,-8(fp)
 2028348:	e17fff15 	stw	r5,-4(fp)
   qp qptr;
   qp qlast;

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
 202834c:	20287fc0 	call	20287fc <irq_Mask>
   qptr = q->q_head;
 2028350:	e0bffe17 	ldw	r2,-8(fp)
 2028354:	10800017 	ldw	r2,0(r2)
 2028358:	e0bffc15 	stw	r2,-16(fp)
   qlast = NULL;
 202835c:	e03ffd15 	stw	zero,-12(fp)
   while (qptr)
 2028360:	00002b06 	br	2028410 <qdel+0xdc>
   {
      if (qptr == (qp)elt)
 2028364:	e0fffc17 	ldw	r3,-16(fp)
 2028368:	e0bfff17 	ldw	r2,-4(fp)
 202836c:	1880231e 	bne	r3,r2,20283fc <qdel+0xc8>
      {
         /* found our item; dequeue it */
         if (qlast)
 2028370:	e0bffd17 	ldw	r2,-12(fp)
 2028374:	10000526 	beq	r2,zero,202838c <qdel+0x58>
            qlast->qe_next = qptr->qe_next;
 2028378:	e0bffc17 	ldw	r2,-16(fp)
 202837c:	10c00017 	ldw	r3,0(r2)
 2028380:	e0bffd17 	ldw	r2,-12(fp)
 2028384:	10c00015 	stw	r3,0(r2)
 2028388:	00000406 	br	202839c <qdel+0x68>
         else     /* item was at head of queqe */
            q->q_head = qptr->qe_next;
 202838c:	e0bffc17 	ldw	r2,-16(fp)
 2028390:	10c00017 	ldw	r3,0(r2)
 2028394:	e0bffe17 	ldw	r2,-8(fp)
 2028398:	10c00015 	stw	r3,0(r2)

         /* fix queue tail pointer if needed */
         if (q->q_tail == (qp)elt)
 202839c:	e0bffe17 	ldw	r2,-8(fp)
 20283a0:	10c00117 	ldw	r3,4(r2)
 20283a4:	e0bfff17 	ldw	r2,-4(fp)
 20283a8:	1880031e 	bne	r3,r2,20283b8 <qdel+0x84>
            q->q_tail = qlast;
 20283ac:	e0bffe17 	ldw	r2,-8(fp)
 20283b0:	e0fffd17 	ldw	r3,-12(fp)
 20283b4:	10c00115 	stw	r3,4(r2)

         /* fix queue counters */
         q->q_len--;
 20283b8:	e0bffe17 	ldw	r2,-8(fp)
 20283bc:	10800217 	ldw	r2,8(r2)
 20283c0:	10ffffc4 	addi	r3,r2,-1
 20283c4:	e0bffe17 	ldw	r2,-8(fp)
 20283c8:	10c00215 	stw	r3,8(r2)
         if (q->q_len < q->q_min)
 20283cc:	e0bffe17 	ldw	r2,-8(fp)
 20283d0:	10c00217 	ldw	r3,8(r2)
 20283d4:	e0bffe17 	ldw	r2,-8(fp)
 20283d8:	10800417 	ldw	r2,16(r2)
 20283dc:	1880040e 	bge	r3,r2,20283f0 <qdel+0xbc>
            q->q_min = q->q_len;
 20283e0:	e0bffe17 	ldw	r2,-8(fp)
 20283e4:	10c00217 	ldw	r3,8(r2)
 20283e8:	e0bffe17 	ldw	r2,-8(fp)
 20283ec:	10c00415 	stw	r3,16(r2)
         EXIT_CRIT_SECTION(q);   /* restore int state */
 20283f0:	20288580 	call	2028858 <irq_Unmask>
         return (qp)elt;   /* success exit point */
 20283f4:	e0bfff17 	ldw	r2,-4(fp)
 20283f8:	00000906 	br	2028420 <qdel+0xec>
      }
      qlast = qptr;
 20283fc:	e0bffc17 	ldw	r2,-16(fp)
 2028400:	e0bffd15 	stw	r2,-12(fp)
      qptr = qptr->qe_next;
 2028404:	e0bffc17 	ldw	r2,-16(fp)
 2028408:	10800017 	ldw	r2,0(r2)
 202840c:	e0bffc15 	stw	r2,-16(fp)

   /* search queue for element passed */
   ENTER_CRIT_SECTION(q);
   qptr = q->q_head;
   qlast = NULL;
   while (qptr)
 2028410:	e0bffc17 	ldw	r2,-16(fp)
 2028414:	103fd31e 	bne	r2,zero,2028364 <qdel+0x30>
         return (qp)elt;   /* success exit point */
      }
      qlast = qptr;
      qptr = qptr->qe_next;
   }
   EXIT_CRIT_SECTION(q);   /* restore int state */
 2028418:	20288580 	call	2028858 <irq_Unmask>
   return NULL;   /* item not found in queue */
 202841c:	0005883a 	mov	r2,zero
}
 2028420:	e037883a 	mov	sp,fp
 2028424:	dfc00117 	ldw	ra,4(sp)
 2028428:	df000017 	ldw	fp,0(sp)
 202842c:	dec00204 	addi	sp,sp,8
 2028430:	f800283a 	ret

02028434 <asm_cksum>:
      .text

      .global	  asm_cksum

asm_cksum:
      mov   r2, zero		       /* accumulator = 0 */
 2028434:	0005883a 	mov	r2,zero
      ble   r5, zero, done	       /* count <= 0 ? */
 2028438:	0140620e 	bge	zero,r5,20285c4 <done>

      mov   r6, zero		       /* carry accumulator */
 202843c:	000d883a 	mov	r6,zero

      andi  r3, r4, 2		       /* ptr 32-bit aligned? */
 2028440:	20c0008c 	andi	r3,r4,2
      beq   r3, zero, asm1
 2028444:	18000326 	beq	r3,zero,2028454 <asm1>
      ldhu  r2, (r4)		       /* no - process first 16-bits */
 2028448:	2080000b 	ldhu	r2,0(r4)
      addi  r4, r4, 2
 202844c:	21000084 	addi	r4,r4,2
      subi  r5, r5, 1
 2028450:	297fffc4 	addi	r5,r5,-1

02028454 <asm1>:
 2028454:	02c080f4 	movhi	r11,515
/*
 * adjust ptr by ((count/2) mod 16) * 4 bytes
 * jump to location: loop0 - (count/2 mod 16) * 4 instructions
 */
asm1:
      movia r11, loop0
 2028458:	5ae16004 	addi	r11,r11,-31360
      andi  r9, r5, 1		       /* r9 = last halfword flag */
 202845c:	2a40004c 	andi	r9,r5,1
      srai  r5, r5, 1		       /* count = number of words */
 2028460:	280bd07a 	srai	r5,r5,1
      andi  r10, r5, 0xf	       /* modulo 16 */
 2028464:	2a8003cc 	andi	r10,r5,15
      slli  r10, r10, 2		       /*      * 4 bytes per word */
 2028468:	501490ba 	slli	r10,r10,2
      add   r4, r10, r4		       /* adjust ptr */
 202846c:	5109883a 	add	r4,r10,r4
      slli  r10, r10, 2		       /*      * 4 instructions per 4 bytes */
 2028470:	501490ba 	slli	r10,r10,2
      sub   r11, r11, r10
 2028474:	5a97c83a 	sub	r11,r11,r10
      jmp   r11
 2028478:	5800683a 	jmp	r11

0202847c <loop>:
      
loop:
      addi  r4, r4, 64		       /* increment data pointer */
 202847c:	21001004 	addi	r4,r4,64

      ldw   r7, -64(r4)
 2028480:	21fff017 	ldw	r7,-64(r4)
      add   r2, r7, r2
 2028484:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028488:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202848c:	418d883a 	add	r6,r8,r6

      ldw   r7, -60(r4)
 2028490:	21fff117 	ldw	r7,-60(r4)
      add   r2, r7, r2
 2028494:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028498:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202849c:	418d883a 	add	r6,r8,r6

      ldw   r7, -56(r4)
 20284a0:	21fff217 	ldw	r7,-56(r4)
      add   r2, r7, r2
 20284a4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 20284a8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 20284ac:	418d883a 	add	r6,r8,r6

      ldw   r7, -52(r4)
 20284b0:	21fff317 	ldw	r7,-52(r4)
      add   r2, r7, r2
 20284b4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 20284b8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 20284bc:	418d883a 	add	r6,r8,r6

      ldw   r7, -48(r4)
 20284c0:	21fff417 	ldw	r7,-48(r4)
      add   r2, r7, r2
 20284c4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 20284c8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 20284cc:	418d883a 	add	r6,r8,r6

      ldw   r7, -44(r4)
 20284d0:	21fff517 	ldw	r7,-44(r4)
      add   r2, r7, r2
 20284d4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 20284d8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 20284dc:	418d883a 	add	r6,r8,r6

      ldw   r7, -40(r4)
 20284e0:	21fff617 	ldw	r7,-40(r4)
      add   r2, r7, r2
 20284e4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 20284e8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 20284ec:	418d883a 	add	r6,r8,r6

      ldw   r7, -36(r4)
 20284f0:	21fff717 	ldw	r7,-36(r4)
      add   r2, r7, r2
 20284f4:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 20284f8:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 20284fc:	418d883a 	add	r6,r8,r6

      ldw   r7, -32(r4)
 2028500:	21fff817 	ldw	r7,-32(r4)
      add   r2, r7, r2
 2028504:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028508:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202850c:	418d883a 	add	r6,r8,r6

      ldw   r7, -28(r4)
 2028510:	21fff917 	ldw	r7,-28(r4)
      add   r2, r7, r2
 2028514:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028518:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202851c:	418d883a 	add	r6,r8,r6

      ldw   r7, -24(r4)
 2028520:	21fffa17 	ldw	r7,-24(r4)
      add   r2, r7, r2
 2028524:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028528:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202852c:	418d883a 	add	r6,r8,r6

      ldw   r7, -20(r4)
 2028530:	21fffb17 	ldw	r7,-20(r4)
      add   r2, r7, r2
 2028534:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028538:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202853c:	418d883a 	add	r6,r8,r6

      ldw   r7, -16(r4)
 2028540:	21fffc17 	ldw	r7,-16(r4)
      add   r2, r7, r2
 2028544:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028548:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202854c:	418d883a 	add	r6,r8,r6

      ldw   r7, -12(r4)
 2028550:	21fffd17 	ldw	r7,-12(r4)
      add   r2, r7, r2
 2028554:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028558:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202855c:	418d883a 	add	r6,r8,r6

      ldw   r7, -8(r4)
 2028560:	21fffe17 	ldw	r7,-8(r4)
      add   r2, r7, r2
 2028564:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028568:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202856c:	418d883a 	add	r6,r8,r6

      ldw   r7, -4(r4)
 2028570:	21ffff17 	ldw	r7,-4(r4)
      add   r2, r7, r2
 2028574:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028578:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 202857c:	418d883a 	add	r6,r8,r6

02028580 <loop0>:
loop0:
      subi  r5, r5, 16
 2028580:	297ffc04 	addi	r5,r5,-16
      bge   r5, zero, loop
 2028584:	283fbd0e 	bge	r5,zero,202847c <loop>
/*
 * process last halfword (if any)
 */
      beq   r9, zero, fold
 2028588:	48000426 	beq	r9,zero,202859c <fold>
      ldhu  r7, 0(r4)
 202858c:	21c0000b 	ldhu	r7,0(r4)
      add   r2, r7, r2
 2028590:	3885883a 	add	r2,r7,r2
      cmpltu r8, r2, r7
 2028594:	11d1803a 	cmpltu	r8,r2,r7
      add   r6, r8, r6
 2028598:	418d883a 	add	r6,r8,r6

0202859c <fold>:
      
fold:
      srli  r7, r2, 16
 202859c:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 20285a0:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add the upper and lower halfwords */
 20285a4:	3885883a 	add	r2,r7,r2
      add   r2, r6, r2		    /* add the carries */
 20285a8:	3085883a 	add	r2,r6,r2
/* the accumulator is 18 bits */
      srli  r7, r2, 16
 20285ac:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 20285b0:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add 2 carry bits to lower halfword */
 20285b4:	3885883a 	add	r2,r7,r2
/* the accumulator is 17 bits */
      srli  r7, r2, 16
 20285b8:	100ed43a 	srli	r7,r2,16
      andi  r2, r2, 0xffff
 20285bc:	10bfffcc 	andi	r2,r2,65535
      add   r2, r7, r2		    /* add carry to lower halfword */
 20285c0:	3885883a 	add	r2,r7,r2

020285c4 <done>:

done:
      ret			    		/* r2 = 16-bit checksum */
 20285c4:	f800283a 	ret

020285c8 <dtrap>:
void irq_Unmask(void);

/* dtrap() - function to trap to debugger */
void
dtrap(void)
{
 20285c8:	defffe04 	addi	sp,sp,-8
 20285cc:	dfc00115 	stw	ra,4(sp)
 20285d0:	df000015 	stw	fp,0(sp)
 20285d4:	d839883a 	mov	fp,sp
   printf("dtrap - needs breakpoint\n");
 20285d8:	01008174 	movhi	r4,517
 20285dc:	213c5604 	addi	r4,r4,-3752
 20285e0:	2006cb40 	call	2006cb4 <puts>
}
 20285e4:	e037883a 	mov	sp,fp
 20285e8:	dfc00117 	ldw	ra,4(sp)
 20285ec:	df000017 	ldw	fp,0(sp)
 20285f0:	dec00204 	addi	sp,sp,8
 20285f4:	f800283a 	ret

020285f8 <kbhit>:

int
kbhit()
{
 20285f8:	defffd04 	addi	sp,sp,-12
 20285fc:	dfc00215 	stw	ra,8(sp)
 2028600:	df000115 	stw	fp,4(sp)
 2028604:	df000104 	addi	fp,sp,4
   static int kbd_init = 0;
   int   kb;
   
   if (!kbd_init)
 2028608:	d0a09717 	ldw	r2,-32164(gp)
 202860c:	10000b1e 	bne	r2,zero,202863c <kbhit+0x44>
      /* we really should read the flags, OR in O_NONBLOCK, and write
       * the flags back to STDIN, but the NIOS-II/HAL implementation
       * will only let us modify O_NONBLOCK and O_APPEND, so we'll
       * just write the new flag value.
       */
      if (fcntl(STDIN_FILENO, F_SETFL, O_NONBLOCK) != 0)
 2028610:	0009883a 	mov	r4,zero
 2028614:	01400104 	movi	r5,4
 2028618:	01900004 	movi	r6,16384
 202861c:	203dc040 	call	203dc04 <fcntl>
 2028620:	10000426 	beq	r2,zero,2028634 <kbhit+0x3c>
      {
         printf("F_SETFL failed.\n");
 2028624:	01008174 	movhi	r4,517
 2028628:	213c5d04 	addi	r4,r4,-3724
 202862c:	2006cb40 	call	2006cb4 <puts>
         dtrap();
 2028630:	20285c80 	call	20285c8 <dtrap>
      }
      kbd_init = 1; 
 2028634:	00800044 	movi	r2,1
 2028638:	d0a09715 	stw	r2,-32164(gp)
   }

   /* we have to do a read to see if there is a character available.
    * we save the character, if there was one, to be read later. */
   if (kb_last == EOF)
 202863c:	d0a04017 	ldw	r2,-32512(gp)
 2028640:	10bfffd8 	cmpnei	r2,r2,-1
 2028644:	10000d1e 	bne	r2,zero,202867c <kbhit+0x84>
   {
      kb = getchar();
 2028648:	00808174 	movhi	r2,517
 202864c:	10903604 	addi	r2,r2,16600
 2028650:	10800017 	ldw	r2,0(r2)
 2028654:	10800117 	ldw	r2,4(r2)
 2028658:	1009883a 	mov	r4,r2
 202865c:	2005c580 	call	2005c58 <getc>
 2028660:	e0bfff15 	stw	r2,-4(fp)
      if (kb < 0)       /* any error means no character present */
 2028664:	e0bfff17 	ldw	r2,-4(fp)
 2028668:	1000020e 	bge	r2,zero,2028674 <kbhit+0x7c>
         return (FALSE);
 202866c:	0005883a 	mov	r2,zero
 2028670:	00000306 	br	2028680 <kbhit+0x88>
         
      /* there was a character, and we read it. */
      kb_last = kb;
 2028674:	e0bfff17 	ldw	r2,-4(fp)
 2028678:	d0a04015 	stw	r2,-32512(gp)
   }

   return (TRUE);
 202867c:	00800044 	movi	r2,1
}
 2028680:	e037883a 	mov	sp,fp
 2028684:	dfc00117 	ldw	ra,4(sp)
 2028688:	df000017 	ldw	fp,0(sp)
 202868c:	dec00204 	addi	sp,sp,8
 2028690:	f800283a 	ret

02028694 <getch>:

int 
getch()
{
 2028694:	defffd04 	addi	sp,sp,-12
 2028698:	dfc00215 	stw	ra,8(sp)
 202869c:	df000115 	stw	fp,4(sp)
 20286a0:	df000104 	addi	fp,sp,4
int chr;

   if(kb_last != EOF)
 20286a4:	d0a04017 	ldw	r2,-32512(gp)
 20286a8:	10bfffe0 	cmpeqi	r2,r2,-1
 20286ac:	1000051e 	bne	r2,zero,20286c4 <getch+0x30>
   {
      chr = kb_last;
 20286b0:	d0a04017 	ldw	r2,-32512(gp)
 20286b4:	e0bfff15 	stw	r2,-4(fp)
      kb_last = EOF;
 20286b8:	00bfffc4 	movi	r2,-1
 20286bc:	d0a04015 	stw	r2,-32512(gp)
 20286c0:	00000706 	br	20286e0 <getch+0x4c>
   }
   else
      chr = getchar();
 20286c4:	00808174 	movhi	r2,517
 20286c8:	10903604 	addi	r2,r2,16600
 20286cc:	10800017 	ldw	r2,0(r2)
 20286d0:	10800117 	ldw	r2,4(r2)
 20286d4:	1009883a 	mov	r4,r2
 20286d8:	2005c580 	call	2005c58 <getc>
 20286dc:	e0bfff15 	stw	r2,-4(fp)

   return chr;
 20286e0:	e0bfff17 	ldw	r2,-4(fp)
}
 20286e4:	e037883a 	mov	sp,fp
 20286e8:	dfc00117 	ldw	ra,4(sp)
 20286ec:	df000017 	ldw	fp,0(sp)
 20286f0:	dec00204 	addi	sp,sp,8
 20286f4:	f800283a 	ret

020286f8 <clock_init>:
int OS_TPS;
int cticks_factor;
int cticks_initialized = 0;

void clock_init(void)
{
 20286f8:	deffff04 	addi	sp,sp,-4
 20286fc:	df000015 	stw	fp,0(sp)
 2028700:	d839883a 	mov	fp,sp
   OS_TPS = OS_TICKS_PER_SEC;
 2028704:	00801904 	movi	r2,100
 2028708:	d0a09915 	stw	r2,-32156(gp)
   cticks_factor = 0;
 202870c:	d0209815 	stw	zero,-32160(gp)
   cticks = 0;
 2028710:	00808174 	movhi	r2,517
 2028714:	1090c904 	addi	r2,r2,17188
 2028718:	10000015 	stw	zero,0(r2)
   cticks_initialized = 1;
 202871c:	00800044 	movi	r2,1
 2028720:	d0a09415 	stw	r2,-32176(gp)
}
 2028724:	e037883a 	mov	sp,fp
 2028728:	df000017 	ldw	fp,0(sp)
 202872c:	dec00104 	addi	sp,sp,4
 2028730:	f800283a 	ret

02028734 <clock_c>:

/* undo effects of clock_init (i.e. restore ISR vector) 
 * NO OP since using RTOS's timer.
 */
void clock_c(void)
{
 2028734:	deffff04 	addi	sp,sp,-4
 2028738:	df000015 	stw	fp,0(sp)
 202873c:	d839883a 	mov	fp,sp
   /* null */ ;
}
 2028740:	e037883a 	mov	sp,fp
 2028744:	df000017 	ldw	fp,0(sp)
 2028748:	dec00104 	addi	sp,sp,4
 202874c:	f800283a 	ret

02028750 <cticks_hook>:
 * Use the uCOS-II/Altera HAL BSP's timer and scale cticks as per TPS.
 */

void
cticks_hook(void)
{
 2028750:	defffe04 	addi	sp,sp,-8
 2028754:	dfc00115 	stw	ra,4(sp)
 2028758:	df000015 	stw	fp,0(sp)
 202875c:	d839883a 	mov	fp,sp
   if (cticks_initialized) 
 2028760:	d0a09417 	ldw	r2,-32176(gp)
 2028764:	10002026 	beq	r2,zero,20287e8 <cticks_hook+0x98>
   {
      cticks_factor += TPS;
 2028768:	d0a09817 	ldw	r2,-32160(gp)
 202876c:	1009883a 	mov	r4,r2
 2028770:	20143580 	call	2014358 <__floatsidf>
 2028774:	100b883a 	mov	r5,r2
 2028778:	180d883a 	mov	r6,r3
 202877c:	2809883a 	mov	r4,r5
 2028780:	300b883a 	mov	r5,r6
 2028784:	000d883a 	mov	r6,zero
 2028788:	01d01674 	movhi	r7,16473
 202878c:	2013bd40 	call	2013bd4 <__adddf3>
 2028790:	1009883a 	mov	r4,r2
 2028794:	180b883a 	mov	r5,r3
 2028798:	2005883a 	mov	r2,r4
 202879c:	2807883a 	mov	r3,r5
 20287a0:	1009883a 	mov	r4,r2
 20287a4:	180b883a 	mov	r5,r3
 20287a8:	201442c0 	call	201442c <__fixdfsi>
 20287ac:	d0a09815 	stw	r2,-32160(gp)
      if (cticks_factor >= OS_TPS)
 20287b0:	d0e09817 	ldw	r3,-32160(gp)
 20287b4:	d0a09917 	ldw	r2,-32156(gp)
 20287b8:	18800b16 	blt	r3,r2,20287e8 <cticks_hook+0x98>
      {
         cticks++;
 20287bc:	00808174 	movhi	r2,517
 20287c0:	1090c904 	addi	r2,r2,17188
 20287c4:	10800017 	ldw	r2,0(r2)
 20287c8:	10c00044 	addi	r3,r2,1
 20287cc:	00808174 	movhi	r2,517
 20287d0:	1090c904 	addi	r2,r2,17188
 20287d4:	10c00015 	stw	r3,0(r2)
         cticks_factor -= OS_TPS;
 20287d8:	d0e09817 	ldw	r3,-32160(gp)
 20287dc:	d0a09917 	ldw	r2,-32156(gp)
 20287e0:	1885c83a 	sub	r2,r3,r2
 20287e4:	d0a09815 	stw	r2,-32160(gp)
#ifdef USE_LCD
         update_display();
#endif
      }
   }
}
 20287e8:	e037883a 	mov	sp,fp
 20287ec:	dfc00117 	ldw	ra,4(sp)
 20287f0:	df000017 	ldw	fp,0(sp)
 20287f4:	dec00204 	addi	sp,sp,8
 20287f8:	f800283a 	ret

020287fc <irq_Mask>:
 * ENTER_CRIT_SECTION() and enable them in EXIT_CRIT_SECTION()
 * because calls to ENTER_CRIT_SECTION() can be nested."
 */
void
irq_Mask(void)
{
 20287fc:	defffd04 	addi	sp,sp,-12
 2028800:	df000215 	stw	fp,8(sp)
 2028804:	df000204 	addi	fp,sp,8
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2028808:	0005303a 	rdctl	r2,status
 202880c:	e0bfff15 	stw	r2,-4(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2028810:	e0ffff17 	ldw	r3,-4(fp)
 2028814:	00bfff84 	movi	r2,-2
 2028818:	1884703a 	and	r2,r3,r2
 202881c:	1001703a 	wrctl	status,r2
  
  return context;
 2028820:	e0bfff17 	ldw	r2,-4(fp)
   alt_irq_context  local_cpu_statusreg;

   local_cpu_statusreg = alt_irq_disable_all();
 2028824:	e0bffe15 	stw	r2,-8(fp)
	
   if (++irq_level == 1)
 2028828:	d0a09517 	ldw	r2,-32172(gp)
 202882c:	10800044 	addi	r2,r2,1
 2028830:	d0a09515 	stw	r2,-32172(gp)
 2028834:	d0a09517 	ldw	r2,-32172(gp)
 2028838:	10800058 	cmpnei	r2,r2,1
 202883c:	1000021e 	bne	r2,zero,2028848 <irq_Mask+0x4c>
   {
      cpu_statusreg = local_cpu_statusreg;
 2028840:	e0bffe17 	ldw	r2,-8(fp)
 2028844:	d0a09615 	stw	r2,-32168(gp)
   }
}
 2028848:	e037883a 	mov	sp,fp
 202884c:	df000017 	ldw	fp,0(sp)
 2028850:	dec00104 	addi	sp,sp,4
 2028854:	f800283a 	ret

02028858 <irq_Unmask>:


/* Re-Enable Interrupts */
void
irq_Unmask(void)
{
 2028858:	defffe04 	addi	sp,sp,-8
 202885c:	df000115 	stw	fp,4(sp)
 2028860:	df000104 	addi	fp,sp,4
   if (--irq_level == 0)
 2028864:	d0a09517 	ldw	r2,-32172(gp)
 2028868:	10bfffc4 	addi	r2,r2,-1
 202886c:	d0a09515 	stw	r2,-32172(gp)
 2028870:	d0a09517 	ldw	r2,-32172(gp)
 2028874:	1000041e 	bne	r2,zero,2028888 <irq_Unmask+0x30>
   {
      alt_irq_enable_all(cpu_statusreg);
 2028878:	d0a09617 	ldw	r2,-32168(gp)
 202887c:	e0bfff15 	stw	r2,-4(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2028880:	e0bfff17 	ldw	r2,-4(fp)
 2028884:	1001703a 	wrctl	status,r2
   }
}
 2028888:	e037883a 	mov	sp,fp
 202888c:	df000017 	ldw	fp,0(sp)
 2028890:	dec00104 	addi	sp,sp,4
 2028894:	f800283a 	ret

02028898 <LOCK_NET_RESOURCE>:
extern void irq_Mask(void);
extern void irq_Unmask(void);

void
LOCK_NET_RESOURCE(int resid)
{
 2028898:	defffb04 	addi	sp,sp,-20
 202889c:	dfc00415 	stw	ra,16(sp)
 20288a0:	df000315 	stw	fp,12(sp)
 20288a4:	df000304 	addi	fp,sp,12
 20288a8:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 20288ac:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 20288b0:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 20288b4:	e0bfff17 	ldw	r2,-4(fp)
 20288b8:	10002216 	blt	r2,zero,2028944 <LOCK_NET_RESOURCE+0xac>
 20288bc:	e0bfff17 	ldw	r2,-4(fp)
 20288c0:	10800408 	cmpgei	r2,r2,16
 20288c4:	10001f1e 	bne	r2,zero,2028944 <LOCK_NET_RESOURCE+0xac>
   {
      do
      {
         OSSemPend(resid_semaphore[resid], 0, &error);
 20288c8:	00c09934 	movhi	r3,612
 20288cc:	18f6ac04 	addi	r3,r3,-9552
 20288d0:	e0bfff17 	ldw	r2,-4(fp)
 20288d4:	1085883a 	add	r2,r2,r2
 20288d8:	1085883a 	add	r2,r2,r2
 20288dc:	1885883a 	add	r2,r3,r2
 20288e0:	10c00017 	ldw	r3,0(r2)
 20288e4:	e0bffe04 	addi	r2,fp,-8
 20288e8:	1809883a 	mov	r4,r3
 20288ec:	000b883a 	mov	r5,zero
 20288f0:	100d883a 	mov	r6,r2
 20288f4:	201c0180 	call	201c018 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 20288f8:	e0bffe03 	ldbu	r2,-8(fp)
 20288fc:	10803fcc 	andi	r2,r2,255
 2028900:	10800298 	cmpnei	r2,r2,10
 2028904:	10000a1e 	bne	r2,zero,2028930 <LOCK_NET_RESOURCE+0x98>
 2028908:	e0bffd17 	ldw	r2,-12(fp)
 202890c:	10800044 	addi	r2,r2,1
 2028910:	e0bffd15 	stw	r2,-12(fp)
 2028914:	e0bffd17 	ldw	r2,-12(fp)
 2028918:	1080fa50 	cmplti	r2,r2,1001
 202891c:	1000041e 	bne	r2,zero,2028930 <LOCK_NET_RESOURCE+0x98>
         {
            panic("lock NET");   /* fatal */
 2028920:	01008174 	movhi	r4,517
 2028924:	213c6104 	addi	r4,r4,-3708
 2028928:	2026bf80 	call	2026bf8 <panic>
 202892c:	00000606 	br	2028948 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
 2028930:	e0bffe03 	ldbu	r2,-8(fp)
 2028934:	10803fcc 	andi	r2,r2,255
 2028938:	108002a0 	cmpeqi	r2,r2,10
 202893c:	103fe21e 	bne	r2,zero,20288c8 <LOCK_NET_RESOURCE+0x30>
LOCK_NET_RESOURCE(int resid)
{
   INT8U error = 0;
   int   errct = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
 2028940:	00000106 	br	2028948 <LOCK_NET_RESOURCE+0xb0>
            return;
         }
      } while (error == 10);
   }
   else
      dtrap();
 2028944:	20285c80 	call	20285c8 <dtrap>
}
 2028948:	e037883a 	mov	sp,fp
 202894c:	dfc00117 	ldw	ra,4(sp)
 2028950:	df000017 	ldw	fp,0(sp)
 2028954:	dec00204 	addi	sp,sp,8
 2028958:	f800283a 	ret

0202895c <UNLOCK_NET_RESOURCE>:

void
UNLOCK_NET_RESOURCE(int resid)
{
 202895c:	defffc04 	addi	sp,sp,-16
 2028960:	dfc00315 	stw	ra,12(sp)
 2028964:	df000215 	stw	fp,8(sp)
 2028968:	df000204 	addi	fp,sp,8
 202896c:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 2028970:	e03ffe05 	stb	zero,-8(fp)

   if ((0 <= resid) && (resid <= MAX_RESID))
 2028974:	e0bfff17 	ldw	r2,-4(fp)
 2028978:	10001316 	blt	r2,zero,20289c8 <UNLOCK_NET_RESOURCE+0x6c>
 202897c:	e0bfff17 	ldw	r2,-4(fp)
 2028980:	10800408 	cmpgei	r2,r2,16
 2028984:	1000101e 	bne	r2,zero,20289c8 <UNLOCK_NET_RESOURCE+0x6c>
   {
      error = OSSemPost(resid_semaphore[resid]);
 2028988:	00c09934 	movhi	r3,612
 202898c:	18f6ac04 	addi	r3,r3,-9552
 2028990:	e0bfff17 	ldw	r2,-4(fp)
 2028994:	1085883a 	add	r2,r2,r2
 2028998:	1085883a 	add	r2,r2,r2
 202899c:	1885883a 	add	r2,r3,r2
 20289a0:	10800017 	ldw	r2,0(r2)
 20289a4:	1009883a 	mov	r4,r2
 20289a8:	201c3f80 	call	201c3f8 <OSSemPost>
 20289ac:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 20289b0:	e0bffe03 	ldbu	r2,-8(fp)
 20289b4:	10000526 	beq	r2,zero,20289cc <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
 20289b8:	01008174 	movhi	r4,517
 20289bc:	213c6404 	addi	r4,r4,-3696
 20289c0:	2026bf80 	call	2026bf8 <panic>
   INT8U error = 0;

   if ((0 <= resid) && (resid <= MAX_RESID))
   {
      error = OSSemPost(resid_semaphore[resid]);
      if (error != OS_NO_ERR)
 20289c4:	00000106 	br	20289cc <UNLOCK_NET_RESOURCE+0x70>
      {
         panic("unlock NET");
      }
   }
   else
      dtrap();
 20289c8:	20285c80 	call	20285c8 <dtrap>
}
 20289cc:	e037883a 	mov	sp,fp
 20289d0:	dfc00117 	ldw	ra,4(sp)
 20289d4:	df000017 	ldw	fp,0(sp)
 20289d8:	dec00204 	addi	sp,sp,8
 20289dc:	f800283a 	ret

020289e0 <TK_NEWTASK>:
extern long     nettick_wakes;


int
TK_NEWTASK(struct inet_taskinfo * nettask)
{
 20289e0:	deffee04 	addi	sp,sp,-72
 20289e4:	dfc01115 	stw	ra,68(sp)
 20289e8:	df001015 	stw	fp,64(sp)
 20289ec:	df001004 	addi	fp,sp,64
 20289f0:	e13fff15 	stw	r4,-4(fp)
   INT8U    error;
   OS_STK * stack;

   stack = (OS_STK*)npalloc(nettask->stacksize);
 20289f4:	e0bfff17 	ldw	r2,-4(fp)
 20289f8:	10800417 	ldw	r2,16(r2)
 20289fc:	1009883a 	mov	r4,r2
 2028a00:	20290400 	call	2029040 <npalloc>
 2028a04:	e0bff515 	stw	r2,-44(fp)
   if(!stack)
 2028a08:	e0bff517 	ldw	r2,-44(fp)
 2028a0c:	1000031e 	bne	r2,zero,2028a1c <TK_NEWTASK+0x3c>
      panic("stack alloc");
 2028a10:	01008174 	movhi	r4,517
 2028a14:	213c6704 	addi	r4,r4,-3684
 2028a18:	2026bf80 	call	2026bf8 <panic>

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
      nettask->entry,
 2028a1c:	e0bfff17 	ldw	r2,-4(fp)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 2028a20:	11000217 	ldw	r4,8(r2)
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
 2028a24:	e0bfff17 	ldw	r2,-4(fp)
 2028a28:	10800417 	ldw	r2,16(r2)
 2028a2c:	1004d0ba 	srli	r2,r2,2
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 2028a30:	10bfffc4 	addi	r2,r2,-1
 2028a34:	1085883a 	add	r2,r2,r2
 2028a38:	1085883a 	add	r2,r2,r2
 2028a3c:	e0fff517 	ldw	r3,-44(fp)
 2028a40:	1887883a 	add	r3,r3,r2
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
 2028a44:	e0bfff17 	ldw	r2,-4(fp)
 2028a48:	10800317 	ldw	r2,12(r2)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 2028a4c:	10803fcc 	andi	r2,r2,255
      nettask->entry,
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
 2028a50:	e17fff17 	ldw	r5,-4(fp)
 2028a54:	29400317 	ldw	r5,12(r5)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 2028a58:	29bfffcc 	andi	r6,r5,65535
      NULL,
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority,
      nettask->priority,
      stack, 
      (INT32U)nettask->stacksize / sizeof(OS_STK),
 2028a5c:	e17fff17 	ldw	r5,-4(fp)
 2028a60:	29400417 	ldw	r5,16(r5)
   stack = (OS_STK*)npalloc(nettask->stacksize);
   if(!stack)
      panic("stack alloc");

#if OS_TASK_CREATE_EXT_EN > 0
   error = OSTaskCreateExt(
 2028a64:	280ad0ba 	srli	r5,r5,2
 2028a68:	d9800015 	stw	r6,0(sp)
 2028a6c:	e1bff517 	ldw	r6,-44(fp)
 2028a70:	d9800115 	stw	r6,4(sp)
 2028a74:	d9400215 	stw	r5,8(sp)
 2028a78:	d8000315 	stw	zero,12(sp)
 2028a7c:	014000c4 	movi	r5,3
 2028a80:	d9400415 	stw	r5,16(sp)
 2028a84:	000b883a 	mov	r5,zero
 2028a88:	180d883a 	mov	r6,r3
 2028a8c:	100f883a 	mov	r7,r2
 2028a90:	201ce040 	call	201ce04 <OSTaskCreateExt>
 2028a94:	e0bff605 	stb	r2,-40(fp)
      stack + (nettask->stacksize/sizeof(OS_STK)) - 1,
      nettask->priority);
#endif
   /* If we go here, then there's another task using our priority */
   /* Tell the user and exit with an error */
   if (error == OS_PRIO_EXIST)
 2028a98:	e0bff603 	ldbu	r2,-40(fp)
 2028a9c:	10803fcc 	andi	r2,r2,255
 2028aa0:	10800a18 	cmpnei	r2,r2,40
 2028aa4:	10001a1e 	bne	r2,zero,2028b10 <TK_NEWTASK+0x130>
   { 
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
 2028aa8:	e0bfff17 	ldw	r2,-4(fp)
 2028aac:	10800317 	ldw	r2,12(r2)
 2028ab0:	11003fcc 	andi	r4,r2,255
 2028ab4:	e0fff684 	addi	r3,fp,-38
 2028ab8:	e0bff644 	addi	r2,fp,-39
 2028abc:	180b883a 	mov	r5,r3
 2028ac0:	100d883a 	mov	r6,r2
 2028ac4:	201d52c0 	call	201d52c <OSTaskNameGet>
     curr_task[OS_TASK_NAME_SIZE-1]=0;
 2028ac8:	e03ffe45 	stb	zero,-7(fp)
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
 2028acc:	e0bfff17 	ldw	r2,-4(fp)
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
     curr_task[OS_TASK_NAME_SIZE-1]=0;
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 2028ad0:	11400117 	ldw	r5,4(r2)
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
 2028ad4:	e0bfff17 	ldw	r2,-4(fp)
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
     curr_task[OS_TASK_NAME_SIZE-1]=0;
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 2028ad8:	10c00317 	ldw	r3,12(r2)
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
 2028adc:	e0bfff17 	ldw	r2,-4(fp)
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
     curr_task[OS_TASK_NAME_SIZE-1]=0;
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 2028ae0:	11000317 	ldw	r4,12(r2)
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
 2028ae4:	e0bff684 	addi	r2,fp,-38
     char curr_task[OS_TASK_NAME_SIZE];
     INT8U err;
     OSTaskNameGet(nettask->priority, curr_task, &err);
     curr_task[OS_TASK_NAME_SIZE-1]=0;
    
     printf("Priority requested for task \"%s\" (Prio:%d) conflicts with "\
 2028ae8:	d9000015 	stw	r4,0(sp)
 2028aec:	01008174 	movhi	r4,517
 2028af0:	213c6a04 	addi	r4,r4,-3672
 2028af4:	180d883a 	mov	r6,r3
 2028af8:	100f883a 	mov	r7,r2
 2028afc:	2006a240 	call	2006a24 <printf>
            "already running task \"%s\" (Prio: %d)\n",
             nettask->name, nettask->priority, curr_task, nettask->priority);
             
     printf("You may wish to check your task priority settings in "\
 2028b00:	01008174 	movhi	r4,517
 2028b04:	213c8204 	addi	r4,r4,-3576
 2028b08:	2006cb40 	call	2006cb4 <puts>
 2028b0c:	00002006 	br	2028b90 <TK_NEWTASK+0x1b0>
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
 2028b10:	e0bff603 	ldbu	r2,-40(fp)
 2028b14:	10803fcc 	andi	r2,r2,255
 2028b18:	10800a98 	cmpnei	r2,r2,42
 2028b1c:	10000e1e 	bne	r2,zero,2028b58 <TK_NEWTASK+0x178>
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
 2028b20:	e0bfff17 	ldw	r2,-4(fp)
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 2028b24:	10c00117 	ldw	r3,4(r2)
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
 2028b28:	e0bfff17 	ldw	r2,-4(fp)
            "\"<bsp path>\\iniche\\src\\h\\nios2\\ipport.h\" against "\
            "the priority settings in your application and recompile.\n\n");
   }
   else if (error == OS_PRIO_INVALID)
   {
     printf("Priority requested for task \"%s\" (Prio:%d) exceeds "\
 2028b2c:	10800317 	ldw	r2,12(r2)
 2028b30:	01008174 	movhi	r4,517
 2028b34:	213caa04 	addi	r4,r4,-3416
 2028b38:	180b883a 	mov	r5,r3
 2028b3c:	100d883a 	mov	r6,r2
 2028b40:	01c00504 	movi	r7,20
 2028b44:	2006a240 	call	2006a24 <printf>
            "available priority levels in the system (OS_LOWEST_PRIO = %d)\n\n",
             nettask->name, nettask->priority, OS_LOWEST_PRIO);
             
     printf("Please modify the tasks priority level, or modify the "\
 2028b48:	01008174 	movhi	r4,517
 2028b4c:	213cc704 	addi	r4,r4,-3300
 2028b50:	2006cb40 	call	2006cb4 <puts>
 2028b54:	00000e06 	br	2028b90 <TK_NEWTASK+0x1b0>
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
 2028b58:	e0bff603 	ldbu	r2,-40(fp)
 2028b5c:	10803fcc 	andi	r2,r2,255
 2028b60:	10000b26 	beq	r2,zero,2028b90 <TK_NEWTASK+0x1b0>
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 2028b64:	e0bff603 	ldbu	r2,-40(fp)
 2028b68:	10c03fcc 	andi	r3,r2,255
             error, nettask->name);
 2028b6c:	e0bfff17 	ldw	r2,-4(fp)
            "\"Lowest assignable priority\" setting in the MicroC/OS-II "\
            "component\n");
   }
   else if (error != OS_NO_ERR)
   {                          /* All other errors are fatal */
      printf("Task create error /(MicroC/OS-II error code:%d/) on %s\n",
 2028b70:	10800117 	ldw	r2,4(r2)
 2028b74:	01008174 	movhi	r4,517
 2028b78:	213ce604 	addi	r4,r4,-3176
 2028b7c:	180b883a 	mov	r5,r3
 2028b80:	100d883a 	mov	r6,r2
 2028b84:	2006a240 	call	2006a24 <printf>
             error, nettask->name);
      return (-1);
 2028b88:	00bfffc4 	movi	r2,-1
 2028b8c:	00001b06 	br	2028bfc <TK_NEWTASK+0x21c>
   }

   /* Include the task name, so that uc/osII (os aware) debuggers can
    * display it.
    */
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);
 2028b90:	e0bfff17 	ldw	r2,-4(fp)
 2028b94:	10800317 	ldw	r2,12(r2)
 2028b98:	11003fcc 	andi	r4,r2,255
 2028b9c:	e0bfff17 	ldw	r2,-4(fp)
 2028ba0:	10c00117 	ldw	r3,4(r2)
 2028ba4:	e0bff604 	addi	r2,fp,-40
 2028ba8:	180b883a 	mov	r5,r3
 2028bac:	100d883a 	mov	r6,r2
 2028bb0:	201d6d40 	call	201d6d4 <OSTaskNameSet>

   nettask->stackbase = (char*)stack;
 2028bb4:	e0bfff17 	ldw	r2,-4(fp)
 2028bb8:	e0fff517 	ldw	r3,-44(fp)
 2028bbc:	10c00515 	stw	r3,20(r2)
   *nettask->tk_ptr = (INT8U)nettask->priority;  
 2028bc0:	e0bfff17 	ldw	r2,-4(fp)
 2028bc4:	10800017 	ldw	r2,0(r2)
 2028bc8:	e0ffff17 	ldw	r3,-4(fp)
 2028bcc:	18c00317 	ldw	r3,12(r3)
 2028bd0:	10c00005 	stb	r3,0(r2)

   printf("Created \"%s\" task (Prio: %d)\n",
         (char *)nettask->name, nettask->priority);
 2028bd4:	e0bfff17 	ldw	r2,-4(fp)
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);

   nettask->stackbase = (char*)stack;
   *nettask->tk_ptr = (INT8U)nettask->priority;  

   printf("Created \"%s\" task (Prio: %d)\n",
 2028bd8:	10c00117 	ldw	r3,4(r2)
         (char *)nettask->name, nettask->priority);
 2028bdc:	e0bfff17 	ldw	r2,-4(fp)
   OSTaskNameSet(nettask->priority, &nettask->name[0], &error);

   nettask->stackbase = (char*)stack;
   *nettask->tk_ptr = (INT8U)nettask->priority;  

   printf("Created \"%s\" task (Prio: %d)\n",
 2028be0:	10800317 	ldw	r2,12(r2)
 2028be4:	01008174 	movhi	r4,517
 2028be8:	213cf404 	addi	r4,r4,-3120
 2028bec:	180b883a 	mov	r5,r3
 2028bf0:	100d883a 	mov	r6,r2
 2028bf4:	2006a240 	call	2006a24 <printf>
         (char *)nettask->name, nettask->priority);

   return (0);
 2028bf8:	0005883a 	mov	r2,zero
}
 2028bfc:	e037883a 	mov	sp,fp
 2028c00:	dfc00117 	ldw	ra,4(sp)
 2028c04:	df000017 	ldw	fp,0(sp)
 2028c08:	dec00204 	addi	sp,sp,8
 2028c0c:	f800283a 	ret

02028c10 <wait_app_sem>:
 * event (e.g., configuration inputs from user, initiation of a new session,
 * or a periodic timeout notification.
 */
void
wait_app_sem(unsigned long semid)
{
 2028c10:	defffb04 	addi	sp,sp,-20
 2028c14:	dfc00415 	stw	ra,16(sp)
 2028c18:	df000315 	stw	fp,12(sp)
 2028c1c:	df000304 	addi	fp,sp,12
 2028c20:	e13fff15 	stw	r4,-4(fp)
   INT8U error = 0;
 2028c24:	e03ffe05 	stb	zero,-8(fp)
   int   errct = 0;
 2028c28:	e03ffd15 	stw	zero,-12(fp)

   if ((0 <= semid) && (semid <= MAX_SEMID))
 2028c2c:	e0bfff17 	ldw	r2,-4(fp)
 2028c30:	108001a8 	cmpgeui	r2,r2,6
 2028c34:	10001f1e 	bne	r2,zero,2028cb4 <wait_app_sem+0xa4>
   {
      do
      {
         OSSemPend(app_semaphore[semid], 0, &error);
 2028c38:	00c09934 	movhi	r3,612
 2028c3c:	18f6bc04 	addi	r3,r3,-9488
 2028c40:	e0bfff17 	ldw	r2,-4(fp)
 2028c44:	1085883a 	add	r2,r2,r2
 2028c48:	1085883a 	add	r2,r2,r2
 2028c4c:	1885883a 	add	r2,r3,r2
 2028c50:	10c00017 	ldw	r3,0(r2)
 2028c54:	e0bffe04 	addi	r2,fp,-8
 2028c58:	1809883a 	mov	r4,r3
 2028c5c:	000b883a 	mov	r5,zero
 2028c60:	100d883a 	mov	r6,r2
 2028c64:	201c0180 	call	201c018 <OSSemPend>
         /* 
          * Sometimes we get a "timeout" error even though we passed a zero
          * to indicate we'll wait forever. When this happens, try again:
          */
         if ((error == 10) && (++errct > 1000))
 2028c68:	e0bffe03 	ldbu	r2,-8(fp)
 2028c6c:	10803fcc 	andi	r2,r2,255
 2028c70:	10800298 	cmpnei	r2,r2,10
 2028c74:	10000a1e 	bne	r2,zero,2028ca0 <wait_app_sem+0x90>
 2028c78:	e0bffd17 	ldw	r2,-12(fp)
 2028c7c:	10800044 	addi	r2,r2,1
 2028c80:	e0bffd15 	stw	r2,-12(fp)
 2028c84:	e0bffd17 	ldw	r2,-12(fp)
 2028c88:	1080fa50 	cmplti	r2,r2,1001
 2028c8c:	1000041e 	bne	r2,zero,2028ca0 <wait_app_sem+0x90>
         {
            panic("lock NET");   /* fatal */
 2028c90:	01008174 	movhi	r4,517
 2028c94:	213c6104 	addi	r4,r4,-3708
 2028c98:	2026bf80 	call	2026bf8 <panic>
 2028c9c:	00000606 	br	2028cb8 <wait_app_sem+0xa8>
            return;
         }
      } while (error == 10);
 2028ca0:	e0bffe03 	ldbu	r2,-8(fp)
 2028ca4:	10803fcc 	andi	r2,r2,255
 2028ca8:	108002a0 	cmpeqi	r2,r2,10
 2028cac:	103fe21e 	bne	r2,zero,2028c38 <wait_app_sem+0x28>
 2028cb0:	00000106 	br	2028cb8 <wait_app_sem+0xa8>
   }
   else
      dtrap();
 2028cb4:	20285c80 	call	20285c8 <dtrap>
}
 2028cb8:	e037883a 	mov	sp,fp
 2028cbc:	dfc00117 	ldw	ra,4(sp)
 2028cc0:	df000017 	ldw	fp,0(sp)
 2028cc4:	dec00204 	addi	sp,sp,8
 2028cc8:	f800283a 	ret

02028ccc <post_app_sem>:
 * notification. It signals the corresponding application event.
 */

void
post_app_sem(unsigned long semid)
{
 2028ccc:	defffc04 	addi	sp,sp,-16
 2028cd0:	dfc00315 	stw	ra,12(sp)
 2028cd4:	df000215 	stw	fp,8(sp)
 2028cd8:	df000204 	addi	fp,sp,8
 2028cdc:	e13fff15 	stw	r4,-4(fp)
   INT8U error;

   if ((0 <= semid) && (semid <= MAX_SEMID))
 2028ce0:	e0bfff17 	ldw	r2,-4(fp)
 2028ce4:	108001a8 	cmpgeui	r2,r2,6
 2028ce8:	1000101e 	bne	r2,zero,2028d2c <post_app_sem+0x60>
   {
      error = OSSemPost(app_semaphore[semid]);
 2028cec:	00c09934 	movhi	r3,612
 2028cf0:	18f6bc04 	addi	r3,r3,-9488
 2028cf4:	e0bfff17 	ldw	r2,-4(fp)
 2028cf8:	1085883a 	add	r2,r2,r2
 2028cfc:	1085883a 	add	r2,r2,r2
 2028d00:	1885883a 	add	r2,r3,r2
 2028d04:	10800017 	ldw	r2,0(r2)
 2028d08:	1009883a 	mov	r4,r2
 2028d0c:	201c3f80 	call	201c3f8 <OSSemPost>
 2028d10:	e0bffe05 	stb	r2,-8(fp)
      if (error != OS_NO_ERR)
 2028d14:	e0bffe03 	ldbu	r2,-8(fp)
 2028d18:	10000526 	beq	r2,zero,2028d30 <post_app_sem+0x64>
      {
         panic("unlock NET");
 2028d1c:	01008174 	movhi	r4,517
 2028d20:	213c6404 	addi	r4,r4,-3696
 2028d24:	2026bf80 	call	2026bf8 <panic>
 2028d28:	00000106 	br	2028d30 <post_app_sem+0x64>
      }
   }
   else
      dtrap();
 2028d2c:	20285c80 	call	20285c8 <dtrap>
}
 2028d30:	e037883a 	mov	sp,fp
 2028d34:	dfc00117 	ldw	ra,4(sp)
 2028d38:	df000017 	ldw	fp,0(sp)
 2028d3c:	dec00204 	addi	sp,sp,8
 2028d40:	f800283a 	ret

02028d44 <alt_iniche_init>:
#ifndef SUPERLOOP

extern OS_EVENT *resid_semaphore[MAX_RESID+1];

void alt_iniche_init(void)
{
 2028d44:	defffd04 	addi	sp,sp,-12
 2028d48:	dfc00215 	stw	ra,8(sp)
 2028d4c:	df000115 	stw	fp,4(sp)
 2028d50:	df000104 	addi	fp,sp,4
   int i;

   /* initialize the npalloc() heap semaphore */
   mheap_sem_ptr = OSSemCreate(1);
 2028d54:	01000044 	movi	r4,1
 2028d58:	201bca80 	call	201bca8 <OSSemCreate>
 2028d5c:	d0a0a115 	stw	r2,-32124(gp)
   if (!mheap_sem_ptr)
 2028d60:	d0a0a117 	ldw	r2,-32124(gp)
 2028d64:	1000031e 	bne	r2,zero,2028d74 <alt_iniche_init+0x30>
      panic("mheap_sem_ptr create err"); 
 2028d68:	01008174 	movhi	r4,517
 2028d6c:	213cfc04 	addi	r4,r4,-3088
 2028d70:	2026bf80 	call	2026bf8 <panic>

   rcvdq_sem_ptr = OSSemCreate(0);
 2028d74:	0009883a 	mov	r4,zero
 2028d78:	201bca80 	call	201bca8 <OSSemCreate>
 2028d7c:	d0a0a215 	stw	r2,-32120(gp)
   if (!rcvdq_sem_ptr)
 2028d80:	d0a0a217 	ldw	r2,-32120(gp)
 2028d84:	1000031e 	bne	r2,zero,2028d94 <alt_iniche_init+0x50>
      panic("rcvdq_sem_ptr create err"); 
 2028d88:	01008174 	movhi	r4,517
 2028d8c:	213d0304 	addi	r4,r4,-3060
 2028d90:	2026bf80 	call	2026bf8 <panic>

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 2028d94:	e03fff15 	stw	zero,-4(fp)
 2028d98:	00001806 	br	2028dfc <alt_iniche_init+0xb8>
   {
      resid_semaphore[i] = OSSemCreate(1);
 2028d9c:	01000044 	movi	r4,1
 2028da0:	201bca80 	call	201bca8 <OSSemCreate>
 2028da4:	1007883a 	mov	r3,r2
 2028da8:	01009934 	movhi	r4,612
 2028dac:	2136ac04 	addi	r4,r4,-9552
 2028db0:	e0bfff17 	ldw	r2,-4(fp)
 2028db4:	1085883a 	add	r2,r2,r2
 2028db8:	1085883a 	add	r2,r2,r2
 2028dbc:	2085883a 	add	r2,r4,r2
 2028dc0:	10c00015 	stw	r3,0(r2)
      if (!resid_semaphore[i])
 2028dc4:	00c09934 	movhi	r3,612
 2028dc8:	18f6ac04 	addi	r3,r3,-9552
 2028dcc:	e0bfff17 	ldw	r2,-4(fp)
 2028dd0:	1085883a 	add	r2,r2,r2
 2028dd4:	1085883a 	add	r2,r2,r2
 2028dd8:	1885883a 	add	r2,r3,r2
 2028ddc:	10800017 	ldw	r2,0(r2)
 2028de0:	1000031e 	bne	r2,zero,2028df0 <alt_iniche_init+0xac>
         panic("resid_semaphore create err");  
 2028de4:	01008174 	movhi	r4,517
 2028de8:	213d0a04 	addi	r4,r4,-3032
 2028dec:	2026bf80 	call	2026bf8 <panic>
   rcvdq_sem_ptr = OSSemCreate(0);
   if (!rcvdq_sem_ptr)
      panic("rcvdq_sem_ptr create err"); 

#ifdef OS_PREEMPTIVE
   for (i = 0; i <= MAX_RESID; i++)
 2028df0:	e0bfff17 	ldw	r2,-4(fp)
 2028df4:	10800044 	addi	r2,r2,1
 2028df8:	e0bfff15 	stw	r2,-4(fp)
 2028dfc:	e0bfff17 	ldw	r2,-4(fp)
 2028e00:	10800410 	cmplti	r2,r2,16
 2028e04:	103fe51e 	bne	r2,zero,2028d9c <alt_iniche_init+0x58>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 2028e08:	e03fff15 	stw	zero,-4(fp)
 2028e0c:	00001806 	br	2028e70 <alt_iniche_init+0x12c>
   {
      app_semaphore[i] = OSSemCreate(1);
 2028e10:	01000044 	movi	r4,1
 2028e14:	201bca80 	call	201bca8 <OSSemCreate>
 2028e18:	1007883a 	mov	r3,r2
 2028e1c:	01009934 	movhi	r4,612
 2028e20:	2136bc04 	addi	r4,r4,-9488
 2028e24:	e0bfff17 	ldw	r2,-4(fp)
 2028e28:	1085883a 	add	r2,r2,r2
 2028e2c:	1085883a 	add	r2,r2,r2
 2028e30:	2085883a 	add	r2,r4,r2
 2028e34:	10c00015 	stw	r3,0(r2)
      if (!app_semaphore[i])
 2028e38:	00c09934 	movhi	r3,612
 2028e3c:	18f6bc04 	addi	r3,r3,-9488
 2028e40:	e0bfff17 	ldw	r2,-4(fp)
 2028e44:	1085883a 	add	r2,r2,r2
 2028e48:	1085883a 	add	r2,r2,r2
 2028e4c:	1885883a 	add	r2,r3,r2
 2028e50:	10800017 	ldw	r2,0(r2)
 2028e54:	1000031e 	bne	r2,zero,2028e64 <alt_iniche_init+0x120>
         panic("app_semaphore create err");  
 2028e58:	01008174 	movhi	r4,517
 2028e5c:	213d1104 	addi	r4,r4,-3004
 2028e60:	2026bf80 	call	2026bf8 <panic>
   {
      resid_semaphore[i] = OSSemCreate(1);
      if (!resid_semaphore[i])
         panic("resid_semaphore create err");  
   }
   for (i = 0; i <= MAX_SEMID; i++)
 2028e64:	e0bfff17 	ldw	r2,-4(fp)
 2028e68:	10800044 	addi	r2,r2,1
 2028e6c:	e0bfff15 	stw	r2,-4(fp)
 2028e70:	e0bfff17 	ldw	r2,-4(fp)
 2028e74:	10800190 	cmplti	r2,r2,6
 2028e78:	103fe51e 	bne	r2,zero,2028e10 <alt_iniche_init+0xcc>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 2028e7c:	e03fff15 	stw	zero,-4(fp)
 2028e80:	00002406 	br	2028f14 <alt_iniche_init+0x1d0>
   {
      global_TCPwakeup_set[i].ctick = 0;
 2028e84:	00c09934 	movhi	r3,612
 2028e88:	18f67004 	addi	r3,r3,-9792
 2028e8c:	e0bfff17 	ldw	r2,-4(fp)
 2028e90:	10800324 	muli	r2,r2,12
 2028e94:	1885883a 	add	r2,r3,r2
 2028e98:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].soc_event = NULL;
 2028e9c:	00c09934 	movhi	r3,612
 2028ea0:	18f67004 	addi	r3,r3,-9792
 2028ea4:	e0bfff17 	ldw	r2,-4(fp)
 2028ea8:	10800324 	muli	r2,r2,12
 2028eac:	1885883a 	add	r2,r3,r2
 2028eb0:	10800104 	addi	r2,r2,4
 2028eb4:	10000015 	stw	zero,0(r2)
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
 2028eb8:	0009883a 	mov	r4,zero
 2028ebc:	201bca80 	call	201bca8 <OSSemCreate>
 2028ec0:	01009934 	movhi	r4,612
 2028ec4:	21367004 	addi	r4,r4,-9792
 2028ec8:	e0ffff17 	ldw	r3,-4(fp)
 2028ecc:	18c00324 	muli	r3,r3,12
 2028ed0:	20c7883a 	add	r3,r4,r3
 2028ed4:	18c00204 	addi	r3,r3,8
 2028ed8:	18800015 	stw	r2,0(r3)
      if (!global_TCPwakeup_set[i].semaphore)
 2028edc:	00c09934 	movhi	r3,612
 2028ee0:	18f67004 	addi	r3,r3,-9792
 2028ee4:	e0bfff17 	ldw	r2,-4(fp)
 2028ee8:	10800324 	muli	r2,r2,12
 2028eec:	1885883a 	add	r2,r3,r2
 2028ef0:	10800204 	addi	r2,r2,8
 2028ef4:	10800017 	ldw	r2,0(r2)
 2028ef8:	1000031e 	bne	r2,zero,2028f08 <alt_iniche_init+0x1c4>
         panic("globwake_semaphore create err");  
 2028efc:	01008174 	movhi	r4,517
 2028f00:	213d1804 	addi	r4,r4,-2976
 2028f04:	2026bf80 	call	2026bf8 <panic>

#ifndef TCPWAKE_RTOS
   /* 
    * clear global_TCPwakeup_set
    */
   for (i = 0; i < GLOBWAKE_SZ; i++)
 2028f08:	e0bfff17 	ldw	r2,-4(fp)
 2028f0c:	10800044 	addi	r2,r2,1
 2028f10:	e0bfff15 	stw	r2,-4(fp)
 2028f14:	e0bfff17 	ldw	r2,-4(fp)
 2028f18:	10800510 	cmplti	r2,r2,20
 2028f1c:	103fd91e 	bne	r2,zero,2028e84 <alt_iniche_init+0x140>
      global_TCPwakeup_set[i].soc_event = NULL;
      global_TCPwakeup_set[i].semaphore = OSSemCreate(0);
      if (!global_TCPwakeup_set[i].semaphore)
         panic("globwake_semaphore create err");  
   }
   global_TCPwakeup_setIndx = 0;
 2028f20:	00808174 	movhi	r2,517
 2028f24:	1090c804 	addi	r2,r2,17184
 2028f28:	10000015 	stw	zero,0(r2)
#endif  /* TCPWAKE_RTOS */
}
 2028f2c:	e037883a 	mov	sp,fp
 2028f30:	dfc00117 	ldw	ra,4(sp)
 2028f34:	df000017 	ldw	fp,0(sp)
 2028f38:	dec00204 	addi	sp,sp,8
 2028f3c:	f800283a 	ret

02028f40 <pre_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
pre_task_setup()
{
 2028f40:	deffff04 	addi	sp,sp,-4
 2028f44:	df000015 	stw	fp,0(sp)
 2028f48:	d839883a 	mov	fp,sp
   write_leds(0);
   write_7seg_raw(0x0000);
#endif

   /* preset buffer counts; may be overridden from command line */
   bigbufs = MAXBIGPKTS;
 2028f4c:	00808174 	movhi	r2,517
 2028f50:	10906804 	addi	r2,r2,16800
 2028f54:	00c00784 	movi	r3,30
 2028f58:	10c00015 	stw	r3,0(r2)
   lilbufs = MAXLILPKTS;
 2028f5c:	00808174 	movhi	r2,517
 2028f60:	10906604 	addi	r2,r2,16792
 2028f64:	00c00784 	movi	r3,30
 2028f68:	10c00015 	stw	r3,0(r2)
   bigbufsiz = BIGBUFSIZE;
 2028f6c:	00808174 	movhi	r2,517
 2028f70:	10906904 	addi	r2,r2,16804
 2028f74:	00c18004 	movi	r3,1536
 2028f78:	10c00015 	stw	r3,0(r2)
   lilbufsiz = LILBUFSIZE;
 2028f7c:	00808174 	movhi	r2,517
 2028f80:	10906704 	addi	r2,r2,16796
 2028f84:	00c02004 	movi	r3,128
 2028f88:	10c00015 	stw	r3,0(r2)

   /* Install callback to prep_armintcp from prep_ifaces() */
   port_prep = prep_armintcp;
 2028f8c:	00808174 	movhi	r2,517
 2028f90:	1090ea04 	addi	r2,r2,17320
 2028f94:	00c080f4 	movhi	r3,515
 2028f98:	18e3f504 	addi	r3,r3,-28716
 2028f9c:	10c00015 	stw	r3,0(r2)
#endif   /* NOTDEF */

#endif   /* USE_PPP */


   return NULL;
 2028fa0:	0005883a 	mov	r2,zero
}
 2028fa4:	e037883a 	mov	sp,fp
 2028fa8:	df000017 	ldw	fp,0(sp)
 2028fac:	dec00104 	addi	sp,sp,4
 2028fb0:	f800283a 	ret

02028fb4 <post_task_setup>:
 * Return NULL if OK, else brief error message
 */

char *
post_task_setup()
{
 2028fb4:	deffff04 	addi	sp,sp,-4
 2028fb8:	df000015 	stw	fp,0(sp)
 2028fbc:	d839883a 	mov	fp,sp
   return NULL;
 2028fc0:	0005883a 	mov	r2,zero
}
 2028fc4:	e037883a 	mov	sp,fp
 2028fc8:	df000017 	ldw	fp,0(sp)
 2028fcc:	dec00104 	addi	sp,sp,4
 2028fd0:	f800283a 	ret

02028fd4 <prep_armintcp>:

#endif  /* INCLUDE_NVPARMS */

int 
prep_armintcp(int ifaces_found)
{
 2028fd4:	defffd04 	addi	sp,sp,-12
 2028fd8:	dfc00215 	stw	ra,8(sp)
 2028fdc:	df000115 	stw	fp,4(sp)
 2028fe0:	df000104 	addi	fp,sp,4
 2028fe4:	e13fff15 	stw	r4,-4(fp)
 * Call iniche_devices_init, in alt_iniche_dev.c, 
 * to step through all devices and all their respective
 * low-level initialization routines.
 */
#ifdef ALT_INICHE
   ifaces_found = iniche_devices_init(ifaces_found);
 2028fe8:	e13fff17 	ldw	r4,-4(fp)
 2028fec:	20237b00 	call	20237b0 <iniche_devices_init>
 2028ff0:	e0bfff15 	stw	r2,-4(fp)

#ifdef USE_SLIP
   ifaces_found = prep_slip(ifaces_found);
#endif

   return ifaces_found;
 2028ff4:	e0bfff17 	ldw	r2,-4(fp)
}
 2028ff8:	e037883a 	mov	sp,fp
 2028ffc:	dfc00117 	ldw	ra,4(sp)
 2029000:	df000017 	ldw	fp,0(sp)
 2029004:	dec00204 	addi	sp,sp,8
 2029008:	f800283a 	ret

0202900c <calloc2>:
 * There is already a function called calloc1() in memio.c,
 * hence use a different function name.
 */
char * 
calloc2(unsigned size)
{
 202900c:	defffd04 	addi	sp,sp,-12
 2029010:	dfc00215 	stw	ra,8(sp)
 2029014:	df000115 	stw	fp,4(sp)
 2029018:	df000104 	addi	fp,sp,4
 202901c:	e13fff15 	stw	r4,-4(fp)
   return (calloc(1,size));
 2029020:	01000044 	movi	r4,1
 2029024:	e17fff17 	ldw	r5,-4(fp)
 2029028:	204bcf00 	call	204bcf0 <calloc>
}
 202902c:	e037883a 	mov	sp,fp
 2029030:	dfc00117 	ldw	ra,4(sp)
 2029034:	df000017 	ldw	fp,0(sp)
 2029038:	dec00204 	addi	sp,sp,8
 202903c:	f800283a 	ret

02029040 <npalloc>:


char *
npalloc(unsigned size)
{
 2029040:	defffa04 	addi	sp,sp,-24
 2029044:	dfc00515 	stw	ra,20(sp)
 2029048:	df000415 	stw	fp,16(sp)
 202904c:	df000404 	addi	fp,sp,16
 2029050:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;
#endif

#ifdef UCOS_II
   OSSemPend(mheap_sem_ptr, 0, &err);
 2029054:	d0e0a117 	ldw	r3,-32124(gp)
 2029058:	e0bffe04 	addi	r2,fp,-8
 202905c:	1809883a 	mov	r4,r3
 2029060:	000b883a 	mov	r5,zero
 2029064:	100d883a 	mov	r6,r2
 2029068:	201c0180 	call	201c018 <OSSemPend>
   if(err)
 202906c:	e0bffe03 	ldbu	r2,-8(fp)
 2029070:	10803fcc 	andi	r2,r2,255
 2029074:	10001826 	beq	r2,zero,20290d8 <npalloc+0x98>
   {
      int errct = 0;
 2029078:	e03ffc15 	stw	zero,-16(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 202907c:	00001206 	br	20290c8 <npalloc+0x88>
      {
         if(errct++ > 1000)
 2029080:	e0bffc17 	ldw	r2,-16(fp)
 2029084:	1080fa48 	cmpgei	r2,r2,1001
 2029088:	e0fffc17 	ldw	r3,-16(fp)
 202908c:	18c00044 	addi	r3,r3,1
 2029090:	e0fffc15 	stw	r3,-16(fp)
 2029094:	10803fcc 	andi	r2,r2,255
 2029098:	10000526 	beq	r2,zero,20290b0 <npalloc+0x70>
         {
            panic("npalloc");    /* fatal? */
 202909c:	01008174 	movhi	r4,517
 20290a0:	213d2004 	addi	r4,r4,-2944
 20290a4:	2026bf80 	call	2026bf8 <panic>
            return NULL;
 20290a8:	0005883a 	mov	r2,zero
 20290ac:	00001a06 	br	2029118 <npalloc+0xd8>
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 20290b0:	d0e0a117 	ldw	r3,-32124(gp)
 20290b4:	e0bffe04 	addi	r2,fp,-8
 20290b8:	1809883a 	mov	r4,r3
 20290bc:	000b883a 	mov	r5,zero
 20290c0:	100d883a 	mov	r6,r2
 20290c4:	201c0180 	call	201c018 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while(err == 10)
 20290c8:	e0bffe03 	ldbu	r2,-8(fp)
 20290cc:	10803fcc 	andi	r2,r2,255
 20290d0:	108002a0 	cmpeqi	r2,r2,10
 20290d4:	103fea1e 	bne	r2,zero,2029080 <npalloc+0x40>
#endif

#ifdef   MEM_WRAPPERS
   ptr = wrap_alloc(size, calloc2);
#else
   ptr = calloc2(size);
 20290d8:	e13fff17 	ldw	r4,-4(fp)
 20290dc:	202900c0 	call	202900c <calloc2>
 20290e0:	e0bffd15 	stw	r2,-12(fp)
#endif

#ifdef UCOS_II 
   err = OSSemPost(mheap_sem_ptr);
 20290e4:	d0a0a117 	ldw	r2,-32124(gp)
 20290e8:	1009883a 	mov	r4,r2
 20290ec:	201c3f80 	call	201c3f8 <OSSemPost>
 20290f0:	e0bffe05 	stb	r2,-8(fp)
#endif
   
   if(!ptr)
 20290f4:	e0bffd17 	ldw	r2,-12(fp)
 20290f8:	1000021e 	bne	r2,zero,2029104 <npalloc+0xc4>
      return NULL;
 20290fc:	0005883a 	mov	r2,zero
 2029100:	00000506 	br	2029118 <npalloc+0xd8>

   MEMSET(ptr, 0, size);
 2029104:	e13ffd17 	ldw	r4,-12(fp)
 2029108:	000b883a 	mov	r5,zero
 202910c:	e1bfff17 	ldw	r6,-4(fp)
 2029110:	200682c0 	call	200682c <memset>
   return ptr;      
 2029114:	e0bffd17 	ldw	r2,-12(fp)
}
 2029118:	e037883a 	mov	sp,fp
 202911c:	dfc00117 	ldw	ra,4(sp)
 2029120:	df000017 	ldw	fp,0(sp)
 2029124:	dec00204 	addi	sp,sp,8
 2029128:	f800283a 	ret

0202912c <npfree>:

void
npfree(void * ptr)
{
 202912c:	defffb04 	addi	sp,sp,-20
 2029130:	dfc00415 	stw	ra,16(sp)
 2029134:	df000315 	stw	fp,12(sp)
 2029138:	df000304 	addi	fp,sp,12
 202913c:	e13fff15 	stw	r4,-4(fp)
#ifdef UCOS_II
   INT8U err;

   OSSemPend(mheap_sem_ptr, 0, &err);
 2029140:	d0e0a117 	ldw	r3,-32124(gp)
 2029144:	e0bffe04 	addi	r2,fp,-8
 2029148:	1809883a 	mov	r4,r3
 202914c:	000b883a 	mov	r5,zero
 2029150:	100d883a 	mov	r6,r2
 2029154:	201c0180 	call	201c018 <OSSemPend>
   if (err)
 2029158:	e0bffe03 	ldbu	r2,-8(fp)
 202915c:	10803fcc 	andi	r2,r2,255
 2029160:	10001726 	beq	r2,zero,20291c0 <npfree+0x94>
   {
      int errct = 0;
 2029164:	e03ffd15 	stw	zero,-12(fp)

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 2029168:	00001106 	br	20291b0 <npfree+0x84>
      {
         if (errct++ > 1000)
 202916c:	e0bffd17 	ldw	r2,-12(fp)
 2029170:	1080fa48 	cmpgei	r2,r2,1001
 2029174:	e0fffd17 	ldw	r3,-12(fp)
 2029178:	18c00044 	addi	r3,r3,1
 202917c:	e0fffd15 	stw	r3,-12(fp)
 2029180:	10803fcc 	andi	r2,r2,255
 2029184:	10000426 	beq	r2,zero,2029198 <npfree+0x6c>
         {
            panic("npfree");    /* fatal? */
 2029188:	01008174 	movhi	r4,517
 202918c:	213d2204 	addi	r4,r4,-2936
 2029190:	2026bf80 	call	2026bf8 <panic>
 2029194:	00001006 	br	20291d8 <npfree+0xac>
            return;
         }
         OSSemPend(mheap_sem_ptr, 0, &err);
 2029198:	d0e0a117 	ldw	r3,-32124(gp)
 202919c:	e0bffe04 	addi	r2,fp,-8
 20291a0:	1809883a 	mov	r4,r3
 20291a4:	000b883a 	mov	r5,zero
 20291a8:	100d883a 	mov	r6,r2
 20291ac:	201c0180 	call	201c018 <OSSemPend>
      int errct = 0;

      /* sometimes we get a "timeout" error even though we passed a zero
       * to indicate we'll wait forever. When this happens, try again:
       */
      while (err == 10)
 20291b0:	e0bffe03 	ldbu	r2,-8(fp)
 20291b4:	10803fcc 	andi	r2,r2,255
 20291b8:	108002a0 	cmpeqi	r2,r2,10
 20291bc:	103feb1e 	bne	r2,zero,202916c <npfree+0x40>
   }
   
#ifdef   MEM_WRAPPERS
   wrap_free((char*)ptr, free);
#else
   free(ptr);
 20291c0:	e13fff17 	ldw	r4,-4(fp)
 20291c4:	204bd580 	call	204bd58 <free>
#endif

   err = OSSemPost(mheap_sem_ptr);
 20291c8:	d0a0a117 	ldw	r2,-32124(gp)
 20291cc:	1009883a 	mov	r4,r2
 20291d0:	201c3f80 	call	201c3f8 <OSSemPost>
 20291d4:	e0bffe05 	stb	r2,-8(fp)
 */
   free(ptr);
#endif
#endif

}
 20291d8:	e037883a 	mov	sp,fp
 20291dc:	dfc00117 	ldw	ra,4(sp)
 20291e0:	df000017 	ldw	fp,0(sp)
 20291e4:	dec00204 	addi	sp,sp,8
 20291e8:	f800283a 	ret

020291ec <ncpalloc>:
 * contains macro definitions that assign specific memory
 * allocation calls to these routines.
 */
#ifdef ALT_INICHE
char * ncpalloc(unsigned size)
{
 20291ec:	defffc04 	addi	sp,sp,-16
 20291f0:	dfc00315 	stw	ra,12(sp)
 20291f4:	df000215 	stw	fp,8(sp)
 20291f8:	df000204 	addi	fp,sp,8
 20291fc:	e13fff15 	stw	r4,-4(fp)
   char *ptr = npalloc(size);
 2029200:	e13fff17 	ldw	r4,-4(fp)
 2029204:	20290400 	call	2029040 <npalloc>
 2029208:	e0bffe15 	stw	r2,-8(fp)

   if(ptr) {
 202920c:	e0bffe17 	ldw	r2,-8(fp)
 2029210:	10000426 	beq	r2,zero,2029224 <ncpalloc+0x38>
      ptr = (char *) alt_remap_uncached(ptr, size);
 2029214:	e13ffe17 	ldw	r4,-8(fp)
 2029218:	e17fff17 	ldw	r5,-4(fp)
 202921c:	20379100 	call	2037910 <alt_remap_uncached>
 2029220:	e0bffe15 	stw	r2,-8(fp)
   }

   return ptr;
 2029224:	e0bffe17 	ldw	r2,-8(fp)
}
 2029228:	e037883a 	mov	sp,fp
 202922c:	dfc00117 	ldw	ra,4(sp)
 2029230:	df000017 	ldw	fp,0(sp)
 2029234:	dec00204 	addi	sp,sp,8
 2029238:	f800283a 	ret

0202923c <ncpfree>:

void ncpfree(void *ptr)
{
 202923c:	defffd04 	addi	sp,sp,-12
 2029240:	dfc00215 	stw	ra,8(sp)
 2029244:	df000115 	stw	fp,4(sp)
 2029248:	df000104 	addi	fp,sp,4
 202924c:	e13fff15 	stw	r4,-4(fp)
   if(ptr) {
 2029250:	e0bfff17 	ldw	r2,-4(fp)
 2029254:	10000626 	beq	r2,zero,2029270 <ncpfree+0x34>
      ptr = alt_remap_cached(ptr, sizeof(ptr));
 2029258:	e13fff17 	ldw	r4,-4(fp)
 202925c:	01400104 	movi	r5,4
 2029260:	20378dc0 	call	20378dc <alt_remap_cached>
 2029264:	e0bfff15 	stw	r2,-4(fp)
      npfree(ptr);
 2029268:	e13fff17 	ldw	r4,-4(fp)
 202926c:	202912c0 	call	202912c <npfree>
   }
}
 2029270:	e037883a 	mov	sp,fp
 2029274:	dfc00117 	ldw	ra,4(sp)
 2029278:	df000017 	ldw	fp,0(sp)
 202927c:	dec00204 	addi	sp,sp,8
 2029280:	f800283a 	ret

02029284 <pffindtype>:
 * RETURNS: 
 */

struct protosw *  
pffindtype(int domain, int type)
{
 2029284:	defffc04 	addi	sp,sp,-16
 2029288:	dfc00315 	stw	ra,12(sp)
 202928c:	df000215 	stw	fp,8(sp)
 2029290:	df000204 	addi	fp,sp,8
 2029294:	e13ffe15 	stw	r4,-8(fp)
 2029298:	e17fff15 	stw	r5,-4(fp)

   /* check that the passed domain is vaid for the build */
   if (domain != AF_INET)
 202929c:	e0bffe17 	ldw	r2,-8(fp)
 20292a0:	108000a0 	cmpeqi	r2,r2,2
 20292a4:	1000031e 	bne	r2,zero,20292b4 <pffindtype+0x30>
   {
#ifdef IP_V6
      if(domain != AF_INET6)
#endif
      {
         dtrap();    /* programming error */
 20292a8:	20285c80 	call	20285c8 <dtrap>
         return NULL;
 20292ac:	0005883a 	mov	r2,zero
 20292b0:	00001306 	br	2029300 <pffindtype+0x7c>
      }
   }

   if (type == SOCK_STREAM)
 20292b4:	e0bfff17 	ldw	r2,-4(fp)
 20292b8:	10800058 	cmpnei	r2,r2,1
 20292bc:	1000031e 	bne	r2,zero,20292cc <pffindtype+0x48>
      return &tcp_protosw;
 20292c0:	00808174 	movhi	r2,517
 20292c4:	108efc04 	addi	r2,r2,15344
 20292c8:	00000d06 	br	2029300 <pffindtype+0x7c>
#ifdef UDP_SOCKETS
   else if(type == SOCK_DGRAM)
 20292cc:	e0bfff17 	ldw	r2,-4(fp)
 20292d0:	10800098 	cmpnei	r2,r2,2
 20292d4:	1000031e 	bne	r2,zero,20292e4 <pffindtype+0x60>
      return &udp_protosw;
 20292d8:	00808174 	movhi	r2,517
 20292dc:	108f0204 	addi	r2,r2,15368
 20292e0:	00000706 	br	2029300 <pffindtype+0x7c>
#endif   /* UDP_SOCKETS */
#ifdef IP_RAW
   else if(type == SOCK_RAW)
 20292e4:	e0bfff17 	ldw	r2,-4(fp)
 20292e8:	108000d8 	cmpnei	r2,r2,3
 20292ec:	1000031e 	bne	r2,zero,20292fc <pffindtype+0x78>
      return &rawip_protosw;
 20292f0:	00808174 	movhi	r2,517
 20292f4:	108f0804 	addi	r2,r2,15392
 20292f8:	00000106 	br	2029300 <pffindtype+0x7c>
#endif  /* IP_RAW */
   else
      return NULL;
 20292fc:	0005883a 	mov	r2,zero
}
 2029300:	e037883a 	mov	sp,fp
 2029304:	dfc00117 	ldw	ra,4(sp)
 2029308:	df000017 	ldw	fp,0(sp)
 202930c:	dec00204 	addi	sp,sp,8
 2029310:	f800283a 	ret

02029314 <pffindproto>:
 * RETURNS: 
 */

struct protosw *  
pffindproto(int domain, int protocol, int type)
{
 2029314:	defffb04 	addi	sp,sp,-20
 2029318:	dfc00415 	stw	ra,16(sp)
 202931c:	df000315 	stw	fp,12(sp)
 2029320:	df000304 	addi	fp,sp,12
 2029324:	e13ffd15 	stw	r4,-12(fp)
 2029328:	e17ffe15 	stw	r5,-8(fp)
 202932c:	e1bfff15 	stw	r6,-4(fp)
#ifdef IP_RAW
   if (type == SOCK_RAW)
 2029330:	e0bfff17 	ldw	r2,-4(fp)
 2029334:	108000d8 	cmpnei	r2,r2,3
 2029338:	1000041e 	bne	r2,zero,202934c <pffindproto+0x38>
      return(pffindtype(domain, type));
 202933c:	e13ffd17 	ldw	r4,-12(fp)
 2029340:	e17fff17 	ldw	r5,-4(fp)
 2029344:	20292840 	call	2029284 <pffindtype>
 2029348:	00001e06 	br	20293c4 <pffindproto+0xb0>
#endif

   switch (protocol)
 202934c:	e0bffe17 	ldw	r2,-8(fp)
 2029350:	10c001a0 	cmpeqi	r3,r2,6
 2029354:	1800041e 	bne	r3,zero,2029368 <pffindproto+0x54>
 2029358:	10c00460 	cmpeqi	r3,r2,17
 202935c:	1800081e 	bne	r3,zero,2029380 <pffindproto+0x6c>
 2029360:	10001026 	beq	r2,zero,20293a4 <pffindproto+0x90>
 2029364:	00000c06 	br	2029398 <pffindproto+0x84>
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
 2029368:	e0bfff17 	ldw	r2,-4(fp)
 202936c:	10800058 	cmpnei	r2,r2,1
 2029370:	10000e26 	beq	r2,zero,20293ac <pffindproto+0x98>
         break;
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
 2029374:	20285c80 	call	20285c8 <dtrap>
      return NULL;
 2029378:	0005883a 	mov	r2,zero
 202937c:	00001106 	br	20293c4 <pffindproto+0xb0>
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
 2029380:	e0bfff17 	ldw	r2,-4(fp)
 2029384:	10800098 	cmpnei	r2,r2,2
 2029388:	10000a26 	beq	r2,zero,20293b4 <pffindproto+0xa0>
         break;
      /* IPPROTO_UDP protocol on non-SOCK_DGRAM type socket */
      dtrap();
 202938c:	20285c80 	call	20285c8 <dtrap>
      return NULL;
 2029390:	0005883a 	mov	r2,zero
 2029394:	00000b06 	br	20293c4 <pffindproto+0xb0>
   case 0:
      /* let protocol default based on socket type */
      break;
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
 2029398:	20285c80 	call	20285c8 <dtrap>
      return NULL;
 202939c:	0005883a 	mov	r2,zero
 20293a0:	00000806 	br	20293c4 <pffindproto+0xb0>
      dtrap();
      return NULL;
#endif /* BSD_SOCKETS */
   case 0:
      /* let protocol default based on socket type */
      break;
 20293a4:	0001883a 	nop
 20293a8:	00000306 	br	20293b8 <pffindproto+0xa4>
   switch (protocol)
   {
#ifdef BSD_SOCKETS
   case IPPROTO_TCP:
      if (type == SOCK_STREAM)
         break;
 20293ac:	0001883a 	nop
 20293b0:	00000106 	br	20293b8 <pffindproto+0xa4>
      /* IPPROTO_TCP protocol on non-SOCK_STREAM type socket */
      dtrap();
      return NULL;
   case IPPROTO_UDP:
      if (type == SOCK_DGRAM)
         break;
 20293b4:	0001883a 	nop
   default:
      /* unknown/unsupported protocol on socket */
      dtrap();
      return NULL;
   }
   return(pffindtype(domain, type));   /* map to findtype */
 20293b8:	e13ffd17 	ldw	r4,-12(fp)
 20293bc:	e17fff17 	ldw	r5,-4(fp)
 20293c0:	20292840 	call	2029284 <pffindtype>
}
 20293c4:	e037883a 	mov	sp,fp
 20293c8:	dfc00117 	ldw	ra,4(sp)
 20293cc:	df000017 	ldw	fp,0(sp)
 20293d0:	dec00204 	addi	sp,sp,8
 20293d4:	f800283a 	ret

020293d8 <m_getnbuf>:
 * RETURNS: 
 */

struct mbuf *  
m_getnbuf(int type, int len)
{
 20293d8:	defffa04 	addi	sp,sp,-24
 20293dc:	dfc00515 	stw	ra,20(sp)
 20293e0:	df000415 	stw	fp,16(sp)
 20293e4:	df000404 	addi	fp,sp,16
 20293e8:	e13ffe15 	stw	r4,-8(fp)
 20293ec:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   PACKET pkt = NULL;
 20293f0:	e03ffc15 	stw	zero,-16(fp)

#ifdef NPDEBUG
   if (type < MT_RXDATA || type > MT_IFADDR)
 20293f4:	e0bffe17 	ldw	r2,-8(fp)
 20293f8:	0080030e 	bge	zero,r2,2029408 <m_getnbuf+0x30>
 20293fc:	e0bffe17 	ldw	r2,-8(fp)
 2029400:	10800390 	cmplti	r2,r2,14
 2029404:	1000011e 	bne	r2,zero,202940c <m_getnbuf+0x34>
   {
      dtrap(); /* is this OK? */
 2029408:	20285c80 	call	20285c8 <dtrap>
   }
#endif

   /* if caller has data (len >= 0), we need to allocate 
    * a packet buffer; else all we need is the mbuf */
   if (len != 0)
 202940c:	e0bfff17 	ldw	r2,-4(fp)
 2029410:	10000d26 	beq	r2,zero,2029448 <m_getnbuf+0x70>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2029414:	01000084 	movi	r4,2
 2029418:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pkt = pk_alloc(len + HDRSLEN);
 202941c:	e0bfff17 	ldw	r2,-4(fp)
 2029420:	10800e04 	addi	r2,r2,56
 2029424:	1009883a 	mov	r4,r2
 2029428:	2027cec0 	call	2027cec <pk_alloc>
 202942c:	e0bffc15 	stw	r2,-16(fp)

      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2029430:	01000084 	movi	r4,2
 2029434:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      if (!pkt)
 2029438:	e0bffc17 	ldw	r2,-16(fp)
 202943c:	1000021e 	bne	r2,zero,2029448 <m_getnbuf+0x70>
         return NULL;
 2029440:	0005883a 	mov	r2,zero
 2029444:	00004106 	br	202954c <m_getnbuf+0x174>
   }

   m = (struct mbuf *)getq(&mfreeq);
 2029448:	01009934 	movhi	r4,612
 202944c:	2136db04 	addi	r4,r4,-9364
 2029450:	20281d00 	call	20281d0 <getq>
 2029454:	e0bffd15 	stw	r2,-12(fp)
   if (!m)
 2029458:	e0bffd17 	ldw	r2,-12(fp)
 202945c:	10000a1e 	bne	r2,zero,2029488 <m_getnbuf+0xb0>
   {
      if (pkt) 
 2029460:	e0bffc17 	ldw	r2,-16(fp)
 2029464:	10000626 	beq	r2,zero,2029480 <m_getnbuf+0xa8>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 2029468:	01000084 	movi	r4,2
 202946c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 2029470:	e13ffc17 	ldw	r4,-16(fp)
 2029474:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2029478:	01000084 	movi	r4,2
 202947c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      }
      return NULL;
 2029480:	0005883a 	mov	r2,zero
 2029484:	00003106 	br	202954c <m_getnbuf+0x174>
   }
   m->m_type = type;
 2029488:	e0bffd17 	ldw	r2,-12(fp)
 202948c:	e0fffe17 	ldw	r3,-8(fp)
 2029490:	10c00815 	stw	r3,32(r2)
   if (len == 0)
 2029494:	e0bfff17 	ldw	r2,-4(fp)
 2029498:	1000071e 	bne	r2,zero,20294b8 <m_getnbuf+0xe0>
   {
      m->pkt = NULL;
 202949c:	e0bffd17 	ldw	r2,-12(fp)
 20294a0:	10000115 	stw	zero,4(r2)
      m->m_base = NULL;    /* caller better fill these in! */
 20294a4:	e0bffd17 	ldw	r2,-12(fp)
 20294a8:	10000415 	stw	zero,16(r2)
      m->m_memsz = 0;
 20294ac:	e0bffd17 	ldw	r2,-12(fp)
 20294b0:	10000515 	stw	zero,20(r2)
 20294b4:	00001506 	br	202950c <m_getnbuf+0x134>
   }
   else
   {
      m->pkt = pkt;
 20294b8:	e0bffd17 	ldw	r2,-12(fp)
 20294bc:	e0fffc17 	ldw	r3,-16(fp)
 20294c0:	10c00115 	stw	r3,4(r2)
      /* set m_data to the part where tcp data should go */
      m->m_base = m->m_data = pkt->nb_prot = pkt->nb_buff + HDRSLEN;
 20294c4:	e0bffc17 	ldw	r2,-16(fp)
 20294c8:	10800117 	ldw	r2,4(r2)
 20294cc:	10c00e04 	addi	r3,r2,56
 20294d0:	e0bffc17 	ldw	r2,-16(fp)
 20294d4:	10c00315 	stw	r3,12(r2)
 20294d8:	e0bffc17 	ldw	r2,-16(fp)
 20294dc:	10c00317 	ldw	r3,12(r2)
 20294e0:	e0bffd17 	ldw	r2,-12(fp)
 20294e4:	10c00315 	stw	r3,12(r2)
 20294e8:	e0bffd17 	ldw	r2,-12(fp)
 20294ec:	10c00317 	ldw	r3,12(r2)
 20294f0:	e0bffd17 	ldw	r2,-12(fp)
 20294f4:	10c00415 	stw	r3,16(r2)
      m->m_memsz = pkt->nb_blen - HDRSLEN;
 20294f8:	e0bffc17 	ldw	r2,-16(fp)
 20294fc:	10800217 	ldw	r2,8(r2)
 2029500:	10fff204 	addi	r3,r2,-56
 2029504:	e0bffd17 	ldw	r2,-12(fp)
 2029508:	10c00515 	stw	r3,20(r2)
   }
   m->m_len = 0;
 202950c:	e0bffd17 	ldw	r2,-12(fp)
 2029510:	10000215 	stw	zero,8(r2)
   m->m_next = m->m_act = NULL;
 2029514:	e0bffd17 	ldw	r2,-12(fp)
 2029518:	10000715 	stw	zero,28(r2)
 202951c:	e0bffd17 	ldw	r2,-12(fp)
 2029520:	10c00717 	ldw	r3,28(r2)
 2029524:	e0bffd17 	ldw	r2,-12(fp)
 2029528:	10c00615 	stw	r3,24(r2)
   mbstat.allocs++;        /* maintain local statistics */
 202952c:	d0a0a517 	ldw	r2,-32108(gp)
 2029530:	10800044 	addi	r2,r2,1
 2029534:	d0a0a515 	stw	r2,-32108(gp)
   putq(&mbufq, (qp)m);
 2029538:	01009934 	movhi	r4,612
 202953c:	2136d604 	addi	r4,r4,-9384
 2029540:	e17ffd17 	ldw	r5,-12(fp)
 2029544:	20282880 	call	2028288 <putq>
   return m;
 2029548:	e0bffd17 	ldw	r2,-12(fp)
}
 202954c:	e037883a 	mov	sp,fp
 2029550:	dfc00117 	ldw	ra,4(sp)
 2029554:	df000017 	ldw	fp,0(sp)
 2029558:	dec00204 	addi	sp,sp,8
 202955c:	f800283a 	ret

02029560 <m_free>:
 */


struct mbuf *  
m_free(struct mbuf * m)
{
 2029560:	defffc04 	addi	sp,sp,-16
 2029564:	dfc00315 	stw	ra,12(sp)
 2029568:	df000215 	stw	fp,8(sp)
 202956c:	df000204 	addi	fp,sp,8
 2029570:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  nextptr;

#ifdef NPDEBUG
   if (mbufq.q_len < 1)
 2029574:	00809934 	movhi	r2,612
 2029578:	10b6d604 	addi	r2,r2,-9384
 202957c:	10800217 	ldw	r2,8(r2)
 2029580:	00800316 	blt	zero,r2,2029590 <m_free+0x30>
      panic("mfree: q_len");
 2029584:	01008174 	movhi	r4,517
 2029588:	213d2404 	addi	r4,r4,-2928
 202958c:	2026bf80 	call	2026bf8 <panic>

   if (m->m_type < MT_RXDATA || m->m_type > MT_IFADDR)
 2029590:	e0bfff17 	ldw	r2,-4(fp)
 2029594:	10800817 	ldw	r2,32(r2)
 2029598:	0080040e 	bge	zero,r2,20295ac <m_free+0x4c>
 202959c:	e0bfff17 	ldw	r2,-4(fp)
 20295a0:	10800817 	ldw	r2,32(r2)
 20295a4:	10800390 	cmplti	r2,r2,14
 20295a8:	10000a1e 	bne	r2,zero,20295d4 <m_free+0x74>
   {
      if (m->m_type == MT_FREE)
 20295ac:	e0bfff17 	ldw	r2,-4(fp)
 20295b0:	10800817 	ldw	r2,32(r2)
 20295b4:	1000041e 	bne	r2,zero,20295c8 <m_free+0x68>
      {
         dtrap(); /* debug double free of mbuf by tcp_in() */
 20295b8:	20285c80 	call	20285c8 <dtrap>
         return m->m_next; /* seems harmless, though.... */
 20295bc:	e0bfff17 	ldw	r2,-4(fp)
 20295c0:	10800617 	ldw	r2,24(r2)
 20295c4:	00002706 	br	2029664 <m_free+0x104>
      }
      else
         panic("m_free: type");
 20295c8:	01008174 	movhi	r4,517
 20295cc:	213d2804 	addi	r4,r4,-2912
 20295d0:	2026bf80 	call	2026bf8 <panic>
   }
#endif   /* NPDEBUG */

   nextptr = m->m_next;    /* remember value to return */
 20295d4:	e0bfff17 	ldw	r2,-4(fp)
 20295d8:	10800617 	ldw	r2,24(r2)
 20295dc:	e0bffe15 	stw	r2,-8(fp)

   if (qdel(&mbufq, m) == NULL)
 20295e0:	01009934 	movhi	r4,612
 20295e4:	2136d604 	addi	r4,r4,-9384
 20295e8:	e17fff17 	ldw	r5,-4(fp)
 20295ec:	20283340 	call	2028334 <qdel>
 20295f0:	1000031e 	bne	r2,zero,2029600 <m_free+0xa0>
      panic("m_free: missing");
 20295f4:	01008174 	movhi	r4,517
 20295f8:	213d2c04 	addi	r4,r4,-2896
 20295fc:	2026bf80 	call	2026bf8 <panic>

   m->m_type = MT_FREE;    /* this may seem silly, but helps error checking */
 2029600:	e0bfff17 	ldw	r2,-4(fp)
 2029604:	10000815 	stw	zero,32(r2)

   if (m->pkt)
 2029608:	e0bfff17 	ldw	r2,-4(fp)
 202960c:	10800117 	ldw	r2,4(r2)
 2029610:	10000826 	beq	r2,zero,2029634 <m_free+0xd4>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2029614:	01000084 	movi	r4,2
 2029618:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(m->pkt);     /* free up the netport buffer */
 202961c:	e0bfff17 	ldw	r2,-4(fp)
 2029620:	10800117 	ldw	r2,4(r2)
 2029624:	1009883a 	mov	r4,r2
 2029628:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 202962c:	01000084 	movi	r4,2
 2029630:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   }
   mbstat.frees++;
 2029634:	00808174 	movhi	r2,517
 2029638:	1090d004 	addi	r2,r2,17216
 202963c:	10800017 	ldw	r2,0(r2)
 2029640:	10c00044 	addi	r3,r2,1
 2029644:	00808174 	movhi	r2,517
 2029648:	1090d004 	addi	r2,r2,17216
 202964c:	10c00015 	stw	r3,0(r2)
   putq(&mfreeq, (qp)m);
 2029650:	01009934 	movhi	r4,612
 2029654:	2136db04 	addi	r4,r4,-9364
 2029658:	e17fff17 	ldw	r5,-4(fp)
 202965c:	20282880 	call	2028288 <putq>
   return nextptr;
 2029660:	e0bffe17 	ldw	r2,-8(fp)
}
 2029664:	e037883a 	mov	sp,fp
 2029668:	dfc00117 	ldw	ra,4(sp)
 202966c:	df000017 	ldw	fp,0(sp)
 2029670:	dec00204 	addi	sp,sp,8
 2029674:	f800283a 	ret

02029678 <m_freem>:
 * RETURNS: 
 */

void
m_freem(struct mbuf * m)
{
 2029678:	defffd04 	addi	sp,sp,-12
 202967c:	dfc00215 	stw	ra,8(sp)
 2029680:	df000115 	stw	fp,4(sp)
 2029684:	df000104 	addi	fp,sp,4
 2029688:	e13fff15 	stw	r4,-4(fp)
   while (m != NULL)
 202968c:	00000306 	br	202969c <m_freem+0x24>
      m = m_free(m);
 2029690:	e13fff17 	ldw	r4,-4(fp)
 2029694:	20295600 	call	2029560 <m_free>
 2029698:	e0bfff15 	stw	r2,-4(fp)
 */

void
m_freem(struct mbuf * m)
{
   while (m != NULL)
 202969c:	e0bfff17 	ldw	r2,-4(fp)
 20296a0:	103ffb1e 	bne	r2,zero,2029690 <m_freem+0x18>
      m = m_free(m);
}
 20296a4:	e037883a 	mov	sp,fp
 20296a8:	dfc00117 	ldw	ra,4(sp)
 20296ac:	df000017 	ldw	fp,0(sp)
 20296b0:	dec00204 	addi	sp,sp,8
 20296b4:	f800283a 	ret

020296b8 <m_copy>:
 * RETURNS: 
 */

struct mbuf *  
m_copy(struct mbuf * m, int off, int len)
{
 20296b8:	defff704 	addi	sp,sp,-36
 20296bc:	dfc00815 	stw	ra,32(sp)
 20296c0:	df000715 	stw	fp,28(sp)
 20296c4:	df000704 	addi	fp,sp,28
 20296c8:	e13ffd15 	stw	r4,-12(fp)
 20296cc:	e17ffe15 	stw	r5,-8(fp)
 20296d0:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  nb, * head, *  tail;
   int   tocopy;

   if (len == 0)  /* nothing to do */
 20296d4:	e0bfff17 	ldw	r2,-4(fp)
 20296d8:	1000021e 	bne	r2,zero,20296e4 <m_copy+0x2c>
      return NULL;
 20296dc:	0005883a 	mov	r2,zero
 20296e0:	0000ac06 	br	2029994 <m_copy+0x2dc>

#ifdef NPDEBUG
   /* sanity test parms */
   if (off < 0 || (len < 0 && len != M_COPYALL))
 20296e4:	e0bffe17 	ldw	r2,-8(fp)
 20296e8:	10000516 	blt	r2,zero,2029700 <m_copy+0x48>
 20296ec:	e0bfff17 	ldw	r2,-4(fp)
 20296f0:	1000170e 	bge	r2,zero,2029750 <m_copy+0x98>
 20296f4:	e0bfff17 	ldw	r2,-4(fp)
 20296f8:	10bfffe0 	cmpeqi	r2,r2,-1
 20296fc:	1000141e 	bne	r2,zero,2029750 <m_copy+0x98>
   {
      dtrap();
 2029700:	20285c80 	call	20285c8 <dtrap>
      return NULL;
 2029704:	0005883a 	mov	r2,zero
 2029708:	0000a206 	br	2029994 <m_copy+0x2dc>
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
   {
      if (!m)
 202970c:	e0bffd17 	ldw	r2,-12(fp)
 2029710:	1000031e 	bne	r2,zero,2029720 <m_copy+0x68>
      {
         dtrap();
 2029714:	20285c80 	call	20285c8 <dtrap>
         return NULL;
 2029718:	0005883a 	mov	r2,zero
 202971c:	00009d06 	br	2029994 <m_copy+0x2dc>
      }
      if (off < (int)m->m_len)
 2029720:	e0bffd17 	ldw	r2,-12(fp)
 2029724:	10800217 	ldw	r2,8(r2)
 2029728:	e0fffe17 	ldw	r3,-8(fp)
 202972c:	18800b16 	blt	r3,r2,202975c <m_copy+0xa4>
         break;
      off -= m->m_len;
 2029730:	e0fffe17 	ldw	r3,-8(fp)
 2029734:	e0bffd17 	ldw	r2,-12(fp)
 2029738:	10800217 	ldw	r2,8(r2)
 202973c:	1885c83a 	sub	r2,r3,r2
 2029740:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 2029744:	e0bffd17 	ldw	r2,-12(fp)
 2029748:	10800617 	ldw	r2,24(r2)
 202974c:	e0bffd15 	stw	r2,-12(fp)
      return NULL;
   }
#endif   /* NPDEBUG */

   /* move forward through mbuf q to "off" point */
   while (off > 0) 
 2029750:	e0bffe17 	ldw	r2,-8(fp)
 2029754:	00bfed16 	blt	zero,r2,202970c <m_copy+0x54>
 2029758:	00000106 	br	2029760 <m_copy+0xa8>
      {
         dtrap();
         return NULL;
      }
      if (off < (int)m->m_len)
         break;
 202975c:	0001883a 	nop
      off -= m->m_len;
      m = m->m_next;
   }

   head = tail = NULL;
 2029760:	e03ffb15 	stw	zero,-20(fp)
 2029764:	e0bffb17 	ldw	r2,-20(fp)
 2029768:	e0bffa15 	stw	r2,-24(fp)

   while (len > 0)
 202976c:	00007f06 	br	202996c <m_copy+0x2b4>
   {
      if (m == NULL) /* at end of queue? */
 2029770:	e0bffd17 	ldw	r2,-12(fp)
 2029774:	1000051e 	bne	r2,zero,202978c <m_copy+0xd4>
      {
         panic("m_copy: bad len");
 2029778:	01008174 	movhi	r4,517
 202977c:	213d3004 	addi	r4,r4,-2880
 2029780:	2026bf80 	call	2026bf8 <panic>
         return NULL;
 2029784:	0005883a 	mov	r2,zero
 2029788:	00008206 	br	2029994 <m_copy+0x2dc>
      }
      tocopy = (int)MIN(len, (int)(m->m_len - off));
 202978c:	e0bffd17 	ldw	r2,-12(fp)
 2029790:	10c00217 	ldw	r3,8(r2)
 2029794:	e0bffe17 	ldw	r2,-8(fp)
 2029798:	1885c83a 	sub	r2,r3,r2
 202979c:	e0ffff17 	ldw	r3,-4(fp)
 20297a0:	1880010e 	bge	r3,r2,20297a8 <m_copy+0xf0>
 20297a4:	1805883a 	mov	r2,r3
 20297a8:	e0bffc15 	stw	r2,-16(fp)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 20297ac:	e0bffe17 	ldw	r2,-8(fp)
 20297b0:	108000cc 	andi	r2,r2,3
 20297b4:	1000051e 	bne	r2,zero,20297cc <m_copy+0x114>
          (m->pkt->inuse != 1))
 20297b8:	e0bffd17 	ldw	r2,-12(fp)
 20297bc:	10800117 	ldw	r2,4(r2)
 20297c0:	10800917 	ldw	r2,36(r2)
       * ALIGN_TYPE, so if the offset isn't aligned, we must 
       * copy the buffer instead of cloning it.
       * Also, don't permit multiple clones; they sometimes
       * lead to corrupted data.
       */
      if ((off & (ALIGN_TYPE - 1)) ||
 20297c4:	10800060 	cmpeqi	r2,r2,1
 20297c8:	1000251e 	bne	r2,zero,2029860 <m_copy+0x1a8>
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
 20297cc:	e0bffd17 	ldw	r2,-12(fp)
 20297d0:	10800817 	ldw	r2,32(r2)
 20297d4:	1009883a 	mov	r4,r2
 20297d8:	e17ffc17 	ldw	r5,-16(fp)
 20297dc:	20293d80 	call	20293d8 <m_getnbuf>
 20297e0:	e0bff915 	stw	r2,-28(fp)
 20297e4:	e0bff917 	ldw	r2,-28(fp)
 20297e8:	10006426 	beq	r2,zero,202997c <m_copy+0x2c4>
            goto nospace;
         MEMCPY(nb->m_data, m->m_data+off, tocopy);
 20297ec:	e0bff917 	ldw	r2,-28(fp)
 20297f0:	11000317 	ldw	r4,12(r2)
 20297f4:	e0bffd17 	ldw	r2,-12(fp)
 20297f8:	10c00317 	ldw	r3,12(r2)
 20297fc:	e0bffe17 	ldw	r2,-8(fp)
 2029800:	1887883a 	add	r3,r3,r2
 2029804:	e0bffc17 	ldw	r2,-16(fp)
 2029808:	180b883a 	mov	r5,r3
 202980c:	100d883a 	mov	r6,r2
 2029810:	200660c0 	call	200660c <memcpy>
         nb->m_len = tocopy;  /* set length of data we just moved into new mbuf */
 2029814:	e0fffc17 	ldw	r3,-16(fp)
 2029818:	e0bff917 	ldw	r2,-28(fp)
 202981c:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mcopies++;
 2029820:	00809934 	movhi	r2,612
 2029824:	10b6f504 	addi	r2,r2,-9260
 2029828:	10802e17 	ldw	r2,184(r2)
 202982c:	10c00044 	addi	r3,r2,1
 2029830:	00809934 	movhi	r2,612
 2029834:	10b6f504 	addi	r2,r2,-9260
 2029838:	10c02e15 	stw	r3,184(r2)
         tcpstat.tcps_mcopiedbytes += tocopy;
 202983c:	00809934 	movhi	r2,612
 2029840:	10b6f504 	addi	r2,r2,-9260
 2029844:	10c03017 	ldw	r3,192(r2)
 2029848:	e0bffc17 	ldw	r2,-16(fp)
 202984c:	1887883a 	add	r3,r3,r2
 2029850:	00809934 	movhi	r2,612
 2029854:	10b6f504 	addi	r2,r2,-9260
 2029858:	10c03015 	stw	r3,192(r2)
 202985c:	00003106 	br	2029924 <m_copy+0x26c>
      {
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
 2029860:	e0bffd17 	ldw	r2,-12(fp)
 2029864:	10800817 	ldw	r2,32(r2)
 2029868:	1009883a 	mov	r4,r2
 202986c:	000b883a 	mov	r5,zero
 2029870:	20293d80 	call	20293d8 <m_getnbuf>
 2029874:	e0bff915 	stw	r2,-28(fp)
 2029878:	e0bff917 	ldw	r2,-28(fp)
 202987c:	10004126 	beq	r2,zero,2029984 <m_copy+0x2cc>
            goto nospace;

         m->pkt->inuse++;     /* bump pkt use count to clone it */
 2029880:	e0bffd17 	ldw	r2,-12(fp)
 2029884:	10800117 	ldw	r2,4(r2)
 2029888:	10c00917 	ldw	r3,36(r2)
 202988c:	18c00044 	addi	r3,r3,1
 2029890:	10c00915 	stw	r3,36(r2)

         /* set up new mbuf with pointers to cloned packet */
         nb->pkt = m->pkt;
 2029894:	e0bffd17 	ldw	r2,-12(fp)
 2029898:	10c00117 	ldw	r3,4(r2)
 202989c:	e0bff917 	ldw	r2,-28(fp)
 20298a0:	10c00115 	stw	r3,4(r2)
         nb->m_base = m->m_base;
 20298a4:	e0bffd17 	ldw	r2,-12(fp)
 20298a8:	10c00417 	ldw	r3,16(r2)
 20298ac:	e0bff917 	ldw	r2,-28(fp)
 20298b0:	10c00415 	stw	r3,16(r2)
         nb->m_memsz = m->m_memsz;
 20298b4:	e0bffd17 	ldw	r2,-12(fp)
 20298b8:	10c00517 	ldw	r3,20(r2)
 20298bc:	e0bff917 	ldw	r2,-28(fp)
 20298c0:	10c00515 	stw	r3,20(r2)
         nb->m_data = m->m_data + off;
 20298c4:	e0bffd17 	ldw	r2,-12(fp)
 20298c8:	10c00317 	ldw	r3,12(r2)
 20298cc:	e0bffe17 	ldw	r2,-8(fp)
 20298d0:	1887883a 	add	r3,r3,r2
 20298d4:	e0bff917 	ldw	r2,-28(fp)
 20298d8:	10c00315 	stw	r3,12(r2)
         nb->m_len = tocopy;
 20298dc:	e0fffc17 	ldw	r3,-16(fp)
 20298e0:	e0bff917 	ldw	r2,-28(fp)
 20298e4:	10c00215 	stw	r3,8(r2)

         tcpstat.tcps_mclones++;
 20298e8:	00809934 	movhi	r2,612
 20298ec:	10b6f504 	addi	r2,r2,-9260
 20298f0:	10802f17 	ldw	r2,188(r2)
 20298f4:	10c00044 	addi	r3,r2,1
 20298f8:	00809934 	movhi	r2,612
 20298fc:	10b6f504 	addi	r2,r2,-9260
 2029900:	10c02f15 	stw	r3,188(r2)
         tcpstat.tcps_mclonedbytes += tocopy;
 2029904:	00809934 	movhi	r2,612
 2029908:	10b6f504 	addi	r2,r2,-9260
 202990c:	10c03117 	ldw	r3,196(r2)
 2029910:	e0bffc17 	ldw	r2,-16(fp)
 2029914:	1887883a 	add	r3,r3,r2
 2029918:	00809934 	movhi	r2,612
 202991c:	10b6f504 	addi	r2,r2,-9260
 2029920:	10c03115 	stw	r3,196(r2)
      }

      len -= tocopy;
 2029924:	e0ffff17 	ldw	r3,-4(fp)
 2029928:	e0bffc17 	ldw	r2,-16(fp)
 202992c:	1885c83a 	sub	r2,r3,r2
 2029930:	e0bfff15 	stw	r2,-4(fp)
      off = 0;
 2029934:	e03ffe15 	stw	zero,-8(fp)
      if (tail)      /* head & tail are set by first pass thru loop */
 2029938:	e0bffb17 	ldw	r2,-20(fp)
 202993c:	10000426 	beq	r2,zero,2029950 <m_copy+0x298>
         tail->m_next = nb;
 2029940:	e0bffb17 	ldw	r2,-20(fp)
 2029944:	e0fff917 	ldw	r3,-28(fp)
 2029948:	10c00615 	stw	r3,24(r2)
 202994c:	00000206 	br	2029958 <m_copy+0x2a0>
      else
         head = nb;
 2029950:	e0bff917 	ldw	r2,-28(fp)
 2029954:	e0bffa15 	stw	r2,-24(fp)
      tail = nb;     /* always make new mbuf the tail */
 2029958:	e0bff917 	ldw	r2,-28(fp)
 202995c:	e0bffb15 	stw	r2,-20(fp)
      m = m->m_next;
 2029960:	e0bffd17 	ldw	r2,-12(fp)
 2029964:	10800617 	ldw	r2,24(r2)
 2029968:	e0bffd15 	stw	r2,-12(fp)
      m = m->m_next;
   }

   head = tail = NULL;

   while (len > 0)
 202996c:	e0bfff17 	ldw	r2,-4(fp)
 2029970:	00bf7f16 	blt	zero,r2,2029770 <m_copy+0xb8>
      tail = nb;     /* always make new mbuf the tail */
      m = m->m_next;

   }

   return head;
 2029974:	e0bffa17 	ldw	r2,-24(fp)
 2029978:	00000606 	br	2029994 <m_copy+0x2dc>
       */
      if ((off & (ALIGN_TYPE - 1)) ||
          (m->pkt->inuse != 1))
      {
         if ((nb = m_getwithdata (m->m_type, tocopy)) == NULL)
            goto nospace;
 202997c:	0001883a 	nop
 2029980:	00000106 	br	2029988 <m_copy+0x2d0>
         /* Rather than memcpy every mbuf's data, "clone" the data by 
          * making a duplicate of the mbufs involved and bumping the 
          * inuse count of the actual packet structs
          */
         if ((nb = m_getwithdata (m->m_type, 0)) == NULL)
            goto nospace;
 2029984:	0001883a 	nop
   }

   return head;

nospace:
   m_freem (head);
 2029988:	e13ffa17 	ldw	r4,-24(fp)
 202998c:	20296780 	call	2029678 <m_freem>
   return NULL;
 2029990:	0005883a 	mov	r2,zero
}
 2029994:	e037883a 	mov	sp,fp
 2029998:	dfc00117 	ldw	ra,4(sp)
 202999c:	df000017 	ldw	fp,0(sp)
 20299a0:	dec00204 	addi	sp,sp,8
 20299a4:	f800283a 	ret

020299a8 <m_adj>:
 * RETURNS: 
 */

void
m_adj(struct mbuf * mp, int len)
{
 20299a8:	defffb04 	addi	sp,sp,-20
 20299ac:	df000415 	stw	fp,16(sp)
 20299b0:	df000404 	addi	fp,sp,16
 20299b4:	e13ffe15 	stw	r4,-8(fp)
 20299b8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
 20299bc:	e0bffe17 	ldw	r2,-8(fp)
 20299c0:	e0bffc15 	stw	r2,-16(fp)
 20299c4:	e0bffc17 	ldw	r2,-16(fp)
 20299c8:	10006426 	beq	r2,zero,2029b5c <m_adj+0x1b4>
      return;

   if (len >= 0) 
 20299cc:	e0bfff17 	ldw	r2,-4(fp)
 20299d0:	10002316 	blt	r2,zero,2029a60 <m_adj+0xb8>
   {
      while (m != NULL && len > 0) 
 20299d4:	00001d06 	br	2029a4c <m_adj+0xa4>
      {
         if (m->m_len <= (unsigned)len)
 20299d8:	e0bffc17 	ldw	r2,-16(fp)
 20299dc:	10800217 	ldw	r2,8(r2)
 20299e0:	e0ffff17 	ldw	r3,-4(fp)
 20299e4:	18800b36 	bltu	r3,r2,2029a14 <m_adj+0x6c>
         {
            len -= m->m_len;
 20299e8:	e0ffff17 	ldw	r3,-4(fp)
 20299ec:	e0bffc17 	ldw	r2,-16(fp)
 20299f0:	10800217 	ldw	r2,8(r2)
 20299f4:	1885c83a 	sub	r2,r3,r2
 20299f8:	e0bfff15 	stw	r2,-4(fp)
            m->m_len = 0;
 20299fc:	e0bffc17 	ldw	r2,-16(fp)
 2029a00:	10000215 	stw	zero,8(r2)
            m = m->m_next;
 2029a04:	e0bffc17 	ldw	r2,-16(fp)
 2029a08:	10800617 	ldw	r2,24(r2)
 2029a0c:	e0bffc15 	stw	r2,-16(fp)
 2029a10:	00000e06 	br	2029a4c <m_adj+0xa4>
         }
         else
         {
            m->m_len -= len;
 2029a14:	e0bffc17 	ldw	r2,-16(fp)
 2029a18:	10c00217 	ldw	r3,8(r2)
 2029a1c:	e0bfff17 	ldw	r2,-4(fp)
 2029a20:	1887c83a 	sub	r3,r3,r2
 2029a24:	e0bffc17 	ldw	r2,-16(fp)
 2029a28:	10c00215 	stw	r3,8(r2)
            m->m_data += len;
 2029a2c:	e0bffc17 	ldw	r2,-16(fp)
 2029a30:	10c00317 	ldw	r3,12(r2)
 2029a34:	e0bfff17 	ldw	r2,-4(fp)
 2029a38:	1887883a 	add	r3,r3,r2
 2029a3c:	e0bffc17 	ldw	r2,-16(fp)
 2029a40:	10c00315 	stw	r3,12(r2)
            break;
 2029a44:	0001883a 	nop
 2029a48:	00004706 	br	2029b68 <m_adj+0x1c0>
   if ((m = mp) == NULL)
      return;

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 2029a4c:	e0bffc17 	ldw	r2,-16(fp)
 2029a50:	10004426 	beq	r2,zero,2029b64 <m_adj+0x1bc>
 2029a54:	e0bfff17 	ldw	r2,-4(fp)
 2029a58:	00bfdf16 	blt	zero,r2,20299d8 <m_adj+0x30>
 2029a5c:	00004106 	br	2029b64 <m_adj+0x1bc>
       * calculating its length and finding the last mbuf.
       * If the adjustment only affects this mbuf, then just
       * adjust and return.  Otherwise, rescan and truncate
       * after the remaining size.
       */
      len = -len;
 2029a60:	e0bfff17 	ldw	r2,-4(fp)
 2029a64:	0085c83a 	sub	r2,zero,r2
 2029a68:	e0bfff15 	stw	r2,-4(fp)
      count = 0;
 2029a6c:	e03ffd15 	stw	zero,-12(fp)
      for (;;) 
      {
         count += m->m_len;
 2029a70:	e0bffc17 	ldw	r2,-16(fp)
 2029a74:	10c00217 	ldw	r3,8(r2)
 2029a78:	e0bffd17 	ldw	r2,-12(fp)
 2029a7c:	1885883a 	add	r2,r3,r2
 2029a80:	e0bffd15 	stw	r2,-12(fp)
         if (m->m_next == (struct mbuf *)0)
 2029a84:	e0bffc17 	ldw	r2,-16(fp)
 2029a88:	10800617 	ldw	r2,24(r2)
 2029a8c:	10000426 	beq	r2,zero,2029aa0 <m_adj+0xf8>
            break;
         m = m->m_next;
 2029a90:	e0bffc17 	ldw	r2,-16(fp)
 2029a94:	10800617 	ldw	r2,24(r2)
 2029a98:	e0bffc15 	stw	r2,-16(fp)
      }
 2029a9c:	003ff406 	br	2029a70 <m_adj+0xc8>
      count = 0;
      for (;;) 
      {
         count += m->m_len;
         if (m->m_next == (struct mbuf *)0)
            break;
 2029aa0:	0001883a 	nop
         m = m->m_next;
      }
      if (m->m_len >= (unsigned)len)
 2029aa4:	e0bffc17 	ldw	r2,-16(fp)
 2029aa8:	10c00217 	ldw	r3,8(r2)
 2029aac:	e0bfff17 	ldw	r2,-4(fp)
 2029ab0:	18800736 	bltu	r3,r2,2029ad0 <m_adj+0x128>
      {
         m->m_len -= len;
 2029ab4:	e0bffc17 	ldw	r2,-16(fp)
 2029ab8:	10c00217 	ldw	r3,8(r2)
 2029abc:	e0bfff17 	ldw	r2,-4(fp)
 2029ac0:	1887c83a 	sub	r3,r3,r2
 2029ac4:	e0bffc17 	ldw	r2,-16(fp)
 2029ac8:	10c00215 	stw	r3,8(r2)
         return;
 2029acc:	00002606 	br	2029b68 <m_adj+0x1c0>
      }
      count -= len;
 2029ad0:	e0fffd17 	ldw	r3,-12(fp)
 2029ad4:	e0bfff17 	ldw	r2,-4(fp)
 2029ad8:	1885c83a 	sub	r2,r3,r2
 2029adc:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 2029ae0:	e0bffe17 	ldw	r2,-8(fp)
 2029ae4:	e0bffc15 	stw	r2,-16(fp)
 2029ae8:	00001106 	br	2029b30 <m_adj+0x188>
      {
         if (m->m_len >= (unsigned)count)
 2029aec:	e0bffc17 	ldw	r2,-16(fp)
 2029af0:	10c00217 	ldw	r3,8(r2)
 2029af4:	e0bffd17 	ldw	r2,-12(fp)
 2029af8:	18800536 	bltu	r3,r2,2029b10 <m_adj+0x168>
         {
            m->m_len = count;
 2029afc:	e0fffd17 	ldw	r3,-12(fp)
 2029b00:	e0bffc17 	ldw	r2,-16(fp)
 2029b04:	10c00215 	stw	r3,8(r2)
            break;
 2029b08:	0001883a 	nop
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 2029b0c:	00000d06 	br	2029b44 <m_adj+0x19c>
         if (m->m_len >= (unsigned)count)
         {
            m->m_len = count;
            break;
         }
         count -= m->m_len;
 2029b10:	e0fffd17 	ldw	r3,-12(fp)
 2029b14:	e0bffc17 	ldw	r2,-16(fp)
 2029b18:	10800217 	ldw	r2,8(r2)
 2029b1c:	1885c83a 	sub	r2,r3,r2
 2029b20:	e0bffd15 	stw	r2,-12(fp)
      /*
       * Correct length for chain is "count".
       * Find the mbuf with last data, adjust its length,
       * and toss data from remaining mbufs on chain.
       */
      for (m = mp; m; m = m->m_next)
 2029b24:	e0bffc17 	ldw	r2,-16(fp)
 2029b28:	10800617 	ldw	r2,24(r2)
 2029b2c:	e0bffc15 	stw	r2,-16(fp)
 2029b30:	e0bffc17 	ldw	r2,-16(fp)
 2029b34:	103fed1e 	bne	r2,zero,2029aec <m_adj+0x144>
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 2029b38:	00000206 	br	2029b44 <m_adj+0x19c>
         m->m_len = 0;
 2029b3c:	e0bffc17 	ldw	r2,-16(fp)
 2029b40:	10000215 	stw	zero,8(r2)
            m->m_len = count;
            break;
         }
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
 2029b44:	e0bffc17 	ldw	r2,-16(fp)
 2029b48:	10800617 	ldw	r2,24(r2)
 2029b4c:	e0bffc15 	stw	r2,-16(fp)
 2029b50:	e0bffc17 	ldw	r2,-16(fp)
 2029b54:	103ff91e 	bne	r2,zero,2029b3c <m_adj+0x194>
 2029b58:	00000306 	br	2029b68 <m_adj+0x1c0>
{
   struct mbuf *  m;
   int   count;

   if ((m = mp) == NULL)
      return;
 2029b5c:	0001883a 	nop
 2029b60:	00000106 	br	2029b68 <m_adj+0x1c0>

   if (len >= 0) 
   {
      while (m != NULL && len > 0) 
 2029b64:	0001883a 	nop
         count -= m->m_len;
      }
      while ((m = m->m_next) != (struct mbuf *)NULL)
         m->m_len = 0;
   }
}
 2029b68:	e037883a 	mov	sp,fp
 2029b6c:	df000017 	ldw	fp,0(sp)
 2029b70:	dec00104 	addi	sp,sp,4
 2029b74:	f800283a 	ret

02029b78 <mbuf_len>:
 * RETURNS: 
 */

int
mbuf_len (struct mbuf * m)
{
 2029b78:	defffd04 	addi	sp,sp,-12
 2029b7c:	df000215 	stw	fp,8(sp)
 2029b80:	df000204 	addi	fp,sp,8
 2029b84:	e13fff15 	stw	r4,-4(fp)
   int   len   =  0;
 2029b88:	e03ffe15 	stw	zero,-8(fp)

   while (m)
 2029b8c:	00000806 	br	2029bb0 <mbuf_len+0x38>
   {
      len += m->m_len;
 2029b90:	e0bfff17 	ldw	r2,-4(fp)
 2029b94:	10c00217 	ldw	r3,8(r2)
 2029b98:	e0bffe17 	ldw	r2,-8(fp)
 2029b9c:	1885883a 	add	r2,r3,r2
 2029ba0:	e0bffe15 	stw	r2,-8(fp)
      m = m->m_next;
 2029ba4:	e0bfff17 	ldw	r2,-4(fp)
 2029ba8:	10800617 	ldw	r2,24(r2)
 2029bac:	e0bfff15 	stw	r2,-4(fp)
int
mbuf_len (struct mbuf * m)
{
   int   len   =  0;

   while (m)
 2029bb0:	e0bfff17 	ldw	r2,-4(fp)
 2029bb4:	103ff61e 	bne	r2,zero,2029b90 <mbuf_len+0x18>
   {
      len += m->m_len;
      m = m->m_next;
   }
   return len;
 2029bb8:	e0bffe17 	ldw	r2,-8(fp)
}
 2029bbc:	e037883a 	mov	sp,fp
 2029bc0:	df000017 	ldw	fp,0(sp)
 2029bc4:	dec00104 	addi	sp,sp,4
 2029bc8:	f800283a 	ret

02029bcc <dtom>:
 * RETURNS: 
 */

struct mbuf *  
dtom(void * data)
{
 2029bcc:	defffb04 	addi	sp,sp,-20
 2029bd0:	dfc00415 	stw	ra,16(sp)
 2029bd4:	df000315 	stw	fp,12(sp)
 2029bd8:	df000304 	addi	fp,sp,12
 2029bdc:	e13fff15 	stw	r4,-4(fp)
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 2029be0:	00809934 	movhi	r2,612
 2029be4:	10b6d604 	addi	r2,r2,-9384
 2029be8:	10800017 	ldw	r2,0(r2)
 2029bec:	e0bffd15 	stw	r2,-12(fp)
 2029bf0:	00001206 	br	2029c3c <dtom+0x70>
   {
      m = (struct mbuf *)qptr;
 2029bf4:	e0bffd17 	ldw	r2,-12(fp)
 2029bf8:	e0bffe15 	stw	r2,-8(fp)

      if (IN_RANGE(m->m_base, m->m_memsz, (char*)data))
 2029bfc:	e0bffe17 	ldw	r2,-8(fp)
 2029c00:	10800417 	ldw	r2,16(r2)
 2029c04:	e0ffff17 	ldw	r3,-4(fp)
 2029c08:	18800936 	bltu	r3,r2,2029c30 <dtom+0x64>
 2029c0c:	e0bffe17 	ldw	r2,-8(fp)
 2029c10:	10c00417 	ldw	r3,16(r2)
 2029c14:	e0bffe17 	ldw	r2,-8(fp)
 2029c18:	10800517 	ldw	r2,20(r2)
 2029c1c:	1885883a 	add	r2,r3,r2
 2029c20:	e0ffff17 	ldw	r3,-4(fp)
 2029c24:	1880022e 	bgeu	r3,r2,2029c30 <dtom+0x64>
         return (struct mbuf *)qptr;
 2029c28:	e0bffd17 	ldw	r2,-12(fp)
 2029c2c:	00000906 	br	2029c54 <dtom+0x88>
dtom(void * data)
{
   qp qptr;
   struct mbuf *  m;

   for (qptr = mbufq.q_head; qptr; qptr = qptr->qe_next)
 2029c30:	e0bffd17 	ldw	r2,-12(fp)
 2029c34:	10800017 	ldw	r2,0(r2)
 2029c38:	e0bffd15 	stw	r2,-12(fp)
 2029c3c:	e0bffd17 	ldw	r2,-12(fp)
 2029c40:	103fec1e 	bne	r2,zero,2029bf4 <dtom+0x28>
      else
         continue;

   }

   panic("dtom");    /* data not found in any "in use" mbuf */
 2029c44:	01008174 	movhi	r4,517
 2029c48:	213d3404 	addi	r4,r4,-2864
 2029c4c:	2026bf80 	call	2026bf8 <panic>
   return NULL;
 2029c50:	0005883a 	mov	r2,zero
}
 2029c54:	e037883a 	mov	sp,fp
 2029c58:	dfc00117 	ldw	ra,4(sp)
 2029c5c:	df000017 	ldw	fp,0(sp)
 2029c60:	dec00204 	addi	sp,sp,8
 2029c64:	f800283a 	ret

02029c68 <remque>:
};


void
remque (void * arg)
{
 2029c68:	defffd04 	addi	sp,sp,-12
 2029c6c:	df000215 	stw	fp,8(sp)
 2029c70:	df000204 	addi	fp,sp,8
 2029c74:	e13fff15 	stw	r4,-4(fp)
   struct bsdq *  old;

   old = (struct bsdq *)arg;
 2029c78:	e0bfff17 	ldw	r2,-4(fp)
 2029c7c:	e0bffe15 	stw	r2,-8(fp)
   if (!old->prev) return;
 2029c80:	e0bffe17 	ldw	r2,-8(fp)
 2029c84:	10800117 	ldw	r2,4(r2)
 2029c88:	10000e26 	beq	r2,zero,2029cc4 <remque+0x5c>
      old->prev->next = old->next;
 2029c8c:	e0bffe17 	ldw	r2,-8(fp)
 2029c90:	10800117 	ldw	r2,4(r2)
 2029c94:	e0fffe17 	ldw	r3,-8(fp)
 2029c98:	18c00017 	ldw	r3,0(r3)
 2029c9c:	10c00015 	stw	r3,0(r2)
   if (old->next)
 2029ca0:	e0bffe17 	ldw	r2,-8(fp)
 2029ca4:	10800017 	ldw	r2,0(r2)
 2029ca8:	10000726 	beq	r2,zero,2029cc8 <remque+0x60>
      old->next->prev = old->prev;
 2029cac:	e0bffe17 	ldw	r2,-8(fp)
 2029cb0:	10800017 	ldw	r2,0(r2)
 2029cb4:	e0fffe17 	ldw	r3,-8(fp)
 2029cb8:	18c00117 	ldw	r3,4(r3)
 2029cbc:	10c00115 	stw	r3,4(r2)
 2029cc0:	00000106 	br	2029cc8 <remque+0x60>
remque (void * arg)
{
   struct bsdq *  old;

   old = (struct bsdq *)arg;
   if (!old->prev) return;
 2029cc4:	0001883a 	nop
      old->prev->next = old->next;
   if (old->next)
      old->next->prev = old->prev;
}
 2029cc8:	e037883a 	mov	sp,fp
 2029ccc:	df000017 	ldw	fp,0(sp)
 2029cd0:	dec00104 	addi	sp,sp,4
 2029cd4:	f800283a 	ret

02029cd8 <insque>:
 * RETURNS: 
 */

void
insque(void * n, void * p)
{
 2029cd8:	defffb04 	addi	sp,sp,-20
 2029cdc:	df000415 	stw	fp,16(sp)
 2029ce0:	df000404 	addi	fp,sp,16
 2029ce4:	e13ffe15 	stw	r4,-8(fp)
 2029ce8:	e17fff15 	stw	r5,-4(fp)
   struct bsdq *  newe, *  prev;

   newe = (struct bsdq *)n;
 2029cec:	e0bffe17 	ldw	r2,-8(fp)
 2029cf0:	e0bffc15 	stw	r2,-16(fp)
   prev = (struct bsdq *)p;
 2029cf4:	e0bfff17 	ldw	r2,-4(fp)
 2029cf8:	e0bffd15 	stw	r2,-12(fp)
   newe->next = prev->next;
 2029cfc:	e0bffd17 	ldw	r2,-12(fp)
 2029d00:	10c00017 	ldw	r3,0(r2)
 2029d04:	e0bffc17 	ldw	r2,-16(fp)
 2029d08:	10c00015 	stw	r3,0(r2)
   newe->prev = prev;
 2029d0c:	e0bffc17 	ldw	r2,-16(fp)
 2029d10:	e0fffd17 	ldw	r3,-12(fp)
 2029d14:	10c00115 	stw	r3,4(r2)
   prev->next = newe;
 2029d18:	e0bffd17 	ldw	r2,-12(fp)
 2029d1c:	e0fffc17 	ldw	r3,-16(fp)
 2029d20:	10c00015 	stw	r3,0(r2)
   if (newe->next)
 2029d24:	e0bffc17 	ldw	r2,-16(fp)
 2029d28:	10800017 	ldw	r2,0(r2)
 2029d2c:	10000426 	beq	r2,zero,2029d40 <insque+0x68>
      newe->next->prev = newe;
 2029d30:	e0bffc17 	ldw	r2,-16(fp)
 2029d34:	10800017 	ldw	r2,0(r2)
 2029d38:	e0fffc17 	ldw	r3,-16(fp)
 2029d3c:	10c00115 	stw	r3,4(r2)
}
 2029d40:	e037883a 	mov	sp,fp
 2029d44:	df000017 	ldw	fp,0(sp)
 2029d48:	dec00104 	addi	sp,sp,4
 2029d4c:	f800283a 	ret

02029d50 <nptcp_init>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
nptcp_init()
{
 2029d50:	defffb04 	addi	sp,sp,-20
 2029d54:	dfc00415 	stw	ra,16(sp)
 2029d58:	df000315 	stw	fp,12(sp)
 2029d5c:	df000304 	addi	fp,sp,12
    * buffers, soreceive() can't complete and the packet buffers stay 
    * on the queue, so we allocate 3 extra mbufs in the hope that 
    * this will allow soreceive() to complete and free up the packet 
    * buffers. yes, its kind of an ugly hack and 3 is a wild guess.
    */
   unsigned bufcount = (lilbufs + bigbufs) * 2 + 3;
 2029d60:	00808174 	movhi	r2,517
 2029d64:	10906604 	addi	r2,r2,16792
 2029d68:	10c00017 	ldw	r3,0(r2)
 2029d6c:	00808174 	movhi	r2,517
 2029d70:	10906804 	addi	r2,r2,16800
 2029d74:	10800017 	ldw	r2,0(r2)
 2029d78:	1885883a 	add	r2,r3,r2
 2029d7c:	1085883a 	add	r2,r2,r2
 2029d80:	108000c4 	addi	r2,r2,3
 2029d84:	e0bffe15 	stw	r2,-8(fp)
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
 2029d88:	01009934 	movhi	r4,612
 2029d8c:	2136c204 	addi	r4,r4,-9464
 2029d90:	000b883a 	mov	r5,zero
 2029d94:	01800504 	movi	r6,20
 2029d98:	200682c0 	call	200682c <memset>
   MEMSET(&mbufq, 0, sizeof(mbufq));
 2029d9c:	01009934 	movhi	r4,612
 2029da0:	2136d604 	addi	r4,r4,-9384
 2029da4:	000b883a 	mov	r5,zero
 2029da8:	01800504 	movi	r6,20
 2029dac:	200682c0 	call	200682c <memset>
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
 2029db0:	01009934 	movhi	r4,612
 2029db4:	2136db04 	addi	r4,r4,-9364
 2029db8:	000b883a 	mov	r5,zero
 2029dbc:	01800504 	movi	r6,20
 2029dc0:	200682c0 	call	200682c <memset>
   for (i = 0; i < (int)bufcount; i++)
 2029dc4:	e03ffd15 	stw	zero,-12(fp)
 2029dc8:	00001506 	br	2029e20 <nptcp_init+0xd0>
   {
      m = MBU_ALLOC(sizeof(struct mbuf));
 2029dcc:	01000904 	movi	r4,36
 2029dd0:	20290400 	call	2029040 <npalloc>
 2029dd4:	e0bfff15 	stw	r2,-4(fp)
      if (!m)  /* malloc error, bail out */
 2029dd8:	e0bfff17 	ldw	r2,-4(fp)
 2029ddc:	1000031e 	bne	r2,zero,2029dec <nptcp_init+0x9c>
         panic("tcpinit");
 2029de0:	01008174 	movhi	r4,517
 2029de4:	213d3604 	addi	r4,r4,-2856
 2029de8:	2026bf80 	call	2026bf8 <panic>
      m->m_type = MT_FREE;
 2029dec:	e0bfff17 	ldw	r2,-4(fp)
 2029df0:	10000815 	stw	zero,32(r2)
      m->m_len = 0;
 2029df4:	e0bfff17 	ldw	r2,-4(fp)
 2029df8:	10000215 	stw	zero,8(r2)
      m->m_data = NULL;
 2029dfc:	e0bfff17 	ldw	r2,-4(fp)
 2029e00:	10000315 	stw	zero,12(r2)
      putq(&mfreeq, (qp)m);
 2029e04:	01009934 	movhi	r4,612
 2029e08:	2136db04 	addi	r4,r4,-9364
 2029e0c:	e17fff17 	ldw	r5,-4(fp)
 2029e10:	20282880 	call	2028288 <putq>
   struct mbuf *  m; /* scratch mbuf for mfreeq init */

   MEMSET(&soq, 0, sizeof(soq));    /* Set socket queue to NULLs */
   MEMSET(&mbufq, 0, sizeof(mbufq));
   MEMSET(&mfreeq, 0, sizeof(mfreeq));
   for (i = 0; i < (int)bufcount; i++)
 2029e14:	e0bffd17 	ldw	r2,-12(fp)
 2029e18:	10800044 	addi	r2,r2,1
 2029e1c:	e0bffd15 	stw	r2,-12(fp)
 2029e20:	e0bffe17 	ldw	r2,-8(fp)
 2029e24:	e0fffd17 	ldw	r3,-12(fp)
 2029e28:	18bfe816 	blt	r3,r2,2029dcc <nptcp_init+0x7c>
      m->m_type = MT_FREE;
      m->m_len = 0;
      m->m_data = NULL;
      putq(&mfreeq, (qp)m);
   }
   mfreeq.q_min = (int)bufcount;   /* this should match q_max and q_len */
 2029e2c:	e0fffe17 	ldw	r3,-8(fp)
 2029e30:	00809934 	movhi	r2,612
 2029e34:	10b6db04 	addi	r2,r2,-9364
 2029e38:	10c00415 	stw	r3,16(r2)
   tcpmib.tcpRtoAlgorithm = 4;     /* Van Jacobson's algorithm */
   tcpmib.tcpRtoMin = TCPTV_MIN * 1000;      /* PR_SLOWHZ */
   tcpmib.tcpRtoMax = TCPTV_REXMTMAX * 1000; /* PR_SLOWHZ */
#endif

   tcp_init();    /* call the BSD init in tcp_usr.c */
 2029e3c:	20346000 	call	2034600 <tcp_init>

#ifdef TCP_MENUS
   install_menu(&tcpmenu[0]);
#endif   /* IN_MENUS */

   return 0;   /* good return */
 2029e40:	0005883a 	mov	r2,zero
}
 2029e44:	e037883a 	mov	sp,fp
 2029e48:	dfc00117 	ldw	ra,4(sp)
 2029e4c:	df000017 	ldw	fp,0(sp)
 2029e50:	dec00204 	addi	sp,sp,8
 2029e54:	f800283a 	ret

02029e58 <tcp_rcv>:

#ifdef IP_V4
 
int
tcp_rcv(PACKET pkt)     /* NOTE: pkt has nb_prot pointing to IP header */
{
 2029e58:	defff904 	addi	sp,sp,-28
 2029e5c:	dfc00615 	stw	ra,24(sp)
 2029e60:	df000515 	stw	fp,20(sp)
 2029e64:	df000504 	addi	fp,sp,20
 2029e68:	e13fff15 	stw	r4,-4(fp)

   /* For TCP, the netport IP layer is modified to set nb_prot to the 
    * start of the IP header (not TCP). We need to do some further
    * mods which the BSD code expects:
    */
   bip = (struct ip *)pkt->nb_prot;    /* get ip header */
 2029e6c:	e0bfff17 	ldw	r2,-4(fp)
 2029e70:	10800317 	ldw	r2,12(r2)
 2029e74:	e0bffb15 	stw	r2,-20(fp)
   len = ntohs(bip->ip_len);  /* get length in local endian */
 2029e78:	e0bffb17 	ldw	r2,-20(fp)
 2029e7c:	1080008b 	ldhu	r2,2(r2)
 2029e80:	10bfffcc 	andi	r2,r2,65535
 2029e84:	1004d23a 	srli	r2,r2,8
 2029e88:	1007883a 	mov	r3,r2
 2029e8c:	e0bffb17 	ldw	r2,-20(fp)
 2029e90:	1080008b 	ldhu	r2,2(r2)
 2029e94:	10bfffcc 	andi	r2,r2,65535
 2029e98:	1004923a 	slli	r2,r2,8
 2029e9c:	1884b03a 	or	r2,r3,r2
 2029ea0:	e0bffc0d 	sth	r2,-16(fp)

   /* verify checksum of received packet */

   tcpp = (struct tcphdr *)ip_data(bip);
 2029ea4:	e0bffb17 	ldw	r2,-20(fp)
 2029ea8:	10800003 	ldbu	r2,0(r2)
 2029eac:	10803fcc 	andi	r2,r2,255
 2029eb0:	108003cc 	andi	r2,r2,15
 2029eb4:	1085883a 	add	r2,r2,r2
 2029eb8:	1085883a 	add	r2,r2,r2
 2029ebc:	e0fffb17 	ldw	r3,-20(fp)
 2029ec0:	1885883a 	add	r2,r3,r2
 2029ec4:	e0bffd15 	stw	r2,-12(fp)
   if (tcp_cksum(bip) != tcpp->th_sum)
 2029ec8:	e13ffb17 	ldw	r4,-20(fp)
 2029ecc:	20480ac0 	call	20480ac <tcp_cksum>
 2029ed0:	e0fffd17 	ldw	r3,-12(fp)
 2029ed4:	1900040b 	ldhu	r4,16(r3)
 2029ed8:	10ffffcc 	andi	r3,r2,65535
 2029edc:	20bfffcc 	andi	r2,r4,65535
 2029ee0:	18801626 	beq	r3,r2,2029f3c <tcp_rcv+0xe4>
   {
      TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 2029ee4:	00809934 	movhi	r2,612
 2029ee8:	10b6c704 	addi	r2,r2,-9444
 2029eec:	10800d17 	ldw	r2,52(r2)
 2029ef0:	10c00044 	addi	r3,r2,1
 2029ef4:	00809934 	movhi	r2,612
 2029ef8:	10b6c704 	addi	r2,r2,-9444
 2029efc:	10c00d15 	stw	r3,52(r2)
      tcpstat.tcps_rcvbadsum++;  /* keep BSD stats */
 2029f00:	00809934 	movhi	r2,612
 2029f04:	10b6f504 	addi	r2,r2,-9260
 2029f08:	10801c17 	ldw	r2,112(r2)
 2029f0c:	10c00044 	addi	r3,r2,1
 2029f10:	00809934 	movhi	r2,612
 2029f14:	10b6f504 	addi	r2,r2,-9260
 2029f18:	10c01c15 	stw	r3,112(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2029f1c:	01000084 	movi	r4,2
 2029f20:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);  /* punt packet */
 2029f24:	e13fff17 	ldw	r4,-4(fp)
 2029f28:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2029f2c:	01000084 	movi	r4,2
 2029f30:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 2029f34:	00bff804 	movi	r2,-32
 2029f38:	00003306 	br	202a008 <tcp_rcv+0x1b0>
   }

   m_in = m_getnbuf(MT_RXDATA, 0);
 2029f3c:	01000044 	movi	r4,1
 2029f40:	000b883a 	mov	r5,zero
 2029f44:	20293d80 	call	20293d8 <m_getnbuf>
 2029f48:	e0bffe15 	stw	r2,-8(fp)
   if (!m_in){
 2029f4c:	e0bffe17 	ldw	r2,-8(fp)
 2029f50:	1000081e 	bne	r2,zero,2029f74 <tcp_rcv+0x11c>
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2029f54:	01000084 	movi	r4,2
 2029f58:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 2029f5c:	e13fff17 	ldw	r4,-4(fp)
 2029f60:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2029f64:	01000084 	movi	r4,2
 2029f68:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;  
 2029f6c:	00bffa84 	movi	r2,-22
 2029f70:	00002506 	br	202a008 <tcp_rcv+0x1b0>
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);      /* measure time in TCP */

   /* subtract IP header length from total IP packet length */
   len -= ((unshort)(bip->ip_ver_ihl & 0x0f) << 2);
 2029f74:	e0bffb17 	ldw	r2,-20(fp)
 2029f78:	10800003 	ldbu	r2,0(r2)
 2029f7c:	10803fcc 	andi	r2,r2,255
 2029f80:	108003cc 	andi	r2,r2,15
 2029f84:	1085883a 	add	r2,r2,r2
 2029f88:	1085883a 	add	r2,r2,r2
 2029f8c:	e0fffc0b 	ldhu	r3,-16(fp)
 2029f90:	1885c83a 	sub	r2,r3,r2
 2029f94:	e0bffc0d 	sth	r2,-16(fp)
   bip->ip_len = len;   /* put TCP length in struct for TCP code to use */
 2029f98:	e0bffb17 	ldw	r2,-20(fp)
 2029f9c:	e0fffc0b 	ldhu	r3,-16(fp)
 2029fa0:	10c0008d 	sth	r3,2(r2)

   /* set mbuf to point to start of IP header (not TCP) */
   m_in->pkt = pkt;
 2029fa4:	e0bffe17 	ldw	r2,-8(fp)
 2029fa8:	e0ffff17 	ldw	r3,-4(fp)
 2029fac:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 2029fb0:	e0bfff17 	ldw	r2,-4(fp)
 2029fb4:	10c00317 	ldw	r3,12(r2)
 2029fb8:	e0bffe17 	ldw	r2,-8(fp)
 2029fbc:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 2029fc0:	e0bfff17 	ldw	r2,-4(fp)
 2029fc4:	10c00417 	ldw	r3,16(r2)
 2029fc8:	e0bffe17 	ldw	r2,-8(fp)
 2029fcc:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;     /* ??? */
 2029fd0:	e0bfff17 	ldw	r2,-4(fp)
 2029fd4:	10c00117 	ldw	r3,4(r2)
 2029fd8:	e0bffe17 	ldw	r2,-8(fp)
 2029fdc:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;    /* ??? */
 2029fe0:	e0bfff17 	ldw	r2,-4(fp)
 2029fe4:	10c00217 	ldw	r3,8(r2)
 2029fe8:	e0bffe17 	ldw	r2,-8(fp)
 2029fec:	10c00515 	stw	r3,20(r2)

   tcp_input(m_in, pkt->net);
 2029ff0:	e0bfff17 	ldw	r2,-4(fp)
 2029ff4:	10800617 	ldw	r2,24(r2)
 2029ff8:	e13ffe17 	ldw	r4,-8(fp)
 2029ffc:	100b883a 	mov	r5,r2
 202a000:	2030a680 	call	2030a68 <tcp_input>

   IN_PROFILER(PF_TCP, PF_EXIT);      /* measure time in TCP */

   return 0;
 202a004:	0005883a 	mov	r2,zero
}
 202a008:	e037883a 	mov	sp,fp
 202a00c:	dfc00117 	ldw	ra,4(sp)
 202a010:	df000017 	ldw	fp,0(sp)
 202a014:	dec00204 	addi	sp,sp,8
 202a018:	f800283a 	ret

0202a01c <ip_output>:
 * RETURNS: 
 */

int
ip_output(struct mbuf * data, struct   ip_socopts * so_optsPack) /* mbuf chain with data to send */
{
 202a01c:	defff404 	addi	sp,sp,-48
 202a020:	dfc00b15 	stw	ra,44(sp)
 202a024:	df000a15 	stw	fp,40(sp)
 202a028:	df000a04 	addi	fp,sp,40
 202a02c:	e13ffe15 	stw	r4,-8(fp)
 202a030:	e17fff15 	stw	r5,-4(fp)
    * little copying as possible. Typically the mbufs will be either 
    * 1) a single mbuf with iptcp header info only (e.g.tcp ACK 
    * packet), or 2) iptcp header with data mbuf chained to it, or 3) 
    * #2) with a tiny option data mbuf between header and data. 
    */
   if ((data->m_next))
 202a034:	e0bffe17 	ldw	r2,-8(fp)
 202a038:	10800617 	ldw	r2,24(r2)
 202a03c:	10010f26 	beq	r2,zero,202a47c <ip_output+0x460>
   {
      m1 = data;
 202a040:	e0bffe17 	ldw	r2,-8(fp)
 202a044:	e0bff615 	stw	r2,-40(fp)
      m2 = data->m_next;
 202a048:	e0bffe17 	ldw	r2,-8(fp)
 202a04c:	10800617 	ldw	r2,24(r2)
 202a050:	e0bff715 	stw	r2,-36(fp)

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 202a054:	00003406 	br	202a128 <ip_output+0x10c>
      {
         pkt = m1->pkt;
 202a058:	e0bff617 	ldw	r2,-40(fp)
 202a05c:	10800117 	ldw	r2,4(r2)
 202a060:	e0bffa15 	stw	r2,-24(fp)
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 202a064:	e0bffa17 	ldw	r2,-24(fp)
 202a068:	10c00117 	ldw	r3,4(r2)
 202a06c:	e0bffa17 	ldw	r2,-24(fp)
 202a070:	10800217 	ldw	r2,8(r2)
 202a074:	1885883a 	add	r2,r3,r2
             (m1->m_data + m1->m_len + m2->m_len))
 202a078:	e0fff617 	ldw	r3,-40(fp)
 202a07c:	19000317 	ldw	r4,12(r3)
 202a080:	e0fff617 	ldw	r3,-40(fp)
 202a084:	19400217 	ldw	r5,8(r3)
 202a088:	e0fff717 	ldw	r3,-36(fp)
 202a08c:	18c00217 	ldw	r3,8(r3)
 202a090:	28c7883a 	add	r3,r5,r3
 202a094:	20c7883a 	add	r3,r4,r3

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
      {
         pkt = m1->pkt;
         if ((pkt->nb_buff + pkt->nb_blen) > /* make sure m2 will fit in m1 */
 202a098:	18802a2e 	bgeu	r3,r2,202a144 <ip_output+0x128>
             (m1->m_data + m1->m_len + m2->m_len))
         {
            MEMCPY((m1->m_data + m1->m_len), m2->m_data, m2->m_len);
 202a09c:	e0bff617 	ldw	r2,-40(fp)
 202a0a0:	10c00317 	ldw	r3,12(r2)
 202a0a4:	e0bff617 	ldw	r2,-40(fp)
 202a0a8:	10800217 	ldw	r2,8(r2)
 202a0ac:	1889883a 	add	r4,r3,r2
 202a0b0:	e0bff717 	ldw	r2,-36(fp)
 202a0b4:	10c00317 	ldw	r3,12(r2)
 202a0b8:	e0bff717 	ldw	r2,-36(fp)
 202a0bc:	10800217 	ldw	r2,8(r2)
 202a0c0:	180b883a 	mov	r5,r3
 202a0c4:	100d883a 	mov	r6,r2
 202a0c8:	200660c0 	call	200660c <memcpy>
            m1->m_len += m2->m_len;
 202a0cc:	e0bff617 	ldw	r2,-40(fp)
 202a0d0:	10c00217 	ldw	r3,8(r2)
 202a0d4:	e0bff717 	ldw	r2,-36(fp)
 202a0d8:	10800217 	ldw	r2,8(r2)
 202a0dc:	1887883a 	add	r3,r3,r2
 202a0e0:	e0bff617 	ldw	r2,-40(fp)
 202a0e4:	10c00215 	stw	r3,8(r2)
            m1->m_next = m2->m_next;
 202a0e8:	e0bff717 	ldw	r2,-36(fp)
 202a0ec:	10c00617 	ldw	r3,24(r2)
 202a0f0:	e0bff617 	ldw	r2,-40(fp)
 202a0f4:	10c00615 	stw	r3,24(r2)
            m_free(m2);    /* free this m2.... */
 202a0f8:	e13ff717 	ldw	r4,-36(fp)
 202a0fc:	20295600 	call	2029560 <m_free>
            m2 = m1->m_next;  /* ...and thread the next one */
 202a100:	e0bff617 	ldw	r2,-40(fp)
 202a104:	10800617 	ldw	r2,24(r2)
 202a108:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oappends++;
 202a10c:	00809934 	movhi	r2,612
 202a110:	10b6f504 	addi	r2,r2,-9260
 202a114:	10803317 	ldw	r2,204(r2)
 202a118:	10c00044 	addi	r3,r2,1
 202a11c:	00809934 	movhi	r2,612
 202a120:	10b6f504 	addi	r2,r2,-9260
 202a124:	10c03315 	stw	r3,204(r2)
   {
      m1 = data;
      m2 = data->m_next;

      /* If m2 is small (e.g. options), copy it to m1 and free it */
      while (m2 && (m2->m_len < 10))
 202a128:	e0bff717 	ldw	r2,-36(fp)
 202a12c:	10006026 	beq	r2,zero,202a2b0 <ip_output+0x294>
 202a130:	e0bff717 	ldw	r2,-36(fp)
 202a134:	10800217 	ldw	r2,8(r2)
 202a138:	108002b0 	cmpltui	r2,r2,10
 202a13c:	103fc61e 	bne	r2,zero,202a058 <ip_output+0x3c>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 202a140:	00005b06 	br	202a2b0 <ip_output+0x294>
            m_free(m2);    /* free this m2.... */
            m2 = m1->m_next;  /* ...and thread the next one */
            tcpstat.tcps_oappends++;
         }
         else     /* if won't fit, fall to next copy */
            break;
 202a144:	0001883a 	nop
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 202a148:	00005906 	br	202a2b0 <ip_output+0x294>
      {
         /* try prepending m1 to m2, first see if it fits: */
         e = m2->m_data - m2->pkt->nb_buff;  /* e is prepend space */
 202a14c:	e0bff717 	ldw	r2,-36(fp)
 202a150:	10800317 	ldw	r2,12(r2)
 202a154:	1007883a 	mov	r3,r2
 202a158:	e0bff717 	ldw	r2,-36(fp)
 202a15c:	10800117 	ldw	r2,4(r2)
 202a160:	10800117 	ldw	r2,4(r2)
 202a164:	1885c83a 	sub	r2,r3,r2
 202a168:	e0bffb15 	stw	r2,-20(fp)
         if (e < MaxLnh)
 202a16c:	00808174 	movhi	r2,517
 202a170:	1090b004 	addi	r2,r2,17088
 202a174:	10800017 	ldw	r2,0(r2)
 202a178:	e0fffb17 	ldw	r3,-20(fp)
 202a17c:	18800b0e 	bge	r3,r2,202a1ac <ip_output+0x190>
         { 
#ifdef NPDEBUG
            dprintf("nptcp: MaxLnh:%d, e:%d\n", MaxLnh, e);
 202a180:	00808174 	movhi	r2,517
 202a184:	1090b004 	addi	r2,r2,17088
 202a188:	10800017 	ldw	r2,0(r2)
 202a18c:	01008174 	movhi	r4,517
 202a190:	213d3804 	addi	r4,r4,-2848
 202a194:	100b883a 	mov	r5,r2
 202a198:	e1bffb17 	ldw	r6,-20(fp)
 202a19c:	2006a240 	call	2006a24 <printf>
#endif
            panic("tcp_out:mbuf-nbuf");   /* sanity check */
 202a1a0:	01008174 	movhi	r4,517
 202a1a4:	213d3e04 	addi	r4,r4,-2824
 202a1a8:	2026bf80 	call	2026bf8 <panic>
         }

         if ((m1->m_len < (unsigned)(e - MaxLnh))  /* leave room for MAC */
 202a1ac:	e0bff617 	ldw	r2,-40(fp)
 202a1b0:	10c00217 	ldw	r3,8(r2)
 202a1b4:	00808174 	movhi	r2,517
 202a1b8:	1090b004 	addi	r2,r2,17088
 202a1bc:	10800017 	ldw	r2,0(r2)
 202a1c0:	e13ffb17 	ldw	r4,-20(fp)
 202a1c4:	2085c83a 	sub	r2,r4,r2
 202a1c8:	18803b2e 	bgeu	r3,r2,202a2b8 <ip_output+0x29c>
             && ((m1->m_len & (ALIGN_TYPE - 1)) == 0)  /* and stay aligned */
 202a1cc:	e0bff617 	ldw	r2,-40(fp)
 202a1d0:	10800217 	ldw	r2,8(r2)
 202a1d4:	108000cc 	andi	r2,r2,3
 202a1d8:	1000371e 	bne	r2,zero,202a2b8 <ip_output+0x29c>
             && ((m2->m_data - m2->pkt->nb_buff) == HDRSLEN))   /* be at start */
 202a1dc:	e0bff717 	ldw	r2,-36(fp)
 202a1e0:	10800317 	ldw	r2,12(r2)
 202a1e4:	1007883a 	mov	r3,r2
 202a1e8:	e0bff717 	ldw	r2,-36(fp)
 202a1ec:	10800117 	ldw	r2,4(r2)
 202a1f0:	10800117 	ldw	r2,4(r2)
 202a1f4:	1885c83a 	sub	r2,r3,r2
 202a1f8:	10800e18 	cmpnei	r2,r2,56
 202a1fc:	10002e1e 	bne	r2,zero,202a2b8 <ip_output+0x29c>
         {
            MEMCPY((m2->m_data - m1->m_len), m1->m_data, m1->m_len);
 202a200:	e0bff717 	ldw	r2,-36(fp)
 202a204:	10c00317 	ldw	r3,12(r2)
 202a208:	e0bff617 	ldw	r2,-40(fp)
 202a20c:	10800217 	ldw	r2,8(r2)
 202a210:	0085c83a 	sub	r2,zero,r2
 202a214:	1889883a 	add	r4,r3,r2
 202a218:	e0bff617 	ldw	r2,-40(fp)
 202a21c:	10c00317 	ldw	r3,12(r2)
 202a220:	e0bff617 	ldw	r2,-40(fp)
 202a224:	10800217 	ldw	r2,8(r2)
 202a228:	180b883a 	mov	r5,r3
 202a22c:	100d883a 	mov	r6,r2
 202a230:	200660c0 	call	200660c <memcpy>
            m2->m_data -= m1->m_len;   /* fix target to reflect prepend */
 202a234:	e0bff717 	ldw	r2,-36(fp)
 202a238:	10c00317 	ldw	r3,12(r2)
 202a23c:	e0bff617 	ldw	r2,-40(fp)
 202a240:	10800217 	ldw	r2,8(r2)
 202a244:	0085c83a 	sub	r2,zero,r2
 202a248:	1887883a 	add	r3,r3,r2
 202a24c:	e0bff717 	ldw	r2,-36(fp)
 202a250:	10c00315 	stw	r3,12(r2)
            m2->m_len += m1->m_len;
 202a254:	e0bff717 	ldw	r2,-36(fp)
 202a258:	10c00217 	ldw	r3,8(r2)
 202a25c:	e0bff617 	ldw	r2,-40(fp)
 202a260:	10800217 	ldw	r2,8(r2)
 202a264:	1887883a 	add	r3,r3,r2
 202a268:	e0bff717 	ldw	r2,-36(fp)
 202a26c:	10c00215 	stw	r3,8(r2)
            m_free(m1);    /* free head (copied) mbuf */
 202a270:	e13ff617 	ldw	r4,-40(fp)
 202a274:	20295600 	call	2029560 <m_free>
            data = m1 = m2;   /* move other mbufs up the chain */
 202a278:	e0bff717 	ldw	r2,-36(fp)
 202a27c:	e0bff615 	stw	r2,-40(fp)
 202a280:	e0bff617 	ldw	r2,-40(fp)
 202a284:	e0bffe15 	stw	r2,-8(fp)
            m2 = m2->m_next;  /* loop to while(m2) test */
 202a288:	e0bff717 	ldw	r2,-36(fp)
 202a28c:	10800617 	ldw	r2,24(r2)
 202a290:	e0bff715 	stw	r2,-36(fp)
            tcpstat.tcps_oprepends++;
 202a294:	00809934 	movhi	r2,612
 202a298:	10b6f504 	addi	r2,r2,-9260
 202a29c:	10803217 	ldw	r2,200(r2)
 202a2a0:	10c00044 	addi	r3,r2,1
 202a2a4:	00809934 	movhi	r2,612
 202a2a8:	10b6f504 	addi	r2,r2,-9260
 202a2ac:	10c03215 	stw	r3,200(r2)
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      while (m2)  /* If we still have two or more buffers, more copying: */
 202a2b0:	e0bff717 	ldw	r2,-36(fp)
 202a2b4:	103fa51e 	bne	r2,zero,202a14c <ip_output+0x130>
         }
         else     /* if won't fit, fall to next copy */
            break;
      }

      if (m2)  /* If all else fails, brute force copy: */
 202a2b8:	e0bff717 	ldw	r2,-36(fp)
 202a2bc:	10006f26 	beq	r2,zero,202a47c <ip_output+0x460>
      {
         total = 0;
 202a2c0:	e03ff915 	stw	zero,-28(fp)
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 202a2c4:	e0bff617 	ldw	r2,-40(fp)
 202a2c8:	e0bff815 	stw	r2,-32(fp)
 202a2cc:	00000806 	br	202a2f0 <ip_output+0x2d4>
            total += mtmp->m_len;
 202a2d0:	e0bff817 	ldw	r2,-32(fp)
 202a2d4:	10c00217 	ldw	r3,8(r2)
 202a2d8:	e0bff917 	ldw	r2,-28(fp)
 202a2dc:	1885883a 	add	r2,r3,r2
 202a2e0:	e0bff915 	stw	r2,-28(fp)
      }

      if (m2)  /* If all else fails, brute force copy: */
      {
         total = 0;
         for (mtmp = m1; mtmp; mtmp = mtmp->m_next)
 202a2e4:	e0bff817 	ldw	r2,-32(fp)
 202a2e8:	10800617 	ldw	r2,24(r2)
 202a2ec:	e0bff815 	stw	r2,-32(fp)
 202a2f0:	e0bff817 	ldw	r2,-32(fp)
 202a2f4:	103ff61e 	bne	r2,zero,202a2d0 <ip_output+0x2b4>
            total += mtmp->m_len;
         LOCK_NET_RESOURCE(FREEQ_RESID);
 202a2f8:	01000084 	movi	r4,2
 202a2fc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pkt = pk_alloc(total + HDRSLEN);
 202a300:	e0bff917 	ldw	r2,-28(fp)
 202a304:	10800e04 	addi	r2,r2,56
 202a308:	1009883a 	mov	r4,r2
 202a30c:	2027cec0 	call	2027cec <pk_alloc>
 202a310:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 202a314:	01000084 	movi	r4,2
 202a318:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         if (!pkt)
 202a31c:	e0bffa17 	ldw	r2,-24(fp)
 202a320:	1000021e 	bne	r2,zero,202a32c <ip_output+0x310>
            return ENOBUFS;
 202a324:	00801a44 	movi	r2,105
 202a328:	0000a806 	br	202a5cc <ip_output+0x5b0>
         pkt->nb_prot = pkt->nb_buff + MaxLnh;
 202a32c:	e0bffa17 	ldw	r2,-24(fp)
 202a330:	10c00117 	ldw	r3,4(r2)
 202a334:	00808174 	movhi	r2,517
 202a338:	1090b004 	addi	r2,r2,17088
 202a33c:	10800017 	ldw	r2,0(r2)
 202a340:	1887883a 	add	r3,r3,r2
 202a344:	e0bffa17 	ldw	r2,-24(fp)
 202a348:	10c00315 	stw	r3,12(r2)

         mtmp = m1;
 202a34c:	e0bff617 	ldw	r2,-40(fp)
 202a350:	e0bff815 	stw	r2,-32(fp)
         while (mtmp)
 202a354:	00002806 	br	202a3f8 <ip_output+0x3dc>
         {
            MEMCPY(pkt->nb_prot, mtmp->m_data, mtmp->m_len);
 202a358:	e0bffa17 	ldw	r2,-24(fp)
 202a35c:	11000317 	ldw	r4,12(r2)
 202a360:	e0bff817 	ldw	r2,-32(fp)
 202a364:	10c00317 	ldw	r3,12(r2)
 202a368:	e0bff817 	ldw	r2,-32(fp)
 202a36c:	10800217 	ldw	r2,8(r2)
 202a370:	180b883a 	mov	r5,r3
 202a374:	100d883a 	mov	r6,r2
 202a378:	200660c0 	call	200660c <memcpy>
            pkt->nb_prot += mtmp->m_len;
 202a37c:	e0bffa17 	ldw	r2,-24(fp)
 202a380:	10c00317 	ldw	r3,12(r2)
 202a384:	e0bff817 	ldw	r2,-32(fp)
 202a388:	10800217 	ldw	r2,8(r2)
 202a38c:	1887883a 	add	r3,r3,r2
 202a390:	e0bffa17 	ldw	r2,-24(fp)
 202a394:	10c00315 	stw	r3,12(r2)
            pkt->nb_plen += mtmp->m_len;
 202a398:	e0bffa17 	ldw	r2,-24(fp)
 202a39c:	10c00417 	ldw	r3,16(r2)
 202a3a0:	e0bff817 	ldw	r2,-32(fp)
 202a3a4:	10800217 	ldw	r2,8(r2)
 202a3a8:	1887883a 	add	r3,r3,r2
 202a3ac:	e0bffa17 	ldw	r2,-24(fp)
 202a3b0:	10c00415 	stw	r3,16(r2)
            m2 = mtmp;
 202a3b4:	e0bff817 	ldw	r2,-32(fp)
 202a3b8:	e0bff715 	stw	r2,-36(fp)
            mtmp = mtmp->m_next;
 202a3bc:	e0bff817 	ldw	r2,-32(fp)
 202a3c0:	10800617 	ldw	r2,24(r2)
 202a3c4:	e0bff815 	stw	r2,-32(fp)
            if (m2 != data)   /* save original head */
 202a3c8:	e0fff717 	ldw	r3,-36(fp)
 202a3cc:	e0bffe17 	ldw	r2,-8(fp)
 202a3d0:	18800226 	beq	r3,r2,202a3dc <ip_output+0x3c0>
               m_free(m2);
 202a3d4:	e13ff717 	ldw	r4,-36(fp)
 202a3d8:	20295600 	call	2029560 <m_free>
            tcpstat.tcps_ocopies++;
 202a3dc:	00809934 	movhi	r2,612
 202a3e0:	10b6f504 	addi	r2,r2,-9260
 202a3e4:	10803417 	ldw	r2,208(r2)
 202a3e8:	10c00044 	addi	r3,r2,1
 202a3ec:	00809934 	movhi	r2,612
 202a3f0:	10b6f504 	addi	r2,r2,-9260
 202a3f4:	10c03415 	stw	r3,208(r2)
         if (!pkt)
            return ENOBUFS;
         pkt->nb_prot = pkt->nb_buff + MaxLnh;

         mtmp = m1;
         while (mtmp)
 202a3f8:	e0bff817 	ldw	r2,-32(fp)
 202a3fc:	103fd61e 	bne	r2,zero,202a358 <ip_output+0x33c>
            mtmp = mtmp->m_next;
            if (m2 != data)   /* save original head */
               m_free(m2);
            tcpstat.tcps_ocopies++;
         }
         pkt->nb_prot -= total;     /* fix data pointer */
 202a400:	e0bffa17 	ldw	r2,-24(fp)
 202a404:	10c00317 	ldw	r3,12(r2)
 202a408:	e0bff917 	ldw	r2,-28(fp)
 202a40c:	0085c83a 	sub	r2,zero,r2
 202a410:	1887883a 	add	r3,r3,r2
 202a414:	e0bffa17 	ldw	r2,-24(fp)
 202a418:	10c00315 	stw	r3,12(r2)

         /* release the original mbufs packet install the new one */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 202a41c:	01000084 	movi	r4,2
 202a420:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(data->pkt);
 202a424:	e0bffe17 	ldw	r2,-8(fp)
 202a428:	10800117 	ldw	r2,4(r2)
 202a42c:	1009883a 	mov	r4,r2
 202a430:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 202a434:	01000084 	movi	r4,2
 202a438:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         data->pkt = pkt;
 202a43c:	e0bffe17 	ldw	r2,-8(fp)
 202a440:	e0fffa17 	ldw	r3,-24(fp)
 202a444:	10c00115 	stw	r3,4(r2)
         data->m_len = pkt->nb_plen;
 202a448:	e0bffa17 	ldw	r2,-24(fp)
 202a44c:	10c00417 	ldw	r3,16(r2)
 202a450:	e0bffe17 	ldw	r2,-8(fp)
 202a454:	10c00215 	stw	r3,8(r2)
         data->m_next = NULL;
 202a458:	e0bffe17 	ldw	r2,-8(fp)
 202a45c:	10000615 	stw	zero,24(r2)
         data->m_data = pkt->nb_prot;
 202a460:	e0bffa17 	ldw	r2,-24(fp)
 202a464:	10c00317 	ldw	r3,12(r2)
 202a468:	e0bffe17 	ldw	r2,-8(fp)
 202a46c:	10c00315 	stw	r3,12(r2)
         data->m_len = total;
 202a470:	e0fff917 	ldw	r3,-28(fp)
 202a474:	e0bffe17 	ldw	r2,-8(fp)
 202a478:	10c00215 	stw	r3,8(r2)
      }
   }

   if ((data->m_data < (data->pkt->nb_buff + MaxLnh)))
 202a47c:	e0bffe17 	ldw	r2,-8(fp)
 202a480:	10c00317 	ldw	r3,12(r2)
 202a484:	e0bffe17 	ldw	r2,-8(fp)
 202a488:	10800117 	ldw	r2,4(r2)
 202a48c:	11000117 	ldw	r4,4(r2)
 202a490:	00808174 	movhi	r2,517
 202a494:	1090b004 	addi	r2,r2,17088
 202a498:	10800017 	ldw	r2,0(r2)
 202a49c:	2085883a 	add	r2,r4,r2
 202a4a0:	1880032e 	bgeu	r3,r2,202a4b0 <ip_output+0x494>
      panic("ip_output: overflow");
 202a4a4:	01008174 	movhi	r4,517
 202a4a8:	213d4304 	addi	r4,r4,-2804
 202a4ac:	2026bf80 	call	2026bf8 <panic>

   pkt = data->pkt;
 202a4b0:	e0bffe17 	ldw	r2,-8(fp)
 202a4b4:	10800117 	ldw	r2,4(r2)
 202a4b8:	e0bffa15 	stw	r2,-24(fp)

   /* do we have options? */
   if (so_optsPack)
 202a4bc:	e0bfff17 	ldw	r2,-4(fp)
 202a4c0:	10000326 	beq	r2,zero,202a4d0 <ip_output+0x4b4>
	   pkt->soxopts = so_optsPack;   /* yup */
 202a4c4:	e0bffa17 	ldw	r2,-24(fp)
 202a4c8:	e0ffff17 	ldw	r3,-4(fp)
 202a4cc:	10c00c15 	stw	r3,48(r2)
      panic("ip_output: no so_optsPack for the IPv6 scope");     
   }
#endif

   /* fill in dest host for IP layer */
   bip = (struct ip *)data->m_data;
 202a4d0:	e0bffe17 	ldw	r2,-8(fp)
 202a4d4:	10800317 	ldw	r2,12(r2)
 202a4d8:	e0bffc15 	stw	r2,-16(fp)
   pkt->fhost = bip->ip_dest;
 202a4dc:	e0bffc17 	ldw	r2,-16(fp)
 202a4e0:	10c00417 	ldw	r3,16(r2)
 202a4e4:	e0bffa17 	ldw	r2,-24(fp)
 202a4e8:	10c00715 	stw	r3,28(r2)

   /* make enough IP header for cksum calculation */
   bip->ip_ver_ihl = 0x45;
 202a4ec:	e0bffc17 	ldw	r2,-16(fp)
 202a4f0:	00c01144 	movi	r3,69
 202a4f4:	10c00005 	stb	r3,0(r2)
   bip->ip_len = htons(bip->ip_len);   /* make net endian for calculation */
 202a4f8:	e0bffc17 	ldw	r2,-16(fp)
 202a4fc:	1080008b 	ldhu	r2,2(r2)
 202a500:	10bfffcc 	andi	r2,r2,65535
 202a504:	1004d23a 	srli	r2,r2,8
 202a508:	1007883a 	mov	r3,r2
 202a50c:	e0bffc17 	ldw	r2,-16(fp)
 202a510:	1080008b 	ldhu	r2,2(r2)
 202a514:	10bfffcc 	andi	r2,r2,65535
 202a518:	1004923a 	slli	r2,r2,8
 202a51c:	1884b03a 	or	r2,r3,r2
 202a520:	1007883a 	mov	r3,r2
 202a524:	e0bffc17 	ldw	r2,-16(fp)
 202a528:	10c0008d 	sth	r3,2(r2)
   tcpp = (struct tcphdr *)ip_data(bip);
 202a52c:	e0bffc17 	ldw	r2,-16(fp)
 202a530:	10800003 	ldbu	r2,0(r2)
 202a534:	10803fcc 	andi	r2,r2,255
 202a538:	108003cc 	andi	r2,r2,15
 202a53c:	1085883a 	add	r2,r2,r2
 202a540:	1085883a 	add	r2,r2,r2
 202a544:	e0fffc17 	ldw	r3,-16(fp)
 202a548:	1885883a 	add	r2,r3,r2
 202a54c:	e0bffd15 	stw	r2,-12(fp)
#ifdef CSUM_DEMO
   if (!(tcpp->th_flags & TH_SYN))
   tcpp->th_flags |= TH_PUSH;     /* force the PSH flag in TCP hdr */
#endif
   tcpp->th_sum = tcp_cksum(bip);
 202a550:	e13ffc17 	ldw	r4,-16(fp)
 202a554:	20480ac0 	call	20480ac <tcp_cksum>
 202a558:	e0fffd17 	ldw	r3,-12(fp)
 202a55c:	1880040d 	sth	r2,16(r3)

   pkt->nb_prot = (char*)(bip + 1);    /* point past IP header */
 202a560:	e0bffc17 	ldw	r2,-16(fp)
 202a564:	10c00504 	addi	r3,r2,20
 202a568:	e0bffa17 	ldw	r2,-24(fp)
 202a56c:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen = data->m_len - sizeof(struct ip);
 202a570:	e0bffe17 	ldw	r2,-8(fp)
 202a574:	10800217 	ldw	r2,8(r2)
 202a578:	10fffb04 	addi	r3,r2,-20
 202a57c:	e0bffa17 	ldw	r2,-24(fp)
 202a580:	10c00415 	stw	r3,16(r2)

   e = ip_write(IPPROTO_TCP, pkt);
 202a584:	01000184 	movi	r4,6
 202a588:	e17ffa17 	ldw	r5,-24(fp)
 202a58c:	203fd780 	call	203fd78 <ip_write>
 202a590:	e0bffb15 	stw	r2,-20(fp)

   /* ip_write() is now responsable for data->pkt, so... */
   data->pkt = NULL;
 202a594:	e0bffe17 	ldw	r2,-8(fp)
 202a598:	10000115 	stw	zero,4(r2)
   m_freem(data);
 202a59c:	e13ffe17 	ldw	r4,-8(fp)
 202a5a0:	20296780 	call	2029678 <m_freem>

   if (e < 0)
 202a5a4:	e0bffb17 	ldw	r2,-20(fp)
 202a5a8:	1000070e 	bge	r2,zero,202a5c8 <ip_output+0x5ac>
   {
      /* don't report dropped sends, it causes socket applications to 
      bail when a TCP retry will fix the problem */
      if (e == SEND_DROPPED)
 202a5ac:	e0bffb17 	ldw	r2,-20(fp)
 202a5b0:	10bffa98 	cmpnei	r2,r2,-22
 202a5b4:	1000021e 	bne	r2,zero,202a5c0 <ip_output+0x5a4>
         return 0;
 202a5b8:	0005883a 	mov	r2,zero
 202a5bc:	00000306 	br	202a5cc <ip_output+0x5b0>
      return e;
 202a5c0:	e0bffb17 	ldw	r2,-20(fp)
 202a5c4:	00000106 	br	202a5cc <ip_output+0x5b0>
   }
   else
      return 0;
 202a5c8:	0005883a 	mov	r2,zero
}
 202a5cc:	e037883a 	mov	sp,fp
 202a5d0:	dfc00117 	ldw	ra,4(sp)
 202a5d4:	df000017 	ldw	fp,0(sp)
 202a5d8:	dec00204 	addi	sp,sp,8
 202a5dc:	f800283a 	ret

0202a5e0 <in_broadcast>:
 * RETURNS: TRUE if broadcast, else FALSE
 */

int
in_broadcast(u_long ipaddr)   /* passed in net endian */
{
 202a5e0:	defffe04 	addi	sp,sp,-8
 202a5e4:	df000115 	stw	fp,4(sp)
 202a5e8:	df000104 	addi	fp,sp,4
 202a5ec:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr == 0xffffffff)
 202a5f0:	e0bfff17 	ldw	r2,-4(fp)
 202a5f4:	10bfffd8 	cmpnei	r2,r2,-1
 202a5f8:	1000021e 	bne	r2,zero,202a604 <in_broadcast+0x24>
      return TRUE;
 202a5fc:	00800044 	movi	r2,1
 202a600:	00000106 	br	202a608 <in_broadcast+0x28>

   return FALSE;
 202a604:	0005883a 	mov	r2,zero
}
 202a608:	e037883a 	mov	sp,fp
 202a60c:	df000017 	ldw	fp,0(sp)
 202a610:	dec00104 	addi	sp,sp,4
 202a614:	f800283a 	ret

0202a618 <np_stripoptions>:
 * RETURNS: void
 */

void
np_stripoptions(struct ip * ti, struct mbuf * m)
{
 202a618:	defffb04 	addi	sp,sp,-20
 202a61c:	dfc00415 	stw	ra,16(sp)
 202a620:	df000315 	stw	fp,12(sp)
 202a624:	df000304 	addi	fp,sp,12
 202a628:	e13ffe15 	stw	r4,-8(fp)
 202a62c:	e17fff15 	stw	r5,-4(fp)
   int   ihlen;

   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;
 202a630:	e0bffe17 	ldw	r2,-8(fp)
 202a634:	10800003 	ldbu	r2,0(r2)
 202a638:	10803fcc 	andi	r2,r2,255
 202a63c:	108003cc 	andi	r2,r2,15
 202a640:	1085883a 	add	r2,r2,r2
 202a644:	1085883a 	add	r2,r2,r2
 202a648:	e0bffd15 	stw	r2,-12(fp)

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
 202a64c:	e0bffd17 	ldw	r2,-12(fp)
 202a650:	10800548 	cmpgei	r2,r2,21
 202a654:	10002726 	beq	r2,zero,202a6f4 <np_stripoptions+0xdc>
      return;

   /* figure out how much to strip: we want to keep the 20-octet IP header */
   ihlen -= 20;
 202a658:	e0bffd17 	ldw	r2,-12(fp)
 202a65c:	10bffb04 	addi	r2,r2,-20
 202a660:	e0bffd15 	stw	r2,-12(fp)

   /* remove the stripped options from the IP datagram length */
   ti->ip_len -= ihlen;
 202a664:	e0bffe17 	ldw	r2,-8(fp)
 202a668:	10c0008b 	ldhu	r3,2(r2)
 202a66c:	e0bffd17 	ldw	r2,-12(fp)
 202a670:	1885c83a 	sub	r2,r3,r2
 202a674:	1007883a 	mov	r3,r2
 202a678:	e0bffe17 	ldw	r2,-8(fp)
 202a67c:	10c0008d 	sth	r3,2(r2)

   /* and from the IP header length (which will be 5*4 octets long) */
   ti->ip_ver_ihl = (ti->ip_ver_ihl & 0xf0) | 5;
 202a680:	e0bffe17 	ldw	r2,-8(fp)
 202a684:	10800003 	ldbu	r2,0(r2)
 202a688:	1007883a 	mov	r3,r2
 202a68c:	00bffc04 	movi	r2,-16
 202a690:	1884703a 	and	r2,r3,r2
 202a694:	10800154 	ori	r2,r2,5
 202a698:	1007883a 	mov	r3,r2
 202a69c:	e0bffe17 	ldw	r2,-8(fp)
 202a6a0:	10c00005 	stb	r3,0(r2)

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
 202a6a4:	e0bffd17 	ldw	r2,-12(fp)
 202a6a8:	e0fffe17 	ldw	r3,-8(fp)
 202a6ac:	1885883a 	add	r2,r3,r2
 202a6b0:	1009883a 	mov	r4,r2
 202a6b4:	e17ffe17 	ldw	r5,-8(fp)
 202a6b8:	01800504 	movi	r6,20
 202a6bc:	20067040 	call	2006704 <memmove>
   m->m_len -= ihlen;
 202a6c0:	e0bfff17 	ldw	r2,-4(fp)
 202a6c4:	10c00217 	ldw	r3,8(r2)
 202a6c8:	e0bffd17 	ldw	r2,-12(fp)
 202a6cc:	1887c83a 	sub	r3,r3,r2
 202a6d0:	e0bfff17 	ldw	r2,-4(fp)
 202a6d4:	10c00215 	stw	r3,8(r2)
   m->m_data += ihlen;
 202a6d8:	e0bfff17 	ldw	r2,-4(fp)
 202a6dc:	10c00317 	ldw	r3,12(r2)
 202a6e0:	e0bffd17 	ldw	r2,-12(fp)
 202a6e4:	1887883a 	add	r3,r3,r2
 202a6e8:	e0bfff17 	ldw	r2,-4(fp)
 202a6ec:	10c00315 	stw	r3,12(r2)
 202a6f0:	00000106 	br	202a6f8 <np_stripoptions+0xe0>
   /* get the IP header length in octets */
   ihlen = (ti->ip_ver_ihl & 0x0f) << 2;

   /* if it's <= 20 octets, there are no IP header options to strip */
   if (ihlen <= 20)
      return;
 202a6f4:	0001883a 	nop

   /* move the 20-octet IP header up against the IP payload */
   MEMMOVE( ((char*)ti) + ihlen, ti, 20);
   m->m_len -= ihlen;
   m->m_data += ihlen;
}
 202a6f8:	e037883a 	mov	sp,fp
 202a6fc:	dfc00117 	ldw	ra,4(sp)
 202a700:	df000017 	ldw	fp,0(sp)
 202a704:	dec00204 	addi	sp,sp,8
 202a708:	f800283a 	ret

0202a70c <so_icmpdu>:
 * RETURNS: 
 */

void
so_icmpdu(PACKET p, struct destun * pdp)
{
 202a70c:	defff304 	addi	sp,sp,-52
 202a710:	dfc00c15 	stw	ra,48(sp)
 202a714:	df000b15 	stw	fp,44(sp)
 202a718:	df000b04 	addi	fp,sp,44
 202a71c:	e13ffe15 	stw	r4,-8(fp)
 202a720:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;
   struct socket *   so;
   struct tcpcb * tp;

   /* extract information about packet which generated DU */
   fhost = htonl(pdp->dip.ip_dest);
 202a724:	e0bfff17 	ldw	r2,-4(fp)
 202a728:	10800617 	ldw	r2,24(r2)
 202a72c:	1006d63a 	srli	r3,r2,24
 202a730:	e0bfff17 	ldw	r2,-4(fp)
 202a734:	10800617 	ldw	r2,24(r2)
 202a738:	1004d23a 	srli	r2,r2,8
 202a73c:	10bfc00c 	andi	r2,r2,65280
 202a740:	1886b03a 	or	r3,r3,r2
 202a744:	e0bfff17 	ldw	r2,-4(fp)
 202a748:	10800617 	ldw	r2,24(r2)
 202a74c:	10bfc00c 	andi	r2,r2,65280
 202a750:	1004923a 	slli	r2,r2,8
 202a754:	1886b03a 	or	r3,r3,r2
 202a758:	e0bfff17 	ldw	r2,-4(fp)
 202a75c:	10800617 	ldw	r2,24(r2)
 202a760:	1004963a 	slli	r2,r2,24
 202a764:	1884b03a 	or	r2,r3,r2
 202a768:	e0bff815 	stw	r2,-32(fp)
   lhost = htonl(pdp->dip.ip_src);
 202a76c:	e0bfff17 	ldw	r2,-4(fp)
 202a770:	10800517 	ldw	r2,20(r2)
 202a774:	1006d63a 	srli	r3,r2,24
 202a778:	e0bfff17 	ldw	r2,-4(fp)
 202a77c:	10800517 	ldw	r2,20(r2)
 202a780:	1004d23a 	srli	r2,r2,8
 202a784:	10bfc00c 	andi	r2,r2,65280
 202a788:	1886b03a 	or	r3,r3,r2
 202a78c:	e0bfff17 	ldw	r2,-4(fp)
 202a790:	10800517 	ldw	r2,20(r2)
 202a794:	10bfc00c 	andi	r2,r2,65280
 202a798:	1004923a 	slli	r2,r2,8
 202a79c:	1886b03a 	or	r3,r3,r2
 202a7a0:	e0bfff17 	ldw	r2,-4(fp)
 202a7a4:	10800517 	ldw	r2,20(r2)
 202a7a8:	1004963a 	slli	r2,r2,24
 202a7ac:	1884b03a 	or	r2,r3,r2
 202a7b0:	e0bff915 	stw	r2,-28(fp)
   lport = htons(*(unshort*)(&pdp->ddata[0]));
 202a7b4:	e0bfff17 	ldw	r2,-4(fp)
 202a7b8:	10800704 	addi	r2,r2,28
 202a7bc:	1080000b 	ldhu	r2,0(r2)
 202a7c0:	10bfffcc 	andi	r2,r2,65535
 202a7c4:	1004d23a 	srli	r2,r2,8
 202a7c8:	1007883a 	mov	r3,r2
 202a7cc:	e0bfff17 	ldw	r2,-4(fp)
 202a7d0:	10800704 	addi	r2,r2,28
 202a7d4:	1080000b 	ldhu	r2,0(r2)
 202a7d8:	10bfffcc 	andi	r2,r2,65535
 202a7dc:	1004923a 	slli	r2,r2,8
 202a7e0:	1884b03a 	or	r2,r3,r2
 202a7e4:	e0bffa0d 	sth	r2,-24(fp)
   fport = htons(*(unshort*)(&pdp->ddata[2]));
 202a7e8:	e0bfff17 	ldw	r2,-4(fp)
 202a7ec:	10800784 	addi	r2,r2,30
 202a7f0:	1080000b 	ldhu	r2,0(r2)
 202a7f4:	10bfffcc 	andi	r2,r2,65535
 202a7f8:	1004d23a 	srli	r2,r2,8
 202a7fc:	1007883a 	mov	r3,r2
 202a800:	e0bfff17 	ldw	r2,-4(fp)
 202a804:	10800784 	addi	r2,r2,30
 202a808:	1080000b 	ldhu	r2,0(r2)
 202a80c:	10bfffcc 	andi	r2,r2,65535
 202a810:	1004923a 	slli	r2,r2,8
 202a814:	1884b03a 	or	r2,r3,r2
 202a818:	e0bffa8d 	sth	r2,-22(fp)
#ifndef IP_PMTU
   /* if it's a datagram-too-big message, ignore it -- As the
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
 202a81c:	e0bfff17 	ldw	r2,-4(fp)
 202a820:	10800043 	ldbu	r2,1(r2)
 202a824:	10803fcc 	andi	r2,r2,255
 202a828:	1080201c 	xori	r2,r2,128
 202a82c:	10bfe004 	addi	r2,r2,-128
 202a830:	10800118 	cmpnei	r2,r2,4
 202a834:	10007026 	beq	r2,zero,202a9f8 <so_icmpdu+0x2ec>
       goto done;
    }
#endif   /* IP_PMTU */

   /* if it's a TCP connection, clean it up */
   if (pdp->dip.ip_prot == TCPTP)
 202a838:	e0bfff17 	ldw	r2,-4(fp)
 202a83c:	10800443 	ldbu	r2,17(r2)
 202a840:	10803fcc 	andi	r2,r2,255
 202a844:	10800198 	cmpnei	r2,r2,6
 202a848:	1000221e 	bne	r2,zero,202a8d4 <so_icmpdu+0x1c8>
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
 202a84c:	e0bffa8b 	ldhu	r2,-22(fp)
 202a850:	e0fffa0b 	ldhu	r3,-24(fp)
 202a854:	d8c00015 	stw	r3,0(sp)
 202a858:	00c00044 	movi	r3,1
 202a85c:	d8c00115 	stw	r3,4(sp)
 202a860:	01009934 	movhi	r4,612
 202a864:	2136ea04 	addi	r4,r4,-9304
 202a868:	e17ff817 	ldw	r5,-32(fp)
 202a86c:	100d883a 	mov	r6,r2
 202a870:	e1fff917 	ldw	r7,-28(fp)
 202a874:	2048b580 	call	2048b58 <in_pcblookup>
 202a878:	e0bffb15 	stw	r2,-20(fp)
      if (inp == 0)
 202a87c:	e0bffb17 	ldw	r2,-20(fp)
 202a880:	10005f26 	beq	r2,zero,202aa00 <so_icmpdu+0x2f4>
         goto done;
      so = inp->inp_socket;
 202a884:	e0bffb17 	ldw	r2,-20(fp)
 202a888:	10800817 	ldw	r2,32(r2)
 202a88c:	e0bffc15 	stw	r2,-16(fp)
      if (so == 0)
 202a890:	e0bffc17 	ldw	r2,-16(fp)
 202a894:	10005c26 	beq	r2,zero,202aa08 <so_icmpdu+0x2fc>
         goto done;
      tp = intotcpcb(inp);
 202a898:	e0bffb17 	ldw	r2,-20(fp)
 202a89c:	10800917 	ldw	r2,36(r2)
 202a8a0:	e0bffd15 	stw	r2,-12(fp)
      if (tp)
 202a8a4:	e0bffd17 	ldw	r2,-12(fp)
 202a8a8:	10000626 	beq	r2,zero,202a8c4 <so_icmpdu+0x1b8>
      {
         if (tp->t_state <= TCPS_LISTEN)
 202a8ac:	e0bffd17 	ldw	r2,-12(fp)
 202a8b0:	10800217 	ldw	r2,8(r2)
 202a8b4:	10800088 	cmpgei	r2,r2,2
 202a8b8:	10005526 	beq	r2,zero,202aa10 <so_icmpdu+0x304>
               goto done;
        }
   }
#endif

         tcp_close(tp);
 202a8bc:	e13ffd17 	ldw	r4,-12(fp)
 202a8c0:	2034d240 	call	2034d24 <tcp_close>
      }
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 202a8c4:	e0bffc17 	ldw	r2,-16(fp)
 202a8c8:	00c01bc4 	movi	r3,111
 202a8cc:	10c00615 	stw	r3,24(r2)
 202a8d0:	00005606 	br	202aa2c <so_icmpdu+0x320>
   }   
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
 202a8d4:	e0bfff17 	ldw	r2,-4(fp)
 202a8d8:	10800443 	ldbu	r2,17(r2)
 202a8dc:	10803fcc 	andi	r2,r2,255
 202a8e0:	10800458 	cmpnei	r2,r2,17
 202a8e4:	10004c1e 	bne	r2,zero,202aa18 <so_icmpdu+0x30c>
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 202a8e8:	00808174 	movhi	r2,517
 202a8ec:	1090f204 	addi	r2,r2,17352
 202a8f0:	10800017 	ldw	r2,0(r2)
 202a8f4:	e0bff715 	stw	r2,-36(fp)
 202a8f8:	00002106 	br	202a980 <so_icmpdu+0x274>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 202a8fc:	e0bff717 	ldw	r2,-36(fp)
 202a900:	1080020b 	ldhu	r2,8(r2)
 202a904:	10ffffcc 	andi	r3,r2,65535
 202a908:	e0bffa8b 	ldhu	r2,-22(fp)
 202a90c:	18800426 	beq	r3,r2,202a920 <so_icmpdu+0x214>
 202a910:	e0bff717 	ldw	r2,-36(fp)
 202a914:	1080020b 	ldhu	r2,8(r2)
 202a918:	10bfffcc 	andi	r2,r2,65535
 202a91c:	1000151e 	bne	r2,zero,202a974 <so_icmpdu+0x268>
             (tmp->u_fhost == htonl(fhost)) &&
 202a920:	e0bff717 	ldw	r2,-36(fp)
 202a924:	10c00417 	ldw	r3,16(r2)
 202a928:	e0bff817 	ldw	r2,-32(fp)
 202a92c:	1008d63a 	srli	r4,r2,24
 202a930:	e0bff817 	ldw	r2,-32(fp)
 202a934:	1004d23a 	srli	r2,r2,8
 202a938:	10bfc00c 	andi	r2,r2,65280
 202a93c:	2088b03a 	or	r4,r4,r2
 202a940:	e0bff817 	ldw	r2,-32(fp)
 202a944:	10bfc00c 	andi	r2,r2,65280
 202a948:	1004923a 	slli	r2,r2,8
 202a94c:	2088b03a 	or	r4,r4,r2
 202a950:	e0bff817 	ldw	r2,-32(fp)
 202a954:	1004963a 	slli	r2,r2,24
 202a958:	2084b03a 	or	r2,r4,r2
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
 202a95c:	1880051e 	bne	r3,r2,202a974 <so_icmpdu+0x268>
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
 202a960:	e0bff717 	ldw	r2,-36(fp)
 202a964:	1080018b 	ldhu	r2,6(r2)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
 202a968:	10ffffcc 	andi	r3,r2,65535
 202a96c:	e0bffa0b 	ldhu	r2,-24(fp)
 202a970:	18800626 	beq	r3,r2,202a98c <so_icmpdu+0x280>
#ifdef UDP_SOCKETS   /* this sockets layer supports UDP too */
   else if(pdp->dip.ip_prot == UDP_PROT)
   {
      UDPCONN tmp;
      /* search udp table (which keeps hosts in net endian) */
      for (tmp = firstudp; tmp; tmp = tmp->u_next)
 202a974:	e0bff717 	ldw	r2,-36(fp)
 202a978:	10800017 	ldw	r2,0(r2)
 202a97c:	e0bff715 	stw	r2,-36(fp)
 202a980:	e0bff717 	ldw	r2,-36(fp)
 202a984:	103fdd1e 	bne	r2,zero,202a8fc <so_icmpdu+0x1f0>
 202a988:	00000106 	br	202a990 <so_icmpdu+0x284>
         if ((tmp->u_fport == fport || tmp->u_fport == 0) &&
             (tmp->u_fhost == htonl(fhost)) &&
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
 202a98c:	0001883a 	nop
         }
      if (!tmp) 
 202a990:	e0bff717 	ldw	r2,-36(fp)
 202a994:	10002226 	beq	r2,zero,202aa20 <so_icmpdu+0x314>
         goto done;
      so = (struct socket *)tmp->u_data;
 202a998:	e0bff717 	ldw	r2,-36(fp)
 202a99c:	10800617 	ldw	r2,24(r2)
 202a9a0:	e0bffc15 	stw	r2,-16(fp)
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
 202a9a4:	e0bffc17 	ldw	r2,-16(fp)
 202a9a8:	10800983 	ldbu	r2,38(r2)
 202a9ac:	10803fcc 	andi	r2,r2,255
 202a9b0:	1080201c 	xori	r2,r2,128
 202a9b4:	10bfe004 	addi	r2,r2,-128
 202a9b8:	108000a0 	cmpeqi	r2,r2,2
 202a9bc:	10001a26 	beq	r2,zero,202aa28 <so_icmpdu+0x31c>
         goto done;
      so->so_error = ECONNREFUSED;  /* set error for socket owner */
 202a9c0:	e0bffc17 	ldw	r2,-16(fp)
 202a9c4:	00c01bc4 	movi	r3,111
 202a9c8:	10c00615 	stw	r3,24(r2)
      /* do a select() notify on socket here */
      sorwakeup(so);
 202a9cc:	e0bffc17 	ldw	r2,-16(fp)
 202a9d0:	10800a04 	addi	r2,r2,40
 202a9d4:	e13ffc17 	ldw	r4,-16(fp)
 202a9d8:	100b883a 	mov	r5,r2
 202a9dc:	202f3300 	call	202f330 <sbwakeup>
      sowwakeup(so);
 202a9e0:	e0bffc17 	ldw	r2,-16(fp)
 202a9e4:	10801204 	addi	r2,r2,72
 202a9e8:	e13ffc17 	ldw	r4,-16(fp)
 202a9ec:	100b883a 	mov	r5,r2
 202a9f0:	202f3300 	call	202f330 <sbwakeup>
 202a9f4:	00000d06 	br	202aa2c <so_icmpdu+0x320>
    * build isn't using PMTU Discovery this packet is most 
    * probably a Denial of Service Attack.
    */
    if(pdp->dcode == DSTFRAG)
    {
       goto done;
 202a9f8:	0001883a 	nop
 202a9fc:	00000b06 	br	202aa2c <so_icmpdu+0x320>
   if (pdp->dip.ip_prot == TCPTP)
   {
      /* find associated data structs and socket */
      inp = in_pcblookup(&tcb, fhost, fport, lhost, lport, INPLOOKUP_WILDCARD);
      if (inp == 0)
         goto done;
 202aa00:	0001883a 	nop
 202aa04:	00000906 	br	202aa2c <so_icmpdu+0x320>
      so = inp->inp_socket;
      if (so == 0)
         goto done;
 202aa08:	0001883a 	nop
 202aa0c:	00000706 	br	202aa2c <so_icmpdu+0x320>
      tp = intotcpcb(inp);
      if (tp)
      {
         if (tp->t_state <= TCPS_LISTEN)
         {
            goto done;
 202aa10:	0001883a 	nop
 202aa14:	00000506 	br	202aa2c <so_icmpdu+0x320>
      sorwakeup(so);
      sowwakeup(so);
   }
#endif   /* UDP_SOCKETS */
   else
      goto done;
 202aa18:	0001883a 	nop
 202aa1c:	00000306 	br	202aa2c <so_icmpdu+0x320>
             (tmp->u_lport == lport))
         {
            break;   /* found our UDP table entry */
         }
      if (!tmp) 
         goto done;
 202aa20:	0001883a 	nop
 202aa24:	00000106 	br	202aa2c <so_icmpdu+0x320>
      so = (struct socket *)tmp->u_data;
      /* May be non-socket (lightweight) UDP connection. */
      if (so->so_type != SOCK_DGRAM)
         goto done;
 202aa28:	0001883a 	nop
   if (pdp->dcode == DSTFRAG)
      pmtucache_set(pdp->dip.ip_dest, htons(pdp->dno2));
#endif   /* IP_PMTU */

done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
 202aa2c:	01000084 	movi	r4,2
 202aa30:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p); /* done with original packet */
 202aa34:	e13ffe17 	ldw	r4,-8(fp)
 202aa38:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 202aa3c:	01000084 	movi	r4,2
 202aa40:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return;
 202aa44:	0001883a 	nop
}
 202aa48:	e037883a 	mov	sp,fp
 202aa4c:	dfc00117 	ldw	ra,4(sp)
 202aa50:	df000017 	ldw	fp,0(sp)
 202aa54:	dec00204 	addi	sp,sp,8
 202aa58:	f800283a 	ret

0202aa5c <tcp_tick>:
unsigned long nextslow = 0L;     /* next slow tcp timer time */
static int in_tcptick = 0;       /* reentry gaurd */

void
tcp_tick()
{
 202aa5c:	defffe04 	addi	sp,sp,-8
 202aa60:	dfc00115 	stw	ra,4(sp)
 202aa64:	df000015 	stw	fp,0(sp)
 202aa68:	d839883a 	mov	fp,sp
   /* guard against re-entry */
   if (in_tcptick)
 202aa6c:	d0a0a417 	ldw	r2,-32112(gp)
 202aa70:	1000251e 	bne	r2,zero,202ab08 <tcp_tick+0xac>
      return;
   in_tcptick++;
 202aa74:	d0a0a417 	ldw	r2,-32112(gp)
 202aa78:	10800044 	addi	r2,r2,1
 202aa7c:	d0a0a415 	stw	r2,-32112(gp)

   LOCK_NET_RESOURCE(NET_RESID);
 202aa80:	0009883a 	mov	r4,zero
 202aa84:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   if (cticks >= nextslow) /* time to do it again */
 202aa88:	00808174 	movhi	r2,517
 202aa8c:	1090c904 	addi	r2,r2,17188
 202aa90:	10c00017 	ldw	r3,0(r2)
 202aa94:	d0a0a317 	ldw	r2,-32116(gp)
 202aa98:	18801536 	bltu	r3,r2,202aaf0 <tcp_tick+0x94>
   {
      tcp_slowtimo();      /* call routine in BSD tcp_timr.c */
 202aa9c:	2034f540 	call	2034f54 <tcp_slowtimo>
#ifdef CSUM_DEMO
      nextslow = cticks + (TPS/5);  /* another 200 ms */
#else
      nextslow = cticks + (TPS/2);  /* another 500 ms */
 202aaa0:	00808174 	movhi	r2,517
 202aaa4:	1090c904 	addi	r2,r2,17188
 202aaa8:	10800017 	ldw	r2,0(r2)
 202aaac:	1009883a 	mov	r4,r2
 202aab0:	20145600 	call	2014560 <__floatunsidf>
 202aab4:	100b883a 	mov	r5,r2
 202aab8:	180d883a 	mov	r6,r3
 202aabc:	2809883a 	mov	r4,r5
 202aac0:	300b883a 	mov	r5,r6
 202aac4:	000d883a 	mov	r6,zero
 202aac8:	01d01274 	movhi	r7,16457
 202aacc:	2013bd40 	call	2013bd4 <__adddf3>
 202aad0:	1009883a 	mov	r4,r2
 202aad4:	180b883a 	mov	r5,r3
 202aad8:	2005883a 	mov	r2,r4
 202aadc:	2807883a 	mov	r3,r5
 202aae0:	1009883a 	mov	r4,r2
 202aae4:	180b883a 	mov	r5,r3
 202aae8:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 202aaec:	d0a0a315 	stw	r2,-32116(gp)

#ifdef DO_DELAY_ACKS
   tcp_fasttimo();
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);
 202aaf0:	0009883a 	mov	r4,zero
 202aaf4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   in_tcptick--;
 202aaf8:	d0a0a417 	ldw	r2,-32112(gp)
 202aafc:	10bfffc4 	addi	r2,r2,-1
 202ab00:	d0a0a415 	stw	r2,-32112(gp)
 202ab04:	00000106 	br	202ab0c <tcp_tick+0xb0>
void
tcp_tick()
{
   /* guard against re-entry */
   if (in_tcptick)
      return;
 202ab08:	0001883a 	nop
#endif   /* DO_DELAY_ACKS */

   UNLOCK_NET_RESOURCE(NET_RESID);

   in_tcptick--;
}
 202ab0c:	e037883a 	mov	sp,fp
 202ab10:	dfc00117 	ldw	ra,4(sp)
 202ab14:	df000017 	ldw	fp,0(sp)
 202ab18:	dec00204 	addi	sp,sp,8
 202ab1c:	f800283a 	ret

0202ab20 <rawip_lookup>:
 *          or NULL if no matching raw IP endpoint is found.
 */

struct ipraw_ep *
rawip_lookup(struct socket * so)
{
 202ab20:	defffd04 	addi	sp,sp,-12
 202ab24:	df000215 	stw	fp,8(sp)
 202ab28:	df000204 	addi	fp,sp,8
 202ab2c:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 202ab30:	00808174 	movhi	r2,517
 202ab34:	1090ef04 	addi	r2,r2,17340
 202ab38:	10800017 	ldw	r2,0(r2)
 202ab3c:	e0bffe15 	stw	r2,-8(fp)
 202ab40:	00000906 	br	202ab68 <rawip_lookup+0x48>
      if (tmp->ipr_data == (void*)so)
 202ab44:	e0bffe17 	ldw	r2,-8(fp)
 202ab48:	10c00417 	ldw	r3,16(r2)
 202ab4c:	e0bfff17 	ldw	r2,-4(fp)
 202ab50:	1880021e 	bne	r3,r2,202ab5c <rawip_lookup+0x3c>
      return (tmp);
 202ab54:	e0bffe17 	ldw	r2,-8(fp)
 202ab58:	00000606 	br	202ab74 <rawip_lookup+0x54>
struct ipraw_ep *
rawip_lookup(struct socket * so)
{
   struct ipraw_ep * tmp;

   for (tmp = ipraw_eps; tmp; tmp = tmp->ipr_next)
 202ab5c:	e0bffe17 	ldw	r2,-8(fp)
 202ab60:	10800017 	ldw	r2,0(r2)
 202ab64:	e0bffe15 	stw	r2,-8(fp)
 202ab68:	e0bffe17 	ldw	r2,-8(fp)
 202ab6c:	103ff51e 	bne	r2,zero,202ab44 <rawip_lookup+0x24>
      if (tmp->ipr_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 202ab70:	0005883a 	mov	r2,zero
}
 202ab74:	e037883a 	mov	sp,fp
 202ab78:	df000017 	ldw	fp,0(sp)
 202ab7c:	dec00104 	addi	sp,sp,4
 202ab80:	f800283a 	ret

0202ab84 <rawip_soinput>:
 *          indicates that the packet has not been accepted.
 */

int
rawip_soinput(PACKET pkt, void * so_ptr)
{
 202ab84:	defff504 	addi	sp,sp,-44
 202ab88:	dfc00a15 	stw	ra,40(sp)
 202ab8c:	df000915 	stw	fp,36(sp)
 202ab90:	df000904 	addi	fp,sp,36
 202ab94:	e13ffe15 	stw	r4,-8(fp)
 202ab98:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 202ab9c:	e0bfff17 	ldw	r2,-4(fp)
 202aba0:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;

   LOCK_NET_RESOURCE(NET_RESID); 
 202aba4:	0009883a 	mov	r4,zero
 202aba8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 202abac:	e0bff717 	ldw	r2,-36(fp)
 202abb0:	10c00a17 	ldw	r3,40(r2)
 202abb4:	e0bffe17 	ldw	r2,-8(fp)
 202abb8:	10800417 	ldw	r2,16(r2)
 202abbc:	1887883a 	add	r3,r3,r2
 202abc0:	e0bff717 	ldw	r2,-36(fp)
 202abc4:	10800b17 	ldw	r2,44(r2)
 202abc8:	18800436 	bltu	r3,r2,202abdc <rawip_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 202abcc:	0009883a 	mov	r4,zero
 202abd0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 202abd4:	00801a44 	movi	r2,105
 202abd8:	00005706 	br	202ad38 <rawip_soinput+0x1b4>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 202abdc:	01000044 	movi	r4,1
 202abe0:	000b883a 	mov	r5,zero
 202abe4:	20293d80 	call	20293d8 <m_getnbuf>
 202abe8:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 202abec:	e0bff817 	ldw	r2,-32(fp)
 202abf0:	1000041e 	bne	r2,zero,202ac04 <rawip_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 202abf4:	0009883a 	mov	r4,zero
 202abf8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 202abfc:	00801a44 	movi	r2,105
 202ac00:	00004d06 	br	202ad38 <rawip_soinput+0x1b4>
   }

   /* set data mbuf to point to start of IP header */
   m_in->pkt = pkt;
 202ac04:	e0bff817 	ldw	r2,-32(fp)
 202ac08:	e0fffe17 	ldw	r3,-8(fp)
 202ac0c:	10c00115 	stw	r3,4(r2)
   m_in->m_base = pkt->nb_buff;
 202ac10:	e0bffe17 	ldw	r2,-8(fp)
 202ac14:	10c00117 	ldw	r3,4(r2)
 202ac18:	e0bff817 	ldw	r2,-32(fp)
 202ac1c:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 202ac20:	e0bffe17 	ldw	r2,-8(fp)
 202ac24:	10c00217 	ldw	r3,8(r2)
 202ac28:	e0bff817 	ldw	r2,-32(fp)
 202ac2c:	10c00515 	stw	r3,20(r2)
   m_in->m_data = pkt->nb_prot;
 202ac30:	e0bffe17 	ldw	r2,-8(fp)
 202ac34:	10c00317 	ldw	r3,12(r2)
 202ac38:	e0bff817 	ldw	r2,-32(fp)
 202ac3c:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 202ac40:	e0bffe17 	ldw	r2,-8(fp)
 202ac44:	10c00417 	ldw	r3,16(r2)
 202ac48:	e0bff817 	ldw	r2,-32(fp)
 202ac4c:	10c00215 	stw	r3,8(r2)

   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
 202ac50:	e0bff717 	ldw	r2,-36(fp)
 202ac54:	10800417 	ldw	r2,16(r2)
 202ac58:	1088000c 	andi	r2,r2,8192
 202ac5c:	1000141e 	bne	r2,zero,202acb0 <rawip_soinput+0x12c>
   {
      unsigned int ihl = 
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
 202ac60:	e0bffe17 	ldw	r2,-8(fp)
 202ac64:	10800317 	ldw	r2,12(r2)
 202ac68:	10800003 	ldbu	r2,0(r2)
 202ac6c:	10803fcc 	andi	r2,r2,255
 202ac70:	108003cc 	andi	r2,r2,15
 202ac74:	1085883a 	add	r2,r2,r2
 202ac78:	1085883a 	add	r2,r2,r2
   /* if this socket doesn't have IP_HDRINCL set, adjust the
    * mbuf to skip past the IP header
    */
   if (!(so->so_options & SO_HDRINCL))
   {
      unsigned int ihl = 
 202ac7c:	e0bff915 	stw	r2,-28(fp)
         (((struct ip *)(pkt->nb_prot))->ip_ver_ihl & 0x0f) << 2;
      m_in->m_data += ihl;
 202ac80:	e0bff817 	ldw	r2,-32(fp)
 202ac84:	10c00317 	ldw	r3,12(r2)
 202ac88:	e0bff917 	ldw	r2,-28(fp)
 202ac8c:	1887883a 	add	r3,r3,r2
 202ac90:	e0bff817 	ldw	r2,-32(fp)
 202ac94:	10c00315 	stw	r3,12(r2)
      m_in->m_len -= ihl;
 202ac98:	e0bff817 	ldw	r2,-32(fp)
 202ac9c:	10c00217 	ldw	r3,8(r2)
 202aca0:	e0bff917 	ldw	r2,-28(fp)
 202aca4:	1887c83a 	sub	r3,r3,r2
 202aca8:	e0bff817 	ldw	r2,-32(fp)
 202acac:	10c00215 	stw	r3,8(r2)
   }

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 202acb0:	e0bffe17 	ldw	r2,-8(fp)
 202acb4:	10800717 	ldw	r2,28(r2)
 202acb8:	e0bffb15 	stw	r2,-20(fp)
   sin.sin_port = 0;
 202acbc:	e03ffa8d 	sth	zero,-22(fp)
   sin.sin_family = AF_INET;
 202acc0:	00800084 	movi	r2,2
 202acc4:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 202acc8:	e0bff717 	ldw	r2,-36(fp)
 202accc:	10c00a04 	addi	r3,r2,40
 202acd0:	e0bffa04 	addi	r2,fp,-24
 202acd4:	1809883a 	mov	r4,r3
 202acd8:	100b883a 	mov	r5,r2
 202acdc:	e1bff817 	ldw	r6,-32(fp)
 202ace0:	202f65c0 	call	202f65c <sbappendaddr>
 202ace4:	1000081e 	bne	r2,zero,202ad08 <rawip_soinput+0x184>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       * underlying stack
       */
      m_in->pkt = NULL;
 202ace8:	e0bff817 	ldw	r2,-32(fp)
 202acec:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 202acf0:	e13ff817 	ldw	r4,-32(fp)
 202acf4:	20295600 	call	2029560 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 202acf8:	0009883a 	mov	r4,zero
 202acfc:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 202ad00:	00801a44 	movi	r2,105
 202ad04:	00000c06 	br	202ad38 <rawip_soinput+0x1b4>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 202ad08:	e0bff717 	ldw	r2,-36(fp)
 202ad0c:	10800a04 	addi	r2,r2,40
 202ad10:	1009883a 	mov	r4,r2
 202ad14:	20276980 	call	2027698 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 202ad18:	e0bff717 	ldw	r2,-36(fp)
 202ad1c:	10800a04 	addi	r2,r2,40
 202ad20:	e13ff717 	ldw	r4,-36(fp)
 202ad24:	100b883a 	mov	r5,r2
 202ad28:	202f3300 	call	202f330 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 202ad2c:	0009883a 	mov	r4,zero
 202ad30:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return 0;
 202ad34:	0005883a 	mov	r2,zero
}
 202ad38:	e037883a 	mov	sp,fp
 202ad3c:	dfc00117 	ldw	ra,4(sp)
 202ad40:	df000017 	ldw	fp,0(sp)
 202ad44:	dec00204 	addi	sp,sp,8
 202ad48:	f800283a 	ret

0202ad4c <rawip_usrreq>:

int
rawip_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 202ad4c:	deffef04 	addi	sp,sp,-68
 202ad50:	dfc01015 	stw	ra,64(sp)
 202ad54:	df000f15 	stw	fp,60(sp)
 202ad58:	dc000e15 	stw	r16,56(sp)
 202ad5c:	df000e04 	addi	fp,sp,56
 202ad60:	e13ffd15 	stw	r4,-12(fp)
 202ad64:	e17ffe15 	stw	r5,-8(fp)
 202ad68:	e1bfff15 	stw	r6,-4(fp)
   u_char prot;
   struct ip * pip;
   int   req;
   NET   ifp;     /* ptr to network interface structure */

   req = so->so_req;    /* get request from socket struct */
 202ad6c:	e0bffd17 	ldw	r2,-12(fp)
 202ad70:	10800717 	ldw	r2,28(r2)
 202ad74:	e0bff715 	stw	r2,-36(fp)

   switch (req) 
 202ad78:	e0bff717 	ldw	r2,-36(fp)
 202ad7c:	10800468 	cmpgeui	r2,r2,17
 202ad80:	1001bd1e 	bne	r2,zero,202b478 <rawip_usrreq+0x72c>
 202ad84:	e0bff717 	ldw	r2,-36(fp)
 202ad88:	1085883a 	add	r2,r2,r2
 202ad8c:	1087883a 	add	r3,r2,r2
 202ad90:	008080f4 	movhi	r2,515
 202ad94:	10ab6904 	addi	r2,r2,-21084
 202ad98:	1885883a 	add	r2,r3,r2
 202ad9c:	10800017 	ldw	r2,0(r2)
 202ada0:	1000683a 	jmp	r2
 202ada4:	0202ade8 	cmpgeui	r8,zero,2743
 202ada8:	0202ae70 	cmpltui	r8,zero,2745
 202adac:	0202aeac 	andhi	r8,zero,2746
 202adb0:	0202b478 	rdprs	r8,zero,2769
 202adb4:	0202aeac 	andhi	r8,zero,2746
 202adb8:	0202b478 	rdprs	r8,zero,2769
 202adbc:	0202b46c 	andhi	r8,zero,2769
 202adc0:	0202b478 	rdprs	r8,zero,2769
 202adc4:	0202b46c 	andhi	r8,zero,2769
 202adc8:	0202b038 	rdprs	r8,zero,2752
 202adcc:	0202b478 	rdprs	r8,zero,2769
 202add0:	0202b478 	rdprs	r8,zero,2769
 202add4:	0202b478 	rdprs	r8,zero,2769
 202add8:	0202b478 	rdprs	r8,zero,2769
 202addc:	0202b478 	rdprs	r8,zero,2769
 202ade0:	0202b3d8 	cmpnei	r8,zero,2767
 202ade4:	0202b3d8 	cmpnei	r8,zero,2767
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 202ade8:	e0bffd17 	ldw	r2,-12(fp)
 202adec:	10800417 	ldw	r2,16(r2)
 202adf0:	1088000c 	andi	r2,r2,8192
 202adf4:	1009883a 	mov	r4,r2
 202adf8:	20446e00 	call	20446e0 <ip_raw_maxalloc>

   switch (req) 
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = 
 202adfc:	1007883a 	mov	r3,r2
 202ae00:	e0bffd17 	ldw	r2,-12(fp)
 202ae04:	10c01315 	stw	r3,76(r2)
 202ae08:	e0bffd17 	ldw	r2,-12(fp)
 202ae0c:	10c01317 	ldw	r3,76(r2)
 202ae10:	e0bffd17 	ldw	r2,-12(fp)
 202ae14:	10c00b15 	stw	r3,44(r2)
         ip_raw_maxalloc(so->so_options & SO_HDRINCL);
      /* make a raw IP endpoint */
      prot = (u_char)(MBUF2LONG(nam));
 202ae18:	e0bfff17 	ldw	r2,-4(fp)
 202ae1c:	e0bff805 	stb	r2,-32(fp)
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 202ae20:	0009883a 	mov	r4,zero
 202ae24:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ep = ip_raw_open(prot, 0L, 0L, rawip_soinput, so);
 202ae28:	e0bff803 	ldbu	r2,-32(fp)
 202ae2c:	e0fffd17 	ldw	r3,-12(fp)
 202ae30:	d8c00015 	stw	r3,0(sp)
 202ae34:	1009883a 	mov	r4,r2
 202ae38:	000b883a 	mov	r5,zero
 202ae3c:	000d883a 	mov	r6,zero
 202ae40:	01c080f4 	movhi	r7,515
 202ae44:	39eae104 	addi	r7,r7,-21628
 202ae48:	20442200 	call	2044220 <ip_raw_open>
 202ae4c:	e0bff915 	stw	r2,-28(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 202ae50:	0009883a 	mov	r4,zero
 202ae54:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      if (!ep)
 202ae58:	e0bff917 	ldw	r2,-28(fp)
 202ae5c:	1000021e 	bne	r2,zero,202ae68 <rawip_usrreq+0x11c>
         return(EINVAL);
 202ae60:	00800584 	movi	r2,22
 202ae64:	00018506 	br	202b47c <rawip_usrreq+0x730>
      return 0;
 202ae68:	0005883a 	mov	r2,zero
 202ae6c:	00018306 	br	202b47c <rawip_usrreq+0x730>
   case PRU_DETACH:
      /* delete the raw IP endpoint */
      ep = rawip_lookup(so);
 202ae70:	e13ffd17 	ldw	r4,-12(fp)
 202ae74:	202ab200 	call	202ab20 <rawip_lookup>
 202ae78:	e0bff915 	stw	r2,-28(fp)
      if (!ep)
 202ae7c:	e0bff917 	ldw	r2,-28(fp)
 202ae80:	1000021e 	bne	r2,zero,202ae8c <rawip_usrreq+0x140>
         return(EINVAL);
 202ae84:	00800584 	movi	r2,22
 202ae88:	00017c06 	br	202b47c <rawip_usrreq+0x730>
      /* unlock the net resource; IP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 202ae8c:	0009883a 	mov	r4,zero
 202ae90:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ip_raw_close(ep);
 202ae94:	e13ff917 	ldw	r4,-28(fp)
 202ae98:	20443000 	call	2044300 <ip_raw_close>
      LOCK_NET_RESOURCE(NET_RESID);
 202ae9c:	0009883a 	mov	r4,zero
 202aea0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      return 0;
 202aea4:	0005883a 	mov	r2,zero
 202aea8:	00017406 	br	202b47c <rawip_usrreq+0x730>
       * a default address for sending
       */
      /* fall through to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 202aeac:	e0bfff17 	ldw	r2,-4(fp)
 202aeb0:	1000021e 	bne	r2,zero,202aebc <rawip_usrreq+0x170>
         return(EINVAL);
 202aeb4:	00800584 	movi	r2,22
 202aeb8:	00017006 	br	202b47c <rawip_usrreq+0x730>
      sin = mtod(nam, struct sockaddr_in *);
 202aebc:	e0bfff17 	ldw	r2,-4(fp)
 202aec0:	10800317 	ldw	r2,12(r2)
 202aec4:	e0bffa15 	stw	r2,-24(fp)
      if (sin == NULL)
 202aec8:	e0bffa17 	ldw	r2,-24(fp)
 202aecc:	1000021e 	bne	r2,zero,202aed8 <rawip_usrreq+0x18c>
         return(EINVAL);
 202aed0:	00800584 	movi	r2,22
 202aed4:	00016906 	br	202b47c <rawip_usrreq+0x730>
      if (nam->m_len != sizeof (*sin))
 202aed8:	e0bfff17 	ldw	r2,-4(fp)
 202aedc:	10800217 	ldw	r2,8(r2)
 202aee0:	10800420 	cmpeqi	r2,r2,16
 202aee4:	1000021e 	bne	r2,zero,202aef0 <rawip_usrreq+0x1a4>
         return(EINVAL);
 202aee8:	00800584 	movi	r2,22
 202aeec:	00016306 	br	202b47c <rawip_usrreq+0x730>
      ep = rawip_lookup(so);
 202aef0:	e13ffd17 	ldw	r4,-12(fp)
 202aef4:	202ab200 	call	202ab20 <rawip_lookup>
 202aef8:	e0bff915 	stw	r2,-28(fp)
      if (!ep)
 202aefc:	e0bff917 	ldw	r2,-28(fp)
 202af00:	1000021e 	bne	r2,zero,202af0c <rawip_usrreq+0x1c0>
         return(EINVAL);
 202af04:	00800584 	movi	r2,22
 202af08:	00015c06 	br	202b47c <rawip_usrreq+0x730>
      if (req == PRU_BIND)
 202af0c:	e0bff717 	ldw	r2,-36(fp)
 202af10:	10800098 	cmpnei	r2,r2,2
 202af14:	1000201e 	bne	r2,zero,202af98 <rawip_usrreq+0x24c>
          * if the caller-supplied address is INADDR_ANY,
          * don't bind to a specific address; else, 
          * make sure the caller-supplied address is
          * an interface IP address and if so, bind to that
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 202af18:	e0bffa17 	ldw	r2,-24(fp)
 202af1c:	10800117 	ldw	r2,4(r2)
 202af20:	1000021e 	bne	r2,zero,202af2c <rawip_usrreq+0x1e0>
         {
            lhost = 0L;
 202af24:	e03ff515 	stw	zero,-44(fp)
 202af28:	00001706 	br	202af88 <rawip_usrreq+0x23c>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
 202af2c:	e0bffa17 	ldw	r2,-24(fp)
 202af30:	10800117 	ldw	r2,4(r2)
 202af34:	e0bff515 	stw	r2,-44(fp)
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202af38:	00809934 	movhi	r2,612
 202af3c:	10b7ce04 	addi	r2,r2,-8392
 202af40:	10800017 	ldw	r2,0(r2)
 202af44:	e0bff615 	stw	r2,-40(fp)
 202af48:	00000706 	br	202af68 <rawip_usrreq+0x21c>
               if (ifp->n_ipaddr == lhost)
 202af4c:	e0bff617 	ldw	r2,-40(fp)
 202af50:	10c00a17 	ldw	r3,40(r2)
 202af54:	e0bff517 	ldw	r2,-44(fp)
 202af58:	18800626 	beq	r3,r2,202af74 <rawip_usrreq+0x228>
         }
         else
         {
            lhost = sin->sin_addr.s_addr;
            /* verify that lhost is a local interface address */
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202af5c:	e0bff617 	ldw	r2,-40(fp)
 202af60:	10800017 	ldw	r2,0(r2)
 202af64:	e0bff615 	stw	r2,-40(fp)
 202af68:	e0bff617 	ldw	r2,-40(fp)
 202af6c:	103ff71e 	bne	r2,zero,202af4c <rawip_usrreq+0x200>
 202af70:	00000106 	br	202af78 <rawip_usrreq+0x22c>
               if (ifp->n_ipaddr == lhost)
                  break;
 202af74:	0001883a 	nop
            if (ifp == NULL)
 202af78:	e0bff617 	ldw	r2,-40(fp)
 202af7c:	1000021e 	bne	r2,zero,202af88 <rawip_usrreq+0x23c>
               return(EADDRNOTAVAIL);
 202af80:	00801f44 	movi	r2,125
 202af84:	00013d06 	br	202b47c <rawip_usrreq+0x730>
         }

         /* bind the endpoint */
         ep->ipr_laddr = lhost;
 202af88:	e0bff917 	ldw	r2,-28(fp)
 202af8c:	e0fff517 	ldw	r3,-44(fp)
 202af90:	10c00115 	stw	r3,4(r2)
 202af94:	00002606 	br	202b030 <rawip_usrreq+0x2e4>
          *
          * if the caller-supplied address is INADDR_ANY,
          * use the wildcard address; else, use the caller-
          * supplied address
          */
         if (sin->sin_addr.s_addr == INADDR_ANY)
 202af98:	e0bffa17 	ldw	r2,-24(fp)
 202af9c:	10800117 	ldw	r2,4(r2)
 202afa0:	1000021e 	bne	r2,zero,202afac <rawip_usrreq+0x260>
            fhost = 0L;
 202afa4:	e03ff415 	stw	zero,-48(fp)
 202afa8:	00000306 	br	202afb8 <rawip_usrreq+0x26c>
         else
            fhost = sin->sin_addr.s_addr;
 202afac:	e0bffa17 	ldw	r2,-24(fp)
 202afb0:	10800117 	ldw	r2,4(r2)
 202afb4:	e0bff415 	stw	r2,-48(fp)
         /* connect the IP endpoint */
         ep->ipr_faddr = fhost;
 202afb8:	e0bff917 	ldw	r2,-28(fp)
 202afbc:	e0fff417 	ldw	r3,-48(fp)
 202afc0:	10c00215 	stw	r3,8(r2)
         /* mark the socket as connected or disconnected, as appropriate */
         if (fhost != 0L) {
 202afc4:	e0bff417 	ldw	r2,-48(fp)
 202afc8:	10000e26 	beq	r2,zero,202b004 <rawip_usrreq+0x2b8>
            so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 202afcc:	e0bffd17 	ldw	r2,-12(fp)
 202afd0:	10c0088b 	ldhu	r3,34(r2)
 202afd4:	00bffcc4 	movi	r2,-13
 202afd8:	1884703a 	and	r2,r3,r2
 202afdc:	1007883a 	mov	r3,r2
 202afe0:	e0bffd17 	ldw	r2,-12(fp)
 202afe4:	10c0088d 	sth	r3,34(r2)
            so->so_state |= SS_ISCONNECTED;
 202afe8:	e0bffd17 	ldw	r2,-12(fp)
 202afec:	1080088b 	ldhu	r2,34(r2)
 202aff0:	10800094 	ori	r2,r2,2
 202aff4:	1007883a 	mov	r3,r2
 202aff8:	e0bffd17 	ldw	r2,-12(fp)
 202affc:	10c0088d 	sth	r3,34(r2)
 202b000:	00000706 	br	202b020 <rawip_usrreq+0x2d4>
         }
         else
         {
            so->so_state &= ~SS_ISCONNECTED;
 202b004:	e0bffd17 	ldw	r2,-12(fp)
 202b008:	10c0088b 	ldhu	r3,34(r2)
 202b00c:	00bfff44 	movi	r2,-3
 202b010:	1884703a 	and	r2,r3,r2
 202b014:	1007883a 	mov	r3,r2
 202b018:	e0bffd17 	ldw	r2,-12(fp)
 202b01c:	10c0088d 	sth	r3,34(r2)
         }
         /* since socket was in listen state, packets may be queued */
         sbflush(&so->so_rcv);   /* dump these now */
 202b020:	e0bffd17 	ldw	r2,-12(fp)
 202b024:	10800a04 	addi	r2,r2,40
 202b028:	1009883a 	mov	r4,r2
 202b02c:	202fa0c0 	call	202fa0c <sbflush>
      }
      return 0;
 202b030:	0005883a 	mov	r2,zero
 202b034:	00011106 	br	202b47c <rawip_usrreq+0x730>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 202b038:	e0bffe17 	ldw	r2,-8(fp)
 202b03c:	1000021e 	bne	r2,zero,202b048 <rawip_usrreq+0x2fc>
         return(EINVAL);
 202b040:	00800584 	movi	r2,22
 202b044:	00010d06 	br	202b47c <rawip_usrreq+0x730>

      ep = rawip_lookup(so);
 202b048:	e13ffd17 	ldw	r4,-12(fp)
 202b04c:	202ab200 	call	202ab20 <rawip_lookup>
 202b050:	e0bff915 	stw	r2,-28(fp)
      if (!ep)
 202b054:	e0bff917 	ldw	r2,-28(fp)
 202b058:	1000041e 	bne	r2,zero,202b06c <rawip_usrreq+0x320>
      {
         m_free(m);
 202b05c:	e13ffe17 	ldw	r4,-8(fp)
 202b060:	20295600 	call	2029560 <m_free>
         /* may be bogus socket, but more likely the connection may 
         have closed due to ICMP dest unreachable from other side. */
         return(ECONNREFUSED);
 202b064:	00801bc4 	movi	r2,111
 202b068:	00010406 	br	202b47c <rawip_usrreq+0x730>
      }

      if (nam == NULL)  /* no sendto() info passed, must be send() */
 202b06c:	e0bfff17 	ldw	r2,-4(fp)
 202b070:	10000b1e 	bne	r2,zero,202b0a0 <rawip_usrreq+0x354>
      {
         if (!(so->so_state & SS_ISCONNECTED))
 202b074:	e0bffd17 	ldw	r2,-12(fp)
 202b078:	1080088b 	ldhu	r2,34(r2)
 202b07c:	10bfffcc 	andi	r2,r2,65535
 202b080:	1080008c 	andi	r2,r2,2
 202b084:	1000021e 	bne	r2,zero,202b090 <rawip_usrreq+0x344>
            return (ENOTCONN);
 202b088:	00802004 	movi	r2,128
 202b08c:	0000fb06 	br	202b47c <rawip_usrreq+0x730>
         fhost = ep->ipr_faddr;
 202b090:	e0bff917 	ldw	r2,-28(fp)
 202b094:	10800217 	ldw	r2,8(r2)
 202b098:	e0bff415 	stw	r2,-48(fp)
 202b09c:	00001406 	br	202b0f0 <rawip_usrreq+0x3a4>
      }
      else 
      {
         if (so->so_state & SS_ISCONNECTED)
 202b0a0:	e0bffd17 	ldw	r2,-12(fp)
 202b0a4:	1080088b 	ldhu	r2,34(r2)
 202b0a8:	10bfffcc 	andi	r2,r2,65535
 202b0ac:	1080008c 	andi	r2,r2,2
 202b0b0:	10000226 	beq	r2,zero,202b0bc <rawip_usrreq+0x370>
            return (EISCONN);
 202b0b4:	00801fc4 	movi	r2,127
 202b0b8:	0000f006 	br	202b47c <rawip_usrreq+0x730>
         if (nam->m_len != sizeof (*sin))
 202b0bc:	e0bfff17 	ldw	r2,-4(fp)
 202b0c0:	10800217 	ldw	r2,8(r2)
 202b0c4:	10800420 	cmpeqi	r2,r2,16
 202b0c8:	1000031e 	bne	r2,zero,202b0d8 <rawip_usrreq+0x38c>
         {
            dtrap();
 202b0cc:	20285c80 	call	20285c8 <dtrap>
            return (EINVAL);
 202b0d0:	00800584 	movi	r2,22
 202b0d4:	0000e906 	br	202b47c <rawip_usrreq+0x730>
         }
         sin = mtod(nam, struct sockaddr_in *);
 202b0d8:	e0bfff17 	ldw	r2,-4(fp)
 202b0dc:	10800317 	ldw	r2,12(r2)
 202b0e0:	e0bffa15 	stw	r2,-24(fp)
         fhost = sin->sin_addr.s_addr;
 202b0e4:	e0bffa17 	ldw	r2,-24(fp)
 202b0e8:	10800117 	ldw	r2,4(r2)
 202b0ec:	e0bff415 	stw	r2,-48(fp)

      /* since our pkt->nb_buff size is tied to max packet size, we 
       * assume our raw IP datagrams are always in one mbuf and that the 
       * mbuf -- but check anyway
       */
      if (m->m_len > (unsigned)ip_raw_maxalloc(so->so_options & SO_HDRINCL))
 202b0f0:	e0bffe17 	ldw	r2,-8(fp)
 202b0f4:	14000217 	ldw	r16,8(r2)
 202b0f8:	e0bffd17 	ldw	r2,-12(fp)
 202b0fc:	10800417 	ldw	r2,16(r2)
 202b100:	1088000c 	andi	r2,r2,8192
 202b104:	1009883a 	mov	r4,r2
 202b108:	20446e00 	call	20446e0 <ip_raw_maxalloc>
 202b10c:	1400032e 	bgeu	r2,r16,202b11c <rawip_usrreq+0x3d0>
      {
         dtrap(); /* should never happen */
 202b110:	20285c80 	call	20285c8 <dtrap>
         return EMSGSIZE;  /* try to recover */
 202b114:	00801e84 	movi	r2,122
 202b118:	0000d806 	br	202b47c <rawip_usrreq+0x730>
      }
      /* get a packet buffer for send */
      pkt = ip_raw_alloc(m->m_len, so->so_options & SO_HDRINCL);
 202b11c:	e0bffe17 	ldw	r2,-8(fp)
 202b120:	10800217 	ldw	r2,8(r2)
 202b124:	1007883a 	mov	r3,r2
 202b128:	e0bffd17 	ldw	r2,-12(fp)
 202b12c:	10800417 	ldw	r2,16(r2)
 202b130:	1088000c 	andi	r2,r2,8192
 202b134:	1809883a 	mov	r4,r3
 202b138:	100b883a 	mov	r5,r2
 202b13c:	20445e00 	call	20445e0 <ip_raw_alloc>
 202b140:	e0bffb15 	stw	r2,-20(fp)
      if (!pkt)
 202b144:	e0bffb17 	ldw	r2,-20(fp)
 202b148:	1000041e 	bne	r2,zero,202b15c <rawip_usrreq+0x410>
      {
         m_free(m);
 202b14c:	e13ffe17 	ldw	r4,-8(fp)
 202b150:	20295600 	call	2029560 <m_free>
         return ENOBUFS;   /* report buffer shortages */
 202b154:	00801a44 	movi	r2,105
 202b158:	0000c806 	br	202b47c <rawip_usrreq+0x730>
      }
      MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 202b15c:	e0bffb17 	ldw	r2,-20(fp)
 202b160:	11000317 	ldw	r4,12(r2)
 202b164:	e0bffe17 	ldw	r2,-8(fp)
 202b168:	10c00317 	ldw	r3,12(r2)
 202b16c:	e0bffe17 	ldw	r2,-8(fp)
 202b170:	10800217 	ldw	r2,8(r2)
 202b174:	180b883a 	mov	r5,r3
 202b178:	100d883a 	mov	r6,r2
 202b17c:	200660c0 	call	200660c <memcpy>
      pkt->nb_plen = m->m_len;
 202b180:	e0bffe17 	ldw	r2,-8(fp)
 202b184:	10c00217 	ldw	r3,8(r2)
 202b188:	e0bffb17 	ldw	r2,-20(fp)
 202b18c:	10c00415 	stw	r3,16(r2)
      /* finished with mbuf, free it now */
      m_free(m);
 202b190:	e13ffe17 	ldw	r4,-8(fp)
 202b194:	20295600 	call	2029560 <m_free>
      pkt->fhost = fhost;
 202b198:	e0bffb17 	ldw	r2,-20(fp)
 202b19c:	e0fff417 	ldw	r3,-48(fp)
 202b1a0:	10c00715 	stw	r3,28(r2)
       * is up; if (after all that) we don't have an interface then we
       * fail with error EADDRNOTAVAIL; and finally, if we're built
       * for a single-homed configuration where there's only one
       * interface, we might as well use it, so we do.  
       */
      if (fhost == 0xffffffff)
 202b1a4:	e0bff417 	ldw	r2,-48(fp)
 202b1a8:	10bfffd8 	cmpnei	r2,r2,-1
 202b1ac:	10004a1e 	bne	r2,zero,202b2d8 <rawip_usrreq+0x58c>
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
 202b1b0:	e0bff917 	ldw	r2,-28(fp)
 202b1b4:	10800117 	ldw	r2,4(r2)
 202b1b8:	10001026 	beq	r2,zero,202b1fc <rawip_usrreq+0x4b0>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202b1bc:	00809934 	movhi	r2,612
 202b1c0:	10b7ce04 	addi	r2,r2,-8392
 202b1c4:	10800017 	ldw	r2,0(r2)
 202b1c8:	e0bff615 	stw	r2,-40(fp)
 202b1cc:	00000806 	br	202b1f0 <rawip_usrreq+0x4a4>
               if (ifp->n_ipaddr == ep->ipr_laddr)
 202b1d0:	e0bff617 	ldw	r2,-40(fp)
 202b1d4:	10c00a17 	ldw	r3,40(r2)
 202b1d8:	e0bff917 	ldw	r2,-28(fp)
 202b1dc:	10800117 	ldw	r2,4(r2)
 202b1e0:	18801d26 	beq	r3,r2,202b258 <rawip_usrreq+0x50c>
      if (fhost == 0xffffffff)
      {
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202b1e4:	e0bff617 	ldw	r2,-40(fp)
 202b1e8:	10800017 	ldw	r2,0(r2)
 202b1ec:	e0bff615 	stw	r2,-40(fp)
 202b1f0:	e0bff617 	ldw	r2,-40(fp)
 202b1f4:	103ff61e 	bne	r2,zero,202b1d0 <rawip_usrreq+0x484>
 202b1f8:	00001a06 	br	202b264 <rawip_usrreq+0x518>
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202b1fc:	00809934 	movhi	r2,612
 202b200:	10b7ce04 	addi	r2,r2,-8392
 202b204:	10800017 	ldw	r2,0(r2)
 202b208:	e0bff615 	stw	r2,-40(fp)
 202b20c:	00000f06 	br	202b24c <rawip_usrreq+0x500>
               if ((ifp->n_flags & NF_BCAST) &&
 202b210:	e0bff617 	ldw	r2,-40(fp)
 202b214:	10802a17 	ldw	r2,168(r2)
 202b218:	1080004c 	andi	r2,r2,1
 202b21c:	10000826 	beq	r2,zero,202b240 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 202b220:	e0bff617 	ldw	r2,-40(fp)
 202b224:	10802717 	ldw	r2,156(r2)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
 202b228:	10000526 	beq	r2,zero,202b240 <rawip_usrreq+0x4f4>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 202b22c:	e0bff617 	ldw	r2,-40(fp)
 202b230:	10802717 	ldw	r2,156(r2)
 202b234:	10800617 	ldw	r2,24(r2)
 202b238:	10800058 	cmpnei	r2,r2,1
 202b23c:	10000826 	beq	r2,zero,202b260 <rawip_usrreq+0x514>
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202b240:	e0bff617 	ldw	r2,-40(fp)
 202b244:	10800017 	ldw	r2,0(r2)
 202b248:	e0bff615 	stw	r2,-40(fp)
 202b24c:	e0bff617 	ldw	r2,-40(fp)
 202b250:	103fef1e 	bne	r2,zero,202b210 <rawip_usrreq+0x4c4>
 202b254:	00000306 	br	202b264 <rawip_usrreq+0x518>
#ifdef MULTI_HOMED
         if (ep->ipr_laddr != 0L)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if (ifp->n_ipaddr == ep->ipr_laddr)
                  break;
 202b258:	0001883a 	nop
 202b25c:	00000106 	br	202b264 <rawip_usrreq+0x518>
         }
         else {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
               if ((ifp->n_flags & NF_BCAST) &&
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 202b260:	0001883a 	nop
         }
         if (ifp == NULL)
 202b264:	e0bff617 	ldw	r2,-40(fp)
 202b268:	1000181e 	bne	r2,zero,202b2cc <rawip_usrreq+0x580>
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202b26c:	00809934 	movhi	r2,612
 202b270:	10b7ce04 	addi	r2,r2,-8392
 202b274:	10800017 	ldw	r2,0(r2)
 202b278:	e0bff615 	stw	r2,-40(fp)
 202b27c:	00000b06 	br	202b2ac <rawip_usrreq+0x560>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 202b280:	e0bff617 	ldw	r2,-40(fp)
 202b284:	10802717 	ldw	r2,156(r2)
 202b288:	10000526 	beq	r2,zero,202b2a0 <rawip_usrreq+0x554>
 202b28c:	e0bff617 	ldw	r2,-40(fp)
 202b290:	10802717 	ldw	r2,156(r2)
 202b294:	10800617 	ldw	r2,24(r2)
 202b298:	10800058 	cmpnei	r2,r2,1
 202b29c:	10000626 	beq	r2,zero,202b2b8 <rawip_usrreq+0x56c>
                   (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
         }
         if (ifp == NULL)
         {
            for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 202b2a0:	e0bff617 	ldw	r2,-40(fp)
 202b2a4:	10800017 	ldw	r2,0(r2)
 202b2a8:	e0bff615 	stw	r2,-40(fp)
 202b2ac:	e0bff617 	ldw	r2,-40(fp)
 202b2b0:	103ff31e 	bne	r2,zero,202b280 <rawip_usrreq+0x534>
 202b2b4:	00000106 	br	202b2bc <rawip_usrreq+0x570>
               if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
                  break;
 202b2b8:	0001883a 	nop
            if (ifp == NULL)
 202b2bc:	e0bff617 	ldw	r2,-40(fp)
 202b2c0:	1000021e 	bne	r2,zero,202b2cc <rawip_usrreq+0x580>
               return(EADDRNOTAVAIL);
 202b2c4:	00801f44 	movi	r2,125
 202b2c8:	00006c06 	br	202b47c <rawip_usrreq+0x730>
         }
         pkt->net = ifp;
 202b2cc:	e0bffb17 	ldw	r2,-20(fp)
 202b2d0:	e0fff617 	ldw	r3,-40(fp)
 202b2d4:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

      /* If the socket has an IP moptions structure for multicast options,
       * place a pointer to this structure in the PACKET structure.
       */
      if (so->inp_moptions)
 202b2d8:	e0bffd17 	ldw	r2,-12(fp)
 202b2dc:	10800317 	ldw	r2,12(r2)
 202b2e0:	10000426 	beq	r2,zero,202b2f4 <rawip_usrreq+0x5a8>
         pkt->imo = so->inp_moptions;
 202b2e4:	e0bffd17 	ldw	r2,-12(fp)
 202b2e8:	10c00317 	ldw	r3,12(r2)
 202b2ec:	e0bffb17 	ldw	r2,-20(fp)
 202b2f0:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

      if (so->so_options & SO_HDRINCL)
 202b2f4:	e0bffd17 	ldw	r2,-12(fp)
 202b2f8:	10800417 	ldw	r2,16(r2)
 202b2fc:	1088000c 	andi	r2,r2,8192
 202b300:	10000826 	beq	r2,zero,202b324 <rawip_usrreq+0x5d8>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 202b304:	0009883a 	mov	r4,zero
 202b308:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         e = ip_raw_write(pkt);
 202b30c:	e13ffb17 	ldw	r4,-20(fp)
 202b310:	20403080 	call	2040308 <ip_raw_write>
 202b314:	e0bff315 	stw	r2,-52(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 202b318:	0009883a 	mov	r4,zero
 202b31c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
 202b320:	00002706 	br	202b3c0 <rawip_usrreq+0x674>
      }
      else
      {
         pip = (struct ip *)(pkt->nb_prot - IPHSIZ);
 202b324:	e0bffb17 	ldw	r2,-20(fp)
 202b328:	10800317 	ldw	r2,12(r2)
 202b32c:	10bffb04 	addi	r2,r2,-20
 202b330:	e0bffc15 	stw	r2,-16(fp)
         if (ep->ipr_laddr)
 202b334:	e0bff917 	ldw	r2,-28(fp)
 202b338:	10800117 	ldw	r2,4(r2)
 202b33c:	10000526 	beq	r2,zero,202b354 <rawip_usrreq+0x608>
            pip->ip_src = ep->ipr_laddr;
 202b340:	e0bff917 	ldw	r2,-28(fp)
 202b344:	10c00117 	ldw	r3,4(r2)
 202b348:	e0bffc17 	ldw	r2,-16(fp)
 202b34c:	10c00315 	stw	r3,12(r2)
 202b350:	00000d06 	br	202b388 <rawip_usrreq+0x63c>
         else
         {
            if (fhost == 0xffffffff)
 202b354:	e0bff417 	ldw	r2,-48(fp)
 202b358:	10bfffd8 	cmpnei	r2,r2,-1
 202b35c:	1000061e 	bne	r2,zero,202b378 <rawip_usrreq+0x62c>
               pip->ip_src = pkt->net->n_ipaddr;
 202b360:	e0bffb17 	ldw	r2,-20(fp)
 202b364:	10800617 	ldw	r2,24(r2)
 202b368:	10c00a17 	ldw	r3,40(r2)
 202b36c:	e0bffc17 	ldw	r2,-16(fp)
 202b370:	10c00315 	stw	r3,12(r2)
 202b374:	00000406 	br	202b388 <rawip_usrreq+0x63c>
            else
               pip->ip_src = ip_mymach(fhost);
 202b378:	e13ff417 	ldw	r4,-48(fp)
 202b37c:	2040d940 	call	2040d94 <ip_mymach>
 202b380:	e0fffc17 	ldw	r3,-16(fp)
 202b384:	18800315 	stw	r2,12(r3)
         }
         pip->ip_dest = fhost;
 202b388:	e0bffc17 	ldw	r2,-16(fp)
 202b38c:	e0fff417 	ldw	r3,-48(fp)
 202b390:	10c00415 	stw	r3,16(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 202b394:	0009883a 	mov	r4,zero
 202b398:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         e = ip_write(ep->ipr_prot, pkt);
 202b39c:	e0bff917 	ldw	r2,-28(fp)
 202b3a0:	10800503 	ldbu	r2,20(r2)
 202b3a4:	10803fcc 	andi	r2,r2,255
 202b3a8:	1009883a 	mov	r4,r2
 202b3ac:	e17ffb17 	ldw	r5,-20(fp)
 202b3b0:	203fd780 	call	203fd78 <ip_write>
 202b3b4:	e0bff315 	stw	r2,-52(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 202b3b8:	0009883a 	mov	r4,zero
 202b3bc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      }         
      if (e < 0) 
 202b3c0:	e0bff317 	ldw	r2,-52(fp)
 202b3c4:	1000020e 	bge	r2,zero,202b3d0 <rawip_usrreq+0x684>
         return(e);
 202b3c8:	e0bff317 	ldw	r2,-52(fp)
 202b3cc:	00002b06 	br	202b47c <rawip_usrreq+0x730>
      return 0;
 202b3d0:	0005883a 	mov	r2,zero
 202b3d4:	00002906 	br	202b47c <rawip_usrreq+0x730>
   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 202b3d8:	e0bfff17 	ldw	r2,-4(fp)
 202b3dc:	1000021e 	bne	r2,zero,202b3e8 <rawip_usrreq+0x69c>
         return(EINVAL);
 202b3e0:	00800584 	movi	r2,22
 202b3e4:	00002506 	br	202b47c <rawip_usrreq+0x730>
      sin = mtod(nam, struct sockaddr_in *);
 202b3e8:	e0bfff17 	ldw	r2,-4(fp)
 202b3ec:	10800317 	ldw	r2,12(r2)
 202b3f0:	e0bffa15 	stw	r2,-24(fp)
      if (sin == NULL)
 202b3f4:	e0bffa17 	ldw	r2,-24(fp)
 202b3f8:	1000021e 	bne	r2,zero,202b404 <rawip_usrreq+0x6b8>
         return(EINVAL);
 202b3fc:	00800584 	movi	r2,22
 202b400:	00001e06 	br	202b47c <rawip_usrreq+0x730>
      ep = rawip_lookup(so);
 202b404:	e13ffd17 	ldw	r4,-12(fp)
 202b408:	202ab200 	call	202ab20 <rawip_lookup>
 202b40c:	e0bff915 	stw	r2,-28(fp)
      if (!ep)
 202b410:	e0bff917 	ldw	r2,-28(fp)
 202b414:	1000021e 	bne	r2,zero,202b420 <rawip_usrreq+0x6d4>
         return(EINVAL);
 202b418:	00800584 	movi	r2,22
 202b41c:	00001706 	br	202b47c <rawip_usrreq+0x730>
      sin->sin_port = 0;
 202b420:	e0bffa17 	ldw	r2,-24(fp)
 202b424:	1000008d 	sth	zero,2(r2)
      nam->m_len = sizeof(*sin);
 202b428:	e0bfff17 	ldw	r2,-4(fp)
 202b42c:	00c00404 	movi	r3,16
 202b430:	10c00215 	stw	r3,8(r2)
      if (req == PRU_SOCKADDR)
 202b434:	e0bff717 	ldw	r2,-36(fp)
 202b438:	108003d8 	cmpnei	r2,r2,15
 202b43c:	1000051e 	bne	r2,zero,202b454 <rawip_usrreq+0x708>
      {
         sin->sin_addr.s_addr = ep->ipr_laddr;
 202b440:	e0bff917 	ldw	r2,-28(fp)
 202b444:	10c00117 	ldw	r3,4(r2)
 202b448:	e0bffa17 	ldw	r2,-24(fp)
 202b44c:	10c00115 	stw	r3,4(r2)
 202b450:	00000406 	br	202b464 <rawip_usrreq+0x718>
      }
      else /* PRU_PEERADDR */
      {
         sin->sin_addr.s_addr = ep->ipr_faddr;
 202b454:	e0bff917 	ldw	r2,-28(fp)
 202b458:	10c00217 	ldw	r3,8(r2)
 202b45c:	e0bffa17 	ldw	r2,-24(fp)
 202b460:	10c00115 	stw	r3,4(r2)
      }
      return 0;
 202b464:	0005883a 	mov	r2,zero
 202b468:	00000406 	br	202b47c <rawip_usrreq+0x730>
   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 202b46c:	20285c80 	call	20285c8 <dtrap>
      return 0;
 202b470:	0005883a 	mov	r2,zero
 202b474:	00000106 	br	202b47c <rawip_usrreq+0x730>
   case PRU_LISTEN:     /* don't support these for raw IP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 202b478:	008017c4 	movi	r2,95
   }
}
 202b47c:	e037883a 	mov	sp,fp
 202b480:	dfc00217 	ldw	ra,8(sp)
 202b484:	df000117 	ldw	fp,4(sp)
 202b488:	dc000017 	ldw	r16,0(sp)
 202b48c:	dec00304 	addi	sp,sp,12
 202b490:	f800283a 	ret

0202b494 <DOMAIN_CHECK>:
 */

#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
 202b494:	defffc04 	addi	sp,sp,-16
 202b498:	dfc00315 	stw	ra,12(sp)
 202b49c:	df000215 	stw	fp,8(sp)
 202b4a0:	df000204 	addi	fp,sp,8
 202b4a4:	e13ffe15 	stw	r4,-8(fp)
 202b4a8:	e17fff15 	stw	r5,-4(fp)
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 202b4ac:	e0bffe17 	ldw	r2,-8(fp)
 202b4b0:	10800517 	ldw	r2,20(r2)
 202b4b4:	10800098 	cmpnei	r2,r2,2
 202b4b8:	1000041e 	bne	r2,zero,202b4cc <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
 202b4bc:	e0bfff17 	ldw	r2,-4(fp)
#ifdef NPDEBUG
void
DOMAIN_CHECK(struct socket * so, int size)
{
#ifdef IP_V4
   if((so->so_domain == AF_INET) &&
 202b4c0:	10800428 	cmpgeui	r2,r2,16
 202b4c4:	1000011e 	bne	r2,zero,202b4cc <DOMAIN_CHECK+0x38>
      (size < sizeof(struct sockaddr_in)))
   {
      dtrap(); /* programmer passed wrong structure */
 202b4c8:	20285c80 	call	20285c8 <dtrap>
      (size != sizeof(struct sockaddr_in6)))
   {
      dtrap(); /* programmer passed wrong structure */
   }
#endif   /* IP_V6 */
}
 202b4cc:	e037883a 	mov	sp,fp
 202b4d0:	dfc00117 	ldw	ra,4(sp)
 202b4d4:	df000017 	ldw	fp,0(sp)
 202b4d8:	dec00204 	addi	sp,sp,8
 202b4dc:	f800283a 	ret

0202b4e0 <t_socket>:

long
t_socket(int family, 
   int   type, 
   int   proto)
{
 202b4e0:	defffa04 	addi	sp,sp,-24
 202b4e4:	dfc00515 	stw	ra,20(sp)
 202b4e8:	df000415 	stw	fp,16(sp)
 202b4ec:	df000404 	addi	fp,sp,16
 202b4f0:	e13ffd15 	stw	r4,-12(fp)
 202b4f4:	e17ffe15 	stw	r5,-8(fp)
 202b4f8:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;

   INET_TRACE (INETM_SOCKET, ("SOCK:sock:family %d, typ %d, proto %d\n",
    family, type, proto));
   LOCK_NET_RESOURCE(NET_RESID);
 202b4fc:	0009883a 	mov	r4,zero
 202b500:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   if ((so = socreate (family, type, proto)) == NULL) 
 202b504:	e13ffd17 	ldw	r4,-12(fp)
 202b508:	e17ffe17 	ldw	r5,-8(fp)
 202b50c:	e1bfff17 	ldw	r6,-4(fp)
 202b510:	202ca8c0 	call	202ca8c <socreate>
 202b514:	e0bffc15 	stw	r2,-16(fp)
 202b518:	e0bffc17 	ldw	r2,-16(fp)
 202b51c:	1000041e 	bne	r2,zero,202b530 <t_socket+0x50>
   {  /* can't really return error info since no socket.... */
      UNLOCK_NET_RESOURCE(NET_RESID);
 202b520:	0009883a 	mov	r4,zero
 202b524:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 202b528:	00bfffc4 	movi	r2,-1
 202b52c:	00000706 	br	202b54c <t_socket+0x6c>
   }
   SOC_RANGE(so);
   so->so_error = 0;
 202b530:	e0bffc17 	ldw	r2,-16(fp)
 202b534:	10000615 	stw	zero,24(r2)
   UNLOCK_NET_RESOURCE(NET_RESID);
 202b538:	0009883a 	mov	r4,zero
 202b53c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return SO2LONG(so);
 202b540:	e0bffc17 	ldw	r2,-16(fp)
 202b544:	1004d0ba 	srli	r2,r2,2
 202b548:	10800804 	addi	r2,r2,32
}
 202b54c:	e037883a 	mov	sp,fp
 202b550:	dfc00117 	ldw	ra,4(sp)
 202b554:	df000017 	ldw	fp,0(sp)
 202b558:	dec00204 	addi	sp,sp,8
 202b55c:	f800283a 	ret

0202b560 <t_bind>:

int
t_bind (long s, 
   struct sockaddr * addr,
   int addrlen)
{
 202b560:	defff204 	addi	sp,sp,-56
 202b564:	dfc00d15 	stw	ra,52(sp)
 202b568:	df000c15 	stw	fp,48(sp)
 202b56c:	df000c04 	addi	fp,sp,48
 202b570:	e13ffd15 	stw	r4,-12(fp)
 202b574:	e17ffe15 	stw	r5,-8(fp)
 202b578:	e1bfff15 	stw	r6,-4(fp)
   struct sockaddr   sa;
   struct sockaddr * sap;
   struct socket *   so;
   int               err;

   so = LONG2SO(s);  /* convert long to socket */
 202b57c:	e0bffd17 	ldw	r2,-12(fp)
 202b580:	10bff804 	addi	r2,r2,-32
 202b584:	1085883a 	add	r2,r2,r2
 202b588:	1085883a 	add	r2,r2,r2
 202b58c:	e0bff615 	stw	r2,-40(fp)
   SOC_CHECK(so);
 202b590:	00809934 	movhi	r2,612
 202b594:	10b6c204 	addi	r2,r2,-9464
 202b598:	e0bff515 	stw	r2,-44(fp)
 202b59c:	00000606 	br	202b5b8 <t_bind+0x58>
 202b5a0:	e0fff517 	ldw	r3,-44(fp)
 202b5a4:	e0bff617 	ldw	r2,-40(fp)
 202b5a8:	18800526 	beq	r3,r2,202b5c0 <t_bind+0x60>
 202b5ac:	e0bff517 	ldw	r2,-44(fp)
 202b5b0:	10800017 	ldw	r2,0(r2)
 202b5b4:	e0bff515 	stw	r2,-44(fp)
 202b5b8:	e0bff517 	ldw	r2,-44(fp)
 202b5bc:	103ff81e 	bne	r2,zero,202b5a0 <t_bind+0x40>
 202b5c0:	e0fff517 	ldw	r3,-44(fp)
 202b5c4:	e0bff617 	ldw	r2,-40(fp)
 202b5c8:	18800326 	beq	r3,r2,202b5d8 <t_bind+0x78>
 202b5cc:	20285c80 	call	20285c8 <dtrap>
 202b5d0:	00bfffc4 	movi	r2,-1
 202b5d4:	00003406 	br	202b6a8 <t_bind+0x148>
   DOMAIN_CHECK(so, addrlen);
 202b5d8:	e13ff617 	ldw	r4,-40(fp)
 202b5dc:	e17fff17 	ldw	r5,-4(fp)
 202b5e0:	202b4940 	call	202b494 <DOMAIN_CHECK>

   so->so_error = 0;
 202b5e4:	e0bff617 	ldw	r2,-40(fp)
 202b5e8:	10000615 	stw	zero,24(r2)
   if (addr == (struct sockaddr *)NULL) 
 202b5ec:	e0bffe17 	ldw	r2,-8(fp)
 202b5f0:	10000d1e 	bne	r2,zero,202b628 <t_bind+0xc8>
   {
      MEMSET ((void *)&sa, 0, sizeof(sa));
 202b5f4:	e0bff904 	addi	r2,fp,-28
 202b5f8:	1009883a 	mov	r4,r2
 202b5fc:	000b883a 	mov	r5,zero
 202b600:	01800404 	movi	r6,16
 202b604:	200682c0 	call	200682c <memset>
      addrlen = sizeof(sa);
 202b608:	00800404 	movi	r2,16
 202b60c:	e0bfff15 	stw	r2,-4(fp)
      sa.sa_family = so->so_domain;
 202b610:	e0bff617 	ldw	r2,-40(fp)
 202b614:	10800517 	ldw	r2,20(r2)
 202b618:	e0bff90d 	sth	r2,-28(fp)
      sap = &sa;
 202b61c:	e0bff904 	addi	r2,fp,-28
 202b620:	e0bff415 	stw	r2,-48(fp)
 202b624:	00000206 	br	202b630 <t_bind+0xd0>
   } else
      sap = addr;
 202b628:	e0bffe17 	ldw	r2,-8(fp)
 202b62c:	e0bff415 	stw	r2,-48(fp)

   if ((nam = sockargs (sap, addrlen, MT_SONAME)) == NULL) 
 202b630:	e13ff417 	ldw	r4,-48(fp)
 202b634:	e17fff17 	ldw	r5,-4(fp)
 202b638:	01800244 	movi	r6,9
 202b63c:	202c9680 	call	202c968 <sockargs>
 202b640:	e0bff715 	stw	r2,-36(fp)
 202b644:	e0bff717 	ldw	r2,-36(fp)
 202b648:	1000051e 	bne	r2,zero,202b660 <t_bind+0x100>
   {
      so->so_error = ENOMEM;
 202b64c:	e0bff617 	ldw	r2,-40(fp)
 202b650:	00c00304 	movi	r3,12
 202b654:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202b658:	00bfffc4 	movi	r2,-1
 202b65c:	00001206 	br	202b6a8 <t_bind+0x148>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 202b660:	0009883a 	mov	r4,zero
 202b664:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   err = sobind (so, nam);
 202b668:	e13ff617 	ldw	r4,-40(fp)
 202b66c:	e17ff717 	ldw	r5,-36(fp)
 202b670:	202cc400 	call	202cc40 <sobind>
 202b674:	e0bff815 	stw	r2,-32(fp)
   m_freem(nam);
 202b678:	e13ff717 	ldw	r4,-36(fp)
 202b67c:	20296780 	call	2029678 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 202b680:	0009883a 	mov	r4,zero
 202b684:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (err) 
 202b688:	e0bff817 	ldw	r2,-32(fp)
 202b68c:	10000526 	beq	r2,zero,202b6a4 <t_bind+0x144>
   {
      so->so_error = err;
 202b690:	e0bff617 	ldw	r2,-40(fp)
 202b694:	e0fff817 	ldw	r3,-32(fp)
 202b698:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202b69c:	00bfffc4 	movi	r2,-1
 202b6a0:	00000106 	br	202b6a8 <t_bind+0x148>
   }
   return 0;
 202b6a4:	0005883a 	mov	r2,zero
}
 202b6a8:	e037883a 	mov	sp,fp
 202b6ac:	dfc00117 	ldw	ra,4(sp)
 202b6b0:	df000017 	ldw	fp,0(sp)
 202b6b4:	dec00204 	addi	sp,sp,8
 202b6b8:	f800283a 	ret

0202b6bc <t_listen>:
 */

int
t_listen(long s, 
   int   backlog)
{
 202b6bc:	defff904 	addi	sp,sp,-28
 202b6c0:	dfc00615 	stw	ra,24(sp)
 202b6c4:	df000515 	stw	fp,20(sp)
 202b6c8:	df000504 	addi	fp,sp,20
 202b6cc:	e13ffe15 	stw	r4,-8(fp)
 202b6d0:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);  /* convert long to socket */
 202b6d4:	e0bffe17 	ldw	r2,-8(fp)
 202b6d8:	10bff804 	addi	r2,r2,-32
 202b6dc:	1085883a 	add	r2,r2,r2
 202b6e0:	1085883a 	add	r2,r2,r2
 202b6e4:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 202b6e8:	00809934 	movhi	r2,612
 202b6ec:	10b6c204 	addi	r2,r2,-9464
 202b6f0:	e0bffb15 	stw	r2,-20(fp)
 202b6f4:	00000606 	br	202b710 <t_listen+0x54>
 202b6f8:	e0fffb17 	ldw	r3,-20(fp)
 202b6fc:	e0bffc17 	ldw	r2,-16(fp)
 202b700:	18800526 	beq	r3,r2,202b718 <t_listen+0x5c>
 202b704:	e0bffb17 	ldw	r2,-20(fp)
 202b708:	10800017 	ldw	r2,0(r2)
 202b70c:	e0bffb15 	stw	r2,-20(fp)
 202b710:	e0bffb17 	ldw	r2,-20(fp)
 202b714:	103ff81e 	bne	r2,zero,202b6f8 <t_listen+0x3c>
 202b718:	e0fffb17 	ldw	r3,-20(fp)
 202b71c:	e0bffc17 	ldw	r2,-16(fp)
 202b720:	18800326 	beq	r3,r2,202b730 <t_listen+0x74>
 202b724:	20285c80 	call	20285c8 <dtrap>
 202b728:	00bfffc4 	movi	r2,-1
 202b72c:	00001206 	br	202b778 <t_listen+0xbc>
   so->so_error = 0;
 202b730:	e0bffc17 	ldw	r2,-16(fp)
 202b734:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("SOCK:listen:qlen %d\n", backlog));

   LOCK_NET_RESOURCE(NET_RESID);
 202b738:	0009883a 	mov	r4,zero
 202b73c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   err = solisten (so, backlog);
 202b740:	e13ffc17 	ldw	r4,-16(fp)
 202b744:	e17fff17 	ldw	r5,-4(fp)
 202b748:	202cc9c0 	call	202cc9c <solisten>
 202b74c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 202b750:	0009883a 	mov	r4,zero
 202b754:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 202b758:	e0bffd17 	ldw	r2,-12(fp)
 202b75c:	10000526 	beq	r2,zero,202b774 <t_listen+0xb8>
   {
      so->so_error = err;
 202b760:	e0bffc17 	ldw	r2,-16(fp)
 202b764:	e0fffd17 	ldw	r3,-12(fp)
 202b768:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202b76c:	00bfffc4 	movi	r2,-1
 202b770:	00000106 	br	202b778 <t_listen+0xbc>
   }
   return 0;
 202b774:	0005883a 	mov	r2,zero
}
 202b778:	e037883a 	mov	sp,fp
 202b77c:	dfc00117 	ldw	ra,4(sp)
 202b780:	df000017 	ldw	fp,0(sp)
 202b784:	dec00204 	addi	sp,sp,8
 202b788:	f800283a 	ret

0202b78c <t_accept>:

long
t_accept(long s, 
   struct sockaddr * addr,
   int * addrlen)
{
 202b78c:	defff704 	addi	sp,sp,-36
 202b790:	dfc00815 	stw	ra,32(sp)
 202b794:	df000715 	stw	fp,28(sp)
 202b798:	df000704 	addi	fp,sp,28
 202b79c:	e13ffd15 	stw	r4,-12(fp)
 202b7a0:	e17ffe15 	stw	r5,-8(fp)
 202b7a4:	e1bfff15 	stw	r6,-4(fp)
   char logbuf[10];
#endif
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 202b7a8:	e0bffd17 	ldw	r2,-12(fp)
 202b7ac:	10bff804 	addi	r2,r2,-32
 202b7b0:	1085883a 	add	r2,r2,r2
 202b7b4:	1085883a 	add	r2,r2,r2
 202b7b8:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 202b7bc:	00809934 	movhi	r2,612
 202b7c0:	10b6c204 	addi	r2,r2,-9464
 202b7c4:	e0bff915 	stw	r2,-28(fp)
 202b7c8:	00000606 	br	202b7e4 <t_accept+0x58>
 202b7cc:	e0fff917 	ldw	r3,-28(fp)
 202b7d0:	e0bffa17 	ldw	r2,-24(fp)
 202b7d4:	18800526 	beq	r3,r2,202b7ec <t_accept+0x60>
 202b7d8:	e0bff917 	ldw	r2,-28(fp)
 202b7dc:	10800017 	ldw	r2,0(r2)
 202b7e0:	e0bff915 	stw	r2,-28(fp)
 202b7e4:	e0bff917 	ldw	r2,-28(fp)
 202b7e8:	103ff81e 	bne	r2,zero,202b7cc <t_accept+0x40>
 202b7ec:	e0fff917 	ldw	r3,-28(fp)
 202b7f0:	e0bffa17 	ldw	r2,-24(fp)
 202b7f4:	18800326 	beq	r3,r2,202b804 <t_accept+0x78>
 202b7f8:	20285c80 	call	20285c8 <dtrap>
 202b7fc:	00bfffc4 	movi	r2,-1
 202b800:	00007006 	br	202b9c4 <t_accept+0x238>
   DOMAIN_CHECK(so, *addrlen);
 202b804:	e0bfff17 	ldw	r2,-4(fp)
 202b808:	10800017 	ldw	r2,0(r2)
 202b80c:	e13ffa17 	ldw	r4,-24(fp)
 202b810:	100b883a 	mov	r5,r2
 202b814:	202b4940 	call	202b494 <DOMAIN_CHECK>

   so->so_error = 0;
 202b818:	e0bffa17 	ldw	r2,-24(fp)
 202b81c:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
      ("INET:accept:so %x so_qlen %d so_state %x\n", so, so->so_qlen, so->so_state));
   if ((so->so_options & SO_ACCEPTCONN) == 0)
 202b820:	e0bffa17 	ldw	r2,-24(fp)
 202b824:	10800417 	ldw	r2,16(r2)
 202b828:	1080008c 	andi	r2,r2,2
 202b82c:	1000051e 	bne	r2,zero,202b844 <t_accept+0xb8>
   {
      so->so_error = EINVAL;
 202b830:	e0bffa17 	ldw	r2,-24(fp)
 202b834:	00c00584 	movi	r3,22
 202b838:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 202b83c:	00bfffc4 	movi	r2,-1
 202b840:	00006006 	br	202b9c4 <t_accept+0x238>
   }
   if ((so->so_state & SS_NBIO) && so->so_qlen == 0)
 202b844:	e0bffa17 	ldw	r2,-24(fp)
 202b848:	1080088b 	ldhu	r2,34(r2)
 202b84c:	10bfffcc 	andi	r2,r2,65535
 202b850:	1080400c 	andi	r2,r2,256
 202b854:	10000b26 	beq	r2,zero,202b884 <t_accept+0xf8>
 202b858:	e0bffa17 	ldw	r2,-24(fp)
 202b85c:	10801e43 	ldbu	r2,121(r2)
 202b860:	10803fcc 	andi	r2,r2,255
 202b864:	1080201c 	xori	r2,r2,128
 202b868:	10bfe004 	addi	r2,r2,-128
 202b86c:	1000051e 	bne	r2,zero,202b884 <t_accept+0xf8>
   {
      so->so_error = EWOULDBLOCK;
 202b870:	e0bffa17 	ldw	r2,-24(fp)
 202b874:	00c002c4 	movi	r3,11
 202b878:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 202b87c:	00bfffc4 	movi	r2,-1
 202b880:	00005006 	br	202b9c4 <t_accept+0x238>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 202b884:	0009883a 	mov	r4,zero
 202b888:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   while (so->so_qlen == 0 && so->so_error == 0)
 202b88c:	00001006 	br	202b8d0 <t_accept+0x144>
   {
      if (so->so_state & SS_CANTRCVMORE)
 202b890:	e0bffa17 	ldw	r2,-24(fp)
 202b894:	1080088b 	ldhu	r2,34(r2)
 202b898:	10bfffcc 	andi	r2,r2,65535
 202b89c:	1080080c 	andi	r2,r2,32
 202b8a0:	10000726 	beq	r2,zero,202b8c0 <t_accept+0x134>
      {
         so->so_error = ECONNABORTED;
 202b8a4:	e0bffa17 	ldw	r2,-24(fp)
 202b8a8:	00c01c44 	movi	r3,113
 202b8ac:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE(NET_RESID);
 202b8b0:	0009883a 	mov	r4,zero
 202b8b4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 202b8b8:	00bfffc4 	movi	r2,-1
 202b8bc:	00004106 	br	202b9c4 <t_accept+0x238>
      }
      tcp_sleep ((char *)&so->so_timeo);
 202b8c0:	e0bffa17 	ldw	r2,-24(fp)
 202b8c4:	10800904 	addi	r2,r2,36
 202b8c8:	1009883a 	mov	r4,r2
 202b8cc:	20274f40 	call	20274f4 <tcp_sleep>
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
   }
   LOCK_NET_RESOURCE(NET_RESID);
   while (so->so_qlen == 0 && so->so_error == 0)
 202b8d0:	e0bffa17 	ldw	r2,-24(fp)
 202b8d4:	10801e43 	ldbu	r2,121(r2)
 202b8d8:	10803fcc 	andi	r2,r2,255
 202b8dc:	1080201c 	xori	r2,r2,128
 202b8e0:	10bfe004 	addi	r2,r2,-128
 202b8e4:	1000031e 	bne	r2,zero,202b8f4 <t_accept+0x168>
 202b8e8:	e0bffa17 	ldw	r2,-24(fp)
 202b8ec:	10800617 	ldw	r2,24(r2)
 202b8f0:	103fe726 	beq	r2,zero,202b890 <t_accept+0x104>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return SOCKET_ERROR;
      }
      tcp_sleep ((char *)&so->so_timeo);
   }
   if (so->so_error)
 202b8f4:	e0bffa17 	ldw	r2,-24(fp)
 202b8f8:	10800617 	ldw	r2,24(r2)
 202b8fc:	10000426 	beq	r2,zero,202b910 <t_accept+0x184>
   {
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 202b900:	0009883a 	mov	r4,zero
 202b904:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 202b908:	00bfffc4 	movi	r2,-1
 202b90c:	00002d06 	br	202b9c4 <t_accept+0x238>
   }
   nam = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 202b910:	01000244 	movi	r4,9
 202b914:	01400404 	movi	r5,16
 202b918:	20293d80 	call	20293d8 <m_getnbuf>
 202b91c:	e0bffb15 	stw	r2,-20(fp)
   if (nam == NULL) 
 202b920:	e0bffb17 	ldw	r2,-20(fp)
 202b924:	1000071e 	bne	r2,zero,202b944 <t_accept+0x1b8>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 202b928:	0009883a 	mov	r4,zero
 202b92c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      so->so_error = ENOMEM;
 202b930:	e0bffa17 	ldw	r2,-24(fp)
 202b934:	00c00304 	movi	r3,12
 202b938:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_accept[%d]: %d", __LINE__, so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 202b93c:	00bfffc4 	movi	r2,-1
 202b940:	00002006 	br	202b9c4 <t_accept+0x238>
   }
   { 
      struct socket *aso = so->so_q;
 202b944:	e0bffa17 	ldw	r2,-24(fp)
 202b948:	10801d17 	ldw	r2,116(r2)
 202b94c:	e0bffc15 	stw	r2,-16(fp)
      if (soqremque (aso, 1) == 0)
 202b950:	e13ffc17 	ldw	r4,-16(fp)
 202b954:	01400044 	movi	r5,1
 202b958:	202f0e00 	call	202f0e0 <soqremque>
 202b95c:	1000031e 	bne	r2,zero,202b96c <t_accept+0x1e0>
         panic("accept");
 202b960:	01008174 	movhi	r4,517
 202b964:	213d4804 	addi	r4,r4,-2784
 202b968:	2026bf80 	call	2026bf8 <panic>
      so = aso;
 202b96c:	e0bffc17 	ldw	r2,-16(fp)
 202b970:	e0bffa15 	stw	r2,-24(fp)
   }
   (void)soaccept (so, nam);
 202b974:	e13ffa17 	ldw	r4,-24(fp)
 202b978:	e17ffb17 	ldw	r5,-20(fp)
 202b97c:	202d2240 	call	202d224 <soaccept>
      INET_TRACE (INETM_SOCKET, ("INET:accept:done so %lx port %d addr %lx\n",
       so, sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_INET */
   /* return the addressing info in the passed structure */
   if (addr != NULL)
 202b980:	e0bffe17 	ldw	r2,-8(fp)
 202b984:	10000826 	beq	r2,zero,202b9a8 <t_accept+0x21c>
      MEMCPY(addr, nam->m_data, *addrlen);
 202b988:	e0bffb17 	ldw	r2,-20(fp)
 202b98c:	10c00317 	ldw	r3,12(r2)
 202b990:	e0bfff17 	ldw	r2,-4(fp)
 202b994:	10800017 	ldw	r2,0(r2)
 202b998:	e13ffe17 	ldw	r4,-8(fp)
 202b99c:	180b883a 	mov	r5,r3
 202b9a0:	100d883a 	mov	r6,r2
 202b9a4:	200660c0 	call	200660c <memcpy>
   m_freem (nam);
 202b9a8:	e13ffb17 	ldw	r4,-20(fp)
 202b9ac:	20296780 	call	2029678 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 202b9b0:	0009883a 	mov	r4,zero
 202b9b4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   SOC_RANGE(so);
   return SO2LONG(so);
 202b9b8:	e0bffa17 	ldw	r2,-24(fp)
 202b9bc:	1004d0ba 	srli	r2,r2,2
 202b9c0:	10800804 	addi	r2,r2,32
}
 202b9c4:	e037883a 	mov	sp,fp
 202b9c8:	dfc00117 	ldw	ra,4(sp)
 202b9cc:	df000017 	ldw	fp,0(sp)
 202b9d0:	dec00204 	addi	sp,sp,8
 202b9d4:	f800283a 	ret

0202b9d8 <t_connect>:

int
t_connect(long s, 
   struct sockaddr * addr,
   int   addrlen)
{
 202b9d8:	defff804 	addi	sp,sp,-32
 202b9dc:	dfc00715 	stw	ra,28(sp)
 202b9e0:	df000615 	stw	fp,24(sp)
 202b9e4:	df000604 	addi	fp,sp,24
 202b9e8:	e13ffd15 	stw	r4,-12(fp)
 202b9ec:	e17ffe15 	stw	r5,-8(fp)
 202b9f0:	e1bfff15 	stw	r6,-4(fp)
   struct socket *   so;
   struct mbuf *  nam;

   so = LONG2SO(s);
 202b9f4:	e0bffd17 	ldw	r2,-12(fp)
 202b9f8:	10bff804 	addi	r2,r2,-32
 202b9fc:	1085883a 	add	r2,r2,r2
 202ba00:	1085883a 	add	r2,r2,r2
 202ba04:	e0bffb15 	stw	r2,-20(fp)
   SOC_CHECK(so);
 202ba08:	00809934 	movhi	r2,612
 202ba0c:	10b6c204 	addi	r2,r2,-9464
 202ba10:	e0bffa15 	stw	r2,-24(fp)
 202ba14:	00000606 	br	202ba30 <t_connect+0x58>
 202ba18:	e0fffa17 	ldw	r3,-24(fp)
 202ba1c:	e0bffb17 	ldw	r2,-20(fp)
 202ba20:	18800526 	beq	r3,r2,202ba38 <t_connect+0x60>
 202ba24:	e0bffa17 	ldw	r2,-24(fp)
 202ba28:	10800017 	ldw	r2,0(r2)
 202ba2c:	e0bffa15 	stw	r2,-24(fp)
 202ba30:	e0bffa17 	ldw	r2,-24(fp)
 202ba34:	103ff81e 	bne	r2,zero,202ba18 <t_connect+0x40>
 202ba38:	e0fffa17 	ldw	r3,-24(fp)
 202ba3c:	e0bffb17 	ldw	r2,-20(fp)
 202ba40:	18800326 	beq	r3,r2,202ba50 <t_connect+0x78>
 202ba44:	20285c80 	call	20285c8 <dtrap>
 202ba48:	00bfffc4 	movi	r2,-1
 202ba4c:	00007706 	br	202bc2c <t_connect+0x254>
   DOMAIN_CHECK(so, addrlen);
 202ba50:	e13ffb17 	ldw	r4,-20(fp)
 202ba54:	e17fff17 	ldw	r5,-4(fp)
 202ba58:	202b4940 	call	202b494 <DOMAIN_CHECK>

#ifdef NB_CONNECT
   /* need to test non blocking connect bits in case this is a 
      poll of a previous request */
   if (so->so_state & SS_NBIO)
 202ba5c:	e0bffb17 	ldw	r2,-20(fp)
 202ba60:	1080088b 	ldhu	r2,34(r2)
 202ba64:	10bfffcc 	andi	r2,r2,65535
 202ba68:	1080400c 	andi	r2,r2,256
 202ba6c:	10002426 	beq	r2,zero,202bb00 <t_connect+0x128>
   {
      if (so->so_state & SS_ISCONNECTING) /* still trying */
 202ba70:	e0bffb17 	ldw	r2,-20(fp)
 202ba74:	1080088b 	ldhu	r2,34(r2)
 202ba78:	10bfffcc 	andi	r2,r2,65535
 202ba7c:	1080010c 	andi	r2,r2,4
 202ba80:	10000526 	beq	r2,zero,202ba98 <t_connect+0xc0>
      {
         so->so_error = EINPROGRESS;
 202ba84:	e0bffb17 	ldw	r2,-20(fp)
 202ba88:	00c01dc4 	movi	r3,119
 202ba8c:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 202ba90:	00bfffc4 	movi	r2,-1
 202ba94:	00006506 	br	202bc2c <t_connect+0x254>
      }
      if (so->so_state & SS_ISCONNECTED)  /* connected OK */
 202ba98:	e0bffb17 	ldw	r2,-20(fp)
 202ba9c:	1080088b 	ldhu	r2,34(r2)
 202baa0:	10bfffcc 	andi	r2,r2,65535
 202baa4:	1080008c 	andi	r2,r2,2
 202baa8:	10000426 	beq	r2,zero,202babc <t_connect+0xe4>
      {
         so->so_error = 0;
 202baac:	e0bffb17 	ldw	r2,-20(fp)
 202bab0:	10000615 	stw	zero,24(r2)
         return 0;
 202bab4:	0005883a 	mov	r2,zero
 202bab8:	00005c06 	br	202bc2c <t_connect+0x254>
      }
      if (so->so_state & SS_WASCONNECTING)
 202babc:	e0bffb17 	ldw	r2,-20(fp)
 202bac0:	1080088b 	ldhu	r2,34(r2)
 202bac4:	10bfffcc 	andi	r2,r2,65535
 202bac8:	1088000c 	andi	r2,r2,8192
 202bacc:	10000c26 	beq	r2,zero,202bb00 <t_connect+0x128>
      {
         so->so_state &= ~SS_WASCONNECTING;
 202bad0:	e0bffb17 	ldw	r2,-20(fp)
 202bad4:	10c0088b 	ldhu	r3,34(r2)
 202bad8:	00b7ffc4 	movi	r2,-8193
 202badc:	1884703a 	and	r2,r3,r2
 202bae0:	1007883a 	mov	r3,r2
 202bae4:	e0bffb17 	ldw	r2,-20(fp)
 202bae8:	10c0088d 	sth	r3,34(r2)
         if (so->so_error) /* connect error - maybe timeout */
 202baec:	e0bffb17 	ldw	r2,-20(fp)
 202baf0:	10800617 	ldw	r2,24(r2)
 202baf4:	10000226 	beq	r2,zero,202bb00 <t_connect+0x128>
            return SOCKET_ERROR;
 202baf8:	00bfffc4 	movi	r2,-1
 202bafc:	00004b06 	br	202bc2c <t_connect+0x254>
      }
   }
#endif   /*  NB_CONNECT */

   so->so_error = 0;
 202bb00:	e0bffb17 	ldw	r2,-20(fp)
 202bb04:	10000615 	stw	zero,24(r2)

   if ((nam = sockargs (addr, addrlen, MT_SONAME))
 202bb08:	e13ffe17 	ldw	r4,-8(fp)
 202bb0c:	e17fff17 	ldw	r5,-4(fp)
 202bb10:	01800244 	movi	r6,9
 202bb14:	202c9680 	call	202c968 <sockargs>
 202bb18:	e0bffc15 	stw	r2,-16(fp)
 202bb1c:	e0bffc17 	ldw	r2,-16(fp)
 202bb20:	1000051e 	bne	r2,zero,202bb38 <t_connect+0x160>
       == NULL)
   {
      so->so_error = ENOMEM;
 202bb24:	e0bffb17 	ldw	r2,-20(fp)
 202bb28:	00c00304 	movi	r3,12
 202bb2c:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202bb30:	00bfffc4 	movi	r2,-1
 202bb34:	00003d06 	br	202bc2c <t_connect+0x254>
      INET_TRACE (INETM_SOCKET, ("INET: connect, port %d addr %lx\n",
       sin->sin_port, sin->sin_addr.s_addr));
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 202bb38:	0009883a 	mov	r4,zero
 202bb3c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   if ((so->so_error = soconnect (so, nam)) != 0)
 202bb40:	e13ffb17 	ldw	r4,-20(fp)
 202bb44:	e17ffc17 	ldw	r5,-16(fp)
 202bb48:	202d2bc0 	call	202d2bc <soconnect>
 202bb4c:	e0fffb17 	ldw	r3,-20(fp)
 202bb50:	18800615 	stw	r2,24(r3)
 202bb54:	e0bffb17 	ldw	r2,-20(fp)
 202bb58:	10800617 	ldw	r2,24(r2)
 202bb5c:	10001d1e 	bne	r2,zero,202bbd4 <t_connect+0x1fc>
      goto bad;

#ifdef NB_CONNECT
   /* need to test non blocking connect bits after soconnect() call */
   if ((so->so_state & SS_NBIO)&& (so->so_state & SS_ISCONNECTING))
 202bb60:	e0bffb17 	ldw	r2,-20(fp)
 202bb64:	1080088b 	ldhu	r2,34(r2)
 202bb68:	10bfffcc 	andi	r2,r2,65535
 202bb6c:	1080400c 	andi	r2,r2,256
 202bb70:	10000e26 	beq	r2,zero,202bbac <t_connect+0x1d4>
 202bb74:	e0bffb17 	ldw	r2,-20(fp)
 202bb78:	1080088b 	ldhu	r2,34(r2)
 202bb7c:	10bfffcc 	andi	r2,r2,65535
 202bb80:	1080010c 	andi	r2,r2,4
 202bb84:	10000926 	beq	r2,zero,202bbac <t_connect+0x1d4>
   {
      so->so_error = EINPROGRESS;
 202bb88:	e0bffb17 	ldw	r2,-20(fp)
 202bb8c:	00c01dc4 	movi	r3,119
 202bb90:	10c00615 	stw	r3,24(r2)
      goto bad;
 202bb94:	00001006 	br	202bbd8 <t_connect+0x200>
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
 202bb98:	e0bffb17 	ldw	r2,-20(fp)
 202bb9c:	10800904 	addi	r2,r2,36
 202bba0:	1009883a 	mov	r4,r2
 202bba4:	20274f40 	call	20274f4 <tcp_sleep>
 202bba8:	00000106 	br	202bbb0 <t_connect+0x1d8>
   }
#endif   /*  NB_CONNECT */
   INET_TRACE (INETM_SOCKET, ("INET: connect, so %x so_state %x so_error %d\n",
    so, so->so_state, so->so_error));

   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
 202bbac:	0001883a 	nop
 202bbb0:	e0bffb17 	ldw	r2,-20(fp)
 202bbb4:	1080088b 	ldhu	r2,34(r2)
 202bbb8:	10bfffcc 	andi	r2,r2,65535
 202bbbc:	1080010c 	andi	r2,r2,4
 202bbc0:	10000526 	beq	r2,zero,202bbd8 <t_connect+0x200>
 202bbc4:	e0bffb17 	ldw	r2,-20(fp)
 202bbc8:	10800617 	ldw	r2,24(r2)
 202bbcc:	103ff226 	beq	r2,zero,202bb98 <t_connect+0x1c0>
 202bbd0:	00000106 	br	202bbd8 <t_connect+0x200>
   }
#endif   /* TRACE_DEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   if ((so->so_error = soconnect (so, nam)) != 0)
      goto bad;
 202bbd4:	0001883a 	nop
   while ((so->so_state & SS_ISCONNECTING) && so->so_error == 0) 
   {
      tcp_sleep ((char *)&so->so_timeo);
   }
bad:
   if (so->so_error != EINPROGRESS)
 202bbd8:	e0bffb17 	ldw	r2,-20(fp)
 202bbdc:	10800617 	ldw	r2,24(r2)
 202bbe0:	10801de0 	cmpeqi	r2,r2,119
 202bbe4:	1000071e 	bne	r2,zero,202bc04 <t_connect+0x22c>
      so->so_state &= ~(SS_ISCONNECTING|SS_WASCONNECTING);
 202bbe8:	e0bffb17 	ldw	r2,-20(fp)
 202bbec:	10c0088b 	ldhu	r3,34(r2)
 202bbf0:	00b7fec4 	movi	r2,-8197
 202bbf4:	1884703a 	and	r2,r3,r2
 202bbf8:	1007883a 	mov	r3,r2
 202bbfc:	e0bffb17 	ldw	r2,-20(fp)
 202bc00:	10c0088d 	sth	r3,34(r2)
   m_freem (nam);
 202bc04:	e13ffc17 	ldw	r4,-16(fp)
 202bc08:	20296780 	call	2029678 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 202bc0c:	0009883a 	mov	r4,zero
 202bc10:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (so->so_error)
 202bc14:	e0bffb17 	ldw	r2,-20(fp)
 202bc18:	10800617 	ldw	r2,24(r2)
 202bc1c:	10000226 	beq	r2,zero,202bc28 <t_connect+0x250>
   {
/*      printf("t_connect(): so_error = %d\n", so->so_error);*/
      return SOCKET_ERROR;
 202bc20:	00bfffc4 	movi	r2,-1
 202bc24:	00000106 	br	202bc2c <t_connect+0x254>

   }
      return 0;
 202bc28:	0005883a 	mov	r2,zero
}
 202bc2c:	e037883a 	mov	sp,fp
 202bc30:	dfc00117 	ldw	ra,4(sp)
 202bc34:	df000017 	ldw	fp,0(sp)
 202bc38:	dec00204 	addi	sp,sp,8
 202bc3c:	f800283a 	ret

0202bc40 <t_getpeername>:
 * RETURNS: 
 */

int
t_getpeername(long s, struct sockaddr * addr, int * addrlen)
{
 202bc40:	defffb04 	addi	sp,sp,-20
 202bc44:	dfc00415 	stw	ra,16(sp)
 202bc48:	df000315 	stw	fp,12(sp)
 202bc4c:	df000304 	addi	fp,sp,12
 202bc50:	e13ffd15 	stw	r4,-12(fp)
 202bc54:	e17ffe15 	stw	r5,-8(fp)
 202bc58:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_PEERADDR));
 202bc5c:	e13ffd17 	ldw	r4,-12(fp)
 202bc60:	e17ffe17 	ldw	r5,-8(fp)
 202bc64:	e1bfff17 	ldw	r6,-4(fp)
 202bc68:	01c00404 	movi	r7,16
 202bc6c:	202bcc80 	call	202bcc8 <t_getname>
}
 202bc70:	e037883a 	mov	sp,fp
 202bc74:	dfc00117 	ldw	ra,4(sp)
 202bc78:	df000017 	ldw	fp,0(sp)
 202bc7c:	dec00204 	addi	sp,sp,8
 202bc80:	f800283a 	ret

0202bc84 <t_getsockname>:
 * RETURNS: 
 */

int 
t_getsockname(long s, struct sockaddr * addr, int * addrlen)
{
 202bc84:	defffb04 	addi	sp,sp,-20
 202bc88:	dfc00415 	stw	ra,16(sp)
 202bc8c:	df000315 	stw	fp,12(sp)
 202bc90:	df000304 	addi	fp,sp,12
 202bc94:	e13ffd15 	stw	r4,-12(fp)
 202bc98:	e17ffe15 	stw	r5,-8(fp)
 202bc9c:	e1bfff15 	stw	r6,-4(fp)
   return(t_getname(s, addr, addrlen, PRU_SOCKADDR));
 202bca0:	e13ffd17 	ldw	r4,-12(fp)
 202bca4:	e17ffe17 	ldw	r5,-8(fp)
 202bca8:	e1bfff17 	ldw	r6,-4(fp)
 202bcac:	01c003c4 	movi	r7,15
 202bcb0:	202bcc80 	call	202bcc8 <t_getname>
}
 202bcb4:	e037883a 	mov	sp,fp
 202bcb8:	dfc00117 	ldw	ra,4(sp)
 202bcbc:	df000017 	ldw	fp,0(sp)
 202bcc0:	dec00204 	addi	sp,sp,8
 202bcc4:	f800283a 	ret

0202bcc8 <t_getname>:
 * RETURNS: 
 */

static int
t_getname(long s, struct sockaddr * addr, int * addrlen, int opcode)
{
 202bcc8:	defff604 	addi	sp,sp,-40
 202bccc:	dfc00915 	stw	ra,36(sp)
 202bcd0:	df000815 	stw	fp,32(sp)
 202bcd4:	df000804 	addi	fp,sp,32
 202bcd8:	e13ffc15 	stw	r4,-16(fp)
 202bcdc:	e17ffd15 	stw	r5,-12(fp)
 202bce0:	e1bffe15 	stw	r6,-8(fp)
 202bce4:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *  m;
   int   err;

   so = LONG2SO(s);
 202bce8:	e0bffc17 	ldw	r2,-16(fp)
 202bcec:	10bff804 	addi	r2,r2,-32
 202bcf0:	1085883a 	add	r2,r2,r2
 202bcf4:	1085883a 	add	r2,r2,r2
 202bcf8:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 202bcfc:	00809934 	movhi	r2,612
 202bd00:	10b6c204 	addi	r2,r2,-9464
 202bd04:	e0bff815 	stw	r2,-32(fp)
 202bd08:	00000606 	br	202bd24 <t_getname+0x5c>
 202bd0c:	e0fff817 	ldw	r3,-32(fp)
 202bd10:	e0bff917 	ldw	r2,-28(fp)
 202bd14:	18800526 	beq	r3,r2,202bd2c <t_getname+0x64>
 202bd18:	e0bff817 	ldw	r2,-32(fp)
 202bd1c:	10800017 	ldw	r2,0(r2)
 202bd20:	e0bff815 	stw	r2,-32(fp)
 202bd24:	e0bff817 	ldw	r2,-32(fp)
 202bd28:	103ff81e 	bne	r2,zero,202bd0c <t_getname+0x44>
 202bd2c:	e0fff817 	ldw	r3,-32(fp)
 202bd30:	e0bff917 	ldw	r2,-28(fp)
 202bd34:	18800326 	beq	r3,r2,202bd44 <t_getname+0x7c>
 202bd38:	20285c80 	call	20285c8 <dtrap>
 202bd3c:	00bfffc4 	movi	r2,-1
 202bd40:	00005106 	br	202be88 <t_getname+0x1c0>

   so->so_error = 0;
 202bd44:	e0bff917 	ldw	r2,-28(fp)
 202bd48:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:get[sock|peer]name so %x\n", so));
   if((opcode == PRU_PEERADDR) && (so->so_state & SS_ISCONNECTED) == 0)
 202bd4c:	e0bfff17 	ldw	r2,-4(fp)
 202bd50:	10800418 	cmpnei	r2,r2,16
 202bd54:	10000a1e 	bne	r2,zero,202bd80 <t_getname+0xb8>
 202bd58:	e0bff917 	ldw	r2,-28(fp)
 202bd5c:	1080088b 	ldhu	r2,34(r2)
 202bd60:	10bfffcc 	andi	r2,r2,65535
 202bd64:	1080008c 	andi	r2,r2,2
 202bd68:	1000051e 	bne	r2,zero,202bd80 <t_getname+0xb8>
   {
      so->so_error = ENOTCONN;
 202bd6c:	e0bff917 	ldw	r2,-28(fp)
 202bd70:	00c02004 	movi	r3,128
 202bd74:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202bd78:	00bfffc4 	movi	r2,-1
 202bd7c:	00004206 	br	202be88 <t_getname+0x1c0>
   }
   LOCK_NET_RESOURCE(NET_RESID);
 202bd80:	0009883a 	mov	r4,zero
 202bd84:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 202bd88:	01000244 	movi	r4,9
 202bd8c:	01400404 	movi	r5,16
 202bd90:	20293d80 	call	20293d8 <m_getnbuf>
 202bd94:	e0bffa15 	stw	r2,-24(fp)
   if (m == NULL) 
 202bd98:	e0bffa17 	ldw	r2,-24(fp)
 202bd9c:	1000071e 	bne	r2,zero,202bdbc <t_getname+0xf4>
   {
      so->so_error = ENOMEM;
 202bda0:	e0bff917 	ldw	r2,-28(fp)
 202bda4:	00c00304 	movi	r3,12
 202bda8:	10c00615 	stw	r3,24(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 202bdac:	0009883a 	mov	r4,zero
 202bdb0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return SOCKET_ERROR;
 202bdb4:	00bfffc4 	movi	r2,-1
 202bdb8:	00003306 	br	202be88 <t_getname+0x1c0>
   }
   so->so_req = opcode;
 202bdbc:	e0bff917 	ldw	r2,-28(fp)
 202bdc0:	e0ffff17 	ldw	r3,-4(fp)
 202bdc4:	10c00715 	stw	r3,28(r2)
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
 202bdc8:	e0bff917 	ldw	r2,-28(fp)
 202bdcc:	10800217 	ldw	r2,8(r2)
 202bdd0:	10800317 	ldw	r2,12(r2)
 202bdd4:	e13ff917 	ldw	r4,-28(fp)
 202bdd8:	000b883a 	mov	r5,zero
 202bddc:	e1bffa17 	ldw	r6,-24(fp)
 202bde0:	103ee83a 	callr	r2
 202bde4:	e0bffb15 	stw	r2,-20(fp)
 202bde8:	e0bffb17 	ldw	r2,-20(fp)
 202bdec:	1000191e 	bne	r2,zero,202be54 <t_getname+0x18c>
      goto bad;

#ifdef IP_V4
   if(so->so_domain == AF_INET)
 202bdf0:	e0bff917 	ldw	r2,-28(fp)
 202bdf4:	10800517 	ldw	r2,20(r2)
 202bdf8:	10800098 	cmpnei	r2,r2,2
 202bdfc:	1000161e 	bne	r2,zero,202be58 <t_getname+0x190>
   {
      if(*addrlen < sizeof(struct sockaddr_in))
 202be00:	e0bffe17 	ldw	r2,-8(fp)
 202be04:	10800017 	ldw	r2,0(r2)
 202be08:	10800428 	cmpgeui	r2,r2,16
 202be0c:	1000071e 	bne	r2,zero,202be2c <t_getname+0x164>
      {
         dtrap();    /* programming error */
 202be10:	20285c80 	call	20285c8 <dtrap>
         m_freem(m);
 202be14:	e13ffa17 	ldw	r4,-24(fp)
 202be18:	20296780 	call	2029678 <m_freem>
         UNLOCK_NET_RESOURCE(NET_RESID);
 202be1c:	0009883a 	mov	r4,zero
 202be20:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return EINVAL;
 202be24:	00800584 	movi	r2,22
 202be28:	00001706 	br	202be88 <t_getname+0x1c0>
      }
      MEMCPY(addr, m->m_data, sizeof(struct sockaddr_in));
 202be2c:	e0bffa17 	ldw	r2,-24(fp)
 202be30:	10800317 	ldw	r2,12(r2)
 202be34:	e13ffd17 	ldw	r4,-12(fp)
 202be38:	100b883a 	mov	r5,r2
 202be3c:	01800404 	movi	r6,16
 202be40:	200660c0 	call	200660c <memcpy>
      *addrlen = sizeof(struct sockaddr_in);
 202be44:	e0bffe17 	ldw	r2,-8(fp)
 202be48:	00c00404 	movi	r3,16
 202be4c:	10c00015 	stw	r3,0(r2)
 202be50:	00000106 	br	202be58 <t_getname+0x190>
      UNLOCK_NET_RESOURCE(NET_RESID);
      return SOCKET_ERROR;
   }
   so->so_req = opcode;
   if ((err = (*so->so_proto->pr_usrreq)(so, 0, m)) != 0)
      goto bad;
 202be54:	0001883a 	nop
   }
#endif   /* IP_V6 */


bad:
   m_freem(m);
 202be58:	e13ffa17 	ldw	r4,-24(fp)
 202be5c:	20296780 	call	2029678 <m_freem>
   UNLOCK_NET_RESOURCE(NET_RESID);
 202be60:	0009883a 	mov	r4,zero
 202be64:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (err) 
 202be68:	e0bffb17 	ldw	r2,-20(fp)
 202be6c:	10000526 	beq	r2,zero,202be84 <t_getname+0x1bc>
   {
      so->so_error = err;
 202be70:	e0bff917 	ldw	r2,-28(fp)
 202be74:	e0fffb17 	ldw	r3,-20(fp)
 202be78:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202be7c:	00bfffc4 	movi	r2,-1
 202be80:	00000106 	br	202be88 <t_getname+0x1c0>
   }
   return 0;
 202be84:	0005883a 	mov	r2,zero
}
 202be88:	e037883a 	mov	sp,fp
 202be8c:	dfc00117 	ldw	ra,4(sp)
 202be90:	df000017 	ldw	fp,0(sp)
 202be94:	dec00204 	addi	sp,sp,8
 202be98:	f800283a 	ret

0202be9c <t_setsockopt>:
t_setsockopt(long s,
   int   level,
   int   name,
   void * arg,
   int arglen)
{
 202be9c:	defff704 	addi	sp,sp,-36
 202bea0:	dfc00815 	stw	ra,32(sp)
 202bea4:	df000715 	stw	fp,28(sp)
 202bea8:	df000704 	addi	fp,sp,28
 202beac:	e13ffc15 	stw	r4,-16(fp)
 202beb0:	e17ffd15 	stw	r5,-12(fp)
 202beb4:	e1bffe15 	stw	r6,-8(fp)
 202beb8:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 202bebc:	e0bffc17 	ldw	r2,-16(fp)
 202bec0:	10bff804 	addi	r2,r2,-32
 202bec4:	1085883a 	add	r2,r2,r2
 202bec8:	1085883a 	add	r2,r2,r2
 202becc:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 202bed0:	00809934 	movhi	r2,612
 202bed4:	10b6c204 	addi	r2,r2,-9464
 202bed8:	e0bff915 	stw	r2,-28(fp)
 202bedc:	00000606 	br	202bef8 <t_setsockopt+0x5c>
 202bee0:	e0fff917 	ldw	r3,-28(fp)
 202bee4:	e0bffa17 	ldw	r2,-24(fp)
 202bee8:	18800526 	beq	r3,r2,202bf00 <t_setsockopt+0x64>
 202beec:	e0bff917 	ldw	r2,-28(fp)
 202bef0:	10800017 	ldw	r2,0(r2)
 202bef4:	e0bff915 	stw	r2,-28(fp)
 202bef8:	e0bff917 	ldw	r2,-28(fp)
 202befc:	103ff81e 	bne	r2,zero,202bee0 <t_setsockopt+0x44>
 202bf00:	e0fff917 	ldw	r3,-28(fp)
 202bf04:	e0bffa17 	ldw	r2,-24(fp)
 202bf08:	18800326 	beq	r3,r2,202bf18 <t_setsockopt+0x7c>
 202bf0c:	20285c80 	call	20285c8 <dtrap>
 202bf10:	00bfffc4 	movi	r2,-1
 202bf14:	00004906 	br	202c03c <t_setsockopt+0x1a0>
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 202bf18:	0009883a 	mov	r4,zero
 202bf1c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   so->so_error = 0;
 202bf20:	e0bffa17 	ldw	r2,-24(fp)
 202bf24:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET,
    ("INET: setsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 202bf28:	e0bffd17 	ldw	r2,-12(fp)
 202bf2c:	10800060 	cmpeqi	r2,r2,1
 202bf30:	10000e1e 	bne	r2,zero,202bf6c <t_setsockopt+0xd0>
   {
      if ((err = sosetopt (so, name, arg)) != 0) 
 202bf34:	e13ffa17 	ldw	r4,-24(fp)
 202bf38:	e17ffe17 	ldw	r5,-8(fp)
 202bf3c:	e1bfff17 	ldw	r6,-4(fp)
 202bf40:	202e2380 	call	202e238 <sosetopt>
 202bf44:	e0bffb15 	stw	r2,-20(fp)
 202bf48:	e0bffb17 	ldw	r2,-20(fp)
 202bf4c:	10003826 	beq	r2,zero,202c030 <t_setsockopt+0x194>
      {
         so->so_error = err;
 202bf50:	e0bffa17 	ldw	r2,-24(fp)
 202bf54:	e0fffb17 	ldw	r3,-20(fp)
 202bf58:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 202bf5c:	0009883a 	mov	r4,zero
 202bf60:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 202bf64:	00bfffc4 	movi	r2,-1
 202bf68:	00003406 	br	202c03c <t_setsockopt+0x1a0>
   {
   /* level 1 options are for the IP packet level.
    * the info is carried in the socket CB, then put 
    * into the PACKET.
    */
      if (!so->so_optsPack)
 202bf6c:	e0bffa17 	ldw	r2,-24(fp)
 202bf70:	10801f17 	ldw	r2,124(r2)
 202bf74:	10000e1e 	bne	r2,zero,202bfb0 <t_setsockopt+0x114>
      {
         so->so_optsPack = (struct ip_socopts *) SOCOPT_ALLOC (sizeof(struct ip_socopts *));
 202bf78:	01000104 	movi	r4,4
 202bf7c:	20290400 	call	2029040 <npalloc>
 202bf80:	e0fffa17 	ldw	r3,-24(fp)
 202bf84:	18801f15 	stw	r2,124(r3)
         if (!so->so_optsPack) 
 202bf88:	e0bffa17 	ldw	r2,-24(fp)
 202bf8c:	10801f17 	ldw	r2,124(r2)
 202bf90:	1000071e 	bne	r2,zero,202bfb0 <t_setsockopt+0x114>
         {
            so->so_error = ENOMEM;
 202bf94:	e0bffa17 	ldw	r2,-24(fp)
 202bf98:	00c00304 	movi	r3,12
 202bf9c:	10c00615 	stw	r3,24(r2)
            UNLOCK_NET_RESOURCE (NET_RESID);
 202bfa0:	0009883a 	mov	r4,zero
 202bfa4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            return SOCKET_ERROR;
 202bfa8:	00bfffc4 	movi	r2,-1
 202bfac:	00002306 	br	202c03c <t_setsockopt+0x1a0>
         }
      }
      
      if (name == IP_TTL_OPT)
 202bfb0:	e0bffe17 	ldw	r2,-8(fp)
 202bfb4:	10800118 	cmpnei	r2,r2,4
 202bfb8:	1000061e 	bne	r2,zero,202bfd4 <t_setsockopt+0x138>
         so->so_optsPack->ip_ttl = (u_char)(*(int *)arg);
 202bfbc:	e0bffa17 	ldw	r2,-24(fp)
 202bfc0:	10801f17 	ldw	r2,124(r2)
 202bfc4:	e0ffff17 	ldw	r3,-4(fp)
 202bfc8:	18c00017 	ldw	r3,0(r3)
 202bfcc:	10c00045 	stb	r3,1(r2)
 202bfd0:	00001706 	br	202c030 <t_setsockopt+0x194>
      else
      if (name == IP_TOS)
 202bfd4:	e0bffe17 	ldw	r2,-8(fp)
 202bfd8:	108000d8 	cmpnei	r2,r2,3
 202bfdc:	1000061e 	bne	r2,zero,202bff8 <t_setsockopt+0x15c>
         so->so_optsPack->ip_tos = (u_char)(*(int *)arg);
 202bfe0:	e0bffa17 	ldw	r2,-24(fp)
 202bfe4:	10801f17 	ldw	r2,124(r2)
 202bfe8:	e0ffff17 	ldw	r3,-4(fp)
 202bfec:	18c00017 	ldw	r3,0(r3)
 202bff0:	10c00005 	stb	r3,0(r2)
 202bff4:	00000e06 	br	202c030 <t_setsockopt+0x194>
	   else
	   if (name == IP_SCOPEID)
 202bff8:	e0bffe17 	ldw	r2,-8(fp)
 202bffc:	10800398 	cmpnei	r2,r2,14
 202c000:	1000071e 	bne	r2,zero,202c020 <t_setsockopt+0x184>
            so->so_optsPack->ip_scopeid = (u_char)(*(u_int *)arg);
 202c004:	e0bffa17 	ldw	r2,-24(fp)
 202c008:	10801f17 	ldw	r2,124(r2)
 202c00c:	e0ffff17 	ldw	r3,-4(fp)
 202c010:	18c00017 	ldw	r3,0(r3)
 202c014:	18c03fcc 	andi	r3,r3,255
 202c018:	10c00115 	stw	r3,4(r2)
 202c01c:	00000406 	br	202c030 <t_setsockopt+0x194>
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 202c020:	0009883a 	mov	r4,zero
 202c024:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 202c028:	00bfffc4 	movi	r2,-1
 202c02c:	00000306 	br	202c03c <t_setsockopt+0x1a0>
      }   
   }

   UNLOCK_NET_RESOURCE (NET_RESID);
 202c030:	0009883a 	mov	r4,zero
 202c034:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return 0;
 202c038:	0005883a 	mov	r2,zero
}
 202c03c:	e037883a 	mov	sp,fp
 202c040:	dfc00117 	ldw	ra,4(sp)
 202c044:	df000017 	ldw	fp,0(sp)
 202c048:	dec00204 	addi	sp,sp,8
 202c04c:	f800283a 	ret

0202c050 <t_getsockopt>:
   int   level,
   int   name,
   void *   arg,
   int   arglen)

{
 202c050:	defff704 	addi	sp,sp,-36
 202c054:	dfc00815 	stw	ra,32(sp)
 202c058:	df000715 	stw	fp,28(sp)
 202c05c:	df000704 	addi	fp,sp,28
 202c060:	e13ffc15 	stw	r4,-16(fp)
 202c064:	e17ffd15 	stw	r5,-12(fp)
 202c068:	e1bffe15 	stw	r6,-8(fp)
 202c06c:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 202c070:	e0bffc17 	ldw	r2,-16(fp)
 202c074:	10bff804 	addi	r2,r2,-32
 202c078:	1085883a 	add	r2,r2,r2
 202c07c:	1085883a 	add	r2,r2,r2
 202c080:	e0bffa15 	stw	r2,-24(fp)
   SOC_CHECK(so);
 202c084:	00809934 	movhi	r2,612
 202c088:	10b6c204 	addi	r2,r2,-9464
 202c08c:	e0bff915 	stw	r2,-28(fp)
 202c090:	00000606 	br	202c0ac <t_getsockopt+0x5c>
 202c094:	e0fff917 	ldw	r3,-28(fp)
 202c098:	e0bffa17 	ldw	r2,-24(fp)
 202c09c:	18800526 	beq	r3,r2,202c0b4 <t_getsockopt+0x64>
 202c0a0:	e0bff917 	ldw	r2,-28(fp)
 202c0a4:	10800017 	ldw	r2,0(r2)
 202c0a8:	e0bff915 	stw	r2,-28(fp)
 202c0ac:	e0bff917 	ldw	r2,-28(fp)
 202c0b0:	103ff81e 	bne	r2,zero,202c094 <t_getsockopt+0x44>
 202c0b4:	e0fff917 	ldw	r3,-28(fp)
 202c0b8:	e0bffa17 	ldw	r2,-24(fp)
 202c0bc:	18800326 	beq	r3,r2,202c0cc <t_getsockopt+0x7c>
 202c0c0:	20285c80 	call	20285c8 <dtrap>
 202c0c4:	00bfffc4 	movi	r2,-1
 202c0c8:	00003d06 	br	202c1c0 <t_getsockopt+0x170>
   USE_ARG(level);
   USE_ARG(arglen);

   LOCK_NET_RESOURCE (NET_RESID);
 202c0cc:	0009883a 	mov	r4,zero
 202c0d0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   INET_TRACE (INETM_SOCKET,
    ("INET: getsockopt: name %x val %x valsize %d\n",
    name, val));

   /* is it a level IP_OPTIONS call? */
   if (level != IP_OPTIONS)
 202c0d4:	e0bffd17 	ldw	r2,-12(fp)
 202c0d8:	10800060 	cmpeqi	r2,r2,1
 202c0dc:	10000e1e 	bne	r2,zero,202c118 <t_getsockopt+0xc8>
   {
      if ((err = sogetopt (so, name, arg)) != 0) 
 202c0e0:	e13ffa17 	ldw	r4,-24(fp)
 202c0e4:	e17ffe17 	ldw	r5,-8(fp)
 202c0e8:	e1bfff17 	ldw	r6,-4(fp)
 202c0ec:	202e6680 	call	202e668 <sogetopt>
 202c0f0:	e0bffb15 	stw	r2,-20(fp)
 202c0f4:	e0bffb17 	ldw	r2,-20(fp)
 202c0f8:	10002c26 	beq	r2,zero,202c1ac <t_getsockopt+0x15c>
      {
         so->so_error = err;
 202c0fc:	e0bffa17 	ldw	r2,-24(fp)
 202c100:	e0fffb17 	ldw	r3,-20(fp)
 202c104:	10c00615 	stw	r3,24(r2)
         UNLOCK_NET_RESOURCE (NET_RESID);
 202c108:	0009883a 	mov	r4,zero
 202c10c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 202c110:	00bfffc4 	movi	r2,-1
 202c114:	00002a06 	br	202c1c0 <t_getsockopt+0x170>
   {
      /* level 1 options are for the IP packet level.
       * the info is carried in the socket CB, then put 
       * into the PACKET.
       */
      if (name == IP_TTL_OPT)
 202c118:	e0bffe17 	ldw	r2,-8(fp)
 202c11c:	10800118 	cmpnei	r2,r2,4
 202c120:	10000e1e 	bne	r2,zero,202c15c <t_getsockopt+0x10c>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TTL;
 202c124:	e0bffa17 	ldw	r2,-24(fp)
 202c128:	10801f17 	ldw	r2,124(r2)
 202c12c:	1000041e 	bne	r2,zero,202c140 <t_getsockopt+0xf0>
 202c130:	e0bfff17 	ldw	r2,-4(fp)
 202c134:	00c01004 	movi	r3,64
 202c138:	10c00015 	stw	r3,0(r2)
 202c13c:	00001b06 	br	202c1ac <t_getsockopt+0x15c>
         else *(int *)arg = (int)so->so_optsPack->ip_ttl;
 202c140:	e0bffa17 	ldw	r2,-24(fp)
 202c144:	10801f17 	ldw	r2,124(r2)
 202c148:	10800043 	ldbu	r2,1(r2)
 202c14c:	10c03fcc 	andi	r3,r2,255
 202c150:	e0bfff17 	ldw	r2,-4(fp)
 202c154:	10c00015 	stw	r3,0(r2)
 202c158:	00001406 	br	202c1ac <t_getsockopt+0x15c>
      }
      else if (name == IP_TOS)
 202c15c:	e0bffe17 	ldw	r2,-8(fp)
 202c160:	108000d8 	cmpnei	r2,r2,3
 202c164:	10000d1e 	bne	r2,zero,202c19c <t_getsockopt+0x14c>
      {
         if (!so->so_optsPack) *(int *)arg = IP_TOS_DEFVAL;
 202c168:	e0bffa17 	ldw	r2,-24(fp)
 202c16c:	10801f17 	ldw	r2,124(r2)
 202c170:	1000031e 	bne	r2,zero,202c180 <t_getsockopt+0x130>
 202c174:	e0bfff17 	ldw	r2,-4(fp)
 202c178:	10000015 	stw	zero,0(r2)
 202c17c:	00000b06 	br	202c1ac <t_getsockopt+0x15c>
         else *(int *)arg = (int)so->so_optsPack->ip_tos;
 202c180:	e0bffa17 	ldw	r2,-24(fp)
 202c184:	10801f17 	ldw	r2,124(r2)
 202c188:	10800003 	ldbu	r2,0(r2)
 202c18c:	10c03fcc 	andi	r3,r2,255
 202c190:	e0bfff17 	ldw	r2,-4(fp)
 202c194:	10c00015 	stw	r3,0(r2)
 202c198:	00000406 	br	202c1ac <t_getsockopt+0x15c>
      }
      else
      {
         UNLOCK_NET_RESOURCE (NET_RESID);
 202c19c:	0009883a 	mov	r4,zero
 202c1a0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return SOCKET_ERROR;
 202c1a4:	00bfffc4 	movi	r2,-1
 202c1a8:	00000506 	br	202c1c0 <t_getsockopt+0x170>
      }
   }   
   so->so_error = 0;
 202c1ac:	e0bffa17 	ldw	r2,-24(fp)
 202c1b0:	10000615 	stw	zero,24(r2)

   UNLOCK_NET_RESOURCE (NET_RESID);
 202c1b4:	0009883a 	mov	r4,zero
 202c1b8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return 0;
 202c1bc:	0005883a 	mov	r2,zero
}
 202c1c0:	e037883a 	mov	sp,fp
 202c1c4:	dfc00117 	ldw	ra,4(sp)
 202c1c8:	df000017 	ldw	fp,0(sp)
 202c1cc:	dec00204 	addi	sp,sp,8
 202c1d0:	f800283a 	ret

0202c1d4 <t_recv>:
int
t_recv (long s, 
   char *   buf,
   int   len, 
   int   flag)
{
 202c1d4:	defff604 	addi	sp,sp,-40
 202c1d8:	dfc00915 	stw	ra,36(sp)
 202c1dc:	df000815 	stw	fp,32(sp)
 202c1e0:	df000804 	addi	fp,sp,32
 202c1e4:	e13ffc15 	stw	r4,-16(fp)
 202c1e8:	e17ffd15 	stw	r5,-12(fp)
 202c1ec:	e1bffe15 	stw	r6,-8(fp)
 202c1f0:	e1ffff15 	stw	r7,-4(fp)
#ifdef SOCKDEBUG
   char logbuf[10];
#endif
   struct socket *   so;
   int   err;
   int   sendlen = len;
 202c1f4:	e0bffe17 	ldw	r2,-8(fp)
 202c1f8:	e0bff915 	stw	r2,-28(fp)

   so = LONG2SO(s);
 202c1fc:	e0bffc17 	ldw	r2,-16(fp)
 202c200:	10bff804 	addi	r2,r2,-32
 202c204:	1085883a 	add	r2,r2,r2
 202c208:	1085883a 	add	r2,r2,r2
 202c20c:	e0bffa15 	stw	r2,-24(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 202c210:	e0bffa17 	ldw	r2,-24(fp)
 202c214:	1080088b 	ldhu	r2,34(r2)
 202c218:	10bfffcc 	andi	r2,r2,65535
 202c21c:	1080038c 	andi	r2,r2,14
 202c220:	108000a0 	cmpeqi	r2,r2,2
 202c224:	1000051e 	bne	r2,zero,202c23c <t_recv+0x68>
   {
      so->so_error = EPIPE;
 202c228:	e0bffa17 	ldw	r2,-24(fp)
 202c22c:	00c00804 	movi	r3,32
 202c230:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 202c234:	00bfffc4 	movi	r2,-1
 202c238:	00001906 	br	202c2a0 <t_recv+0xcc>
   }
   so->so_error = 0;
 202c23c:	e0bffa17 	ldw	r2,-24(fp)
 202c240:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 202c244:	0009883a 	mov	r4,zero
 202c248:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   IN_PROFILER(PF_TCP, PF_ENTRY);        /* measure time in TCP */
   INET_TRACE (INETM_IO, ("INET:recv: so %x, len %d\n", so, len));
   err = soreceive(so, NULL, buf, &len, flag);
 202c24c:	e0bffe04 	addi	r2,fp,-8
 202c250:	e0ffff17 	ldw	r3,-4(fp)
 202c254:	d8c00015 	stw	r3,0(sp)
 202c258:	e13ffa17 	ldw	r4,-24(fp)
 202c25c:	000b883a 	mov	r5,zero
 202c260:	e1bffd17 	ldw	r6,-12(fp)
 202c264:	100f883a 	mov	r7,r2
 202c268:	202d9680 	call	202d968 <soreceive>
 202c26c:	e0bffb15 	stw	r2,-20(fp)
   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   UNLOCK_NET_RESOURCE(NET_RESID);
 202c270:	0009883a 	mov	r4,zero
 202c274:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if(err)
 202c278:	e0bffb17 	ldw	r2,-20(fp)
 202c27c:	10000526 	beq	r2,zero,202c294 <t_recv+0xc0>
   {
      so->so_error = err;
 202c280:	e0bffa17 	ldw	r2,-24(fp)
 202c284:	e0fffb17 	ldw	r3,-20(fp)
 202c288:	10c00615 	stw	r3,24(r2)
#ifdef SOCKDEBUG
      sprintf(logbuf, "t_recv: %d", so->so_error);
      glog_with_type(LOG_TYPE_DEBUG, logbuf, 1);
#endif
      return SOCKET_ERROR;
 202c28c:	00bfffc4 	movi	r2,-1
 202c290:	00000306 	br	202c2a0 <t_recv+0xcc>
   }

   /* return bytes we sent - the amount we wanted to send minus
    * the amount left in the buffer.
    */
   return (sendlen - len);
 202c294:	e0bffe17 	ldw	r2,-8(fp)
 202c298:	e0fff917 	ldw	r3,-28(fp)
 202c29c:	1885c83a 	sub	r2,r3,r2
}
 202c2a0:	e037883a 	mov	sp,fp
 202c2a4:	dfc00117 	ldw	ra,4(sp)
 202c2a8:	df000017 	ldw	fp,0(sp)
 202c2ac:	dec00204 	addi	sp,sp,8
 202c2b0:	f800283a 	ret

0202c2b4 <t_recvfrom>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * from,
   int * fromlen)
{
 202c2b4:	defff404 	addi	sp,sp,-48
 202c2b8:	dfc00b15 	stw	ra,44(sp)
 202c2bc:	df000a15 	stw	fp,40(sp)
 202c2c0:	df000a04 	addi	fp,sp,40
 202c2c4:	e13ffc15 	stw	r4,-16(fp)
 202c2c8:	e17ffd15 	stw	r5,-12(fp)
 202c2cc:	e1bffe15 	stw	r6,-8(fp)
 202c2d0:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   struct mbuf *     sender = NULL;
 202c2d4:	e03ffb15 	stw	zero,-20(fp)
   int   err;
   int   sendlen = len;
 202c2d8:	e0bffe17 	ldw	r2,-8(fp)
 202c2dc:	e0bff815 	stw	r2,-32(fp)

   so = LONG2SO(s);
 202c2e0:	e0bffc17 	ldw	r2,-16(fp)
 202c2e4:	10bff804 	addi	r2,r2,-32
 202c2e8:	1085883a 	add	r2,r2,r2
 202c2ec:	1085883a 	add	r2,r2,r2
 202c2f0:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 202c2f4:	00809934 	movhi	r2,612
 202c2f8:	10b6c204 	addi	r2,r2,-9464
 202c2fc:	e0bff715 	stw	r2,-36(fp)
 202c300:	00000606 	br	202c31c <t_recvfrom+0x68>
 202c304:	e0fff717 	ldw	r3,-36(fp)
 202c308:	e0bff917 	ldw	r2,-28(fp)
 202c30c:	18800526 	beq	r3,r2,202c324 <t_recvfrom+0x70>
 202c310:	e0bff717 	ldw	r2,-36(fp)
 202c314:	10800017 	ldw	r2,0(r2)
 202c318:	e0bff715 	stw	r2,-36(fp)
 202c31c:	e0bff717 	ldw	r2,-36(fp)
 202c320:	103ff81e 	bne	r2,zero,202c304 <t_recvfrom+0x50>
 202c324:	e0fff717 	ldw	r3,-36(fp)
 202c328:	e0bff917 	ldw	r2,-28(fp)
 202c32c:	18800326 	beq	r3,r2,202c33c <t_recvfrom+0x88>
 202c330:	20285c80 	call	20285c8 <dtrap>
 202c334:	00bfffc4 	movi	r2,-1
 202c338:	00002706 	br	202c3d8 <t_recvfrom+0x124>
   so->so_error = 0;
 202c33c:	e0bff917 	ldw	r2,-28(fp)
 202c340:	10000615 	stw	zero,24(r2)

   LOCK_NET_RESOURCE(NET_RESID);
 202c344:	0009883a 	mov	r4,zero
 202c348:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   err = soreceive(so, &sender, buf, &len, flags);
 202c34c:	e0fffb04 	addi	r3,fp,-20
 202c350:	e0bffe04 	addi	r2,fp,-8
 202c354:	e13fff17 	ldw	r4,-4(fp)
 202c358:	d9000015 	stw	r4,0(sp)
 202c35c:	e13ff917 	ldw	r4,-28(fp)
 202c360:	180b883a 	mov	r5,r3
 202c364:	e1bffd17 	ldw	r6,-12(fp)
 202c368:	100f883a 	mov	r7,r2
 202c36c:	202d9680 	call	202d968 <soreceive>
 202c370:	e0bffa15 	stw	r2,-24(fp)

   /* copy sender info from mbuf to sockaddr */
   if (sender)
 202c374:	e0bffb17 	ldw	r2,-20(fp)
 202c378:	10000b26 	beq	r2,zero,202c3a8 <t_recvfrom+0xf4>
   {
      MEMCPY(from, (mtod(sender, struct sockaddr *)), *fromlen );
 202c37c:	e0bffb17 	ldw	r2,-20(fp)
 202c380:	10c00317 	ldw	r3,12(r2)
 202c384:	e0800317 	ldw	r2,12(fp)
 202c388:	10800017 	ldw	r2,0(r2)
 202c38c:	e1000217 	ldw	r4,8(fp)
 202c390:	180b883a 	mov	r5,r3
 202c394:	100d883a 	mov	r6,r2
 202c398:	200660c0 	call	200660c <memcpy>
      m_freem (sender);
 202c39c:	e0bffb17 	ldw	r2,-20(fp)
 202c3a0:	1009883a 	mov	r4,r2
 202c3a4:	20296780 	call	2029678 <m_freem>
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 202c3a8:	0009883a 	mov	r4,zero
 202c3ac:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if(err)
 202c3b0:	e0bffa17 	ldw	r2,-24(fp)
 202c3b4:	10000526 	beq	r2,zero,202c3cc <t_recvfrom+0x118>
   {
      so->so_error = err;
 202c3b8:	e0bff917 	ldw	r2,-28(fp)
 202c3bc:	e0fffa17 	ldw	r3,-24(fp)
 202c3c0:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202c3c4:	00bfffc4 	movi	r2,-1
 202c3c8:	00000306 	br	202c3d8 <t_recvfrom+0x124>
   }

   /* OK return: amount of data actually sent */
   return (sendlen - len);
 202c3cc:	e0bffe17 	ldw	r2,-8(fp)
 202c3d0:	e0fff817 	ldw	r3,-32(fp)
 202c3d4:	1885c83a 	sub	r2,r3,r2
}
 202c3d8:	e037883a 	mov	sp,fp
 202c3dc:	dfc00117 	ldw	ra,4(sp)
 202c3e0:	df000017 	ldw	fp,0(sp)
 202c3e4:	dec00204 	addi	sp,sp,8
 202c3e8:	f800283a 	ret

0202c3ec <t_sendto>:
   char *   buf,
   int   len, 
   int   flags,
   struct sockaddr * to,
   int   tolen)
{
 202c3ec:	defff404 	addi	sp,sp,-48
 202c3f0:	dfc00b15 	stw	ra,44(sp)
 202c3f4:	df000a15 	stw	fp,40(sp)
 202c3f8:	df000a04 	addi	fp,sp,40
 202c3fc:	e13ffc15 	stw	r4,-16(fp)
 202c400:	e17ffd15 	stw	r5,-12(fp)
 202c404:	e1bffe15 	stw	r6,-8(fp)
 202c408:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   sendlen;
   int   err;
   struct mbuf *     name;

   so = LONG2SO(s);
 202c40c:	e0bffc17 	ldw	r2,-16(fp)
 202c410:	10bff804 	addi	r2,r2,-32
 202c414:	1085883a 	add	r2,r2,r2
 202c418:	1085883a 	add	r2,r2,r2
 202c41c:	e0bff915 	stw	r2,-28(fp)
   SOC_CHECK(so);
 202c420:	00809934 	movhi	r2,612
 202c424:	10b6c204 	addi	r2,r2,-9464
 202c428:	e0bff815 	stw	r2,-32(fp)
 202c42c:	00000606 	br	202c448 <t_sendto+0x5c>
 202c430:	e0fff817 	ldw	r3,-32(fp)
 202c434:	e0bff917 	ldw	r2,-28(fp)
 202c438:	18800526 	beq	r3,r2,202c450 <t_sendto+0x64>
 202c43c:	e0bff817 	ldw	r2,-32(fp)
 202c440:	10800017 	ldw	r2,0(r2)
 202c444:	e0bff815 	stw	r2,-32(fp)
 202c448:	e0bff817 	ldw	r2,-32(fp)
 202c44c:	103ff81e 	bne	r2,zero,202c430 <t_sendto+0x44>
 202c450:	e0fff817 	ldw	r3,-32(fp)
 202c454:	e0bff917 	ldw	r2,-28(fp)
 202c458:	18800326 	beq	r3,r2,202c468 <t_sendto+0x7c>
 202c45c:	20285c80 	call	20285c8 <dtrap>
 202c460:	00bfffc4 	movi	r2,-1
 202c464:	00005706 	br	202c5c4 <t_sendto+0x1d8>
   so->so_error = 0;
 202c468:	e0bff917 	ldw	r2,-28(fp)
 202c46c:	10000615 	stw	zero,24(r2)

   switch (so->so_type)
 202c470:	e0bff917 	ldw	r2,-28(fp)
 202c474:	10800983 	ldbu	r2,38(r2)
 202c478:	10803fcc 	andi	r2,r2,255
 202c47c:	1080201c 	xori	r2,r2,128
 202c480:	10bfe004 	addi	r2,r2,-128
 202c484:	10c000a0 	cmpeqi	r3,r2,2
 202c488:	18000a1e 	bne	r3,zero,202c4b4 <t_sendto+0xc8>
 202c48c:	10c000e0 	cmpeqi	r3,r2,3
 202c490:	18000b1e 	bne	r3,zero,202c4c0 <t_sendto+0xd4>
 202c494:	10800060 	cmpeqi	r2,r2,1
 202c498:	10001026 	beq	r2,zero,202c4dc <t_sendto+0xf0>
   {
   case SOCK_STREAM:
      /* this is a stream socket, so pass this request through
       * t_send() for its large-send support.
       */
      return t_send(s, buf, len, flags);
 202c49c:	e13ffc17 	ldw	r4,-16(fp)
 202c4a0:	e17ffd17 	ldw	r5,-12(fp)
 202c4a4:	e1bffe17 	ldw	r6,-8(fp)
 202c4a8:	e1ffff17 	ldw	r7,-4(fp)
 202c4ac:	202c5d80 	call	202c5d8 <t_send>
 202c4b0:	00004406 	br	202c5c4 <t_sendto+0x1d8>
      /*NOTREACHED*/
   case SOCK_DGRAM:
      /* datagram (UDP) socket -- prepare to check length */
      sendlen = udp_maxalloc();
 202c4b4:	2045b000 	call	2045b00 <udp_maxalloc>
 202c4b8:	e0bffb15 	stw	r2,-20(fp)
      break;
 202c4bc:	00000d06 	br	202c4f4 <t_sendto+0x108>
#ifdef IP_RAW
   case SOCK_RAW:
      /* raw socket -- prepare to check length */
      sendlen = ip_raw_maxalloc(so->so_options & SO_HDRINCL);
 202c4c0:	e0bff917 	ldw	r2,-28(fp)
 202c4c4:	10800417 	ldw	r2,16(r2)
 202c4c8:	1088000c 	andi	r2,r2,8192
 202c4cc:	1009883a 	mov	r4,r2
 202c4d0:	20446e00 	call	20446e0 <ip_raw_maxalloc>
 202c4d4:	e0bffb15 	stw	r2,-20(fp)
      break;
 202c4d8:	00000606 	br	202c4f4 <t_sendto+0x108>
#endif /* IP_RAW */
   default:
      /* socket has unknown type */
      dtrap();
 202c4dc:	20285c80 	call	20285c8 <dtrap>
      so->so_error = EFAULT;
 202c4e0:	e0bff917 	ldw	r2,-28(fp)
 202c4e4:	00c00384 	movi	r3,14
 202c4e8:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202c4ec:	00bfffc4 	movi	r2,-1
 202c4f0:	00003406 	br	202c5c4 <t_sendto+0x1d8>
   /* fall through for non-stream sockets: SOCK_DGRAM (UDP) and
    * SOCK_RAW (raw IP)
    */

   /* check length against underlying stack's maximum */
   if (len > sendlen)
 202c4f4:	e0fffb17 	ldw	r3,-20(fp)
 202c4f8:	e0bffe17 	ldw	r2,-8(fp)
 202c4fc:	1880050e 	bge	r3,r2,202c514 <t_sendto+0x128>
   {
      so->so_error = EMSGSIZE;
 202c500:	e0bff917 	ldw	r2,-28(fp)
 202c504:	00c01e84 	movi	r3,122
 202c508:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202c50c:	00bfffc4 	movi	r2,-1
 202c510:	00002c06 	br	202c5c4 <t_sendto+0x1d8>
   /* if a sockaddr was passed, wrap it in an mbuf and pas it into the
    * bowels of the BSD code; else assume this is a bound UDP socket
    * and this call came from t_send() below.
    */

   if (to)  /* sockaddr was passed */
 202c514:	e0800217 	ldw	r2,8(fp)
 202c518:	10000c26 	beq	r2,zero,202c54c <t_sendto+0x160>
   {
      name = sockargs(to, tolen, MT_SONAME);
 202c51c:	e1000217 	ldw	r4,8(fp)
 202c520:	e1400317 	ldw	r5,12(fp)
 202c524:	01800244 	movi	r6,9
 202c528:	202c9680 	call	202c968 <sockargs>
 202c52c:	e0bff715 	stw	r2,-36(fp)
      if(name == NULL)
 202c530:	e0bff717 	ldw	r2,-36(fp)
 202c534:	1000061e 	bne	r2,zero,202c550 <t_sendto+0x164>
      {
         so->so_error = ENOMEM;
 202c538:	e0bff917 	ldw	r2,-28(fp)
 202c53c:	00c00304 	movi	r3,12
 202c540:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 202c544:	00bfffc4 	movi	r2,-1
 202c548:	00001e06 	br	202c5c4 <t_sendto+0x1d8>
      }
   }
   else     /* hope user called bind() first... */
      name = NULL;
 202c54c:	e03ff715 	stw	zero,-36(fp)
   
   sendlen = len;
 202c550:	e0bffe17 	ldw	r2,-8(fp)
 202c554:	e0bffb15 	stw	r2,-20(fp)

   LOCK_NET_RESOURCE(NET_RESID);
 202c558:	0009883a 	mov	r4,zero
 202c55c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   err = sosend (so, name, buf, &sendlen, flags);
 202c560:	e0bffb04 	addi	r2,fp,-20
 202c564:	e0ffff17 	ldw	r3,-4(fp)
 202c568:	d8c00015 	stw	r3,0(sp)
 202c56c:	e13ff917 	ldw	r4,-28(fp)
 202c570:	e17ff717 	ldw	r5,-36(fp)
 202c574:	e1bffd17 	ldw	r6,-12(fp)
 202c578:	100f883a 	mov	r7,r2
 202c57c:	202d40c0 	call	202d40c <sosend>
 202c580:	e0bffa15 	stw	r2,-24(fp)

   if (name)
 202c584:	e0bff717 	ldw	r2,-36(fp)
 202c588:	10000226 	beq	r2,zero,202c594 <t_sendto+0x1a8>
      m_freem(name);
 202c58c:	e13ff717 	ldw	r4,-36(fp)
 202c590:	20296780 	call	2029678 <m_freem>

   UNLOCK_NET_RESOURCE(NET_RESID);
 202c594:	0009883a 	mov	r4,zero
 202c598:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (err != 0)
 202c59c:	e0bffa17 	ldw	r2,-24(fp)
 202c5a0:	10000526 	beq	r2,zero,202c5b8 <t_sendto+0x1cc>
   {
      so->so_error = err;
 202c5a4:	e0bff917 	ldw	r2,-28(fp)
 202c5a8:	e0fffa17 	ldw	r3,-24(fp)
 202c5ac:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202c5b0:	00bfffc4 	movi	r2,-1
 202c5b4:	00000306 	br	202c5c4 <t_sendto+0x1d8>
   }

   return (len - sendlen);
 202c5b8:	e0bffb17 	ldw	r2,-20(fp)
 202c5bc:	e0fffe17 	ldw	r3,-8(fp)
 202c5c0:	1885c83a 	sub	r2,r3,r2
}
 202c5c4:	e037883a 	mov	sp,fp
 202c5c8:	dfc00117 	ldw	ra,4(sp)
 202c5cc:	df000017 	ldw	fp,0(sp)
 202c5d0:	dec00204 	addi	sp,sp,8
 202c5d4:	f800283a 	ret

0202c5d8 <t_send>:
int
t_send(long s, 
   char *   buf,
   int      len, 
   int      flags)
{
 202c5d8:	defff104 	addi	sp,sp,-60
 202c5dc:	dfc00e15 	stw	ra,56(sp)
 202c5e0:	df000d15 	stw	fp,52(sp)
 202c5e4:	df000d04 	addi	fp,sp,52
 202c5e8:	e13ffc15 	stw	r4,-16(fp)
 202c5ec:	e17ffd15 	stw	r5,-12(fp)
 202c5f0:	e1bffe15 	stw	r6,-8(fp)
 202c5f4:	e1ffff15 	stw	r7,-4(fp)
   struct socket *   so;
   int   e;       /* error holder */
   int   total_sent  =  0;
 202c5f8:	e03ff515 	stw	zero,-44(fp)
   int   maxpkt;
   int   sendlen;
   int   sent;

   so = LONG2SO(s);
 202c5fc:	e0bffc17 	ldw	r2,-16(fp)
 202c600:	10bff804 	addi	r2,r2,-32
 202c604:	1085883a 	add	r2,r2,r2
 202c608:	1085883a 	add	r2,r2,r2
 202c60c:	e0bff715 	stw	r2,-36(fp)
#ifdef SOC_CHECK_ALWAYS
   SOC_CHECK(so);
#endif
   if ((so->so_state & SO_IO_OK) != SS_ISCONNECTED)
 202c610:	e0bff717 	ldw	r2,-36(fp)
 202c614:	1080088b 	ldhu	r2,34(r2)
 202c618:	10bfffcc 	andi	r2,r2,65535
 202c61c:	1080038c 	andi	r2,r2,14
 202c620:	108000a0 	cmpeqi	r2,r2,2
 202c624:	1000051e 	bne	r2,zero,202c63c <t_send+0x64>
   {
      so->so_error = EPIPE;
 202c628:	e0bff717 	ldw	r2,-36(fp)
 202c62c:	00c00804 	movi	r3,32
 202c630:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202c634:	00bfffc4 	movi	r2,-1
 202c638:	00006306 	br	202c7c8 <t_send+0x1f0>
   }
   so->so_error = 0;
 202c63c:	e0bff717 	ldw	r2,-36(fp)
 202c640:	10000615 	stw	zero,24(r2)

   /* If this is not a stream socket, assume it is bound and pass to
    * t_sendto() with a null sockaddr
    */
   if (so->so_type != SOCK_STREAM)
 202c644:	e0bff717 	ldw	r2,-36(fp)
 202c648:	10800983 	ldbu	r2,38(r2)
 202c64c:	10803fcc 	andi	r2,r2,255
 202c650:	1080201c 	xori	r2,r2,128
 202c654:	10bfe004 	addi	r2,r2,-128
 202c658:	10800060 	cmpeqi	r2,r2,1
 202c65c:	1000081e 	bne	r2,zero,202c680 <t_send+0xa8>
      return(t_sendto(s, buf, len, flags, NULL, 0));
 202c660:	d8000015 	stw	zero,0(sp)
 202c664:	d8000115 	stw	zero,4(sp)
 202c668:	e13ffc17 	ldw	r4,-16(fp)
 202c66c:	e17ffd17 	ldw	r5,-12(fp)
 202c670:	e1bffe17 	ldw	r6,-8(fp)
 202c674:	e1ffff17 	ldw	r7,-4(fp)
 202c678:	202c3ec0 	call	202c3ec <t_sendto>
 202c67c:	00005206 	br	202c7c8 <t_send+0x1f0>

   maxpkt = TCP_MSS;
 202c680:	00816d04 	movi	r2,1460
 202c684:	e0bff615 	stw	r2,-40(fp)
   if(so->so_pcb)
 202c688:	e0bff717 	ldw	r2,-36(fp)
 202c68c:	10800117 	ldw	r2,4(r2)
 202c690:	10004826 	beq	r2,zero,202c7b4 <t_send+0x1dc>
   { 
      struct tcpcb * tp;
      tp = intotcpcb(so->so_pcb);   /* get tcp structure with mss */
 202c694:	e0bff717 	ldw	r2,-36(fp)
 202c698:	10800117 	ldw	r2,4(r2)
 202c69c:	10800917 	ldw	r2,36(r2)
 202c6a0:	e0bff815 	stw	r2,-32(fp)
      if(tp->t_maxseg)              /* Make sure it's set */
 202c6a4:	e0bff817 	ldw	r2,-32(fp)
 202c6a8:	10800a0b 	ldhu	r2,40(r2)
 202c6ac:	10bfffcc 	andi	r2,r2,65535
 202c6b0:	10004026 	beq	r2,zero,202c7b4 <t_send+0x1dc>
         maxpkt = tp->t_maxseg;
 202c6b4:	e0bff817 	ldw	r2,-32(fp)
 202c6b8:	10800a0b 	ldhu	r2,40(r2)
 202c6bc:	10bfffcc 	andi	r2,r2,65535
 202c6c0:	e0bff615 	stw	r2,-40(fp)
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 202c6c4:	00003b06 	br	202c7b4 <t_send+0x1dc>
   {
      if (len > maxpkt)
 202c6c8:	e0bffe17 	ldw	r2,-8(fp)
 202c6cc:	e0fff617 	ldw	r3,-40(fp)
 202c6d0:	1880030e 	bge	r3,r2,202c6e0 <t_send+0x108>
         sendlen = maxpkt;  /* take biggest block we can */
 202c6d4:	e0bff617 	ldw	r2,-40(fp)
 202c6d8:	e0bffb15 	stw	r2,-20(fp)
 202c6dc:	00000206 	br	202c6e8 <t_send+0x110>
      else
         sendlen = len;
 202c6e0:	e0bffe17 	ldw	r2,-8(fp)
 202c6e4:	e0bffb15 	stw	r2,-20(fp)
      sent = sendlen;
 202c6e8:	e0bffb17 	ldw	r2,-20(fp)
 202c6ec:	e0bff915 	stw	r2,-28(fp)

      LOCK_NET_RESOURCE(NET_RESID);
 202c6f0:	0009883a 	mov	r4,zero
 202c6f4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      e = sosend (so, NULL, buf, &sendlen, flags);
 202c6f8:	e0bffb04 	addi	r2,fp,-20
 202c6fc:	e0ffff17 	ldw	r3,-4(fp)
 202c700:	d8c00015 	stw	r3,0(sp)
 202c704:	e13ff717 	ldw	r4,-36(fp)
 202c708:	000b883a 	mov	r5,zero
 202c70c:	e1bffd17 	ldw	r6,-12(fp)
 202c710:	100f883a 	mov	r7,r2
 202c714:	202d40c0 	call	202d40c <sosend>
 202c718:	e0bffa15 	stw	r2,-24(fp)
      UNLOCK_NET_RESOURCE(NET_RESID);
 202c71c:	0009883a 	mov	r4,zero
 202c720:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
 
      if (e != 0)  /* sock_sendit failed? */
 202c724:	e0bffa17 	ldw	r2,-24(fp)
 202c728:	10001026 	beq	r2,zero,202c76c <t_send+0x194>
      {
         /* if we simply ran out of bufs, report back to caller. */
         if ((e == ENOBUFS) || (e == EWOULDBLOCK))
 202c72c:	e0bffa17 	ldw	r2,-24(fp)
 202c730:	10801a60 	cmpeqi	r2,r2,105
 202c734:	1000031e 	bne	r2,zero,202c744 <t_send+0x16c>
 202c738:	e0bffa17 	ldw	r2,-24(fp)
 202c73c:	108002d8 	cmpnei	r2,r2,11
 202c740:	1000051e 	bne	r2,zero,202c758 <t_send+0x180>
            /* if we actually sent something before running out
             * of buffers, report what we sent; 
             * else, report the error and let the application 
             * retry the call later
             */
            if (total_sent != 0)
 202c744:	e0bff517 	ldw	r2,-44(fp)
 202c748:	10000326 	beq	r2,zero,202c758 <t_send+0x180>
            {
               so->so_error = 0;
 202c74c:	e0bff717 	ldw	r2,-36(fp)
 202c750:	10000615 	stw	zero,24(r2)
               break;      /* break out of while(len) loop */
 202c754:	00001b06 	br	202c7c4 <t_send+0x1ec>
            }
         }
         so->so_error = e;
 202c758:	e0bff717 	ldw	r2,-36(fp)
 202c75c:	e0fffa17 	ldw	r3,-24(fp)
 202c760:	10c00615 	stw	r3,24(r2)
         return SOCKET_ERROR;
 202c764:	00bfffc4 	movi	r2,-1
 202c768:	00001706 	br	202c7c8 <t_send+0x1f0>
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
 202c76c:	e0bffb17 	ldw	r2,-20(fp)
 202c770:	1000131e 	bne	r2,zero,202c7c0 <t_send+0x1e8>
         break;         /* break out of while(len) loop */

      /* adjust numbers & pointers, and go do next send loop */
      sent -= sendlen;        /* subtract anything that didn't get sent */
 202c774:	e0bffb17 	ldw	r2,-20(fp)
 202c778:	e0fff917 	ldw	r3,-28(fp)
 202c77c:	1885c83a 	sub	r2,r3,r2
 202c780:	e0bff915 	stw	r2,-28(fp)
      buf += sent;
 202c784:	e0bff917 	ldw	r2,-28(fp)
 202c788:	e0fffd17 	ldw	r3,-12(fp)
 202c78c:	1885883a 	add	r2,r3,r2
 202c790:	e0bffd15 	stw	r2,-12(fp)
      len -= sent;
 202c794:	e0fffe17 	ldw	r3,-8(fp)
 202c798:	e0bff917 	ldw	r2,-28(fp)
 202c79c:	1885c83a 	sub	r2,r3,r2
 202c7a0:	e0bffe15 	stw	r2,-8(fp)
      total_sent += sent;
 202c7a4:	e0fff517 	ldw	r3,-44(fp)
 202c7a8:	e0bff917 	ldw	r2,-28(fp)
 202c7ac:	1885883a 	add	r2,r3,r2
 202c7b0:	e0bff515 	stw	r2,-44(fp)
         maxpkt = tp->t_maxseg;
   }

   IN_PROFILER(PF_TCP, PF_ENTRY);       /* measure time in TCP */

   while (len)
 202c7b4:	e0bffe17 	ldw	r2,-8(fp)
 202c7b8:	103fc31e 	bne	r2,zero,202c6c8 <t_send+0xf0>
 202c7bc:	00000106 	br	202c7c4 <t_send+0x1ec>
         so->so_error = e;
         return SOCKET_ERROR;
      }
      /* if we can't send anymore, return now */
      if (sendlen != 0)
         break;         /* break out of while(len) loop */
 202c7c0:	0001883a 	nop
      len -= sent;
      total_sent += sent;
   }

   IN_PROFILER(PF_TCP, PF_EXIT);        /* measure time in TCP */
   return total_sent;
 202c7c4:	e0bff517 	ldw	r2,-44(fp)
}
 202c7c8:	e037883a 	mov	sp,fp
 202c7cc:	dfc00117 	ldw	ra,4(sp)
 202c7d0:	df000017 	ldw	fp,0(sp)
 202c7d4:	dec00204 	addi	sp,sp,8
 202c7d8:	f800283a 	ret

0202c7dc <t_shutdown>:
 * RETURNS: 
 */

int
t_shutdown(long s, int   how)
{
 202c7dc:	defff904 	addi	sp,sp,-28
 202c7e0:	dfc00615 	stw	ra,24(sp)
 202c7e4:	df000515 	stw	fp,20(sp)
 202c7e8:	df000504 	addi	fp,sp,20
 202c7ec:	e13ffe15 	stw	r4,-8(fp)
 202c7f0:	e17fff15 	stw	r5,-4(fp)
   struct socket *so;
   int   err;

   so = LONG2SO(s);
 202c7f4:	e0bffe17 	ldw	r2,-8(fp)
 202c7f8:	10bff804 	addi	r2,r2,-32
 202c7fc:	1085883a 	add	r2,r2,r2
 202c800:	1085883a 	add	r2,r2,r2
 202c804:	e0bffc15 	stw	r2,-16(fp)
   SOC_CHECK(so);
 202c808:	00809934 	movhi	r2,612
 202c80c:	10b6c204 	addi	r2,r2,-9464
 202c810:	e0bffb15 	stw	r2,-20(fp)
 202c814:	00000606 	br	202c830 <t_shutdown+0x54>
 202c818:	e0fffb17 	ldw	r3,-20(fp)
 202c81c:	e0bffc17 	ldw	r2,-16(fp)
 202c820:	18800526 	beq	r3,r2,202c838 <t_shutdown+0x5c>
 202c824:	e0bffb17 	ldw	r2,-20(fp)
 202c828:	10800017 	ldw	r2,0(r2)
 202c82c:	e0bffb15 	stw	r2,-20(fp)
 202c830:	e0bffb17 	ldw	r2,-20(fp)
 202c834:	103ff81e 	bne	r2,zero,202c818 <t_shutdown+0x3c>
 202c838:	e0fffb17 	ldw	r3,-20(fp)
 202c83c:	e0bffc17 	ldw	r2,-16(fp)
 202c840:	18800326 	beq	r3,r2,202c850 <t_shutdown+0x74>
 202c844:	20285c80 	call	20285c8 <dtrap>
 202c848:	00bfffc4 	movi	r2,-1
 202c84c:	00001206 	br	202c898 <t_shutdown+0xbc>
   so->so_error = 0;
 202c850:	e0bffc17 	ldw	r2,-16(fp)
 202c854:	10000615 	stw	zero,24(r2)
   INET_TRACE (INETM_SOCKET, ("INET:shutdown so %x how %d\n", so, how));

   LOCK_NET_RESOURCE(NET_RESID);
 202c858:	0009883a 	mov	r4,zero
 202c85c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   err = soshutdown(so, how);
 202c860:	e13ffc17 	ldw	r4,-16(fp)
 202c864:	e17fff17 	ldw	r5,-4(fp)
 202c868:	202e0a80 	call	202e0a8 <soshutdown>
 202c86c:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 202c870:	0009883a 	mov	r4,zero
 202c874:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (err != 0)
 202c878:	e0bffd17 	ldw	r2,-12(fp)
 202c87c:	10000526 	beq	r2,zero,202c894 <t_shutdown+0xb8>
   {
      so->so_error = err;
 202c880:	e0bffc17 	ldw	r2,-16(fp)
 202c884:	e0fffd17 	ldw	r3,-12(fp)
 202c888:	10c00615 	stw	r3,24(r2)
      return SOCKET_ERROR;
 202c88c:	00bfffc4 	movi	r2,-1
 202c890:	00000106 	br	202c898 <t_shutdown+0xbc>
   }
   return 0;
 202c894:	0005883a 	mov	r2,zero
}
 202c898:	e037883a 	mov	sp,fp
 202c89c:	dfc00117 	ldw	ra,4(sp)
 202c8a0:	df000017 	ldw	fp,0(sp)
 202c8a4:	dec00204 	addi	sp,sp,8
 202c8a8:	f800283a 	ret

0202c8ac <t_socketclose>:
 * RETURNS: 
 */

int
t_socketclose(long s)
{
 202c8ac:	defffa04 	addi	sp,sp,-24
 202c8b0:	dfc00515 	stw	ra,20(sp)
 202c8b4:	df000415 	stw	fp,16(sp)
 202c8b8:	df000404 	addi	fp,sp,16
 202c8bc:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int   err;

   so = LONG2SO(s);
 202c8c0:	e0bfff17 	ldw	r2,-4(fp)
 202c8c4:	10bff804 	addi	r2,r2,-32
 202c8c8:	1085883a 	add	r2,r2,r2
 202c8cc:	1085883a 	add	r2,r2,r2
 202c8d0:	e0bffd15 	stw	r2,-12(fp)
   SOC_CHECK(so);
 202c8d4:	00809934 	movhi	r2,612
 202c8d8:	10b6c204 	addi	r2,r2,-9464
 202c8dc:	e0bffc15 	stw	r2,-16(fp)
 202c8e0:	00000606 	br	202c8fc <t_socketclose+0x50>
 202c8e4:	e0fffc17 	ldw	r3,-16(fp)
 202c8e8:	e0bffd17 	ldw	r2,-12(fp)
 202c8ec:	18800526 	beq	r3,r2,202c904 <t_socketclose+0x58>
 202c8f0:	e0bffc17 	ldw	r2,-16(fp)
 202c8f4:	10800017 	ldw	r2,0(r2)
 202c8f8:	e0bffc15 	stw	r2,-16(fp)
 202c8fc:	e0bffc17 	ldw	r2,-16(fp)
 202c900:	103ff81e 	bne	r2,zero,202c8e4 <t_socketclose+0x38>
 202c904:	e0fffc17 	ldw	r3,-16(fp)
 202c908:	e0bffd17 	ldw	r2,-12(fp)
 202c90c:	18800326 	beq	r3,r2,202c91c <t_socketclose+0x70>
 202c910:	20285c80 	call	20285c8 <dtrap>
 202c914:	00bfffc4 	movi	r2,-1
 202c918:	00000e06 	br	202c954 <t_socketclose+0xa8>
   so->so_error = 0;
 202c91c:	e0bffd17 	ldw	r2,-12(fp)
 202c920:	10000615 	stw	zero,24(r2)
   INET_TRACE ((INETM_CLOSE|INETM_SOCKET), ("INET:close, so %lx\n",so));

   LOCK_NET_RESOURCE(NET_RESID);
 202c924:	0009883a 	mov	r4,zero
 202c928:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   err = soclose(so);
 202c92c:	e13ffd17 	ldw	r4,-12(fp)
 202c930:	202ce8c0 	call	202ce8c <soclose>
 202c934:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 202c938:	0009883a 	mov	r4,zero
 202c93c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (err != 0) 
 202c940:	e0bffe17 	ldw	r2,-8(fp)
 202c944:	10000226 	beq	r2,zero,202c950 <t_socketclose+0xa4>
   {
      /* do not do the following assignment since the socket structure
         addressed by so has been freed by this point, jharan 12-10-98 */
      /*      so->so_error = err;   */
      return SOCKET_ERROR;
 202c948:	00bfffc4 	movi	r2,-1
 202c94c:	00000106 	br	202c954 <t_socketclose+0xa8>
   }
   return 0;
 202c950:	0005883a 	mov	r2,zero
}
 202c954:	e037883a 	mov	sp,fp
 202c958:	dfc00117 	ldw	ra,4(sp)
 202c95c:	df000017 	ldw	fp,0(sp)
 202c960:	dec00204 	addi	sp,sp,8
 202c964:	f800283a 	ret

0202c968 <sockargs>:

static struct mbuf  * 
sockargs (void * arg, 
   int   arglen, 
   int   type)
{
 202c968:	defffa04 	addi	sp,sp,-24
 202c96c:	dfc00515 	stw	ra,20(sp)
 202c970:	df000415 	stw	fp,16(sp)
 202c974:	df000404 	addi	fp,sp,16
 202c978:	e13ffd15 	stw	r4,-12(fp)
 202c97c:	e17ffe15 	stw	r5,-8(fp)
 202c980:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m;

   LOCK_NET_RESOURCE(NET_RESID);    /* protect mfreeq */
 202c984:	0009883a 	mov	r4,zero
 202c988:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   m = m_getwithdata (type, arglen);
 202c98c:	e13fff17 	ldw	r4,-4(fp)
 202c990:	e17ffe17 	ldw	r5,-8(fp)
 202c994:	20293d80 	call	20293d8 <m_getnbuf>
 202c998:	e0bffc15 	stw	r2,-16(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 202c99c:	0009883a 	mov	r4,zero
 202c9a0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (m == NULL)
 202c9a4:	e0bffc17 	ldw	r2,-16(fp)
 202c9a8:	1000021e 	bne	r2,zero,202c9b4 <sockargs+0x4c>
      return NULL;
 202c9ac:	0005883a 	mov	r2,zero
 202c9b0:	00000b06 	br	202c9e0 <sockargs+0x78>
   m->m_len = arglen;
 202c9b4:	e0fffe17 	ldw	r3,-8(fp)
 202c9b8:	e0bffc17 	ldw	r2,-16(fp)
 202c9bc:	10c00215 	stw	r3,8(r2)
   MEMCPY(mtod (m, char *), arg, arglen);
 202c9c0:	e0bffc17 	ldw	r2,-16(fp)
 202c9c4:	10c00317 	ldw	r3,12(r2)
 202c9c8:	e0bffe17 	ldw	r2,-8(fp)
 202c9cc:	1809883a 	mov	r4,r3
 202c9d0:	e17ffd17 	ldw	r5,-12(fp)
 202c9d4:	100d883a 	mov	r6,r2
 202c9d8:	200660c0 	call	200660c <memcpy>
   return m;
 202c9dc:	e0bffc17 	ldw	r2,-16(fp)
}
 202c9e0:	e037883a 	mov	sp,fp
 202c9e4:	dfc00117 	ldw	ra,4(sp)
 202c9e8:	df000017 	ldw	fp,0(sp)
 202c9ec:	dec00204 	addi	sp,sp,8
 202c9f0:	f800283a 	ret

0202c9f4 <t_errno>:
 *                            ENOTSOCK if socket not found
 */

int
t_errno(long s)
{
 202c9f4:	defffa04 	addi	sp,sp,-24
 202c9f8:	dfc00515 	stw	ra,20(sp)
 202c9fc:	df000415 	stw	fp,16(sp)
 202ca00:	df000404 	addi	fp,sp,16
 202ca04:	e13fff15 	stw	r4,-4(fp)
   struct socket *so = LONG2SO(s);
 202ca08:	e0bfff17 	ldw	r2,-4(fp)
 202ca0c:	10bff804 	addi	r2,r2,-32
 202ca10:	1085883a 	add	r2,r2,r2
 202ca14:	1085883a 	add	r2,r2,r2
 202ca18:	e0bffe15 	stw	r2,-8(fp)
   struct socket *tmp;
   int errcode = ENOTSOCK;
 202ca1c:	00801b04 	movi	r2,108
 202ca20:	e0bffd15 	stw	r2,-12(fp)

   LOCK_NET_RESOURCE(NET_RESID);    /* protect soq */
 202ca24:	0009883a 	mov	r4,zero
 202ca28:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 202ca2c:	00809934 	movhi	r2,612
 202ca30:	10b6c204 	addi	r2,r2,-9464
 202ca34:	e0bffc15 	stw	r2,-16(fp)
 202ca38:	00000a06 	br	202ca64 <t_errno+0x70>
   {
      if (tmp == so)  /* found socket, return error */
 202ca3c:	e0fffc17 	ldw	r3,-16(fp)
 202ca40:	e0bffe17 	ldw	r2,-8(fp)
 202ca44:	1880041e 	bne	r3,r2,202ca58 <t_errno+0x64>
      {
         errcode = so->so_error;
 202ca48:	e0bffe17 	ldw	r2,-8(fp)
 202ca4c:	10800617 	ldw	r2,24(r2)
 202ca50:	e0bffd15 	stw	r2,-12(fp)
         break;
 202ca54:	00000506 	br	202ca6c <t_errno+0x78>

   /* search socket queue for passed socket. This routine should
    * not use SOC_CHECK since it can be ifdeffed out, and we must
    * be ready to return EPIPE if the socket does not exist.
    */
   for (tmp = (struct socket *)(&soq); tmp; tmp = tmp->next)
 202ca58:	e0bffc17 	ldw	r2,-16(fp)
 202ca5c:	10800017 	ldw	r2,0(r2)
 202ca60:	e0bffc15 	stw	r2,-16(fp)
 202ca64:	e0bffc17 	ldw	r2,-16(fp)
 202ca68:	103ff41e 	bne	r2,zero,202ca3c <t_errno+0x48>
         errcode = so->so_error;
         break;
      }
   }

   UNLOCK_NET_RESOURCE(NET_RESID);
 202ca6c:	0009883a 	mov	r4,zero
 202ca70:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   return errcode;
 202ca74:	e0bffd17 	ldw	r2,-12(fp)
}
 202ca78:	e037883a 	mov	sp,fp
 202ca7c:	dfc00117 	ldw	ra,4(sp)
 202ca80:	df000017 	ldw	fp,0(sp)
 202ca84:	dec00204 	addi	sp,sp,8
 202ca88:	f800283a 	ret

0202ca8c <socreate>:
 * RETURNS: 
 */

struct socket *   
socreate (int dom, int type, int proto)
{
 202ca8c:	defff704 	addi	sp,sp,-36
 202ca90:	dfc00815 	stw	ra,32(sp)
 202ca94:	df000715 	stw	fp,28(sp)
 202ca98:	df000704 	addi	fp,sp,28
 202ca9c:	e13ffd15 	stw	r4,-12(fp)
 202caa0:	e17ffe15 	stw	r5,-8(fp)
 202caa4:	e1bfff15 	stw	r6,-4(fp)
   struct protosw *prp;
   struct socket *so;
   int   error;
   int rc;

   if (proto)
 202caa8:	e0bfff17 	ldw	r2,-4(fp)
 202caac:	10000626 	beq	r2,zero,202cac8 <socreate+0x3c>
      prp = pffindproto(dom, proto, type);
 202cab0:	e13ffd17 	ldw	r4,-12(fp)
 202cab4:	e17fff17 	ldw	r5,-4(fp)
 202cab8:	e1bffe17 	ldw	r6,-8(fp)
 202cabc:	20293140 	call	2029314 <pffindproto>
 202cac0:	e0bff915 	stw	r2,-28(fp)
 202cac4:	00000406 	br	202cad8 <socreate+0x4c>
   else
      prp = pffindtype(dom, type);
 202cac8:	e13ffd17 	ldw	r4,-12(fp)
 202cacc:	e17ffe17 	ldw	r5,-8(fp)
 202cad0:	20292840 	call	2029284 <pffindtype>
 202cad4:	e0bff915 	stw	r2,-28(fp)
   if (prp == 0)
 202cad8:	e0bff917 	ldw	r2,-28(fp)
 202cadc:	1000021e 	bne	r2,zero,202cae8 <socreate+0x5c>
      return NULL;
 202cae0:	0005883a 	mov	r2,zero
 202cae4:	00005106 	br	202cc2c <socreate+0x1a0>
   if (prp->pr_type != type)
 202cae8:	e0bff917 	ldw	r2,-28(fp)
 202caec:	1080000b 	ldhu	r2,0(r2)
 202caf0:	10ffffcc 	andi	r3,r2,65535
 202caf4:	18e0001c 	xori	r3,r3,32768
 202caf8:	18e00004 	addi	r3,r3,-32768
 202cafc:	e0bffe17 	ldw	r2,-8(fp)
 202cb00:	18800226 	beq	r3,r2,202cb0c <socreate+0x80>
      return NULL;
 202cb04:	0005883a 	mov	r2,zero
 202cb08:	00004806 	br	202cc2c <socreate+0x1a0>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 202cb0c:	01002104 	movi	r4,132
 202cb10:	20290400 	call	2029040 <npalloc>
 202cb14:	e0bffa15 	stw	r2,-24(fp)
 202cb18:	e0bffa17 	ldw	r2,-24(fp)
 202cb1c:	1000021e 	bne	r2,zero,202cb28 <socreate+0x9c>
      return NULL;
 202cb20:	0005883a 	mov	r2,zero
 202cb24:	00004106 	br	202cc2c <socreate+0x1a0>
   so->next = NULL;
 202cb28:	e0bffa17 	ldw	r2,-24(fp)
 202cb2c:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);
 202cb30:	01009934 	movhi	r4,612
 202cb34:	2136c204 	addi	r4,r4,-9464
 202cb38:	e17ffa17 	ldw	r5,-24(fp)
 202cb3c:	20282880 	call	2028288 <putq>

   so->so_options = socket_defaults;
 202cb40:	d0a0420b 	ldhu	r2,-32504(gp)
 202cb44:	10ffffcc 	andi	r3,r2,65535
 202cb48:	e0bffa17 	ldw	r2,-24(fp)
 202cb4c:	10c00415 	stw	r3,16(r2)
   so->so_domain = dom;
 202cb50:	e0bffa17 	ldw	r2,-24(fp)
 202cb54:	e0fffd17 	ldw	r3,-12(fp)
 202cb58:	10c00515 	stw	r3,20(r2)
   so->so_state = 0;
 202cb5c:	e0bffa17 	ldw	r2,-24(fp)
 202cb60:	1000088d 	sth	zero,34(r2)
   so->so_type = (char)type;
 202cb64:	e0bffe17 	ldw	r2,-8(fp)
 202cb68:	1007883a 	mov	r3,r2
 202cb6c:	e0bffa17 	ldw	r2,-24(fp)
 202cb70:	10c00985 	stb	r3,38(r2)
   so->so_proto = prp;
 202cb74:	e0bffa17 	ldw	r2,-24(fp)
 202cb78:	e0fff917 	ldw	r3,-28(fp)
 202cb7c:	10c00215 	stw	r3,8(r2)

#ifdef IP_MULTICAST
   so->inp_moptions = NULL;
 202cb80:	e0bffa17 	ldw	r2,-24(fp)
 202cb84:	10000315 	stw	zero,12(r2)
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
 202cb88:	e0bffa17 	ldw	r2,-24(fp)
 202cb8c:	10000715 	stw	zero,28(r2)
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
 202cb90:	e0bff917 	ldw	r2,-28(fp)
 202cb94:	10c00317 	ldw	r3,12(r2)
 202cb98:	e0bfff17 	ldw	r2,-4(fp)
 202cb9c:	e13ffa17 	ldw	r4,-24(fp)
 202cba0:	000b883a 	mov	r5,zero
 202cba4:	100d883a 	mov	r6,r2
 202cba8:	183ee83a 	callr	r3
 202cbac:	e0bffb15 	stw	r2,-20(fp)
   if (error) goto bad;
 202cbb0:	e0bffb17 	ldw	r2,-20(fp)
 202cbb4:	10000e1e 	bne	r2,zero,202cbf0 <socreate+0x164>

   if (so_evtmap)
 202cbb8:	00808174 	movhi	r2,517
 202cbbc:	1090ee04 	addi	r2,r2,17336
 202cbc0:	10800003 	ldbu	r2,0(r2)
 202cbc4:	10803fcc 	andi	r2,r2,255
 202cbc8:	10001726 	beq	r2,zero,202cc28 <socreate+0x19c>
   {                       
      rc = (*so_evtmap_create) (so);
 202cbcc:	00808174 	movhi	r2,517
 202cbd0:	1090ec04 	addi	r2,r2,17328
 202cbd4:	10800017 	ldw	r2,0(r2)
 202cbd8:	e13ffa17 	ldw	r4,-24(fp)
 202cbdc:	103ee83a 	callr	r2
 202cbe0:	e0bffc15 	stw	r2,-16(fp)
      if (rc != 0)
 202cbe4:	e0bffc17 	ldw	r2,-16(fp)
 202cbe8:	10000c26 	beq	r2,zero,202cc1c <socreate+0x190>
 202cbec:	00000106 	br	202cbf4 <socreate+0x168>
   so->inp_moptions = NULL;
#endif   /* IP_MULTICAST */

   so->so_req = PRU_ATTACH;
   error = (*prp->pr_usrreq)(so,(struct mbuf *)0, LONG2MBUF((long)proto));
   if (error) goto bad;
 202cbf0:	0001883a 	nop
   {                       
      rc = (*so_evtmap_create) (so);
      if (rc != 0)
      {
bad:   
         so->so_state |= SS_NOFDREF;
 202cbf4:	e0bffa17 	ldw	r2,-24(fp)
 202cbf8:	1080088b 	ldhu	r2,34(r2)
 202cbfc:	10800054 	ori	r2,r2,1
 202cc00:	1007883a 	mov	r3,r2
 202cc04:	e0bffa17 	ldw	r2,-24(fp)
 202cc08:	10c0088d 	sth	r3,34(r2)
         sofree (so);
 202cc0c:	e13ffa17 	ldw	r4,-24(fp)
 202cc10:	202cd6c0 	call	202cd6c <sofree>
         return NULL;   
 202cc14:	0005883a 	mov	r2,zero
 202cc18:	00000406 	br	202cc2c <socreate+0x1a0>
      /*
       * Altera Niche Stack Nios port modification:
       * Remove (void *) cast since -> owner is now TK_OBJECT
       * to fix build warning.
       */
      so->owner = TK_THIS;
 202cc1c:	202779c0 	call	202779c <TK_OSTaskQuery>
 202cc20:	e0fffa17 	ldw	r3,-24(fp)
 202cc24:	18802005 	stb	r2,128(r3)
   }

   return so;
 202cc28:	e0bffa17 	ldw	r2,-24(fp)
}
 202cc2c:	e037883a 	mov	sp,fp
 202cc30:	dfc00117 	ldw	ra,4(sp)
 202cc34:	df000017 	ldw	fp,0(sp)
 202cc38:	dec00204 	addi	sp,sp,8
 202cc3c:	f800283a 	ret

0202cc40 <sobind>:
 */

int
sobind(struct socket * so, 
   struct mbuf *  nam)
{
 202cc40:	defffb04 	addi	sp,sp,-20
 202cc44:	dfc00415 	stw	ra,16(sp)
 202cc48:	df000315 	stw	fp,12(sp)
 202cc4c:	df000304 	addi	fp,sp,12
 202cc50:	e13ffe15 	stw	r4,-8(fp)
 202cc54:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_BIND;
 202cc58:	e0bffe17 	ldw	r2,-8(fp)
 202cc5c:	00c00084 	movi	r3,2
 202cc60:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 202cc64:	e0bffe17 	ldw	r2,-8(fp)
 202cc68:	10800217 	ldw	r2,8(r2)
 202cc6c:	10800317 	ldw	r2,12(r2)
 202cc70:	e13ffe17 	ldw	r4,-8(fp)
 202cc74:	000b883a 	mov	r5,zero
 202cc78:	e1bfff17 	ldw	r6,-4(fp)
 202cc7c:	103ee83a 	callr	r2
 202cc80:	e0bffd15 	stw	r2,-12(fp)
   return (error);
 202cc84:	e0bffd17 	ldw	r2,-12(fp)
}
 202cc88:	e037883a 	mov	sp,fp
 202cc8c:	dfc00117 	ldw	ra,4(sp)
 202cc90:	df000017 	ldw	fp,0(sp)
 202cc94:	dec00204 	addi	sp,sp,8
 202cc98:	f800283a 	ret

0202cc9c <solisten>:
 */

int
solisten(struct socket * so, 
   int   backlog)
{
 202cc9c:	defffb04 	addi	sp,sp,-20
 202cca0:	dfc00415 	stw	ra,16(sp)
 202cca4:	df000315 	stw	fp,12(sp)
 202cca8:	df000304 	addi	fp,sp,12
 202ccac:	e13ffe15 	stw	r4,-8(fp)
 202ccb0:	e17fff15 	stw	r5,-4(fp)
   int   error;

   so->so_req = PRU_LISTEN;
 202ccb4:	e0bffe17 	ldw	r2,-8(fp)
 202ccb8:	00c000c4 	movi	r3,3
 202ccbc:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so,
 202ccc0:	e0bffe17 	ldw	r2,-8(fp)
 202ccc4:	10800217 	ldw	r2,8(r2)
 202ccc8:	10800317 	ldw	r2,12(r2)
 202cccc:	e13ffe17 	ldw	r4,-8(fp)
 202ccd0:	000b883a 	mov	r5,zero
 202ccd4:	000d883a 	mov	r6,zero
 202ccd8:	103ee83a 	callr	r2
 202ccdc:	e0bffd15 	stw	r2,-12(fp)
    (struct mbuf *)0, (struct mbuf *)0);
   if (error) 
 202cce0:	e0bffd17 	ldw	r2,-12(fp)
 202cce4:	10000226 	beq	r2,zero,202ccf0 <solisten+0x54>
   {
      return (error);
 202cce8:	e0bffd17 	ldw	r2,-12(fp)
 202ccec:	00001a06 	br	202cd58 <solisten+0xbc>
   }
   if (so->so_q == 0) 
 202ccf0:	e0bffe17 	ldw	r2,-8(fp)
 202ccf4:	10801d17 	ldw	r2,116(r2)
 202ccf8:	10000b1e 	bne	r2,zero,202cd28 <solisten+0x8c>
   {
      so->so_q = so;
 202ccfc:	e0bffe17 	ldw	r2,-8(fp)
 202cd00:	e0fffe17 	ldw	r3,-8(fp)
 202cd04:	10c01d15 	stw	r3,116(r2)
      so->so_q0 = so;
 202cd08:	e0bffe17 	ldw	r2,-8(fp)
 202cd0c:	e0fffe17 	ldw	r3,-8(fp)
 202cd10:	10c01c15 	stw	r3,112(r2)
      so->so_options |= SO_ACCEPTCONN;
 202cd14:	e0bffe17 	ldw	r2,-8(fp)
 202cd18:	10800417 	ldw	r2,16(r2)
 202cd1c:	10c00094 	ori	r3,r2,2
 202cd20:	e0bffe17 	ldw	r2,-8(fp)
 202cd24:	10c00415 	stw	r3,16(r2)
   }
   if (backlog < 0)
 202cd28:	e0bfff17 	ldw	r2,-4(fp)
 202cd2c:	1000010e 	bge	r2,zero,202cd34 <solisten+0x98>
      backlog = 0;
 202cd30:	e03fff15 	stw	zero,-4(fp)
   so->so_qlimit = (char)MIN(backlog, SOMAXCONN);
 202cd34:	e0bfff17 	ldw	r2,-4(fp)
 202cd38:	10800188 	cmpgei	r2,r2,6
 202cd3c:	1000021e 	bne	r2,zero,202cd48 <solisten+0xac>
 202cd40:	e0bfff17 	ldw	r2,-4(fp)
 202cd44:	00000106 	br	202cd4c <solisten+0xb0>
 202cd48:	00800144 	movi	r2,5
 202cd4c:	e0fffe17 	ldw	r3,-8(fp)
 202cd50:	18801e85 	stb	r2,122(r3)
   return 0;
 202cd54:	0005883a 	mov	r2,zero
}
 202cd58:	e037883a 	mov	sp,fp
 202cd5c:	dfc00117 	ldw	ra,4(sp)
 202cd60:	df000017 	ldw	fp,0(sp)
 202cd64:	dec00204 	addi	sp,sp,8
 202cd68:	f800283a 	ret

0202cd6c <sofree>:
 * RETURNS: 
 */

void
sofree(struct socket * so)
{
 202cd6c:	defffd04 	addi	sp,sp,-12
 202cd70:	dfc00215 	stw	ra,8(sp)
 202cd74:	df000115 	stw	fp,4(sp)
 202cd78:	df000104 	addi	fp,sp,4
 202cd7c:	e13fff15 	stw	r4,-4(fp)
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
 202cd80:	e0bfff17 	ldw	r2,-4(fp)
 202cd84:	10800117 	ldw	r2,4(r2)
 202cd88:	10003a1e 	bne	r2,zero,202ce74 <sofree+0x108>
 202cd8c:	e0bfff17 	ldw	r2,-4(fp)
 202cd90:	1080088b 	ldhu	r2,34(r2)
 202cd94:	10bfffcc 	andi	r2,r2,65535
 202cd98:	1080004c 	andi	r2,r2,1
 202cd9c:	10003526 	beq	r2,zero,202ce74 <sofree+0x108>
      return;
   if (so->so_head) 
 202cda0:	e0bfff17 	ldw	r2,-4(fp)
 202cda4:	10801b17 	ldw	r2,108(r2)
 202cda8:	10000d26 	beq	r2,zero,202cde0 <sofree+0x74>
   {
      if (!soqremque(so, 0) && !soqremque(so, 1))
 202cdac:	e13fff17 	ldw	r4,-4(fp)
 202cdb0:	000b883a 	mov	r5,zero
 202cdb4:	202f0e00 	call	202f0e0 <soqremque>
 202cdb8:	1000071e 	bne	r2,zero,202cdd8 <sofree+0x6c>
 202cdbc:	e13fff17 	ldw	r4,-4(fp)
 202cdc0:	01400044 	movi	r5,1
 202cdc4:	202f0e00 	call	202f0e0 <soqremque>
 202cdc8:	1000031e 	bne	r2,zero,202cdd8 <sofree+0x6c>
         panic("sofree");
 202cdcc:	01008174 	movhi	r4,517
 202cdd0:	213d4a04 	addi	r4,r4,-2776
 202cdd4:	2026bf80 	call	2026bf8 <panic>
      so->so_head = 0;
 202cdd8:	e0bfff17 	ldw	r2,-4(fp)
 202cddc:	10001b15 	stw	zero,108(r2)
   }
   sbrelease(&so->so_snd);
 202cde0:	e0bfff17 	ldw	r2,-4(fp)
 202cde4:	10801204 	addi	r2,r2,72
 202cde8:	1009883a 	mov	r4,r2
 202cdec:	202f49c0 	call	202f49c <sbrelease>
   sorflush(so);
 202cdf0:	e13fff17 	ldw	r4,-4(fp)
 202cdf4:	202e1400 	call	202e140 <sorflush>
      _socket_free_entry (so);
#endif   /* SAVE_SOCK_ENDPOINTS */

#ifdef IP_MULTICAST
   /* multicast opts? */
   if (so->inp_moptions)
 202cdf8:	e0bfff17 	ldw	r2,-4(fp)
 202cdfc:	10800317 	ldw	r2,12(r2)
 202ce00:	10000426 	beq	r2,zero,202ce14 <sofree+0xa8>
	   ip_freemoptions(so->inp_moptions);
 202ce04:	e0bfff17 	ldw	r2,-4(fp)
 202ce08:	10800317 	ldw	r2,12(r2)
 202ce0c:	1009883a 	mov	r4,r2
 202ce10:	2046dac0 	call	2046dac <ip_freemoptions>
#endif   /* IP_MULTICAST */

   /* IP_TOS opts? */
   if (so->so_optsPack)
 202ce14:	e0bfff17 	ldw	r2,-4(fp)
 202ce18:	10801f17 	ldw	r2,124(r2)
 202ce1c:	10000426 	beq	r2,zero,202ce30 <sofree+0xc4>
      SOCOPT_FREE(so->so_optsPack);
 202ce20:	e0bfff17 	ldw	r2,-4(fp)
 202ce24:	10801f17 	ldw	r2,124(r2)
 202ce28:	1009883a 	mov	r4,r2
 202ce2c:	202912c0 	call	202912c <npfree>
	   
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 202ce30:	01009934 	movhi	r4,612
 202ce34:	2136c204 	addi	r4,r4,-9464
 202ce38:	e17fff17 	ldw	r5,-4(fp)
 202ce3c:	20283340 	call	2028334 <qdel>
   
   if (so_evtmap)  
 202ce40:	00808174 	movhi	r2,517
 202ce44:	1090ee04 	addi	r2,r2,17336
 202ce48:	10800003 	ldbu	r2,0(r2)
 202ce4c:	10803fcc 	andi	r2,r2,255
 202ce50:	10000526 	beq	r2,zero,202ce68 <sofree+0xfc>
      (*so_evtmap_delete) (so);
 202ce54:	00808174 	movhi	r2,517
 202ce58:	1090ed04 	addi	r2,r2,17332
 202ce5c:	10800017 	ldw	r2,0(r2)
 202ce60:	e13fff17 	ldw	r4,-4(fp)
 202ce64:	103ee83a 	callr	r2
   
   SOC_FREE(so);
 202ce68:	e13fff17 	ldw	r4,-4(fp)
 202ce6c:	202912c0 	call	202912c <npfree>
 202ce70:	00000106 	br	202ce78 <sofree+0x10c>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sofree, so %lx so_pcb %lx so_state %x so_head %lx\n",
    so, so->so_pcb, so->so_state, so->so_head));

   if (so->so_pcb || (so->so_state & SS_NOFDREF) == 0)
      return;
 202ce74:	0001883a 	nop
   
   if (so_evtmap)  
      (*so_evtmap_delete) (so);
   
   SOC_FREE(so);
}
 202ce78:	e037883a 	mov	sp,fp
 202ce7c:	dfc00117 	ldw	ra,4(sp)
 202ce80:	df000017 	ldw	fp,0(sp)
 202ce84:	dec00204 	addi	sp,sp,8
 202ce88:	f800283a 	ret

0202ce8c <soclose>:
 * RETURNS: 
 */

int
soclose(struct socket * so)
{
 202ce8c:	defff704 	addi	sp,sp,-36
 202ce90:	dfc00815 	stw	ra,32(sp)
 202ce94:	df000715 	stw	fp,28(sp)
 202ce98:	dc400615 	stw	r17,24(sp)
 202ce9c:	dc000515 	stw	r16,20(sp)
 202cea0:	df000504 	addi	fp,sp,20
 202cea4:	e13fff15 	stw	r4,-4(fp)
   int   error =  0;
 202cea8:	e03ffb15 	stw	zero,-20(fp)
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 202ceac:	00809934 	movhi	r2,612
 202ceb0:	10b6c204 	addi	r2,r2,-9464
 202ceb4:	10800017 	ldw	r2,0(r2)
 202ceb8:	e0bffc15 	stw	r2,-16(fp)
 202cebc:	00000606 	br	202ced8 <soclose+0x4c>
   {
      if (so == tmpso)
 202cec0:	e0ffff17 	ldw	r3,-4(fp)
 202cec4:	e0bffc17 	ldw	r2,-16(fp)
 202cec8:	18800626 	beq	r3,r2,202cee4 <soclose+0x58>
   unsigned long endtime;

   /* Check whether the closing socket is in the socket queue.  If it is
    * not, return a EINVAL error code to the caller.
    */
   for ((tmpso=(struct socket *)soq.q_head);tmpso != NULL;tmpso=tmpso->next)
 202cecc:	e0bffc17 	ldw	r2,-16(fp)
 202ced0:	10800017 	ldw	r2,0(r2)
 202ced4:	e0bffc15 	stw	r2,-16(fp)
 202ced8:	e0bffc17 	ldw	r2,-16(fp)
 202cedc:	103ff81e 	bne	r2,zero,202cec0 <soclose+0x34>
 202cee0:	00000106 	br	202cee8 <soclose+0x5c>
   {
      if (so == tmpso)
         break;
 202cee4:	0001883a 	nop
   }
   if ( tmpso == NULL)
 202cee8:	e0bffc17 	ldw	r2,-16(fp)
 202ceec:	1000021e 	bne	r2,zero,202cef8 <soclose+0x6c>
      return EINVAL;
 202cef0:	00800584 	movi	r2,22
 202cef4:	0000b006 	br	202d1b8 <soclose+0x32c>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
 202cef8:	e0bfff17 	ldw	r2,-4(fp)
 202cefc:	10800417 	ldw	r2,16(r2)
 202cf00:	1080008c 	andi	r2,r2,2
 202cf04:	10001226 	beq	r2,zero,202cf50 <soclose+0xc4>
   {
      while (so->so_q0 != so)
 202cf08:	00000406 	br	202cf1c <soclose+0x90>
         (void) soabort(so->so_q0);
 202cf0c:	e0bfff17 	ldw	r2,-4(fp)
 202cf10:	10801c17 	ldw	r2,112(r2)
 202cf14:	1009883a 	mov	r4,r2
 202cf18:	202d1d40 	call	202d1d4 <soabort>
   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: soclose, so %lx  so_pcb %lx so_state %x so_q %lx\n",
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
 202cf1c:	e0bfff17 	ldw	r2,-4(fp)
 202cf20:	10c01c17 	ldw	r3,112(r2)
 202cf24:	e0bfff17 	ldw	r2,-4(fp)
 202cf28:	18bff81e 	bne	r3,r2,202cf0c <soclose+0x80>
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 202cf2c:	00000406 	br	202cf40 <soclose+0xb4>
         (void) soabort(so->so_q);
 202cf30:	e0bfff17 	ldw	r2,-4(fp)
 202cf34:	10801d17 	ldw	r2,116(r2)
 202cf38:	1009883a 	mov	r4,r2
 202cf3c:	202d1d40 	call	202d1d4 <soabort>
    so, so->so_pcb, so->so_state, so->so_q));
   if (so->so_options & SO_ACCEPTCONN)
   {
      while (so->so_q0 != so)
         (void) soabort(so->so_q0);
      while (so->so_q != so)
 202cf40:	e0bfff17 	ldw	r2,-4(fp)
 202cf44:	10c01d17 	ldw	r3,116(r2)
 202cf48:	e0bfff17 	ldw	r2,-4(fp)
 202cf4c:	18bff81e 	bne	r3,r2,202cf30 <soclose+0xa4>
         (void) soabort(so->so_q);
   }
   /* for datagram-oriented sockets, dispense with further tests */
   if (so->so_type != SOCK_STREAM)
 202cf50:	e0bfff17 	ldw	r2,-4(fp)
 202cf54:	10800983 	ldbu	r2,38(r2)
 202cf58:	10803fcc 	andi	r2,r2,255
 202cf5c:	1080201c 	xori	r2,r2,128
 202cf60:	10bfe004 	addi	r2,r2,-128
 202cf64:	10800060 	cmpeqi	r2,r2,1
 202cf68:	10000c1e 	bne	r2,zero,202cf9c <soclose+0x110>
   { 
      so->so_req = PRU_DETACH;
 202cf6c:	e0bfff17 	ldw	r2,-4(fp)
 202cf70:	00c00044 	movi	r3,1
 202cf74:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so,
 202cf78:	e0bfff17 	ldw	r2,-4(fp)
 202cf7c:	10800217 	ldw	r2,8(r2)
 202cf80:	10800317 	ldw	r2,12(r2)
 202cf84:	e13fff17 	ldw	r4,-4(fp)
 202cf88:	000b883a 	mov	r5,zero
 202cf8c:	000d883a 	mov	r6,zero
 202cf90:	103ee83a 	callr	r2
 202cf94:	e0bffb15 	stw	r2,-20(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
 202cf98:	00007806 	br	202d17c <soclose+0x2f0>
   }

   if (so->so_pcb == 0)
 202cf9c:	e0bfff17 	ldw	r2,-4(fp)
 202cfa0:	10800117 	ldw	r2,4(r2)
 202cfa4:	10007426 	beq	r2,zero,202d178 <soclose+0x2ec>
      goto discard;
   if (so->so_state & SS_ISCONNECTED) 
 202cfa8:	e0bfff17 	ldw	r2,-4(fp)
 202cfac:	1080088b 	ldhu	r2,34(r2)
 202cfb0:	10bfffcc 	andi	r2,r2,65535
 202cfb4:	1080008c 	andi	r2,r2,2
 202cfb8:	10005c26 	beq	r2,zero,202d12c <soclose+0x2a0>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
 202cfbc:	e0bfff17 	ldw	r2,-4(fp)
 202cfc0:	1080088b 	ldhu	r2,34(r2)
 202cfc4:	10bfffcc 	andi	r2,r2,65535
 202cfc8:	1080020c 	andi	r2,r2,8
 202cfcc:	1000051e 	bne	r2,zero,202cfe4 <soclose+0x158>
      {
         error = sodisconnect(so);
 202cfd0:	e13fff17 	ldw	r4,-4(fp)
 202cfd4:	202d3740 	call	202d374 <sodisconnect>
 202cfd8:	e0bffb15 	stw	r2,-20(fp)
         if (error)
 202cfdc:	e0bffb17 	ldw	r2,-20(fp)
 202cfe0:	10004f1e 	bne	r2,zero,202d120 <soclose+0x294>
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
 202cfe4:	e0bfff17 	ldw	r2,-4(fp)
 202cfe8:	10800417 	ldw	r2,16(r2)
 202cfec:	1080200c 	andi	r2,r2,128
 202cff0:	10004026 	beq	r2,zero,202d0f4 <soclose+0x268>
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 202cff4:	e0bfff17 	ldw	r2,-4(fp)
 202cff8:	1080088b 	ldhu	r2,34(r2)
 202cffc:	10bfffcc 	andi	r2,r2,65535
 202d000:	1080020c 	andi	r2,r2,8
 202d004:	10000526 	beq	r2,zero,202d01c <soclose+0x190>
             (so->so_state & SS_NBIO))
 202d008:	e0bfff17 	ldw	r2,-4(fp)
 202d00c:	1080088b 	ldhu	r2,34(r2)
 202d010:	10bfffcc 	andi	r2,r2,65535
 202d014:	1080400c 	andi	r2,r2,256
         if (error)
            goto drop;
      }
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
 202d018:	1000431e 	bne	r2,zero,202d128 <soclose+0x29c>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
 202d01c:	00808174 	movhi	r2,517
 202d020:	1090c904 	addi	r2,r2,17188
 202d024:	10800017 	ldw	r2,0(r2)
 202d028:	1009883a 	mov	r4,r2
 202d02c:	20145600 	call	2014560 <__floatunsidf>
 202d030:	1021883a 	mov	r16,r2
 202d034:	1823883a 	mov	r17,r3
 202d038:	e0bfff17 	ldw	r2,-4(fp)
 202d03c:	1080080b 	ldhu	r2,32(r2)
 202d040:	10bfffcc 	andi	r2,r2,65535
 202d044:	10a0001c 	xori	r2,r2,32768
 202d048:	10a00004 	addi	r2,r2,-32768
 202d04c:	1009883a 	mov	r4,r2
 202d050:	20145600 	call	2014560 <__floatunsidf>
 202d054:	100b883a 	mov	r5,r2
 202d058:	180d883a 	mov	r6,r3
 202d05c:	2809883a 	mov	r4,r5
 202d060:	300b883a 	mov	r5,r6
 202d064:	000d883a 	mov	r6,zero
 202d068:	01d01674 	movhi	r7,16473
 202d06c:	2013c880 	call	2013c88 <__muldf3>
 202d070:	1009883a 	mov	r4,r2
 202d074:	180b883a 	mov	r5,r3
 202d078:	2005883a 	mov	r2,r4
 202d07c:	2807883a 	mov	r3,r5
 202d080:	8009883a 	mov	r4,r16
 202d084:	880b883a 	mov	r5,r17
 202d088:	100d883a 	mov	r6,r2
 202d08c:	180f883a 	mov	r7,r3
 202d090:	2013bd40 	call	2013bd4 <__adddf3>
 202d094:	1009883a 	mov	r4,r2
 202d098:	180b883a 	mov	r5,r3
 202d09c:	2005883a 	mov	r2,r4
 202d0a0:	2807883a 	mov	r3,r5
 202d0a4:	1009883a 	mov	r4,r2
 202d0a8:	180b883a 	mov	r5,r3
 202d0ac:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 202d0b0:	e0bffd15 	stw	r2,-12(fp)
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 202d0b4:	00000406 	br	202d0c8 <soclose+0x23c>
         {
            tcp_sleep((char *)&so->so_timeo);
 202d0b8:	e0bfff17 	ldw	r2,-4(fp)
 202d0bc:	10800904 	addi	r2,r2,36
 202d0c0:	1009883a 	mov	r4,r2
 202d0c4:	20274f40 	call	20274f4 <tcp_sleep>
             (so->so_state & SS_NBIO))
         {
            goto drop;
         }
         endtime = cticks + (unsigned long)so->so_linger * TPS;         
         while ((so->so_state & SS_ISCONNECTED) && (cticks < endtime))
 202d0c8:	e0bfff17 	ldw	r2,-4(fp)
 202d0cc:	1080088b 	ldhu	r2,34(r2)
 202d0d0:	10bfffcc 	andi	r2,r2,65535
 202d0d4:	1080008c 	andi	r2,r2,2
 202d0d8:	10001426 	beq	r2,zero,202d12c <soclose+0x2a0>
 202d0dc:	00808174 	movhi	r2,517
 202d0e0:	1090c904 	addi	r2,r2,17188
 202d0e4:	10c00017 	ldw	r3,0(r2)
 202d0e8:	e0bffd17 	ldw	r2,-12(fp)
 202d0ec:	18bff236 	bltu	r3,r2,202d0b8 <soclose+0x22c>
 202d0f0:	00000e06 	br	202d12c <soclose+0x2a0>
      {
         /* If socket still has send data just return now, leaving the 
          * socket intact so the data can be sent. Socket should be cleaned
          * up later by timers.
          */
         if(so->so_snd.sb_cc)
 202d0f4:	e0bfff17 	ldw	r2,-4(fp)
 202d0f8:	10801217 	ldw	r2,72(r2)
 202d0fc:	10000b26 	beq	r2,zero,202d12c <soclose+0x2a0>
         {
            so->so_state |= SS_NOFDREF;   /* mark as OK to close */
 202d100:	e0bfff17 	ldw	r2,-4(fp)
 202d104:	1080088b 	ldhu	r2,34(r2)
 202d108:	10800054 	ori	r2,r2,1
 202d10c:	1007883a 	mov	r3,r2
 202d110:	e0bfff17 	ldw	r2,-4(fp)
 202d114:	10c0088d 	sth	r3,34(r2)
            return 0;
 202d118:	0005883a 	mov	r2,zero
 202d11c:	00002606 	br	202d1b8 <soclose+0x32c>
   {
      if ((so->so_state & SS_ISDISCONNECTING) == 0) 
      {
         error = sodisconnect(so);
         if (error)
            goto drop;
 202d120:	0001883a 	nop
 202d124:	00000106 	br	202d12c <soclose+0x2a0>
      if (so->so_options & SO_LINGER) 
      {
         if ((so->so_state & SS_ISDISCONNECTING) &&
             (so->so_state & SS_NBIO))
         {
            goto drop;
 202d128:	0001883a 	nop
            return 0;
         }
      }
   }
drop:
   if (so->so_pcb) 
 202d12c:	e0bfff17 	ldw	r2,-4(fp)
 202d130:	10800117 	ldw	r2,4(r2)
 202d134:	10001126 	beq	r2,zero,202d17c <soclose+0x2f0>
   {
      int   error2;
      so->so_req = PRU_DETACH;
 202d138:	e0bfff17 	ldw	r2,-4(fp)
 202d13c:	00c00044 	movi	r3,1
 202d140:	10c00715 	stw	r3,28(r2)
      error2 = (*so->so_proto->pr_usrreq)(so,
 202d144:	e0bfff17 	ldw	r2,-4(fp)
 202d148:	10800217 	ldw	r2,8(r2)
 202d14c:	10800317 	ldw	r2,12(r2)
 202d150:	e13fff17 	ldw	r4,-4(fp)
 202d154:	000b883a 	mov	r5,zero
 202d158:	000d883a 	mov	r6,zero
 202d15c:	103ee83a 	callr	r2
 202d160:	e0bffe15 	stw	r2,-8(fp)
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
 202d164:	e0bffb17 	ldw	r2,-20(fp)
 202d168:	1000041e 	bne	r2,zero,202d17c <soclose+0x2f0>
         error = error2;
 202d16c:	e0bffe17 	ldw	r2,-8(fp)
 202d170:	e0bffb15 	stw	r2,-20(fp)
 202d174:	00000106 	br	202d17c <soclose+0x2f0>
       (struct mbuf *)0, (struct mbuf *)0);
      goto discard;
   }

   if (so->so_pcb == 0)
      goto discard;
 202d178:	0001883a 	nop
       (struct mbuf *)0, (struct mbuf *)0);
      if (error == 0)
         error = error2;
   }
discard:
   if (so->so_state & SS_NOFDREF)
 202d17c:	e0bfff17 	ldw	r2,-4(fp)
 202d180:	1080088b 	ldhu	r2,34(r2)
 202d184:	10bfffcc 	andi	r2,r2,65535
 202d188:	1080004c 	andi	r2,r2,1
 202d18c:	10000126 	beq	r2,zero,202d194 <soclose+0x308>
   {
      /* panic("soclose");  - non-fatal - degrade to dtrap() for now */
      dtrap();
 202d190:	20285c80 	call	20285c8 <dtrap>
   }
   so->so_state |= SS_NOFDREF;
 202d194:	e0bfff17 	ldw	r2,-4(fp)
 202d198:	1080088b 	ldhu	r2,34(r2)
 202d19c:	10800054 	ori	r2,r2,1
 202d1a0:	1007883a 	mov	r3,r2
 202d1a4:	e0bfff17 	ldw	r2,-4(fp)
 202d1a8:	10c0088d 	sth	r3,34(r2)
   sofree(so);
 202d1ac:	e13fff17 	ldw	r4,-4(fp)
 202d1b0:	202cd6c0 	call	202cd6c <sofree>
   return (error);
 202d1b4:	e0bffb17 	ldw	r2,-20(fp)
}
 202d1b8:	e037883a 	mov	sp,fp
 202d1bc:	dfc00317 	ldw	ra,12(sp)
 202d1c0:	df000217 	ldw	fp,8(sp)
 202d1c4:	dc400117 	ldw	r17,4(sp)
 202d1c8:	dc000017 	ldw	r16,0(sp)
 202d1cc:	dec00404 	addi	sp,sp,16
 202d1d0:	f800283a 	ret

0202d1d4 <soabort>:
 * RETURNS: 
 */

int
soabort(struct socket * so)
{
 202d1d4:	defffd04 	addi	sp,sp,-12
 202d1d8:	dfc00215 	stw	ra,8(sp)
 202d1dc:	df000115 	stw	fp,4(sp)
 202d1e0:	df000104 	addi	fp,sp,4
 202d1e4:	e13fff15 	stw	r4,-4(fp)
   so->so_req = PRU_ABORT;
 202d1e8:	e0bfff17 	ldw	r2,-4(fp)
 202d1ec:	00c00284 	movi	r3,10
 202d1f0:	10c00715 	stw	r3,28(r2)
   return(*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 202d1f4:	e0bfff17 	ldw	r2,-4(fp)
 202d1f8:	10800217 	ldw	r2,8(r2)
 202d1fc:	10800317 	ldw	r2,12(r2)
 202d200:	e13fff17 	ldw	r4,-4(fp)
 202d204:	000b883a 	mov	r5,zero
 202d208:	000d883a 	mov	r6,zero
 202d20c:	103ee83a 	callr	r2
}
 202d210:	e037883a 	mov	sp,fp
 202d214:	dfc00117 	ldw	ra,4(sp)
 202d218:	df000017 	ldw	fp,0(sp)
 202d21c:	dec00204 	addi	sp,sp,8
 202d220:	f800283a 	ret

0202d224 <soaccept>:
 */

int
soaccept(struct socket * so, 
   struct mbuf *  nam)
{
 202d224:	defffb04 	addi	sp,sp,-20
 202d228:	dfc00415 	stw	ra,16(sp)
 202d22c:	df000315 	stw	fp,12(sp)
 202d230:	df000304 	addi	fp,sp,12
 202d234:	e13ffe15 	stw	r4,-8(fp)
 202d238:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if ((so->so_state & SS_NOFDREF) == 0)
 202d23c:	e0bffe17 	ldw	r2,-8(fp)
 202d240:	1080088b 	ldhu	r2,34(r2)
 202d244:	10bfffcc 	andi	r2,r2,65535
 202d248:	1080004c 	andi	r2,r2,1
 202d24c:	1000031e 	bne	r2,zero,202d25c <soaccept+0x38>
      panic("soaccept");
 202d250:	01008174 	movhi	r4,517
 202d254:	213d4c04 	addi	r4,r4,-2768
 202d258:	2026bf80 	call	2026bf8 <panic>
   so->so_state &= ~SS_NOFDREF;
 202d25c:	e0bffe17 	ldw	r2,-8(fp)
 202d260:	10c0088b 	ldhu	r3,34(r2)
 202d264:	00bfff84 	movi	r2,-2
 202d268:	1884703a 	and	r2,r3,r2
 202d26c:	1007883a 	mov	r3,r2
 202d270:	e0bffe17 	ldw	r2,-8(fp)
 202d274:	10c0088d 	sth	r3,34(r2)
   so->so_req = PRU_ACCEPT;
 202d278:	e0bffe17 	ldw	r2,-8(fp)
 202d27c:	00c00144 	movi	r3,5
 202d280:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 202d284:	e0bffe17 	ldw	r2,-8(fp)
 202d288:	10800217 	ldw	r2,8(r2)
 202d28c:	10800317 	ldw	r2,12(r2)
 202d290:	e13ffe17 	ldw	r4,-8(fp)
 202d294:	000b883a 	mov	r5,zero
 202d298:	e1bfff17 	ldw	r6,-4(fp)
 202d29c:	103ee83a 	callr	r2
 202d2a0:	e0bffd15 	stw	r2,-12(fp)

   return (error);
 202d2a4:	e0bffd17 	ldw	r2,-12(fp)
}
 202d2a8:	e037883a 	mov	sp,fp
 202d2ac:	dfc00117 	ldw	ra,4(sp)
 202d2b0:	df000017 	ldw	fp,0(sp)
 202d2b4:	dec00204 	addi	sp,sp,8
 202d2b8:	f800283a 	ret

0202d2bc <soconnect>:
 */

int
soconnect(struct socket * so, 
   struct mbuf *  nam)
{
 202d2bc:	defffb04 	addi	sp,sp,-20
 202d2c0:	dfc00415 	stw	ra,16(sp)
 202d2c4:	df000315 	stw	fp,12(sp)
 202d2c8:	df000304 	addi	fp,sp,12
 202d2cc:	e13ffe15 	stw	r4,-8(fp)
 202d2d0:	e17fff15 	stw	r5,-4(fp)
   int   error;

   if (so->so_options & SO_ACCEPTCONN)
 202d2d4:	e0bffe17 	ldw	r2,-8(fp)
 202d2d8:	10800417 	ldw	r2,16(r2)
 202d2dc:	1080008c 	andi	r2,r2,2
 202d2e0:	10000226 	beq	r2,zero,202d2ec <soconnect+0x30>
      return (EOPNOTSUPP);
 202d2e4:	008017c4 	movi	r2,95
 202d2e8:	00001d06 	br	202d360 <soconnect+0xa4>
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 202d2ec:	e0bffe17 	ldw	r2,-8(fp)
 202d2f0:	1080088b 	ldhu	r2,34(r2)
 202d2f4:	10bfffcc 	andi	r2,r2,65535
 202d2f8:	1080018c 	andi	r2,r2,6
 202d2fc:	10000c26 	beq	r2,zero,202d330 <soconnect+0x74>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 202d300:	e0bffe17 	ldw	r2,-8(fp)
 202d304:	10800217 	ldw	r2,8(r2)
 202d308:	1080010b 	ldhu	r2,4(r2)
 202d30c:	10bfffcc 	andi	r2,r2,65535
 202d310:	1080010c 	andi	r2,r2,4
    * If protocol is connection-based, can only connect once.
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
 202d314:	1000031e 	bne	r2,zero,202d324 <soconnect+0x68>
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
       (sodisconnect(so) != 0)))
 202d318:	e13ffe17 	ldw	r4,-8(fp)
 202d31c:	202d3740 	call	202d374 <sodisconnect>
    * Otherwise, if connected, try to disconnect first.
    * This allows user to disconnect by connecting to, e.g.,
    * a null address.
    */
   if (so->so_state & (SS_ISCONNECTED|SS_ISCONNECTING) &&
       ((so->so_proto->pr_flags & PR_CONNREQUIRED) ||
 202d320:	10000326 	beq	r2,zero,202d330 <soconnect+0x74>
       (sodisconnect(so) != 0)))
   {
      error = EISCONN;
 202d324:	00801fc4 	movi	r2,127
 202d328:	e0bffd15 	stw	r2,-12(fp)
 202d32c:	00000b06 	br	202d35c <soconnect+0xa0>
   }
   else
   {
      so->so_req = PRU_CONNECT;
 202d330:	e0bffe17 	ldw	r2,-8(fp)
 202d334:	00c00104 	movi	r3,4
 202d338:	10c00715 	stw	r3,28(r2)
      error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, nam);
 202d33c:	e0bffe17 	ldw	r2,-8(fp)
 202d340:	10800217 	ldw	r2,8(r2)
 202d344:	10800317 	ldw	r2,12(r2)
 202d348:	e13ffe17 	ldw	r4,-8(fp)
 202d34c:	000b883a 	mov	r5,zero
 202d350:	e1bfff17 	ldw	r6,-4(fp)
 202d354:	103ee83a 	callr	r2
 202d358:	e0bffd15 	stw	r2,-12(fp)
   }
   return error;
 202d35c:	e0bffd17 	ldw	r2,-12(fp)
}
 202d360:	e037883a 	mov	sp,fp
 202d364:	dfc00117 	ldw	ra,4(sp)
 202d368:	df000017 	ldw	fp,0(sp)
 202d36c:	dec00204 	addi	sp,sp,8
 202d370:	f800283a 	ret

0202d374 <sodisconnect>:
 * RETURNS: 
 */

int
sodisconnect(struct socket * so)
{
 202d374:	defffc04 	addi	sp,sp,-16
 202d378:	dfc00315 	stw	ra,12(sp)
 202d37c:	df000215 	stw	fp,8(sp)
 202d380:	df000204 	addi	fp,sp,8
 202d384:	e13fff15 	stw	r4,-4(fp)
   int   error;

   INET_TRACE (INETM_SOCKET|INETM_CLOSE,
    ("INET: sodisconnect, so %lx so_state %x\n", so, so->so_state));

   if ((so->so_state & SS_ISCONNECTED) == 0) 
 202d388:	e0bfff17 	ldw	r2,-4(fp)
 202d38c:	1080088b 	ldhu	r2,34(r2)
 202d390:	10bfffcc 	andi	r2,r2,65535
 202d394:	1080008c 	andi	r2,r2,2
 202d398:	1000031e 	bne	r2,zero,202d3a8 <sodisconnect+0x34>
   {
      error = ENOTCONN;
 202d39c:	00802004 	movi	r2,128
 202d3a0:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 202d3a4:	00001306 	br	202d3f4 <sodisconnect+0x80>
   }
   if (so->so_state & SS_ISDISCONNECTING) 
 202d3a8:	e0bfff17 	ldw	r2,-4(fp)
 202d3ac:	1080088b 	ldhu	r2,34(r2)
 202d3b0:	10bfffcc 	andi	r2,r2,65535
 202d3b4:	1080020c 	andi	r2,r2,8
 202d3b8:	10000326 	beq	r2,zero,202d3c8 <sodisconnect+0x54>
   {
      error = EALREADY;
 202d3bc:	00801e04 	movi	r2,120
 202d3c0:	e0bffe15 	stw	r2,-8(fp)
      goto bad;
 202d3c4:	00000b06 	br	202d3f4 <sodisconnect+0x80>
   }
   so->so_req = PRU_DISCONNECT;
 202d3c8:	e0bfff17 	ldw	r2,-4(fp)
 202d3cc:	00c00184 	movi	r3,6
 202d3d0:	10c00715 	stw	r3,28(r2)
   error = (*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0);
 202d3d4:	e0bfff17 	ldw	r2,-4(fp)
 202d3d8:	10800217 	ldw	r2,8(r2)
 202d3dc:	10800317 	ldw	r2,12(r2)
 202d3e0:	e13fff17 	ldw	r4,-4(fp)
 202d3e4:	000b883a 	mov	r5,zero
 202d3e8:	000d883a 	mov	r6,zero
 202d3ec:	103ee83a 	callr	r2
 202d3f0:	e0bffe15 	stw	r2,-8(fp)

bad:
   return (error);
 202d3f4:	e0bffe17 	ldw	r2,-8(fp)
}
 202d3f8:	e037883a 	mov	sp,fp
 202d3fc:	dfc00117 	ldw	ra,4(sp)
 202d400:	df000017 	ldw	fp,0(sp)
 202d404:	dec00204 	addi	sp,sp,8
 202d408:	f800283a 	ret

0202d40c <sosend>:
sosend(struct socket *so, 
       struct mbuf *nam,      /* sockaddr, if UDP socket, NULL if TCP */
       char  *data,           /* data to send */
       int   *data_length,    /* IN/OUT  length of (remaining) data */
       int   flags)
{
 202d40c:	defff204 	addi	sp,sp,-56
 202d410:	dfc00d15 	stw	ra,52(sp)
 202d414:	df000c15 	stw	fp,48(sp)
 202d418:	df000c04 	addi	fp,sp,48
 202d41c:	e13ffc15 	stw	r4,-16(fp)
 202d420:	e17ffd15 	stw	r5,-12(fp)
 202d424:	e1bffe15 	stw	r6,-8(fp)
 202d428:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *head = (struct mbuf *)NULL;
 202d42c:	e03ff415 	stw	zero,-48(fp)
   struct mbuf *m;
   int   space;
   int   resid;
   int   len;
   int   error = 0;
 202d430:	e03ff815 	stw	zero,-32(fp)
   int   dontroute;
   int   first = 1;
 202d434:	00800044 	movi	r2,1
 202d438:	e0bff915 	stw	r2,-28(fp)

   resid = *data_length;
 202d43c:	e0bfff17 	ldw	r2,-4(fp)
 202d440:	10800017 	ldw	r2,0(r2)
 202d444:	e0bff715 	stw	r2,-36(fp)
    * However, space must be signed, as it might be less than 0
    * if we over-committed, and we must use a signed comparison
    * of space and resid.  On the other hand, a negative resid
    * causes us to loop sending 0-length segments to the protocol.
    */
   if (resid < 0)
 202d448:	e0bff717 	ldw	r2,-36(fp)
 202d44c:	1000020e 	bge	r2,zero,202d458 <sosend+0x4c>
      return (EINVAL);
 202d450:	00800584 	movi	r2,22
 202d454:	00013f06 	br	202d954 <sosend+0x548>

   INET_TRACE (INETM_IO, ("INET:sosend: so %lx resid %d sb_hiwat %d so_state %x\n",
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
 202d458:	e0bffc17 	ldw	r2,-16(fp)
 202d45c:	10800217 	ldw	r2,8(r2)
 202d460:	1080010b 	ldhu	r2,4(r2)
 202d464:	10bfffcc 	andi	r2,r2,65535
 202d468:	1080004c 	andi	r2,r2,1
 202d46c:	10000726 	beq	r2,zero,202d48c <sosend+0x80>
 202d470:	e0bffc17 	ldw	r2,-16(fp)
 202d474:	10801317 	ldw	r2,76(r2)
 202d478:	1007883a 	mov	r3,r2
 202d47c:	e0bff717 	ldw	r2,-36(fp)
 202d480:	1880020e 	bge	r3,r2,202d48c <sosend+0x80>
      return (EMSGSIZE);
 202d484:	00801e84 	movi	r2,122
 202d488:	00013206 	br	202d954 <sosend+0x548>

   dontroute = (flags & MSG_DONTROUTE) &&
 202d48c:	e0800217 	ldw	r2,8(fp)
 202d490:	1080010c 	andi	r2,r2,4
               ((so->so_options & SO_DONTROUTE) == 0) &&
 202d494:	10000c26 	beq	r2,zero,202d4c8 <sosend+0xbc>
 202d498:	e0bffc17 	ldw	r2,-16(fp)
 202d49c:	10800417 	ldw	r2,16(r2)
 202d4a0:	1080040c 	andi	r2,r2,16
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 202d4a4:	1000081e 	bne	r2,zero,202d4c8 <sosend+0xbc>
               ((so->so_options & SO_DONTROUTE) == 0) &&
               (so->so_proto->pr_flags & PR_ATOMIC);
 202d4a8:	e0bffc17 	ldw	r2,-16(fp)
 202d4ac:	10800217 	ldw	r2,8(r2)
 202d4b0:	1080010b 	ldhu	r2,4(r2)
 202d4b4:	10bfffcc 	andi	r2,r2,65535
 202d4b8:	1080004c 	andi	r2,r2,1

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
               ((so->so_options & SO_DONTROUTE) == 0) &&
 202d4bc:	10000226 	beq	r2,zero,202d4c8 <sosend+0xbc>
 202d4c0:	00800044 	movi	r2,1
 202d4c4:	00000106 	br	202d4cc <sosend+0xc0>
 202d4c8:	0005883a 	mov	r2,zero
               so, resid, so->so_snd.sb_hiwat, so->so_state));

   if (sosendallatonce(so) && (resid > (int)so->so_snd.sb_hiwat))
      return (EMSGSIZE);

   dontroute = (flags & MSG_DONTROUTE) &&
 202d4cc:	e0bffa15 	stw	r2,-24(fp)
               (so->so_proto->pr_flags & PR_ATOMIC);

#define     snderr(errno)     {  error =  errno;   goto  release; }

restart:
   sblock(&so->so_snd);
 202d4d0:	00000506 	br	202d4e8 <sosend+0xdc>
 202d4d4:	00000406 	br	202d4e8 <sosend+0xdc>
 202d4d8:	e0bffc17 	ldw	r2,-16(fp)
 202d4dc:	10801904 	addi	r2,r2,100
 202d4e0:	1009883a 	mov	r4,r2
 202d4e4:	20274f40 	call	20274f4 <tcp_sleep>
 202d4e8:	e0bffc17 	ldw	r2,-16(fp)
 202d4ec:	1080190b 	ldhu	r2,100(r2)
 202d4f0:	10bfffcc 	andi	r2,r2,65535
 202d4f4:	1080004c 	andi	r2,r2,1
 202d4f8:	103ff71e 	bne	r2,zero,202d4d8 <sosend+0xcc>
 202d4fc:	e0bffc17 	ldw	r2,-16(fp)
 202d500:	1080190b 	ldhu	r2,100(r2)
 202d504:	10800054 	ori	r2,r2,1
 202d508:	1007883a 	mov	r3,r2
 202d50c:	e0bffc17 	ldw	r2,-16(fp)
 202d510:	10c0190d 	sth	r3,100(r2)
   do 
   {
      if (so->so_error) 
 202d514:	e0bffc17 	ldw	r2,-16(fp)
 202d518:	10800617 	ldw	r2,24(r2)
 202d51c:	10000626 	beq	r2,zero,202d538 <sosend+0x12c>
      {
         error = so->so_error;
 202d520:	e0bffc17 	ldw	r2,-16(fp)
 202d524:	10800617 	ldw	r2,24(r2)
 202d528:	e0bff815 	stw	r2,-32(fp)
         so->so_error = 0;          /* ??? */
 202d52c:	e0bffc17 	ldw	r2,-16(fp)
 202d530:	10000615 	stw	zero,24(r2)
         goto release;
 202d534:	0000f706 	br	202d914 <sosend+0x508>
      }
      if (so->so_state & SS_CANTSENDMORE)
 202d538:	e0bffc17 	ldw	r2,-16(fp)
 202d53c:	1080088b 	ldhu	r2,34(r2)
 202d540:	10bfffcc 	andi	r2,r2,65535
 202d544:	1080040c 	andi	r2,r2,16
 202d548:	10000326 	beq	r2,zero,202d558 <sosend+0x14c>
         snderr(EPIPE);
 202d54c:	00800804 	movi	r2,32
 202d550:	e0bff815 	stw	r2,-32(fp)
 202d554:	0000ef06 	br	202d914 <sosend+0x508>
      if ((so->so_state & SS_ISCONNECTED) == 0) 
 202d558:	e0bffc17 	ldw	r2,-16(fp)
 202d55c:	1080088b 	ldhu	r2,34(r2)
 202d560:	10bfffcc 	andi	r2,r2,65535
 202d564:	1080008c 	andi	r2,r2,2
 202d568:	10000e1e 	bne	r2,zero,202d5a4 <sosend+0x198>
      {
         if (so->so_proto->pr_flags & PR_CONNREQUIRED)
 202d56c:	e0bffc17 	ldw	r2,-16(fp)
 202d570:	10800217 	ldw	r2,8(r2)
 202d574:	1080010b 	ldhu	r2,4(r2)
 202d578:	10bfffcc 	andi	r2,r2,65535
 202d57c:	1080010c 	andi	r2,r2,4
 202d580:	10000326 	beq	r2,zero,202d590 <sosend+0x184>
            snderr(ENOTCONN);
 202d584:	00802004 	movi	r2,128
 202d588:	e0bff815 	stw	r2,-32(fp)
 202d58c:	0000e106 	br	202d914 <sosend+0x508>
         if (nam == 0)
 202d590:	e0bffd17 	ldw	r2,-12(fp)
 202d594:	1000031e 	bne	r2,zero,202d5a4 <sosend+0x198>
            snderr(EDESTADDRREQ);
 202d598:	00801e44 	movi	r2,121
 202d59c:	e0bff815 	stw	r2,-32(fp)
 202d5a0:	0000dc06 	br	202d914 <sosend+0x508>
      }
      if (flags & MSG_OOB)
 202d5a4:	e0800217 	ldw	r2,8(fp)
 202d5a8:	1080004c 	andi	r2,r2,1
 202d5ac:	10000326 	beq	r2,zero,202d5bc <sosend+0x1b0>
         space = 1024;
 202d5b0:	00810004 	movi	r2,1024
 202d5b4:	e0bff615 	stw	r2,-40(fp)
 202d5b8:	00004706 	br	202d6d8 <sosend+0x2cc>
      else 
      {
         space = (int)sbspace(&so->so_snd);
 202d5bc:	e0bffc17 	ldw	r2,-16(fp)
 202d5c0:	10801317 	ldw	r2,76(r2)
 202d5c4:	1007883a 	mov	r3,r2
 202d5c8:	e0bffc17 	ldw	r2,-16(fp)
 202d5cc:	10801217 	ldw	r2,72(r2)
 202d5d0:	1885c83a 	sub	r2,r3,r2
 202d5d4:	10000616 	blt	r2,zero,202d5f0 <sosend+0x1e4>
 202d5d8:	e0bffc17 	ldw	r2,-16(fp)
 202d5dc:	10c01317 	ldw	r3,76(r2)
 202d5e0:	e0bffc17 	ldw	r2,-16(fp)
 202d5e4:	10801217 	ldw	r2,72(r2)
 202d5e8:	1885c83a 	sub	r2,r3,r2
 202d5ec:	00000106 	br	202d5f4 <sosend+0x1e8>
 202d5f0:	0005883a 	mov	r2,zero
 202d5f4:	e0bff615 	stw	r2,-40(fp)
         if ((sosendallatonce(so) && (space < resid)) ||
 202d5f8:	e0bffc17 	ldw	r2,-16(fp)
 202d5fc:	10800217 	ldw	r2,8(r2)
 202d600:	1080010b 	ldhu	r2,4(r2)
 202d604:	10bfffcc 	andi	r2,r2,65535
 202d608:	1080004c 	andi	r2,r2,1
 202d60c:	10000326 	beq	r2,zero,202d61c <sosend+0x210>
 202d610:	e0fff617 	ldw	r3,-40(fp)
 202d614:	e0bff717 	ldw	r2,-36(fp)
 202d618:	18801216 	blt	r3,r2,202d664 <sosend+0x258>
 202d61c:	e0bff717 	ldw	r2,-36(fp)
 202d620:	10815e10 	cmplti	r2,r2,1400
 202d624:	10002c1e 	bne	r2,zero,202d6d8 <sosend+0x2cc>
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 202d628:	e0bff617 	ldw	r2,-40(fp)
 202d62c:	10815e08 	cmpgei	r2,r2,1400
 202d630:	1000291e 	bne	r2,zero,202d6d8 <sosend+0x2cc>
              (so->so_snd.sb_cc >= CLBYTES) &&
 202d634:	e0bffc17 	ldw	r2,-16(fp)
 202d638:	10801217 	ldw	r2,72(r2)
         space = 1024;
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
 202d63c:	10815e30 	cmpltui	r2,r2,1400
 202d640:	1000251e 	bne	r2,zero,202d6d8 <sosend+0x2cc>
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 202d644:	e0bffc17 	ldw	r2,-16(fp)
 202d648:	1080088b 	ldhu	r2,34(r2)
 202d64c:	10bfffcc 	andi	r2,r2,65535
 202d650:	1080400c 	andi	r2,r2,256
      else 
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
 202d654:	1000201e 	bne	r2,zero,202d6d8 <sosend+0x2cc>
              ((so->so_state & SS_NBIO) == 0) &&
              ((flags & MSG_DONTWAIT) == 0)))
 202d658:	e0800217 	ldw	r2,8(fp)
 202d65c:	1080080c 	andi	r2,r2,32
      {
         space = (int)sbspace(&so->so_snd);
         if ((sosendallatonce(so) && (space < resid)) ||
             ((resid >= CLBYTES) && (space < CLBYTES) &&
              (so->so_snd.sb_cc >= CLBYTES) &&
              ((so->so_state & SS_NBIO) == 0) &&
 202d660:	10001d1e 	bne	r2,zero,202d6d8 <sosend+0x2cc>
              ((flags & MSG_DONTWAIT) == 0)))
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 202d664:	e0bffc17 	ldw	r2,-16(fp)
 202d668:	1080088b 	ldhu	r2,34(r2)
 202d66c:	10bfffcc 	andi	r2,r2,65535
 202d670:	1080400c 	andi	r2,r2,256
 202d674:	1000031e 	bne	r2,zero,202d684 <sosend+0x278>
 202d678:	e0800217 	ldw	r2,8(fp)
 202d67c:	1080080c 	andi	r2,r2,32
 202d680:	10000526 	beq	r2,zero,202d698 <sosend+0x28c>
            {
               if (first)
 202d684:	e0bff917 	ldw	r2,-28(fp)
 202d688:	10009d26 	beq	r2,zero,202d900 <sosend+0x4f4>
                  error = EWOULDBLOCK;
 202d68c:	008002c4 	movi	r2,11
 202d690:	e0bff815 	stw	r2,-32(fp)
               goto release;
 202d694:	00009a06 	br	202d900 <sosend+0x4f4>
            }
            sbunlock(&so->so_snd);
 202d698:	e0bffc17 	ldw	r2,-16(fp)
 202d69c:	10c0190b 	ldhu	r3,100(r2)
 202d6a0:	00bfff84 	movi	r2,-2
 202d6a4:	1884703a 	and	r2,r3,r2
 202d6a8:	1007883a 	mov	r3,r2
 202d6ac:	e0bffc17 	ldw	r2,-16(fp)
 202d6b0:	10c0190d 	sth	r3,100(r2)
 202d6b4:	e0bffc17 	ldw	r2,-16(fp)
 202d6b8:	10801904 	addi	r2,r2,100
 202d6bc:	1009883a 	mov	r4,r2
 202d6c0:	20276980 	call	2027698 <tcp_wakeup>
            sbwait(&so->so_snd);
 202d6c4:	e0bffc17 	ldw	r2,-16(fp)
 202d6c8:	10801204 	addi	r2,r2,72
 202d6cc:	1009883a 	mov	r4,r2
 202d6d0:	202f2c80 	call	202f2c8 <sbwait>
            goto restart;
 202d6d4:	003f7f06 	br	202d4d4 <sosend+0xc8>
         }
      }
      if ( space <= 0 ) 
 202d6d8:	e0bff617 	ldw	r2,-40(fp)
 202d6dc:	00805e16 	blt	zero,r2,202d858 <sosend+0x44c>
      {
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
 202d6e0:	e0bffc17 	ldw	r2,-16(fp)
 202d6e4:	1080088b 	ldhu	r2,34(r2)
 202d6e8:	10bfffcc 	andi	r2,r2,65535
 202d6ec:	1080400c 	andi	r2,r2,256
 202d6f0:	1000031e 	bne	r2,zero,202d700 <sosend+0x2f4>
 202d6f4:	e0800217 	ldw	r2,8(fp)
 202d6f8:	1080080c 	andi	r2,r2,32
 202d6fc:	10000526 	beq	r2,zero,202d714 <sosend+0x308>
         {
            if (first)     /* report first error */
 202d700:	e0bff917 	ldw	r2,-28(fp)
 202d704:	10008026 	beq	r2,zero,202d908 <sosend+0x4fc>
               error = EWOULDBLOCK;
 202d708:	008002c4 	movi	r2,11
 202d70c:	e0bff815 	stw	r2,-32(fp)
            goto release;
 202d710:	00007d06 	br	202d908 <sosend+0x4fc>
         }
         /* If blocking socket, let someone else run */
         sbunlock(&so->so_snd);
 202d714:	e0bffc17 	ldw	r2,-16(fp)
 202d718:	10c0190b 	ldhu	r3,100(r2)
 202d71c:	00bfff84 	movi	r2,-2
 202d720:	1884703a 	and	r2,r3,r2
 202d724:	1007883a 	mov	r3,r2
 202d728:	e0bffc17 	ldw	r2,-16(fp)
 202d72c:	10c0190d 	sth	r3,100(r2)
 202d730:	e0bffc17 	ldw	r2,-16(fp)
 202d734:	10801904 	addi	r2,r2,100
 202d738:	1009883a 	mov	r4,r2
 202d73c:	20276980 	call	2027698 <tcp_wakeup>
         sbwait(&so->so_snd);
 202d740:	e0bffc17 	ldw	r2,-16(fp)
 202d744:	10801204 	addi	r2,r2,72
 202d748:	1009883a 	mov	r4,r2
 202d74c:	202f2c80 	call	202f2c8 <sbwait>
         goto restart;
 202d750:	003f6006 	br	202d4d4 <sosend+0xc8>
      }

      while (space > 0) 
      {
         len = resid;
 202d754:	e0bff717 	ldw	r2,-36(fp)
 202d758:	e0bffb15 	stw	r2,-20(fp)
         if ( so->so_type == SOCK_STREAM )
 202d75c:	e0bffc17 	ldw	r2,-16(fp)
 202d760:	10800983 	ldbu	r2,38(r2)
 202d764:	10803fcc 	andi	r2,r2,255
 202d768:	1080201c 	xori	r2,r2,128
 202d76c:	10bfe004 	addi	r2,r2,-128
 202d770:	10800058 	cmpnei	r2,r2,1
 202d774:	1000171e 	bne	r2,zero,202d7d4 <sosend+0x3c8>
         {
            m = m_getwithdata(MT_TXDATA, len);
 202d778:	01000084 	movi	r4,2
 202d77c:	e17ffb17 	ldw	r5,-20(fp)
 202d780:	20293d80 	call	20293d8 <m_getnbuf>
 202d784:	e0bff515 	stw	r2,-44(fp)
            if (!m)   
 202d788:	e0bff517 	ldw	r2,-44(fp)
 202d78c:	1000031e 	bne	r2,zero,202d79c <sosend+0x390>
               snderr(ENOBUFS);
 202d790:	00801a44 	movi	r2,105
 202d794:	e0bff815 	stw	r2,-32(fp)
 202d798:	00005e06 	br	202d914 <sosend+0x508>
            MEMCPY(m->m_data, data, len);
 202d79c:	e0bff517 	ldw	r2,-44(fp)
 202d7a0:	10c00317 	ldw	r3,12(r2)
 202d7a4:	e0bffb17 	ldw	r2,-20(fp)
 202d7a8:	1809883a 	mov	r4,r3
 202d7ac:	e17ffe17 	ldw	r5,-8(fp)
 202d7b0:	100d883a 	mov	r6,r2
 202d7b4:	200660c0 	call	200660c <memcpy>
            so->so_snd.sb_flags |= SB_MBCOMP;   /* allow compression */
 202d7b8:	e0bffc17 	ldw	r2,-16(fp)
 202d7bc:	1080190b 	ldhu	r2,100(r2)
 202d7c0:	10802014 	ori	r2,r2,128
 202d7c4:	1007883a 	mov	r3,r2
 202d7c8:	e0bffc17 	ldw	r2,-16(fp)
 202d7cc:	10c0190d 	sth	r3,100(r2)
 202d7d0:	00000706 	br	202d7f0 <sosend+0x3e4>
         }
         else
         {
            m = m_get (M_WAIT, MT_TXDATA);
 202d7d4:	01000084 	movi	r4,2
 202d7d8:	000b883a 	mov	r5,zero
 202d7dc:	20293d80 	call	20293d8 <m_getnbuf>
 202d7e0:	e0bff515 	stw	r2,-44(fp)
            m->m_data = data;
 202d7e4:	e0bff517 	ldw	r2,-44(fp)
 202d7e8:	e0fffe17 	ldw	r3,-8(fp)
 202d7ec:	10c00315 	stw	r3,12(r2)
         }
         INET_TRACE (INETM_IO,
          ("sosend:got %d bytes so %lx mlen %d, off %d mtod %x\n",
             len, so, m->m_len, m->m_off, mtod (m, caddr_t)));

         *data_length -= len;
 202d7f0:	e0bfff17 	ldw	r2,-4(fp)
 202d7f4:	10c00017 	ldw	r3,0(r2)
 202d7f8:	e0bffb17 	ldw	r2,-20(fp)
 202d7fc:	1887c83a 	sub	r3,r3,r2
 202d800:	e0bfff17 	ldw	r2,-4(fp)
 202d804:	10c00015 	stw	r3,0(r2)
         resid -= len;
 202d808:	e0fff717 	ldw	r3,-36(fp)
 202d80c:	e0bffb17 	ldw	r2,-20(fp)
 202d810:	1885c83a 	sub	r2,r3,r2
 202d814:	e0bff715 	stw	r2,-36(fp)
         data += len;
 202d818:	e0bffb17 	ldw	r2,-20(fp)
 202d81c:	e0fffe17 	ldw	r3,-8(fp)
 202d820:	1885883a 	add	r2,r3,r2
 202d824:	e0bffe15 	stw	r2,-8(fp)
         m->m_len = len;
 202d828:	e0fffb17 	ldw	r3,-20(fp)
 202d82c:	e0bff517 	ldw	r2,-44(fp)
 202d830:	10c00215 	stw	r3,8(r2)
         if (head == (struct mbuf *)NULL)
 202d834:	e0bff417 	ldw	r2,-48(fp)
 202d838:	1000021e 	bne	r2,zero,202d844 <sosend+0x438>
            head = m;
 202d83c:	e0bff517 	ldw	r2,-44(fp)
 202d840:	e0bff415 	stw	r2,-48(fp)
         if (error)
 202d844:	e0bff817 	ldw	r2,-32(fp)
 202d848:	1000311e 	bne	r2,zero,202d910 <sosend+0x504>
            goto release;
         if (*data_length <= 0)
 202d84c:	e0bfff17 	ldw	r2,-4(fp)
 202d850:	10800017 	ldw	r2,0(r2)
 202d854:	0080030e 	bge	zero,r2,202d864 <sosend+0x458>
         sbunlock(&so->so_snd);
         sbwait(&so->so_snd);
         goto restart;
      }

      while (space > 0) 
 202d858:	e0bff617 	ldw	r2,-40(fp)
 202d85c:	00bfbd16 	blt	zero,r2,202d754 <sosend+0x348>
 202d860:	00000106 	br	202d868 <sosend+0x45c>
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
         if (*data_length <= 0)
            break;
 202d864:	0001883a 	nop
      }

      if (dontroute)
 202d868:	e0bffa17 	ldw	r2,-24(fp)
 202d86c:	10000526 	beq	r2,zero,202d884 <sosend+0x478>
         so->so_options |= SO_DONTROUTE;
 202d870:	e0bffc17 	ldw	r2,-16(fp)
 202d874:	10800417 	ldw	r2,16(r2)
 202d878:	10c00414 	ori	r3,r2,16
 202d87c:	e0bffc17 	ldw	r2,-16(fp)
 202d880:	10c00415 	stw	r3,16(r2)

      so->so_req = (flags & MSG_OOB) ? PRU_SENDOOB : PRU_SEND;
 202d884:	e0800217 	ldw	r2,8(fp)
 202d888:	1080004c 	andi	r2,r2,1
 202d88c:	10000226 	beq	r2,zero,202d898 <sosend+0x48c>
 202d890:	00800384 	movi	r2,14
 202d894:	00000106 	br	202d89c <sosend+0x490>
 202d898:	00800244 	movi	r2,9
 202d89c:	e0fffc17 	ldw	r3,-16(fp)
 202d8a0:	18800715 	stw	r2,28(r3)
      error = (*so->so_proto->pr_usrreq)(so, head, nam);
 202d8a4:	e0bffc17 	ldw	r2,-16(fp)
 202d8a8:	10800217 	ldw	r2,8(r2)
 202d8ac:	10800317 	ldw	r2,12(r2)
 202d8b0:	e13ffc17 	ldw	r4,-16(fp)
 202d8b4:	e17ff417 	ldw	r5,-48(fp)
 202d8b8:	e1bffd17 	ldw	r6,-12(fp)
 202d8bc:	103ee83a 	callr	r2
 202d8c0:	e0bff815 	stw	r2,-32(fp)

      if (dontroute)
 202d8c4:	e0bffa17 	ldw	r2,-24(fp)
 202d8c8:	10000626 	beq	r2,zero,202d8e4 <sosend+0x4d8>
         so->so_options &= ~SO_DONTROUTE;
 202d8cc:	e0bffc17 	ldw	r2,-16(fp)
 202d8d0:	10c00417 	ldw	r3,16(r2)
 202d8d4:	00bffbc4 	movi	r2,-17
 202d8d8:	1886703a 	and	r3,r3,r2
 202d8dc:	e0bffc17 	ldw	r2,-16(fp)
 202d8e0:	10c00415 	stw	r3,16(r2)

      head = (struct mbuf *)NULL;
 202d8e4:	e03ff415 	stw	zero,-48(fp)
      first = 0;
 202d8e8:	e03ff915 	stw	zero,-28(fp)
   } while ((resid != 0) && (error == 0));
 202d8ec:	e0bff717 	ldw	r2,-36(fp)
 202d8f0:	10000826 	beq	r2,zero,202d914 <sosend+0x508>
 202d8f4:	e0bff817 	ldw	r2,-32(fp)
 202d8f8:	103f0626 	beq	r2,zero,202d514 <sosend+0x108>
 202d8fc:	00000506 	br	202d914 <sosend+0x508>
         {
            if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
            {
               if (first)
                  error = EWOULDBLOCK;
               goto release;
 202d900:	0001883a 	nop
 202d904:	00000306 	br	202d914 <sosend+0x508>
         /* no space in socket send buffer - see if we can wait */
         if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT))
         {
            if (first)     /* report first error */
               error = EWOULDBLOCK;
            goto release;
 202d908:	0001883a 	nop
 202d90c:	00000106 	br	202d914 <sosend+0x508>
         data += len;
         m->m_len = len;
         if (head == (struct mbuf *)NULL)
            head = m;
         if (error)
            goto release;
 202d910:	0001883a 	nop
      head = (struct mbuf *)NULL;
      first = 0;
   } while ((resid != 0) && (error == 0));

release:
   sbunlock(&so->so_snd);  
 202d914:	e0bffc17 	ldw	r2,-16(fp)
 202d918:	10c0190b 	ldhu	r3,100(r2)
 202d91c:	00bfff84 	movi	r2,-2
 202d920:	1884703a 	and	r2,r3,r2
 202d924:	1007883a 	mov	r3,r2
 202d928:	e0bffc17 	ldw	r2,-16(fp)
 202d92c:	10c0190d 	sth	r3,100(r2)
 202d930:	e0bffc17 	ldw	r2,-16(fp)
 202d934:	10801904 	addi	r2,r2,100
 202d938:	1009883a 	mov	r4,r2
 202d93c:	20276980 	call	2027698 <tcp_wakeup>
   if (head)
 202d940:	e0bff417 	ldw	r2,-48(fp)
 202d944:	10000226 	beq	r2,zero,202d950 <sosend+0x544>
      m_freem(head);
 202d948:	e13ff417 	ldw	r4,-48(fp)
 202d94c:	20296780 	call	2029678 <m_freem>
   return error;
 202d950:	e0bff817 	ldw	r2,-32(fp)
}
 202d954:	e037883a 	mov	sp,fp
 202d958:	dfc00117 	ldw	ra,4(sp)
 202d95c:	df000017 	ldw	fp,0(sp)
 202d960:	dec00204 	addi	sp,sp,8
 202d964:	f800283a 	ret

0202d968 <soreceive>:
soreceive(struct socket * so, 
   struct mbuf **aname,
   char * data,
   int * datalen,
   int   flags)
{
 202d968:	defff204 	addi	sp,sp,-56
 202d96c:	dfc00d15 	stw	ra,52(sp)
 202d970:	df000c15 	stw	fp,48(sp)
 202d974:	df000c04 	addi	fp,sp,48
 202d978:	e13ffc15 	stw	r4,-16(fp)
 202d97c:	e17ffd15 	stw	r5,-12(fp)
 202d980:	e1bffe15 	stw	r6,-8(fp)
 202d984:	e1ffff15 	stw	r7,-4(fp)
   struct mbuf *  m;
   int   len;
   int   error =  0;
 202d988:	e03ff615 	stw	zero,-40(fp)
   int   offset;
   struct protosw *  pr =  so->so_proto;
 202d98c:	e0bffc17 	ldw	r2,-16(fp)
 202d990:	10800217 	ldw	r2,8(r2)
 202d994:	e0bffa15 	stw	r2,-24(fp)
   struct mbuf *  nextrecord;
   int   moff;
   int   lflags;

   if (aname)
 202d998:	e0bffd17 	ldw	r2,-12(fp)
 202d99c:	10000226 	beq	r2,zero,202d9a8 <soreceive+0x40>
      *aname = 0;
 202d9a0:	e0bffd17 	ldw	r2,-12(fp)
 202d9a4:	10000015 	stw	zero,0(r2)
   if (flags & MSG_OOB) 
 202d9a8:	e0800217 	ldw	r2,8(fp)
 202d9ac:	1080004c 	andi	r2,r2,1
 202d9b0:	10004526 	beq	r2,zero,202dac8 <soreceive+0x160>
   {
      m = m_get (M_WAIT, MT_RXDATA);
 202d9b4:	01000044 	movi	r4,1
 202d9b8:	000b883a 	mov	r5,zero
 202d9bc:	20293d80 	call	20293d8 <m_getnbuf>
 202d9c0:	e0bff415 	stw	r2,-48(fp)
      if (m == NULL)
 202d9c4:	e0bff417 	ldw	r2,-48(fp)
 202d9c8:	1000021e 	bne	r2,zero,202d9d4 <soreceive+0x6c>
         return ENOBUFS;
 202d9cc:	00801a44 	movi	r2,105
 202d9d0:	0001b006 	br	202e094 <soreceive+0x72c>
      lflags = flags & MSG_PEEK;
 202d9d4:	e0800217 	ldw	r2,8(fp)
 202d9d8:	1080008c 	andi	r2,r2,2
 202d9dc:	e0bffb15 	stw	r2,-20(fp)

      so->so_req = PRU_RCVOOB;
 202d9e0:	e0bffc17 	ldw	r2,-16(fp)
 202d9e4:	00c00344 	movi	r3,13
 202d9e8:	10c00715 	stw	r3,28(r2)
      error = (*pr->pr_usrreq)(so, m, LONG2MBUF((long)lflags));
 202d9ec:	e0bffa17 	ldw	r2,-24(fp)
 202d9f0:	10c00317 	ldw	r3,12(r2)
 202d9f4:	e0bffb17 	ldw	r2,-20(fp)
 202d9f8:	e13ffc17 	ldw	r4,-16(fp)
 202d9fc:	e17ff417 	ldw	r5,-48(fp)
 202da00:	100d883a 	mov	r6,r2
 202da04:	183ee83a 	callr	r3
 202da08:	e0bff615 	stw	r2,-40(fp)
      if (error == 0)
 202da0c:	e0bff617 	ldw	r2,-40(fp)
 202da10:	1000231e 	bne	r2,zero,202daa0 <soreceive+0x138>
      {
         do 
         {
            len = *datalen;
 202da14:	e0bfff17 	ldw	r2,-4(fp)
 202da18:	10800017 	ldw	r2,0(r2)
 202da1c:	e0bff515 	stw	r2,-44(fp)
            if (len > (int)m->m_len)
 202da20:	e0bff417 	ldw	r2,-48(fp)
 202da24:	10800217 	ldw	r2,8(r2)
 202da28:	1007883a 	mov	r3,r2
 202da2c:	e0bff517 	ldw	r2,-44(fp)
 202da30:	1880030e 	bge	r3,r2,202da40 <soreceive+0xd8>
               len = m->m_len;
 202da34:	e0bff417 	ldw	r2,-48(fp)
 202da38:	10800217 	ldw	r2,8(r2)
 202da3c:	e0bff515 	stw	r2,-44(fp)

            MEMCPY(data, mtod(m, char*), len);
 202da40:	e0bff417 	ldw	r2,-48(fp)
 202da44:	10c00317 	ldw	r3,12(r2)
 202da48:	e0bff517 	ldw	r2,-44(fp)
 202da4c:	e13ffe17 	ldw	r4,-8(fp)
 202da50:	180b883a 	mov	r5,r3
 202da54:	100d883a 	mov	r6,r2
 202da58:	200660c0 	call	200660c <memcpy>
            data += len;
 202da5c:	e0bff517 	ldw	r2,-44(fp)
 202da60:	e0fffe17 	ldw	r3,-8(fp)
 202da64:	1885883a 	add	r2,r3,r2
 202da68:	e0bffe15 	stw	r2,-8(fp)
            *datalen = len;
 202da6c:	e0bfff17 	ldw	r2,-4(fp)
 202da70:	e0fff517 	ldw	r3,-44(fp)
 202da74:	10c00015 	stw	r3,0(r2)
            m = m_free(m);
 202da78:	e13ff417 	ldw	r4,-48(fp)
 202da7c:	20295600 	call	2029560 <m_free>
 202da80:	e0bff415 	stw	r2,-48(fp)
         } while (*datalen && (error == 0) && m);
 202da84:	e0bfff17 	ldw	r2,-4(fp)
 202da88:	10800017 	ldw	r2,0(r2)
 202da8c:	10000426 	beq	r2,zero,202daa0 <soreceive+0x138>
 202da90:	e0bff617 	ldw	r2,-40(fp)
 202da94:	1000021e 	bne	r2,zero,202daa0 <soreceive+0x138>
 202da98:	e0bff417 	ldw	r2,-48(fp)
 202da9c:	103fdd1e 	bne	r2,zero,202da14 <soreceive+0xac>
      }

      if (m)
 202daa0:	e0bff417 	ldw	r2,-48(fp)
 202daa4:	10000226 	beq	r2,zero,202dab0 <soreceive+0x148>
         m_freem(m);
 202daa8:	e13ff417 	ldw	r4,-48(fp)
 202daac:	20296780 	call	2029678 <m_freem>
      return (error);
 202dab0:	e0bff617 	ldw	r2,-40(fp)
 202dab4:	00017706 	br	202e094 <soreceive+0x72c>
   }

restart:
   sblock (&so->so_rcv);
 202dab8:	e0bffc17 	ldw	r2,-16(fp)
 202dabc:	10801104 	addi	r2,r2,68
 202dac0:	1009883a 	mov	r4,r2
 202dac4:	20274f40 	call	20274f4 <tcp_sleep>
 202dac8:	e0bffc17 	ldw	r2,-16(fp)
 202dacc:	1080110b 	ldhu	r2,68(r2)
 202dad0:	10bfffcc 	andi	r2,r2,65535
 202dad4:	1080004c 	andi	r2,r2,1
 202dad8:	103ff71e 	bne	r2,zero,202dab8 <soreceive+0x150>
 202dadc:	e0bffc17 	ldw	r2,-16(fp)
 202dae0:	1080110b 	ldhu	r2,68(r2)
 202dae4:	10800054 	ori	r2,r2,1
 202dae8:	1007883a 	mov	r3,r2
 202daec:	e0bffc17 	ldw	r2,-16(fp)
 202daf0:	10c0110d 	sth	r3,68(r2)
   INET_TRACE (INETM_IO,
    ("INET:soreceive sbcc %d soerror %d so_state %d *datalen %d\n",
    so->so_rcv.sb_cc, so->so_error, so->so_state, *datalen));

   /* If no data is ready, see if we should wait or return */
   if (so->so_rcv.sb_cc == 0) 
 202daf4:	e0bffc17 	ldw	r2,-16(fp)
 202daf8:	10800a17 	ldw	r2,40(r2)
 202dafc:	10003b1e 	bne	r2,zero,202dbec <soreceive+0x284>
   {
      if (so->so_error) 
 202db00:	e0bffc17 	ldw	r2,-16(fp)
 202db04:	10800617 	ldw	r2,24(r2)
 202db08:	10000626 	beq	r2,zero,202db24 <soreceive+0x1bc>
      {
         error = so->so_error;
 202db0c:	e0bffc17 	ldw	r2,-16(fp)
 202db10:	10800617 	ldw	r2,24(r2)
 202db14:	e0bff615 	stw	r2,-40(fp)
         so->so_error = 0;
 202db18:	e0bffc17 	ldw	r2,-16(fp)
 202db1c:	10000615 	stw	zero,24(r2)
         goto release;
 202db20:	00015006 	br	202e064 <soreceive+0x6fc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 202db24:	e0bffc17 	ldw	r2,-16(fp)
 202db28:	1080088b 	ldhu	r2,34(r2)
 202db2c:	10bfffcc 	andi	r2,r2,65535
 202db30:	1080080c 	andi	r2,r2,32
 202db34:	1001481e 	bne	r2,zero,202e058 <soreceive+0x6f0>
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 202db38:	e0bffc17 	ldw	r2,-16(fp)
 202db3c:	1080088b 	ldhu	r2,34(r2)
 202db40:	10bfffcc 	andi	r2,r2,65535
 202db44:	1080008c 	andi	r2,r2,2
 202db48:	1000091e 	bne	r2,zero,202db70 <soreceive+0x208>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
 202db4c:	e0bffc17 	ldw	r2,-16(fp)
 202db50:	10800217 	ldw	r2,8(r2)
 202db54:	1080010b 	ldhu	r2,4(r2)
 202db58:	10bfffcc 	andi	r2,r2,65535
 202db5c:	1080010c 	andi	r2,r2,4
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
      if ((so->so_state & SS_ISCONNECTED) == 0 &&
 202db60:	10000326 	beq	r2,zero,202db70 <soreceive+0x208>
          (so->so_proto->pr_flags & PR_CONNREQUIRED)) 
      {
         error = ENOTCONN;
 202db64:	00802004 	movi	r2,128
 202db68:	e0bff615 	stw	r2,-40(fp)
         goto release;
 202db6c:	00013d06 	br	202e064 <soreceive+0x6fc>
      }
      if (*datalen == 0)
 202db70:	e0bfff17 	ldw	r2,-4(fp)
 202db74:	10800017 	ldw	r2,0(r2)
 202db78:	10013926 	beq	r2,zero,202e060 <soreceive+0x6f8>
         goto release;
      if ((so->so_state & SS_NBIO) || (flags & MSG_DONTWAIT)) 
 202db7c:	e0bffc17 	ldw	r2,-16(fp)
 202db80:	1080088b 	ldhu	r2,34(r2)
 202db84:	10bfffcc 	andi	r2,r2,65535
 202db88:	1080400c 	andi	r2,r2,256
 202db8c:	1000031e 	bne	r2,zero,202db9c <soreceive+0x234>
 202db90:	e0800217 	ldw	r2,8(fp)
 202db94:	1080080c 	andi	r2,r2,32
 202db98:	10000326 	beq	r2,zero,202dba8 <soreceive+0x240>
      {
         error = EWOULDBLOCK;
 202db9c:	008002c4 	movi	r2,11
 202dba0:	e0bff615 	stw	r2,-40(fp)
         goto release;
 202dba4:	00012f06 	br	202e064 <soreceive+0x6fc>
      }
      sbunlock(&so->so_rcv);
 202dba8:	e0bffc17 	ldw	r2,-16(fp)
 202dbac:	10c0110b 	ldhu	r3,68(r2)
 202dbb0:	00bfff84 	movi	r2,-2
 202dbb4:	1884703a 	and	r2,r3,r2
 202dbb8:	1007883a 	mov	r3,r2
 202dbbc:	e0bffc17 	ldw	r2,-16(fp)
 202dbc0:	10c0110d 	sth	r3,68(r2)
 202dbc4:	e0bffc17 	ldw	r2,-16(fp)
 202dbc8:	10801104 	addi	r2,r2,68
 202dbcc:	1009883a 	mov	r4,r2
 202dbd0:	20276980 	call	2027698 <tcp_wakeup>
      sbwait(&so->so_rcv);
 202dbd4:	e0bffc17 	ldw	r2,-16(fp)
 202dbd8:	10800a04 	addi	r2,r2,40
 202dbdc:	1009883a 	mov	r4,r2
 202dbe0:	202f2c80 	call	202f2c8 <sbwait>
      goto restart;
 202dbe4:	0001883a 	nop
         m_freem(m);
      return (error);
   }

restart:
   sblock (&so->so_rcv);
 202dbe8:	003fb706 	br	202dac8 <soreceive+0x160>
      }
      sbunlock(&so->so_rcv);
      sbwait(&so->so_rcv);
      goto restart;
   }
   m = so->so_rcv.sb_mb;
 202dbec:	e0bffc17 	ldw	r2,-16(fp)
 202dbf0:	10801017 	ldw	r2,64(r2)
 202dbf4:	e0bff415 	stw	r2,-48(fp)
   if (m == 0)
 202dbf8:	e0bff417 	ldw	r2,-48(fp)
 202dbfc:	1000031e 	bne	r2,zero,202dc0c <soreceive+0x2a4>
      panic("sorecv 1");
 202dc00:	01008174 	movhi	r4,517
 202dc04:	213d4f04 	addi	r4,r4,-2756
 202dc08:	2026bf80 	call	2026bf8 <panic>
   nextrecord = m->m_act;
 202dc0c:	e0bff417 	ldw	r2,-48(fp)
 202dc10:	10800717 	ldw	r2,28(r2)
 202dc14:	e0bff815 	stw	r2,-32(fp)
   if (pr->pr_flags & PR_ADDR) 
 202dc18:	e0bffa17 	ldw	r2,-24(fp)
 202dc1c:	1080010b 	ldhu	r2,4(r2)
 202dc20:	10bfffcc 	andi	r2,r2,65535
 202dc24:	1080008c 	andi	r2,r2,2
 202dc28:	10004026 	beq	r2,zero,202dd2c <soreceive+0x3c4>
   {
      if (m->m_type != MT_SONAME) 
 202dc2c:	e0bff417 	ldw	r2,-48(fp)
 202dc30:	10800817 	ldw	r2,32(r2)
 202dc34:	10800260 	cmpeqi	r2,r2,9
 202dc38:	1000091e 	bne	r2,zero,202dc60 <soreceive+0x2f8>
      {
         dprintf ("sorecv:type %d not nam", m->m_type);
 202dc3c:	e0bff417 	ldw	r2,-48(fp)
 202dc40:	10800817 	ldw	r2,32(r2)
 202dc44:	01008174 	movhi	r4,517
 202dc48:	213d5204 	addi	r4,r4,-2744
 202dc4c:	100b883a 	mov	r5,r2
 202dc50:	2006a240 	call	2006a24 <printf>
         panic("sorecv 2");
 202dc54:	01008174 	movhi	r4,517
 202dc58:	213d5804 	addi	r4,r4,-2720
 202dc5c:	2026bf80 	call	2026bf8 <panic>
      }
      if (flags & MSG_PEEK) 
 202dc60:	e0800217 	ldw	r2,8(fp)
 202dc64:	1080008c 	andi	r2,r2,2
 202dc68:	10000e26 	beq	r2,zero,202dca4 <soreceive+0x33c>
      {
         if (aname)
 202dc6c:	e0bffd17 	ldw	r2,-12(fp)
 202dc70:	10000826 	beq	r2,zero,202dc94 <soreceive+0x32c>
            *aname = m_copy (m, 0, m->m_len);
 202dc74:	e0bff417 	ldw	r2,-48(fp)
 202dc78:	10800217 	ldw	r2,8(r2)
 202dc7c:	e13ff417 	ldw	r4,-48(fp)
 202dc80:	000b883a 	mov	r5,zero
 202dc84:	100d883a 	mov	r6,r2
 202dc88:	20296b80 	call	20296b8 <m_copy>
 202dc8c:	e0fffd17 	ldw	r3,-12(fp)
 202dc90:	18800015 	stw	r2,0(r3)
         m = m->m_next;
 202dc94:	e0bff417 	ldw	r2,-48(fp)
 202dc98:	10800617 	ldw	r2,24(r2)
 202dc9c:	e0bff415 	stw	r2,-48(fp)
 202dca0:	00002206 	br	202dd2c <soreceive+0x3c4>
      } else 
      {
         sbfree (&so->so_rcv, m);
 202dca4:	e0bffc17 	ldw	r2,-16(fp)
 202dca8:	10c00a17 	ldw	r3,40(r2)
 202dcac:	e0bff417 	ldw	r2,-48(fp)
 202dcb0:	10800217 	ldw	r2,8(r2)
 202dcb4:	1887c83a 	sub	r3,r3,r2
 202dcb8:	e0bffc17 	ldw	r2,-16(fp)
 202dcbc:	10c00a15 	stw	r3,40(r2)
         if (aname) 
 202dcc0:	e0bffd17 	ldw	r2,-12(fp)
 202dcc4:	10000d26 	beq	r2,zero,202dcfc <soreceive+0x394>
         {
            *aname = m;
 202dcc8:	e0bffd17 	ldw	r2,-12(fp)
 202dccc:	e0fff417 	ldw	r3,-48(fp)
 202dcd0:	10c00015 	stw	r3,0(r2)
            m = m->m_next;
 202dcd4:	e0bff417 	ldw	r2,-48(fp)
 202dcd8:	10800617 	ldw	r2,24(r2)
 202dcdc:	e0bff415 	stw	r2,-48(fp)
            (*aname)->m_next = 0;
 202dce0:	e0bffd17 	ldw	r2,-12(fp)
 202dce4:	10800017 	ldw	r2,0(r2)
 202dce8:	10000615 	stw	zero,24(r2)
            so->so_rcv.sb_mb = m;
 202dcec:	e0bffc17 	ldw	r2,-16(fp)
 202dcf0:	e0fff417 	ldw	r3,-48(fp)
 202dcf4:	10c01015 	stw	r3,64(r2)
 202dcf8:	00000706 	br	202dd18 <soreceive+0x3b0>
         } else 
         {
            MFREE(m, so->so_rcv.sb_mb);
 202dcfc:	e13ff417 	ldw	r4,-48(fp)
 202dd00:	20295600 	call	2029560 <m_free>
 202dd04:	e0fffc17 	ldw	r3,-16(fp)
 202dd08:	18801015 	stw	r2,64(r3)
            m = so->so_rcv.sb_mb;
 202dd0c:	e0bffc17 	ldw	r2,-16(fp)
 202dd10:	10801017 	ldw	r2,64(r2)
 202dd14:	e0bff415 	stw	r2,-48(fp)
         }
         if (m)
 202dd18:	e0bff417 	ldw	r2,-48(fp)
 202dd1c:	10000326 	beq	r2,zero,202dd2c <soreceive+0x3c4>
            m->m_act = nextrecord;
 202dd20:	e0bff417 	ldw	r2,-48(fp)
 202dd24:	e0fff817 	ldw	r3,-32(fp)
 202dd28:	10c00715 	stw	r3,28(r2)
      }
   }
   moff = 0;
 202dd2c:	e03ff915 	stw	zero,-28(fp)
   offset = 0;
 202dd30:	e03ff715 	stw	zero,-36(fp)
   while (m && (*datalen > 0) && (error == 0))
 202dd34:	00009d06 	br	202dfac <soreceive+0x644>
   {
      if (m->m_type != MT_RXDATA && m->m_type != MT_HEADER)
 202dd38:	e0bff417 	ldw	r2,-48(fp)
 202dd3c:	10800817 	ldw	r2,32(r2)
 202dd40:	10800060 	cmpeqi	r2,r2,1
 202dd44:	1000071e 	bne	r2,zero,202dd64 <soreceive+0x3fc>
 202dd48:	e0bff417 	ldw	r2,-48(fp)
 202dd4c:	10800817 	ldw	r2,32(r2)
 202dd50:	108000e0 	cmpeqi	r2,r2,3
 202dd54:	1000031e 	bne	r2,zero,202dd64 <soreceive+0x3fc>
         panic("sorecv 3");
 202dd58:	01008174 	movhi	r4,517
 202dd5c:	213d5b04 	addi	r4,r4,-2708
 202dd60:	2026bf80 	call	2026bf8 <panic>
      len = *datalen;
 202dd64:	e0bfff17 	ldw	r2,-4(fp)
 202dd68:	10800017 	ldw	r2,0(r2)
 202dd6c:	e0bff515 	stw	r2,-44(fp)
      so->so_state &= ~SS_RCVATMARK;
 202dd70:	e0bffc17 	ldw	r2,-16(fp)
 202dd74:	10c0088b 	ldhu	r3,34(r2)
 202dd78:	00bfefc4 	movi	r2,-65
 202dd7c:	1884703a 	and	r2,r3,r2
 202dd80:	1007883a 	mov	r3,r2
 202dd84:	e0bffc17 	ldw	r2,-16(fp)
 202dd88:	10c0088d 	sth	r3,34(r2)
      if (so->so_oobmark && (len > (int)(so->so_oobmark - offset)))
 202dd8c:	e0bffc17 	ldw	r2,-16(fp)
 202dd90:	10801a17 	ldw	r2,104(r2)
 202dd94:	10000c26 	beq	r2,zero,202ddc8 <soreceive+0x460>
 202dd98:	e0bffc17 	ldw	r2,-16(fp)
 202dd9c:	10c01a17 	ldw	r3,104(r2)
 202dda0:	e0bff717 	ldw	r2,-36(fp)
 202dda4:	1885c83a 	sub	r2,r3,r2
 202dda8:	1007883a 	mov	r3,r2
 202ddac:	e0bff517 	ldw	r2,-44(fp)
 202ddb0:	1880050e 	bge	r3,r2,202ddc8 <soreceive+0x460>
         len = (int)(so->so_oobmark - offset);
 202ddb4:	e0bffc17 	ldw	r2,-16(fp)
 202ddb8:	10c01a17 	ldw	r3,104(r2)
 202ddbc:	e0bff717 	ldw	r2,-36(fp)
 202ddc0:	1885c83a 	sub	r2,r3,r2
 202ddc4:	e0bff515 	stw	r2,-44(fp)
      if (len > (int)(m->m_len - moff))
 202ddc8:	e0bff417 	ldw	r2,-48(fp)
 202ddcc:	10c00217 	ldw	r3,8(r2)
 202ddd0:	e0bff917 	ldw	r2,-28(fp)
 202ddd4:	1885c83a 	sub	r2,r3,r2
 202ddd8:	1007883a 	mov	r3,r2
 202dddc:	e0bff517 	ldw	r2,-44(fp)
 202dde0:	1880050e 	bge	r3,r2,202ddf8 <soreceive+0x490>
         len = m->m_len - moff;
 202dde4:	e0bff417 	ldw	r2,-48(fp)
 202dde8:	10c00217 	ldw	r3,8(r2)
 202ddec:	e0bff917 	ldw	r2,-28(fp)
 202ddf0:	1885c83a 	sub	r2,r3,r2
 202ddf4:	e0bff515 	stw	r2,-44(fp)
       * it points to next record) when we drop priority;
       * we must note any additions to the sockbuf when we
       * block interrupts again.
       */

      MEMCPY(data, (mtod(m, char *) + moff), len);
 202ddf8:	e0bff417 	ldw	r2,-48(fp)
 202ddfc:	10c00317 	ldw	r3,12(r2)
 202de00:	e0bff917 	ldw	r2,-28(fp)
 202de04:	1887883a 	add	r3,r3,r2
 202de08:	e0bff517 	ldw	r2,-44(fp)
 202de0c:	e13ffe17 	ldw	r4,-8(fp)
 202de10:	180b883a 	mov	r5,r3
 202de14:	100d883a 	mov	r6,r2
 202de18:	200660c0 	call	200660c <memcpy>
      data += len;
 202de1c:	e0bff517 	ldw	r2,-44(fp)
 202de20:	e0fffe17 	ldw	r3,-8(fp)
 202de24:	1885883a 	add	r2,r3,r2
 202de28:	e0bffe15 	stw	r2,-8(fp)
      *datalen -= len;
 202de2c:	e0bfff17 	ldw	r2,-4(fp)
 202de30:	10c00017 	ldw	r3,0(r2)
 202de34:	e0bff517 	ldw	r2,-44(fp)
 202de38:	1887c83a 	sub	r3,r3,r2
 202de3c:	e0bfff17 	ldw	r2,-4(fp)
 202de40:	10c00015 	stw	r3,0(r2)

      if (len == (int)(m->m_len - moff))
 202de44:	e0bff417 	ldw	r2,-48(fp)
 202de48:	10c00217 	ldw	r3,8(r2)
 202de4c:	e0bff917 	ldw	r2,-28(fp)
 202de50:	1885c83a 	sub	r2,r3,r2
 202de54:	1007883a 	mov	r3,r2
 202de58:	e0bff517 	ldw	r2,-44(fp)
 202de5c:	18801f1e 	bne	r3,r2,202dedc <soreceive+0x574>
      {
         if (flags & MSG_PEEK) 
 202de60:	e0800217 	ldw	r2,8(fp)
 202de64:	1080008c 	andi	r2,r2,2
 202de68:	10000526 	beq	r2,zero,202de80 <soreceive+0x518>
         {
            m = m->m_next;
 202de6c:	e0bff417 	ldw	r2,-48(fp)
 202de70:	10800617 	ldw	r2,24(r2)
 202de74:	e0bff415 	stw	r2,-48(fp)
            moff = 0;
 202de78:	e03ff915 	stw	zero,-28(fp)
 202de7c:	00003106 	br	202df44 <soreceive+0x5dc>
         } else 
         {
            nextrecord = m->m_act;
 202de80:	e0bff417 	ldw	r2,-48(fp)
 202de84:	10800717 	ldw	r2,28(r2)
 202de88:	e0bff815 	stw	r2,-32(fp)
            sbfree(&so->so_rcv, m);
 202de8c:	e0bffc17 	ldw	r2,-16(fp)
 202de90:	10c00a17 	ldw	r3,40(r2)
 202de94:	e0bff417 	ldw	r2,-48(fp)
 202de98:	10800217 	ldw	r2,8(r2)
 202de9c:	1887c83a 	sub	r3,r3,r2
 202dea0:	e0bffc17 	ldw	r2,-16(fp)
 202dea4:	10c00a15 	stw	r3,40(r2)
            {
               MFREE(m, so->so_rcv.sb_mb);
 202dea8:	e13ff417 	ldw	r4,-48(fp)
 202deac:	20295600 	call	2029560 <m_free>
 202deb0:	e0fffc17 	ldw	r3,-16(fp)
 202deb4:	18801015 	stw	r2,64(r3)
               m = so->so_rcv.sb_mb;
 202deb8:	e0bffc17 	ldw	r2,-16(fp)
 202debc:	10801017 	ldw	r2,64(r2)
 202dec0:	e0bff415 	stw	r2,-48(fp)
            }
            if (m)
 202dec4:	e0bff417 	ldw	r2,-48(fp)
 202dec8:	10001e26 	beq	r2,zero,202df44 <soreceive+0x5dc>
               m->m_act = nextrecord;
 202decc:	e0bff417 	ldw	r2,-48(fp)
 202ded0:	e0fff817 	ldw	r3,-32(fp)
 202ded4:	10c00715 	stw	r3,28(r2)
 202ded8:	00001a06 	br	202df44 <soreceive+0x5dc>
         }
      } else 
      {
         if (flags & MSG_PEEK)
 202dedc:	e0800217 	ldw	r2,8(fp)
 202dee0:	1080008c 	andi	r2,r2,2
 202dee4:	10000526 	beq	r2,zero,202defc <soreceive+0x594>
            moff += len;
 202dee8:	e0fff917 	ldw	r3,-28(fp)
 202deec:	e0bff517 	ldw	r2,-44(fp)
 202def0:	1885883a 	add	r2,r3,r2
 202def4:	e0bff915 	stw	r2,-28(fp)
 202def8:	00001206 	br	202df44 <soreceive+0x5dc>
         else 
         {
            m->m_data += len;
 202defc:	e0bff417 	ldw	r2,-48(fp)
 202df00:	10c00317 	ldw	r3,12(r2)
 202df04:	e0bff517 	ldw	r2,-44(fp)
 202df08:	1887883a 	add	r3,r3,r2
 202df0c:	e0bff417 	ldw	r2,-48(fp)
 202df10:	10c00315 	stw	r3,12(r2)
            m->m_len -= len;
 202df14:	e0bff417 	ldw	r2,-48(fp)
 202df18:	10c00217 	ldw	r3,8(r2)
 202df1c:	e0bff517 	ldw	r2,-44(fp)
 202df20:	1887c83a 	sub	r3,r3,r2
 202df24:	e0bff417 	ldw	r2,-48(fp)
 202df28:	10c00215 	stw	r3,8(r2)
            so->so_rcv.sb_cc -= len;
 202df2c:	e0bffc17 	ldw	r2,-16(fp)
 202df30:	10c00a17 	ldw	r3,40(r2)
 202df34:	e0bff517 	ldw	r2,-44(fp)
 202df38:	1887c83a 	sub	r3,r3,r2
 202df3c:	e0bffc17 	ldw	r2,-16(fp)
 202df40:	10c00a15 	stw	r3,40(r2)
         }
      }
      if (so->so_oobmark) 
 202df44:	e0bffc17 	ldw	r2,-16(fp)
 202df48:	10801a17 	ldw	r2,104(r2)
 202df4c:	10001726 	beq	r2,zero,202dfac <soreceive+0x644>
      {
         if ((flags & MSG_PEEK) == 0) 
 202df50:	e0800217 	ldw	r2,8(fp)
 202df54:	1080008c 	andi	r2,r2,2
 202df58:	1000101e 	bne	r2,zero,202df9c <soreceive+0x634>
         {
            so->so_oobmark -= len;
 202df5c:	e0bffc17 	ldw	r2,-16(fp)
 202df60:	10c01a17 	ldw	r3,104(r2)
 202df64:	e0bff517 	ldw	r2,-44(fp)
 202df68:	1887c83a 	sub	r3,r3,r2
 202df6c:	e0bffc17 	ldw	r2,-16(fp)
 202df70:	10c01a15 	stw	r3,104(r2)
            if (so->so_oobmark == 0) 
 202df74:	e0bffc17 	ldw	r2,-16(fp)
 202df78:	10801a17 	ldw	r2,104(r2)
 202df7c:	10000b1e 	bne	r2,zero,202dfac <soreceive+0x644>
            {
               so->so_state |= SS_RCVATMARK;
 202df80:	e0bffc17 	ldw	r2,-16(fp)
 202df84:	1080088b 	ldhu	r2,34(r2)
 202df88:	10801014 	ori	r2,r2,64
 202df8c:	1007883a 	mov	r3,r2
 202df90:	e0bffc17 	ldw	r2,-16(fp)
 202df94:	10c0088d 	sth	r3,34(r2)
               break;
 202df98:	00000b06 	br	202dfc8 <soreceive+0x660>
            }
         } else
            offset += len;
 202df9c:	e0fff717 	ldw	r3,-36(fp)
 202dfa0:	e0bff517 	ldw	r2,-44(fp)
 202dfa4:	1885883a 	add	r2,r3,r2
 202dfa8:	e0bff715 	stw	r2,-36(fp)
            m->m_act = nextrecord;
      }
   }
   moff = 0;
   offset = 0;
   while (m && (*datalen > 0) && (error == 0))
 202dfac:	e0bff417 	ldw	r2,-48(fp)
 202dfb0:	10000526 	beq	r2,zero,202dfc8 <soreceive+0x660>
 202dfb4:	e0bfff17 	ldw	r2,-4(fp)
 202dfb8:	10800017 	ldw	r2,0(r2)
 202dfbc:	0080020e 	bge	zero,r2,202dfc8 <soreceive+0x660>
 202dfc0:	e0bff617 	ldw	r2,-40(fp)
 202dfc4:	103f5c26 	beq	r2,zero,202dd38 <soreceive+0x3d0>
         } else
            offset += len;
      }
   }

   if ((flags & MSG_PEEK) == 0) 
 202dfc8:	e0800217 	ldw	r2,8(fp)
 202dfcc:	1080008c 	andi	r2,r2,2
 202dfd0:	1000241e 	bne	r2,zero,202e064 <soreceive+0x6fc>
   {
      if (m == 0)
 202dfd4:	e0bff417 	ldw	r2,-48(fp)
 202dfd8:	1000041e 	bne	r2,zero,202dfec <soreceive+0x684>
         so->so_rcv.sb_mb = nextrecord;
 202dfdc:	e0bffc17 	ldw	r2,-16(fp)
 202dfe0:	e0fff817 	ldw	r3,-32(fp)
 202dfe4:	10c01015 	stw	r3,64(r2)
 202dfe8:	00000906 	br	202e010 <soreceive+0x6a8>
      else if (pr->pr_flags & PR_ATOMIC)
 202dfec:	e0bffa17 	ldw	r2,-24(fp)
 202dff0:	1080010b 	ldhu	r2,4(r2)
 202dff4:	10bfffcc 	andi	r2,r2,65535
 202dff8:	1080004c 	andi	r2,r2,1
 202dffc:	10000426 	beq	r2,zero,202e010 <soreceive+0x6a8>
         (void) sbdroprecord(&so->so_rcv);
 202e000:	e0bffc17 	ldw	r2,-16(fp)
 202e004:	10800a04 	addi	r2,r2,40
 202e008:	1009883a 	mov	r4,r2
 202e00c:	202fd480 	call	202fd48 <sbdroprecord>
      if (pr->pr_flags & PR_WANTRCVD && so->so_pcb)
 202e010:	e0bffa17 	ldw	r2,-24(fp)
 202e014:	1080010b 	ldhu	r2,4(r2)
 202e018:	10bfffcc 	andi	r2,r2,65535
 202e01c:	1080020c 	andi	r2,r2,8
 202e020:	10001026 	beq	r2,zero,202e064 <soreceive+0x6fc>
 202e024:	e0bffc17 	ldw	r2,-16(fp)
 202e028:	10800117 	ldw	r2,4(r2)
 202e02c:	10000d26 	beq	r2,zero,202e064 <soreceive+0x6fc>
      {
         so->so_req = PRU_RCVD;
 202e030:	e0bffc17 	ldw	r2,-16(fp)
 202e034:	00c00204 	movi	r3,8
 202e038:	10c00715 	stw	r3,28(r2)
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
 202e03c:	e0bffa17 	ldw	r2,-24(fp)
 202e040:	10800317 	ldw	r2,12(r2)
 202e044:	e13ffc17 	ldw	r4,-16(fp)
 202e048:	000b883a 	mov	r5,zero
 202e04c:	000d883a 	mov	r6,zero
 202e050:	103ee83a 	callr	r2
 202e054:	00000306 	br	202e064 <soreceive+0x6fc>
         error = so->so_error;
         so->so_error = 0;
         goto release;
      }
      if (so->so_state & SS_CANTRCVMORE)
         goto release;
 202e058:	0001883a 	nop
 202e05c:	00000106 	br	202e064 <soreceive+0x6fc>
      {
         error = ENOTCONN;
         goto release;
      }
      if (*datalen == 0)
         goto release;
 202e060:	0001883a 	nop
         (*pr->pr_usrreq)(so, (struct mbuf *)0,
          (struct mbuf *)0);
      }
   }
release:
   sbunlock(&so->so_rcv);
 202e064:	e0bffc17 	ldw	r2,-16(fp)
 202e068:	10c0110b 	ldhu	r3,68(r2)
 202e06c:	00bfff84 	movi	r2,-2
 202e070:	1884703a 	and	r2,r3,r2
 202e074:	1007883a 	mov	r3,r2
 202e078:	e0bffc17 	ldw	r2,-16(fp)
 202e07c:	10c0110d 	sth	r3,68(r2)
 202e080:	e0bffc17 	ldw	r2,-16(fp)
 202e084:	10801104 	addi	r2,r2,68
 202e088:	1009883a 	mov	r4,r2
 202e08c:	20276980 	call	2027698 <tcp_wakeup>
   return (error);
 202e090:	e0bff617 	ldw	r2,-40(fp)
}
 202e094:	e037883a 	mov	sp,fp
 202e098:	dfc00117 	ldw	ra,4(sp)
 202e09c:	df000017 	ldw	fp,0(sp)
 202e0a0:	dec00204 	addi	sp,sp,8
 202e0a4:	f800283a 	ret

0202e0a8 <soshutdown>:
 *
 * RETURNS: int               0 if successful, else error code
 */
int
soshutdown(struct socket *so, int how)
{
 202e0a8:	defffc04 	addi	sp,sp,-16
 202e0ac:	dfc00315 	stw	ra,12(sp)
 202e0b0:	df000215 	stw	fp,8(sp)
 202e0b4:	df000204 	addi	fp,sp,8
 202e0b8:	e13ffe15 	stw	r4,-8(fp)
 202e0bc:	e17fff15 	stw	r5,-4(fp)
   how++;   /* convert 0,1,2 into 1,2,3 */
 202e0c0:	e0bfff17 	ldw	r2,-4(fp)
 202e0c4:	10800044 	addi	r2,r2,1
 202e0c8:	e0bfff15 	stw	r2,-4(fp)
   if (how & 1)   /* caller wanted READ or BOTH */
 202e0cc:	e0bfff17 	ldw	r2,-4(fp)
 202e0d0:	1080004c 	andi	r2,r2,1
 202e0d4:	10000226 	beq	r2,zero,202e0e0 <soshutdown+0x38>
      sorflush(so);
 202e0d8:	e13ffe17 	ldw	r4,-8(fp)
 202e0dc:	202e1400 	call	202e140 <sorflush>

   if (how & 2)   /* caller wanted WRITE or BOTH */
 202e0e0:	e0bfff17 	ldw	r2,-4(fp)
 202e0e4:	1080008c 	andi	r2,r2,2
 202e0e8:	10000f26 	beq	r2,zero,202e128 <soshutdown+0x80>
   {
      sbflush(&so->so_snd); /* flush the socket send queue */
 202e0ec:	e0bffe17 	ldw	r2,-8(fp)
 202e0f0:	10801204 	addi	r2,r2,72
 202e0f4:	1009883a 	mov	r4,r2
 202e0f8:	202fa0c0 	call	202fa0c <sbflush>
      so->so_req = PRU_SHUTDOWN;
 202e0fc:	e0bffe17 	ldw	r2,-8(fp)
 202e100:	00c001c4 	movi	r3,7
 202e104:	10c00715 	stw	r3,28(r2)
      return ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0));
 202e108:	e0bffe17 	ldw	r2,-8(fp)
 202e10c:	10800217 	ldw	r2,8(r2)
 202e110:	10800317 	ldw	r2,12(r2)
 202e114:	e13ffe17 	ldw	r4,-8(fp)
 202e118:	000b883a 	mov	r5,zero
 202e11c:	000d883a 	mov	r6,zero
 202e120:	103ee83a 	callr	r2
 202e124:	00000106 	br	202e12c <soshutdown+0x84>
   }

   return 0;
 202e128:	0005883a 	mov	r2,zero
}
 202e12c:	e037883a 	mov	sp,fp
 202e130:	dfc00117 	ldw	ra,4(sp)
 202e134:	df000017 	ldw	fp,0(sp)
 202e138:	dec00204 	addi	sp,sp,8
 202e13c:	f800283a 	ret

0202e140 <sorflush>:
 * socket receive buffer is discarded. Wakeup any processes waiting
 * on the socket.
 */
void
sorflush(struct socket * so)
{
 202e140:	defffb04 	addi	sp,sp,-20
 202e144:	dfc00415 	stw	ra,16(sp)
 202e148:	df000315 	stw	fp,12(sp)
 202e14c:	df000304 	addi	fp,sp,12
 202e150:	e13fff15 	stw	r4,-4(fp)
   struct sockbuf *sb =  &so->so_rcv;
 202e154:	e0bfff17 	ldw	r2,-4(fp)
 202e158:	10800a04 	addi	r2,r2,40
 202e15c:	e0bffd15 	stw	r2,-12(fp)
   int   s;

   sblock(sb);
 202e160:	00000406 	br	202e174 <sorflush+0x34>
 202e164:	e0bffd17 	ldw	r2,-12(fp)
 202e168:	10800704 	addi	r2,r2,28
 202e16c:	1009883a 	mov	r4,r2
 202e170:	20274f40 	call	20274f4 <tcp_sleep>
 202e174:	e0bffd17 	ldw	r2,-12(fp)
 202e178:	1080070b 	ldhu	r2,28(r2)
 202e17c:	10bfffcc 	andi	r2,r2,65535
 202e180:	1080004c 	andi	r2,r2,1
 202e184:	103ff71e 	bne	r2,zero,202e164 <sorflush+0x24>
 202e188:	e0bffd17 	ldw	r2,-12(fp)
 202e18c:	1080070b 	ldhu	r2,28(r2)
 202e190:	10800054 	ori	r2,r2,1
 202e194:	1007883a 	mov	r3,r2
 202e198:	e0bffd17 	ldw	r2,-12(fp)
 202e19c:	10c0070d 	sth	r3,28(r2)
   socantrcvmore(so);
 202e1a0:	e13fff17 	ldw	r4,-4(fp)
 202e1a4:	202f23c0 	call	202f23c <socantrcvmore>
   sbunlock(sb);
 202e1a8:	e0bffd17 	ldw	r2,-12(fp)
 202e1ac:	10c0070b 	ldhu	r3,28(r2)
 202e1b0:	00bfff84 	movi	r2,-2
 202e1b4:	1884703a 	and	r2,r3,r2
 202e1b8:	1007883a 	mov	r3,r2
 202e1bc:	e0bffd17 	ldw	r2,-12(fp)
 202e1c0:	10c0070d 	sth	r3,28(r2)
 202e1c4:	e0bffd17 	ldw	r2,-12(fp)
 202e1c8:	10800704 	addi	r2,r2,28
 202e1cc:	1009883a 	mov	r4,r2
 202e1d0:	20276980 	call	2027698 <tcp_wakeup>
   sbrelease(sb);
 202e1d4:	e13ffd17 	ldw	r4,-12(fp)
 202e1d8:	202f49c0 	call	202f49c <sbrelease>
   MEMSET((char *)sb, 0, sizeof (*sb));
 202e1dc:	e13ffd17 	ldw	r4,-12(fp)
 202e1e0:	000b883a 	mov	r5,zero
 202e1e4:	01800804 	movi	r6,32
 202e1e8:	200682c0 	call	200682c <memset>
   s = so->so_error;
 202e1ec:	e0bfff17 	ldw	r2,-4(fp)
 202e1f0:	10800617 	ldw	r2,24(r2)
 202e1f4:	e0bffe15 	stw	r2,-8(fp)
   so->so_error = ESHUTDOWN;
 202e1f8:	e0bfff17 	ldw	r2,-4(fp)
 202e1fc:	00c01b84 	movi	r3,110
 202e200:	10c00615 	stw	r3,24(r2)
   sorwakeup(so);
 202e204:	e0bfff17 	ldw	r2,-4(fp)
 202e208:	10800a04 	addi	r2,r2,40
 202e20c:	e13fff17 	ldw	r4,-4(fp)
 202e210:	100b883a 	mov	r5,r2
 202e214:	202f3300 	call	202f330 <sbwakeup>
   so->so_error = s;
 202e218:	e0bfff17 	ldw	r2,-4(fp)
 202e21c:	e0fffe17 	ldw	r3,-8(fp)
 202e220:	10c00615 	stw	r3,24(r2)
}
 202e224:	e037883a 	mov	sp,fp
 202e228:	dfc00117 	ldw	ra,4(sp)
 202e22c:	df000017 	ldw	fp,0(sp)
 202e230:	dec00204 	addi	sp,sp,8
 202e234:	f800283a 	ret

0202e238 <sosetopt>:

int
sosetopt(struct socket * so, 
   int   optname,
   void *   arg)
{
 202e238:	defff604 	addi	sp,sp,-40
 202e23c:	dfc00915 	stw	ra,36(sp)
 202e240:	df000815 	stw	fp,32(sp)
 202e244:	df000804 	addi	fp,sp,32
 202e248:	e13ffd15 	stw	r4,-12(fp)
 202e24c:	e17ffe15 	stw	r5,-8(fp)
 202e250:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 202e254:	e03ff815 	stw	zero,-32(fp)

   switch (optname) 
 202e258:	e0bffe17 	ldw	r2,-8(fp)
 202e25c:	10c08020 	cmpeqi	r3,r2,512
 202e260:	18003b1e 	bne	r3,zero,202e350 <sosetopt+0x118>
 202e264:	10c08048 	cmpgei	r3,r2,513
 202e268:	1800171e 	bne	r3,zero,202e2c8 <sosetopt+0x90>
 202e26c:	10c00388 	cmpgei	r3,r2,14
 202e270:	1800091e 	bne	r3,zero,202e298 <sosetopt+0x60>
 202e274:	10c00248 	cmpgei	r3,r2,9
 202e278:	1800831e 	bne	r3,zero,202e488 <sosetopt+0x250>
 202e27c:	10c00120 	cmpeqi	r3,r2,4
 202e280:	1800331e 	bne	r3,zero,202e350 <sosetopt+0x118>
 202e284:	10c00220 	cmpeqi	r3,r2,8
 202e288:	1800311e 	bne	r3,zero,202e350 <sosetopt+0x118>
 202e28c:	108000a0 	cmpeqi	r2,r2,2
 202e290:	1000831e 	bne	r2,zero,202e4a0 <sosetopt+0x268>
 202e294:	0000ea06 	br	202e640 <sosetopt+0x408>
 202e298:	10c00820 	cmpeqi	r3,r2,32
 202e29c:	18002c1e 	bne	r3,zero,202e350 <sosetopt+0x118>
 202e2a0:	10c00848 	cmpgei	r3,r2,33
 202e2a4:	1800031e 	bne	r3,zero,202e2b4 <sosetopt+0x7c>
 202e2a8:	10800420 	cmpeqi	r2,r2,16
 202e2ac:	1000281e 	bne	r2,zero,202e350 <sosetopt+0x118>
 202e2b0:	0000e306 	br	202e640 <sosetopt+0x408>
 202e2b4:	10c02020 	cmpeqi	r3,r2,128
 202e2b8:	1800201e 	bne	r3,zero,202e33c <sosetopt+0x104>
 202e2bc:	10804020 	cmpeqi	r2,r2,256
 202e2c0:	1000231e 	bne	r2,zero,202e350 <sosetopt+0x118>
 202e2c4:	0000de06 	br	202e640 <sosetopt+0x408>
 202e2c8:	10c40520 	cmpeqi	r3,r2,4116
 202e2cc:	1800481e 	bne	r3,zero,202e3f0 <sosetopt+0x1b8>
 202e2d0:	10c40548 	cmpgei	r3,r2,4117
 202e2d4:	18000b1e 	bne	r3,zero,202e304 <sosetopt+0xcc>
 202e2d8:	10c401a0 	cmpeqi	r3,r2,4102
 202e2dc:	18003f1e 	bne	r3,zero,202e3dc <sosetopt+0x1a4>
 202e2e0:	10c401c8 	cmpgei	r3,r2,4103
 202e2e4:	1800041e 	bne	r3,zero,202e2f8 <sosetopt+0xc0>
 202e2e8:	10bbffc4 	addi	r2,r2,-4097
 202e2ec:	108000a8 	cmpgeui	r2,r2,2
 202e2f0:	1000d31e 	bne	r2,zero,202e640 <sosetopt+0x408>
 202e2f4:	00002806 	br	202e398 <sosetopt+0x160>
 202e2f8:	10840420 	cmpeqi	r2,r2,4112
 202e2fc:	1000a91e 	bne	r2,zero,202e5a4 <sosetopt+0x36c>
 202e300:	0000cf06 	br	202e640 <sosetopt+0x408>
 202e304:	10c800e0 	cmpeqi	r3,r2,8195
 202e308:	1800a61e 	bne	r3,zero,202e5a4 <sosetopt+0x36c>
 202e30c:	10c80108 	cmpgei	r3,r2,8196
 202e310:	1800051e 	bne	r3,zero,202e328 <sosetopt+0xf0>
 202e314:	10c40560 	cmpeqi	r3,r2,4117
 202e318:	18003c1e 	bne	r3,zero,202e40c <sosetopt+0x1d4>
 202e31c:	108405a0 	cmpeqi	r2,r2,4118
 202e320:	1000421e 	bne	r2,zero,202e42c <sosetopt+0x1f4>
 202e324:	0000c606 	br	202e640 <sosetopt+0x408>
 202e328:	10c80120 	cmpeqi	r3,r2,8196
 202e32c:	1800711e 	bne	r3,zero,202e4f4 <sosetopt+0x2bc>
 202e330:	10900020 	cmpeqi	r2,r2,16384
 202e334:	1000061e 	bne	r2,zero,202e350 <sosetopt+0x118>
 202e338:	0000c106 	br	202e640 <sosetopt+0x408>
   {
   case SO_LINGER:
      so->so_linger = (short)((struct linger *)arg)->l_linger;
 202e33c:	e0bfff17 	ldw	r2,-4(fp)
 202e340:	10800117 	ldw	r2,4(r2)
 202e344:	1007883a 	mov	r3,r2
 202e348:	e0bffd17 	ldw	r2,-12(fp)
 202e34c:	10c0080d 	sth	r3,32(r2)
   case SO_TCPSACK:
   case SO_NOSLOWSTART:
#ifdef SUPPORT_SO_FULLMSS
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
 202e350:	e0bfff17 	ldw	r2,-4(fp)
 202e354:	10800017 	ldw	r2,0(r2)
 202e358:	10000726 	beq	r2,zero,202e378 <sosetopt+0x140>
         so->so_options |= optname;
 202e35c:	e0bffd17 	ldw	r2,-12(fp)
 202e360:	10c00417 	ldw	r3,16(r2)
 202e364:	e0bffe17 	ldw	r2,-8(fp)
 202e368:	1886b03a 	or	r3,r3,r2
 202e36c:	e0bffd17 	ldw	r2,-12(fp)
 202e370:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~optname;
      break;
 202e374:	0000b606 	br	202e650 <sosetopt+0x418>
   case SO_FULLMSS:
#endif
      if (*(int *)arg) 
         so->so_options |= optname;
      else
         so->so_options &= ~optname;
 202e378:	e0bffd17 	ldw	r2,-12(fp)
 202e37c:	10c00417 	ldw	r3,16(r2)
 202e380:	e0bffe17 	ldw	r2,-8(fp)
 202e384:	0084303a 	nor	r2,zero,r2
 202e388:	1886703a 	and	r3,r3,r2
 202e38c:	e0bffd17 	ldw	r2,-12(fp)
 202e390:	10c00415 	stw	r3,16(r2)
      break;
 202e394:	0000ae06 	br	202e650 <sosetopt+0x418>
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 202e398:	e0bffe17 	ldw	r2,-8(fp)
 202e39c:	10840058 	cmpnei	r2,r2,4097
 202e3a0:	1000031e 	bne	r2,zero,202e3b0 <sosetopt+0x178>
 202e3a4:	e0bffd17 	ldw	r2,-12(fp)
 202e3a8:	10801204 	addi	r2,r2,72
 202e3ac:	00000206 	br	202e3b8 <sosetopt+0x180>
 202e3b0:	e0bffd17 	ldw	r2,-12(fp)
 202e3b4:	10800a04 	addi	r2,r2,40
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
 202e3b8:	e0ffff17 	ldw	r3,-4(fp)
 202e3bc:	18c00017 	ldw	r3,0(r3)
      break;
#endif /* TCP_BIGCWND */

   case SO_SNDBUF:
   case SO_RCVBUF:
      if (sbreserve(optname == SO_SNDBUF ?
 202e3c0:	1009883a 	mov	r4,r2
 202e3c4:	180b883a 	mov	r5,r3
 202e3c8:	202f44c0 	call	202f44c <sbreserve>
 202e3cc:	10009f1e 	bne	r2,zero,202e64c <sosetopt+0x414>
          &so->so_snd : &so->so_rcv,
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
 202e3d0:	00801a44 	movi	r2,105
 202e3d4:	e0bff815 	stw	r2,-32(fp)
         goto bad;
 202e3d8:	00009d06 	br	202e650 <sosetopt+0x418>
      }
      break;

   case SO_RCVTIMEO:
      so->so_rcv.sb_timeo = *(short *)arg;
 202e3dc:	e0bfff17 	ldw	r2,-4(fp)
 202e3e0:	10c0000b 	ldhu	r3,0(r2)
 202e3e4:	e0bffd17 	ldw	r2,-12(fp)
 202e3e8:	10c0118d 	sth	r3,70(r2)
      break;
 202e3ec:	00009806 	br	202e650 <sosetopt+0x418>

   case SO_NBIO:     /* set socket into NON-blocking mode */
      so->so_state |= SS_NBIO;
 202e3f0:	e0bffd17 	ldw	r2,-12(fp)
 202e3f4:	1080088b 	ldhu	r2,34(r2)
 202e3f8:	10804014 	ori	r2,r2,256
 202e3fc:	1007883a 	mov	r3,r2
 202e400:	e0bffd17 	ldw	r2,-12(fp)
 202e404:	10c0088d 	sth	r3,34(r2)
      break;
 202e408:	00009106 	br	202e650 <sosetopt+0x418>

   case SO_BIO:   /* set socket into blocking mode */
      so->so_state &= ~SS_NBIO;
 202e40c:	e0bffd17 	ldw	r2,-12(fp)
 202e410:	10c0088b 	ldhu	r3,34(r2)
 202e414:	00bfbfc4 	movi	r2,-257
 202e418:	1884703a 	and	r2,r3,r2
 202e41c:	1007883a 	mov	r3,r2
 202e420:	e0bffd17 	ldw	r2,-12(fp)
 202e424:	10c0088d 	sth	r3,34(r2)
      break;
 202e428:	00008906 	br	202e650 <sosetopt+0x418>

   case SO_NONBLOCK:    /* set blocking mode according to arg */
      /* sanity check the arg parameter */
      if (!arg)
 202e42c:	e0bfff17 	ldw	r2,-4(fp)
 202e430:	1000031e 	bne	r2,zero,202e440 <sosetopt+0x208>
      {
         error = ENP_PARAM;
 202e434:	00bffd84 	movi	r2,-10
 202e438:	e0bff815 	stw	r2,-32(fp)
         break;
 202e43c:	00008406 	br	202e650 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 202e440:	e0bfff17 	ldw	r2,-4(fp)
 202e444:	10800017 	ldw	r2,0(r2)
 202e448:	10000726 	beq	r2,zero,202e468 <sosetopt+0x230>
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
 202e44c:	e0bffd17 	ldw	r2,-12(fp)
 202e450:	1080088b 	ldhu	r2,34(r2)
 202e454:	10804014 	ori	r2,r2,256
 202e458:	1007883a 	mov	r3,r2
 202e45c:	e0bffd17 	ldw	r2,-12(fp)
 202e460:	10c0088d 	sth	r3,34(r2)
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
      break;
 202e464:	00007a06 	br	202e650 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         so->so_state |= SS_NBIO;   /* set non-blocking mode */
      else
         so->so_state &= ~SS_NBIO;  /* set blocking mode */
 202e468:	e0bffd17 	ldw	r2,-12(fp)
 202e46c:	10c0088b 	ldhu	r3,34(r2)
 202e470:	00bfbfc4 	movi	r2,-257
 202e474:	1884703a 	and	r2,r3,r2
 202e478:	1007883a 	mov	r3,r2
 202e47c:	e0bffd17 	ldw	r2,-12(fp)
 202e480:	10c0088d 	sth	r3,34(r2)
      break;
 202e484:	00007206 	br	202e650 <sosetopt+0x418>
   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
   case IP_ADD_MEMBERSHIP:
   case IP_DROP_MEMBERSHIP:
      error = ip_setmoptions(optname, so, arg);
 202e488:	e13ffe17 	ldw	r4,-8(fp)
 202e48c:	e17ffd17 	ldw	r5,-12(fp)
 202e490:	e1bfff17 	ldw	r6,-4(fp)
 202e494:	20466cc0 	call	20466cc <ip_setmoptions>
 202e498:	e0bff815 	stw	r2,-32(fp)
      break;
 202e49c:	00006c06 	br	202e650 <sosetopt+0x418>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 202e4a0:	e0bfff17 	ldw	r2,-4(fp)
 202e4a4:	1000031e 	bne	r2,zero,202e4b4 <sosetopt+0x27c>
      {
         error = ENP_PARAM;
 202e4a8:	00bffd84 	movi	r2,-10
 202e4ac:	e0bff815 	stw	r2,-32(fp)
         break;
 202e4b0:	00006706 	br	202e650 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
 202e4b4:	e0bfff17 	ldw	r2,-4(fp)
 202e4b8:	10800017 	ldw	r2,0(r2)
 202e4bc:	10000626 	beq	r2,zero,202e4d8 <sosetopt+0x2a0>
         so->so_options |= SO_HDRINCL;
 202e4c0:	e0bffd17 	ldw	r2,-12(fp)
 202e4c4:	10800417 	ldw	r2,16(r2)
 202e4c8:	10c80014 	ori	r3,r2,8192
 202e4cc:	e0bffd17 	ldw	r2,-12(fp)
 202e4d0:	10c00415 	stw	r3,16(r2)
      else
         so->so_options &= ~SO_HDRINCL;
      break;
 202e4d4:	00005e06 	br	202e650 <sosetopt+0x418>
      }
      /* set the socket option flag based on the pointed-to argument */
      if (*(int *)arg)
         so->so_options |= SO_HDRINCL;
      else
         so->so_options &= ~SO_HDRINCL;
 202e4d8:	e0bffd17 	ldw	r2,-12(fp)
 202e4dc:	10c00417 	ldw	r3,16(r2)
 202e4e0:	00b7ffc4 	movi	r2,-8193
 202e4e4:	1886703a 	and	r3,r3,r2
 202e4e8:	e0bffd17 	ldw	r2,-12(fp)
 202e4ec:	10c00415 	stw	r3,16(r2)
      break;
 202e4f0:	00005706 	br	202e650 <sosetopt+0x418>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 202e4f4:	e0bffd17 	ldw	r2,-12(fp)
 202e4f8:	10800983 	ldbu	r2,38(r2)
 202e4fc:	10803fcc 	andi	r2,r2,255
 202e500:	1080201c 	xori	r2,r2,128
 202e504:	10bfe004 	addi	r2,r2,-128
 202e508:	10800060 	cmpeqi	r2,r2,1
 202e50c:	1000031e 	bne	r2,zero,202e51c <sosetopt+0x2e4>
      {
         error = EINVAL;
 202e510:	00800584 	movi	r2,22
 202e514:	e0bff815 	stw	r2,-32(fp)
         break;
 202e518:	00004d06 	br	202e650 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 202e51c:	e0bffd17 	ldw	r2,-12(fp)
 202e520:	10800117 	ldw	r2,4(r2)
 202e524:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 202e528:	e0bff917 	ldw	r2,-28(fp)
 202e52c:	10800917 	ldw	r2,36(r2)
 202e530:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 202e534:	e0bffa17 	ldw	r2,-24(fp)
 202e538:	1000031e 	bne	r2,zero,202e548 <sosetopt+0x310>
      {
         error = ENOTCONN;
 202e53c:	00802004 	movi	r2,128
 202e540:	e0bff815 	stw	r2,-32(fp)
         break;
 202e544:	00004206 	br	202e650 <sosetopt+0x418>
      }
      /* try to make sure that the argument pointer is valid */
      if (arg == NULL)
 202e548:	e0bfff17 	ldw	r2,-4(fp)
 202e54c:	1000031e 	bne	r2,zero,202e55c <sosetopt+0x324>
      {
         error = ENP_PARAM;
 202e550:	00bffd84 	movi	r2,-10
 202e554:	e0bff815 	stw	r2,-32(fp)
         break;
 202e558:	00003d06 	br	202e650 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
 202e55c:	e0bfff17 	ldw	r2,-4(fp)
 202e560:	10800017 	ldw	r2,0(r2)
 202e564:	10000726 	beq	r2,zero,202e584 <sosetopt+0x34c>
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
 202e568:	e0bffa17 	ldw	r2,-24(fp)
 202e56c:	10800b0b 	ldhu	r2,44(r2)
 202e570:	10800114 	ori	r2,r2,4
 202e574:	1007883a 	mov	r3,r2
 202e578:	e0bffa17 	ldw	r2,-24(fp)
 202e57c:	10c00b0d 	sth	r3,44(r2)
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */

      break;
 202e580:	00003306 	br	202e650 <sosetopt+0x418>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (*(int *) arg)
         tp->t_flags |= TF_NODELAY;   /* Disable Nagle Algorithm */
      else
         tp->t_flags &= ~TF_NODELAY;  /* Enable Nagle Algorithm */
 202e584:	e0bffa17 	ldw	r2,-24(fp)
 202e588:	10c00b0b 	ldhu	r3,44(r2)
 202e58c:	00bffec4 	movi	r2,-5
 202e590:	1884703a 	and	r2,r3,r2
 202e594:	1007883a 	mov	r3,r2
 202e598:	e0bffa17 	ldw	r2,-24(fp)
 202e59c:	10c00b0d 	sth	r3,44(r2)

      break;
 202e5a0:	00002b06 	br	202e650 <sosetopt+0x418>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 202e5a4:	e0bffd17 	ldw	r2,-12(fp)
 202e5a8:	10800983 	ldbu	r2,38(r2)
 202e5ac:	10803fcc 	andi	r2,r2,255
 202e5b0:	1080201c 	xori	r2,r2,128
 202e5b4:	10bfe004 	addi	r2,r2,-128
 202e5b8:	10800060 	cmpeqi	r2,r2,1
 202e5bc:	1000031e 	bne	r2,zero,202e5cc <sosetopt+0x394>
      {
         error = EINVAL;
 202e5c0:	00800584 	movi	r2,22
 202e5c4:	e0bff815 	stw	r2,-32(fp)
         break;
 202e5c8:	00002106 	br	202e650 <sosetopt+0x418>
      }
      inp = (struct inpcb *)(so->so_pcb);
 202e5cc:	e0bffd17 	ldw	r2,-12(fp)
 202e5d0:	10800117 	ldw	r2,4(r2)
 202e5d4:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 202e5d8:	e0bffb17 	ldw	r2,-20(fp)
 202e5dc:	10800917 	ldw	r2,36(r2)
 202e5e0:	e0bffc15 	stw	r2,-16(fp)
      if(!tp)
 202e5e4:	e0bffc17 	ldw	r2,-16(fp)
 202e5e8:	1000031e 	bne	r2,zero,202e5f8 <sosetopt+0x3c0>
      {
         error = ENOTCONN;
 202e5ec:	00802004 	movi	r2,128
 202e5f0:	e0bff815 	stw	r2,-32(fp)
         break;
 202e5f4:	00001606 	br	202e650 <sosetopt+0x418>
      }
      if (tp->t_state != TCPS_CLOSED)
 202e5f8:	e0bffc17 	ldw	r2,-16(fp)
 202e5fc:	10800217 	ldw	r2,8(r2)
 202e600:	10000326 	beq	r2,zero,202e610 <sosetopt+0x3d8>
      {
         error = EINVAL;
 202e604:	00800584 	movi	r2,22
 202e608:	e0bff815 	stw	r2,-32(fp)
         break;
 202e60c:	00001006 	br	202e650 <sosetopt+0x418>
      }
      tp->t_maxseg = *(int*)(arg);    /* set TCP MSS */
 202e610:	e0bfff17 	ldw	r2,-4(fp)
 202e614:	10800017 	ldw	r2,0(r2)
 202e618:	1007883a 	mov	r3,r2
 202e61c:	e0bffc17 	ldw	r2,-16(fp)
 202e620:	10c00a0d 	sth	r3,40(r2)
      tp->t_flags |= TF_MAXSEG;   /* mark as user set max seg */
 202e624:	e0bffc17 	ldw	r2,-16(fp)
 202e628:	10800b0b 	ldhu	r2,44(r2)
 202e62c:	10810014 	ori	r2,r2,1024
 202e630:	1007883a 	mov	r3,r2
 202e634:	e0bffc17 	ldw	r2,-16(fp)
 202e638:	10c00b0d 	sth	r3,44(r2)
      break;
 202e63c:	00000406 	br	202e650 <sosetopt+0x418>
   }
   default:
      error = ENOPROTOOPT;
 202e640:	00801b44 	movi	r2,109
 202e644:	e0bff815 	stw	r2,-32(fp)
      break;
 202e648:	00000106 	br	202e650 <sosetopt+0x418>
          (u_long) * (int *)arg) == 0) 
      {
         error = ENOBUFS;
         goto bad;
      }
      break;
 202e64c:	0001883a 	nop
   default:
      error = ENOPROTOOPT;
      break;
   }
bad:
   return (error);
 202e650:	e0bff817 	ldw	r2,-32(fp)
}
 202e654:	e037883a 	mov	sp,fp
 202e658:	dfc00117 	ldw	ra,4(sp)
 202e65c:	df000017 	ldw	fp,0(sp)
 202e660:	dec00204 	addi	sp,sp,8
 202e664:	f800283a 	ret

0202e668 <sogetopt>:

int
sogetopt(struct socket * so, 
   int   optname,
   void *   val)
{
 202e668:	defff504 	addi	sp,sp,-44
 202e66c:	dfc00a15 	stw	ra,40(sp)
 202e670:	df000915 	stw	fp,36(sp)
 202e674:	df000904 	addi	fp,sp,36
 202e678:	e13ffd15 	stw	r4,-12(fp)
 202e67c:	e17ffe15 	stw	r5,-8(fp)
 202e680:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 202e684:	e03ff715 	stw	zero,-36(fp)

   /* sanity check the val parameter */
   if (!val)
 202e688:	e0bfff17 	ldw	r2,-4(fp)
 202e68c:	1000021e 	bne	r2,zero,202e698 <sogetopt+0x30>
   {
      return ENP_PARAM;
 202e690:	00bffd84 	movi	r2,-10
 202e694:	00011906 	br	202eafc <sogetopt+0x494>
   }

   switch (optname) 
 202e698:	e0bffe17 	ldw	r2,-8(fp)
 202e69c:	10c400e0 	cmpeqi	r3,r2,4099
 202e6a0:	1800701e 	bne	r3,zero,202e864 <sogetopt+0x1fc>
 202e6a4:	10c40108 	cmpgei	r3,r2,4100
 202e6a8:	1800201e 	bne	r3,zero,202e72c <sogetopt+0xc4>
 202e6ac:	10c00420 	cmpeqi	r3,r2,16
 202e6b0:	1800641e 	bne	r3,zero,202e844 <sogetopt+0x1dc>
 202e6b4:	10c00448 	cmpgei	r3,r2,17
 202e6b8:	18000c1e 	bne	r3,zero,202e6ec <sogetopt+0x84>
 202e6bc:	10c00220 	cmpeqi	r3,r2,8
 202e6c0:	1800601e 	bne	r3,zero,202e844 <sogetopt+0x1dc>
 202e6c4:	10c00248 	cmpgei	r3,r2,9
 202e6c8:	1800051e 	bne	r3,zero,202e6e0 <sogetopt+0x78>
 202e6cc:	10c000a0 	cmpeqi	r3,r2,2
 202e6d0:	1800d61e 	bne	r3,zero,202ea2c <sogetopt+0x3c4>
 202e6d4:	10800120 	cmpeqi	r2,r2,4
 202e6d8:	10005a1e 	bne	r2,zero,202e844 <sogetopt+0x1dc>
 202e6dc:	00010406 	br	202eaf0 <sogetopt+0x488>
 202e6e0:	10800308 	cmpgei	r2,r2,12
 202e6e4:	1001021e 	bne	r2,zero,202eaf0 <sogetopt+0x488>
 202e6e8:	0000ca06 	br	202ea14 <sogetopt+0x3ac>
 202e6ec:	10c04020 	cmpeqi	r3,r2,256
 202e6f0:	1800541e 	bne	r3,zero,202e844 <sogetopt+0x1dc>
 202e6f4:	10c04048 	cmpgei	r3,r2,257
 202e6f8:	1800051e 	bne	r3,zero,202e710 <sogetopt+0xa8>
 202e6fc:	10c00820 	cmpeqi	r3,r2,32
 202e700:	1800501e 	bne	r3,zero,202e844 <sogetopt+0x1dc>
 202e704:	10802020 	cmpeqi	r2,r2,128
 202e708:	10003f1e 	bne	r2,zero,202e808 <sogetopt+0x1a0>
 202e70c:	0000f806 	br	202eaf0 <sogetopt+0x488>
 202e710:	10c40060 	cmpeqi	r3,r2,4097
 202e714:	18005f1e 	bne	r3,zero,202e894 <sogetopt+0x22c>
 202e718:	10c40088 	cmpgei	r3,r2,4098
 202e71c:	1800631e 	bne	r3,zero,202e8ac <sogetopt+0x244>
 202e720:	10808020 	cmpeqi	r2,r2,512
 202e724:	1000471e 	bne	r2,zero,202e844 <sogetopt+0x1dc>
 202e728:	0000f106 	br	202eaf0 <sogetopt+0x488>
 202e72c:	10c40420 	cmpeqi	r3,r2,4112
 202e730:	18007f1e 	bne	r3,zero,202e930 <sogetopt+0x2c8>
 202e734:	10c40448 	cmpgei	r3,r2,4113
 202e738:	1800101e 	bne	r3,zero,202e77c <sogetopt+0x114>
 202e73c:	10c401a0 	cmpeqi	r3,r2,4102
 202e740:	18009b1e 	bne	r3,zero,202e9b0 <sogetopt+0x348>
 202e744:	10c401c8 	cmpgei	r3,r2,4103
 202e748:	1800051e 	bne	r3,zero,202e760 <sogetopt+0xf8>
 202e74c:	10c40120 	cmpeqi	r3,r2,4100
 202e750:	18004a1e 	bne	r3,zero,202e87c <sogetopt+0x214>
 202e754:	10840160 	cmpeqi	r2,r2,4101
 202e758:	1000901e 	bne	r2,zero,202e99c <sogetopt+0x334>
 202e75c:	0000e406 	br	202eaf0 <sogetopt+0x488>
 202e760:	10c40220 	cmpeqi	r3,r2,4104
 202e764:	1800631e 	bne	r3,zero,202e8f4 <sogetopt+0x28c>
 202e768:	10c40210 	cmplti	r3,r2,4104
 202e76c:	1800691e 	bne	r3,zero,202e914 <sogetopt+0x2ac>
 202e770:	10840260 	cmpeqi	r2,r2,4105
 202e774:	1000931e 	bne	r2,zero,202e9c4 <sogetopt+0x35c>
 202e778:	0000dd06 	br	202eaf0 <sogetopt+0x488>
 202e77c:	10c404e0 	cmpeqi	r3,r2,4115
 202e780:	18000e1e 	bne	r3,zero,202e7bc <sogetopt+0x154>
 202e784:	10c40508 	cmpgei	r3,r2,4116
 202e788:	1800051e 	bne	r3,zero,202e7a0 <sogetopt+0x138>
 202e78c:	10c40460 	cmpeqi	r3,r2,4113
 202e790:	18004c1e 	bne	r3,zero,202e8c4 <sogetopt+0x25c>
 202e794:	108404a0 	cmpeqi	r2,r2,4114
 202e798:	1000501e 	bne	r2,zero,202e8dc <sogetopt+0x274>
 202e79c:	0000d406 	br	202eaf0 <sogetopt+0x488>
 202e7a0:	10c800e0 	cmpeqi	r3,r2,8195
 202e7a4:	1800621e 	bne	r3,zero,202e930 <sogetopt+0x2c8>
 202e7a8:	10c80120 	cmpeqi	r3,r2,8196
 202e7ac:	1800aa1e 	bne	r3,zero,202ea58 <sogetopt+0x3f0>
 202e7b0:	108405a0 	cmpeqi	r2,r2,4118
 202e7b4:	10008b1e 	bne	r2,zero,202e9e4 <sogetopt+0x37c>
 202e7b8:	0000cd06 	br	202eaf0 <sogetopt+0x488>
   {
   case SO_MYADDR:
      /* Get my IP address. */
      if (so->so_state & SS_ISCONNECTED)
 202e7bc:	e0bffd17 	ldw	r2,-12(fp)
 202e7c0:	1080088b 	ldhu	r2,34(r2)
 202e7c4:	10bfffcc 	andi	r2,r2,65535
 202e7c8:	1080008c 	andi	r2,r2,2
 202e7cc:	10000726 	beq	r2,zero,202e7ec <sogetopt+0x184>
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
 202e7d0:	e0bffd17 	ldw	r2,-12(fp)
 202e7d4:	10800117 	ldw	r2,4(r2)
 202e7d8:	10800a17 	ldw	r2,40(r2)
 202e7dc:	10c00a17 	ldw	r3,40(r2)
 202e7e0:	e0bfff17 	ldw	r2,-4(fp)
 202e7e4:	10c00015 	stw	r3,0(r2)
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
      break;
 202e7e8:	0000c306 	br	202eaf8 <sogetopt+0x490>
      if (so->so_state & SS_ISCONNECTED)
      {
         *(u_long *)val = so->so_pcb->ifp->n_ipaddr;
      }
      else  /* not connected, use first iface */
         *(u_long *)val = nets[0]->n_ipaddr;
 202e7ec:	00809934 	movhi	r2,612
 202e7f0:	10b5c104 	addi	r2,r2,-10492
 202e7f4:	10800017 	ldw	r2,0(r2)
 202e7f8:	10c00a17 	ldw	r3,40(r2)
 202e7fc:	e0bfff17 	ldw	r2,-4(fp)
 202e800:	10c00015 	stw	r3,0(r2)
      break;
 202e804:	0000bc06 	br	202eaf8 <sogetopt+0x490>
   case SO_LINGER:
      {
         struct linger *   l  =  (struct  linger *)val;
 202e808:	e0bfff17 	ldw	r2,-4(fp)
 202e80c:	e0bff815 	stw	r2,-32(fp)
         l->l_onoff = so->so_options & SO_LINGER;
 202e810:	e0bffd17 	ldw	r2,-12(fp)
 202e814:	10800417 	ldw	r2,16(r2)
 202e818:	10c0200c 	andi	r3,r2,128
 202e81c:	e0bff817 	ldw	r2,-32(fp)
 202e820:	10c00015 	stw	r3,0(r2)
         l->l_linger = so->so_linger;
 202e824:	e0bffd17 	ldw	r2,-12(fp)
 202e828:	1080080b 	ldhu	r2,32(r2)
 202e82c:	10ffffcc 	andi	r3,r2,65535
 202e830:	18e0001c 	xori	r3,r3,32768
 202e834:	18e00004 	addi	r3,r3,-32768
 202e838:	e0bff817 	ldw	r2,-32(fp)
 202e83c:	10c00115 	stw	r3,4(r2)
      }
      break;
 202e840:	0000ad06 	br	202eaf8 <sogetopt+0x490>
   case SO_OOBINLINE:
   case SO_DONTROUTE:
   case SO_REUSEADDR:
   case SO_BROADCAST:
   case SO_TCPSACK:
      *(int *)val = so->so_options & optname;
 202e844:	e0bffd17 	ldw	r2,-12(fp)
 202e848:	10c00417 	ldw	r3,16(r2)
 202e84c:	e0bffe17 	ldw	r2,-8(fp)
 202e850:	1884703a 	and	r2,r3,r2
 202e854:	1007883a 	mov	r3,r2
 202e858:	e0bfff17 	ldw	r2,-4(fp)
 202e85c:	10c00015 	stw	r3,0(r2)
      break;
 202e860:	0000a506 	br	202eaf8 <sogetopt+0x490>

   case SO_SNDLOWAT:
      *(int *)val = (int)so->so_snd.sb_lowat;
 202e864:	e0bffd17 	ldw	r2,-12(fp)
 202e868:	10801617 	ldw	r2,88(r2)
 202e86c:	1007883a 	mov	r3,r2
 202e870:	e0bfff17 	ldw	r2,-4(fp)
 202e874:	10c00015 	stw	r3,0(r2)
      break;
 202e878:	00009f06 	br	202eaf8 <sogetopt+0x490>

   case SO_RCVLOWAT:
      *(int *)val = (int)so->so_rcv.sb_lowat;
 202e87c:	e0bffd17 	ldw	r2,-12(fp)
 202e880:	10800e17 	ldw	r2,56(r2)
 202e884:	1007883a 	mov	r3,r2
 202e888:	e0bfff17 	ldw	r2,-4(fp)
 202e88c:	10c00015 	stw	r3,0(r2)
      break;
 202e890:	00009906 	br	202eaf8 <sogetopt+0x490>

   case SO_SNDBUF:
      *(int *)val = (int)so->so_snd.sb_hiwat;
 202e894:	e0bffd17 	ldw	r2,-12(fp)
 202e898:	10801317 	ldw	r2,76(r2)
 202e89c:	1007883a 	mov	r3,r2
 202e8a0:	e0bfff17 	ldw	r2,-4(fp)
 202e8a4:	10c00015 	stw	r3,0(r2)
      break;
 202e8a8:	00009306 	br	202eaf8 <sogetopt+0x490>

   case SO_RCVBUF:
      *(int *)val = (int)so->so_rcv.sb_hiwat;
 202e8ac:	e0bffd17 	ldw	r2,-12(fp)
 202e8b0:	10800b17 	ldw	r2,44(r2)
 202e8b4:	1007883a 	mov	r3,r2
 202e8b8:	e0bfff17 	ldw	r2,-4(fp)
 202e8bc:	10c00015 	stw	r3,0(r2)
      break;
 202e8c0:	00008d06 	br	202eaf8 <sogetopt+0x490>

   case SO_RXDATA:   /* added, JB */
      *(int *)val = (int)so->so_rcv.sb_cc;
 202e8c4:	e0bffd17 	ldw	r2,-12(fp)
 202e8c8:	10800a17 	ldw	r2,40(r2)
 202e8cc:	1007883a 	mov	r3,r2
 202e8d0:	e0bfff17 	ldw	r2,-4(fp)
 202e8d4:	10c00015 	stw	r3,0(r2)
      break;
 202e8d8:	00008706 	br	202eaf8 <sogetopt+0x490>

   case SO_TXDATA:   /* added for rel 1.8 */
      *(int *)val = (int)so->so_snd.sb_cc;
 202e8dc:	e0bffd17 	ldw	r2,-12(fp)
 202e8e0:	10801217 	ldw	r2,72(r2)
 202e8e4:	1007883a 	mov	r3,r2
 202e8e8:	e0bfff17 	ldw	r2,-4(fp)
 202e8ec:	10c00015 	stw	r3,0(r2)
      break;
 202e8f0:	00008106 	br	202eaf8 <sogetopt+0x490>

   case SO_TYPE:
      *(int *)val = so->so_type;
 202e8f4:	e0bffd17 	ldw	r2,-12(fp)
 202e8f8:	10800983 	ldbu	r2,38(r2)
 202e8fc:	10c03fcc 	andi	r3,r2,255
 202e900:	18c0201c 	xori	r3,r3,128
 202e904:	18ffe004 	addi	r3,r3,-128
 202e908:	e0bfff17 	ldw	r2,-4(fp)
 202e90c:	10c00015 	stw	r3,0(r2)
      break;
 202e910:	00007906 	br	202eaf8 <sogetopt+0x490>

   case SO_ERROR:
      *(int *)val = so->so_error;
 202e914:	e0bffd17 	ldw	r2,-12(fp)
 202e918:	10c00617 	ldw	r3,24(r2)
 202e91c:	e0bfff17 	ldw	r2,-4(fp)
 202e920:	10c00015 	stw	r3,0(r2)
      so->so_error = 0;
 202e924:	e0bffd17 	ldw	r2,-12(fp)
 202e928:	10000615 	stw	zero,24(r2)
      break;
 202e92c:	00007206 	br	202eaf8 <sogetopt+0x490>
   case TCP_MAXSEG:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 202e930:	e0bffd17 	ldw	r2,-12(fp)
 202e934:	10800983 	ldbu	r2,38(r2)
 202e938:	10803fcc 	andi	r2,r2,255
 202e93c:	1080201c 	xori	r2,r2,128
 202e940:	10bfe004 	addi	r2,r2,-128
 202e944:	10800060 	cmpeqi	r2,r2,1
 202e948:	1000031e 	bne	r2,zero,202e958 <sogetopt+0x2f0>
      {
         error = EINVAL;
 202e94c:	00800584 	movi	r2,22
 202e950:	e0bff715 	stw	r2,-36(fp)
         break;
 202e954:	00006806 	br	202eaf8 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 202e958:	e0bffd17 	ldw	r2,-12(fp)
 202e95c:	10800117 	ldw	r2,4(r2)
 202e960:	e0bff915 	stw	r2,-28(fp)
      tp = intotcpcb(inp);
 202e964:	e0bff917 	ldw	r2,-28(fp)
 202e968:	10800917 	ldw	r2,36(r2)
 202e96c:	e0bffa15 	stw	r2,-24(fp)
      if(!tp)
 202e970:	e0bffa17 	ldw	r2,-24(fp)
 202e974:	1000031e 	bne	r2,zero,202e984 <sogetopt+0x31c>
      {
         error = ENOTCONN;
 202e978:	00802004 	movi	r2,128
 202e97c:	e0bff715 	stw	r2,-36(fp)
         break;
 202e980:	00005d06 	br	202eaf8 <sogetopt+0x490>
      }
      *(int *)val = tp->t_maxseg;     /* Fill in TCP MSS for current socket */
 202e984:	e0bffa17 	ldw	r2,-24(fp)
 202e988:	10800a0b 	ldhu	r2,40(r2)
 202e98c:	10ffffcc 	andi	r3,r2,65535
 202e990:	e0bfff17 	ldw	r2,-4(fp)
 202e994:	10c00015 	stw	r3,0(r2)
      break;
 202e998:	00005706 	br	202eaf8 <sogetopt+0x490>
   }
 
   case SO_SNDTIMEO:
      *(short*)val = so->so_snd.sb_timeo;
 202e99c:	e0bffd17 	ldw	r2,-12(fp)
 202e9a0:	10c0198b 	ldhu	r3,102(r2)
 202e9a4:	e0bfff17 	ldw	r2,-4(fp)
 202e9a8:	10c0000d 	sth	r3,0(r2)
      break;
 202e9ac:	00005206 	br	202eaf8 <sogetopt+0x490>

   case SO_RCVTIMEO:
      *(short*)val = so->so_rcv.sb_timeo;
 202e9b0:	e0bffd17 	ldw	r2,-12(fp)
 202e9b4:	10c0118b 	ldhu	r3,70(r2)
 202e9b8:	e0bfff17 	ldw	r2,-4(fp)
 202e9bc:	10c0000d 	sth	r3,0(r2)
      break;
 202e9c0:	00004d06 	br	202eaf8 <sogetopt+0x490>

   case SO_HOPCNT:
      *(int *)val = so->so_hopcnt;
 202e9c4:	e0bffd17 	ldw	r2,-12(fp)
 202e9c8:	108009c3 	ldbu	r2,39(r2)
 202e9cc:	10c03fcc 	andi	r3,r2,255
 202e9d0:	18c0201c 	xori	r3,r3,128
 202e9d4:	18ffe004 	addi	r3,r3,-128
 202e9d8:	e0bfff17 	ldw	r2,-4(fp)
 202e9dc:	10c00015 	stw	r3,0(r2)
      break;
 202e9e0:	00004506 	br	202eaf8 <sogetopt+0x490>

   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
 202e9e4:	e0bffd17 	ldw	r2,-12(fp)
 202e9e8:	1080088b 	ldhu	r2,34(r2)
 202e9ec:	10bfffcc 	andi	r2,r2,65535
 202e9f0:	1080400c 	andi	r2,r2,256
 202e9f4:	10000426 	beq	r2,zero,202ea08 <sogetopt+0x3a0>
         *(int *)val = 1;   /* return 1 in val */
 202e9f8:	e0bfff17 	ldw	r2,-4(fp)
 202e9fc:	00c00044 	movi	r3,1
 202ea00:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;     /* return 0 in val */
      break;
 202ea04:	00003c06 	br	202eaf8 <sogetopt+0x490>
   case SO_NONBLOCK:    /* get blocking mode according to val */
      /* if the non-blocking I/O bit is set in the state */
      if (so->so_state & SS_NBIO)
         *(int *)val = 1;   /* return 1 in val */
      else
         *(int *)val = 0;     /* return 0 in val */
 202ea08:	e0bfff17 	ldw	r2,-4(fp)
 202ea0c:	10000015 	stw	zero,0(r2)
      break;
 202ea10:	00003906 	br	202eaf8 <sogetopt+0x490>
#ifdef IP_MULTICAST

   case IP_MULTICAST_IF:
   case IP_MULTICAST_TTL:
   case IP_MULTICAST_LOOP:
      error = ip_getmoptions(optname, so, val);
 202ea14:	e13ffe17 	ldw	r4,-8(fp)
 202ea18:	e17ffd17 	ldw	r5,-12(fp)
 202ea1c:	e1bfff17 	ldw	r6,-4(fp)
 202ea20:	2046c980 	call	2046c98 <ip_getmoptions>
 202ea24:	e0bff715 	stw	r2,-36(fp)
      break;
 202ea28:	00003306 	br	202eaf8 <sogetopt+0x490>

#ifdef IP_RAW

   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
 202ea2c:	e0bffd17 	ldw	r2,-12(fp)
 202ea30:	10800417 	ldw	r2,16(r2)
 202ea34:	1088000c 	andi	r2,r2,8192
 202ea38:	10000426 	beq	r2,zero,202ea4c <sogetopt+0x3e4>
         *(int *)val = 1;
 202ea3c:	e0bfff17 	ldw	r2,-4(fp)
 202ea40:	00c00044 	movi	r3,1
 202ea44:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;
      break;
 202ea48:	00002b06 	br	202eaf8 <sogetopt+0x490>
   case IP_HDRINCL:
      /* indicate based on header-include flag in socket state */
      if (so->so_options & SO_HDRINCL)
         *(int *)val = 1;
      else
         *(int *)val = 0;
 202ea4c:	e0bfff17 	ldw	r2,-4(fp)
 202ea50:	10000015 	stw	zero,0(r2)
      break;
 202ea54:	00002806 	br	202eaf8 <sogetopt+0x490>
   case TCP_NODELAY:
   {
      struct inpcb * inp;
      struct tcpcb * tp;

      if(so->so_type != SOCK_STREAM)
 202ea58:	e0bffd17 	ldw	r2,-12(fp)
 202ea5c:	10800983 	ldbu	r2,38(r2)
 202ea60:	10803fcc 	andi	r2,r2,255
 202ea64:	1080201c 	xori	r2,r2,128
 202ea68:	10bfe004 	addi	r2,r2,-128
 202ea6c:	10800060 	cmpeqi	r2,r2,1
 202ea70:	1000031e 	bne	r2,zero,202ea80 <sogetopt+0x418>
      {
         error = EINVAL;
 202ea74:	00800584 	movi	r2,22
 202ea78:	e0bff715 	stw	r2,-36(fp)
         break;
 202ea7c:	00001e06 	br	202eaf8 <sogetopt+0x490>
      }
      inp = (struct inpcb *)(so->so_pcb);
 202ea80:	e0bffd17 	ldw	r2,-12(fp)
 202ea84:	10800117 	ldw	r2,4(r2)
 202ea88:	e0bffb15 	stw	r2,-20(fp)
      tp = intotcpcb(inp);
 202ea8c:	e0bffb17 	ldw	r2,-20(fp)
 202ea90:	10800917 	ldw	r2,36(r2)
 202ea94:	e0bffc15 	stw	r2,-16(fp)
      if (!tp)
 202ea98:	e0bffc17 	ldw	r2,-16(fp)
 202ea9c:	1000031e 	bne	r2,zero,202eaac <sogetopt+0x444>
      {
         error = ENOTCONN;
 202eaa0:	00802004 	movi	r2,128
 202eaa4:	e0bff715 	stw	r2,-36(fp)
         break;
 202eaa8:	00001306 	br	202eaf8 <sogetopt+0x490>
      }
      /* try to make sure that the argument pointer is valid */
      if (val == NULL)
 202eaac:	e0bfff17 	ldw	r2,-4(fp)
 202eab0:	1000031e 	bne	r2,zero,202eac0 <sogetopt+0x458>
      {
         error = ENP_PARAM;
 202eab4:	00bffd84 	movi	r2,-10
 202eab8:	e0bff715 	stw	r2,-36(fp)
         break;
 202eabc:	00000e06 	br	202eaf8 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
 202eac0:	e0bffc17 	ldw	r2,-16(fp)
 202eac4:	10800b0b 	ldhu	r2,44(r2)
 202eac8:	10bfffcc 	andi	r2,r2,65535
 202eacc:	1080010c 	andi	r2,r2,4
 202ead0:	10000426 	beq	r2,zero,202eae4 <sogetopt+0x47c>
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
 202ead4:	e0bfff17 	ldw	r2,-4(fp)
 202ead8:	00c00044 	movi	r3,1
 202eadc:	10c00015 	stw	r3,0(r2)
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */

      break;
 202eae0:	00000506 	br	202eaf8 <sogetopt+0x490>
      }
      /* if contents of integer addressed by arg are non-zero */
      if (tp->t_flags & TF_NODELAY)
         *(int *)val = 1;  /* Nagle Algorithm is Enabled */
      else
         *(int *)val = 0;  /* Nagle Algorithm is NOT Enabled */
 202eae4:	e0bfff17 	ldw	r2,-4(fp)
 202eae8:	10000015 	stw	zero,0(r2)

      break;
 202eaec:	00000206 	br	202eaf8 <sogetopt+0x490>
   }

   default:
      return ENOPROTOOPT;
 202eaf0:	00801b44 	movi	r2,109
 202eaf4:	00000106 	br	202eafc <sogetopt+0x494>
   }
   return error;     /* no error */
 202eaf8:	e0bff717 	ldw	r2,-36(fp)
}
 202eafc:	e037883a 	mov	sp,fp
 202eb00:	dfc00117 	ldw	ra,4(sp)
 202eb04:	df000017 	ldw	fp,0(sp)
 202eb08:	dec00204 	addi	sp,sp,8
 202eb0c:	f800283a 	ret

0202eb10 <sohasoutofband>:
 * RETURNS: 
 */

void
sohasoutofband(struct socket * so)
{
 202eb10:	defffd04 	addi	sp,sp,-12
 202eb14:	dfc00215 	stw	ra,8(sp)
 202eb18:	df000115 	stw	fp,4(sp)
 202eb1c:	df000104 	addi	fp,sp,4
 202eb20:	e13fff15 	stw	r4,-4(fp)
   so->so_error = EHAVEOOB;   /* WILL be picked up by the socket */
 202eb24:	e0bfff17 	ldw	r2,-4(fp)
 202eb28:	00c03644 	movi	r3,217
 202eb2c:	10c00615 	stw	r3,24(r2)
   sorwakeup (so);
 202eb30:	e0bfff17 	ldw	r2,-4(fp)
 202eb34:	10800a04 	addi	r2,r2,40
 202eb38:	e13fff17 	ldw	r4,-4(fp)
 202eb3c:	100b883a 	mov	r5,r2
 202eb40:	202f3300 	call	202f330 <sbwakeup>
}
 202eb44:	e037883a 	mov	sp,fp
 202eb48:	dfc00117 	ldw	ra,4(sp)
 202eb4c:	df000017 	ldw	fp,0(sp)
 202eb50:	dec00204 	addi	sp,sp,8
 202eb54:	f800283a 	ret

0202eb58 <soisconnecting>:
 * RETURNS: 
 */

void
soisconnecting(struct socket * so)
{
 202eb58:	defffd04 	addi	sp,sp,-12
 202eb5c:	dfc00215 	stw	ra,8(sp)
 202eb60:	df000115 	stw	fp,4(sp)
 202eb64:	df000104 	addi	fp,sp,4
 202eb68:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~(SS_ISCONNECTED|SS_ISDISCONNECTING);
 202eb6c:	e0bfff17 	ldw	r2,-4(fp)
 202eb70:	10c0088b 	ldhu	r3,34(r2)
 202eb74:	00bffd44 	movi	r2,-11
 202eb78:	1884703a 	and	r2,r3,r2
 202eb7c:	1007883a 	mov	r3,r2
 202eb80:	e0bfff17 	ldw	r2,-4(fp)
 202eb84:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTING;
 202eb88:	e0bfff17 	ldw	r2,-4(fp)
 202eb8c:	1080088b 	ldhu	r2,34(r2)
 202eb90:	10800114 	ori	r2,r2,4
 202eb94:	1007883a 	mov	r3,r2
 202eb98:	e0bfff17 	ldw	r2,-4(fp)
 202eb9c:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 202eba0:	e0bfff17 	ldw	r2,-4(fp)
 202eba4:	10800904 	addi	r2,r2,36
 202eba8:	1009883a 	mov	r4,r2
 202ebac:	20276980 	call	2027698 <tcp_wakeup>
}
 202ebb0:	e037883a 	mov	sp,fp
 202ebb4:	dfc00117 	ldw	ra,4(sp)
 202ebb8:	df000017 	ldw	fp,0(sp)
 202ebbc:	dec00204 	addi	sp,sp,8
 202ebc0:	f800283a 	ret

0202ebc4 <soisconnected>:
 * RETURNS: 
 */

void
soisconnected(struct socket * so)
{
 202ebc4:	defffc04 	addi	sp,sp,-16
 202ebc8:	dfc00315 	stw	ra,12(sp)
 202ebcc:	df000215 	stw	fp,8(sp)
 202ebd0:	df000204 	addi	fp,sp,8
 202ebd4:	e13fff15 	stw	r4,-4(fp)
   struct socket *   head  =  so->so_head;
 202ebd8:	e0bfff17 	ldw	r2,-4(fp)
 202ebdc:	10801b17 	ldw	r2,108(r2)
 202ebe0:	e0bffe15 	stw	r2,-8(fp)

   if (head) 
 202ebe4:	e0bffe17 	ldw	r2,-8(fp)
 202ebe8:	10001426 	beq	r2,zero,202ec3c <soisconnected+0x78>
   {
      if (soqremque(so, 0) == 0)
 202ebec:	e13fff17 	ldw	r4,-4(fp)
 202ebf0:	000b883a 	mov	r5,zero
 202ebf4:	202f0e00 	call	202f0e0 <soqremque>
 202ebf8:	1000031e 	bne	r2,zero,202ec08 <soisconnected+0x44>
         panic("soisconnected");
 202ebfc:	01008174 	movhi	r4,517
 202ec00:	213d5e04 	addi	r4,r4,-2696
 202ec04:	2026bf80 	call	2026bf8 <panic>
      soqinsque(head, so, 1);
 202ec08:	e13ffe17 	ldw	r4,-8(fp)
 202ec0c:	e17fff17 	ldw	r5,-4(fp)
 202ec10:	01800044 	movi	r6,1
 202ec14:	202f0380 	call	202f038 <soqinsque>
      sorwakeup(head);
 202ec18:	e0bffe17 	ldw	r2,-8(fp)
 202ec1c:	10800a04 	addi	r2,r2,40
 202ec20:	e13ffe17 	ldw	r4,-8(fp)
 202ec24:	100b883a 	mov	r5,r2
 202ec28:	202f3300 	call	202f330 <sbwakeup>
      tcp_wakeup ((char *)&head->so_timeo);
 202ec2c:	e0bffe17 	ldw	r2,-8(fp)
 202ec30:	10800904 	addi	r2,r2,36
 202ec34:	1009883a 	mov	r4,r2
 202ec38:	20276980 	call	2027698 <tcp_wakeup>
   }

   so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 202ec3c:	e0bfff17 	ldw	r2,-4(fp)
 202ec40:	10c0088b 	ldhu	r3,34(r2)
 202ec44:	00bffcc4 	movi	r2,-13
 202ec48:	1884703a 	and	r2,r3,r2
 202ec4c:	1007883a 	mov	r3,r2
 202ec50:	e0bfff17 	ldw	r2,-4(fp)
 202ec54:	10c0088d 	sth	r3,34(r2)
   so->so_state |= SS_ISCONNECTED;
 202ec58:	e0bfff17 	ldw	r2,-4(fp)
 202ec5c:	1080088b 	ldhu	r2,34(r2)
 202ec60:	10800094 	ori	r2,r2,2
 202ec64:	1007883a 	mov	r3,r2
 202ec68:	e0bfff17 	ldw	r2,-4(fp)
 202ec6c:	10c0088d 	sth	r3,34(r2)
   so->so_error = 0;
 202ec70:	e0bfff17 	ldw	r2,-4(fp)
 202ec74:	10000615 	stw	zero,24(r2)
   tcp_wakeup  ((char *)&so->so_timeo);
 202ec78:	e0bfff17 	ldw	r2,-4(fp)
 202ec7c:	10800904 	addi	r2,r2,36
 202ec80:	1009883a 	mov	r4,r2
 202ec84:	20276980 	call	2027698 <tcp_wakeup>
   sorwakeup (so);
 202ec88:	e0bfff17 	ldw	r2,-4(fp)
 202ec8c:	10800a04 	addi	r2,r2,40
 202ec90:	e13fff17 	ldw	r4,-4(fp)
 202ec94:	100b883a 	mov	r5,r2
 202ec98:	202f3300 	call	202f330 <sbwakeup>
   sowwakeup (so);
 202ec9c:	e0bfff17 	ldw	r2,-4(fp)
 202eca0:	10801204 	addi	r2,r2,72
 202eca4:	e13fff17 	ldw	r4,-4(fp)
 202eca8:	100b883a 	mov	r5,r2
 202ecac:	202f3300 	call	202f330 <sbwakeup>
}
 202ecb0:	e037883a 	mov	sp,fp
 202ecb4:	dfc00117 	ldw	ra,4(sp)
 202ecb8:	df000017 	ldw	fp,0(sp)
 202ecbc:	dec00204 	addi	sp,sp,8
 202ecc0:	f800283a 	ret

0202ecc4 <soisdisconnecting>:
 * RETURNS: 
 */

void
soisdisconnecting(struct socket * so)
{
 202ecc4:	defffd04 	addi	sp,sp,-12
 202ecc8:	dfc00215 	stw	ra,8(sp)
 202eccc:	df000115 	stw	fp,4(sp)
 202ecd0:	df000104 	addi	fp,sp,4
 202ecd4:	e13fff15 	stw	r4,-4(fp)
   so->so_state &= ~SS_ISCONNECTING;
 202ecd8:	e0bfff17 	ldw	r2,-4(fp)
 202ecdc:	10c0088b 	ldhu	r3,34(r2)
 202ece0:	00bffec4 	movi	r2,-5
 202ece4:	1884703a 	and	r2,r3,r2
 202ece8:	1007883a 	mov	r3,r2
 202ecec:	e0bfff17 	ldw	r2,-4(fp)
 202ecf0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_ISDISCONNECTING|SS_CANTRCVMORE|SS_CANTSENDMORE);
 202ecf4:	e0bfff17 	ldw	r2,-4(fp)
 202ecf8:	1080088b 	ldhu	r2,34(r2)
 202ecfc:	10800e14 	ori	r2,r2,56
 202ed00:	1007883a 	mov	r3,r2
 202ed04:	e0bfff17 	ldw	r2,-4(fp)
 202ed08:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup  ((char *)&so->so_timeo);   
 202ed0c:	e0bfff17 	ldw	r2,-4(fp)
 202ed10:	10800904 	addi	r2,r2,36
 202ed14:	1009883a 	mov	r4,r2
 202ed18:	20276980 	call	2027698 <tcp_wakeup>
   sowwakeup (so);
 202ed1c:	e0bfff17 	ldw	r2,-4(fp)
 202ed20:	10801204 	addi	r2,r2,72
 202ed24:	e13fff17 	ldw	r4,-4(fp)
 202ed28:	100b883a 	mov	r5,r2
 202ed2c:	202f3300 	call	202f330 <sbwakeup>
   sorwakeup (so);
 202ed30:	e0bfff17 	ldw	r2,-4(fp)
 202ed34:	10800a04 	addi	r2,r2,40
 202ed38:	e13fff17 	ldw	r4,-4(fp)
 202ed3c:	100b883a 	mov	r5,r2
 202ed40:	202f3300 	call	202f330 <sbwakeup>
}
 202ed44:	e037883a 	mov	sp,fp
 202ed48:	dfc00117 	ldw	ra,4(sp)
 202ed4c:	df000017 	ldw	fp,0(sp)
 202ed50:	dec00204 	addi	sp,sp,8
 202ed54:	f800283a 	ret

0202ed58 <soisdisconnected>:
 * RETURNS: 
 */

void
soisdisconnected(struct socket * so)
{
 202ed58:	defffd04 	addi	sp,sp,-12
 202ed5c:	dfc00215 	stw	ra,8(sp)
 202ed60:	df000115 	stw	fp,4(sp)
 202ed64:	df000104 	addi	fp,sp,4
 202ed68:	e13fff15 	stw	r4,-4(fp)
   if (so->so_state & SS_ISCONNECTING)
 202ed6c:	e0bfff17 	ldw	r2,-4(fp)
 202ed70:	1080088b 	ldhu	r2,34(r2)
 202ed74:	10bfffcc 	andi	r2,r2,65535
 202ed78:	1080010c 	andi	r2,r2,4
 202ed7c:	10000626 	beq	r2,zero,202ed98 <soisdisconnected+0x40>
      so->so_state |= SS_WASCONNECTING;
 202ed80:	e0bfff17 	ldw	r2,-4(fp)
 202ed84:	1080088b 	ldhu	r2,34(r2)
 202ed88:	10880014 	ori	r2,r2,8192
 202ed8c:	1007883a 	mov	r3,r2
 202ed90:	e0bfff17 	ldw	r2,-4(fp)
 202ed94:	10c0088d 	sth	r3,34(r2)
   so->so_state &= ~(SS_ISCONNECTING|SS_ISCONNECTED|SS_ISDISCONNECTING);
 202ed98:	e0bfff17 	ldw	r2,-4(fp)
 202ed9c:	10c0088b 	ldhu	r3,34(r2)
 202eda0:	00bffc44 	movi	r2,-15
 202eda4:	1884703a 	and	r2,r3,r2
 202eda8:	1007883a 	mov	r3,r2
 202edac:	e0bfff17 	ldw	r2,-4(fp)
 202edb0:	10c0088d 	sth	r3,34(r2)
   so->so_state |= (SS_CANTRCVMORE|SS_CANTSENDMORE);
 202edb4:	e0bfff17 	ldw	r2,-4(fp)
 202edb8:	1080088b 	ldhu	r2,34(r2)
 202edbc:	10800c14 	ori	r2,r2,48
 202edc0:	1007883a 	mov	r3,r2
 202edc4:	e0bfff17 	ldw	r2,-4(fp)
 202edc8:	10c0088d 	sth	r3,34(r2)
   tcp_wakeup ((char *)&so->so_timeo);
 202edcc:	e0bfff17 	ldw	r2,-4(fp)
 202edd0:	10800904 	addi	r2,r2,36
 202edd4:	1009883a 	mov	r4,r2
 202edd8:	20276980 	call	2027698 <tcp_wakeup>
   sowwakeup (so);
 202eddc:	e0bfff17 	ldw	r2,-4(fp)
 202ede0:	10801204 	addi	r2,r2,72
 202ede4:	e13fff17 	ldw	r4,-4(fp)
 202ede8:	100b883a 	mov	r5,r2
 202edec:	202f3300 	call	202f330 <sbwakeup>
   sorwakeup (so);
 202edf0:	e0bfff17 	ldw	r2,-4(fp)
 202edf4:	10800a04 	addi	r2,r2,40
 202edf8:	e13fff17 	ldw	r4,-4(fp)
 202edfc:	100b883a 	mov	r5,r2
 202ee00:	202f3300 	call	202f330 <sbwakeup>
}
 202ee04:	e037883a 	mov	sp,fp
 202ee08:	dfc00117 	ldw	ra,4(sp)
 202ee0c:	df000017 	ldw	fp,0(sp)
 202ee10:	dec00204 	addi	sp,sp,8
 202ee14:	f800283a 	ret

0202ee18 <sonewconn>:
 * RETURNS: 
 */

struct socket *   
sonewconn(struct socket * head)
{
 202ee18:	defffb04 	addi	sp,sp,-20
 202ee1c:	dfc00415 	stw	ra,16(sp)
 202ee20:	df000315 	stw	fp,12(sp)
 202ee24:	df000304 	addi	fp,sp,12
 202ee28:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
 202ee2c:	e0bfff17 	ldw	r2,-4(fp)
 202ee30:	10801e43 	ldbu	r2,121(r2)
 202ee34:	10c03fcc 	andi	r3,r2,255
 202ee38:	18c0201c 	xori	r3,r3,128
 202ee3c:	18ffe004 	addi	r3,r3,-128
 202ee40:	e0bfff17 	ldw	r2,-4(fp)
 202ee44:	10801e03 	ldbu	r2,120(r2)
 202ee48:	10803fcc 	andi	r2,r2,255
 202ee4c:	1080201c 	xori	r2,r2,128
 202ee50:	10bfe004 	addi	r2,r2,-128
 202ee54:	1889883a 	add	r4,r3,r2
 202ee58:	e0bfff17 	ldw	r2,-4(fp)
 202ee5c:	10801e83 	ldbu	r2,122(r2)
 202ee60:	10c03fcc 	andi	r3,r2,255
 202ee64:	18c0201c 	xori	r3,r3,128
 202ee68:	18ffe004 	addi	r3,r3,-128
 202ee6c:	1805883a 	mov	r2,r3
 202ee70:	1085883a 	add	r2,r2,r2
 202ee74:	10c5883a 	add	r2,r2,r3
 202ee78:	1006d7fa 	srli	r3,r2,31
 202ee7c:	1885883a 	add	r2,r3,r2
 202ee80:	1005d07a 	srai	r2,r2,1
 202ee84:	11006316 	blt	r2,r4,202f014 <sonewconn+0x1fc>
      goto bad;
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
 202ee88:	01002104 	movi	r4,132
 202ee8c:	20290400 	call	2029040 <npalloc>
 202ee90:	e0bffd15 	stw	r2,-12(fp)
 202ee94:	e0bffd17 	ldw	r2,-12(fp)
 202ee98:	10006026 	beq	r2,zero,202f01c <sonewconn+0x204>
      goto bad;
   so->next = NULL;
 202ee9c:	e0bffd17 	ldw	r2,-12(fp)
 202eea0:	10000015 	stw	zero,0(r2)
   putq(&soq,(qp)so);      /* Place newly created socket in a queue */
 202eea4:	01009934 	movhi	r4,612
 202eea8:	2136c204 	addi	r4,r4,-9464
 202eeac:	e17ffd17 	ldw	r5,-12(fp)
 202eeb0:	20282880 	call	2028288 <putq>
   so->so_type = head->so_type;
 202eeb4:	e0bfff17 	ldw	r2,-4(fp)
 202eeb8:	10c00983 	ldbu	r3,38(r2)
 202eebc:	e0bffd17 	ldw	r2,-12(fp)
 202eec0:	10c00985 	stb	r3,38(r2)
   so->so_options = head->so_options &~ (unshort)SO_ACCEPTCONN;
 202eec4:	e0bfff17 	ldw	r2,-4(fp)
 202eec8:	10c00417 	ldw	r3,16(r2)
 202eecc:	00bfff44 	movi	r2,-3
 202eed0:	1886703a 	and	r3,r3,r2
 202eed4:	e0bffd17 	ldw	r2,-12(fp)
 202eed8:	10c00415 	stw	r3,16(r2)
   so->so_linger = head->so_linger;
 202eedc:	e0bfff17 	ldw	r2,-4(fp)
 202eee0:	10c0080b 	ldhu	r3,32(r2)
 202eee4:	e0bffd17 	ldw	r2,-12(fp)
 202eee8:	10c0080d 	sth	r3,32(r2)
   so->so_state = head->so_state | (unshort)SS_NOFDREF;
 202eeec:	e0bfff17 	ldw	r2,-4(fp)
 202eef0:	1080088b 	ldhu	r2,34(r2)
 202eef4:	10800054 	ori	r2,r2,1
 202eef8:	1007883a 	mov	r3,r2
 202eefc:	e0bffd17 	ldw	r2,-12(fp)
 202ef00:	10c0088d 	sth	r3,34(r2)
   so->so_proto = head->so_proto;
 202ef04:	e0bfff17 	ldw	r2,-4(fp)
 202ef08:	10c00217 	ldw	r3,8(r2)
 202ef0c:	e0bffd17 	ldw	r2,-12(fp)
 202ef10:	10c00215 	stw	r3,8(r2)
   so->so_timeo = head->so_timeo;
 202ef14:	e0bfff17 	ldw	r2,-4(fp)
 202ef18:	10c0090b 	ldhu	r3,36(r2)
 202ef1c:	e0bffd17 	ldw	r2,-12(fp)
 202ef20:	10c0090d 	sth	r3,36(r2)
   so->so_rcv.sb_hiwat = (u_int)tcp_recvspace;
 202ef24:	00808174 	movhi	r2,517
 202ef28:	10907104 	addi	r2,r2,16836
 202ef2c:	10c00017 	ldw	r3,0(r2)
 202ef30:	e0bffd17 	ldw	r2,-12(fp)
 202ef34:	10c00b15 	stw	r3,44(r2)
   so->so_snd.sb_hiwat = (u_int)tcp_sendspace;
 202ef38:	00808174 	movhi	r2,517
 202ef3c:	10907004 	addi	r2,r2,16832
 202ef40:	10c00017 	ldw	r3,0(r2)
 202ef44:	e0bffd17 	ldw	r2,-12(fp)
 202ef48:	10c01315 	stw	r3,76(r2)
   soqinsque (head, so, 0);
 202ef4c:	e13fff17 	ldw	r4,-4(fp)
 202ef50:	e17ffd17 	ldw	r5,-12(fp)
 202ef54:	000d883a 	mov	r6,zero
 202ef58:	202f0380 	call	202f038 <soqinsque>
   so->so_req = PRU_ATTACH;
 202ef5c:	e0bffd17 	ldw	r2,-12(fp)
 202ef60:	10000715 	stw	zero,28(r2)
   so->so_domain = head->so_domain;
 202ef64:	e0bfff17 	ldw	r2,-4(fp)
 202ef68:	10c00517 	ldw	r3,20(r2)
 202ef6c:	e0bffd17 	ldw	r2,-12(fp)
 202ef70:	10c00515 	stw	r3,20(r2)

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
 202ef74:	e0bffd17 	ldw	r2,-12(fp)
 202ef78:	10800217 	ldw	r2,8(r2)
 202ef7c:	10800317 	ldw	r2,12(r2)
 202ef80:	e13ffd17 	ldw	r4,-12(fp)
 202ef84:	000b883a 	mov	r5,zero
 202ef88:	000d883a 	mov	r6,zero
 202ef8c:	103ee83a 	callr	r2
 202ef90:	1000131e 	bne	r2,zero,202efe0 <sonewconn+0x1c8>
      goto bad2;
   if (so_evtmap)
 202ef94:	00808174 	movhi	r2,517
 202ef98:	1090ee04 	addi	r2,r2,17336
 202ef9c:	10800003 	ldbu	r2,0(r2)
 202efa0:	10803fcc 	andi	r2,r2,255
 202efa4:	10000c26 	beq	r2,zero,202efd8 <sonewconn+0x1c0>
   {
      rc = (*so_evtmap_create) (so);                       
 202efa8:	00808174 	movhi	r2,517
 202efac:	1090ec04 	addi	r2,r2,17328
 202efb0:	10800017 	ldw	r2,0(r2)
 202efb4:	e13ffd17 	ldw	r4,-12(fp)
 202efb8:	103ee83a 	callr	r2
 202efbc:	e0bffe15 	stw	r2,-8(fp)
      if (rc != 0) goto bad2;
 202efc0:	e0bffe17 	ldw	r2,-8(fp)
 202efc4:	1000081e 	bne	r2,zero,202efe8 <sonewconn+0x1d0>
      so->owner = head->owner;
 202efc8:	e0bfff17 	ldw	r2,-4(fp)
 202efcc:	10c02003 	ldbu	r3,128(r2)
 202efd0:	e0bffd17 	ldw	r2,-12(fp)
 202efd4:	10c02005 	stb	r3,128(r2)
   }
   return (so);
 202efd8:	e0bffd17 	ldw	r2,-12(fp)
 202efdc:	00001106 	br	202f024 <sonewconn+0x20c>
   soqinsque (head, so, 0);
   so->so_req = PRU_ATTACH;
   so->so_domain = head->so_domain;

   if ((*so->so_proto->pr_usrreq)(so, (struct mbuf *)0, (struct mbuf *)0))
      goto bad2;
 202efe0:	0001883a 	nop
 202efe4:	00000106 	br	202efec <sonewconn+0x1d4>
   if (so_evtmap)
   {
      rc = (*so_evtmap_create) (so);                       
      if (rc != 0) goto bad2;
 202efe8:	0001883a 	nop
      so->owner = head->owner;
   }
   return (so);
   
bad2:
   (void) soqremque (so, 0);
 202efec:	e13ffd17 	ldw	r4,-12(fp)
 202eff0:	000b883a 	mov	r5,zero
 202eff4:	202f0e00 	call	202f0e0 <soqremque>
   qdel(&soq, so);   /* Delete the socket entry from the queue */
 202eff8:	01009934 	movhi	r4,612
 202effc:	2136c204 	addi	r4,r4,-9464
 202f000:	e17ffd17 	ldw	r5,-12(fp)
 202f004:	20283340 	call	2028334 <qdel>
   SOC_FREE(so);  /* Free the socket structure */
 202f008:	e13ffd17 	ldw	r4,-12(fp)
 202f00c:	202912c0 	call	202912c <npfree>
 202f010:	00000306 	br	202f020 <sonewconn+0x208>
{
   struct socket *   so;
   int rc;  

   if (head->so_qlen + head->so_q0len > 3 * head->so_qlimit / 2)
      goto bad;
 202f014:	0001883a 	nop
 202f018:	00000106 	br	202f020 <sonewconn+0x208>
   if ((so = SOC_ALLOC (sizeof (*so))) == NULL)
      goto bad;
 202f01c:	0001883a 	nop
bad2:
   (void) soqremque (so, 0);
   qdel(&soq, so);   /* Delete the socket entry from the queue */
   SOC_FREE(so);  /* Free the socket structure */
bad:
   return ((struct socket *)0);
 202f020:	0005883a 	mov	r2,zero
}
 202f024:	e037883a 	mov	sp,fp
 202f028:	dfc00117 	ldw	ra,4(sp)
 202f02c:	df000017 	ldw	fp,0(sp)
 202f030:	dec00204 	addi	sp,sp,8
 202f034:	f800283a 	ret

0202f038 <soqinsque>:

void
soqinsque(struct socket * head, 
   struct socket *   so,
   int   q)
{
 202f038:	defffc04 	addi	sp,sp,-16
 202f03c:	df000315 	stw	fp,12(sp)
 202f040:	df000304 	addi	fp,sp,12
 202f044:	e13ffd15 	stw	r4,-12(fp)
 202f048:	e17ffe15 	stw	r5,-8(fp)
 202f04c:	e1bfff15 	stw	r6,-4(fp)
   so->so_head = head;
 202f050:	e0bffe17 	ldw	r2,-8(fp)
 202f054:	e0fffd17 	ldw	r3,-12(fp)
 202f058:	10c01b15 	stw	r3,108(r2)
   if (q == 0) 
 202f05c:	e0bfff17 	ldw	r2,-4(fp)
 202f060:	10000e1e 	bne	r2,zero,202f09c <soqinsque+0x64>
   {
      head->so_q0len++;
 202f064:	e0bffd17 	ldw	r2,-12(fp)
 202f068:	10801e03 	ldbu	r2,120(r2)
 202f06c:	10800044 	addi	r2,r2,1
 202f070:	1007883a 	mov	r3,r2
 202f074:	e0bffd17 	ldw	r2,-12(fp)
 202f078:	10c01e05 	stb	r3,120(r2)
      so->so_q0 = head->so_q0;
 202f07c:	e0bffd17 	ldw	r2,-12(fp)
 202f080:	10c01c17 	ldw	r3,112(r2)
 202f084:	e0bffe17 	ldw	r2,-8(fp)
 202f088:	10c01c15 	stw	r3,112(r2)
      head->so_q0 = so;
 202f08c:	e0bffd17 	ldw	r2,-12(fp)
 202f090:	e0fffe17 	ldw	r3,-8(fp)
 202f094:	10c01c15 	stw	r3,112(r2)
 202f098:	00000d06 	br	202f0d0 <soqinsque+0x98>
   } else 
   {
      head->so_qlen++;
 202f09c:	e0bffd17 	ldw	r2,-12(fp)
 202f0a0:	10801e43 	ldbu	r2,121(r2)
 202f0a4:	10800044 	addi	r2,r2,1
 202f0a8:	1007883a 	mov	r3,r2
 202f0ac:	e0bffd17 	ldw	r2,-12(fp)
 202f0b0:	10c01e45 	stb	r3,121(r2)
      so->so_q = head->so_q;
 202f0b4:	e0bffd17 	ldw	r2,-12(fp)
 202f0b8:	10c01d17 	ldw	r3,116(r2)
 202f0bc:	e0bffe17 	ldw	r2,-8(fp)
 202f0c0:	10c01d15 	stw	r3,116(r2)
      head->so_q = so;
 202f0c4:	e0bffd17 	ldw	r2,-12(fp)
 202f0c8:	e0fffe17 	ldw	r3,-8(fp)
 202f0cc:	10c01d15 	stw	r3,116(r2)
   }
}
 202f0d0:	e037883a 	mov	sp,fp
 202f0d4:	df000017 	ldw	fp,0(sp)
 202f0d8:	dec00104 	addi	sp,sp,4
 202f0dc:	f800283a 	ret

0202f0e0 <soqremque>:
 * RETURNS: 
 */

int
soqremque(struct socket * so, int q)
{
 202f0e0:	defffa04 	addi	sp,sp,-24
 202f0e4:	df000515 	stw	fp,20(sp)
 202f0e8:	df000504 	addi	fp,sp,20
 202f0ec:	e13ffe15 	stw	r4,-8(fp)
 202f0f0:	e17fff15 	stw	r5,-4(fp)
   struct socket *   head, *  prev, *  next;

   head = so->so_head;
 202f0f4:	e0bffe17 	ldw	r2,-8(fp)
 202f0f8:	10801b17 	ldw	r2,108(r2)
 202f0fc:	e0bffc15 	stw	r2,-16(fp)
   prev = head;
 202f100:	e0bffc17 	ldw	r2,-16(fp)
 202f104:	e0bffb15 	stw	r2,-20(fp)
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
 202f108:	e0bfff17 	ldw	r2,-4(fp)
 202f10c:	10000326 	beq	r2,zero,202f11c <soqremque+0x3c>
 202f110:	e0bffb17 	ldw	r2,-20(fp)
 202f114:	10801d17 	ldw	r2,116(r2)
 202f118:	00000206 	br	202f124 <soqremque+0x44>
 202f11c:	e0bffb17 	ldw	r2,-20(fp)
 202f120:	10801c17 	ldw	r2,112(r2)
 202f124:	e0bffd15 	stw	r2,-12(fp)
      if (next == so)
 202f128:	e0fffd17 	ldw	r3,-12(fp)
 202f12c:	e0bffe17 	ldw	r2,-8(fp)
 202f130:	18800826 	beq	r3,r2,202f154 <soqremque+0x74>
         break;
      if (next == head)
 202f134:	e0fffd17 	ldw	r3,-12(fp)
 202f138:	e0bffc17 	ldw	r2,-16(fp)
 202f13c:	1880021e 	bne	r3,r2,202f148 <soqremque+0x68>
         return (0);
 202f140:	0005883a 	mov	r2,zero
 202f144:	00002406 	br	202f1d8 <soqremque+0xf8>
      prev = next;
 202f148:	e0bffd17 	ldw	r2,-12(fp)
 202f14c:	e0bffb15 	stw	r2,-20(fp)
   }
 202f150:	003fed06 	br	202f108 <soqremque+0x28>
   prev = head;
   for (;;) 
   {
      next = q ? prev->so_q : prev->so_q0;
      if (next == so)
         break;
 202f154:	0001883a 	nop
      if (next == head)
         return (0);
      prev = next;
   }
   if (q == 0) 
 202f158:	e0bfff17 	ldw	r2,-4(fp)
 202f15c:	10000b1e 	bne	r2,zero,202f18c <soqremque+0xac>
   {
      prev->so_q0 = next->so_q0;
 202f160:	e0bffd17 	ldw	r2,-12(fp)
 202f164:	10c01c17 	ldw	r3,112(r2)
 202f168:	e0bffb17 	ldw	r2,-20(fp)
 202f16c:	10c01c15 	stw	r3,112(r2)
      head->so_q0len--;
 202f170:	e0bffc17 	ldw	r2,-16(fp)
 202f174:	10801e03 	ldbu	r2,120(r2)
 202f178:	10bfffc4 	addi	r2,r2,-1
 202f17c:	1007883a 	mov	r3,r2
 202f180:	e0bffc17 	ldw	r2,-16(fp)
 202f184:	10c01e05 	stb	r3,120(r2)
 202f188:	00000a06 	br	202f1b4 <soqremque+0xd4>
   } else 
   {
      prev->so_q = next->so_q;
 202f18c:	e0bffd17 	ldw	r2,-12(fp)
 202f190:	10c01d17 	ldw	r3,116(r2)
 202f194:	e0bffb17 	ldw	r2,-20(fp)
 202f198:	10c01d15 	stw	r3,116(r2)
      head->so_qlen--;
 202f19c:	e0bffc17 	ldw	r2,-16(fp)
 202f1a0:	10801e43 	ldbu	r2,121(r2)
 202f1a4:	10bfffc4 	addi	r2,r2,-1
 202f1a8:	1007883a 	mov	r3,r2
 202f1ac:	e0bffc17 	ldw	r2,-16(fp)
 202f1b0:	10c01e45 	stb	r3,121(r2)
   }
   next->so_q0 = next->so_q = 0;
 202f1b4:	e0bffd17 	ldw	r2,-12(fp)
 202f1b8:	10001d15 	stw	zero,116(r2)
 202f1bc:	e0bffd17 	ldw	r2,-12(fp)
 202f1c0:	10c01d17 	ldw	r3,116(r2)
 202f1c4:	e0bffd17 	ldw	r2,-12(fp)
 202f1c8:	10c01c15 	stw	r3,112(r2)
   next->so_head = 0;
 202f1cc:	e0bffd17 	ldw	r2,-12(fp)
 202f1d0:	10001b15 	stw	zero,108(r2)
   return 1;
 202f1d4:	00800044 	movi	r2,1
}
 202f1d8:	e037883a 	mov	sp,fp
 202f1dc:	df000017 	ldw	fp,0(sp)
 202f1e0:	dec00104 	addi	sp,sp,4
 202f1e4:	f800283a 	ret

0202f1e8 <socantsendmore>:
 * RETURNS: 
 */

void
socantsendmore(struct socket * so)
{
 202f1e8:	defffd04 	addi	sp,sp,-12
 202f1ec:	dfc00215 	stw	ra,8(sp)
 202f1f0:	df000115 	stw	fp,4(sp)
 202f1f4:	df000104 	addi	fp,sp,4
 202f1f8:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTSENDMORE;
 202f1fc:	e0bfff17 	ldw	r2,-4(fp)
 202f200:	1080088b 	ldhu	r2,34(r2)
 202f204:	10800414 	ori	r2,r2,16
 202f208:	1007883a 	mov	r3,r2
 202f20c:	e0bfff17 	ldw	r2,-4(fp)
 202f210:	10c0088d 	sth	r3,34(r2)
   sowwakeup(so);
 202f214:	e0bfff17 	ldw	r2,-4(fp)
 202f218:	10801204 	addi	r2,r2,72
 202f21c:	e13fff17 	ldw	r4,-4(fp)
 202f220:	100b883a 	mov	r5,r2
 202f224:	202f3300 	call	202f330 <sbwakeup>
}
 202f228:	e037883a 	mov	sp,fp
 202f22c:	dfc00117 	ldw	ra,4(sp)
 202f230:	df000017 	ldw	fp,0(sp)
 202f234:	dec00204 	addi	sp,sp,8
 202f238:	f800283a 	ret

0202f23c <socantrcvmore>:
 * RETURNS: 
 */

void
socantrcvmore(struct socket * so)
{
 202f23c:	defffd04 	addi	sp,sp,-12
 202f240:	dfc00215 	stw	ra,8(sp)
 202f244:	df000115 	stw	fp,4(sp)
 202f248:	df000104 	addi	fp,sp,4
 202f24c:	e13fff15 	stw	r4,-4(fp)
   so->so_state |= SS_CANTRCVMORE;
 202f250:	e0bfff17 	ldw	r2,-4(fp)
 202f254:	1080088b 	ldhu	r2,34(r2)
 202f258:	10800814 	ori	r2,r2,32
 202f25c:	1007883a 	mov	r3,r2
 202f260:	e0bfff17 	ldw	r2,-4(fp)
 202f264:	10c0088d 	sth	r3,34(r2)
   sorwakeup(so);
 202f268:	e0bfff17 	ldw	r2,-4(fp)
 202f26c:	10800a04 	addi	r2,r2,40
 202f270:	e13fff17 	ldw	r4,-4(fp)
 202f274:	100b883a 	mov	r5,r2
 202f278:	202f3300 	call	202f330 <sbwakeup>
}
 202f27c:	e037883a 	mov	sp,fp
 202f280:	dfc00117 	ldw	ra,4(sp)
 202f284:	df000017 	ldw	fp,0(sp)
 202f288:	dec00204 	addi	sp,sp,8
 202f28c:	f800283a 	ret

0202f290 <sbselqueue>:
 * RETURNS: 
 */

void
sbselqueue(struct sockbuf * sb)
{
 202f290:	defffe04 	addi	sp,sp,-8
 202f294:	df000115 	stw	fp,4(sp)
 202f298:	df000104 	addi	fp,sp,4
 202f29c:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_SEL;
 202f2a0:	e0bfff17 	ldw	r2,-4(fp)
 202f2a4:	1080070b 	ldhu	r2,28(r2)
 202f2a8:	10800214 	ori	r2,r2,8
 202f2ac:	1007883a 	mov	r3,r2
 202f2b0:	e0bfff17 	ldw	r2,-4(fp)
 202f2b4:	10c0070d 	sth	r3,28(r2)
}
 202f2b8:	e037883a 	mov	sp,fp
 202f2bc:	df000017 	ldw	fp,0(sp)
 202f2c0:	dec00104 	addi	sp,sp,4
 202f2c4:	f800283a 	ret

0202f2c8 <sbwait>:
 * RETURNS: 
 */

void
sbwait(struct sockbuf * sb)
{
 202f2c8:	defffd04 	addi	sp,sp,-12
 202f2cc:	dfc00215 	stw	ra,8(sp)
 202f2d0:	df000115 	stw	fp,4(sp)
 202f2d4:	df000104 	addi	fp,sp,4
 202f2d8:	e13fff15 	stw	r4,-4(fp)
   sb->sb_flags |= SB_WAIT;
 202f2dc:	e0bfff17 	ldw	r2,-4(fp)
 202f2e0:	1080070b 	ldhu	r2,28(r2)
 202f2e4:	10800114 	ori	r2,r2,4
 202f2e8:	1007883a 	mov	r3,r2
 202f2ec:	e0bfff17 	ldw	r2,-4(fp)
 202f2f0:	10c0070d 	sth	r3,28(r2)
   tcp_sleep ((char *)&sb->sb_cc);
 202f2f4:	e0bfff17 	ldw	r2,-4(fp)
 202f2f8:	1009883a 	mov	r4,r2
 202f2fc:	20274f40 	call	20274f4 <tcp_sleep>
   sb->sb_flags &= ~SB_WAIT;
 202f300:	e0bfff17 	ldw	r2,-4(fp)
 202f304:	10c0070b 	ldhu	r3,28(r2)
 202f308:	00bffec4 	movi	r2,-5
 202f30c:	1884703a 	and	r2,r3,r2
 202f310:	1007883a 	mov	r3,r2
 202f314:	e0bfff17 	ldw	r2,-4(fp)
 202f318:	10c0070d 	sth	r3,28(r2)
}
 202f31c:	e037883a 	mov	sp,fp
 202f320:	dfc00117 	ldw	ra,4(sp)
 202f324:	df000017 	ldw	fp,0(sp)
 202f328:	dec00204 	addi	sp,sp,8
 202f32c:	f800283a 	ret

0202f330 <sbwakeup>:
 * RETURNS: 
 */

void
sbwakeup(struct socket * so, struct sockbuf * sb)
{
 202f330:	defffc04 	addi	sp,sp,-16
 202f334:	dfc00315 	stw	ra,12(sp)
 202f338:	df000215 	stw	fp,8(sp)
 202f33c:	df000204 	addi	fp,sp,8
 202f340:	e13ffe15 	stw	r4,-8(fp)
 202f344:	e17fff15 	stw	r5,-4(fp)
   if (sb->sb_flags & SB_SEL) 
 202f348:	e0bfff17 	ldw	r2,-4(fp)
 202f34c:	1080070b 	ldhu	r2,28(r2)
 202f350:	10bfffcc 	andi	r2,r2,65535
 202f354:	1080020c 	andi	r2,r2,8
 202f358:	10000d26 	beq	r2,zero,202f390 <sbwakeup+0x60>
   {
      select_wait = 0;
 202f35c:	00808174 	movhi	r2,517
 202f360:	1090d104 	addi	r2,r2,17220
 202f364:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
      tcp_wakeup ((char *)&select_wait);
 202f368:	01008174 	movhi	r4,517
 202f36c:	2110d104 	addi	r4,r4,17220
 202f370:	20276980 	call	2027698 <tcp_wakeup>
#else
      tcp_wakeup2 (so->owner);
#endif      
      sb->sb_flags &= ~SB_SEL;
 202f374:	e0bfff17 	ldw	r2,-4(fp)
 202f378:	10c0070b 	ldhu	r3,28(r2)
 202f37c:	00bffdc4 	movi	r2,-9
 202f380:	1884703a 	and	r2,r3,r2
 202f384:	1007883a 	mov	r3,r2
 202f388:	e0bfff17 	ldw	r2,-4(fp)
 202f38c:	10c0070d 	sth	r3,28(r2)
#ifdef SOCK_WAKEALWAYS  /* Always wake the socket? */
   /* Systems Like Green Hills Integrity RTOS, need to process socket
      input even if looks like no one is blocked on the socket */
   tcp_wakeup ((char *)&sb->sb_cc); /* signal wake on socket */
#else /* older BSD style code - only call tcp_wakeup if blocked */
   if (sb->sb_flags & SB_WAIT)   /* is sockbuf's WAIT flag set? */
 202f390:	e0bfff17 	ldw	r2,-4(fp)
 202f394:	1080070b 	ldhu	r2,28(r2)
 202f398:	10bfffcc 	andi	r2,r2,65535
 202f39c:	1080010c 	andi	r2,r2,4
 202f3a0:	10000326 	beq	r2,zero,202f3b0 <sbwakeup+0x80>
   {
      tcp_wakeup ((char *)&sb->sb_cc);   /* call port wakeup routine */
 202f3a4:	e0bfff17 	ldw	r2,-4(fp)
 202f3a8:	1009883a 	mov	r4,r2
 202f3ac:	20276980 	call	2027698 <tcp_wakeup>
   }
#endif   /* SOCK_WAKEALWAYS */
}
 202f3b0:	e037883a 	mov	sp,fp
 202f3b4:	dfc00117 	ldw	ra,4(sp)
 202f3b8:	df000017 	ldw	fp,0(sp)
 202f3bc:	dec00204 	addi	sp,sp,8
 202f3c0:	f800283a 	ret

0202f3c4 <soreserve>:

int
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
 202f3c4:	defffb04 	addi	sp,sp,-20
 202f3c8:	dfc00415 	stw	ra,16(sp)
 202f3cc:	df000315 	stw	fp,12(sp)
 202f3d0:	df000304 	addi	fp,sp,12
 202f3d4:	e13ffd15 	stw	r4,-12(fp)
 202f3d8:	e17ffe15 	stw	r5,-8(fp)
 202f3dc:	e1bfff15 	stw	r6,-4(fp)
   if (sbreserve(&so->so_snd, sndcc) == 0)
 202f3e0:	e0bffd17 	ldw	r2,-12(fp)
 202f3e4:	10801204 	addi	r2,r2,72
 202f3e8:	1009883a 	mov	r4,r2
 202f3ec:	e17ffe17 	ldw	r5,-8(fp)
 202f3f0:	202f44c0 	call	202f44c <sbreserve>
 202f3f4:	10000e26 	beq	r2,zero,202f430 <soreserve+0x6c>
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
 202f3f8:	e0bffd17 	ldw	r2,-12(fp)
 202f3fc:	10800a04 	addi	r2,r2,40
 202f400:	1009883a 	mov	r4,r2
 202f404:	e17fff17 	ldw	r5,-4(fp)
 202f408:	202f44c0 	call	202f44c <sbreserve>
 202f40c:	10000226 	beq	r2,zero,202f418 <soreserve+0x54>
      goto bad2;
   return (0);
 202f410:	0005883a 	mov	r2,zero
 202f414:	00000806 	br	202f438 <soreserve+0x74>
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
   if (sbreserve(&so->so_rcv, rcvcc) == 0)
      goto bad2;
 202f418:	0001883a 	nop
   return (0);
bad2:
   sbrelease(&so->so_snd);
 202f41c:	e0bffd17 	ldw	r2,-12(fp)
 202f420:	10801204 	addi	r2,r2,72
 202f424:	1009883a 	mov	r4,r2
 202f428:	202f49c0 	call	202f49c <sbrelease>
 202f42c:	00000106 	br	202f434 <soreserve+0x70>
soreserve(struct socket * so, 
   u_long   sndcc, 
   u_long   rcvcc)
{
   if (sbreserve(&so->so_snd, sndcc) == 0)
      goto bad;
 202f430:	0001883a 	nop
      goto bad2;
   return (0);
bad2:
   sbrelease(&so->so_snd);
bad:
   return (ENOBUFS);
 202f434:	00801a44 	movi	r2,105
}
 202f438:	e037883a 	mov	sp,fp
 202f43c:	dfc00117 	ldw	ra,4(sp)
 202f440:	df000017 	ldw	fp,0(sp)
 202f444:	dec00204 	addi	sp,sp,8
 202f448:	f800283a 	ret

0202f44c <sbreserve>:
 * RETURNS: 
 */

int
sbreserve(struct sockbuf * sb, u_long cc)
{
 202f44c:	defffd04 	addi	sp,sp,-12
 202f450:	df000215 	stw	fp,8(sp)
 202f454:	df000204 	addi	fp,sp,8
 202f458:	e13ffe15 	stw	r4,-8(fp)
 202f45c:	e17fff15 	stw	r5,-4(fp)
#ifdef COMPILER_32BIT
   if (cc > (u_long)SB_MAX * CLBYTES / (2 * MSIZE + CLBYTES))
      return (0);
#endif
   sb->sb_hiwat = cc;
 202f460:	e0bffe17 	ldw	r2,-8(fp)
 202f464:	e0ffff17 	ldw	r3,-4(fp)
 202f468:	10c00115 	stw	r3,4(r2)
   sb->sb_mbmax = MIN(cc * 2, SB_MAX);
 202f46c:	e0bfff17 	ldw	r2,-4(fp)
 202f470:	1085883a 	add	r2,r2,r2
 202f474:	10d00070 	cmpltui	r3,r2,16385
 202f478:	1800011e 	bne	r3,zero,202f480 <sbreserve+0x34>
 202f47c:	00900004 	movi	r2,16384
 202f480:	e0fffe17 	ldw	r3,-8(fp)
 202f484:	18800315 	stw	r2,12(r3)
   return (1);
 202f488:	00800044 	movi	r2,1
}
 202f48c:	e037883a 	mov	sp,fp
 202f490:	df000017 	ldw	fp,0(sp)
 202f494:	dec00104 	addi	sp,sp,4
 202f498:	f800283a 	ret

0202f49c <sbrelease>:
 * RETURNS: 
 */

void
sbrelease(struct sockbuf * sb)
{
 202f49c:	defffd04 	addi	sp,sp,-12
 202f4a0:	dfc00215 	stw	ra,8(sp)
 202f4a4:	df000115 	stw	fp,4(sp)
 202f4a8:	df000104 	addi	fp,sp,4
 202f4ac:	e13fff15 	stw	r4,-4(fp)
   sbflush(sb);
 202f4b0:	e13fff17 	ldw	r4,-4(fp)
 202f4b4:	202fa0c0 	call	202fa0c <sbflush>
   sb->sb_hiwat = sb->sb_mbmax = 0;
 202f4b8:	e0bfff17 	ldw	r2,-4(fp)
 202f4bc:	10000315 	stw	zero,12(r2)
 202f4c0:	e0bfff17 	ldw	r2,-4(fp)
 202f4c4:	10c00317 	ldw	r3,12(r2)
 202f4c8:	e0bfff17 	ldw	r2,-4(fp)
 202f4cc:	10c00115 	stw	r3,4(r2)
}
 202f4d0:	e037883a 	mov	sp,fp
 202f4d4:	dfc00117 	ldw	ra,4(sp)
 202f4d8:	df000017 	ldw	fp,0(sp)
 202f4dc:	dec00204 	addi	sp,sp,8
 202f4e0:	f800283a 	ret

0202f4e4 <sbappend>:
 * RETURNS: 
 */

void
sbappend(struct sockbuf * sb, struct mbuf * m)
{
 202f4e4:	defffb04 	addi	sp,sp,-20
 202f4e8:	dfc00415 	stw	ra,16(sp)
 202f4ec:	df000315 	stw	fp,12(sp)
 202f4f0:	df000304 	addi	fp,sp,12
 202f4f4:	e13ffe15 	stw	r4,-8(fp)
 202f4f8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  n;

   if (m == 0)
 202f4fc:	e0bfff17 	ldw	r2,-4(fp)
 202f500:	10001a26 	beq	r2,zero,202f56c <sbappend+0x88>
      return;
   ENTER_CRIT_SECTION(sb);
 202f504:	20287fc0 	call	20287fc <irq_Mask>
   if ((n = sb->sb_mb) != NULL) 
 202f508:	e0bffe17 	ldw	r2,-8(fp)
 202f50c:	10800617 	ldw	r2,24(r2)
 202f510:	e0bffd15 	stw	r2,-12(fp)
 202f514:	e0bffd17 	ldw	r2,-12(fp)
 202f518:	10000e26 	beq	r2,zero,202f554 <sbappend+0x70>
   {
      while (n->m_act)
 202f51c:	00000306 	br	202f52c <sbappend+0x48>
         n = n->m_act;
 202f520:	e0bffd17 	ldw	r2,-12(fp)
 202f524:	10800717 	ldw	r2,28(r2)
 202f528:	e0bffd15 	stw	r2,-12(fp)
   if (m == 0)
      return;
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 202f52c:	e0bffd17 	ldw	r2,-12(fp)
 202f530:	10800717 	ldw	r2,28(r2)
 202f534:	103ffa1e 	bne	r2,zero,202f520 <sbappend+0x3c>
         n = n->m_act;
      while (n->m_next)
 202f538:	00000306 	br	202f548 <sbappend+0x64>
         n = n->m_next;
 202f53c:	e0bffd17 	ldw	r2,-12(fp)
 202f540:	10800617 	ldw	r2,24(r2)
 202f544:	e0bffd15 	stw	r2,-12(fp)
   ENTER_CRIT_SECTION(sb);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
         n = n->m_act;
      while (n->m_next)
 202f548:	e0bffd17 	ldw	r2,-12(fp)
 202f54c:	10800617 	ldw	r2,24(r2)
 202f550:	103ffa1e 	bne	r2,zero,202f53c <sbappend+0x58>
         n = n->m_next;
   }
   sbcompress(sb, m, n);
 202f554:	e13ffe17 	ldw	r4,-8(fp)
 202f558:	e17fff17 	ldw	r5,-4(fp)
 202f55c:	e1bffd17 	ldw	r6,-12(fp)
 202f560:	202f8340 	call	202f834 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 202f564:	20288580 	call	2028858 <irq_Unmask>
 202f568:	00000106 	br	202f570 <sbappend+0x8c>
sbappend(struct sockbuf * sb, struct mbuf * m)
{
   struct mbuf *  n;

   if (m == 0)
      return;
 202f56c:	0001883a 	nop
      while (n->m_next)
         n = n->m_next;
   }
   sbcompress(sb, m, n);
   EXIT_CRIT_SECTION(sb);
}
 202f570:	e037883a 	mov	sp,fp
 202f574:	dfc00117 	ldw	ra,4(sp)
 202f578:	df000017 	ldw	fp,0(sp)
 202f57c:	dec00204 	addi	sp,sp,8
 202f580:	f800283a 	ret

0202f584 <sbappendrecord>:
 */

void
sbappendrecord(struct sockbuf * sb, 
   struct mbuf *  m0)
{
 202f584:	defffb04 	addi	sp,sp,-20
 202f588:	dfc00415 	stw	ra,16(sp)
 202f58c:	df000315 	stw	fp,12(sp)
 202f590:	df000304 	addi	fp,sp,12
 202f594:	e13ffe15 	stw	r4,-8(fp)
 202f598:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m;

   if (m0 == 0)
 202f59c:	e0bfff17 	ldw	r2,-4(fp)
 202f5a0:	10002826 	beq	r2,zero,202f644 <sbappendrecord+0xc0>
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
 202f5a4:	20287fc0 	call	20287fc <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 202f5a8:	e0bffe17 	ldw	r2,-8(fp)
 202f5ac:	10800617 	ldw	r2,24(r2)
 202f5b0:	e0bffd15 	stw	r2,-12(fp)
 202f5b4:	e0bffd17 	ldw	r2,-12(fp)
 202f5b8:	10000726 	beq	r2,zero,202f5d8 <sbappendrecord+0x54>
      while (m->m_act)
 202f5bc:	00000306 	br	202f5cc <sbappendrecord+0x48>
      m = m->m_act;
 202f5c0:	e0bffd17 	ldw	r2,-12(fp)
 202f5c4:	10800717 	ldw	r2,28(r2)
 202f5c8:	e0bffd15 	stw	r2,-12(fp)

   if (m0 == 0)
      return;
   ENTER_CRIT_SECTION(sb);    /* protect so_rcv operations */
   if ((m = sb->sb_mb) != NULL)
      while (m->m_act)
 202f5cc:	e0bffd17 	ldw	r2,-12(fp)
 202f5d0:	10800717 	ldw	r2,28(r2)
 202f5d4:	103ffa1e 	bne	r2,zero,202f5c0 <sbappendrecord+0x3c>
      m = m->m_act;
   /*
    * Put the first mbuf on the queue.
    * Note this permits zero length records.
    */
   sballoc(sb, m0);
 202f5d8:	e0bffe17 	ldw	r2,-8(fp)
 202f5dc:	10c00017 	ldw	r3,0(r2)
 202f5e0:	e0bfff17 	ldw	r2,-4(fp)
 202f5e4:	10800217 	ldw	r2,8(r2)
 202f5e8:	1887883a 	add	r3,r3,r2
 202f5ec:	e0bffe17 	ldw	r2,-8(fp)
 202f5f0:	10c00015 	stw	r3,0(r2)
   if (m)
 202f5f4:	e0bffd17 	ldw	r2,-12(fp)
 202f5f8:	10000426 	beq	r2,zero,202f60c <sbappendrecord+0x88>
      m->m_act = m0;
 202f5fc:	e0bffd17 	ldw	r2,-12(fp)
 202f600:	e0ffff17 	ldw	r3,-4(fp)
 202f604:	10c00715 	stw	r3,28(r2)
 202f608:	00000306 	br	202f618 <sbappendrecord+0x94>
   else
      sb->sb_mb = m0;
 202f60c:	e0bffe17 	ldw	r2,-8(fp)
 202f610:	e0ffff17 	ldw	r3,-4(fp)
 202f614:	10c00615 	stw	r3,24(r2)
   m = m0->m_next;
 202f618:	e0bfff17 	ldw	r2,-4(fp)
 202f61c:	10800617 	ldw	r2,24(r2)
 202f620:	e0bffd15 	stw	r2,-12(fp)
   m0->m_next = 0;
 202f624:	e0bfff17 	ldw	r2,-4(fp)
 202f628:	10000615 	stw	zero,24(r2)
   sbcompress(sb, m, m0);
 202f62c:	e13ffe17 	ldw	r4,-8(fp)
 202f630:	e17ffd17 	ldw	r5,-12(fp)
 202f634:	e1bfff17 	ldw	r6,-4(fp)
 202f638:	202f8340 	call	202f834 <sbcompress>
   EXIT_CRIT_SECTION(sb);
 202f63c:	20288580 	call	2028858 <irq_Unmask>
 202f640:	00000106 	br	202f648 <sbappendrecord+0xc4>
   struct mbuf *  m0)
{
   struct mbuf *  m;

   if (m0 == 0)
      return;
 202f644:	0001883a 	nop
      sb->sb_mb = m0;
   m = m0->m_next;
   m0->m_next = 0;
   sbcompress(sb, m, m0);
   EXIT_CRIT_SECTION(sb);
}
 202f648:	e037883a 	mov	sp,fp
 202f64c:	dfc00117 	ldw	ra,4(sp)
 202f650:	df000017 	ldw	fp,0(sp)
 202f654:	dec00204 	addi	sp,sp,8
 202f658:	f800283a 	ret

0202f65c <sbappendaddr>:

int
sbappendaddr(struct sockbuf * sb, 
   struct sockaddr * asa,
   struct mbuf *  m0)
{
 202f65c:	defff804 	addi	sp,sp,-32
 202f660:	dfc00715 	stw	ra,28(sp)
 202f664:	df000615 	stw	fp,24(sp)
 202f668:	df000604 	addi	fp,sp,24
 202f66c:	e13ffd15 	stw	r4,-12(fp)
 202f670:	e17ffe15 	stw	r5,-8(fp)
 202f674:	e1bfff15 	stw	r6,-4(fp)
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);
 202f678:	00800404 	movi	r2,16
 202f67c:	e0bffc15 	stw	r2,-16(fp)

   ENTER_CRIT_SECTION(sb);
 202f680:	20287fc0 	call	20287fc <irq_Mask>
   for (m = m0; m; m = m->m_next)
 202f684:	e0bfff17 	ldw	r2,-4(fp)
 202f688:	e0bffa15 	stw	r2,-24(fp)
 202f68c:	00000806 	br	202f6b0 <sbappendaddr+0x54>
      space += m->m_len;
 202f690:	e0bffa17 	ldw	r2,-24(fp)
 202f694:	10c00217 	ldw	r3,8(r2)
 202f698:	e0bffc17 	ldw	r2,-16(fp)
 202f69c:	1885883a 	add	r2,r3,r2
 202f6a0:	e0bffc15 	stw	r2,-16(fp)
{
   struct mbuf *  m, *  n;
   int   space =  sizeof   (*asa);

   ENTER_CRIT_SECTION(sb);
   for (m = m0; m; m = m->m_next)
 202f6a4:	e0bffa17 	ldw	r2,-24(fp)
 202f6a8:	10800617 	ldw	r2,24(r2)
 202f6ac:	e0bffa15 	stw	r2,-24(fp)
 202f6b0:	e0bffa17 	ldw	r2,-24(fp)
 202f6b4:	103ff61e 	bne	r2,zero,202f690 <sbappendaddr+0x34>
      space += m->m_len;
   if (space > (int)sbspace(sb))
 202f6b8:	e0bffd17 	ldw	r2,-12(fp)
 202f6bc:	10800117 	ldw	r2,4(r2)
 202f6c0:	1007883a 	mov	r3,r2
 202f6c4:	e0bffd17 	ldw	r2,-12(fp)
 202f6c8:	10800017 	ldw	r2,0(r2)
 202f6cc:	1885c83a 	sub	r2,r3,r2
 202f6d0:	10000616 	blt	r2,zero,202f6ec <sbappendaddr+0x90>
 202f6d4:	e0bffd17 	ldw	r2,-12(fp)
 202f6d8:	10c00117 	ldw	r3,4(r2)
 202f6dc:	e0bffd17 	ldw	r2,-12(fp)
 202f6e0:	10800017 	ldw	r2,0(r2)
 202f6e4:	1885c83a 	sub	r2,r3,r2
 202f6e8:	00000106 	br	202f6f0 <sbappendaddr+0x94>
 202f6ec:	0005883a 	mov	r2,zero
 202f6f0:	e0fffc17 	ldw	r3,-16(fp)
 202f6f4:	10c0030e 	bge	r2,r3,202f704 <sbappendaddr+0xa8>
   {
      EXIT_CRIT_SECTION(sb);
 202f6f8:	20288580 	call	2028858 <irq_Unmask>
      return (0);
 202f6fc:	0005883a 	mov	r2,zero
 202f700:	00004706 	br	202f820 <sbappendaddr+0x1c4>
   }
   if ((m = m_getwithdata (MT_SONAME, sizeof (struct sockaddr))) == NULL)
 202f704:	01000244 	movi	r4,9
 202f708:	01400404 	movi	r5,16
 202f70c:	20293d80 	call	20293d8 <m_getnbuf>
 202f710:	e0bffa15 	stw	r2,-24(fp)
 202f714:	e0bffa17 	ldw	r2,-24(fp)
 202f718:	1000031e 	bne	r2,zero,202f728 <sbappendaddr+0xcc>
   {
      EXIT_CRIT_SECTION(sb);
 202f71c:	20288580 	call	2028858 <irq_Unmask>
      return 0;
 202f720:	0005883a 	mov	r2,zero
 202f724:	00003e06 	br	202f820 <sbappendaddr+0x1c4>
   }
   *mtod(m, struct sockaddr *) = *asa;
 202f728:	e0bffa17 	ldw	r2,-24(fp)
 202f72c:	10800317 	ldw	r2,12(r2)
 202f730:	e0fffe17 	ldw	r3,-8(fp)
 202f734:	1900000b 	ldhu	r4,0(r3)
 202f738:	1100000d 	sth	r4,0(r2)
 202f73c:	1900008b 	ldhu	r4,2(r3)
 202f740:	1100008d 	sth	r4,2(r2)
 202f744:	1900010b 	ldhu	r4,4(r3)
 202f748:	1100010d 	sth	r4,4(r2)
 202f74c:	1900018b 	ldhu	r4,6(r3)
 202f750:	1100018d 	sth	r4,6(r2)
 202f754:	1900020b 	ldhu	r4,8(r3)
 202f758:	1100020d 	sth	r4,8(r2)
 202f75c:	1900028b 	ldhu	r4,10(r3)
 202f760:	1100028d 	sth	r4,10(r2)
 202f764:	1900030b 	ldhu	r4,12(r3)
 202f768:	1100030d 	sth	r4,12(r2)
 202f76c:	18c0038b 	ldhu	r3,14(r3)
 202f770:	10c0038d 	sth	r3,14(r2)
   m->m_len = sizeof (*asa);
 202f774:	e0bffa17 	ldw	r2,-24(fp)
 202f778:	00c00404 	movi	r3,16
 202f77c:	10c00215 	stw	r3,8(r2)
   sballoc (sb, m);
 202f780:	e0bffd17 	ldw	r2,-12(fp)
 202f784:	10c00017 	ldw	r3,0(r2)
 202f788:	e0bffa17 	ldw	r2,-24(fp)
 202f78c:	10800217 	ldw	r2,8(r2)
 202f790:	1887883a 	add	r3,r3,r2
 202f794:	e0bffd17 	ldw	r2,-12(fp)
 202f798:	10c00015 	stw	r3,0(r2)
   if ((n = sb->sb_mb) != NULL) 
 202f79c:	e0bffd17 	ldw	r2,-12(fp)
 202f7a0:	10800617 	ldw	r2,24(r2)
 202f7a4:	e0bffb15 	stw	r2,-20(fp)
 202f7a8:	e0bffb17 	ldw	r2,-20(fp)
 202f7ac:	10000b26 	beq	r2,zero,202f7dc <sbappendaddr+0x180>
   {
      while (n->m_act)
 202f7b0:	00000306 	br	202f7c0 <sbappendaddr+0x164>
         n = n->m_act;
 202f7b4:	e0bffb17 	ldw	r2,-20(fp)
 202f7b8:	10800717 	ldw	r2,28(r2)
 202f7bc:	e0bffb15 	stw	r2,-20(fp)
   *mtod(m, struct sockaddr *) = *asa;
   m->m_len = sizeof (*asa);
   sballoc (sb, m);
   if ((n = sb->sb_mb) != NULL) 
   {
      while (n->m_act)
 202f7c0:	e0bffb17 	ldw	r2,-20(fp)
 202f7c4:	10800717 	ldw	r2,28(r2)
 202f7c8:	103ffa1e 	bne	r2,zero,202f7b4 <sbappendaddr+0x158>
         n = n->m_act;
      n->m_act = m;
 202f7cc:	e0bffb17 	ldw	r2,-20(fp)
 202f7d0:	e0fffa17 	ldw	r3,-24(fp)
 202f7d4:	10c00715 	stw	r3,28(r2)
 202f7d8:	00000306 	br	202f7e8 <sbappendaddr+0x18c>
   } else
      sb->sb_mb = m;
 202f7dc:	e0bffd17 	ldw	r2,-12(fp)
 202f7e0:	e0fffa17 	ldw	r3,-24(fp)
 202f7e4:	10c00615 	stw	r3,24(r2)
   if (m->m_next)
 202f7e8:	e0bffa17 	ldw	r2,-24(fp)
 202f7ec:	10800617 	ldw	r2,24(r2)
 202f7f0:	10000326 	beq	r2,zero,202f800 <sbappendaddr+0x1a4>
      m = m->m_next;
 202f7f4:	e0bffa17 	ldw	r2,-24(fp)
 202f7f8:	10800617 	ldw	r2,24(r2)
 202f7fc:	e0bffa15 	stw	r2,-24(fp)
   if (m0)
 202f800:	e0bfff17 	ldw	r2,-4(fp)
 202f804:	10000426 	beq	r2,zero,202f818 <sbappendaddr+0x1bc>
      sbcompress(sb, m0, m);
 202f808:	e13ffd17 	ldw	r4,-12(fp)
 202f80c:	e17fff17 	ldw	r5,-4(fp)
 202f810:	e1bffa17 	ldw	r6,-24(fp)
 202f814:	202f8340 	call	202f834 <sbcompress>

   EXIT_CRIT_SECTION(sb);
 202f818:	20288580 	call	2028858 <irq_Unmask>
   return (1);
 202f81c:	00800044 	movi	r2,1
}
 202f820:	e037883a 	mov	sp,fp
 202f824:	dfc00117 	ldw	ra,4(sp)
 202f828:	df000017 	ldw	fp,0(sp)
 202f82c:	dec00204 	addi	sp,sp,8
 202f830:	f800283a 	ret

0202f834 <sbcompress>:

void
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{
 202f834:	defffb04 	addi	sp,sp,-20
 202f838:	dfc00415 	stw	ra,16(sp)
 202f83c:	df000315 	stw	fp,12(sp)
 202f840:	df000304 	addi	fp,sp,12
 202f844:	e13ffd15 	stw	r4,-12(fp)
 202f848:	e17ffe15 	stw	r5,-8(fp)
 202f84c:	e1bfff15 	stw	r6,-4(fp)

   while (m) 
 202f850:	00006706 	br	202f9f0 <sbcompress+0x1bc>
   {
      if (m->m_len == 0) 
 202f854:	e0bffe17 	ldw	r2,-8(fp)
 202f858:	10800217 	ldw	r2,8(r2)
 202f85c:	1000041e 	bne	r2,zero,202f870 <sbcompress+0x3c>
      {
         m = m_free(m);
 202f860:	e13ffe17 	ldw	r4,-8(fp)
 202f864:	20295600 	call	2029560 <m_free>
 202f868:	e0bffe15 	stw	r2,-8(fp)
         continue;
 202f86c:	00006006 	br	202f9f0 <sbcompress+0x1bc>
      }
      if (m->m_type != MT_RXDATA && 
 202f870:	e0bffe17 	ldw	r2,-8(fp)
 202f874:	10800817 	ldw	r2,32(r2)
 202f878:	10800060 	cmpeqi	r2,r2,1
 202f87c:	1000111e 	bne	r2,zero,202f8c4 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
 202f880:	e0bffe17 	ldw	r2,-8(fp)
 202f884:	10800817 	ldw	r2,32(r2)
      if (m->m_len == 0) 
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
 202f888:	108000a0 	cmpeqi	r2,r2,2
 202f88c:	10000d1e 	bne	r2,zero,202f8c4 <sbcompress+0x90>
          m->m_type != MT_TXDATA && 
          m->m_type != MT_SONAME) 
 202f890:	e0bffe17 	ldw	r2,-8(fp)
 202f894:	10800817 	ldw	r2,32(r2)
      {
         m = m_free(m);
         continue;
      }
      if (m->m_type != MT_RXDATA && 
          m->m_type != MT_TXDATA && 
 202f898:	10800260 	cmpeqi	r2,r2,9
 202f89c:	1000091e 	bne	r2,zero,202f8c4 <sbcompress+0x90>
          m->m_type != MT_SONAME) 
      {
         dprintf ("sbcomp:bad type %d\n", m->m_type);
 202f8a0:	e0bffe17 	ldw	r2,-8(fp)
 202f8a4:	10800817 	ldw	r2,32(r2)
 202f8a8:	01008174 	movhi	r4,517
 202f8ac:	213d6204 	addi	r4,r4,-2680
 202f8b0:	100b883a 	mov	r5,r2
 202f8b4:	2006a240 	call	2006a24 <printf>
         panic ("sbcomp:bad");
 202f8b8:	01008174 	movhi	r4,517
 202f8bc:	213d6704 	addi	r4,r4,-2660
 202f8c0:	2026bf80 	call	2026bf8 <panic>
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 202f8c4:	e0bfff17 	ldw	r2,-4(fp)
 202f8c8:	10003226 	beq	r2,zero,202f994 <sbcompress+0x160>
 202f8cc:	e0bffd17 	ldw	r2,-12(fp)
 202f8d0:	1080070b 	ldhu	r2,28(r2)
 202f8d4:	10bfffcc 	andi	r2,r2,65535
 202f8d8:	1080200c 	andi	r2,r2,128
 202f8dc:	10002d26 	beq	r2,zero,202f994 <sbcompress+0x160>
          ((n->m_len + m->m_len) <
 202f8e0:	e0bfff17 	ldw	r2,-4(fp)
 202f8e4:	10c00217 	ldw	r3,8(r2)
 202f8e8:	e0bffe17 	ldw	r2,-8(fp)
 202f8ec:	10800217 	ldw	r2,8(r2)
 202f8f0:	1887883a 	add	r3,r3,r2
          n->m_memsz - (n->m_data - n->m_base) ) ) 
 202f8f4:	e0bfff17 	ldw	r2,-4(fp)
 202f8f8:	11000517 	ldw	r4,20(r2)
 202f8fc:	e0bfff17 	ldw	r2,-4(fp)
 202f900:	10800417 	ldw	r2,16(r2)
 202f904:	100b883a 	mov	r5,r2
 202f908:	e0bfff17 	ldw	r2,-4(fp)
 202f90c:	10800317 	ldw	r2,12(r2)
 202f910:	2885c83a 	sub	r2,r5,r2
 202f914:	2085883a 	add	r2,r4,r2
      /* If there is room for all the data in M in N, then
       * just copy the data to N.  Note that sbdrop will 
       * increment the n->m_data pointer, so that we must
       * correct n->m_memsz.
       */
      if ( n && (sb->sb_flags & SB_MBCOMP) &&
 202f918:	18801e2e 	bgeu	r3,r2,202f994 <sbcompress+0x160>
          ((n->m_len + m->m_len) <
          n->m_memsz - (n->m_data - n->m_base) ) ) 
      {
         MEMCPY(n->m_data+n->m_len, m->m_data, m->m_len);
 202f91c:	e0bfff17 	ldw	r2,-4(fp)
 202f920:	10c00317 	ldw	r3,12(r2)
 202f924:	e0bfff17 	ldw	r2,-4(fp)
 202f928:	10800217 	ldw	r2,8(r2)
 202f92c:	1889883a 	add	r4,r3,r2
 202f930:	e0bffe17 	ldw	r2,-8(fp)
 202f934:	10c00317 	ldw	r3,12(r2)
 202f938:	e0bffe17 	ldw	r2,-8(fp)
 202f93c:	10800217 	ldw	r2,8(r2)
 202f940:	180b883a 	mov	r5,r3
 202f944:	100d883a 	mov	r6,r2
 202f948:	200660c0 	call	200660c <memcpy>
         sballoc(sb, m);
 202f94c:	e0bffd17 	ldw	r2,-12(fp)
 202f950:	10c00017 	ldw	r3,0(r2)
 202f954:	e0bffe17 	ldw	r2,-8(fp)
 202f958:	10800217 	ldw	r2,8(r2)
 202f95c:	1887883a 	add	r3,r3,r2
 202f960:	e0bffd17 	ldw	r2,-12(fp)
 202f964:	10c00015 	stw	r3,0(r2)
         n->m_len += m->m_len;
 202f968:	e0bfff17 	ldw	r2,-4(fp)
 202f96c:	10c00217 	ldw	r3,8(r2)
 202f970:	e0bffe17 	ldw	r2,-8(fp)
 202f974:	10800217 	ldw	r2,8(r2)
 202f978:	1887883a 	add	r3,r3,r2
 202f97c:	e0bfff17 	ldw	r2,-4(fp)
 202f980:	10c00215 	stw	r3,8(r2)
         m = m_free(m);
 202f984:	e13ffe17 	ldw	r4,-8(fp)
 202f988:	20295600 	call	2029560 <m_free>
 202f98c:	e0bffe15 	stw	r2,-8(fp)
         continue;
 202f990:	00001706 	br	202f9f0 <sbcompress+0x1bc>
      }
      sballoc(sb, m);
 202f994:	e0bffd17 	ldw	r2,-12(fp)
 202f998:	10c00017 	ldw	r3,0(r2)
 202f99c:	e0bffe17 	ldw	r2,-8(fp)
 202f9a0:	10800217 	ldw	r2,8(r2)
 202f9a4:	1887883a 	add	r3,r3,r2
 202f9a8:	e0bffd17 	ldw	r2,-12(fp)
 202f9ac:	10c00015 	stw	r3,0(r2)
      if (n)
 202f9b0:	e0bfff17 	ldw	r2,-4(fp)
 202f9b4:	10000426 	beq	r2,zero,202f9c8 <sbcompress+0x194>
         n->m_next = m;
 202f9b8:	e0bfff17 	ldw	r2,-4(fp)
 202f9bc:	e0fffe17 	ldw	r3,-8(fp)
 202f9c0:	10c00615 	stw	r3,24(r2)
 202f9c4:	00000306 	br	202f9d4 <sbcompress+0x1a0>
      else
         sb->sb_mb = m;
 202f9c8:	e0bffd17 	ldw	r2,-12(fp)
 202f9cc:	e0fffe17 	ldw	r3,-8(fp)
 202f9d0:	10c00615 	stw	r3,24(r2)
      n = m;
 202f9d4:	e0bffe17 	ldw	r2,-8(fp)
 202f9d8:	e0bfff15 	stw	r2,-4(fp)
      m = m->m_next;
 202f9dc:	e0bffe17 	ldw	r2,-8(fp)
 202f9e0:	10800617 	ldw	r2,24(r2)
 202f9e4:	e0bffe15 	stw	r2,-8(fp)
      n->m_next = 0;
 202f9e8:	e0bfff17 	ldw	r2,-4(fp)
 202f9ec:	10000615 	stw	zero,24(r2)
sbcompress(struct sockbuf * sb, 
   struct mbuf *  m,
   struct mbuf *  n)
{

   while (m) 
 202f9f0:	e0bffe17 	ldw	r2,-8(fp)
 202f9f4:	103f971e 	bne	r2,zero,202f854 <sbcompress+0x20>
         sb->sb_mb = m;
      n = m;
      m = m->m_next;
      n->m_next = 0;
   }
}
 202f9f8:	e037883a 	mov	sp,fp
 202f9fc:	dfc00117 	ldw	ra,4(sp)
 202fa00:	df000017 	ldw	fp,0(sp)
 202fa04:	dec00204 	addi	sp,sp,8
 202fa08:	f800283a 	ret

0202fa0c <sbflush>:
 * RETURNS: 
 */

void
sbflush(struct sockbuf * sb)
{
 202fa0c:	defffd04 	addi	sp,sp,-12
 202fa10:	dfc00215 	stw	ra,8(sp)
 202fa14:	df000115 	stw	fp,4(sp)
 202fa18:	df000104 	addi	fp,sp,4
 202fa1c:	e13fff15 	stw	r4,-4(fp)
   ENTER_CRIT_SECTION(sb);
 202fa20:	20287fc0 	call	20287fc <irq_Mask>
   if (sb->sb_flags & SB_LOCK)
 202fa24:	e0bfff17 	ldw	r2,-4(fp)
 202fa28:	1080070b 	ldhu	r2,28(r2)
 202fa2c:	10bfffcc 	andi	r2,r2,65535
 202fa30:	1080004c 	andi	r2,r2,1
 202fa34:	10000a26 	beq	r2,zero,202fa60 <sbflush+0x54>
      panic("sbflush");
 202fa38:	01008174 	movhi	r4,517
 202fa3c:	213d6a04 	addi	r4,r4,-2648
 202fa40:	2026bf80 	call	2026bf8 <panic>
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 202fa44:	00000606 	br	202fa60 <sbflush+0x54>
      sbdrop (sb, (int)sb->sb_cc);
 202fa48:	e0bfff17 	ldw	r2,-4(fp)
 202fa4c:	10800017 	ldw	r2,0(r2)
 202fa50:	e13fff17 	ldw	r4,-4(fp)
 202fa54:	100b883a 	mov	r5,r2
 202fa58:	202fa940 	call	202fa94 <sbdrop>
 202fa5c:	00000106 	br	202fa64 <sbflush+0x58>
sbflush(struct sockbuf * sb)
{
   ENTER_CRIT_SECTION(sb);
   if (sb->sb_flags & SB_LOCK)
      panic("sbflush");
   while ((sb->sb_mbcnt) || (sb->sb_cc))
 202fa60:	0001883a 	nop
 202fa64:	e0bfff17 	ldw	r2,-4(fp)
 202fa68:	10800217 	ldw	r2,8(r2)
 202fa6c:	103ff61e 	bne	r2,zero,202fa48 <sbflush+0x3c>
 202fa70:	e0bfff17 	ldw	r2,-4(fp)
 202fa74:	10800017 	ldw	r2,0(r2)
 202fa78:	103ff31e 	bne	r2,zero,202fa48 <sbflush+0x3c>
      sbdrop (sb, (int)sb->sb_cc);
   EXIT_CRIT_SECTION(sb);
 202fa7c:	20288580 	call	2028858 <irq_Unmask>
}
 202fa80:	e037883a 	mov	sp,fp
 202fa84:	dfc00117 	ldw	ra,4(sp)
 202fa88:	df000017 	ldw	fp,0(sp)
 202fa8c:	dec00204 	addi	sp,sp,8
 202fa90:	f800283a 	ret

0202fa94 <sbdrop>:
 * RETURNS: 
 */

void
sbdrop(struct sockbuf * sb, int len)
{
 202fa94:	defff904 	addi	sp,sp,-28
 202fa98:	dfc00615 	stw	ra,24(sp)
 202fa9c:	df000515 	stw	fp,20(sp)
 202faa0:	df000504 	addi	fp,sp,20
 202faa4:	e13ffe15 	stw	r4,-8(fp)
 202faa8:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m, *  mn;
   struct mbuf *  next;

   ENTER_CRIT_SECTION(sb);
 202faac:	20287fc0 	call	20287fc <irq_Mask>
   if ((m = sb->sb_mb) != NULL)
 202fab0:	e0bffe17 	ldw	r2,-8(fp)
 202fab4:	10800617 	ldw	r2,24(r2)
 202fab8:	e0bffb15 	stw	r2,-20(fp)
 202fabc:	e0bffb17 	ldw	r2,-20(fp)
 202fac0:	10000426 	beq	r2,zero,202fad4 <sbdrop+0x40>
      next = m->m_act;
 202fac4:	e0bffb17 	ldw	r2,-20(fp)
 202fac8:	10800717 	ldw	r2,28(r2)
 202facc:	e0bffc15 	stw	r2,-16(fp)
   else
      next = NULL;
   while (len > 0) 
 202fad0:	00003806 	br	202fbb4 <sbdrop+0x120>

   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
 202fad4:	e03ffc15 	stw	zero,-16(fp)
   while (len > 0) 
 202fad8:	00003606 	br	202fbb4 <sbdrop+0x120>
   {
      if (m == 0) 
 202fadc:	e0bffb17 	ldw	r2,-20(fp)
 202fae0:	10000b1e 	bne	r2,zero,202fb10 <sbdrop+0x7c>
      {
         if (next == 0)
 202fae4:	e0bffc17 	ldw	r2,-16(fp)
 202fae8:	1000031e 	bne	r2,zero,202faf8 <sbdrop+0x64>
            panic("sbdrop");
 202faec:	01008174 	movhi	r4,517
 202faf0:	213d6c04 	addi	r4,r4,-2640
 202faf4:	2026bf80 	call	2026bf8 <panic>
         m = next;
 202faf8:	e0bffc17 	ldw	r2,-16(fp)
 202fafc:	e0bffb15 	stw	r2,-20(fp)
         next = m->m_act;
 202fb00:	e0bffb17 	ldw	r2,-20(fp)
 202fb04:	10800717 	ldw	r2,28(r2)
 202fb08:	e0bffc15 	stw	r2,-16(fp)
         continue;
 202fb0c:	00002906 	br	202fbb4 <sbdrop+0x120>
      }
      if (m->m_len > (unsigned)len) 
 202fb10:	e0bffb17 	ldw	r2,-20(fp)
 202fb14:	10800217 	ldw	r2,8(r2)
 202fb18:	e0ffff17 	ldw	r3,-4(fp)
 202fb1c:	1880142e 	bgeu	r3,r2,202fb70 <sbdrop+0xdc>
      {
         m->m_len -= len;
 202fb20:	e0bffb17 	ldw	r2,-20(fp)
 202fb24:	10c00217 	ldw	r3,8(r2)
 202fb28:	e0bfff17 	ldw	r2,-4(fp)
 202fb2c:	1887c83a 	sub	r3,r3,r2
 202fb30:	e0bffb17 	ldw	r2,-20(fp)
 202fb34:	10c00215 	stw	r3,8(r2)
         m->m_data += len;
 202fb38:	e0bffb17 	ldw	r2,-20(fp)
 202fb3c:	10c00317 	ldw	r3,12(r2)
 202fb40:	e0bfff17 	ldw	r2,-4(fp)
 202fb44:	1887883a 	add	r3,r3,r2
 202fb48:	e0bffb17 	ldw	r2,-20(fp)
 202fb4c:	10c00315 	stw	r3,12(r2)
         sb->sb_cc -= len;
 202fb50:	e0bffe17 	ldw	r2,-8(fp)
 202fb54:	10c00017 	ldw	r3,0(r2)
 202fb58:	e0bfff17 	ldw	r2,-4(fp)
 202fb5c:	1887c83a 	sub	r3,r3,r2
 202fb60:	e0bffe17 	ldw	r2,-8(fp)
 202fb64:	10c00015 	stw	r3,0(r2)
         break;
 202fb68:	0001883a 	nop
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 202fb6c:	00002006 	br	202fbf0 <sbdrop+0x15c>
         m->m_len -= len;
         m->m_data += len;
         sb->sb_cc -= len;
         break;
      }
      len -= m->m_len;
 202fb70:	e0ffff17 	ldw	r3,-4(fp)
 202fb74:	e0bffb17 	ldw	r2,-20(fp)
 202fb78:	10800217 	ldw	r2,8(r2)
 202fb7c:	1885c83a 	sub	r2,r3,r2
 202fb80:	e0bfff15 	stw	r2,-4(fp)
      sbfree (sb, m);
 202fb84:	e0bffe17 	ldw	r2,-8(fp)
 202fb88:	10c00017 	ldw	r3,0(r2)
 202fb8c:	e0bffb17 	ldw	r2,-20(fp)
 202fb90:	10800217 	ldw	r2,8(r2)
 202fb94:	1887c83a 	sub	r3,r3,r2
 202fb98:	e0bffe17 	ldw	r2,-8(fp)
 202fb9c:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 202fba0:	e13ffb17 	ldw	r4,-20(fp)
 202fba4:	20295600 	call	2029560 <m_free>
 202fba8:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 202fbac:	e0bffd17 	ldw	r2,-12(fp)
 202fbb0:	e0bffb15 	stw	r2,-20(fp)
   ENTER_CRIT_SECTION(sb);
   if ((m = sb->sb_mb) != NULL)
      next = m->m_act;
   else
      next = NULL;
   while (len > 0) 
 202fbb4:	e0bfff17 	ldw	r2,-4(fp)
 202fbb8:	00bfc816 	blt	zero,r2,202fadc <sbdrop+0x48>
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 202fbbc:	00000c06 	br	202fbf0 <sbdrop+0x15c>
   {
      sbfree(sb, m);
 202fbc0:	e0bffe17 	ldw	r2,-8(fp)
 202fbc4:	10c00017 	ldw	r3,0(r2)
 202fbc8:	e0bffb17 	ldw	r2,-20(fp)
 202fbcc:	10800217 	ldw	r2,8(r2)
 202fbd0:	1887c83a 	sub	r3,r3,r2
 202fbd4:	e0bffe17 	ldw	r2,-8(fp)
 202fbd8:	10c00015 	stw	r3,0(r2)
      MFREE(m, mn);
 202fbdc:	e13ffb17 	ldw	r4,-20(fp)
 202fbe0:	20295600 	call	2029560 <m_free>
 202fbe4:	e0bffd15 	stw	r2,-12(fp)
      m = mn;
 202fbe8:	e0bffd17 	ldw	r2,-12(fp)
 202fbec:	e0bffb15 	stw	r2,-20(fp)
      len -= m->m_len;
      sbfree (sb, m);
      MFREE(m, mn);
      m = mn;
   }
   while (m && m->m_len == 0) 
 202fbf0:	e0bffb17 	ldw	r2,-20(fp)
 202fbf4:	10000326 	beq	r2,zero,202fc04 <sbdrop+0x170>
 202fbf8:	e0bffb17 	ldw	r2,-20(fp)
 202fbfc:	10800217 	ldw	r2,8(r2)
 202fc00:	103fef26 	beq	r2,zero,202fbc0 <sbdrop+0x12c>
   {
      sbfree(sb, m);
      MFREE(m, mn);
      m = mn;
   }
   if (m) 
 202fc04:	e0bffb17 	ldw	r2,-20(fp)
 202fc08:	10000726 	beq	r2,zero,202fc28 <sbdrop+0x194>
   {
      sb->sb_mb = m;
 202fc0c:	e0bffe17 	ldw	r2,-8(fp)
 202fc10:	e0fffb17 	ldw	r3,-20(fp)
 202fc14:	10c00615 	stw	r3,24(r2)
      m->m_act = next;
 202fc18:	e0bffb17 	ldw	r2,-20(fp)
 202fc1c:	e0fffc17 	ldw	r3,-16(fp)
 202fc20:	10c00715 	stw	r3,28(r2)
 202fc24:	00000306 	br	202fc34 <sbdrop+0x1a0>
   } else
      sb->sb_mb = next;
 202fc28:	e0bffe17 	ldw	r2,-8(fp)
 202fc2c:	e0fffc17 	ldw	r3,-16(fp)
 202fc30:	10c00615 	stw	r3,24(r2)
   EXIT_CRIT_SECTION(sb);
 202fc34:	20288580 	call	2028858 <irq_Unmask>
}
 202fc38:	e037883a 	mov	sp,fp
 202fc3c:	dfc00117 	ldw	ra,4(sp)
 202fc40:	df000017 	ldw	fp,0(sp)
 202fc44:	dec00204 	addi	sp,sp,8
 202fc48:	f800283a 	ret

0202fc4c <sbdropend>:
 * RETURNS: 
 */

void
sbdropend(struct sockbuf * sb, struct mbuf * m)
{
 202fc4c:	defff904 	addi	sp,sp,-28
 202fc50:	dfc00615 	stw	ra,24(sp)
 202fc54:	df000515 	stw	fp,20(sp)
 202fc58:	df000504 	addi	fp,sp,20
 202fc5c:	e13ffe15 	stw	r4,-8(fp)
 202fc60:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  nmb, *   pmb;
   int   len;
   ENTER_CRIT_SECTION(sb);
 202fc64:	20287fc0 	call	20287fc <irq_Mask>
   len = mbuf_len(m);
 202fc68:	e13fff17 	ldw	r4,-4(fp)
 202fc6c:	2029b780 	call	2029b78 <mbuf_len>
 202fc70:	e0bffd15 	stw	r2,-12(fp)
   if (len > 0)
 202fc74:	e0bffd17 	ldw	r2,-12(fp)
 202fc78:	0080070e 	bge	zero,r2,202fc98 <sbdropend+0x4c>
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
 202fc7c:	e0bffe17 	ldw	r2,-8(fp)
 202fc80:	10c00617 	ldw	r3,24(r2)
 202fc84:	e0bffd17 	ldw	r2,-12(fp)
 202fc88:	0085c83a 	sub	r2,zero,r2
 202fc8c:	1809883a 	mov	r4,r3
 202fc90:	100b883a 	mov	r5,r2
 202fc94:	20299a80 	call	20299a8 <m_adj>
   nmb = sb->sb_mb;
 202fc98:	e0bffe17 	ldw	r2,-8(fp)
 202fc9c:	10800617 	ldw	r2,24(r2)
 202fca0:	e0bffb15 	stw	r2,-20(fp)
   pmb = NULL;
 202fca4:	e03ffc15 	stw	zero,-16(fp)
   if (sb->sb_mb->m_len == 0)
 202fca8:	e0bffe17 	ldw	r2,-8(fp)
 202fcac:	10800617 	ldw	r2,24(r2)
 202fcb0:	10800217 	ldw	r2,8(r2)
 202fcb4:	1000081e 	bne	r2,zero,202fcd8 <sbdropend+0x8c>
      sb->sb_mb = NULL;
 202fcb8:	e0bffe17 	ldw	r2,-8(fp)
 202fcbc:	10000615 	stw	zero,24(r2)
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 202fcc0:	00000506 	br	202fcd8 <sbdropend+0x8c>
   {
      pmb = nmb;  /* Remember previous */
 202fcc4:	e0bffb17 	ldw	r2,-20(fp)
 202fcc8:	e0bffc15 	stw	r2,-16(fp)
      nmb = nmb->m_next;    
 202fccc:	e0bffb17 	ldw	r2,-20(fp)
 202fcd0:	10800617 	ldw	r2,24(r2)
 202fcd4:	e0bffb15 	stw	r2,-20(fp)
      m_adj(sb->sb_mb, -len); /* Adjust the lengths of the mbuf chain */
   nmb = sb->sb_mb;
   pmb = NULL;
   if (sb->sb_mb->m_len == 0)
      sb->sb_mb = NULL;
   while (nmb && (nmb->m_len !=0))  /* Release mbufs that have a 0 len */
 202fcd8:	e0bffb17 	ldw	r2,-20(fp)
 202fcdc:	10000326 	beq	r2,zero,202fcec <sbdropend+0xa0>
 202fce0:	e0bffb17 	ldw	r2,-20(fp)
 202fce4:	10800217 	ldw	r2,8(r2)
 202fce8:	103ff61e 	bne	r2,zero,202fcc4 <sbdropend+0x78>
   {
      pmb = nmb;  /* Remember previous */
      nmb = nmb->m_next;    
   }
   if (nmb && (nmb->m_len == 0)) /* Assume once 0 len found, all the rest */
 202fcec:	e0bffb17 	ldw	r2,-20(fp)
 202fcf0:	10000926 	beq	r2,zero,202fd18 <sbdropend+0xcc>
 202fcf4:	e0bffb17 	ldw	r2,-20(fp)
 202fcf8:	10800217 	ldw	r2,8(r2)
 202fcfc:	1000061e 	bne	r2,zero,202fd18 <sbdropend+0xcc>
   {                             /* are zeroes */ 
      if (pmb != NULL)
 202fd00:	e0bffc17 	ldw	r2,-16(fp)
 202fd04:	10000226 	beq	r2,zero,202fd10 <sbdropend+0xc4>
         pmb->m_next = NULL;
 202fd08:	e0bffc17 	ldw	r2,-16(fp)
 202fd0c:	10000615 	stw	zero,24(r2)
      m_freem(nmb);            
 202fd10:	e13ffb17 	ldw	r4,-20(fp)
 202fd14:	20296780 	call	2029678 <m_freem>
   }
   sb->sb_cc -= len;       /* Do a sbfree using the len */
 202fd18:	e0bffe17 	ldw	r2,-8(fp)
 202fd1c:	10c00017 	ldw	r3,0(r2)
 202fd20:	e0bffd17 	ldw	r2,-12(fp)
 202fd24:	1887c83a 	sub	r3,r3,r2
 202fd28:	e0bffe17 	ldw	r2,-8(fp)
 202fd2c:	10c00015 	stw	r3,0(r2)
   EXIT_CRIT_SECTION(sb);
 202fd30:	20288580 	call	2028858 <irq_Unmask>
}
 202fd34:	e037883a 	mov	sp,fp
 202fd38:	dfc00117 	ldw	ra,4(sp)
 202fd3c:	df000017 	ldw	fp,0(sp)
 202fd40:	dec00204 	addi	sp,sp,8
 202fd44:	f800283a 	ret

0202fd48 <sbdroprecord>:
 * RETURNS: 
 */

void
sbdroprecord(struct sockbuf * sb)
{
 202fd48:	defffb04 	addi	sp,sp,-20
 202fd4c:	dfc00415 	stw	ra,16(sp)
 202fd50:	df000315 	stw	fp,12(sp)
 202fd54:	df000304 	addi	fp,sp,12
 202fd58:	e13fff15 	stw	r4,-4(fp)
   struct mbuf *  m, *  mn;

   ENTER_CRIT_SECTION(sb);
 202fd5c:	20287fc0 	call	20287fc <irq_Mask>
   m = sb->sb_mb;
 202fd60:	e0bfff17 	ldw	r2,-4(fp)
 202fd64:	10800617 	ldw	r2,24(r2)
 202fd68:	e0bffd15 	stw	r2,-12(fp)
   if (m)
 202fd6c:	e0bffd17 	ldw	r2,-12(fp)
 202fd70:	10001226 	beq	r2,zero,202fdbc <sbdroprecord+0x74>
   {  sb->sb_mb = m->m_act;
 202fd74:	e0bffd17 	ldw	r2,-12(fp)
 202fd78:	10c00717 	ldw	r3,28(r2)
 202fd7c:	e0bfff17 	ldw	r2,-4(fp)
 202fd80:	10c00615 	stw	r3,24(r2)
      do 
      {  sbfree(sb, m);
 202fd84:	e0bfff17 	ldw	r2,-4(fp)
 202fd88:	10c00017 	ldw	r3,0(r2)
 202fd8c:	e0bffd17 	ldw	r2,-12(fp)
 202fd90:	10800217 	ldw	r2,8(r2)
 202fd94:	1887c83a 	sub	r3,r3,r2
 202fd98:	e0bfff17 	ldw	r2,-4(fp)
 202fd9c:	10c00015 	stw	r3,0(r2)
         MFREE(m, mn);
 202fda0:	e13ffd17 	ldw	r4,-12(fp)
 202fda4:	20295600 	call	2029560 <m_free>
 202fda8:	e0bffe15 	stw	r2,-8(fp)
      } while ((m = mn) != NULL);
 202fdac:	e0bffe17 	ldw	r2,-8(fp)
 202fdb0:	e0bffd15 	stw	r2,-12(fp)
 202fdb4:	e0bffd17 	ldw	r2,-12(fp)
 202fdb8:	103ff21e 	bne	r2,zero,202fd84 <sbdroprecord+0x3c>
         }
   EXIT_CRIT_SECTION(sb);
 202fdbc:	20288580 	call	2028858 <irq_Unmask>
}
 202fdc0:	e037883a 	mov	sp,fp
 202fdc4:	dfc00117 	ldw	ra,4(sp)
 202fdc8:	df000017 	ldw	fp,0(sp)
 202fdcc:	dec00204 	addi	sp,sp,8
 202fdd0:	f800283a 	ret

0202fdd4 <t_select>:
int
t_select(fd_set * in,   /* lists of sockets to watch */
   fd_set * out,
   fd_set * ex,
   long  tv)   /* ticks to wait */
{
 202fdd4:	defe7204 	addi	sp,sp,-1592
 202fdd8:	dfc18d15 	stw	ra,1588(sp)
 202fddc:	df018c15 	stw	fp,1584(sp)
 202fde0:	df018c04 	addi	fp,sp,1584
 202fde4:	e13ffc15 	stw	r4,-16(fp)
 202fde8:	e17ffd15 	stw	r5,-12(fp)
 202fdec:	e1bffe15 	stw	r6,-8(fp)
 202fdf0:	e1ffff15 	stw	r7,-4(fp)
   fd_set obits[3], ibits [3];
   u_long   tmo;
   int   retval   =  0;
 202fdf4:	e03e7415 	stw	zero,-1584(fp)

   MEMSET(&obits, 0, sizeof(obits));
 202fdf8:	e0be7604 	addi	r2,fp,-1576
 202fdfc:	1009883a 	mov	r4,r2
 202fe00:	000b883a 	mov	r5,zero
 202fe04:	0180c304 	movi	r6,780
 202fe08:	200682c0 	call	200682c <memset>
   MEMSET(&ibits, 0, sizeof(ibits));
 202fe0c:	e0bf3904 	addi	r2,fp,-796
 202fe10:	1009883a 	mov	r4,r2
 202fe14:	000b883a 	mov	r5,zero
 202fe18:	0180c304 	movi	r6,780
 202fe1c:	200682c0 	call	200682c <memset>

   if (in)
 202fe20:	e0bffc17 	ldw	r2,-16(fp)
 202fe24:	10000526 	beq	r2,zero,202fe3c <t_select+0x68>
      MEMCPY(&ibits[0], in, sizeof(fd_set));
 202fe28:	e0bf3904 	addi	r2,fp,-796
 202fe2c:	1009883a 	mov	r4,r2
 202fe30:	e17ffc17 	ldw	r5,-16(fp)
 202fe34:	01804104 	movi	r6,260
 202fe38:	200660c0 	call	200660c <memcpy>
   if (out)
 202fe3c:	e0bffd17 	ldw	r2,-12(fp)
 202fe40:	10000626 	beq	r2,zero,202fe5c <t_select+0x88>
      MEMCPY(&ibits[1], out, sizeof(fd_set));
 202fe44:	e0bf3904 	addi	r2,fp,-796
 202fe48:	10804104 	addi	r2,r2,260
 202fe4c:	1009883a 	mov	r4,r2
 202fe50:	e17ffd17 	ldw	r5,-12(fp)
 202fe54:	01804104 	movi	r6,260
 202fe58:	200660c0 	call	200660c <memcpy>
   if (ex)
 202fe5c:	e0bffe17 	ldw	r2,-8(fp)
 202fe60:	10000626 	beq	r2,zero,202fe7c <t_select+0xa8>
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
 202fe64:	e0bf3904 	addi	r2,fp,-796
 202fe68:	10808204 	addi	r2,r2,520
 202fe6c:	1009883a 	mov	r4,r2
 202fe70:	e17ffe17 	ldw	r5,-8(fp)
 202fe74:	01804104 	movi	r6,260
 202fe78:	200660c0 	call	200660c <memcpy>
   tmo = cticks + tv;
 202fe7c:	00808174 	movhi	r2,517
 202fe80:	1090c904 	addi	r2,r2,17188
 202fe84:	10c00017 	ldw	r3,0(r2)
 202fe88:	e0bfff17 	ldw	r2,-4(fp)
 202fe8c:	1885883a 	add	r2,r3,r2
 202fe90:	e0be7515 	stw	r2,-1580(fp)

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 202fe94:	e0bf3917 	ldw	r2,-796(fp)
 202fe98:	10000c1e 	bne	r2,zero,202fecc <t_select+0xf8>
 202fe9c:	e0bf7a17 	ldw	r2,-536(fp)
 202fea0:	10000a1e 	bne	r2,zero,202fecc <t_select+0xf8>
       (ibits[2].fd_count == 0))
 202fea4:	e0bfbb17 	ldw	r2,-276(fp)
   if (ex)
      MEMCPY(&ibits[2], ex, sizeof(fd_set));
   tmo = cticks + tv;

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
 202fea8:	1000081e 	bne	r2,zero,202fecc <t_select+0xf8>
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 202feac:	e0bfff17 	ldw	r2,-4(fp)
 202feb0:	0080240e 	bge	zero,r2,202ff44 <t_select+0x170>
         while (tmo > cticks)
         {
            tk_yield();
         }
#else
         TK_SLEEP(tv);
 202feb4:	e0bfff17 	ldw	r2,-4(fp)
 202feb8:	10800044 	addi	r2,r2,1
 202febc:	10bfffcc 	andi	r2,r2,65535
 202fec0:	1009883a 	mov	r4,r2
 202fec4:	201e00c0 	call	201e00c <OSTimeDly>

   /* if all the fd_sets are empty, just block;  else do a real select() */
   if ((ibits[0].fd_count == 0) && (ibits[1].fd_count == 0) &&
       (ibits[2].fd_count == 0))
   {
      if (tv > 0)      /* make sure we don't block on nothing forever */
 202fec8:	00001e06 	br	202ff44 <t_select+0x170>

      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
 202fecc:	0009883a 	mov	r4,zero
 202fed0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      while ((retval = sock_selscan(ibits, obits)) == 0)
 202fed4:	00000f06 	br	202ff14 <t_select+0x140>
      {
         if (tv != -1L) 
 202fed8:	e0bfff17 	ldw	r2,-4(fp)
 202fedc:	10bfffe0 	cmpeqi	r2,r2,-1
 202fee0:	1000051e 	bne	r2,zero,202fef8 <t_select+0x124>
         {
            if (tmo <= cticks)
 202fee4:	00808174 	movhi	r2,517
 202fee8:	1090c904 	addi	r2,r2,17188
 202feec:	10c00017 	ldw	r3,0(r2)
 202fef0:	e0be7517 	ldw	r2,-1580(fp)
 202fef4:	1880102e 	bgeu	r3,r2,202ff38 <t_select+0x164>
               break;
         }
         select_wait = 1;
 202fef8:	00808174 	movhi	r2,517
 202fefc:	1090d104 	addi	r2,r2,17220
 202ff00:	00c00044 	movi	r3,1
 202ff04:	10c0000d 	sth	r3,0(r2)
         tcp_sleep (&select_wait);
 202ff08:	01008174 	movhi	r4,517
 202ff0c:	2110d104 	addi	r4,r4,17220
 202ff10:	20274f40 	call	20274f4 <tcp_sleep>
      /* Lock the net semaphore before going into selscan. Upon
       * return we will either call tcp_sleep(), which unlocks the
       * semaphore, or fall into the unlock statement.
       */
      LOCK_NET_RESOURCE(NET_RESID);
      while ((retval = sock_selscan(ibits, obits)) == 0)
 202ff14:	e0ff3904 	addi	r3,fp,-796
 202ff18:	e0be7604 	addi	r2,fp,-1576
 202ff1c:	1809883a 	mov	r4,r3
 202ff20:	100b883a 	mov	r5,r2
 202ff24:	202ffc00 	call	202ffc0 <sock_selscan>
 202ff28:	e0be7415 	stw	r2,-1584(fp)
 202ff2c:	e0be7417 	ldw	r2,-1584(fp)
 202ff30:	103fe926 	beq	r2,zero,202fed8 <t_select+0x104>
 202ff34:	00000106 	br	202ff3c <t_select+0x168>
      {
         if (tv != -1L) 
         {
            if (tmo <= cticks)
               break;
 202ff38:	0001883a 	nop
         }
         select_wait = 1;
         tcp_sleep (&select_wait);
      }
      UNLOCK_NET_RESOURCE(NET_RESID);
 202ff3c:	0009883a 	mov	r4,zero
 202ff40:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   }

   if (retval >= 0)
 202ff44:	e0be7417 	ldw	r2,-1584(fp)
 202ff48:	10001716 	blt	r2,zero,202ffa8 <t_select+0x1d4>
   {
      if (in)
 202ff4c:	e0bffc17 	ldw	r2,-16(fp)
 202ff50:	10000526 	beq	r2,zero,202ff68 <t_select+0x194>
         MEMCPY(in, &obits[0], sizeof(fd_set));
 202ff54:	e0be7604 	addi	r2,fp,-1576
 202ff58:	e13ffc17 	ldw	r4,-16(fp)
 202ff5c:	100b883a 	mov	r5,r2
 202ff60:	01804104 	movi	r6,260
 202ff64:	200660c0 	call	200660c <memcpy>
      if (out)
 202ff68:	e0bffd17 	ldw	r2,-12(fp)
 202ff6c:	10000626 	beq	r2,zero,202ff88 <t_select+0x1b4>
         MEMCPY(out, &obits[1], sizeof(fd_set));
 202ff70:	e0be7604 	addi	r2,fp,-1576
 202ff74:	10804104 	addi	r2,r2,260
 202ff78:	e13ffd17 	ldw	r4,-12(fp)
 202ff7c:	100b883a 	mov	r5,r2
 202ff80:	01804104 	movi	r6,260
 202ff84:	200660c0 	call	200660c <memcpy>
      if (ex)
 202ff88:	e0bffe17 	ldw	r2,-8(fp)
 202ff8c:	10000626 	beq	r2,zero,202ffa8 <t_select+0x1d4>
         MEMCPY(ex, &obits[2], sizeof(fd_set));
 202ff90:	e0be7604 	addi	r2,fp,-1576
 202ff94:	10808204 	addi	r2,r2,520
 202ff98:	e13ffe17 	ldw	r4,-8(fp)
 202ff9c:	100b883a 	mov	r5,r2
 202ffa0:	01804104 	movi	r6,260
 202ffa4:	200660c0 	call	200660c <memcpy>
   }
   return retval;
 202ffa8:	e0be7417 	ldw	r2,-1584(fp)
}
 202ffac:	e037883a 	mov	sp,fp
 202ffb0:	dfc00117 	ldw	ra,4(sp)
 202ffb4:	df000017 	ldw	fp,0(sp)
 202ffb8:	dec00204 	addi	sp,sp,8
 202ffbc:	f800283a 	ret

0202ffc0 <sock_selscan>:
 * RETURNS: 
 */

int
sock_selscan(fd_set * ibits, fd_set * obits)
{
 202ffc0:	defff604 	addi	sp,sp,-40
 202ffc4:	dfc00915 	stw	ra,36(sp)
 202ffc8:	df000815 	stw	fp,32(sp)
 202ffcc:	df000804 	addi	fp,sp,32
 202ffd0:	e13ffe15 	stw	r4,-8(fp)
 202ffd4:	e17fff15 	stw	r5,-4(fp)
   fd_set *in, *out;
   int   which;
   int   sock;
   int   flag  =  0;
 202ffd8:	e03ffa15 	stw	zero,-24(fp)
   int   num_sel  =  0;
 202ffdc:	e03ffb15 	stw	zero,-20(fp)

   for (which = 0; which < 3; which++)
 202ffe0:	e03ff815 	stw	zero,-32(fp)
 202ffe4:	00003c06 	br	20300d8 <sock_selscan+0x118>
   {
      switch (which)
 202ffe8:	e0bff817 	ldw	r2,-32(fp)
 202ffec:	10c00060 	cmpeqi	r3,r2,1
 202fff0:	1800061e 	bne	r3,zero,203000c <sock_selscan+0x4c>
 202fff4:	10c000a0 	cmpeqi	r3,r2,2
 202fff8:	1800071e 	bne	r3,zero,2030018 <sock_selscan+0x58>
 202fffc:	1000081e 	bne	r2,zero,2030020 <sock_selscan+0x60>
      {
      case 0:
         flag = SOREAD; break;
 2030000:	00800044 	movi	r2,1
 2030004:	e0bffa15 	stw	r2,-24(fp)
 2030008:	00000506 	br	2030020 <sock_selscan+0x60>

      case 1:
         flag = SOWRITE; break;
 203000c:	00800084 	movi	r2,2
 2030010:	e0bffa15 	stw	r2,-24(fp)
 2030014:	00000206 	br	2030020 <sock_selscan+0x60>

      case 2:
         flag = 0; break;
 2030018:	e03ffa15 	stw	zero,-24(fp)
 203001c:	0001883a 	nop
      }
      in = &ibits [which];
 2030020:	e0bff817 	ldw	r2,-32(fp)
 2030024:	10804124 	muli	r2,r2,260
 2030028:	e0fffe17 	ldw	r3,-8(fp)
 203002c:	1885883a 	add	r2,r3,r2
 2030030:	e0bffc15 	stw	r2,-16(fp)
      out = &obits [which];
 2030034:	e0bff817 	ldw	r2,-32(fp)
 2030038:	10804124 	muli	r2,r2,260
 203003c:	e0ffff17 	ldw	r3,-4(fp)
 2030040:	1885883a 	add	r2,r3,r2
 2030044:	e0bffd15 	stw	r2,-12(fp)
      for (sock = 0; sock < (int)in->fd_count; sock++)
 2030048:	e03ff915 	stw	zero,-28(fp)
 203004c:	00001b06 	br	20300bc <sock_selscan+0xfc>
      {
         if (sock_select (in->fd_array[sock], flag))
 2030050:	e0fffc17 	ldw	r3,-16(fp)
 2030054:	e0bff917 	ldw	r2,-28(fp)
 2030058:	10800044 	addi	r2,r2,1
 203005c:	1085883a 	add	r2,r2,r2
 2030060:	1085883a 	add	r2,r2,r2
 2030064:	1885883a 	add	r2,r3,r2
 2030068:	10800017 	ldw	r2,0(r2)
 203006c:	1009883a 	mov	r4,r2
 2030070:	e17ffa17 	ldw	r5,-24(fp)
 2030074:	20300fc0 	call	20300fc <sock_select>
 2030078:	10000d26 	beq	r2,zero,20300b0 <sock_selscan+0xf0>
         {
            FD_SET(in->fd_array[sock], out);
 203007c:	e0fffc17 	ldw	r3,-16(fp)
 2030080:	e0bff917 	ldw	r2,-28(fp)
 2030084:	10800044 	addi	r2,r2,1
 2030088:	1085883a 	add	r2,r2,r2
 203008c:	1085883a 	add	r2,r2,r2
 2030090:	1885883a 	add	r2,r3,r2
 2030094:	10800017 	ldw	r2,0(r2)
 2030098:	1009883a 	mov	r4,r2
 203009c:	e17ffd17 	ldw	r5,-12(fp)
 20300a0:	203050c0 	call	203050c <ifd_set>
            num_sel++;
 20300a4:	e0bffb17 	ldw	r2,-20(fp)
 20300a8:	10800044 	addi	r2,r2,1
 20300ac:	e0bffb15 	stw	r2,-20(fp)
      case 2:
         flag = 0; break;
      }
      in = &ibits [which];
      out = &obits [which];
      for (sock = 0; sock < (int)in->fd_count; sock++)
 20300b0:	e0bff917 	ldw	r2,-28(fp)
 20300b4:	10800044 	addi	r2,r2,1
 20300b8:	e0bff915 	stw	r2,-28(fp)
 20300bc:	e0bffc17 	ldw	r2,-16(fp)
 20300c0:	10800017 	ldw	r2,0(r2)
 20300c4:	e0fff917 	ldw	r3,-28(fp)
 20300c8:	18bfe116 	blt	r3,r2,2030050 <sock_selscan+0x90>
   int   which;
   int   sock;
   int   flag  =  0;
   int   num_sel  =  0;

   for (which = 0; which < 3; which++)
 20300cc:	e0bff817 	ldw	r2,-32(fp)
 20300d0:	10800044 	addi	r2,r2,1
 20300d4:	e0bff815 	stw	r2,-32(fp)
 20300d8:	e0bff817 	ldw	r2,-32(fp)
 20300dc:	108000d0 	cmplti	r2,r2,3
 20300e0:	103fc11e 	bne	r2,zero,202ffe8 <sock_selscan+0x28>
            FD_SET(in->fd_array[sock], out);
            num_sel++;
         }
      }
   }
   return num_sel;
 20300e4:	e0bffb17 	ldw	r2,-20(fp)
}
 20300e8:	e037883a 	mov	sp,fp
 20300ec:	dfc00117 	ldw	ra,4(sp)
 20300f0:	df000017 	ldw	fp,0(sp)
 20300f4:	dec00204 	addi	sp,sp,8
 20300f8:	f800283a 	ret

020300fc <sock_select>:
 * RETURNS: 
 */

int
sock_select(long sock, int flag)
{
 20300fc:	defffa04 	addi	sp,sp,-24
 2030100:	dfc00515 	stw	ra,20(sp)
 2030104:	df000415 	stw	fp,16(sp)
 2030108:	df000404 	addi	fp,sp,16
 203010c:	e13ffe15 	stw	r4,-8(fp)
 2030110:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so;
   int   ready =  0;
 2030114:	e03ffc15 	stw	zero,-16(fp)

   so = LONG2SO(sock);
 2030118:	e0bffe17 	ldw	r2,-8(fp)
 203011c:	10bff804 	addi	r2,r2,-32
 2030120:	1085883a 	add	r2,r2,r2
 2030124:	1085883a 	add	r2,r2,r2
 2030128:	e0bffd15 	stw	r2,-12(fp)

   switch (flag) 
 203012c:	e0bfff17 	ldw	r2,-4(fp)
 2030130:	10c00060 	cmpeqi	r3,r2,1
 2030134:	1800041e 	bne	r3,zero,2030148 <sock_select+0x4c>
 2030138:	10c000a0 	cmpeqi	r3,r2,2
 203013c:	1800201e 	bne	r3,zero,20301c0 <sock_select+0xc4>
 2030140:	10004326 	beq	r2,zero,2030250 <sock_select+0x154>
 2030144:	00006006 	br	20302c8 <sock_select+0x1cc>
   {
   case SOREAD:
      /* can we read something from so? */
      if (so->so_rcv.sb_cc)
 2030148:	e0bffd17 	ldw	r2,-12(fp)
 203014c:	10800a17 	ldw	r2,40(r2)
 2030150:	10000326 	beq	r2,zero,2030160 <sock_select+0x64>
      {
         ready = 1;
 2030154:	00800044 	movi	r2,1
 2030158:	e0bffc15 	stw	r2,-16(fp)
         break;
 203015c:	00005a06 	br	20302c8 <sock_select+0x1cc>
      }
      if (so->so_state & SS_CANTRCVMORE)
 2030160:	e0bffd17 	ldw	r2,-12(fp)
 2030164:	1080088b 	ldhu	r2,34(r2)
 2030168:	10bfffcc 	andi	r2,r2,65535
 203016c:	1080080c 	andi	r2,r2,32
 2030170:	10000326 	beq	r2,zero,2030180 <sock_select+0x84>
      {  ready = 1;
 2030174:	00800044 	movi	r2,1
 2030178:	e0bffc15 	stw	r2,-16(fp)
         break;
 203017c:	00005206 	br	20302c8 <sock_select+0x1cc>
      }
      if (so->so_qlen)  /* attach is ready */
 2030180:	e0bffd17 	ldw	r2,-12(fp)
 2030184:	10801e43 	ldbu	r2,121(r2)
 2030188:	10803fcc 	andi	r2,r2,255
 203018c:	1080201c 	xori	r2,r2,128
 2030190:	10bfe004 	addi	r2,r2,-128
 2030194:	10000326 	beq	r2,zero,20301a4 <sock_select+0xa8>
      {
         ready = 1;
 2030198:	00800044 	movi	r2,1
 203019c:	e0bffc15 	stw	r2,-16(fp)
         break;
 20301a0:	00004906 	br	20302c8 <sock_select+0x1cc>
         }
      }
#endif   /* TCP_ZEROCOPY */

      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
 20301a4:	e0bffd17 	ldw	r2,-12(fp)
 20301a8:	1080110b 	ldhu	r2,68(r2)
 20301ac:	10800214 	ori	r2,r2,8
 20301b0:	1007883a 	mov	r3,r2
 20301b4:	e0bffd17 	ldw	r2,-12(fp)
 20301b8:	10c0110d 	sth	r3,68(r2)
      break;
 20301bc:	00004206 	br	20302c8 <sock_select+0x1cc>

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 20301c0:	e0bffd17 	ldw	r2,-12(fp)
 20301c4:	10801317 	ldw	r2,76(r2)
 20301c8:	1007883a 	mov	r3,r2
 20301cc:	e0bffd17 	ldw	r2,-12(fp)
 20301d0:	10801217 	ldw	r2,72(r2)
 20301d4:	1885c83a 	sub	r2,r3,r2
 20301d8:	10001816 	blt	r2,zero,203023c <sock_select+0x140>
 20301dc:	e0bffd17 	ldw	r2,-12(fp)
 20301e0:	10c01317 	ldw	r3,76(r2)
 20301e4:	e0bffd17 	ldw	r2,-12(fp)
 20301e8:	10801217 	ldw	r2,72(r2)
 20301ec:	18801326 	beq	r3,r2,203023c <sock_select+0x140>
          ((((so)->so_state&SS_ISCONNECTED) || 
 20301f0:	e0bffd17 	ldw	r2,-12(fp)
 20301f4:	1080088b 	ldhu	r2,34(r2)
 20301f8:	10bfffcc 	andi	r2,r2,65535
 20301fc:	1080008c 	andi	r2,r2,2
      /* fall to here if so is not ready to read */
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
 2030200:	10000b1e 	bne	r2,zero,2030230 <sock_select+0x134>
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 2030204:	e0bffd17 	ldw	r2,-12(fp)
 2030208:	10800217 	ldw	r2,8(r2)
 203020c:	1080010b 	ldhu	r2,4(r2)
 2030210:	10bfffcc 	andi	r2,r2,65535
 2030214:	1080010c 	andi	r2,r2,4
      so->so_rcv.sb_flags |= SB_SEL;   /* set flag for select wakeup */
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
 2030218:	10000526 	beq	r2,zero,2030230 <sock_select+0x134>
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
           ((so)->so_state & SS_CANTSENDMORE)))
 203021c:	e0bffd17 	ldw	r2,-12(fp)
 2030220:	1080088b 	ldhu	r2,34(r2)
 2030224:	10bfffcc 	andi	r2,r2,65535
 2030228:	1080040c 	andi	r2,r2,16
      break;

   case SOWRITE:
      if ((sbspace(&(so)->so_snd) > 0) && 
          ((((so)->so_state&SS_ISCONNECTED) || 
            ((so)->so_proto->pr_flags&PR_CONNREQUIRED)==0) || 
 203022c:	10000326 	beq	r2,zero,203023c <sock_select+0x140>
           ((so)->so_state & SS_CANTSENDMORE)))
      {
         ready = 1;
 2030230:	00800044 	movi	r2,1
 2030234:	e0bffc15 	stw	r2,-16(fp)
         break;
 2030238:	00002306 	br	20302c8 <sock_select+0x1cc>
      }
      sbselqueue (&so->so_snd);
 203023c:	e0bffd17 	ldw	r2,-12(fp)
 2030240:	10801204 	addi	r2,r2,72
 2030244:	1009883a 	mov	r4,r2
 2030248:	202f2900 	call	202f290 <sbselqueue>
      break;
 203024c:	00001e06 	br	20302c8 <sock_select+0x1cc>

   case 0:
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
 2030250:	e0bffd17 	ldw	r2,-12(fp)
 2030254:	10801a17 	ldw	r2,104(r2)
 2030258:	1000051e 	bne	r2,zero,2030270 <sock_select+0x174>
 203025c:	e0bffd17 	ldw	r2,-12(fp)
 2030260:	1080088b 	ldhu	r2,34(r2)
 2030264:	10bfffcc 	andi	r2,r2,65535
 2030268:	1080100c 	andi	r2,r2,64
 203026c:	10000326 	beq	r2,zero,203027c <sock_select+0x180>
      {
         ready = 1;
 2030270:	00800044 	movi	r2,1
 2030274:	e0bffc15 	stw	r2,-16(fp)
         break;
 2030278:	00001306 	br	20302c8 <sock_select+0x1cc>
      }
      if (so->so_error &&
 203027c:	e0bffd17 	ldw	r2,-12(fp)
 2030280:	10800617 	ldw	r2,24(r2)
 2030284:	10000b26 	beq	r2,zero,20302b4 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
 2030288:	e0bffd17 	ldw	r2,-12(fp)
 203028c:	10800617 	ldw	r2,24(r2)
      if (so->so_oobmark || (so->so_state & SS_RCVATMARK))
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
 2030290:	10801de0 	cmpeqi	r2,r2,119
 2030294:	1000071e 	bne	r2,zero,20302b4 <sock_select+0x1b8>
          (so->so_error != EINPROGRESS) &&
          (so->so_error != EWOULDBLOCK))
 2030298:	e0bffd17 	ldw	r2,-12(fp)
 203029c:	10800617 	ldw	r2,24(r2)
      {
         ready = 1;
         break;
      }
      if (so->so_error &&
          (so->so_error != EINPROGRESS) &&
 20302a0:	108002e0 	cmpeqi	r2,r2,11
 20302a4:	1000031e 	bne	r2,zero,20302b4 <sock_select+0x1b8>
          (so->so_error != EWOULDBLOCK))
      {
         ready = 1;
 20302a8:	00800044 	movi	r2,1
 20302ac:	e0bffc15 	stw	r2,-16(fp)
         break;
 20302b0:	00000506 	br	20302c8 <sock_select+0x1cc>
      }
      sbselqueue(&so->so_rcv);
 20302b4:	e0bffd17 	ldw	r2,-12(fp)
 20302b8:	10800a04 	addi	r2,r2,40
 20302bc:	1009883a 	mov	r4,r2
 20302c0:	202f2900 	call	202f290 <sbselqueue>
      break;
 20302c4:	0001883a 	nop
   }

   return ready;
 20302c8:	e0bffc17 	ldw	r2,-16(fp)
}
 20302cc:	e037883a 	mov	sp,fp
 20302d0:	dfc00117 	ldw	ra,4(sp)
 20302d4:	df000017 	ldw	fp,0(sp)
 20302d8:	dec00204 	addi	sp,sp,8
 20302dc:	f800283a 	ret

020302e0 <in_pcbnotify>:
void
in_pcbnotify(struct inpcb * head, 
   struct in_addr *  dst,
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
 20302e0:	defff804 	addi	sp,sp,-32
 20302e4:	dfc00715 	stw	ra,28(sp)
 20302e8:	df000615 	stw	fp,24(sp)
 20302ec:	df000604 	addi	fp,sp,24
 20302f0:	e13ffc15 	stw	r4,-16(fp)
 20302f4:	e17ffd15 	stw	r5,-12(fp)
 20302f8:	e1bffe15 	stw	r6,-8(fp)
 20302fc:	e1ffff15 	stw	r7,-4(fp)
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 2030300:	e0bffc17 	ldw	r2,-16(fp)
 2030304:	10800017 	ldw	r2,0(r2)
 2030308:	e0bffa15 	stw	r2,-24(fp)
 203030c:	00001c06 	br	2030380 <in_pcbnotify+0xa0>
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 2030310:	e0bffa17 	ldw	r2,-24(fp)
 2030314:	10c00317 	ldw	r3,12(r2)
 2030318:	e0bffd17 	ldw	r2,-12(fp)
 203031c:	10800017 	ldw	r2,0(r2)
 2030320:	1880031e 	bne	r3,r2,2030330 <in_pcbnotify+0x50>
          inp->inp_socket == 0) 
 2030324:	e0bffa17 	ldw	r2,-24(fp)
 2030328:	10800817 	ldw	r2,32(r2)
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
   {
      if (inp->inp_faddr.s_addr != dst->s_addr ||
 203032c:	1000041e 	bne	r2,zero,2030340 <in_pcbnotify+0x60>
          inp->inp_socket == 0) 
      {
         inp = inp->inp_next;
 2030330:	e0bffa17 	ldw	r2,-24(fp)
 2030334:	10800017 	ldw	r2,0(r2)
 2030338:	e0bffa15 	stw	r2,-24(fp)
         continue;
 203033c:	00001006 	br	2030380 <in_pcbnotify+0xa0>
      }
      if (errnum) 
 2030340:	e0bffe17 	ldw	r2,-8(fp)
 2030344:	10000426 	beq	r2,zero,2030358 <in_pcbnotify+0x78>
         inp->inp_socket->so_error = errnum;
 2030348:	e0bffa17 	ldw	r2,-24(fp)
 203034c:	10800817 	ldw	r2,32(r2)
 2030350:	e0fffe17 	ldw	r3,-8(fp)
 2030354:	10c00615 	stw	r3,24(r2)
      oinp = inp;
 2030358:	e0bffa17 	ldw	r2,-24(fp)
 203035c:	e0bffb15 	stw	r2,-20(fp)
      inp = inp->inp_next;
 2030360:	e0bffa17 	ldw	r2,-24(fp)
 2030364:	10800017 	ldw	r2,0(r2)
 2030368:	e0bffa15 	stw	r2,-24(fp)
      if (notify)
 203036c:	e0bfff17 	ldw	r2,-4(fp)
 2030370:	10000326 	beq	r2,zero,2030380 <in_pcbnotify+0xa0>
         (*notify)(oinp);
 2030374:	e0bfff17 	ldw	r2,-4(fp)
 2030378:	e13ffb17 	ldw	r4,-20(fp)
 203037c:	103ee83a 	callr	r2
   int   errnum,
   void (*notify) __P ((struct inpcb *)))
{
   struct inpcb * inp, *   oinp;

   for (inp = head->inp_next; inp != head;) 
 2030380:	e0fffa17 	ldw	r3,-24(fp)
 2030384:	e0bffc17 	ldw	r2,-16(fp)
 2030388:	18bfe11e 	bne	r3,r2,2030310 <in_pcbnotify+0x30>
      oinp = inp;
      inp = inp->inp_next;
      if (notify)
         (*notify)(oinp);
   }
}
 203038c:	e037883a 	mov	sp,fp
 2030390:	dfc00117 	ldw	ra,4(sp)
 2030394:	df000017 	ldw	fp,0(sp)
 2030398:	dec00204 	addi	sp,sp,8
 203039c:	f800283a 	ret

020303a0 <tcp_notify>:
 * RETURNS: 
 */

void
tcp_notify(struct inpcb * inp)
{
 20303a0:	defffd04 	addi	sp,sp,-12
 20303a4:	dfc00215 	stw	ra,8(sp)
 20303a8:	df000115 	stw	fp,4(sp)
 20303ac:	df000104 	addi	fp,sp,4
 20303b0:	e13fff15 	stw	r4,-4(fp)
   tcp_wakeup(&inp->inp_socket->so_timeo);
 20303b4:	e0bfff17 	ldw	r2,-4(fp)
 20303b8:	10800817 	ldw	r2,32(r2)
 20303bc:	10800904 	addi	r2,r2,36
 20303c0:	1009883a 	mov	r4,r2
 20303c4:	20276980 	call	2027698 <tcp_wakeup>
   sorwakeup(inp->inp_socket);
 20303c8:	e0bfff17 	ldw	r2,-4(fp)
 20303cc:	10c00817 	ldw	r3,32(r2)
 20303d0:	e0bfff17 	ldw	r2,-4(fp)
 20303d4:	10800817 	ldw	r2,32(r2)
 20303d8:	10800a04 	addi	r2,r2,40
 20303dc:	1809883a 	mov	r4,r3
 20303e0:	100b883a 	mov	r5,r2
 20303e4:	202f3300 	call	202f330 <sbwakeup>
   sowwakeup(inp->inp_socket);
 20303e8:	e0bfff17 	ldw	r2,-4(fp)
 20303ec:	10c00817 	ldw	r3,32(r2)
 20303f0:	e0bfff17 	ldw	r2,-4(fp)
 20303f4:	10800817 	ldw	r2,32(r2)
 20303f8:	10801204 	addi	r2,r2,72
 20303fc:	1809883a 	mov	r4,r3
 2030400:	100b883a 	mov	r5,r2
 2030404:	202f3300 	call	202f330 <sbwakeup>
}
 2030408:	e037883a 	mov	sp,fp
 203040c:	dfc00117 	ldw	ra,4(sp)
 2030410:	df000017 	ldw	fp,0(sp)
 2030414:	dec00204 	addi	sp,sp,8
 2030418:	f800283a 	ret

0203041c <ifd_clr>:
 * compacts the fd_set.
 */

void
ifd_clr(long sock, fd_set *set)
{
 203041c:	defffb04 	addi	sp,sp,-20
 2030420:	dfc00415 	stw	ra,16(sp)
 2030424:	df000315 	stw	fp,12(sp)
 2030428:	df000304 	addi	fp,sp,12
 203042c:	e13ffe15 	stw	r4,-8(fp)
 2030430:	e17fff15 	stw	r5,-4(fp)
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 2030434:	e03ffd15 	stw	zero,-12(fp)
 2030438:	00002a06 	br	20304e4 <ifd_clr+0xc8>
   {
      if (set->fd_array[i] == sock)
 203043c:	e0ffff17 	ldw	r3,-4(fp)
 2030440:	e0bffd17 	ldw	r2,-12(fp)
 2030444:	10800044 	addi	r2,r2,1
 2030448:	1085883a 	add	r2,r2,r2
 203044c:	1085883a 	add	r2,r2,r2
 2030450:	1885883a 	add	r2,r3,r2
 2030454:	10c00017 	ldw	r3,0(r2)
 2030458:	e0bffe17 	ldw	r2,-8(fp)
 203045c:	18801e1e 	bne	r3,r2,20304d8 <ifd_clr+0xbc>
      {
         while (i + 1 < set->fd_count)
 2030460:	00001206 	br	20304ac <ifd_clr+0x90>
         {
            set->fd_array[i] = set->fd_array[i + 1];
 2030464:	e0bffd17 	ldw	r2,-12(fp)
 2030468:	10800044 	addi	r2,r2,1
 203046c:	e0ffff17 	ldw	r3,-4(fp)
 2030470:	10800044 	addi	r2,r2,1
 2030474:	1085883a 	add	r2,r2,r2
 2030478:	1085883a 	add	r2,r2,r2
 203047c:	1885883a 	add	r2,r3,r2
 2030480:	10c00017 	ldw	r3,0(r2)
 2030484:	e13fff17 	ldw	r4,-4(fp)
 2030488:	e0bffd17 	ldw	r2,-12(fp)
 203048c:	10800044 	addi	r2,r2,1
 2030490:	1085883a 	add	r2,r2,r2
 2030494:	1085883a 	add	r2,r2,r2
 2030498:	2085883a 	add	r2,r4,r2
 203049c:	10c00015 	stw	r3,0(r2)
            i++;
 20304a0:	e0bffd17 	ldw	r2,-12(fp)
 20304a4:	10800044 	addi	r2,r2,1
 20304a8:	e0bffd15 	stw	r2,-12(fp)

   for (i = 0; i < set->fd_count ; i++) 
   {
      if (set->fd_array[i] == sock)
      {
         while (i + 1 < set->fd_count)
 20304ac:	e0bffd17 	ldw	r2,-12(fp)
 20304b0:	10c00044 	addi	r3,r2,1
 20304b4:	e0bfff17 	ldw	r2,-4(fp)
 20304b8:	10800017 	ldw	r2,0(r2)
 20304bc:	18bfe936 	bltu	r3,r2,2030464 <ifd_clr+0x48>
         {
            set->fd_array[i] = set->fd_array[i + 1];
            i++;
         }
         set->fd_count--;
 20304c0:	e0bfff17 	ldw	r2,-4(fp)
 20304c4:	10800017 	ldw	r2,0(r2)
 20304c8:	10ffffc4 	addi	r3,r2,-1
 20304cc:	e0bfff17 	ldw	r2,-4(fp)
 20304d0:	10c00015 	stw	r3,0(r2)
         return;
 20304d4:	00000806 	br	20304f8 <ifd_clr+0xdc>
void
ifd_clr(long sock, fd_set *set)
{
   u_int i;

   for (i = 0; i < set->fd_count ; i++) 
 20304d8:	e0bffd17 	ldw	r2,-12(fp)
 20304dc:	10800044 	addi	r2,r2,1
 20304e0:	e0bffd15 	stw	r2,-12(fp)
 20304e4:	e0bfff17 	ldw	r2,-4(fp)
 20304e8:	10800017 	ldw	r2,0(r2)
 20304ec:	e0fffd17 	ldw	r3,-12(fp)
 20304f0:	18bfd236 	bltu	r3,r2,203043c <ifd_clr+0x20>
         return;
      }
   }

#ifdef NPDEBUG
   dtrap(); /* socket wasn't found in array */
 20304f4:	20285c80 	call	20285c8 <dtrap>
#endif
}
 20304f8:	e037883a 	mov	sp,fp
 20304fc:	dfc00117 	ldw	ra,4(sp)
 2030500:	df000017 	ldw	fp,0(sp)
 2030504:	dec00204 	addi	sp,sp,8
 2030508:	f800283a 	ret

0203050c <ifd_set>:
 * called if the fd_set structure is already full.
 */

void
ifd_set(long sock, fd_set *set)
{
 203050c:	defffc04 	addi	sp,sp,-16
 2030510:	dfc00315 	stw	ra,12(sp)
 2030514:	df000215 	stw	fp,8(sp)
 2030518:	df000204 	addi	fp,sp,8
 203051c:	e13ffe15 	stw	r4,-8(fp)
 2030520:	e17fff15 	stw	r5,-4(fp)
   if (set->fd_count < FD_SETSIZE)
 2030524:	e0bfff17 	ldw	r2,-4(fp)
 2030528:	10800017 	ldw	r2,0(r2)
 203052c:	10801028 	cmpgeui	r2,r2,64
 2030530:	10000d1e 	bne	r2,zero,2030568 <ifd_set+0x5c>
      set->fd_array[set->fd_count++] = sock;
 2030534:	e0bfff17 	ldw	r2,-4(fp)
 2030538:	10800017 	ldw	r2,0(r2)
 203053c:	e13fff17 	ldw	r4,-4(fp)
 2030540:	10c00044 	addi	r3,r2,1
 2030544:	18c7883a 	add	r3,r3,r3
 2030548:	18c7883a 	add	r3,r3,r3
 203054c:	20c7883a 	add	r3,r4,r3
 2030550:	e13ffe17 	ldw	r4,-8(fp)
 2030554:	19000015 	stw	r4,0(r3)
 2030558:	10c00044 	addi	r3,r2,1
 203055c:	e0bfff17 	ldw	r2,-4(fp)
 2030560:	10c00015 	stw	r3,0(r2)
 2030564:	00000106 	br	203056c <ifd_set+0x60>
#ifdef NPDEBUG
   else
      dtrap();
 2030568:	20285c80 	call	20285c8 <dtrap>
#endif
}
 203056c:	e037883a 	mov	sp,fp
 2030570:	dfc00117 	ldw	ra,4(sp)
 2030574:	df000017 	ldw	fp,0(sp)
 2030578:	dec00204 	addi	sp,sp,8
 203057c:	f800283a 	ret

02030580 <ifd_isset>:
 * Tests if a socket is a member of a file descriptor set.
 */

int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
 2030580:	defffc04 	addi	sp,sp,-16
 2030584:	df000315 	stw	fp,12(sp)
 2030588:	df000304 	addi	fp,sp,12
 203058c:	e13ffe15 	stw	r4,-8(fp)
 2030590:	e17fff15 	stw	r5,-4(fp)
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 2030594:	e03ffd15 	stw	zero,-12(fp)
 2030598:	00000e06 	br	20305d4 <ifd_isset+0x54>
   {
      if (set->fd_array[i] == sock)
 203059c:	e0ffff17 	ldw	r3,-4(fp)
 20305a0:	e0bffd17 	ldw	r2,-12(fp)
 20305a4:	10800044 	addi	r2,r2,1
 20305a8:	1085883a 	add	r2,r2,r2
 20305ac:	1085883a 	add	r2,r2,r2
 20305b0:	1885883a 	add	r2,r3,r2
 20305b4:	10c00017 	ldw	r3,0(r2)
 20305b8:	e0bffe17 	ldw	r2,-8(fp)
 20305bc:	1880021e 	bne	r3,r2,20305c8 <ifd_isset+0x48>
         return TRUE;
 20305c0:	00800044 	movi	r2,1
 20305c4:	00000806 	br	20305e8 <ifd_isset+0x68>
int   /* actually, boolean */
ifd_isset(long sock, fd_set *set)
{
   u_int   i;

   for (i = 0; i < set->fd_count ; i++)
 20305c8:	e0bffd17 	ldw	r2,-12(fp)
 20305cc:	10800044 	addi	r2,r2,1
 20305d0:	e0bffd15 	stw	r2,-12(fp)
 20305d4:	e0bfff17 	ldw	r2,-4(fp)
 20305d8:	10800017 	ldw	r2,0(r2)
 20305dc:	e0fffd17 	ldw	r3,-12(fp)
 20305e0:	18bfee36 	bltu	r3,r2,203059c <ifd_isset+0x1c>
   {
      if (set->fd_array[i] == sock)
         return TRUE;
   }
   return FALSE;
 20305e4:	0005883a 	mov	r2,zero
}
 20305e8:	e037883a 	mov	sp,fp
 20305ec:	df000017 	ldw	fp,0(sp)
 20305f0:	dec00104 	addi	sp,sp,4
 20305f4:	f800283a 	ret

020305f8 <ifd_get>:
 * NOTE: This is not part of the original FD_XXX() functionality.
 */

long
ifd_get(unsigned i, fd_set *set)
{
 20305f8:	defffc04 	addi	sp,sp,-16
 20305fc:	dfc00315 	stw	ra,12(sp)
 2030600:	df000215 	stw	fp,8(sp)
 2030604:	df000204 	addi	fp,sp,8
 2030608:	e13ffe15 	stw	r4,-8(fp)
 203060c:	e17fff15 	stw	r5,-4(fp)
   if (i < set->fd_count)
 2030610:	e0bfff17 	ldw	r2,-4(fp)
 2030614:	10800017 	ldw	r2,0(r2)
 2030618:	e0fffe17 	ldw	r3,-8(fp)
 203061c:	1880082e 	bgeu	r3,r2,2030640 <ifd_get+0x48>
      return set->fd_array[i];
 2030620:	e0ffff17 	ldw	r3,-4(fp)
 2030624:	e0bffe17 	ldw	r2,-8(fp)
 2030628:	10800044 	addi	r2,r2,1
 203062c:	1085883a 	add	r2,r2,r2
 2030630:	1085883a 	add	r2,r2,r2
 2030634:	1885883a 	add	r2,r3,r2
 2030638:	10800017 	ldw	r2,0(r2)
 203063c:	00000206 	br	2030648 <ifd_get+0x50>
   else
   {
#ifdef NPDEBUG
      dtrap();
 2030640:	20285c80 	call	20285c8 <dtrap>
#endif
      return INVALID_SOCKET;
 2030644:	00bfffc4 	movi	r2,-1
   }
}
 2030648:	e037883a 	mov	sp,fp
 203064c:	dfc00117 	ldw	ra,4(sp)
 2030650:	df000017 	ldw	fp,0(sp)
 2030654:	dec00204 	addi	sp,sp,8
 2030658:	f800283a 	ret

0203065c <tcp_reass>:

int
tcp_reass(struct tcpcb * tp, 
   struct tcpiphdr * ti,
   struct mbuf *  ti_mbuf)
{
 203065c:	defff504 	addi	sp,sp,-44
 2030660:	dfc00a15 	stw	ra,40(sp)
 2030664:	df000915 	stw	fp,36(sp)
 2030668:	df000904 	addi	fp,sp,36
 203066c:	e13ffd15 	stw	r4,-12(fp)
 2030670:	e17ffe15 	stw	r5,-8(fp)
 2030674:	e1bfff15 	stw	r6,-4(fp)
   struct tcpiphdr * q;
   struct socket *   so =  tp->t_inpcb->inp_socket;
 2030678:	e0bffd17 	ldw	r2,-12(fp)
 203067c:	10800d17 	ldw	r2,52(r2)
 2030680:	10800817 	ldw	r2,32(r2)
 2030684:	e0bff815 	stw	r2,-32(fp)

   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
 2030688:	e0bffe17 	ldw	r2,-8(fp)
 203068c:	1000a326 	beq	r2,zero,203091c <tcp_reass+0x2c0>
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 2030690:	e0bffd17 	ldw	r2,-12(fp)
 2030694:	10800017 	ldw	r2,0(r2)
 2030698:	e0bff715 	stw	r2,-36(fp)
 203069c:	00000906 	br	20306c4 <tcp_reass+0x68>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
 20306a0:	e0bff717 	ldw	r2,-36(fp)
 20306a4:	10c00617 	ldw	r3,24(r2)
 20306a8:	e0bffe17 	ldw	r2,-8(fp)
 20306ac:	10800617 	ldw	r2,24(r2)
 20306b0:	1885c83a 	sub	r2,r3,r2
 20306b4:	00800716 	blt	zero,r2,20306d4 <tcp_reass+0x78>

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
       q = (struct tcpiphdr *)q->ti_next)
 20306b8:	e0bff717 	ldw	r2,-36(fp)
 20306bc:	10800017 	ldw	r2,0(r2)
 20306c0:	e0bff715 	stw	r2,-36(fp)
      goto present;

   /*
    * Find a segment which begins after this one does.
    */
   for (q = tp->seg_next; q != (struct tcpiphdr *)tp;
 20306c4:	e0fff717 	ldw	r3,-36(fp)
 20306c8:	e0bffd17 	ldw	r2,-12(fp)
 20306cc:	18bff41e 	bne	r3,r2,20306a0 <tcp_reass+0x44>
 20306d0:	00000106 	br	20306d8 <tcp_reass+0x7c>
       q = (struct tcpiphdr *)q->ti_next)
   {
      if (SEQ_GT(q->ti_seq, ti->ti_seq))
      break;
 20306d4:	0001883a 	nop
   /*
    * If there is a preceding segment, it may provide some of
    * our data already.  If so, drop the data from the incoming
    * segment.  If it provides all of our data, drop us.
    */
   if ((struct tcpiphdr *)q->ti_prev != (struct tcpiphdr *)tp) 
 20306d8:	e0bff717 	ldw	r2,-36(fp)
 20306dc:	10c00117 	ldw	r3,4(r2)
 20306e0:	e0bffd17 	ldw	r2,-12(fp)
 20306e4:	18803e26 	beq	r3,r2,20307e0 <tcp_reass+0x184>
   {
      long  i;
      q = (struct tcpiphdr *)q->ti_prev;
 20306e8:	e0bff717 	ldw	r2,-36(fp)
 20306ec:	10800117 	ldw	r2,4(r2)
 20306f0:	e0bff715 	stw	r2,-36(fp)
      /* conversion to int (in i) handles seq wraparound */
      i = q->ti_seq + q->ti_len - ti->ti_seq;
 20306f4:	e0bff717 	ldw	r2,-36(fp)
 20306f8:	10c00617 	ldw	r3,24(r2)
 20306fc:	e0bff717 	ldw	r2,-36(fp)
 2030700:	1080028b 	ldhu	r2,10(r2)
 2030704:	10bfffcc 	andi	r2,r2,65535
 2030708:	1887883a 	add	r3,r3,r2
 203070c:	e0bffe17 	ldw	r2,-8(fp)
 2030710:	10800617 	ldw	r2,24(r2)
 2030714:	1885c83a 	sub	r2,r3,r2
 2030718:	e0bff915 	stw	r2,-28(fp)
      if (i > 0) 
 203071c:	e0bff917 	ldw	r2,-28(fp)
 2030720:	00802c0e 	bge	zero,r2,20307d4 <tcp_reass+0x178>
      {
         if (i >= (long)ti->ti_len) 
 2030724:	e0bffe17 	ldw	r2,-8(fp)
 2030728:	1080028b 	ldhu	r2,10(r2)
 203072c:	10bfffcc 	andi	r2,r2,65535
 2030730:	e0fff917 	ldw	r3,-28(fp)
 2030734:	18801716 	blt	r3,r2,2030794 <tcp_reass+0x138>
         {
            tcpstat.tcps_rcvduppack++;
 2030738:	00809934 	movhi	r2,612
 203073c:	10b6f504 	addi	r2,r2,-9260
 2030740:	10801f17 	ldw	r2,124(r2)
 2030744:	10c00044 	addi	r3,r2,1
 2030748:	00809934 	movhi	r2,612
 203074c:	10b6f504 	addi	r2,r2,-9260
 2030750:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
 2030754:	00809934 	movhi	r2,612
 2030758:	10b6f504 	addi	r2,r2,-9260
 203075c:	10c02017 	ldw	r3,128(r2)
 2030760:	e0bffe17 	ldw	r2,-8(fp)
 2030764:	1080028b 	ldhu	r2,10(r2)
 2030768:	10bfffcc 	andi	r2,r2,65535
 203076c:	1887883a 	add	r3,r3,r2
 2030770:	00809934 	movhi	r2,612
 2030774:	10b6f504 	addi	r2,r2,-9260
 2030778:	10c02015 	stw	r3,128(r2)
            GOTO_DROP;
 203077c:	008025c4 	movi	r2,151
 2030780:	d0a0a915 	stw	r2,-32092(gp)
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
      sorwakeup(so);
   return (flags);
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
 2030784:	e13fff17 	ldw	r4,-4(fp)
 2030788:	20296780 	call	2029678 <m_freem>
   return (0);
 203078c:	0005883a 	mov	r2,zero
 2030790:	0000b006 	br	2030a54 <tcp_reass+0x3f8>
         {
            tcpstat.tcps_rcvduppack++;
            tcpstat.tcps_rcvdupbyte += ti->ti_len;
            GOTO_DROP;
         }
         m_adj (ti_mbuf, (int)i);
 2030794:	e13fff17 	ldw	r4,-4(fp)
 2030798:	e17ff917 	ldw	r5,-28(fp)
 203079c:	20299a80 	call	20299a8 <m_adj>
         ti->ti_len -= (short)i;
 20307a0:	e0bffe17 	ldw	r2,-8(fp)
 20307a4:	10c0028b 	ldhu	r3,10(r2)
 20307a8:	e0bff917 	ldw	r2,-28(fp)
 20307ac:	1885c83a 	sub	r2,r3,r2
 20307b0:	1007883a 	mov	r3,r2
 20307b4:	e0bffe17 	ldw	r2,-8(fp)
 20307b8:	10c0028d 	sth	r3,10(r2)
         ti->ti_seq += (tcp_seq)i;
 20307bc:	e0bffe17 	ldw	r2,-8(fp)
 20307c0:	10c00617 	ldw	r3,24(r2)
 20307c4:	e0bff917 	ldw	r2,-28(fp)
 20307c8:	1887883a 	add	r3,r3,r2
 20307cc:	e0bffe17 	ldw	r2,-8(fp)
 20307d0:	10c00615 	stw	r3,24(r2)
      }
      q = (struct tcpiphdr *)(q->ti_next);
 20307d4:	e0bff717 	ldw	r2,-36(fp)
 20307d8:	10800017 	ldw	r2,0(r2)
 20307dc:	e0bff715 	stw	r2,-36(fp)
   }
   tcpstat.tcps_rcvoopack++;
 20307e0:	00809934 	movhi	r2,612
 20307e4:	10b6f504 	addi	r2,r2,-9260
 20307e8:	10802317 	ldw	r2,140(r2)
 20307ec:	10c00044 	addi	r3,r2,1
 20307f0:	00809934 	movhi	r2,612
 20307f4:	10b6f504 	addi	r2,r2,-9260
 20307f8:	10c02315 	stw	r3,140(r2)
   tcpstat.tcps_rcvoobyte += ti->ti_len;
 20307fc:	00809934 	movhi	r2,612
 2030800:	10b6f504 	addi	r2,r2,-9260
 2030804:	10c02417 	ldw	r3,144(r2)
 2030808:	e0bffe17 	ldw	r2,-8(fp)
 203080c:	1080028b 	ldhu	r2,10(r2)
 2030810:	10bfffcc 	andi	r2,r2,65535
 2030814:	1887883a 	add	r3,r3,r2
 2030818:	00809934 	movhi	r2,612
 203081c:	10b6f504 	addi	r2,r2,-9260
 2030820:	10c02415 	stw	r3,144(r2)

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 2030824:	00003206 	br	20308f0 <tcp_reass+0x294>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
 2030828:	e0bffe17 	ldw	r2,-8(fp)
 203082c:	10c00617 	ldw	r3,24(r2)
 2030830:	e0bffe17 	ldw	r2,-8(fp)
 2030834:	1080028b 	ldhu	r2,10(r2)
 2030838:	10bfffcc 	andi	r2,r2,65535
 203083c:	1887883a 	add	r3,r3,r2
 2030840:	e0bff717 	ldw	r2,-36(fp)
 2030844:	10800617 	ldw	r2,24(r2)
 2030848:	1885c83a 	sub	r2,r3,r2
 203084c:	e0bffa15 	stw	r2,-24(fp)
      if (i <= 0)
 2030850:	e0bffa17 	ldw	r2,-24(fp)
 2030854:	00802a0e 	bge	zero,r2,2030900 <tcp_reass+0x2a4>
         break;
      if (i < (int)(q->ti_len))
 2030858:	e0bff717 	ldw	r2,-36(fp)
 203085c:	1080028b 	ldhu	r2,10(r2)
 2030860:	10bfffcc 	andi	r2,r2,65535
 2030864:	e0fffa17 	ldw	r3,-24(fp)
 2030868:	1880130e 	bge	r3,r2,20308b8 <tcp_reass+0x25c>
      {
         q->ti_seq += i;
 203086c:	e0bff717 	ldw	r2,-36(fp)
 2030870:	10c00617 	ldw	r3,24(r2)
 2030874:	e0bffa17 	ldw	r2,-24(fp)
 2030878:	1887883a 	add	r3,r3,r2
 203087c:	e0bff717 	ldw	r2,-36(fp)
 2030880:	10c00615 	stw	r3,24(r2)
         q->ti_len -= (u_short)i;
 2030884:	e0bff717 	ldw	r2,-36(fp)
 2030888:	10c0028b 	ldhu	r3,10(r2)
 203088c:	e0bffa17 	ldw	r2,-24(fp)
 2030890:	1885c83a 	sub	r2,r3,r2
 2030894:	1007883a 	mov	r3,r2
 2030898:	e0bff717 	ldw	r2,-36(fp)
 203089c:	10c0028d 	sth	r3,10(r2)
         m_adj (dtom(q), (int)i);
 20308a0:	e13ff717 	ldw	r4,-36(fp)
 20308a4:	2029bcc0 	call	2029bcc <dtom>
 20308a8:	1009883a 	mov	r4,r2
 20308ac:	e17ffa17 	ldw	r5,-24(fp)
 20308b0:	20299a80 	call	20299a8 <m_adj>
         break;
 20308b4:	00001306 	br	2030904 <tcp_reass+0x2a8>
      }
      q = (struct tcpiphdr *)q->ti_next;
 20308b8:	e0bff717 	ldw	r2,-36(fp)
 20308bc:	10800017 	ldw	r2,0(r2)
 20308c0:	e0bff715 	stw	r2,-36(fp)
      m = dtom(q->ti_prev);
 20308c4:	e0bff717 	ldw	r2,-36(fp)
 20308c8:	10800117 	ldw	r2,4(r2)
 20308cc:	1009883a 	mov	r4,r2
 20308d0:	2029bcc0 	call	2029bcc <dtom>
 20308d4:	e0bffb15 	stw	r2,-20(fp)
      remque (q->ti_prev);
 20308d8:	e0bff717 	ldw	r2,-36(fp)
 20308dc:	10800117 	ldw	r2,4(r2)
 20308e0:	1009883a 	mov	r4,r2
 20308e4:	2029c680 	call	2029c68 <remque>
      m_freem (m);
 20308e8:	e13ffb17 	ldw	r4,-20(fp)
 20308ec:	20296780 	call	2029678 <m_freem>

   /*
    * While we overlap succeeding segments trim them or,
    * if they are completely covered, dequeue them.
    */
   while (q != (struct tcpiphdr *)tp) 
 20308f0:	e0fff717 	ldw	r3,-36(fp)
 20308f4:	e0bffd17 	ldw	r2,-12(fp)
 20308f8:	18bfcb1e 	bne	r3,r2,2030828 <tcp_reass+0x1cc>
 20308fc:	00000106 	br	2030904 <tcp_reass+0x2a8>
   {
      int   i  =  (int)((ti->ti_seq +  ti->ti_len) -  q->ti_seq);
      if (i <= 0)
         break;
 2030900:	0001883a 	nop
   }

   /*
    * Stick new segment in its place.
    */
   insque(ti, q->ti_prev);
 2030904:	e0bff717 	ldw	r2,-36(fp)
 2030908:	10800117 	ldw	r2,4(r2)
 203090c:	e13ffe17 	ldw	r4,-8(fp)
 2030910:	100b883a 	mov	r5,r2
 2030914:	2029cd80 	call	2029cd8 <insque>
 2030918:	00000106 	br	2030920 <tcp_reass+0x2c4>
   /*
    * Call with ti==0 after become established to
    * force pre-ESTABLISHED data up to user socket.
    */
   if (ti == 0)
      goto present;
 203091c:	0001883a 	nop
present:
   /*
    * Present data to user, advancing rcv_nxt through
    * completed sequence space.
    */
   if (TCPS_HAVERCVDSYN (tp->t_state) == 0)
 2030920:	e0bffd17 	ldw	r2,-12(fp)
 2030924:	10800217 	ldw	r2,8(r2)
 2030928:	108000c8 	cmpgei	r2,r2,3
 203092c:	1000021e 	bne	r2,zero,2030938 <tcp_reass+0x2dc>
      return (0);
 2030930:	0005883a 	mov	r2,zero
 2030934:	00004706 	br	2030a54 <tcp_reass+0x3f8>
   ti = tp->seg_next;
 2030938:	e0bffd17 	ldw	r2,-12(fp)
 203093c:	10800017 	ldw	r2,0(r2)
 2030940:	e0bffe15 	stw	r2,-8(fp)
   if (ti == (struct tcpiphdr *)tp || ti->ti_seq != tp->rcv_nxt)
 2030944:	e0fffe17 	ldw	r3,-8(fp)
 2030948:	e0bffd17 	ldw	r2,-12(fp)
 203094c:	18800526 	beq	r3,r2,2030964 <tcp_reass+0x308>
 2030950:	e0bffe17 	ldw	r2,-8(fp)
 2030954:	10c00617 	ldw	r3,24(r2)
 2030958:	e0bffd17 	ldw	r2,-12(fp)
 203095c:	10801617 	ldw	r2,88(r2)
 2030960:	18800226 	beq	r3,r2,203096c <tcp_reass+0x310>
      return (0);
 2030964:	0005883a 	mov	r2,zero
 2030968:	00003a06 	br	2030a54 <tcp_reass+0x3f8>
   if (tp->t_state == TCPS_SYN_RECEIVED && ti->ti_len)
 203096c:	e0bffd17 	ldw	r2,-12(fp)
 2030970:	10800217 	ldw	r2,8(r2)
 2030974:	108000d8 	cmpnei	r2,r2,3
 2030978:	1000061e 	bne	r2,zero,2030994 <tcp_reass+0x338>
 203097c:	e0bffe17 	ldw	r2,-8(fp)
 2030980:	1080028b 	ldhu	r2,10(r2)
 2030984:	10bfffcc 	andi	r2,r2,65535
 2030988:	10000226 	beq	r2,zero,2030994 <tcp_reass+0x338>
      return (0);
 203098c:	0005883a 	mov	r2,zero
 2030990:	00003006 	br	2030a54 <tcp_reass+0x3f8>
   do 
   {
      tp->rcv_nxt += ti->ti_len;
 2030994:	e0bffd17 	ldw	r2,-12(fp)
 2030998:	10c01617 	ldw	r3,88(r2)
 203099c:	e0bffe17 	ldw	r2,-8(fp)
 20309a0:	1080028b 	ldhu	r2,10(r2)
 20309a4:	10bfffcc 	andi	r2,r2,65535
 20309a8:	1887883a 	add	r3,r3,r2
 20309ac:	e0bffd17 	ldw	r2,-12(fp)
 20309b0:	10c01615 	stw	r3,88(r2)
      flags = ti->ti_flags & TH_FIN;
 20309b4:	e0bffe17 	ldw	r2,-8(fp)
 20309b8:	10800843 	ldbu	r2,33(r2)
 20309bc:	10803fcc 	andi	r2,r2,255
 20309c0:	1080004c 	andi	r2,r2,1
 20309c4:	e0bffc15 	stw	r2,-16(fp)
      remque(ti);
 20309c8:	e13ffe17 	ldw	r4,-8(fp)
 20309cc:	2029c680 	call	2029c68 <remque>
      m = dtom(ti);
 20309d0:	e13ffe17 	ldw	r4,-8(fp)
 20309d4:	2029bcc0 	call	2029bcc <dtom>
 20309d8:	e0bffb15 	stw	r2,-20(fp)
      ti = (struct tcpiphdr *)ti->ti_next;
 20309dc:	e0bffe17 	ldw	r2,-8(fp)
 20309e0:	10800017 	ldw	r2,0(r2)
 20309e4:	e0bffe15 	stw	r2,-8(fp)
      if (so->so_state & SS_CANTRCVMORE)
 20309e8:	e0bff817 	ldw	r2,-32(fp)
 20309ec:	1080088b 	ldhu	r2,34(r2)
 20309f0:	10bfffcc 	andi	r2,r2,65535
 20309f4:	1080080c 	andi	r2,r2,32
 20309f8:	10000326 	beq	r2,zero,2030a08 <tcp_reass+0x3ac>
         m_freem (m);
 20309fc:	e13ffb17 	ldw	r4,-20(fp)
 2030a00:	20296780 	call	2029678 <m_freem>
 2030a04:	00000506 	br	2030a1c <tcp_reass+0x3c0>
      else
         sbappend (&so->so_rcv, m);
 2030a08:	e0bff817 	ldw	r2,-32(fp)
 2030a0c:	10800a04 	addi	r2,r2,40
 2030a10:	1009883a 	mov	r4,r2
 2030a14:	e17ffb17 	ldw	r5,-20(fp)
 2030a18:	202f4e40 	call	202f4e4 <sbappend>
   } while (ti != (struct tcpiphdr *)tp && ti->ti_seq == tp->rcv_nxt);
 2030a1c:	e0fffe17 	ldw	r3,-8(fp)
 2030a20:	e0bffd17 	ldw	r2,-12(fp)
 2030a24:	18800526 	beq	r3,r2,2030a3c <tcp_reass+0x3e0>
 2030a28:	e0bffe17 	ldw	r2,-8(fp)
 2030a2c:	10c00617 	ldw	r3,24(r2)
 2030a30:	e0bffd17 	ldw	r2,-12(fp)
 2030a34:	10801617 	ldw	r2,88(r2)
 2030a38:	18bfd626 	beq	r3,r2,2030994 <tcp_reass+0x338>
      sorwakeup(so);
 2030a3c:	e0bff817 	ldw	r2,-32(fp)
 2030a40:	10800a04 	addi	r2,r2,40
 2030a44:	e13ff817 	ldw	r4,-32(fp)
 2030a48:	100b883a 	mov	r5,r2
 2030a4c:	202f3300 	call	202f330 <sbwakeup>
   return (flags);
 2030a50:	e0bffc17 	ldw	r2,-16(fp)
drop:
   /**m_freem (dtom(ti));**/
   m_freem (ti_mbuf);
   return (0);
}
 2030a54:	e037883a 	mov	sp,fp
 2030a58:	dfc00117 	ldw	ra,4(sp)
 2030a5c:	df000017 	ldw	fp,0(sp)
 2030a60:	dec00204 	addi	sp,sp,8
 2030a64:	f800283a 	ret

02030a68 <tcp_input>:
 * RETURNS: void
 */

void
tcp_input(struct mbuf * m, NET ifp)
{
 2030a68:	deffdf04 	addi	sp,sp,-132
 2030a6c:	dfc02015 	stw	ra,128(sp)
 2030a70:	df001f15 	stw	fp,124(sp)
 2030a74:	df001f04 	addi	fp,sp,124
 2030a78:	e13ffe15 	stw	r4,-8(fp)
 2030a7c:	e17fff15 	stw	r5,-4(fp)
   ip6_addr    ip6_src;
   ip6_addr    ip6_dst;
#endif   /* IP_V6 */
   struct tcpiphdr * ti;
   struct inpcb * inp;
   struct mbuf *  om =  0;
 2030a80:	e03fe515 	stw	zero,-108(fp)
   int   len,  tlen, off;
   struct tcpcb * tp =  0;
 2030a84:	e03fe615 	stw	zero,-104(fp)
   int   tiflags;
   struct socket *   so =  NULL;
 2030a88:	e03fe815 	stw	zero,-96(fp)
   int   todrop,  acked,   ourfinisacked, needoutput  =  0;
 2030a8c:	e03feb15 	stw	zero,-84(fp)
   int   dropsocket  =  0;
 2030a90:	e03fec15 	stw	zero,-80(fp)
   long  iss   =  0;
 2030a94:	e03fed15 	stw	zero,-76(fp)
#ifdef DO_TCPTRACE
   int   ostate;
#endif


   tcpstat.tcps_rcvtotal++;
 2030a98:	00809934 	movhi	r2,612
 2030a9c:	10b6f504 	addi	r2,r2,-9260
 2030aa0:	10801917 	ldw	r2,100(r2)
 2030aa4:	10c00044 	addi	r3,r2,1
 2030aa8:	00809934 	movhi	r2,612
 2030aac:	10b6f504 	addi	r2,r2,-9260
 2030ab0:	10c01915 	stw	r3,100(r2)
   TCP_MIB_INC(tcpInSegs);    /* keep MIB stats */
 2030ab4:	00809934 	movhi	r2,612
 2030ab8:	10b6c704 	addi	r2,r2,-9444
 2030abc:	10800917 	ldw	r2,36(r2)
 2030ac0:	10c00044 	addi	r3,r2,1
 2030ac4:	00809934 	movhi	r2,612
 2030ac8:	10b6c704 	addi	r2,r2,-9444
 2030acc:	10c00915 	stw	r3,36(r2)
   {
      /*
       * Get IP and TCP header together in first mbuf.
       * Note: IP leaves IP header in first mbuf.
       */
      pip = mtod(m, struct ip *);
 2030ad0:	e0bffe17 	ldw	r2,-8(fp)
 2030ad4:	10800317 	ldw	r2,12(r2)
 2030ad8:	e0bfe315 	stw	r2,-116(fp)
      if (pip->ip_ver_ihl > 0x45)   /* IP v4, 5 dword hdr len */
 2030adc:	e0bfe317 	ldw	r2,-116(fp)
 2030ae0:	10800003 	ldbu	r2,0(r2)
 2030ae4:	10803fcc 	andi	r2,r2,255
 2030ae8:	108011b0 	cmpltui	r2,r2,70
 2030aec:	1000061e 	bne	r2,zero,2030b08 <tcp_input+0xa0>
      {
         np_stripoptions(pip, (struct mbuf *)m);
 2030af0:	e13fe317 	ldw	r4,-116(fp)
 2030af4:	e17ffe17 	ldw	r5,-8(fp)
 2030af8:	202a6180 	call	202a618 <np_stripoptions>
         pip = mtod(m, struct ip *);
 2030afc:	e0bffe17 	ldw	r2,-8(fp)
 2030b00:	10800317 	ldw	r2,12(r2)
 2030b04:	e0bfe315 	stw	r2,-116(fp)
      }
      if (m->m_len < ((sizeof (struct ip) + sizeof (struct tcphdr))))
 2030b08:	e0bffe17 	ldw	r2,-8(fp)
 2030b0c:	10800217 	ldw	r2,8(r2)
 2030b10:	10800a28 	cmpgeui	r2,r2,40
 2030b14:	1000081e 	bne	r2,zero,2030b38 <tcp_input+0xd0>
      {
         tcpstat.tcps_rcvshort++;
 2030b18:	00809934 	movhi	r2,612
 2030b1c:	10b6f504 	addi	r2,r2,-9260
 2030b20:	10801e17 	ldw	r2,120(r2)
 2030b24:	10c00044 	addi	r3,r2,1
 2030b28:	00809934 	movhi	r2,612
 2030b2c:	10b6f504 	addi	r2,r2,-9260
 2030b30:	10c01e15 	stw	r3,120(r2)
 2030b34:	00089706 	br	2032d94 <tcp_input+0x232c>
         return;
      }
      tlen = pip->ip_len;     /* this was fudged by IP layer */
 2030b38:	e0bfe317 	ldw	r2,-116(fp)
 2030b3c:	1080008b 	ldhu	r2,2(r2)
 2030b40:	10bfffcc 	andi	r2,r2,65535
 2030b44:	e0bff115 	stw	r2,-60(fp)
      /* The following is needed in the cases where the size of the
       * overlay structure is larger than the size of the ip header.
       * This can happen if the ih_next and ih_prev pointers in the
       * overlay structure are larger than 32 bit pointers.
       */
      ti = (struct tcpiphdr *)(m->m_data + sizeof(struct ip) - 
 2030b48:	e0bffe17 	ldw	r2,-8(fp)
 2030b4c:	10800317 	ldw	r2,12(r2)
 2030b50:	e0bff215 	stw	r2,-56(fp)
         sizeof(struct ipovly));
      if ((char *)ti < m->pkt->nb_buff)
 2030b54:	e0bffe17 	ldw	r2,-8(fp)
 2030b58:	10800117 	ldw	r2,4(r2)
 2030b5c:	10800117 	ldw	r2,4(r2)
 2030b60:	e0fff217 	ldw	r3,-56(fp)
 2030b64:	1880032e 	bgeu	r3,r2,2030b74 <tcp_input+0x10c>
      {
         panic("tcp_input");
 2030b68:	01008174 	movhi	r4,517
 2030b6c:	213d6e04 	addi	r4,r4,-2632
 2030b70:	2026bf80 	call	2026bf8 <panic>
   /*
    * Check that TCP offset makes sense,
    * pull out TCP options and adjust length.
    */

   off = GET_TH_OFF(ti->ti_t) << 2;
 2030b74:	e0bff217 	ldw	r2,-56(fp)
 2030b78:	10800803 	ldbu	r2,32(r2)
 2030b7c:	10803fcc 	andi	r2,r2,255
 2030b80:	1004d13a 	srli	r2,r2,4
 2030b84:	10803fcc 	andi	r2,r2,255
 2030b88:	1085883a 	add	r2,r2,r2
 2030b8c:	1085883a 	add	r2,r2,r2
 2030b90:	e0bff315 	stw	r2,-52(fp)
   if (off < sizeof (struct tcphdr) || off > tlen) 
 2030b94:	e0bff317 	ldw	r2,-52(fp)
 2030b98:	10800530 	cmpltui	r2,r2,20
 2030b9c:	1000031e 	bne	r2,zero,2030bac <tcp_input+0x144>
 2030ba0:	e0bff317 	ldw	r2,-52(fp)
 2030ba4:	e0fff117 	ldw	r3,-60(fp)
 2030ba8:	1880110e 	bge	r3,r2,2030bf0 <tcp_input+0x188>
   {
#ifdef DO_TCPTRACE
      tcp_trace("tcp off: src %x off %d\n", ti->ti_src, off);
#endif
      tcpstat.tcps_rcvbadoff++;
 2030bac:	00809934 	movhi	r2,612
 2030bb0:	10b6f504 	addi	r2,r2,-9260
 2030bb4:	10801d17 	ldw	r2,116(r2)
 2030bb8:	10c00044 	addi	r3,r2,1
 2030bbc:	00809934 	movhi	r2,612
 2030bc0:	10b6f504 	addi	r2,r2,-9260
 2030bc4:	10c01d15 	stw	r3,116(r2)
      TCP_MIB_INC(tcpInErrs);   /* keep MIB stats */
 2030bc8:	00809934 	movhi	r2,612
 2030bcc:	10b6c704 	addi	r2,r2,-9444
 2030bd0:	10800d17 	ldw	r2,52(r2)
 2030bd4:	10c00044 	addi	r3,r2,1
 2030bd8:	00809934 	movhi	r2,612
 2030bdc:	10b6c704 	addi	r2,r2,-9444
 2030be0:	10c00d15 	stw	r3,52(r2)
      GOTO_DROP;
 2030be4:	00805784 	movi	r2,350
 2030be8:	d0a0a915 	stw	r2,-32092(gp)
 2030bec:	00085f06 	br	2032d6c <tcp_input+0x2304>
   }
   tlen -= (int)off;
 2030bf0:	e0fff117 	ldw	r3,-60(fp)
 2030bf4:	e0bff317 	ldw	r2,-52(fp)
 2030bf8:	1885c83a 	sub	r2,r3,r2
 2030bfc:	e0bff115 	stw	r2,-60(fp)
   ti->ti_len = (u_short)tlen;
 2030c00:	e0bff117 	ldw	r2,-60(fp)
 2030c04:	1007883a 	mov	r3,r2
 2030c08:	e0bff217 	ldw	r2,-56(fp)
 2030c0c:	10c0028d 	sth	r3,10(r2)
   if (off > sizeof (struct tcphdr)) 
 2030c10:	e0bff317 	ldw	r2,-52(fp)
 2030c14:	10800570 	cmpltui	r2,r2,21
 2030c18:	1000331e 	bne	r2,zero,2030ce8 <tcp_input+0x280>
   {
      int olen;      /* length of options field */
      u_char * op;   /* scratch option pointer */

      olen = off - sizeof (struct tcphdr);   /* get options length */
 2030c1c:	e0bff317 	ldw	r2,-52(fp)
 2030c20:	10bffb04 	addi	r2,r2,-20
 2030c24:	e0bff415 	stw	r2,-48(fp)
      om = m_getwithdata (MT_RXDATA, olen);  /* get mbuf for opts */
 2030c28:	01000044 	movi	r4,1
 2030c2c:	e17ff417 	ldw	r5,-48(fp)
 2030c30:	20293d80 	call	20293d8 <m_getnbuf>
 2030c34:	e0bfe515 	stw	r2,-108(fp)
      if (om == 0)
 2030c38:	e0bfe517 	ldw	r2,-108(fp)
 2030c3c:	1000031e 	bne	r2,zero,2030c4c <tcp_input+0x1e4>
         GOTO_DROP;
 2030c40:	00805a84 	movi	r2,362
 2030c44:	d0a0a915 	stw	r2,-32092(gp)
 2030c48:	00084806 	br	2032d6c <tcp_input+0x2304>
      om->m_len = olen;       /* set mbuf length */
 2030c4c:	e0fff417 	ldw	r3,-48(fp)
 2030c50:	e0bfe517 	ldw	r2,-108(fp)
 2030c54:	10c00215 	stw	r3,8(r2)
      /* set pointer to options field at end of TCP header */
      if(m->pkt->type == htons(0x86DD))   /* IPv6 packet */
 2030c58:	e0bffe17 	ldw	r2,-8(fp)
 2030c5c:	10800117 	ldw	r2,4(r2)
 2030c60:	1080080b 	ldhu	r2,32(r2)
 2030c64:	10ffffcc 	andi	r3,r2,65535
 2030c68:	00b76194 	movui	r2,56710
 2030c6c:	1880051e 	bne	r3,r2,2030c84 <tcp_input+0x21c>
         op = (u_char*)(m->m_data + 20);  /* past TCP header */
 2030c70:	e0bffe17 	ldw	r2,-8(fp)
 2030c74:	10800317 	ldw	r2,12(r2)
 2030c78:	10800504 	addi	r2,r2,20
 2030c7c:	e0bfee15 	stw	r2,-72(fp)
 2030c80:	00000406 	br	2030c94 <tcp_input+0x22c>
      else
         op = (u_char*)(m->m_data + 40);  /* past IP + TCP */
 2030c84:	e0bffe17 	ldw	r2,-8(fp)
 2030c88:	10800317 	ldw	r2,12(r2)
 2030c8c:	10800a04 	addi	r2,r2,40
 2030c90:	e0bfee15 	stw	r2,-72(fp)
      MEMCPY(om->m_data, op, olen); /* copy to new mbuf */
 2030c94:	e0bfe517 	ldw	r2,-108(fp)
 2030c98:	10c00317 	ldw	r3,12(r2)
 2030c9c:	e0bff417 	ldw	r2,-48(fp)
 2030ca0:	1809883a 	mov	r4,r3
 2030ca4:	e17fee17 	ldw	r5,-72(fp)
 2030ca8:	100d883a 	mov	r6,r2
 2030cac:	200660c0 	call	200660c <memcpy>

      /* strip options from data mbuf. This actually just cuts the first 
       * m_len bytes from the TCP header, but it leaves the mbuf members 
       * set so the adjustment below does the right thing.
       */
      m->m_data += om->m_len;
 2030cb0:	e0bffe17 	ldw	r2,-8(fp)
 2030cb4:	10c00317 	ldw	r3,12(r2)
 2030cb8:	e0bfe517 	ldw	r2,-108(fp)
 2030cbc:	10800217 	ldw	r2,8(r2)
 2030cc0:	1887883a 	add	r3,r3,r2
 2030cc4:	e0bffe17 	ldw	r2,-8(fp)
 2030cc8:	10c00315 	stw	r3,12(r2)
      m->m_len -= om->m_len;
 2030ccc:	e0bffe17 	ldw	r2,-8(fp)
 2030cd0:	10c00217 	ldw	r3,8(r2)
 2030cd4:	e0bfe517 	ldw	r2,-108(fp)
 2030cd8:	10800217 	ldw	r2,8(r2)
 2030cdc:	1887c83a 	sub	r3,r3,r2
 2030ce0:	e0bffe17 	ldw	r2,-8(fp)
 2030ce4:	10c00215 	stw	r3,8(r2)
   }
   tiflags = ti->ti_flags;
 2030ce8:	e0bff217 	ldw	r2,-56(fp)
 2030cec:	10800843 	ldbu	r2,33(r2)
 2030cf0:	10803fcc 	andi	r2,r2,255
 2030cf4:	e0bfe715 	stw	r2,-100(fp)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   /* Convert TCP protocol specific fields to host format. */
   ti->ti_seq = ntohl(ti->ti_seq);
 2030cf8:	e0bff217 	ldw	r2,-56(fp)
 2030cfc:	10800617 	ldw	r2,24(r2)
 2030d00:	1006d63a 	srli	r3,r2,24
 2030d04:	e0bff217 	ldw	r2,-56(fp)
 2030d08:	10800617 	ldw	r2,24(r2)
 2030d0c:	1004d23a 	srli	r2,r2,8
 2030d10:	10bfc00c 	andi	r2,r2,65280
 2030d14:	1886b03a 	or	r3,r3,r2
 2030d18:	e0bff217 	ldw	r2,-56(fp)
 2030d1c:	10800617 	ldw	r2,24(r2)
 2030d20:	10bfc00c 	andi	r2,r2,65280
 2030d24:	1004923a 	slli	r2,r2,8
 2030d28:	1886b03a 	or	r3,r3,r2
 2030d2c:	e0bff217 	ldw	r2,-56(fp)
 2030d30:	10800617 	ldw	r2,24(r2)
 2030d34:	1004963a 	slli	r2,r2,24
 2030d38:	1886b03a 	or	r3,r3,r2
 2030d3c:	e0bff217 	ldw	r2,-56(fp)
 2030d40:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = ntohl(ti->ti_ack);
 2030d44:	e0bff217 	ldw	r2,-56(fp)
 2030d48:	10800717 	ldw	r2,28(r2)
 2030d4c:	1006d63a 	srli	r3,r2,24
 2030d50:	e0bff217 	ldw	r2,-56(fp)
 2030d54:	10800717 	ldw	r2,28(r2)
 2030d58:	1004d23a 	srli	r2,r2,8
 2030d5c:	10bfc00c 	andi	r2,r2,65280
 2030d60:	1886b03a 	or	r3,r3,r2
 2030d64:	e0bff217 	ldw	r2,-56(fp)
 2030d68:	10800717 	ldw	r2,28(r2)
 2030d6c:	10bfc00c 	andi	r2,r2,65280
 2030d70:	1004923a 	slli	r2,r2,8
 2030d74:	1886b03a 	or	r3,r3,r2
 2030d78:	e0bff217 	ldw	r2,-56(fp)
 2030d7c:	10800717 	ldw	r2,28(r2)
 2030d80:	1004963a 	slli	r2,r2,24
 2030d84:	1886b03a 	or	r3,r3,r2
 2030d88:	e0bff217 	ldw	r2,-56(fp)
 2030d8c:	10c00715 	stw	r3,28(r2)
   ti->ti_urp = ntohs(ti->ti_urp);
 2030d90:	e0bff217 	ldw	r2,-56(fp)
 2030d94:	1080098b 	ldhu	r2,38(r2)
 2030d98:	10bfffcc 	andi	r2,r2,65535
 2030d9c:	1004d23a 	srli	r2,r2,8
 2030da0:	1007883a 	mov	r3,r2
 2030da4:	e0bff217 	ldw	r2,-56(fp)
 2030da8:	1080098b 	ldhu	r2,38(r2)
 2030dac:	10bfffcc 	andi	r2,r2,65535
 2030db0:	1004923a 	slli	r2,r2,8
 2030db4:	1884b03a 	or	r2,r3,r2
 2030db8:	1007883a 	mov	r3,r2
 2030dbc:	e0bff217 	ldw	r2,-56(fp)
 2030dc0:	10c0098d 	sth	r3,38(r2)
   /*
    * Locate pcb for segment.
    */
findpcb:

   switch(m->pkt->type)
 2030dc4:	e0bffe17 	ldw	r2,-8(fp)
 2030dc8:	10800117 	ldw	r2,4(r2)
 2030dcc:	1080080b 	ldhu	r2,32(r2)
 2030dd0:	10bfffcc 	andi	r2,r2,65535
 2030dd4:	10800220 	cmpeqi	r2,r2,8
 2030dd8:	10002126 	beq	r2,zero,2030e60 <tcp_input+0x3f8>
   {
#ifdef IP_V4
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
 2030ddc:	e0bffe17 	ldw	r2,-8(fp)
 2030de0:	10800317 	ldw	r2,12(r2)
 2030de4:	10c00a04 	addi	r3,r2,40
 2030de8:	e0bffe17 	ldw	r2,-8(fp)
 2030dec:	10c00315 	stw	r3,12(r2)
      m->m_len -= 40;
 2030df0:	e0bffe17 	ldw	r2,-8(fp)
 2030df4:	10800217 	ldw	r2,8(r2)
 2030df8:	10fff604 	addi	r3,r2,-40
 2030dfc:	e0bffe17 	ldw	r2,-8(fp)
 2030e00:	10c00215 	stw	r3,8(r2)

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 2030e04:	e0bff217 	ldw	r2,-56(fp)
 2030e08:	11400317 	ldw	r5,12(r2)
 2030e0c:	e0bff217 	ldw	r2,-56(fp)
 2030e10:	1080050b 	ldhu	r2,20(r2)
 2030e14:	10ffffcc 	andi	r3,r2,65535
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 2030e18:	e0bff217 	ldw	r2,-56(fp)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 2030e1c:	10800417 	ldw	r2,16(r2)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
 2030e20:	e13ff217 	ldw	r4,-56(fp)
 2030e24:	2100058b 	ldhu	r4,22(r4)
   case  IPTP:   /* IPv4 packet */
      /* Drop TCP and IP headers; TCP options were dropped above. */
      m->m_data += 40;
      m->m_len -= 40;

      inp = in_pcblookup(&tcb, ti->ti_src.s_addr, ti->ti_sport, 
 2030e28:	213fffcc 	andi	r4,r4,65535
 2030e2c:	d9000015 	stw	r4,0(sp)
 2030e30:	01000044 	movi	r4,1
 2030e34:	d9000115 	stw	r4,4(sp)
 2030e38:	01009934 	movhi	r4,612
 2030e3c:	2136ea04 	addi	r4,r4,-9304
 2030e40:	180d883a 	mov	r6,r3
 2030e44:	100f883a 	mov	r7,r2
 2030e48:	2048b580 	call	2048b58 <in_pcblookup>
 2030e4c:	e0bfe415 	stw	r2,-112(fp)
         ti->ti_dst.s_addr, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
 2030e50:	0001883a 	nop
    * If the state is CLOSED (i.e., TCB does not exist) then
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
 2030e54:	e0bfe417 	ldw	r2,-112(fp)
 2030e58:	1000061e 	bne	r2,zero,2030e74 <tcp_input+0x40c>
 2030e5c:	00000206 	br	2030e68 <tcp_input+0x400>
      inp = ip6_pcblookup(&tcb, &ip6_src, ti->ti_sport, 
         &ip6_dst, ti->ti_dport, INPLOOKUP_WILDCARD);
      break;
#endif   /* IP_V6 */
   default:
      dtrap();
 2030e60:	20285c80 	call	20285c8 <dtrap>
 2030e64:	0007cb06 	br	2032d94 <tcp_input+0x232c>
    * all data in the incoming segment is discarded.
    * If the TCB exists but is in CLOSED state, it is embryonic,
    * but should either do a listen or a connect soon.
    */
   if (inp == 0)
      GOTO_DROPWITHRESET;
 2030e68:	00806b04 	movi	r2,428
 2030e6c:	d0a0a915 	stw	r2,-32092(gp)
 2030e70:	00077d06 	br	2032c68 <tcp_input+0x2200>
   tp = intotcpcb (inp);
 2030e74:	e0bfe417 	ldw	r2,-112(fp)
 2030e78:	10800917 	ldw	r2,36(r2)
 2030e7c:	e0bfe615 	stw	r2,-104(fp)
   if (tp == 0)
 2030e80:	e0bfe617 	ldw	r2,-104(fp)
 2030e84:	1000031e 	bne	r2,zero,2030e94 <tcp_input+0x42c>
      GOTO_DROPWITHRESET;
 2030e88:	00806bc4 	movi	r2,431
 2030e8c:	d0a0a915 	stw	r2,-32092(gp)
 2030e90:	00077506 	br	2032c68 <tcp_input+0x2200>
   if (tp->t_state == TCPS_CLOSED)
 2030e94:	e0bfe617 	ldw	r2,-104(fp)
 2030e98:	10800217 	ldw	r2,8(r2)
 2030e9c:	1000031e 	bne	r2,zero,2030eac <tcp_input+0x444>
      GOTO_DROP;
 2030ea0:	00806c44 	movi	r2,433
 2030ea4:	d0a0a915 	stw	r2,-32092(gp)
 2030ea8:	0007b006 	br	2032d6c <tcp_input+0x2304>
   so = inp->inp_socket;
 2030eac:	e0bfe417 	ldw	r2,-112(fp)
 2030eb0:	10800817 	ldw	r2,32(r2)
 2030eb4:	e0bfe815 	stw	r2,-96(fp)
      tcp_saveti = *ti;
   }
#endif

   /* figure out the size of the other guy's receive window */
   rx_win = (tcp_win)(ntohs(ti->ti_win));    /* convert endian */
 2030eb8:	e0bff217 	ldw	r2,-56(fp)
 2030ebc:	1080088b 	ldhu	r2,34(r2)
 2030ec0:	10bfffcc 	andi	r2,r2,65535
 2030ec4:	1004d23a 	srli	r2,r2,8
 2030ec8:	10bfffcc 	andi	r2,r2,65535
 2030ecc:	10c03fcc 	andi	r3,r2,255
 2030ed0:	e0bff217 	ldw	r2,-56(fp)
 2030ed4:	1080088b 	ldhu	r2,34(r2)
 2030ed8:	10bfffcc 	andi	r2,r2,65535
 2030edc:	1004923a 	slli	r2,r2,8
 2030ee0:	10bfffcc 	andi	r2,r2,65535
 2030ee4:	1884b03a 	or	r2,r3,r2
 2030ee8:	e0bff515 	stw	r2,-44(fp)
   {
      rx_win <<= tp->snd_wind_scale;         /* apply scale */
   }
#endif /* TCP_WIN_SCALE */

   if (so->so_options & SO_ACCEPTCONN) 
 2030eec:	e0bfe817 	ldw	r2,-96(fp)
 2030ef0:	10800417 	ldw	r2,16(r2)
 2030ef4:	1080008c 	andi	r2,r2,2
 2030ef8:	10002d26 	beq	r2,zero,2030fb0 <tcp_input+0x548>
   {
      so = sonewconn(so);
 2030efc:	e13fe817 	ldw	r4,-96(fp)
 2030f00:	202ee180 	call	202ee18 <sonewconn>
 2030f04:	e0bfe815 	stw	r2,-96(fp)
      if (so == 0)
 2030f08:	e0bfe817 	ldw	r2,-96(fp)
 2030f0c:	1000031e 	bne	r2,zero,2030f1c <tcp_input+0x4b4>
         GOTO_DROP;
 2030f10:	00807344 	movi	r2,461
 2030f14:	d0a0a915 	stw	r2,-32092(gp)
 2030f18:	00079406 	br	2032d6c <tcp_input+0x2304>
       * flag dropsocket to see if the temporary
       * socket created here should be discarded.
       * We mark the socket as discardable until
       * we're committed to it below in TCPS_LISTEN.
       */
      dropsocket++;
 2030f1c:	e0bfec17 	ldw	r2,-80(fp)
 2030f20:	10800044 	addi	r2,r2,1
 2030f24:	e0bfec15 	stw	r2,-80(fp)

      inp = (struct inpcb *)so->so_pcb;
 2030f28:	e0bfe817 	ldw	r2,-96(fp)
 2030f2c:	10800117 	ldw	r2,4(r2)
 2030f30:	e0bfe415 	stw	r2,-112(fp)
      inp->ifp = ifp;      /* save iface to peer */
 2030f34:	e0bfe417 	ldw	r2,-112(fp)
 2030f38:	e0ffff17 	ldw	r3,-4(fp)
 2030f3c:	10c00a15 	stw	r3,40(r2)

      switch(so->so_domain)
 2030f40:	e0bfe817 	ldw	r2,-96(fp)
 2030f44:	10800517 	ldw	r2,20(r2)
 2030f48:	108000a0 	cmpeqi	r2,r2,2
 2030f4c:	10000e26 	beq	r2,zero,2030f88 <tcp_input+0x520>
      {
#ifdef IP_V4
      case AF_INET:
         inp->inp_laddr = ti->ti_dst;
 2030f50:	e0bfe417 	ldw	r2,-112(fp)
 2030f54:	e0fff217 	ldw	r3,-56(fp)
 2030f58:	18c00417 	ldw	r3,16(r3)
 2030f5c:	10c00415 	stw	r3,16(r2)
#ifdef IP_PMTU
         inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
         inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 2030f60:	e0bfff17 	ldw	r2,-4(fp)
 2030f64:	10c00917 	ldw	r3,36(r2)
 2030f68:	e0bfff17 	ldw	r2,-4(fp)
 2030f6c:	10800817 	ldw	r2,32(r2)
 2030f70:	013ff604 	movi	r4,-40
 2030f74:	2085c83a 	sub	r2,r4,r2
 2030f78:	1887883a 	add	r3,r3,r2
 2030f7c:	e0bfe417 	ldw	r2,-112(fp)
 2030f80:	10c00615 	stw	r3,24(r2)
#endif   /* IP_PMTU */
         break;
 2030f84:	0001883a 	nop
         inp->inp_pmtu = ip6_pmtulookup(&ip6_src, ifp);
         break;
#endif   /* end v6 */
      }

      inp->inp_lport = ti->ti_dport;
 2030f88:	e0bff217 	ldw	r2,-56(fp)
 2030f8c:	10c0058b 	ldhu	r3,22(r2)
 2030f90:	e0bfe417 	ldw	r2,-112(fp)
 2030f94:	10c0078d 	sth	r3,30(r2)
      tp = intotcpcb(inp);
 2030f98:	e0bfe417 	ldw	r2,-112(fp)
 2030f9c:	10800917 	ldw	r2,36(r2)
 2030fa0:	e0bfe615 	stw	r2,-104(fp)
      tp->t_state = TCPS_LISTEN;
 2030fa4:	e0bfe617 	ldw	r2,-104(fp)
 2030fa8:	00c00044 	movi	r3,1
 2030fac:	10c00215 	stw	r3,8(r2)

   /*
    * Segment received on connection.
    * Reset idle time and keep-alive timer.
    */
   tp->t_idle = 0;
 2030fb0:	e0bfe617 	ldw	r2,-104(fp)
 2030fb4:	10001d15 	stw	zero,116(r2)
   tp->t_timer[TCPT_KEEP] = tcp_keepidle;
 2030fb8:	00808174 	movhi	r2,517
 2030fbc:	10906e04 	addi	r2,r2,16824
 2030fc0:	10c00017 	ldw	r3,0(r2)
 2030fc4:	e0bfe617 	ldw	r2,-104(fp)
 2030fc8:	10c00515 	stw	r3,20(r2)

   /*
    * Process options if not in LISTEN state,
    * else do it below (after getting remote address).
    */
   if (om && tp->t_state != TCPS_LISTEN) 
 2030fcc:	e0bfe517 	ldw	r2,-108(fp)
 2030fd0:	10000926 	beq	r2,zero,2030ff8 <tcp_input+0x590>
 2030fd4:	e0bfe617 	ldw	r2,-104(fp)
 2030fd8:	10800217 	ldw	r2,8(r2)
 2030fdc:	10800060 	cmpeqi	r2,r2,1
 2030fe0:	1000051e 	bne	r2,zero,2030ff8 <tcp_input+0x590>
   {
      tcp_dooptions(tp, om, ti);
 2030fe4:	e13fe617 	ldw	r4,-104(fp)
 2030fe8:	e17fe517 	ldw	r5,-108(fp)
 2030fec:	e1bff217 	ldw	r6,-56(fp)
 2030ff0:	2032da80 	call	2032da8 <tcp_dooptions>
      om = 0;
 2030ff4:	e03fe515 	stw	zero,-108(fp)
   }

   acked = (int)(ti->ti_ack - tp->snd_una);
 2030ff8:	e0bff217 	ldw	r2,-56(fp)
 2030ffc:	10c00717 	ldw	r3,28(r2)
 2031000:	e0bfe617 	ldw	r2,-104(fp)
 2031004:	10800e17 	ldw	r2,56(r2)
 2031008:	1885c83a 	sub	r2,r3,r2
 203100c:	e0bff615 	stw	r2,-40(fp)
    * Receive window is amount of space in rcv queue,
    * but not less than advertised window.
    */
   { long win;

      win = (long)sbspace(&so->so_rcv);
 2031010:	e0bfe817 	ldw	r2,-96(fp)
 2031014:	10800b17 	ldw	r2,44(r2)
 2031018:	1007883a 	mov	r3,r2
 203101c:	e0bfe817 	ldw	r2,-96(fp)
 2031020:	10800a17 	ldw	r2,40(r2)
 2031024:	1885c83a 	sub	r2,r3,r2
 2031028:	10000616 	blt	r2,zero,2031044 <tcp_input+0x5dc>
 203102c:	e0bfe817 	ldw	r2,-96(fp)
 2031030:	10c00b17 	ldw	r3,44(r2)
 2031034:	e0bfe817 	ldw	r2,-96(fp)
 2031038:	10800a17 	ldw	r2,40(r2)
 203103c:	1885c83a 	sub	r2,r3,r2
 2031040:	00000106 	br	2031048 <tcp_input+0x5e0>
 2031044:	0005883a 	mov	r2,zero
 2031048:	e0bfef15 	stw	r2,-68(fp)
      if (win < 0)
 203104c:	e0bfef17 	ldw	r2,-68(fp)
 2031050:	1000010e 	bge	r2,zero,2031058 <tcp_input+0x5f0>
         win = 0;
 2031054:	e03fef15 	stw	zero,-68(fp)
      tp->rcv_wnd = (tcp_win)MAX((u_long)win, (tp->rcv_adv - tp->rcv_nxt));
 2031058:	e0bfe617 	ldw	r2,-104(fp)
 203105c:	10c01917 	ldw	r3,100(r2)
 2031060:	e0bfe617 	ldw	r2,-104(fp)
 2031064:	10801617 	ldw	r2,88(r2)
 2031068:	1885c83a 	sub	r2,r3,r2
 203106c:	e0ffef17 	ldw	r3,-68(fp)
 2031070:	10c0012e 	bgeu	r2,r3,2031078 <tcp_input+0x610>
 2031074:	1805883a 	mov	r2,r3
 2031078:	e0ffe617 	ldw	r3,-104(fp)
 203107c:	18801515 	stw	r2,84(r3)
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 2031080:	e0bfe617 	ldw	r2,-104(fp)
 2031084:	10800217 	ldw	r2,8(r2)
 2031088:	10800118 	cmpnei	r2,r2,4
 203108c:	1001011e 	bne	r2,zero,2031494 <tcp_input+0xa2c>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 2031090:	e0bfe717 	ldw	r2,-100(fp)
 2031094:	10800dcc 	andi	r2,r2,55
    * is non-zero and the ack didn't move, we're the
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
 2031098:	10800418 	cmpnei	r2,r2,16
 203109c:	1000fd1e 	bne	r2,zero,2031494 <tcp_input+0xa2c>
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
 20310a0:	e0bff217 	ldw	r2,-56(fp)
 20310a4:	10c00617 	ldw	r3,24(r2)
 20310a8:	e0bfe617 	ldw	r2,-104(fp)
 20310ac:	10801617 	ldw	r2,88(r2)
    * receiver side.  If we're getting packets in-order
    * (the reassembly queue is empty), add the data to
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
 20310b0:	1880f81e 	bne	r3,r2,2031494 <tcp_input+0xa2c>
       (ti->ti_seq == tp->rcv_nxt) &&
 20310b4:	e0bff517 	ldw	r2,-44(fp)
 20310b8:	1000f626 	beq	r2,zero,2031494 <tcp_input+0xa2c>
       (rx_win && rx_win == tp->snd_wnd) &&
 20310bc:	e0bfe617 	ldw	r2,-104(fp)
 20310c0:	10c01417 	ldw	r3,80(r2)
 20310c4:	e0bff517 	ldw	r2,-44(fp)
 20310c8:	1880f21e 	bne	r3,r2,2031494 <tcp_input+0xa2c>
       (tp->snd_nxt == tp->snd_max))
 20310cc:	e0bfe617 	ldw	r2,-104(fp)
 20310d0:	10c00f17 	ldw	r3,60(r2)
 20310d4:	e0bfe617 	ldw	r2,-104(fp)
 20310d8:	10801a17 	ldw	r2,104(r2)
    * the socket buffer and note that we need a delayed ack.
    */
   if ((tp->t_state == TCPS_ESTABLISHED) &&
       ((tiflags & (TH_SYN|TH_FIN|TH_RST|TH_URG|TH_ACK)) == TH_ACK) &&
       (ti->ti_seq == tp->rcv_nxt) &&
       (rx_win && rx_win == tp->snd_wnd) &&
 20310dc:	1880ed1e 	bne	r3,r2,2031494 <tcp_input+0xa2c>
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
 20310e0:	e0bff217 	ldw	r2,-56(fp)
 20310e4:	1080028b 	ldhu	r2,10(r2)
 20310e8:	10bfffcc 	andi	r2,r2,65535
 20310ec:	1000611e 	bne	r2,zero,2031274 <tcp_input+0x80c>
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 20310f0:	e0bff217 	ldw	r2,-56(fp)
 20310f4:	10c00717 	ldw	r3,28(r2)
 20310f8:	e0bfe617 	ldw	r2,-104(fp)
 20310fc:	10800e17 	ldw	r2,56(r2)
 2031100:	1885c83a 	sub	r2,r3,r2
 2031104:	0080e30e 	bge	zero,r2,2031494 <tcp_input+0xa2c>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 2031108:	e0bff217 	ldw	r2,-56(fp)
 203110c:	10c00717 	ldw	r3,28(r2)
 2031110:	e0bfe617 	ldw	r2,-104(fp)
 2031114:	10801a17 	ldw	r2,104(r2)
 2031118:	1885c83a 	sub	r2,r3,r2
       (rx_win && rx_win == tp->snd_wnd) &&
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
 203111c:	0080dd16 	blt	zero,r2,2031494 <tcp_input+0xa2c>
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
             tp->snd_cwnd >= tp->snd_wnd) 
 2031120:	e0bfe617 	ldw	r2,-104(fp)
 2031124:	10c01b17 	ldw	r3,108(r2)
 2031128:	e0bfe617 	ldw	r2,-104(fp)
 203112c:	10801417 	ldw	r2,80(r2)
       (tp->snd_nxt == tp->snd_max))
   {
      if (ti->ti_len == 0)
      {
         if (SEQ_GT(ti->ti_ack, tp->snd_una) &&
             SEQ_LEQ(ti->ti_ack, tp->snd_max) &&
 2031130:	1880d836 	bltu	r3,r2,2031494 <tcp_input+0xa2c>
             tp->snd_cwnd >= tp->snd_wnd) 
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
 2031134:	00809934 	movhi	r2,612
 2031138:	10b6f504 	addi	r2,r2,-9260
 203113c:	10803517 	ldw	r2,212(r2)
 2031140:	10c00044 	addi	r3,r2,1
 2031144:	00809934 	movhi	r2,612
 2031148:	10b6f504 	addi	r2,r2,-9260
 203114c:	10c03515 	stw	r3,212(r2)
            if (tp->t_rttick && 
 2031150:	e0bfe617 	ldw	r2,-104(fp)
 2031154:	10801e17 	ldw	r2,120(r2)
 2031158:	10000826 	beq	r2,zero,203117c <tcp_input+0x714>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 203115c:	e0bff217 	ldw	r2,-56(fp)
 2031160:	10c00717 	ldw	r3,28(r2)
 2031164:	e0bfe617 	ldw	r2,-104(fp)
 2031168:	10801f17 	ldw	r2,124(r2)
 203116c:	1885c83a 	sub	r2,r3,r2
         {
            /*
             * this is a pure ack for outstanding data.
             */
            ++tcpstat.tcps_predack;
            if (tp->t_rttick && 
 2031170:	0080020e 	bge	zero,r2,203117c <tcp_input+0x714>
#ifdef TCP_TIMESTAMP
               ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
               (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
            {
               tcp_xmit_timer(tp);
 2031174:	e13fe617 	ldw	r4,-104(fp)
 2031178:	20330540 	call	2033054 <tcp_xmit_timer>
            }

            tcpstat.tcps_rcvackpack++;
 203117c:	00809934 	movhi	r2,612
 2031180:	10b6f504 	addi	r2,r2,-9260
 2031184:	10802b17 	ldw	r2,172(r2)
 2031188:	10c00044 	addi	r3,r2,1
 203118c:	00809934 	movhi	r2,612
 2031190:	10b6f504 	addi	r2,r2,-9260
 2031194:	10c02b15 	stw	r3,172(r2)
            tcpstat.tcps_rcvackbyte += acked;
 2031198:	00809934 	movhi	r2,612
 203119c:	10b6f504 	addi	r2,r2,-9260
 20311a0:	10c02c17 	ldw	r3,176(r2)
 20311a4:	e0bff617 	ldw	r2,-40(fp)
 20311a8:	1887883a 	add	r3,r3,r2
 20311ac:	00809934 	movhi	r2,612
 20311b0:	10b6f504 	addi	r2,r2,-9260
 20311b4:	10c02c15 	stw	r3,176(r2)
            sbdrop(&so->so_snd, acked);
 20311b8:	e0bfe817 	ldw	r2,-96(fp)
 20311bc:	10801204 	addi	r2,r2,72
 20311c0:	1009883a 	mov	r4,r2
 20311c4:	e17ff617 	ldw	r5,-40(fp)
 20311c8:	202fa940 	call	202fa94 <sbdrop>
            tp->snd_una = ti->ti_ack;
 20311cc:	e0bff217 	ldw	r2,-56(fp)
 20311d0:	10c00717 	ldw	r3,28(r2)
 20311d4:	e0bfe617 	ldw	r2,-104(fp)
 20311d8:	10c00e15 	stw	r3,56(r2)
            m_freem(m);
 20311dc:	e13ffe17 	ldw	r4,-8(fp)
 20311e0:	20296780 	call	2029678 <m_freem>
             * If process is waiting for space,
             * wakeup/selwakeup/signal.  If data
             * are ready to send, let tcp_output
             * decide between more output or persist.
             */
            if (tp->snd_una == tp->snd_max)
 20311e4:	e0bfe617 	ldw	r2,-104(fp)
 20311e8:	10c00e17 	ldw	r3,56(r2)
 20311ec:	e0bfe617 	ldw	r2,-104(fp)
 20311f0:	10801a17 	ldw	r2,104(r2)
 20311f4:	1880031e 	bne	r3,r2,2031204 <tcp_input+0x79c>
               tp->t_timer[TCPT_REXMT] = 0;
 20311f8:	e0bfe617 	ldw	r2,-104(fp)
 20311fc:	10000315 	stw	zero,12(r2)
 2031200:	00000706 	br	2031220 <tcp_input+0x7b8>
            else if (tp->t_timer[TCPT_PERSIST] == 0)
 2031204:	e0bfe617 	ldw	r2,-104(fp)
 2031208:	10800417 	ldw	r2,16(r2)
 203120c:	1000041e 	bne	r2,zero,2031220 <tcp_input+0x7b8>
               tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 2031210:	e0bfe617 	ldw	r2,-104(fp)
 2031214:	10c00817 	ldw	r3,32(r2)
 2031218:	e0bfe617 	ldw	r2,-104(fp)
 203121c:	10c00315 	stw	r3,12(r2)

            if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 2031220:	e0bfe817 	ldw	r2,-96(fp)
 2031224:	1080190b 	ldhu	r2,100(r2)
 2031228:	10bfffcc 	andi	r2,r2,65535
 203122c:	1080030c 	andi	r2,r2,12
 2031230:	10000526 	beq	r2,zero,2031248 <tcp_input+0x7e0>
               sowwakeup(so);
 2031234:	e0bfe817 	ldw	r2,-96(fp)
 2031238:	10801204 	addi	r2,r2,72
 203123c:	e13fe817 	ldw	r4,-96(fp)
 2031240:	100b883a 	mov	r5,r2
 2031244:	202f3300 	call	202f330 <sbwakeup>

            /* If there is more data in the send buffer, and some is
             * still unsent, then call tcp_output() to try to send it
             */
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
 2031248:	e0bfe817 	ldw	r2,-96(fp)
 203124c:	10801217 	ldw	r2,72(r2)
 2031250:	e0ffe617 	ldw	r3,-104(fp)
 2031254:	19000f17 	ldw	r4,60(r3)
 2031258:	e0ffe617 	ldw	r3,-104(fp)
 203125c:	18c00e17 	ldw	r3,56(r3)
 2031260:	20c7c83a 	sub	r3,r4,r3
 2031264:	1886cb2e 	bgeu	r3,r2,2032d94 <tcp_input+0x232c>
               (void) tcp_output(tp);
 2031268:	e13fe617 	ldw	r4,-104(fp)
 203126c:	20334200 	call	2033420 <tcp_output>
 2031270:	0006c806 	br	2032d94 <tcp_input+0x232c>
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 2031274:	e0bff217 	ldw	r2,-56(fp)
 2031278:	10c00717 	ldw	r3,28(r2)
 203127c:	e0bfe617 	ldw	r2,-104(fp)
 2031280:	10800e17 	ldw	r2,56(r2)
 2031284:	1880831e 	bne	r3,r2,2031494 <tcp_input+0xa2c>
          tp->seg_next == (struct tcpiphdr *)tp &&
 2031288:	e0bfe617 	ldw	r2,-104(fp)
 203128c:	10c00017 	ldw	r3,0(r2)
            if (so->so_snd.sb_cc > (tp->snd_nxt - tp->snd_una))
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
 2031290:	e0bfe617 	ldw	r2,-104(fp)
 2031294:	18807f1e 	bne	r3,r2,2031494 <tcp_input+0xa2c>
          tp->seg_next == (struct tcpiphdr *)tp &&
          ti->ti_len <= sbspace(&so->so_rcv))
 2031298:	e0bff217 	ldw	r2,-56(fp)
 203129c:	1080028b 	ldhu	r2,10(r2)
 20312a0:	10ffffcc 	andi	r3,r2,65535
 20312a4:	e0bfe817 	ldw	r2,-96(fp)
 20312a8:	10800b17 	ldw	r2,44(r2)
 20312ac:	1009883a 	mov	r4,r2
 20312b0:	e0bfe817 	ldw	r2,-96(fp)
 20312b4:	10800a17 	ldw	r2,40(r2)
 20312b8:	2085c83a 	sub	r2,r4,r2
 20312bc:	10000616 	blt	r2,zero,20312d8 <tcp_input+0x870>
 20312c0:	e0bfe817 	ldw	r2,-96(fp)
 20312c4:	11000b17 	ldw	r4,44(r2)
 20312c8:	e0bfe817 	ldw	r2,-96(fp)
 20312cc:	10800a17 	ldw	r2,40(r2)
 20312d0:	2085c83a 	sub	r2,r4,r2
 20312d4:	00000106 	br	20312dc <tcp_input+0x874>
 20312d8:	0005883a 	mov	r2,zero
               (void) tcp_output(tp);
            return;
         }
      }
      else if (ti->ti_ack == tp->snd_una &&
          tp->seg_next == (struct tcpiphdr *)tp &&
 20312dc:	10c06d36 	bltu	r2,r3,2031494 <tcp_input+0xa2c>
#endif   /* TCP_ZEROCOPY */

         /* this may also be a garden-variety probe received because
          * the socket sendbuf was full.
          */
         if(tp->rcv_wnd == 0)
 20312e0:	e0bfe617 	ldw	r2,-104(fp)
 20312e4:	10801517 	ldw	r2,84(r2)
 20312e8:	10000c1e 	bne	r2,zero,203131c <tcp_input+0x8b4>
             * info in this seg, but Windows NT 4.0 has a nasty bug where it
             * will hammer us mericilessly with these probes (one customer
             * reports thousands per second) so we just dump it ASAP to
             * save cycles.
             */
            tcpstat.tcps_rcvwinprobe++;
 20312ec:	00809934 	movhi	r2,612
 20312f0:	10b6f504 	addi	r2,r2,-9260
 20312f4:	10802817 	ldw	r2,160(r2)
 20312f8:	10c00044 	addi	r3,r2,1
 20312fc:	00809934 	movhi	r2,612
 2031300:	10b6f504 	addi	r2,r2,-9260
 2031304:	10c02815 	stw	r3,160(r2)
            m_freem (m);      /* free the received mbuf */
 2031308:	e13ffe17 	ldw	r4,-8(fp)
 203130c:	20296780 	call	2029678 <m_freem>
            tcp_output(tp);   /* send the ack now... */
 2031310:	e13fe617 	ldw	r4,-104(fp)
 2031314:	20334200 	call	2033420 <tcp_output>
 2031318:	00069e06 	br	2032d94 <tcp_input+0x232c>
         /*
          * this is a pure, in-sequence data packet
          * with nothing on the reassembly queue and
          * we have enough buffer space to take it.
          */
         ++tcpstat.tcps_preddat;
 203131c:	00809934 	movhi	r2,612
 2031320:	10b6f504 	addi	r2,r2,-9260
 2031324:	10803617 	ldw	r2,216(r2)
 2031328:	10c00044 	addi	r3,r2,1
 203132c:	00809934 	movhi	r2,612
 2031330:	10b6f504 	addi	r2,r2,-9260
 2031334:	10c03615 	stw	r3,216(r2)
         tp->rcv_nxt += ti->ti_len;
 2031338:	e0bfe617 	ldw	r2,-104(fp)
 203133c:	10c01617 	ldw	r3,88(r2)
 2031340:	e0bff217 	ldw	r2,-56(fp)
 2031344:	1080028b 	ldhu	r2,10(r2)
 2031348:	10bfffcc 	andi	r2,r2,65535
 203134c:	1887883a 	add	r3,r3,r2
 2031350:	e0bfe617 	ldw	r2,-104(fp)
 2031354:	10c01615 	stw	r3,88(r2)
         tcpstat.tcps_rcvpack++;
 2031358:	00809934 	movhi	r2,612
 203135c:	10b6f504 	addi	r2,r2,-9260
 2031360:	10801a17 	ldw	r2,104(r2)
 2031364:	10c00044 	addi	r3,r2,1
 2031368:	00809934 	movhi	r2,612
 203136c:	10b6f504 	addi	r2,r2,-9260
 2031370:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 2031374:	00809934 	movhi	r2,612
 2031378:	10b6f504 	addi	r2,r2,-9260
 203137c:	10c01b17 	ldw	r3,108(r2)
 2031380:	e0bff217 	ldw	r2,-56(fp)
 2031384:	1080028b 	ldhu	r2,10(r2)
 2031388:	10bfffcc 	andi	r2,r2,65535
 203138c:	1887883a 	add	r3,r3,r2
 2031390:	00809934 	movhi	r2,612
 2031394:	10b6f504 	addi	r2,r2,-9260
 2031398:	10c01b15 	stw	r3,108(r2)
         /*
          * Add data to socket buffer.
          */
         sbappend(&so->so_rcv, m);
 203139c:	e0bfe817 	ldw	r2,-96(fp)
 20313a0:	10800a04 	addi	r2,r2,40
 20313a4:	1009883a 	mov	r4,r2
 20313a8:	e17ffe17 	ldw	r5,-8(fp)
 20313ac:	202f4e40 	call	202f4e4 <sbappend>
         sorwakeup(so);
 20313b0:	e0bfe817 	ldw	r2,-96(fp)
 20313b4:	10800a04 	addi	r2,r2,40
 20313b8:	e13fe817 	ldw	r4,-96(fp)
 20313bc:	100b883a 	mov	r5,r2
 20313c0:	202f3300 	call	202f330 <sbwakeup>
         /*
          * If this is a short packet, then ACK now - with Nagel
          *   congestion avoidance sender won't send more until
          *   he gets an ACK.
          */
         if (tiflags & TH_PUSH)
 20313c4:	e0bfe717 	ldw	r2,-100(fp)
 20313c8:	1080020c 	andi	r2,r2,8
 20313cc:	10000726 	beq	r2,zero,20313ec <tcp_input+0x984>
            tp->t_flags |= TF_ACKNOW;
 20313d0:	e0bfe617 	ldw	r2,-104(fp)
 20313d4:	10800b0b 	ldhu	r2,44(r2)
 20313d8:	10800054 	ori	r2,r2,1
 20313dc:	1007883a 	mov	r3,r2
 20313e0:	e0bfe617 	ldw	r2,-104(fp)
 20313e4:	10c00b0d 	sth	r3,44(r2)
 20313e8:	00000606 	br	2031404 <tcp_input+0x99c>
         else
            tp->t_flags |= TF_DELACK;
 20313ec:	e0bfe617 	ldw	r2,-104(fp)
 20313f0:	10800b0b 	ldhu	r2,44(r2)
 20313f4:	10800094 	ori	r2,r2,2
 20313f8:	1007883a 	mov	r3,r2
 20313fc:	e0bfe617 	ldw	r2,-104(fp)
 2031400:	10c00b0d 	sth	r3,44(r2)

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));
 2031404:	e0bfe617 	ldw	r2,-104(fp)
 2031408:	10c01517 	ldw	r3,84(r2)
 203140c:	e0bfe617 	ldw	r2,-104(fp)
 2031410:	11001617 	ldw	r4,88(r2)
 2031414:	e0bfe617 	ldw	r2,-104(fp)
 2031418:	10801917 	ldw	r2,100(r2)
 203141c:	2085c83a 	sub	r2,r4,r2
 2031420:	1885883a 	add	r2,r3,r2
 2031424:	e0bff715 	stw	r2,-36(fp)

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 2031428:	e0bfe617 	ldw	r2,-104(fp)
 203142c:	10800a0b 	ldhu	r2,40(r2)
 2031430:	10bfffcc 	andi	r2,r2,65535
 2031434:	1085883a 	add	r2,r2,r2
 2031438:	e0fff717 	ldw	r3,-36(fp)
 203143c:	1880050e 	bge	r3,r2,2031454 <tcp_input+0x9ec>
             (tp->t_flags & TF_ACKNOW))
 2031440:	e0bfe617 	ldw	r2,-104(fp)
 2031444:	10800b0b 	ldhu	r2,44(r2)
 2031448:	10bfffcc 	andi	r2,r2,65535
 203144c:	1080004c 	andi	r2,r2,1
            tp->t_flags |= TF_DELACK;

         /* see if we need to send an ack */
         adv = (int)(tp->rcv_wnd - (tcp_win)(tp->rcv_adv - tp->rcv_nxt));

         if ((adv >= (int)(tp->t_maxseg * 2)) ||
 2031450:	10065026 	beq	r2,zero,2032d94 <tcp_input+0x232c>
               tp->t_flags &= ~TF_ACKNOW;
               return;
            }
#endif   /* DO_DELAY_ACKS */

            tp->t_flags |= TF_ACKNOW;
 2031454:	e0bfe617 	ldw	r2,-104(fp)
 2031458:	10800b0b 	ldhu	r2,44(r2)
 203145c:	10800054 	ori	r2,r2,1
 2031460:	1007883a 	mov	r3,r2
 2031464:	e0bfe617 	ldw	r2,-104(fp)
 2031468:	10c00b0d 	sth	r3,44(r2)
            tp->t_flags &= ~TF_DELACK;
 203146c:	e0bfe617 	ldw	r2,-104(fp)
 2031470:	10c00b0b 	ldhu	r3,44(r2)
 2031474:	00bfff44 	movi	r2,-3
 2031478:	1884703a 	and	r2,r3,r2
 203147c:	1007883a 	mov	r3,r2
 2031480:	e0bfe617 	ldw	r2,-104(fp)
 2031484:	10c00b0d 	sth	r3,44(r2)
            tcp_output(tp);   /* send the ack now... */
 2031488:	e13fe617 	ldw	r4,-104(fp)
 203148c:	20334200 	call	2033420 <tcp_output>
 2031490:	00064006 	br	2032d94 <tcp_input+0x232c>

         return;
      }
   }

   switch (tp->t_state) 
 2031494:	e0bfe617 	ldw	r2,-104(fp)
 2031498:	10800217 	ldw	r2,8(r2)
 203149c:	10c00060 	cmpeqi	r3,r2,1
 20314a0:	1800031e 	bne	r3,zero,20314b0 <tcp_input+0xa48>
 20314a4:	108000a0 	cmpeqi	r2,r2,2
 20314a8:	1000af1e 	bne	r2,zero,2031768 <tcp_input+0xd00>
 20314ac:	00018306 	br	2031abc <tcp_input+0x1054>
    */
   case TCPS_LISTEN: 
   {
         struct mbuf *  am;

         if (tiflags & TH_RST)
 20314b0:	e0bfe717 	ldw	r2,-100(fp)
 20314b4:	1080010c 	andi	r2,r2,4
 20314b8:	10000326 	beq	r2,zero,20314c8 <tcp_input+0xa60>
            GOTO_DROP;
 20314bc:	0080bec4 	movi	r2,763
 20314c0:	d0a0a915 	stw	r2,-32092(gp)
 20314c4:	00062906 	br	2032d6c <tcp_input+0x2304>
         if (tiflags & TH_ACK)
 20314c8:	e0bfe717 	ldw	r2,-100(fp)
 20314cc:	1080040c 	andi	r2,r2,16
 20314d0:	10000326 	beq	r2,zero,20314e0 <tcp_input+0xa78>
            GOTO_DROPWITHRESET;
 20314d4:	0080bf44 	movi	r2,765
 20314d8:	d0a0a915 	stw	r2,-32092(gp)
 20314dc:	0005e206 	br	2032c68 <tcp_input+0x2200>
         if ((tiflags & TH_SYN) == 0)
 20314e0:	e0bfe717 	ldw	r2,-100(fp)
 20314e4:	1080008c 	andi	r2,r2,2
 20314e8:	1000031e 	bne	r2,zero,20314f8 <tcp_input+0xa90>
            GOTO_DROP;
 20314ec:	0080bfc4 	movi	r2,767
 20314f0:	d0a0a915 	stw	r2,-32092(gp)
 20314f4:	00061d06 	br	2032d6c <tcp_input+0x2304>
         if(in_broadcast(ti->ti_dst.s_addr))
 20314f8:	e0bff217 	ldw	r2,-56(fp)
 20314fc:	10800417 	ldw	r2,16(r2)
 2031500:	1009883a 	mov	r4,r2
 2031504:	202a5e00 	call	202a5e0 <in_broadcast>
 2031508:	10000326 	beq	r2,zero,2031518 <tcp_input+0xab0>
            GOTO_DROP;
 203150c:	0080c044 	movi	r2,769
 2031510:	d0a0a915 	stw	r2,-32092(gp)
 2031514:	00061506 	br	2032d6c <tcp_input+0x2304>
         am = m_getwithdata (MT_SONAME, sizeof (struct sockaddr));
 2031518:	01000244 	movi	r4,9
 203151c:	01400404 	movi	r5,16
 2031520:	20293d80 	call	20293d8 <m_getnbuf>
 2031524:	e0bff815 	stw	r2,-32(fp)
         if (am == NULL)
 2031528:	e0bff817 	ldw	r2,-32(fp)
 203152c:	1000031e 	bne	r2,zero,203153c <tcp_input+0xad4>
            GOTO_DROP;
 2031530:	0080c104 	movi	r2,772
 2031534:	d0a0a915 	stw	r2,-32092(gp)
 2031538:	00060c06 	br	2032d6c <tcp_input+0x2304>

#ifdef IP_V4
         if(inp->inp_socket->so_domain == AF_INET)
 203153c:	e0bfe417 	ldw	r2,-112(fp)
 2031540:	10800817 	ldw	r2,32(r2)
 2031544:	10800517 	ldw	r2,20(r2)
 2031548:	10800098 	cmpnei	r2,r2,2
 203154c:	10002c1e 	bne	r2,zero,2031600 <tcp_input+0xb98>
         {
         struct sockaddr_in * sin;
         am->m_len = sizeof (struct sockaddr_in);
 2031550:	e0bff817 	ldw	r2,-32(fp)
 2031554:	00c00404 	movi	r3,16
 2031558:	10c00215 	stw	r3,8(r2)
         sin = mtod(am, struct sockaddr_in *);
 203155c:	e0bff817 	ldw	r2,-32(fp)
 2031560:	10800317 	ldw	r2,12(r2)
 2031564:	e0bff915 	stw	r2,-28(fp)
         sin->sin_family = AF_INET;
 2031568:	e0bff917 	ldw	r2,-28(fp)
 203156c:	00c00084 	movi	r3,2
 2031570:	10c0000d 	sth	r3,0(r2)
         sin->sin_addr = ti->ti_src;
 2031574:	e0bff917 	ldw	r2,-28(fp)
 2031578:	e0fff217 	ldw	r3,-56(fp)
 203157c:	18c00317 	ldw	r3,12(r3)
 2031580:	10c00115 	stw	r3,4(r2)
         sin->sin_port = ti->ti_sport;
 2031584:	e0bff217 	ldw	r2,-56(fp)
 2031588:	10c0050b 	ldhu	r3,20(r2)
 203158c:	e0bff917 	ldw	r2,-28(fp)
 2031590:	10c0008d 	sth	r3,2(r2)
         /* Assuming pcbconnect will work, we put the sender's address in 
          * the inp_laddr (after saving a local laddr copy). If the connect
          * fails we restore the inpcb before going to drop:
          */
         laddr = inp->inp_laddr;    /* save tmp laddr */
 2031594:	e0bfe417 	ldw	r2,-112(fp)
 2031598:	10800417 	ldw	r2,16(r2)
 203159c:	e0bffd15 	stw	r2,-12(fp)
         if (inp->inp_laddr.s_addr == INADDR_ANY)
 20315a0:	e0bfe417 	ldw	r2,-112(fp)
 20315a4:	10800417 	ldw	r2,16(r2)
 20315a8:	1000041e 	bne	r2,zero,20315bc <tcp_input+0xb54>
            inp->inp_laddr = ti->ti_dst;
 20315ac:	e0bfe417 	ldw	r2,-112(fp)
 20315b0:	e0fff217 	ldw	r3,-56(fp)
 20315b4:	18c00417 	ldw	r3,16(r3)
 20315b8:	10c00415 	stw	r3,16(r2)
         if (in_pcbconnect (inp, am)) 
 20315bc:	e13fe417 	ldw	r4,-112(fp)
 20315c0:	e17ff817 	ldw	r5,-32(fp)
 20315c4:	20488240 	call	2048824 <in_pcbconnect>
 20315c8:	10000826 	beq	r2,zero,20315ec <tcp_input+0xb84>
         {
            inp->inp_laddr = laddr;
 20315cc:	e0bfe417 	ldw	r2,-112(fp)
 20315d0:	e0fffd17 	ldw	r3,-12(fp)
 20315d4:	10c00415 	stw	r3,16(r2)
            (void) m_free(am);
 20315d8:	e13ff817 	ldw	r4,-32(fp)
 20315dc:	20295600 	call	2029560 <m_free>
            GOTO_DROP;
 20315e0:	0080c684 	movi	r2,794
 20315e4:	d0a0a915 	stw	r2,-32092(gp)
 20315e8:	0005e006 	br	2032d6c <tcp_input+0x2304>
         }
         
         inp->ifp = ifp;      /* set interface for conn.*/
 20315ec:	e0bfe417 	ldw	r2,-112(fp)
 20315f0:	e0ffff17 	ldw	r3,-4(fp)
 20315f4:	10c00a15 	stw	r3,40(r2)
         
         (void) m_free (am);
 20315f8:	e13ff817 	ldw	r4,-32(fp)
 20315fc:	20295600 	call	2029560 <m_free>
            }
            (void) m_free(am);
         }
#endif   /* end v6 */

         tp->t_template = tcp_template(tp);
 2031600:	e13fe617 	ldw	r4,-104(fp)
 2031604:	20346580 	call	2034658 <tcp_template>
 2031608:	e0ffe617 	ldw	r3,-104(fp)
 203160c:	18800c15 	stw	r2,48(r3)
         if (tp->t_template == 0) 
 2031610:	e0bfe617 	ldw	r2,-104(fp)
 2031614:	10800c17 	ldw	r2,48(r2)
 2031618:	1000071e 	bne	r2,zero,2031638 <tcp_input+0xbd0>
         {
            SETTP(tp, tcp_drop(tp, ENOBUFS));
 203161c:	e13fe617 	ldw	r4,-104(fp)
 2031620:	01401a44 	movi	r5,105
 2031624:	2034c780 	call	2034c78 <tcp_drop>
            dropsocket = 0;      /* socket is already gone */
 2031628:	e03fec15 	stw	zero,-80(fp)
            GOTO_DROP;
 203162c:	0080d1c4 	movi	r2,839
 2031630:	d0a0a915 	stw	r2,-32092(gp)
 2031634:	0005cd06 	br	2032d6c <tcp_input+0x2304>
         }
         if (om) 
 2031638:	e0bfe517 	ldw	r2,-108(fp)
 203163c:	10000526 	beq	r2,zero,2031654 <tcp_input+0xbec>
         {
            tcp_dooptions(tp, om, ti);
 2031640:	e13fe617 	ldw	r4,-104(fp)
 2031644:	e17fe517 	ldw	r5,-108(fp)
 2031648:	e1bff217 	ldw	r6,-56(fp)
 203164c:	2032da80 	call	2032da8 <tcp_dooptions>
            om = 0;
 2031650:	e03fe515 	stw	zero,-108(fp)
         }
         if (iss)
 2031654:	e0bfed17 	ldw	r2,-76(fp)
 2031658:	10000426 	beq	r2,zero,203166c <tcp_input+0xc04>
            tp->iss = iss;
 203165c:	e0ffed17 	ldw	r3,-76(fp)
 2031660:	e0bfe617 	ldw	r2,-104(fp)
 2031664:	10c01315 	stw	r3,76(r2)
 2031668:	00000506 	br	2031680 <tcp_input+0xc18>
         else
            tp->iss = tcp_iss;
 203166c:	00808174 	movhi	r2,517
 2031670:	1090d604 	addi	r2,r2,17240
 2031674:	10c00017 	ldw	r3,0(r2)
 2031678:	e0bfe617 	ldw	r2,-104(fp)
 203167c:	10c01315 	stw	r3,76(r2)
         tcp_iss += (unsigned)(TCP_ISSINCR/2);
 2031680:	00808174 	movhi	r2,517
 2031684:	1090d604 	addi	r2,r2,17240
 2031688:	10c00017 	ldw	r3,0(r2)
 203168c:	00be9fd4 	movui	r2,64127
 2031690:	1887883a 	add	r3,r3,r2
 2031694:	00808174 	movhi	r2,517
 2031698:	1090d604 	addi	r2,r2,17240
 203169c:	10c00015 	stw	r3,0(r2)
         tp->irs = ti->ti_seq;
 20316a0:	e0bff217 	ldw	r2,-56(fp)
 20316a4:	10c00617 	ldw	r3,24(r2)
 20316a8:	e0bfe617 	ldw	r2,-104(fp)
 20316ac:	10c01815 	stw	r3,96(r2)
         tcp_sendseqinit(tp);
 20316b0:	e0bfe617 	ldw	r2,-104(fp)
 20316b4:	10c01317 	ldw	r3,76(r2)
 20316b8:	e0bfe617 	ldw	r2,-104(fp)
 20316bc:	10c01015 	stw	r3,64(r2)
 20316c0:	e0bfe617 	ldw	r2,-104(fp)
 20316c4:	10c01017 	ldw	r3,64(r2)
 20316c8:	e0bfe617 	ldw	r2,-104(fp)
 20316cc:	10c01a15 	stw	r3,104(r2)
 20316d0:	e0bfe617 	ldw	r2,-104(fp)
 20316d4:	10c01a17 	ldw	r3,104(r2)
 20316d8:	e0bfe617 	ldw	r2,-104(fp)
 20316dc:	10c00f15 	stw	r3,60(r2)
 20316e0:	e0bfe617 	ldw	r2,-104(fp)
 20316e4:	10c00f17 	ldw	r3,60(r2)
 20316e8:	e0bfe617 	ldw	r2,-104(fp)
 20316ec:	10c00e15 	stw	r3,56(r2)
         tcp_rcvseqinit(tp);
 20316f0:	e0bfe617 	ldw	r2,-104(fp)
 20316f4:	10801817 	ldw	r2,96(r2)
 20316f8:	10c00044 	addi	r3,r2,1
 20316fc:	e0bfe617 	ldw	r2,-104(fp)
 2031700:	10c01615 	stw	r3,88(r2)
 2031704:	e0bfe617 	ldw	r2,-104(fp)
 2031708:	10c01617 	ldw	r3,88(r2)
 203170c:	e0bfe617 	ldw	r2,-104(fp)
 2031710:	10c01915 	stw	r3,100(r2)
         tp->t_flags |= TF_ACKNOW;
 2031714:	e0bfe617 	ldw	r2,-104(fp)
 2031718:	10800b0b 	ldhu	r2,44(r2)
 203171c:	10800054 	ori	r2,r2,1
 2031720:	1007883a 	mov	r3,r2
 2031724:	e0bfe617 	ldw	r2,-104(fp)
 2031728:	10c00b0d 	sth	r3,44(r2)
         tp->t_state = TCPS_SYN_RECEIVED;
 203172c:	e0bfe617 	ldw	r2,-104(fp)
 2031730:	00c000c4 	movi	r3,3
 2031734:	10c00215 	stw	r3,8(r2)
         tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 2031738:	e0bfe617 	ldw	r2,-104(fp)
 203173c:	00c02584 	movi	r3,150
 2031740:	10c00515 	stw	r3,20(r2)
         dropsocket = 0;      /* committed to socket */
 2031744:	e03fec15 	stw	zero,-80(fp)
         tcpstat.tcps_accepts++;
 2031748:	00809934 	movhi	r2,612
 203174c:	10b6f504 	addi	r2,r2,-9260
 2031750:	10800117 	ldw	r2,4(r2)
 2031754:	10c00044 	addi	r3,r2,1
 2031758:	00809934 	movhi	r2,612
 203175c:	10b6f504 	addi	r2,r2,-9260
 2031760:	10c00115 	stw	r3,4(r2)
         goto trimthenstep6;
 2031764:	00009006 	br	20319a8 <tcp_input+0xf40>
    *   if SYN has been acked change to ESTABLISHED else SYN_RCVD state
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
 2031768:	e0bfe417 	ldw	r2,-112(fp)
 203176c:	e0ffff17 	ldw	r3,-4(fp)
 2031770:	10c00a15 	stw	r3,40(r2)
      if ((tiflags & TH_ACK) &&
 2031774:	e0bfe717 	ldw	r2,-100(fp)
 2031778:	1080040c 	andi	r2,r2,16
 203177c:	10000f26 	beq	r2,zero,20317bc <tcp_input+0xd54>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 2031780:	e0bff217 	ldw	r2,-56(fp)
 2031784:	10c00717 	ldw	r3,28(r2)
 2031788:	e0bfe617 	ldw	r2,-104(fp)
 203178c:	10801317 	ldw	r2,76(r2)
 2031790:	1885c83a 	sub	r2,r3,r2
    *   arrange for segment to be acked (eventually)
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
 2031794:	0080060e 	bge	zero,r2,20317b0 <tcp_input+0xd48>
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
          SEQ_GT(ti->ti_ack, tp->snd_max)))
 2031798:	e0bff217 	ldw	r2,-56(fp)
 203179c:	10c00717 	ldw	r3,28(r2)
 20317a0:	e0bfe617 	ldw	r2,-104(fp)
 20317a4:	10801a17 	ldw	r2,104(r2)
 20317a8:	1885c83a 	sub	r2,r3,r2
    *   continue processing rest of data/controls, beginning with URG
    */
   case TCPS_SYN_SENT:
      inp->ifp = ifp;
      if ((tiflags & TH_ACK) &&
          (SEQ_LEQ(ti->ti_ack, tp->iss) ||
 20317ac:	0080030e 	bge	zero,r2,20317bc <tcp_input+0xd54>
          SEQ_GT(ti->ti_ack, tp->snd_max)))
      {
         GOTO_DROPWITHRESET;
 20317b0:	0080dc04 	movi	r2,880
 20317b4:	d0a0a915 	stw	r2,-32092(gp)
 20317b8:	00052b06 	br	2032c68 <tcp_input+0x2200>
      }
      if (tiflags & TH_RST) 
 20317bc:	e0bfe717 	ldw	r2,-100(fp)
 20317c0:	1080010c 	andi	r2,r2,4
 20317c4:	10000926 	beq	r2,zero,20317ec <tcp_input+0xd84>
      {
         if (tiflags & TH_ACK)
 20317c8:	e0bfe717 	ldw	r2,-100(fp)
 20317cc:	1080040c 	andi	r2,r2,16
 20317d0:	10000326 	beq	r2,zero,20317e0 <tcp_input+0xd78>
            SETTP(tp, tcp_drop(tp, ECONNREFUSED));
 20317d4:	e13fe617 	ldw	r4,-104(fp)
 20317d8:	01401bc4 	movi	r5,111
 20317dc:	2034c780 	call	2034c78 <tcp_drop>
         GOTO_DROP;
 20317e0:	0080dd84 	movi	r2,886
 20317e4:	d0a0a915 	stw	r2,-32092(gp)
 20317e8:	00056006 	br	2032d6c <tcp_input+0x2304>
      }
      if ((tiflags & TH_SYN) == 0)
 20317ec:	e0bfe717 	ldw	r2,-100(fp)
 20317f0:	1080008c 	andi	r2,r2,2
 20317f4:	1000031e 	bne	r2,zero,2031804 <tcp_input+0xd9c>
         GOTO_DROP;
 20317f8:	0080de44 	movi	r2,889
 20317fc:	d0a0a915 	stw	r2,-32092(gp)
 2031800:	00055a06 	br	2032d6c <tcp_input+0x2304>
      if (tiflags & TH_ACK) 
 2031804:	e0bfe717 	ldw	r2,-100(fp)
 2031808:	1080040c 	andi	r2,r2,16
 203180c:	10000e26 	beq	r2,zero,2031848 <tcp_input+0xde0>
      {
         tp->snd_una = ti->ti_ack;
 2031810:	e0bff217 	ldw	r2,-56(fp)
 2031814:	10c00717 	ldw	r3,28(r2)
 2031818:	e0bfe617 	ldw	r2,-104(fp)
 203181c:	10c00e15 	stw	r3,56(r2)
         if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 2031820:	e0bfe617 	ldw	r2,-104(fp)
 2031824:	10c00f17 	ldw	r3,60(r2)
 2031828:	e0bfe617 	ldw	r2,-104(fp)
 203182c:	10800e17 	ldw	r2,56(r2)
 2031830:	1885c83a 	sub	r2,r3,r2
 2031834:	1000040e 	bge	r2,zero,2031848 <tcp_input+0xde0>
            tp->snd_nxt = tp->snd_una;
 2031838:	e0bfe617 	ldw	r2,-104(fp)
 203183c:	10c00e17 	ldw	r3,56(r2)
 2031840:	e0bfe617 	ldw	r2,-104(fp)
 2031844:	10c00f15 	stw	r3,60(r2)
      }
      tp->t_timer[TCPT_REXMT] = 0;
 2031848:	e0bfe617 	ldw	r2,-104(fp)
 203184c:	10000315 	stw	zero,12(r2)
      tp->irs = ti->ti_seq;
 2031850:	e0bff217 	ldw	r2,-56(fp)
 2031854:	10c00617 	ldw	r3,24(r2)
 2031858:	e0bfe617 	ldw	r2,-104(fp)
 203185c:	10c01815 	stw	r3,96(r2)
      tcp_rcvseqinit(tp);
 2031860:	e0bfe617 	ldw	r2,-104(fp)
 2031864:	10801817 	ldw	r2,96(r2)
 2031868:	10c00044 	addi	r3,r2,1
 203186c:	e0bfe617 	ldw	r2,-104(fp)
 2031870:	10c01615 	stw	r3,88(r2)
 2031874:	e0bfe617 	ldw	r2,-104(fp)
 2031878:	10c01617 	ldw	r3,88(r2)
 203187c:	e0bfe617 	ldw	r2,-104(fp)
 2031880:	10c01915 	stw	r3,100(r2)
      if (inp->inp_laddr.s_addr != ti->ti_dst.s_addr) 
 2031884:	e0bfe417 	ldw	r2,-112(fp)
 2031888:	10c00417 	ldw	r3,16(r2)
 203188c:	e0bff217 	ldw	r2,-56(fp)
 2031890:	10800417 	ldw	r2,16(r2)
 2031894:	18801726 	beq	r3,r2,20318f4 <tcp_input+0xe8c>
          * the IP interface may have changed address since we sent our SYN
          * (e.g. PPP brings link up as a result of said SYN and gets new
          * address via IPCP); if so we need to update the inpcb and the
          * TCP header template with the new address.
          */
         if ((m->pkt->net != NULL)
 2031898:	e0bffe17 	ldw	r2,-8(fp)
 203189c:	10800117 	ldw	r2,4(r2)
 20318a0:	10800617 	ldw	r2,24(r2)
 20318a4:	10001326 	beq	r2,zero,20318f4 <tcp_input+0xe8c>
             && (m->pkt->net->n_ipaddr == ti->ti_dst.s_addr)) 
 20318a8:	e0bffe17 	ldw	r2,-8(fp)
 20318ac:	10800117 	ldw	r2,4(r2)
 20318b0:	10800617 	ldw	r2,24(r2)
 20318b4:	10c00a17 	ldw	r3,40(r2)
 20318b8:	e0bff217 	ldw	r2,-56(fp)
 20318bc:	10800417 	ldw	r2,16(r2)
 20318c0:	18800c1e 	bne	r3,r2,20318f4 <tcp_input+0xe8c>
      /* send an ack */
         {
            inp->inp_laddr = ti->ti_dst;
 20318c4:	e0bfe417 	ldw	r2,-112(fp)
 20318c8:	e0fff217 	ldw	r3,-56(fp)
 20318cc:	18c00417 	ldw	r3,16(r3)
 20318d0:	10c00415 	stw	r3,16(r2)
            if (tp->t_template != NULL)
 20318d4:	e0bfe617 	ldw	r2,-104(fp)
 20318d8:	10800c17 	ldw	r2,48(r2)
 20318dc:	10000526 	beq	r2,zero,20318f4 <tcp_input+0xe8c>
               tp->t_template->ti_src = ti->ti_dst;
 20318e0:	e0bfe617 	ldw	r2,-104(fp)
 20318e4:	10800c17 	ldw	r2,48(r2)
 20318e8:	e0fff217 	ldw	r3,-56(fp)
 20318ec:	18c00417 	ldw	r3,16(r3)
 20318f0:	10c00315 	stw	r3,12(r2)
         }
      }
      tp->t_flags |= TF_ACKNOW;
 20318f4:	e0bfe617 	ldw	r2,-104(fp)
 20318f8:	10800b0b 	ldhu	r2,44(r2)
 20318fc:	10800054 	ori	r2,r2,1
 2031900:	1007883a 	mov	r3,r2
 2031904:	e0bfe617 	ldw	r2,-104(fp)
 2031908:	10c00b0d 	sth	r3,44(r2)
      if (tiflags & TH_ACK && SEQ_GT(tp->snd_una, tp->iss)) 
 203190c:	e0bfe717 	ldw	r2,-100(fp)
 2031910:	1080040c 	andi	r2,r2,16
 2031914:	10002126 	beq	r2,zero,203199c <tcp_input+0xf34>
 2031918:	e0bfe617 	ldw	r2,-104(fp)
 203191c:	10c00e17 	ldw	r3,56(r2)
 2031920:	e0bfe617 	ldw	r2,-104(fp)
 2031924:	10801317 	ldw	r2,76(r2)
 2031928:	1885c83a 	sub	r2,r3,r2
 203192c:	00801b0e 	bge	zero,r2,203199c <tcp_input+0xf34>
      {
         tcpstat.tcps_connects++;
 2031930:	00809934 	movhi	r2,612
 2031934:	10b6f504 	addi	r2,r2,-9260
 2031938:	10800217 	ldw	r2,8(r2)
 203193c:	10c00044 	addi	r3,r2,1
 2031940:	00809934 	movhi	r2,612
 2031944:	10b6f504 	addi	r2,r2,-9260
 2031948:	10c00215 	stw	r3,8(r2)
         tp->t_state = TCPS_ESTABLISHED;
 203194c:	e0bfe617 	ldw	r2,-104(fp)
 2031950:	00c00104 	movi	r3,4
 2031954:	10c00215 	stw	r3,8(r2)
         soisconnected (so);
 2031958:	e13fe817 	ldw	r4,-96(fp)
 203195c:	202ebc40 	call	202ebc4 <soisconnected>
         tp->t_maxseg = tcp_mss(so);
 2031960:	e13fe817 	ldw	r4,-96(fp)
 2031964:	20333280 	call	2033328 <tcp_mss>
 2031968:	1007883a 	mov	r3,r2
 203196c:	e0bfe617 	ldw	r2,-104(fp)
 2031970:	10c00a0d 	sth	r3,40(r2)
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
 2031974:	e13fe617 	ldw	r4,-104(fp)
 2031978:	000b883a 	mov	r5,zero
 203197c:	e1bffe17 	ldw	r6,-8(fp)
 2031980:	203065c0 	call	203065c <tcp_reass>
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 2031984:	e0bfe617 	ldw	r2,-104(fp)
 2031988:	10801e17 	ldw	r2,120(r2)
 203198c:	10000626 	beq	r2,zero,20319a8 <tcp_input+0xf40>
         {
            tcp_xmit_timer(tp);
 2031990:	e13fe617 	ldw	r4,-104(fp)
 2031994:	20330540 	call	2033054 <tcp_xmit_timer>
         (void) tcp_reass (tp, (struct tcpiphdr *)0, m);
         /*
          * if we didn't have to retransmit the SYN,
          * use its rtt as our initial srtt & rtt var.
          */
         if (tp->t_rttick) 
 2031998:	00000306 	br	20319a8 <tcp_input+0xf40>
         {
            tcp_xmit_timer(tp);
         }
      } else
         tp->t_state = TCPS_SYN_RECEIVED;
 203199c:	e0bfe617 	ldw	r2,-104(fp)
 20319a0:	00c000c4 	movi	r3,3
 20319a4:	10c00215 	stw	r3,8(r2)
      /*
       * Advance ti->ti_seq to correspond to first data byte.
       * If data, trim to stay within window,
       * dropping FIN if necessary.
       */
      ti->ti_seq++;
 20319a8:	e0bff217 	ldw	r2,-56(fp)
 20319ac:	10800617 	ldw	r2,24(r2)
 20319b0:	10c00044 	addi	r3,r2,1
 20319b4:	e0bff217 	ldw	r2,-56(fp)
 20319b8:	10c00615 	stw	r3,24(r2)
      if ((tcp_win)ti->ti_len > tp->rcv_wnd) 
 20319bc:	e0bff217 	ldw	r2,-56(fp)
 20319c0:	1080028b 	ldhu	r2,10(r2)
 20319c4:	10bfffcc 	andi	r2,r2,65535
 20319c8:	e0ffe617 	ldw	r3,-104(fp)
 20319cc:	18c01517 	ldw	r3,84(r3)
 20319d0:	1880302e 	bgeu	r3,r2,2031a94 <tcp_input+0x102c>
      {
         todrop = ti->ti_len - (u_short)tp->rcv_wnd;
 20319d4:	e0bff217 	ldw	r2,-56(fp)
 20319d8:	1080028b 	ldhu	r2,10(r2)
 20319dc:	10ffffcc 	andi	r3,r2,65535
 20319e0:	e0bfe617 	ldw	r2,-104(fp)
 20319e4:	10801517 	ldw	r2,84(r2)
 20319e8:	10bfffcc 	andi	r2,r2,65535
 20319ec:	1885c83a 	sub	r2,r3,r2
 20319f0:	e0bfe915 	stw	r2,-92(fp)
         /* XXX work around 4.2 m_adj bug */
         if (m->m_len) 
 20319f4:	e0bffe17 	ldw	r2,-8(fp)
 20319f8:	10800217 	ldw	r2,8(r2)
 20319fc:	10000626 	beq	r2,zero,2031a18 <tcp_input+0xfb0>
         {
            m_adj(m, -todrop);
 2031a00:	e0bfe917 	ldw	r2,-92(fp)
 2031a04:	0085c83a 	sub	r2,zero,r2
 2031a08:	e13ffe17 	ldw	r4,-8(fp)
 2031a0c:	100b883a 	mov	r5,r2
 2031a10:	20299a80 	call	20299a8 <m_adj>
 2031a14:	00000706 	br	2031a34 <tcp_input+0xfcc>
         }
         else 
         {
            /* skip tcp/ip header in first mbuf */
            m_adj(m->m_next, -todrop);
 2031a18:	e0bffe17 	ldw	r2,-8(fp)
 2031a1c:	10c00617 	ldw	r3,24(r2)
 2031a20:	e0bfe917 	ldw	r2,-92(fp)
 2031a24:	0085c83a 	sub	r2,zero,r2
 2031a28:	1809883a 	mov	r4,r3
 2031a2c:	100b883a 	mov	r5,r2
 2031a30:	20299a80 	call	20299a8 <m_adj>
         }
         ti->ti_len = (u_short)tp->rcv_wnd;
 2031a34:	e0bfe617 	ldw	r2,-104(fp)
 2031a38:	10801517 	ldw	r2,84(r2)
 2031a3c:	1007883a 	mov	r3,r2
 2031a40:	e0bff217 	ldw	r2,-56(fp)
 2031a44:	10c0028d 	sth	r3,10(r2)
         tiflags &= ~TH_FIN;
 2031a48:	e0ffe717 	ldw	r3,-100(fp)
 2031a4c:	00bfff84 	movi	r2,-2
 2031a50:	1884703a 	and	r2,r3,r2
 2031a54:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpackafterwin++;
 2031a58:	00809934 	movhi	r2,612
 2031a5c:	10b6f504 	addi	r2,r2,-9260
 2031a60:	10802517 	ldw	r2,148(r2)
 2031a64:	10c00044 	addi	r3,r2,1
 2031a68:	00809934 	movhi	r2,612
 2031a6c:	10b6f504 	addi	r2,r2,-9260
 2031a70:	10c02515 	stw	r3,148(r2)
         tcpstat.tcps_rcvbyteafterwin += todrop;
 2031a74:	00809934 	movhi	r2,612
 2031a78:	10b6f504 	addi	r2,r2,-9260
 2031a7c:	10c02617 	ldw	r3,152(r2)
 2031a80:	e0bfe917 	ldw	r2,-92(fp)
 2031a84:	1887883a 	add	r3,r3,r2
 2031a88:	00809934 	movhi	r2,612
 2031a8c:	10b6f504 	addi	r2,r2,-9260
 2031a90:	10c02615 	stw	r3,152(r2)
      }
      tp->snd_wl1 = ti->ti_seq - 1;
 2031a94:	e0bff217 	ldw	r2,-56(fp)
 2031a98:	10800617 	ldw	r2,24(r2)
 2031a9c:	10ffffc4 	addi	r3,r2,-1
 2031aa0:	e0bfe617 	ldw	r2,-104(fp)
 2031aa4:	10c01115 	stw	r3,68(r2)
      tp->rcv_up = ti->ti_seq;
 2031aa8:	e0bff217 	ldw	r2,-56(fp)
 2031aac:	10c00617 	ldw	r3,24(r2)
 2031ab0:	e0bfe617 	ldw	r2,-104(fp)
 2031ab4:	10c01715 	stw	r3,92(r2)
      goto step6;
 2031ab8:	0002f206 	br	2032684 <tcp_input+0x1c1c>
    * States other than LISTEN or SYN_SENT.
    * First check that at least some bytes of segment are within 
    * receive window.  If segment begins before rcv_nxt,
    * drop leading data (and SYN); if nothing left, just ack.
    */
   todrop = (int)(tp->rcv_nxt - ti->ti_seq);
 2031abc:	e0bfe617 	ldw	r2,-104(fp)
 2031ac0:	10c01617 	ldw	r3,88(r2)
 2031ac4:	e0bff217 	ldw	r2,-56(fp)
 2031ac8:	10800617 	ldw	r2,24(r2)
 2031acc:	1885c83a 	sub	r2,r3,r2
 2031ad0:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 2031ad4:	e0bfe917 	ldw	r2,-92(fp)
 2031ad8:	0080910e 	bge	zero,r2,2031d20 <tcp_input+0x12b8>
   {
      if (tiflags & TH_SYN) 
 2031adc:	e0bfe717 	ldw	r2,-100(fp)
 2031ae0:	1080008c 	andi	r2,r2,2
 2031ae4:	10001c26 	beq	r2,zero,2031b58 <tcp_input+0x10f0>
      {
         tiflags &= ~TH_SYN;
 2031ae8:	e0ffe717 	ldw	r3,-100(fp)
 2031aec:	00bfff44 	movi	r2,-3
 2031af0:	1884703a 	and	r2,r3,r2
 2031af4:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_seq++;
 2031af8:	e0bff217 	ldw	r2,-56(fp)
 2031afc:	10800617 	ldw	r2,24(r2)
 2031b00:	10c00044 	addi	r3,r2,1
 2031b04:	e0bff217 	ldw	r2,-56(fp)
 2031b08:	10c00615 	stw	r3,24(r2)
         if (ti->ti_urp > 1) 
 2031b0c:	e0bff217 	ldw	r2,-56(fp)
 2031b10:	1080098b 	ldhu	r2,38(r2)
 2031b14:	10bfffcc 	andi	r2,r2,65535
 2031b18:	108000b0 	cmpltui	r2,r2,2
 2031b1c:	1000071e 	bne	r2,zero,2031b3c <tcp_input+0x10d4>
            ti->ti_urp--;
 2031b20:	e0bff217 	ldw	r2,-56(fp)
 2031b24:	1080098b 	ldhu	r2,38(r2)
 2031b28:	10bfffc4 	addi	r2,r2,-1
 2031b2c:	1007883a 	mov	r3,r2
 2031b30:	e0bff217 	ldw	r2,-56(fp)
 2031b34:	10c0098d 	sth	r3,38(r2)
 2031b38:	00000406 	br	2031b4c <tcp_input+0x10e4>
         else
            tiflags &= ~TH_URG;
 2031b3c:	e0ffe717 	ldw	r3,-100(fp)
 2031b40:	00bff7c4 	movi	r2,-33
 2031b44:	1884703a 	and	r2,r3,r2
 2031b48:	e0bfe715 	stw	r2,-100(fp)
         todrop--;
 2031b4c:	e0bfe917 	ldw	r2,-92(fp)
 2031b50:	10bfffc4 	addi	r2,r2,-1
 2031b54:	e0bfe915 	stw	r2,-92(fp)
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 2031b58:	e0bff217 	ldw	r2,-56(fp)
 2031b5c:	1080028b 	ldhu	r2,10(r2)
 2031b60:	10ffffcc 	andi	r3,r2,65535
 2031b64:	e0bfe917 	ldw	r2,-92(fp)
 2031b68:	18800816 	blt	r3,r2,2031b8c <tcp_input+0x1124>
          ((todrop == (int)ti->ti_len) && 
 2031b6c:	e0bff217 	ldw	r2,-56(fp)
 2031b70:	1080028b 	ldhu	r2,10(r2)
 2031b74:	10ffffcc 	andi	r3,r2,65535
      /*
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
 2031b78:	e0bfe917 	ldw	r2,-92(fp)
 2031b7c:	1880351e 	bne	r3,r2,2031c54 <tcp_input+0x11ec>
          ((todrop == (int)ti->ti_len) && 
          (tiflags&TH_FIN) == 0)) 
 2031b80:	e0bfe717 	ldw	r2,-100(fp)
 2031b84:	1080004c 	andi	r2,r2,1
       * Altera Niche Stack Nios port modification:
       * Add parenthesis to remove implicit order of operaton
       * & possible build warning.
       */
      if ((todrop > (int)ti->ti_len) ||
          ((todrop == (int)ti->ti_len) && 
 2031b88:	1000321e 	bne	r2,zero,2031c54 <tcp_input+0x11ec>
          (tiflags&TH_FIN) == 0)) 
      {
         tcpstat.tcps_rcvduppack++;
 2031b8c:	00809934 	movhi	r2,612
 2031b90:	10b6f504 	addi	r2,r2,-9260
 2031b94:	10801f17 	ldw	r2,124(r2)
 2031b98:	10c00044 	addi	r3,r2,1
 2031b9c:	00809934 	movhi	r2,612
 2031ba0:	10b6f504 	addi	r2,r2,-9260
 2031ba4:	10c01f15 	stw	r3,124(r2)
         tcpstat.tcps_rcvdupbyte += ti->ti_len;
 2031ba8:	00809934 	movhi	r2,612
 2031bac:	10b6f504 	addi	r2,r2,-9260
 2031bb0:	10c02017 	ldw	r3,128(r2)
 2031bb4:	e0bff217 	ldw	r2,-56(fp)
 2031bb8:	1080028b 	ldhu	r2,10(r2)
 2031bbc:	10bfffcc 	andi	r2,r2,65535
 2031bc0:	1887883a 	add	r3,r3,r2
 2031bc4:	00809934 	movhi	r2,612
 2031bc8:	10b6f504 	addi	r2,r2,-9260
 2031bcc:	10c02015 	stw	r3,128(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 2031bd0:	e0bfe717 	ldw	r2,-100(fp)
 2031bd4:	1080004c 	andi	r2,r2,1
 2031bd8:	10000626 	beq	r2,zero,2031bf4 <tcp_input+0x118c>
 2031bdc:	e0bff217 	ldw	r2,-56(fp)
 2031be0:	1080028b 	ldhu	r2,10(r2)
 2031be4:	10bfffcc 	andi	r2,r2,65535
 2031be8:	10c00044 	addi	r3,r2,1
 2031bec:	e0bfe917 	ldw	r2,-92(fp)
 2031bf0:	18800926 	beq	r3,r2,2031c18 <tcp_input+0x11b0>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 2031bf4:	e0bfe717 	ldw	r2,-100(fp)
 2031bf8:	1080010c 	andi	r2,r2,4
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 2031bfc:	10040926 	beq	r2,zero,2032c24 <tcp_input+0x21bc>
            (tiflags & TH_RST && ti->ti_seq == tp->rcv_nxt - 1))
 2031c00:	e0bff217 	ldw	r2,-56(fp)
 2031c04:	10c00617 	ldw	r3,24(r2)
 2031c08:	e0bfe617 	ldw	r2,-104(fp)
 2031c0c:	10801617 	ldw	r2,88(r2)
 2031c10:	10bfffc4 	addi	r2,r2,-1
 2031c14:	1884031e 	bne	r3,r2,2032c24 <tcp_input+0x21bc>
         {
            todrop = ti->ti_len;
 2031c18:	e0bff217 	ldw	r2,-56(fp)
 2031c1c:	1080028b 	ldhu	r2,10(r2)
 2031c20:	10bfffcc 	andi	r2,r2,65535
 2031c24:	e0bfe915 	stw	r2,-92(fp)
            tiflags &= ~TH_FIN;
 2031c28:	e0ffe717 	ldw	r3,-100(fp)
 2031c2c:	00bfff84 	movi	r2,-2
 2031c30:	1884703a 	and	r2,r3,r2
 2031c34:	e0bfe715 	stw	r2,-100(fp)
            tp->t_flags |= TF_ACKNOW;
 2031c38:	e0bfe617 	ldw	r2,-104(fp)
 2031c3c:	10800b0b 	ldhu	r2,44(r2)
 2031c40:	10800054 	ori	r2,r2,1
 2031c44:	1007883a 	mov	r3,r2
 2031c48:	e0bfe617 	ldw	r2,-104(fp)
 2031c4c:	10c00b0d 	sth	r3,44(r2)
          *    it, but check the ACK or we will get into FIN
          *    wars if our FINs crossed (both CLOSING).
          * In either case, send ACK to resynchronize,
          * but keep on processing for RST or ACK.
          */
         if ((tiflags & TH_FIN && todrop == (int)ti->ti_len + 1) ||
 2031c50:	00000f06 	br	2031c90 <tcp_input+0x1228>
         else
            goto dropafterack;
      }
      else 
      {
         tcpstat.tcps_rcvpartduppack++;
 2031c54:	00809934 	movhi	r2,612
 2031c58:	10b6f504 	addi	r2,r2,-9260
 2031c5c:	10802117 	ldw	r2,132(r2)
 2031c60:	10c00044 	addi	r3,r2,1
 2031c64:	00809934 	movhi	r2,612
 2031c68:	10b6f504 	addi	r2,r2,-9260
 2031c6c:	10c02115 	stw	r3,132(r2)
         tcpstat.tcps_rcvpartdupbyte += todrop;
 2031c70:	00809934 	movhi	r2,612
 2031c74:	10b6f504 	addi	r2,r2,-9260
 2031c78:	10c02217 	ldw	r3,136(r2)
 2031c7c:	e0bfe917 	ldw	r2,-92(fp)
 2031c80:	1887883a 	add	r3,r3,r2
 2031c84:	00809934 	movhi	r2,612
 2031c88:	10b6f504 	addi	r2,r2,-9260
 2031c8c:	10c02215 	stw	r3,136(r2)
      }
      m_adj(m, todrop);
 2031c90:	e13ffe17 	ldw	r4,-8(fp)
 2031c94:	e17fe917 	ldw	r5,-92(fp)
 2031c98:	20299a80 	call	20299a8 <m_adj>
      ti->ti_seq += todrop;
 2031c9c:	e0bff217 	ldw	r2,-56(fp)
 2031ca0:	10c00617 	ldw	r3,24(r2)
 2031ca4:	e0bfe917 	ldw	r2,-92(fp)
 2031ca8:	1887883a 	add	r3,r3,r2
 2031cac:	e0bff217 	ldw	r2,-56(fp)
 2031cb0:	10c00615 	stw	r3,24(r2)
      ti->ti_len -= (u_short)todrop;
 2031cb4:	e0bff217 	ldw	r2,-56(fp)
 2031cb8:	10c0028b 	ldhu	r3,10(r2)
 2031cbc:	e0bfe917 	ldw	r2,-92(fp)
 2031cc0:	1885c83a 	sub	r2,r3,r2
 2031cc4:	1007883a 	mov	r3,r2
 2031cc8:	e0bff217 	ldw	r2,-56(fp)
 2031ccc:	10c0028d 	sth	r3,10(r2)
      if (ti->ti_urp > (u_short)todrop)
 2031cd0:	e0bff217 	ldw	r2,-56(fp)
 2031cd4:	1080098b 	ldhu	r2,38(r2)
 2031cd8:	e0ffe917 	ldw	r3,-92(fp)
 2031cdc:	10bfffcc 	andi	r2,r2,65535
 2031ce0:	18ffffcc 	andi	r3,r3,65535
 2031ce4:	1880082e 	bgeu	r3,r2,2031d08 <tcp_input+0x12a0>
         ti->ti_urp -= (u_short)todrop;
 2031ce8:	e0bff217 	ldw	r2,-56(fp)
 2031cec:	10c0098b 	ldhu	r3,38(r2)
 2031cf0:	e0bfe917 	ldw	r2,-92(fp)
 2031cf4:	1885c83a 	sub	r2,r3,r2
 2031cf8:	1007883a 	mov	r3,r2
 2031cfc:	e0bff217 	ldw	r2,-56(fp)
 2031d00:	10c0098d 	sth	r3,38(r2)
 2031d04:	00000606 	br	2031d20 <tcp_input+0x12b8>
      else 
      {
         tiflags &= ~TH_URG;
 2031d08:	e0ffe717 	ldw	r3,-100(fp)
 2031d0c:	00bff7c4 	movi	r2,-33
 2031d10:	1884703a 	and	r2,r3,r2
 2031d14:	e0bfe715 	stw	r2,-100(fp)
         ti->ti_urp = 0;
 2031d18:	e0bff217 	ldw	r2,-56(fp)
 2031d1c:	1000098d 	sth	zero,38(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 2031d20:	e0bfe817 	ldw	r2,-96(fp)
 2031d24:	1080088b 	ldhu	r2,34(r2)
 2031d28:	10bfffcc 	andi	r2,r2,65535
 2031d2c:	1080004c 	andi	r2,r2,1
 2031d30:	10001526 	beq	r2,zero,2031d88 <tcp_input+0x1320>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 2031d34:	e0bfe617 	ldw	r2,-104(fp)
 2031d38:	10800217 	ldw	r2,8(r2)

   /*
    * If new data are received on a connection after the
    * user processes are gone, then RST the other end.
    */
   if ((so->so_state & SS_NOFDREF) &&
 2031d3c:	10800190 	cmplti	r2,r2,6
 2031d40:	1000111e 	bne	r2,zero,2031d88 <tcp_input+0x1320>
       tp->t_state > TCPS_CLOSE_WAIT && ti->ti_len) 
 2031d44:	e0bff217 	ldw	r2,-56(fp)
 2031d48:	1080028b 	ldhu	r2,10(r2)
 2031d4c:	10bfffcc 	andi	r2,r2,65535
 2031d50:	10000d26 	beq	r2,zero,2031d88 <tcp_input+0x1320>
   {
      tp = tcp_close(tp);
 2031d54:	e13fe617 	ldw	r4,-104(fp)
 2031d58:	2034d240 	call	2034d24 <tcp_close>
 2031d5c:	e0bfe615 	stw	r2,-104(fp)
      tcpstat.tcps_rcvafterclose++;
 2031d60:	00809934 	movhi	r2,612
 2031d64:	10b6f504 	addi	r2,r2,-9260
 2031d68:	10802717 	ldw	r2,156(r2)
 2031d6c:	10c00044 	addi	r3,r2,1
 2031d70:	00809934 	movhi	r2,612
 2031d74:	10b6f504 	addi	r2,r2,-9260
 2031d78:	10c02715 	stw	r3,156(r2)
      GOTO_DROPWITHRESET;
 2031d7c:	00810444 	movi	r2,1041
 2031d80:	d0a0a915 	stw	r2,-32092(gp)
 2031d84:	0003b806 	br	2032c68 <tcp_input+0x2200>

   /*
    * If segment ends after window, drop trailing data
    * (and PUSH and FIN); if nothing left, just ACK.
    */
   todrop = (int)((ti->ti_seq + (short)ti->ti_len) - (tp->rcv_nxt+tp->rcv_wnd));
 2031d88:	e0bff217 	ldw	r2,-56(fp)
 2031d8c:	10c00617 	ldw	r3,24(r2)
 2031d90:	e0bff217 	ldw	r2,-56(fp)
 2031d94:	1080028b 	ldhu	r2,10(r2)
 2031d98:	10bfffcc 	andi	r2,r2,65535
 2031d9c:	10a0001c 	xori	r2,r2,32768
 2031da0:	10a00004 	addi	r2,r2,-32768
 2031da4:	1887883a 	add	r3,r3,r2
 2031da8:	e0bfe617 	ldw	r2,-104(fp)
 2031dac:	11001617 	ldw	r4,88(r2)
 2031db0:	e0bfe617 	ldw	r2,-104(fp)
 2031db4:	10801517 	ldw	r2,84(r2)
 2031db8:	2085883a 	add	r2,r4,r2
 2031dbc:	1885c83a 	sub	r2,r3,r2
 2031dc0:	e0bfe915 	stw	r2,-92(fp)
   if (todrop > 0) 
 2031dc4:	e0bfe917 	ldw	r2,-92(fp)
 2031dc8:	0080690e 	bge	zero,r2,2031f70 <tcp_input+0x1508>
   {
      tcpstat.tcps_rcvpackafterwin++;
 2031dcc:	00809934 	movhi	r2,612
 2031dd0:	10b6f504 	addi	r2,r2,-9260
 2031dd4:	10802517 	ldw	r2,148(r2)
 2031dd8:	10c00044 	addi	r3,r2,1
 2031ddc:	00809934 	movhi	r2,612
 2031de0:	10b6f504 	addi	r2,r2,-9260
 2031de4:	10c02515 	stw	r3,148(r2)
      if (todrop >= (int)ti->ti_len) 
 2031de8:	e0bff217 	ldw	r2,-56(fp)
 2031dec:	1080028b 	ldhu	r2,10(r2)
 2031df0:	10bfffcc 	andi	r2,r2,65535
 2031df4:	e0ffe917 	ldw	r3,-92(fp)
 2031df8:	18803a16 	blt	r3,r2,2031ee4 <tcp_input+0x147c>
      {
         tcpstat.tcps_rcvbyteafterwin += ti->ti_len;
 2031dfc:	00809934 	movhi	r2,612
 2031e00:	10b6f504 	addi	r2,r2,-9260
 2031e04:	10c02617 	ldw	r3,152(r2)
 2031e08:	e0bff217 	ldw	r2,-56(fp)
 2031e0c:	1080028b 	ldhu	r2,10(r2)
 2031e10:	10bfffcc 	andi	r2,r2,65535
 2031e14:	1887883a 	add	r3,r3,r2
 2031e18:	00809934 	movhi	r2,612
 2031e1c:	10b6f504 	addi	r2,r2,-9260
 2031e20:	10c02615 	stw	r3,152(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 2031e24:	e0bfe717 	ldw	r2,-100(fp)
 2031e28:	1080008c 	andi	r2,r2,2
 2031e2c:	10001726 	beq	r2,zero,2031e8c <tcp_input+0x1424>
             tp->t_state == TCPS_TIME_WAIT &&
 2031e30:	e0bfe617 	ldw	r2,-104(fp)
 2031e34:	10800217 	ldw	r2,8(r2)
          * If a new connection request is received
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
 2031e38:	10800298 	cmpnei	r2,r2,10
 2031e3c:	1000131e 	bne	r2,zero,2031e8c <tcp_input+0x1424>
             tp->t_state == TCPS_TIME_WAIT &&
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
 2031e40:	e0bff217 	ldw	r2,-56(fp)
 2031e44:	10c00617 	ldw	r3,24(r2)
 2031e48:	e0bfe617 	ldw	r2,-104(fp)
 2031e4c:	10801617 	ldw	r2,88(r2)
 2031e50:	1885c83a 	sub	r2,r3,r2
          * while in TIME_WAIT, drop the old connection
          * and start over if the sequence numbers
          * are above the previous ones.
          */
         if (tiflags & TH_SYN &&
             tp->t_state == TCPS_TIME_WAIT &&
 2031e54:	00800d0e 	bge	zero,r2,2031e8c <tcp_input+0x1424>
             SEQ_GT(ti->ti_seq, tp->rcv_nxt)) 
         {
            iss = (tcp_seq)(tp->rcv_nxt + (TCP_ISSINCR));
 2031e58:	e0bfe617 	ldw	r2,-104(fp)
 2031e5c:	10c01617 	ldw	r3,88(r2)
 2031e60:	008000b4 	movhi	r2,2
 2031e64:	10bd3fc4 	addi	r2,r2,-2817
 2031e68:	1885883a 	add	r2,r3,r2
 2031e6c:	e0bfed15 	stw	r2,-76(fp)
            if (iss & 0xff000000)
 2031e70:	e0bfed17 	ldw	r2,-76(fp)
 2031e74:	10bfc02c 	andhi	r2,r2,65280
 2031e78:	10000126 	beq	r2,zero,2031e80 <tcp_input+0x1418>
            {
               iss = 0L;
 2031e7c:	e03fed15 	stw	zero,-76(fp)
            }
            (void) tcp_close(tp);
 2031e80:	e13fe617 	ldw	r4,-104(fp)
 2031e84:	2034d240 	call	2034d24 <tcp_close>
            goto findpcb;
 2031e88:	003bce06 	br	2030dc4 <tcp_input+0x35c>
          * window edge, and have to drop data and PUSH from
          * incoming segments.  Continue processing, but
          * remember to ack.  Otherwise, drop segment
          * and ack.
          */
         if ((tp->rcv_wnd == 0) && (ti->ti_seq == tp->rcv_nxt))
 2031e8c:	e0bfe617 	ldw	r2,-104(fp)
 2031e90:	10801517 	ldw	r2,84(r2)
 2031e94:	1003631e 	bne	r2,zero,2032c24 <tcp_input+0x21bc>
 2031e98:	e0bff217 	ldw	r2,-56(fp)
 2031e9c:	10c00617 	ldw	r3,24(r2)
 2031ea0:	e0bfe617 	ldw	r2,-104(fp)
 2031ea4:	10801617 	ldw	r2,88(r2)
 2031ea8:	18835e1e 	bne	r3,r2,2032c24 <tcp_input+0x21bc>
         {
            tp->t_flags |= TF_ACKNOW;
 2031eac:	e0bfe617 	ldw	r2,-104(fp)
 2031eb0:	10800b0b 	ldhu	r2,44(r2)
 2031eb4:	10800054 	ori	r2,r2,1
 2031eb8:	1007883a 	mov	r3,r2
 2031ebc:	e0bfe617 	ldw	r2,-104(fp)
 2031ec0:	10c00b0d 	sth	r3,44(r2)
            tcpstat.tcps_rcvwinprobe++;
 2031ec4:	00809934 	movhi	r2,612
 2031ec8:	10b6f504 	addi	r2,r2,-9260
 2031ecc:	10802817 	ldw	r2,160(r2)
 2031ed0:	10c00044 	addi	r3,r2,1
 2031ed4:	00809934 	movhi	r2,612
 2031ed8:	10b6f504 	addi	r2,r2,-9260
 2031edc:	10c02815 	stw	r3,160(r2)
 2031ee0:	00000806 	br	2031f04 <tcp_input+0x149c>
         } else
            goto dropafterack;
      } else
         tcpstat.tcps_rcvbyteafterwin += todrop;
 2031ee4:	00809934 	movhi	r2,612
 2031ee8:	10b6f504 	addi	r2,r2,-9260
 2031eec:	10c02617 	ldw	r3,152(r2)
 2031ef0:	e0bfe917 	ldw	r2,-92(fp)
 2031ef4:	1887883a 	add	r3,r3,r2
 2031ef8:	00809934 	movhi	r2,612
 2031efc:	10b6f504 	addi	r2,r2,-9260
 2031f00:	10c02615 	stw	r3,152(r2)
      /* XXX work around m_adj bug */
      if (m->m_len) 
 2031f04:	e0bffe17 	ldw	r2,-8(fp)
 2031f08:	10800217 	ldw	r2,8(r2)
 2031f0c:	10000626 	beq	r2,zero,2031f28 <tcp_input+0x14c0>
      {
         m_adj(m, -todrop);
 2031f10:	e0bfe917 	ldw	r2,-92(fp)
 2031f14:	0085c83a 	sub	r2,zero,r2
 2031f18:	e13ffe17 	ldw	r4,-8(fp)
 2031f1c:	100b883a 	mov	r5,r2
 2031f20:	20299a80 	call	20299a8 <m_adj>
 2031f24:	00000706 	br	2031f44 <tcp_input+0x14dc>
      }
      else 
      {
         /* skip tcp/ip header in first mbuf */
         m_adj(m->m_next, -todrop);
 2031f28:	e0bffe17 	ldw	r2,-8(fp)
 2031f2c:	10c00617 	ldw	r3,24(r2)
 2031f30:	e0bfe917 	ldw	r2,-92(fp)
 2031f34:	0085c83a 	sub	r2,zero,r2
 2031f38:	1809883a 	mov	r4,r3
 2031f3c:	100b883a 	mov	r5,r2
 2031f40:	20299a80 	call	20299a8 <m_adj>
      }
      ti->ti_len -= (u_short)todrop;
 2031f44:	e0bff217 	ldw	r2,-56(fp)
 2031f48:	10c0028b 	ldhu	r3,10(r2)
 2031f4c:	e0bfe917 	ldw	r2,-92(fp)
 2031f50:	1885c83a 	sub	r2,r3,r2
 2031f54:	1007883a 	mov	r3,r2
 2031f58:	e0bff217 	ldw	r2,-56(fp)
 2031f5c:	10c0028d 	sth	r3,10(r2)
      tiflags &= ~(TH_PUSH|TH_FIN);
 2031f60:	e0ffe717 	ldw	r3,-100(fp)
 2031f64:	00bffd84 	movi	r2,-10
 2031f68:	1884703a 	and	r2,r3,r2
 2031f6c:	e0bfe715 	stw	r2,-100(fp)
      tiflags &= ~TH_RST;  /* clear reset flag */
      goto dropafterack;   /* send an ack and drop current packet */
   }
#endif /* DOS_RST */

   if (tiflags&TH_RST) 
 2031f70:	e0bfe717 	ldw	r2,-100(fp)
 2031f74:	1080010c 	andi	r2,r2,4
 2031f78:	10003526 	beq	r2,zero,2032050 <tcp_input+0x15e8>
   {
      switch (tp->t_state) 
 2031f7c:	e0bfe617 	ldw	r2,-104(fp)
 2031f80:	10800217 	ldw	r2,8(r2)
 2031f84:	10bfff44 	addi	r2,r2,-3
 2031f88:	10c00228 	cmpgeui	r3,r2,8
 2031f8c:	1800301e 	bne	r3,zero,2032050 <tcp_input+0x15e8>
 2031f90:	1085883a 	add	r2,r2,r2
 2031f94:	1087883a 	add	r3,r2,r2
 2031f98:	008080f4 	movhi	r2,515
 2031f9c:	1087eb04 	addi	r2,r2,8108
 2031fa0:	1885883a 	add	r2,r3,r2
 2031fa4:	10800017 	ldw	r2,0(r2)
 2031fa8:	1000683a 	jmp	r2
 2031fac:	02031fcc 	andi	r8,zero,3199
 2031fb0:	02031fdc 	xori	r8,zero,3199
 2031fb4:	02031ff8 	rdprs	r8,zero,3199
 2031fb8:	02031ff8 	rdprs	r8,zero,3199
 2031fbc:	0203203c 	xorhi	r8,zero,3200
 2031fc0:	0203203c 	xorhi	r8,zero,3200
 2031fc4:	02031ff8 	rdprs	r8,zero,3199
 2031fc8:	0203203c 	xorhi	r8,zero,3200
      {
   
      case TCPS_SYN_RECEIVED:
         so->so_error = ECONNREFUSED;
 2031fcc:	e0bfe817 	ldw	r2,-96(fp)
 2031fd0:	00c01bc4 	movi	r3,111
 2031fd4:	10c00615 	stw	r3,24(r2)
         goto close;
 2031fd8:	00000a06 	br	2032004 <tcp_input+0x159c>
   
      case TCPS_ESTABLISHED:
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 2031fdc:	00809934 	movhi	r2,612
 2031fe0:	10b6c704 	addi	r2,r2,-9444
 2031fe4:	10800717 	ldw	r2,28(r2)
 2031fe8:	10c00044 	addi	r3,r2,1
 2031fec:	00809934 	movhi	r2,612
 2031ff0:	10b6c704 	addi	r2,r2,-9444
 2031ff4:	10c00715 	stw	r3,28(r2)
      case TCPS_FIN_WAIT_1:
      case TCPS_FIN_WAIT_2:
      case TCPS_CLOSE_WAIT:
         so->so_error = ECONNRESET;
 2031ff8:	e0bfe817 	ldw	r2,-96(fp)
 2031ffc:	00c01a04 	movi	r3,104
 2032000:	10c00615 	stw	r3,24(r2)
         close:
         tp->t_state = TCPS_CLOSED;
 2032004:	e0bfe617 	ldw	r2,-104(fp)
 2032008:	10000215 	stw	zero,8(r2)
         tcpstat.tcps_drops++;
 203200c:	00809934 	movhi	r2,612
 2032010:	10b6f504 	addi	r2,r2,-9260
 2032014:	10800317 	ldw	r2,12(r2)
 2032018:	10c00044 	addi	r3,r2,1
 203201c:	00809934 	movhi	r2,612
 2032020:	10b6f504 	addi	r2,r2,-9260
 2032024:	10c00315 	stw	r3,12(r2)
         SETTP(tp, tcp_close(tp));
 2032028:	e13fe617 	ldw	r4,-104(fp)
 203202c:	2034d240 	call	2034d24 <tcp_close>
#ifdef TCP_ZEROCOPY
         if (so->rx_upcall)
            so->rx_upcall(so, NULL, ECONNRESET);
#endif   /* TCP_ZEROCOPY */
         GOTO_DROP;
 2032030:	00812204 	movi	r2,1160
 2032034:	d0a0a915 	stw	r2,-32092(gp)
 2032038:	00034c06 	br	2032d6c <tcp_input+0x2304>
   
      case TCPS_CLOSING:
      case TCPS_LAST_ACK:
      case TCPS_TIME_WAIT:
         SETTP(tp, tcp_close(tp));
 203203c:	e13fe617 	ldw	r4,-104(fp)
 2032040:	2034d240 	call	2034d24 <tcp_close>
         GOTO_DROP;
 2032044:	00812384 	movi	r2,1166
 2032048:	d0a0a915 	stw	r2,-32092(gp)
 203204c:	00034706 	br	2032d6c <tcp_input+0x2304>
     tcp_trace("rcvd SYN in established state - ignoring SYN.\n");
#endif
      GOTO_DROP;
   }
#else
   if (tiflags & TH_SYN) 
 2032050:	e0bfe717 	ldw	r2,-100(fp)
 2032054:	1080008c 	andi	r2,r2,2
 2032058:	10000726 	beq	r2,zero,2032078 <tcp_input+0x1610>
   {
      tp = tcp_drop(tp, ECONNRESET);
 203205c:	e13fe617 	ldw	r4,-104(fp)
 2032060:	01401a04 	movi	r5,104
 2032064:	2034c780 	call	2034c78 <tcp_drop>
 2032068:	e0bfe615 	stw	r2,-104(fp)
      GOTO_DROPWITHRESET;
 203206c:	00812b04 	movi	r2,1196
 2032070:	d0a0a915 	stw	r2,-32092(gp)
 2032074:	0002fc06 	br	2032c68 <tcp_input+0x2200>
#endif /* end of else of DOS_SYN */

   /*
    * If the ACK bit is off we drop the segment and return.
    */
   if ((tiflags & TH_ACK) == 0)
 2032078:	e0bfe717 	ldw	r2,-100(fp)
 203207c:	1080040c 	andi	r2,r2,16
 2032080:	1000031e 	bne	r2,zero,2032090 <tcp_input+0x1628>
      GOTO_DROP;
 2032084:	00812d04 	movi	r2,1204
 2032088:	d0a0a915 	stw	r2,-32092(gp)
 203208c:	00033706 	br	2032d6c <tcp_input+0x2304>

   /*
    * Ack processing.
    */
   switch (tp->t_state) 
 2032090:	e0bfe617 	ldw	r2,-104(fp)
 2032094:	10800217 	ldw	r2,8(r2)
 2032098:	10c000e0 	cmpeqi	r3,r2,3
 203209c:	1800051e 	bne	r3,zero,20320b4 <tcp_input+0x164c>
 20320a0:	10c000d0 	cmplti	r3,r2,3
 20320a4:	1801771e 	bne	r3,zero,2032684 <tcp_input+0x1c1c>
 20320a8:	108002c8 	cmpgei	r2,r2,11
 20320ac:	1001751e 	bne	r2,zero,2032684 <tcp_input+0x1c1c>
 20320b0:	00003006 	br	2032174 <tcp_input+0x170c>
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 20320b4:	e0bfe617 	ldw	r2,-104(fp)
 20320b8:	10c00e17 	ldw	r3,56(r2)
 20320bc:	e0bff217 	ldw	r2,-56(fp)
 20320c0:	10800717 	ldw	r2,28(r2)
 20320c4:	1885c83a 	sub	r2,r3,r2
 20320c8:	00800616 	blt	zero,r2,20320e4 <tcp_input+0x167c>
          SEQ_GT(ti->ti_ack, tp->snd_max))
 20320cc:	e0bff217 	ldw	r2,-56(fp)
 20320d0:	10c00717 	ldw	r3,28(r2)
 20320d4:	e0bfe617 	ldw	r2,-104(fp)
 20320d8:	10801a17 	ldw	r2,104(r2)
 20320dc:	1885c83a 	sub	r2,r3,r2
    * In SYN_RECEIVED state if the ack ACKs our SYN then enter
    * ESTABLISHED state and continue processing, otherwise
    * send an RST.
    */
   case TCPS_SYN_RECEIVED:
      if (SEQ_GT(tp->snd_una, ti->ti_ack) ||
 20320e0:	00800a0e 	bge	zero,r2,203210c <tcp_input+0x16a4>
          SEQ_GT(ti->ti_ack, tp->snd_max))
      {
         TCP_MIB_INC(tcpEstabResets);     /* keep MIB stats */
 20320e4:	00809934 	movhi	r2,612
 20320e8:	10b6c704 	addi	r2,r2,-9444
 20320ec:	10800717 	ldw	r2,28(r2)
 20320f0:	10c00044 	addi	r3,r2,1
 20320f4:	00809934 	movhi	r2,612
 20320f8:	10b6c704 	addi	r2,r2,-9444
 20320fc:	10c00715 	stw	r3,28(r2)
         GOTO_DROPWITHRESET;
 2032100:	00813184 	movi	r2,1222
 2032104:	d0a0a915 	stw	r2,-32092(gp)
 2032108:	0002d706 	br	2032c68 <tcp_input+0x2200>
      }
      tcpstat.tcps_connects++;
 203210c:	00809934 	movhi	r2,612
 2032110:	10b6f504 	addi	r2,r2,-9260
 2032114:	10800217 	ldw	r2,8(r2)
 2032118:	10c00044 	addi	r3,r2,1
 203211c:	00809934 	movhi	r2,612
 2032120:	10b6f504 	addi	r2,r2,-9260
 2032124:	10c00215 	stw	r3,8(r2)
      tp->t_state = TCPS_ESTABLISHED;
 2032128:	e0bfe617 	ldw	r2,-104(fp)
 203212c:	00c00104 	movi	r3,4
 2032130:	10c00215 	stw	r3,8(r2)
      soisconnected(so);
 2032134:	e13fe817 	ldw	r4,-96(fp)
 2032138:	202ebc40 	call	202ebc4 <soisconnected>
      tp->t_maxseg = tcp_mss(so);
 203213c:	e13fe817 	ldw	r4,-96(fp)
 2032140:	20333280 	call	2033328 <tcp_mss>
 2032144:	1007883a 	mov	r3,r2
 2032148:	e0bfe617 	ldw	r2,-104(fp)
 203214c:	10c00a0d 	sth	r3,40(r2)
      (void) tcp_reass(tp, (struct tcpiphdr *)0, m);
 2032150:	e13fe617 	ldw	r4,-104(fp)
 2032154:	000b883a 	mov	r5,zero
 2032158:	e1bffe17 	ldw	r6,-8(fp)
 203215c:	203065c0 	call	203065c <tcp_reass>
      tp->snd_wl1 = ti->ti_seq - 1;
 2032160:	e0bff217 	ldw	r2,-56(fp)
 2032164:	10800617 	ldw	r2,24(r2)
 2032168:	10ffffc4 	addi	r3,r2,-1
 203216c:	e0bfe617 	ldw	r2,-104(fp)
 2032170:	10c01115 	stw	r3,68(r2)
   case TCPS_CLOSE_WAIT:
   case TCPS_CLOSING:
   case TCPS_LAST_ACK:
   case TCPS_TIME_WAIT:

      if (SEQ_LEQ(ti->ti_ack, tp->snd_una)) 
 2032174:	e0bff217 	ldw	r2,-56(fp)
 2032178:	10c00717 	ldw	r3,28(r2)
 203217c:	e0bfe617 	ldw	r2,-104(fp)
 2032180:	10800e17 	ldw	r2,56(r2)
 2032184:	1885c83a 	sub	r2,r3,r2
 2032188:	00806016 	blt	zero,r2,203230c <tcp_input+0x18a4>
      {
         if (ti->ti_len == 0 && rx_win == tp->snd_wnd) 
 203218c:	e0bff217 	ldw	r2,-56(fp)
 2032190:	1080028b 	ldhu	r2,10(r2)
 2032194:	10bfffcc 	andi	r2,r2,65535
 2032198:	1000571e 	bne	r2,zero,20322f8 <tcp_input+0x1890>
 203219c:	e0bfe617 	ldw	r2,-104(fp)
 20321a0:	10c01417 	ldw	r3,80(r2)
 20321a4:	e0bff517 	ldw	r2,-44(fp)
 20321a8:	1880531e 	bne	r3,r2,20322f8 <tcp_input+0x1890>
         {
            tcpstat.tcps_rcvdupack++;
 20321ac:	00809934 	movhi	r2,612
 20321b0:	10b6f504 	addi	r2,r2,-9260
 20321b4:	10802917 	ldw	r2,164(r2)
 20321b8:	10c00044 	addi	r3,r2,1
 20321bc:	00809934 	movhi	r2,612
 20321c0:	10b6f504 	addi	r2,r2,-9260
 20321c4:	10c02915 	stw	r3,164(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 20321c8:	e0bfe617 	ldw	r2,-104(fp)
 20321cc:	10800317 	ldw	r2,12(r2)
 20321d0:	10000526 	beq	r2,zero,20321e8 <tcp_input+0x1780>
                ti->ti_ack != tp->snd_una)
 20321d4:	e0bff217 	ldw	r2,-56(fp)
 20321d8:	10c00717 	ldw	r3,28(r2)
 20321dc:	e0bfe617 	ldw	r2,-104(fp)
 20321e0:	10800e17 	ldw	r2,56(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 20321e4:	18800326 	beq	r3,r2,20321f4 <tcp_input+0x178c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
 20321e8:	e0bfe617 	ldw	r2,-104(fp)
 20321ec:	10000915 	stw	zero,36(r2)
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 20321f0:	00004406 	br	2032304 <tcp_input+0x189c>
                ti->ti_ack != tp->snd_una)
            {
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
 20321f4:	e0bfe617 	ldw	r2,-104(fp)
 20321f8:	10800917 	ldw	r2,36(r2)
 20321fc:	10c00044 	addi	r3,r2,1
 2032200:	e0bfe617 	ldw	r2,-104(fp)
 2032204:	10c00915 	stw	r3,36(r2)
 2032208:	e0bfe617 	ldw	r2,-104(fp)
 203220c:	10c00917 	ldw	r3,36(r2)
 2032210:	d0a04283 	ldbu	r2,-32502(gp)
 2032214:	10803fcc 	andi	r2,r2,255
 2032218:	1080201c 	xori	r2,r2,128
 203221c:	10bfe004 	addi	r2,r2,-128
 2032220:	1880381e 	bne	r3,r2,2032304 <tcp_input+0x189c>
            {
               tcp_seq onxt = tp->snd_nxt;
 2032224:	e0bfe617 	ldw	r2,-104(fp)
 2032228:	10800f17 	ldw	r2,60(r2)
 203222c:	e0bffa15 	stw	r2,-24(fp)
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 2032230:	e0bfe617 	ldw	r2,-104(fp)
 2032234:	10801417 	ldw	r2,80(r2)
 2032238:	e0ffe617 	ldw	r3,-104(fp)
 203223c:	18c01b17 	ldw	r3,108(r3)
 2032240:	1880012e 	bgeu	r3,r2,2032248 <tcp_input+0x17e0>
 2032244:	1805883a 	mov	r2,r3
 2032248:	1006d07a 	srli	r3,r2,1
               tp->t_maxseg;
 203224c:	e0bfe617 	ldw	r2,-104(fp)
 2032250:	10800a0b 	ldhu	r2,40(r2)
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
 2032254:	10bfffcc 	andi	r2,r2,65535
 2032258:	1885203a 	divu	r2,r3,r2
               tp->t_dupacks = 0;
            }
            else if (++tp->t_dupacks == tcprexmtthresh) 
            {
               tcp_seq onxt = tp->snd_nxt;
               u_short  win   =
 203225c:	e0bff00d 	sth	r2,-64(fp)
               MIN(tp->snd_wnd, tp->snd_cwnd) / 2 /
               tp->t_maxseg;

               if (win < 2)
 2032260:	e0bff00b 	ldhu	r2,-64(fp)
 2032264:	108000a8 	cmpgeui	r2,r2,2
 2032268:	1000021e 	bne	r2,zero,2032274 <tcp_input+0x180c>
                  win = 2;
 203226c:	00800084 	movi	r2,2
 2032270:	e0bff00d 	sth	r2,-64(fp)
               tp->snd_ssthresh = (u_short)(win * tp->t_maxseg);
 2032274:	e0bfe617 	ldw	r2,-104(fp)
 2032278:	10c00a0b 	ldhu	r3,40(r2)
 203227c:	e0bff00b 	ldhu	r2,-64(fp)
 2032280:	1885383a 	mul	r2,r3,r2
 2032284:	10ffffcc 	andi	r3,r2,65535
 2032288:	e0bfe617 	ldw	r2,-104(fp)
 203228c:	10c01c15 	stw	r3,112(r2)

               tp->t_timer[TCPT_REXMT] = 0;
 2032290:	e0bfe617 	ldw	r2,-104(fp)
 2032294:	10000315 	stw	zero,12(r2)
               tp->t_rttick = 0;
 2032298:	e0bfe617 	ldw	r2,-104(fp)
 203229c:	10001e15 	stw	zero,120(r2)
               tp->snd_nxt = ti->ti_ack;
 20322a0:	e0bff217 	ldw	r2,-56(fp)
 20322a4:	10c00717 	ldw	r3,28(r2)
 20322a8:	e0bfe617 	ldw	r2,-104(fp)
 20322ac:	10c00f15 	stw	r3,60(r2)
               tp->snd_cwnd = tp->t_maxseg;
 20322b0:	e0bfe617 	ldw	r2,-104(fp)
 20322b4:	10800a0b 	ldhu	r2,40(r2)
 20322b8:	10ffffcc 	andi	r3,r2,65535
 20322bc:	e0bfe617 	ldw	r2,-104(fp)
 20322c0:	10c01b15 	stw	r3,108(r2)
               (void) tcp_output(tp);
 20322c4:	e13fe617 	ldw	r4,-104(fp)
 20322c8:	20334200 	call	2033420 <tcp_output>

               if (SEQ_GT(onxt, tp->snd_nxt))
 20322cc:	e0bfe617 	ldw	r2,-104(fp)
 20322d0:	10800f17 	ldw	r2,60(r2)
 20322d4:	e0fffa17 	ldw	r3,-24(fp)
 20322d8:	1885c83a 	sub	r2,r3,r2
 20322dc:	0080030e 	bge	zero,r2,20322ec <tcp_input+0x1884>
                  tp->snd_nxt = onxt;
 20322e0:	e0bfe617 	ldw	r2,-104(fp)
 20322e4:	e0fffa17 	ldw	r3,-24(fp)
 20322e8:	10c00f15 	stw	r3,60(r2)
               GOTO_DROP;
 20322ec:	00814544 	movi	r2,1301
 20322f0:	d0a0a915 	stw	r2,-32092(gp)
 20322f4:	00029d06 	br	2032d6c <tcp_input+0x2304>
            }
         } else
            tp->t_dupacks = 0;
 20322f8:	e0bfe617 	ldw	r2,-104(fp)
 20322fc:	10000915 	stw	zero,36(r2)
         break;
 2032300:	0000e006 	br	2032684 <tcp_input+0x1c1c>
             * ack and the exp-to-linear thresh
             * set for half the current window
             * size (since we know we're losing at
             * the current window size).
             */
            if (tp->t_timer[TCPT_REXMT] == 0 ||
 2032304:	0001883a 	nop
                  tp->snd_nxt = onxt;
               GOTO_DROP;
            }
         } else
            tp->t_dupacks = 0;
         break;
 2032308:	0000de06 	br	2032684 <tcp_input+0x1c1c>
      }
      tp->t_dupacks = 0;
 203230c:	e0bfe617 	ldw	r2,-104(fp)
 2032310:	10000915 	stw	zero,36(r2)
      if (SEQ_GT(ti->ti_ack, tp->snd_max)) 
 2032314:	e0bff217 	ldw	r2,-56(fp)
 2032318:	10c00717 	ldw	r3,28(r2)
 203231c:	e0bfe617 	ldw	r2,-104(fp)
 2032320:	10801a17 	ldw	r2,104(r2)
 2032324:	1885c83a 	sub	r2,r3,r2
 2032328:	0080080e 	bge	zero,r2,203234c <tcp_input+0x18e4>
      {
         tcpstat.tcps_rcvacktoomuch++;
 203232c:	00809934 	movhi	r2,612
 2032330:	10b6f504 	addi	r2,r2,-9260
 2032334:	10802a17 	ldw	r2,168(r2)
 2032338:	10c00044 	addi	r3,r2,1
 203233c:	00809934 	movhi	r2,612
 2032340:	10b6f504 	addi	r2,r2,-9260
 2032344:	10c02a15 	stw	r3,168(r2)
         goto dropafterack;
 2032348:	00023606 	br	2032c24 <tcp_input+0x21bc>
      }
      acked = (int)(ti->ti_ack - tp->snd_una);
 203234c:	e0bff217 	ldw	r2,-56(fp)
 2032350:	10c00717 	ldw	r3,28(r2)
 2032354:	e0bfe617 	ldw	r2,-104(fp)
 2032358:	10800e17 	ldw	r2,56(r2)
 203235c:	1885c83a 	sub	r2,r3,r2
 2032360:	e0bff615 	stw	r2,-40(fp)
      tcpstat.tcps_rcvackpack++;
 2032364:	00809934 	movhi	r2,612
 2032368:	10b6f504 	addi	r2,r2,-9260
 203236c:	10802b17 	ldw	r2,172(r2)
 2032370:	10c00044 	addi	r3,r2,1
 2032374:	00809934 	movhi	r2,612
 2032378:	10b6f504 	addi	r2,r2,-9260
 203237c:	10c02b15 	stw	r3,172(r2)
      tcpstat.tcps_rcvackbyte += acked;
 2032380:	00809934 	movhi	r2,612
 2032384:	10b6f504 	addi	r2,r2,-9260
 2032388:	10c02c17 	ldw	r3,176(r2)
 203238c:	e0bff617 	ldw	r2,-40(fp)
 2032390:	1887883a 	add	r3,r3,r2
 2032394:	00809934 	movhi	r2,612
 2032398:	10b6f504 	addi	r2,r2,-9260
 203239c:	10c02c15 	stw	r3,176(r2)
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 20323a0:	e0bfe617 	ldw	r2,-104(fp)
 20323a4:	10801e17 	ldw	r2,120(r2)
 20323a8:	10000826 	beq	r2,zero,20323cc <tcp_input+0x1964>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
 20323ac:	e0bff217 	ldw	r2,-56(fp)
 20323b0:	10c00717 	ldw	r3,28(r2)
 20323b4:	e0bfe617 	ldw	r2,-104(fp)
 20323b8:	10801f17 	ldw	r2,124(r2)
 20323bc:	1885c83a 	sub	r2,r3,r2
       * number was acked, update smoothed round trip time.
       * Since we now have an rtt measurement, cancel the
       * timer backoff (cf., Phil Karn's retransmit alg.).
       * Recompute the initial retransmit timer.
       */
      if((tp->t_rttick) && 
 20323c0:	0080020e 	bge	zero,r2,20323cc <tcp_input+0x1964>
#ifdef TCP_TIMESTAMP
         ((tp->t_flags & TF_TIMESTAMP) == 0) && 
#endif /* TCP_TIMESTAMP */
         (SEQ_GT(ti->ti_ack, tp->t_rtseq)))
         tcp_xmit_timer(tp);
 20323c4:	e13fe617 	ldw	r4,-104(fp)
 20323c8:	20330540 	call	2033054 <tcp_xmit_timer>
       * If all outstanding data is acked, stop retransmit
       * timer and remember to restart (more output or persist).
       * If there is more data to be acked, restart retransmit
       * timer, using current (possibly backed-off) value.
       */
      if (ti->ti_ack == tp->snd_max) 
 20323cc:	e0bff217 	ldw	r2,-56(fp)
 20323d0:	10c00717 	ldw	r3,28(r2)
 20323d4:	e0bfe617 	ldw	r2,-104(fp)
 20323d8:	10801a17 	ldw	r2,104(r2)
 20323dc:	1880051e 	bne	r3,r2,20323f4 <tcp_input+0x198c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 20323e0:	e0bfe617 	ldw	r2,-104(fp)
 20323e4:	10000315 	stw	zero,12(r2)
         needoutput = 1;
 20323e8:	00800044 	movi	r2,1
 20323ec:	e0bfeb15 	stw	r2,-84(fp)
 20323f0:	00000706 	br	2032410 <tcp_input+0x19a8>
      } else if (tp->t_timer[TCPT_PERSIST] == 0)
 20323f4:	e0bfe617 	ldw	r2,-104(fp)
 20323f8:	10800417 	ldw	r2,16(r2)
 20323fc:	1000041e 	bne	r2,zero,2032410 <tcp_input+0x19a8>
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 2032400:	e0bfe617 	ldw	r2,-104(fp)
 2032404:	10c00817 	ldw	r3,32(r2)
 2032408:	e0bfe617 	ldw	r2,-104(fp)
 203240c:	10c00315 	stw	r3,12(r2)
       * in flight, open exponentially (maxseg per packet).
       * Otherwise open linearly (maxseg per window,
       * or maxseg^2 / cwnd per packet).
       */
      {
         tcp_win  cw =  tp->snd_cwnd;
 2032410:	e0bfe617 	ldw	r2,-104(fp)
 2032414:	10801b17 	ldw	r2,108(r2)
 2032418:	e0bffb15 	stw	r2,-20(fp)
         u_short  incr  =  tp->t_maxseg;
 203241c:	e0bfe617 	ldw	r2,-104(fp)
 2032420:	10800a0b 	ldhu	r2,40(r2)
 2032424:	e0bff08d 	sth	r2,-62(fp)

         if (cw > tp->snd_ssthresh)
 2032428:	e0bfe617 	ldw	r2,-104(fp)
 203242c:	10c01c17 	ldw	r3,112(r2)
 2032430:	e0bffb17 	ldw	r2,-20(fp)
 2032434:	18800a2e 	bgeu	r3,r2,2032460 <tcp_input+0x19f8>
            incr = MAX( (incr * incr / cw), (ALIGN_TYPE << 2) );
 2032438:	e0fff08b 	ldhu	r3,-62(fp)
 203243c:	e0bff08b 	ldhu	r2,-62(fp)
 2032440:	1885383a 	mul	r2,r3,r2
 2032444:	1007883a 	mov	r3,r2
 2032448:	e0bffb17 	ldw	r2,-20(fp)
 203244c:	1885203a 	divu	r2,r3,r2
 2032450:	10c00428 	cmpgeui	r3,r2,16
 2032454:	1800011e 	bne	r3,zero,203245c <tcp_input+0x19f4>
 2032458:	00800404 	movi	r2,16
 203245c:	e0bff08d 	sth	r2,-62(fp)

         tp->snd_cwnd = MIN(cw + (u_short)incr, (IP_MAXPACKET));
 2032460:	e0fff08b 	ldhu	r3,-62(fp)
 2032464:	e0bffb17 	ldw	r2,-20(fp)
 2032468:	1885883a 	add	r2,r3,r2
 203246c:	10d80070 	cmpltui	r3,r2,24577
 2032470:	1800011e 	bne	r3,zero,2032478 <tcp_input+0x1a10>
 2032474:	00980004 	movi	r2,24576
 2032478:	e0ffe617 	ldw	r3,-104(fp)
 203247c:	18801b15 	stw	r2,108(r3)
      }
      if (acked > (int)so->so_snd.sb_cc) 
 2032480:	e0bfe817 	ldw	r2,-96(fp)
 2032484:	10801217 	ldw	r2,72(r2)
 2032488:	1007883a 	mov	r3,r2
 203248c:	e0bff617 	ldw	r2,-40(fp)
 2032490:	1880120e 	bge	r3,r2,20324dc <tcp_input+0x1a74>
      {
         tp->snd_wnd -= (u_short)so->so_snd.sb_cc;
 2032494:	e0bfe617 	ldw	r2,-104(fp)
 2032498:	10c01417 	ldw	r3,80(r2)
 203249c:	e0bfe817 	ldw	r2,-96(fp)
 20324a0:	10801217 	ldw	r2,72(r2)
 20324a4:	10bfffcc 	andi	r2,r2,65535
 20324a8:	1887c83a 	sub	r3,r3,r2
 20324ac:	e0bfe617 	ldw	r2,-104(fp)
 20324b0:	10c01415 	stw	r3,80(r2)
         sbdrop(&so->so_snd, (int)so->so_snd.sb_cc);
 20324b4:	e0bfe817 	ldw	r2,-96(fp)
 20324b8:	10c01204 	addi	r3,r2,72
 20324bc:	e0bfe817 	ldw	r2,-96(fp)
 20324c0:	10801217 	ldw	r2,72(r2)
 20324c4:	1809883a 	mov	r4,r3
 20324c8:	100b883a 	mov	r5,r2
 20324cc:	202fa940 	call	202fa94 <sbdrop>
         ourfinisacked = 1;
 20324d0:	00800044 	movi	r2,1
 20324d4:	e0bfea15 	stw	r2,-88(fp)
 20324d8:	00000d06 	br	2032510 <tcp_input+0x1aa8>
      } 
      else 
      {
         sbdrop(&so->so_snd, acked);
 20324dc:	e0bfe817 	ldw	r2,-96(fp)
 20324e0:	10801204 	addi	r2,r2,72
 20324e4:	1009883a 	mov	r4,r2
 20324e8:	e17ff617 	ldw	r5,-40(fp)
 20324ec:	202fa940 	call	202fa94 <sbdrop>
         tp->snd_wnd -= (u_short)acked;
 20324f0:	e0bfe617 	ldw	r2,-104(fp)
 20324f4:	10c01417 	ldw	r3,80(r2)
 20324f8:	e0bff617 	ldw	r2,-40(fp)
 20324fc:	10bfffcc 	andi	r2,r2,65535
 2032500:	1887c83a 	sub	r3,r3,r2
 2032504:	e0bfe617 	ldw	r2,-104(fp)
 2032508:	10c01415 	stw	r3,80(r2)
         ourfinisacked = 0;
 203250c:	e03fea15 	stw	zero,-88(fp)
      }

      if (so->so_snd.sb_flags & (SB_WAIT | SB_SEL))
 2032510:	e0bfe817 	ldw	r2,-96(fp)
 2032514:	1080190b 	ldhu	r2,100(r2)
 2032518:	10bfffcc 	andi	r2,r2,65535
 203251c:	1080030c 	andi	r2,r2,12
 2032520:	10000526 	beq	r2,zero,2032538 <tcp_input+0x1ad0>
         sowwakeup(so);
 2032524:	e0bfe817 	ldw	r2,-96(fp)
 2032528:	10801204 	addi	r2,r2,72
 203252c:	e13fe817 	ldw	r4,-96(fp)
 2032530:	100b883a 	mov	r5,r2
 2032534:	202f3300 	call	202f330 <sbwakeup>

      tp->snd_una = ti->ti_ack;
 2032538:	e0bff217 	ldw	r2,-56(fp)
 203253c:	10c00717 	ldw	r3,28(r2)
 2032540:	e0bfe617 	ldw	r2,-104(fp)
 2032544:	10c00e15 	stw	r3,56(r2)
      if (SEQ_LT(tp->snd_nxt, tp->snd_una))
 2032548:	e0bfe617 	ldw	r2,-104(fp)
 203254c:	10c00f17 	ldw	r3,60(r2)
 2032550:	e0bfe617 	ldw	r2,-104(fp)
 2032554:	10800e17 	ldw	r2,56(r2)
 2032558:	1885c83a 	sub	r2,r3,r2
 203255c:	1000040e 	bge	r2,zero,2032570 <tcp_input+0x1b08>
         tp->snd_nxt = tp->snd_una;
 2032560:	e0bfe617 	ldw	r2,-104(fp)
 2032564:	10c00e17 	ldw	r3,56(r2)
 2032568:	e0bfe617 	ldw	r2,-104(fp)
 203256c:	10c00f15 	stw	r3,60(r2)


      switch (tp->t_state) 
 2032570:	e0bfe617 	ldw	r2,-104(fp)
 2032574:	10800217 	ldw	r2,8(r2)
 2032578:	10c001e0 	cmpeqi	r3,r2,7
 203257c:	18001c1e 	bne	r3,zero,20325f0 <tcp_input+0x1b88>
 2032580:	10c00208 	cmpgei	r3,r2,8
 2032584:	1800031e 	bne	r3,zero,2032594 <tcp_input+0x1b2c>
 2032588:	108001a0 	cmpeqi	r2,r2,6
 203258c:	1000061e 	bne	r2,zero,20325a8 <tcp_input+0x1b40>
 2032590:	00003c06 	br	2032684 <tcp_input+0x1c1c>
 2032594:	10c00220 	cmpeqi	r3,r2,8
 2032598:	1800261e 	bne	r3,zero,2032634 <tcp_input+0x1bcc>
 203259c:	108002a0 	cmpeqi	r2,r2,10
 20325a0:	10002b1e 	bne	r2,zero,2032650 <tcp_input+0x1be8>
 20325a4:	00003706 	br	2032684 <tcp_input+0x1c1c>
       * In FIN_WAIT_1 STATE in addition to the processing
       * for the ESTABLISHED state if our FIN is now acknowledged
       * then enter FIN_WAIT_2.
       */
      case TCPS_FIN_WAIT_1:
         if (ourfinisacked) 
 20325a8:	e0bfea17 	ldw	r2,-88(fp)
 20325ac:	10003026 	beq	r2,zero,2032670 <tcp_input+0x1c08>
             * data, then closing user can proceed.
             * Starting the timer is contrary to the
             * specification, but if we don't get a FIN
             * we'll hang forever.
             */
            if (so->so_state & SS_CANTRCVMORE) 
 20325b0:	e0bfe817 	ldw	r2,-96(fp)
 20325b4:	1080088b 	ldhu	r2,34(r2)
 20325b8:	10bfffcc 	andi	r2,r2,65535
 20325bc:	1080080c 	andi	r2,r2,32
 20325c0:	10000726 	beq	r2,zero,20325e0 <tcp_input+0x1b78>
            {
               soisdisconnected(so);
 20325c4:	e13fe817 	ldw	r4,-96(fp)
 20325c8:	202ed580 	call	202ed58 <soisdisconnected>
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
 20325cc:	00808174 	movhi	r2,517
 20325d0:	1090d504 	addi	r2,r2,17236
 20325d4:	10c00017 	ldw	r3,0(r2)
 20325d8:	e0bfe617 	ldw	r2,-104(fp)
 20325dc:	10c00615 	stw	r3,24(r2)
            }
            tp->t_state = TCPS_FIN_WAIT_2;
 20325e0:	e0bfe617 	ldw	r2,-104(fp)
 20325e4:	00c00244 	movi	r3,9
 20325e8:	10c00215 	stw	r3,8(r2)
         }
         break;
 20325ec:	00002006 	br	2032670 <tcp_input+0x1c08>
       * the ESTABLISHED state if the ACK acknowledges our FIN
       * then enter the TIME-WAIT state, otherwise ignore
       * the segment.
       */
      case TCPS_CLOSING:
         if (ourfinisacked) 
 20325f0:	e0bfea17 	ldw	r2,-88(fp)
 20325f4:	10002026 	beq	r2,zero,2032678 <tcp_input+0x1c10>
         {
            tp->t_state = TCPS_TIME_WAIT;
 20325f8:	e0bfe617 	ldw	r2,-104(fp)
 20325fc:	00c00284 	movi	r3,10
 2032600:	10c00215 	stw	r3,8(r2)
            tcp_canceltimers(tp);
 2032604:	e13fe617 	ldw	r4,-104(fp)
 2032608:	20351d80 	call	20351d8 <tcp_canceltimers>
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 203260c:	00808174 	movhi	r2,517
 2032610:	10906b04 	addi	r2,r2,16812
 2032614:	10800017 	ldw	r2,0(r2)
 2032618:	1085883a 	add	r2,r2,r2
 203261c:	1007883a 	mov	r3,r2
 2032620:	e0bfe617 	ldw	r2,-104(fp)
 2032624:	10c00615 	stw	r3,24(r2)
            soisdisconnected(so);
 2032628:	e13fe817 	ldw	r4,-96(fp)
 203262c:	202ed580 	call	202ed58 <soisdisconnected>
         }
         break;
 2032630:	00001106 	br	2032678 <tcp_input+0x1c10>
       * and/or to be acked, as well as for the ack of our FIN.
       * If our FIN is now acknowledged, delete the TCB,
       * enter the closed state and return.
       */
      case TCPS_LAST_ACK:
         if (ourfinisacked) 
 2032634:	e0bfea17 	ldw	r2,-88(fp)
 2032638:	10001126 	beq	r2,zero,2032680 <tcp_input+0x1c18>
         {
            SETTP(tp, tcp_close(tp));
 203263c:	e13fe617 	ldw	r4,-104(fp)
 2032640:	2034d240 	call	2034d24 <tcp_close>
            GOTO_DROP;
 2032644:	00816644 	movi	r2,1433
 2032648:	d0a0a915 	stw	r2,-32092(gp)
 203264c:	0001c706 	br	2032d6c <tcp_input+0x2304>
       * In TIME_WAIT state the only thing that should arrive
       * is a retransmission of the remote FIN.  Acknowledge
       * it and restart the finack timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 2032650:	00808174 	movhi	r2,517
 2032654:	10906b04 	addi	r2,r2,16812
 2032658:	10800017 	ldw	r2,0(r2)
 203265c:	1085883a 	add	r2,r2,r2
 2032660:	1007883a 	mov	r3,r2
 2032664:	e0bfe617 	ldw	r2,-104(fp)
 2032668:	10c00615 	stw	r3,24(r2)
         goto dropafterack;
 203266c:	00016d06 	br	2032c24 <tcp_input+0x21bc>
               soisdisconnected(so);
               tp->t_timer[TCPT_2MSL] = tcp_maxidle;
            }
            tp->t_state = TCPS_FIN_WAIT_2;
         }
         break;
 2032670:	0001883a 	nop
 2032674:	00000306 	br	2032684 <tcp_input+0x1c1c>
            tp->t_state = TCPS_TIME_WAIT;
            tcp_canceltimers(tp);
            tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
            soisdisconnected(so);
         }
         break;
 2032678:	0001883a 	nop
 203267c:	00000106 	br	2032684 <tcp_input+0x1c1c>
         if (ourfinisacked) 
         {
            SETTP(tp, tcp_close(tp));
            GOTO_DROP;
         }
         break;
 2032680:	0001883a 	nop
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 2032684:	e0bfe717 	ldw	r2,-100(fp)
 2032688:	1080040c 	andi	r2,r2,16
 203268c:	10004426 	beq	r2,zero,20327a0 <tcp_input+0x1d38>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 2032690:	e0bfe617 	ldw	r2,-104(fp)
 2032694:	10c01117 	ldw	r3,68(r2)
 2032698:	e0bff217 	ldw	r2,-56(fp)
 203269c:	10800617 	ldw	r2,24(r2)
 20326a0:	1885c83a 	sub	r2,r3,r2
step6:
   /*
    * Update window information.
    * Don't look at window if no ACK: TAC's send garbage on first SYN.
    */
   if ((tiflags & TH_ACK) &&
 20326a4:	10001416 	blt	r2,zero,20326f8 <tcp_input+0x1c90>
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 20326a8:	e0bfe617 	ldw	r2,-104(fp)
 20326ac:	10c01117 	ldw	r3,68(r2)
 20326b0:	e0bff217 	ldw	r2,-56(fp)
 20326b4:	10800617 	ldw	r2,24(r2)
 20326b8:	1880391e 	bne	r3,r2,20327a0 <tcp_input+0x1d38>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 20326bc:	e0bfe617 	ldw	r2,-104(fp)
 20326c0:	10c01217 	ldw	r3,72(r2)
 20326c4:	e0bff217 	ldw	r2,-56(fp)
 20326c8:	10800717 	ldw	r2,28(r2)
 20326cc:	1885c83a 	sub	r2,r3,r2
       /*
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
 20326d0:	10000916 	blt	r2,zero,20326f8 <tcp_input+0x1c90>
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 20326d4:	e0bfe617 	ldw	r2,-104(fp)
 20326d8:	10c01217 	ldw	r3,72(r2)
 20326dc:	e0bff217 	ldw	r2,-56(fp)
 20326e0:	10800717 	ldw	r2,28(r2)
        * Altera Niche Stack Nios port modification:
        * Add parenthesis to remove implicit order of operation
        * & possible build warnings.
        */
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
 20326e4:	18802e1e 	bne	r3,r2,20327a0 <tcp_input+0x1d38>
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
 20326e8:	e0bfe617 	ldw	r2,-104(fp)
 20326ec:	10c01417 	ldw	r3,80(r2)
 20326f0:	e0bff517 	ldw	r2,-44(fp)
 20326f4:	18802a2e 	bgeu	r3,r2,20327a0 <tcp_input+0x1d38>
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 20326f8:	e0bff217 	ldw	r2,-56(fp)
 20326fc:	1080028b 	ldhu	r2,10(r2)
 2032700:	10bfffcc 	andi	r2,r2,65535
 2032704:	1000101e 	bne	r2,zero,2032748 <tcp_input+0x1ce0>
          (tp->snd_wl2 == ti->ti_ack) &&
 2032708:	e0bfe617 	ldw	r2,-104(fp)
 203270c:	10c01217 	ldw	r3,72(r2)
 2032710:	e0bff217 	ldw	r2,-56(fp)
 2032714:	10800717 	ldw	r2,28(r2)
       (SEQ_LT(tp->snd_wl1, ti->ti_seq) || (tp->snd_wl1 == ti->ti_seq &&
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
 2032718:	18800b1e 	bne	r3,r2,2032748 <tcp_input+0x1ce0>
          (tp->snd_wl2 == ti->ti_ack) &&
          (rx_win > tp->snd_wnd))
 203271c:	e0bfe617 	ldw	r2,-104(fp)
 2032720:	10c01417 	ldw	r3,80(r2)
       (SEQ_LT(tp->snd_wl2, ti->ti_ack) ||
       ((tp->snd_wl2 == ti->ti_ack) && (rx_win > tp->snd_wnd)))))) 
   {
      /* keep track of pure window updates */
      if ((ti->ti_len == 0) &&
          (tp->snd_wl2 == ti->ti_ack) &&
 2032724:	e0bff517 	ldw	r2,-44(fp)
 2032728:	1880072e 	bgeu	r3,r2,2032748 <tcp_input+0x1ce0>
          (rx_win > tp->snd_wnd))
      {
         tcpstat.tcps_rcvwinupd++;
 203272c:	00809934 	movhi	r2,612
 2032730:	10b6f504 	addi	r2,r2,-9260
 2032734:	10802d17 	ldw	r2,180(r2)
 2032738:	10c00044 	addi	r3,r2,1
 203273c:	00809934 	movhi	r2,612
 2032740:	10b6f504 	addi	r2,r2,-9260
 2032744:	10c02d15 	stw	r3,180(r2)
      }
      tp->snd_wnd = rx_win;
 2032748:	e0bfe617 	ldw	r2,-104(fp)
 203274c:	e0fff517 	ldw	r3,-44(fp)
 2032750:	10c01415 	stw	r3,80(r2)
      tp->snd_wl1 = ti->ti_seq;
 2032754:	e0bff217 	ldw	r2,-56(fp)
 2032758:	10c00617 	ldw	r3,24(r2)
 203275c:	e0bfe617 	ldw	r2,-104(fp)
 2032760:	10c01115 	stw	r3,68(r2)
      tp->snd_wl2 = ti->ti_ack;
 2032764:	e0bff217 	ldw	r2,-56(fp)
 2032768:	10c00717 	ldw	r3,28(r2)
 203276c:	e0bfe617 	ldw	r2,-104(fp)
 2032770:	10c01215 	stw	r3,72(r2)
      if (tp->snd_wnd > tp->max_sndwnd)
 2032774:	e0bfe617 	ldw	r2,-104(fp)
 2032778:	10801417 	ldw	r2,80(r2)
 203277c:	e0ffe617 	ldw	r3,-104(fp)
 2032780:	18c02317 	ldw	r3,140(r3)
 2032784:	1880042e 	bgeu	r3,r2,2032798 <tcp_input+0x1d30>
         tp->max_sndwnd = tp->snd_wnd;
 2032788:	e0bfe617 	ldw	r2,-104(fp)
 203278c:	10c01417 	ldw	r3,80(r2)
 2032790:	e0bfe617 	ldw	r2,-104(fp)
 2032794:	10c02315 	stw	r3,140(r2)
      needoutput = 1;
 2032798:	00800044 	movi	r2,1
 203279c:	e0bfeb15 	stw	r2,-84(fp)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 20327a0:	e0bfe717 	ldw	r2,-100(fp)
 20327a4:	1080080c 	andi	r2,r2,32
 20327a8:	10005626 	beq	r2,zero,2032904 <tcp_input+0x1e9c>
 20327ac:	e0bff217 	ldw	r2,-56(fp)
 20327b0:	1080098b 	ldhu	r2,38(r2)
 20327b4:	10bfffcc 	andi	r2,r2,65535
 20327b8:	10005226 	beq	r2,zero,2032904 <tcp_input+0x1e9c>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 20327bc:	e0bfe617 	ldw	r2,-104(fp)
 20327c0:	10800217 	ldw	r2,8(r2)
   }

   /*
    * Process segments with URG.
    */
   if ((tiflags & TH_URG) && ti->ti_urp &&
 20327c4:	10800288 	cmpgei	r2,r2,10
 20327c8:	10004e1e 	bne	r2,zero,2032904 <tcp_input+0x1e9c>
       * This is a kludge, but if we receive and accept
       * random urgent pointers, we'll crash in
       * soreceive.  It's hard to imagine someone
       * actually wanting to send this much urgent data.
       */
      if (ti->ti_urp + so->so_rcv.sb_cc > SB_MAX) 
 20327cc:	e0bff217 	ldw	r2,-56(fp)
 20327d0:	1080098b 	ldhu	r2,38(r2)
 20327d4:	10ffffcc 	andi	r3,r2,65535
 20327d8:	e0bfe817 	ldw	r2,-96(fp)
 20327dc:	10800a17 	ldw	r2,40(r2)
 20327e0:	1885883a 	add	r2,r3,r2
 20327e4:	10900070 	cmpltui	r2,r2,16385
 20327e8:	1000071e 	bne	r2,zero,2032808 <tcp_input+0x1da0>
      {
         ti->ti_urp = 0;         /* XXX */
 20327ec:	e0bff217 	ldw	r2,-56(fp)
 20327f0:	1000098d 	sth	zero,38(r2)
         tiflags &= ~TH_URG;     /* XXX */
 20327f4:	e0ffe717 	ldw	r3,-100(fp)
 20327f8:	00bff7c4 	movi	r2,-33
 20327fc:	1884703a 	and	r2,r3,r2
 2032800:	e0bfe715 	stw	r2,-100(fp)
         goto dodata;         /* XXX */
 2032804:	00004b06 	br	2032934 <tcp_input+0x1ecc>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
 2032808:	e0bff217 	ldw	r2,-56(fp)
 203280c:	10c00617 	ldw	r3,24(r2)
 2032810:	e0bff217 	ldw	r2,-56(fp)
 2032814:	1080098b 	ldhu	r2,38(r2)
 2032818:	10bfffcc 	andi	r2,r2,65535
 203281c:	1887883a 	add	r3,r3,r2
 2032820:	e0bfe617 	ldw	r2,-104(fp)
 2032824:	10801717 	ldw	r2,92(r2)
 2032828:	1885c83a 	sub	r2,r3,r2
 203282c:	0080250e 	bge	zero,r2,20328c4 <tcp_input+0x1e5c>
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
 2032830:	e0bff217 	ldw	r2,-56(fp)
 2032834:	10c00617 	ldw	r3,24(r2)
 2032838:	e0bff217 	ldw	r2,-56(fp)
 203283c:	1080098b 	ldhu	r2,38(r2)
 2032840:	10bfffcc 	andi	r2,r2,65535
 2032844:	1887883a 	add	r3,r3,r2
 2032848:	e0bfe617 	ldw	r2,-104(fp)
 203284c:	10c01715 	stw	r3,92(r2)
         so->so_oobmark = so->so_rcv.sb_cc +
 2032850:	e0bfe817 	ldw	r2,-96(fp)
 2032854:	10c00a17 	ldw	r3,40(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
 2032858:	e0bfe617 	ldw	r2,-104(fp)
 203285c:	11001717 	ldw	r4,92(r2)
 2032860:	e0bfe617 	ldw	r2,-104(fp)
 2032864:	10801617 	ldw	r2,88(r2)
 2032868:	2085c83a 	sub	r2,r4,r2
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 203286c:	1885883a 	add	r2,r3,r2
         (tp->rcv_up - tp->rcv_nxt) - 1;
 2032870:	10ffffc4 	addi	r3,r2,-1
       * as the original spec states.
       */
      if (SEQ_GT(ti->ti_seq+ti->ti_urp, tp->rcv_up)) 
      {
         tp->rcv_up = ti->ti_seq + ti->ti_urp;
         so->so_oobmark = so->so_rcv.sb_cc +
 2032874:	e0bfe817 	ldw	r2,-96(fp)
 2032878:	10c01a15 	stw	r3,104(r2)
         (tp->rcv_up - tp->rcv_nxt) - 1;
         if (so->so_oobmark == 0)
 203287c:	e0bfe817 	ldw	r2,-96(fp)
 2032880:	10801a17 	ldw	r2,104(r2)
 2032884:	1000061e 	bne	r2,zero,20328a0 <tcp_input+0x1e38>
            so->so_state |= SS_RCVATMARK;
 2032888:	e0bfe817 	ldw	r2,-96(fp)
 203288c:	1080088b 	ldhu	r2,34(r2)
 2032890:	10801014 	ori	r2,r2,64
 2032894:	1007883a 	mov	r3,r2
 2032898:	e0bfe817 	ldw	r2,-96(fp)
 203289c:	10c0088d 	sth	r3,34(r2)
         sohasoutofband(so);
 20328a0:	e13fe817 	ldw	r4,-96(fp)
 20328a4:	202eb100 	call	202eb10 <sohasoutofband>
         tp->t_oobflags &= ~(TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 20328a8:	e0bfe617 	ldw	r2,-104(fp)
 20328ac:	10c02403 	ldbu	r3,144(r2)
 20328b0:	00bfff04 	movi	r2,-4
 20328b4:	1884703a 	and	r2,r3,r2
 20328b8:	1007883a 	mov	r3,r2
 20328bc:	e0bfe617 	ldw	r2,-104(fp)
 20328c0:	10c02405 	stb	r3,144(r2)
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 20328c4:	e0bff217 	ldw	r2,-56(fp)
 20328c8:	1080098b 	ldhu	r2,38(r2)
 20328cc:	e0fff217 	ldw	r3,-56(fp)
 20328d0:	18c0028b 	ldhu	r3,10(r3)
 20328d4:	10bfffcc 	andi	r2,r2,65535
 20328d8:	18ffffcc 	andi	r3,r3,65535
 20328dc:	18801436 	bltu	r3,r2,2032930 <tcp_input+0x1ec8>
#ifdef SO_OOBINLINE
       && (so->so_options & SO_OOBINLINE) == 0
 20328e0:	e0bfe817 	ldw	r2,-96(fp)
 20328e4:	10800417 	ldw	r2,16(r2)
 20328e8:	1080400c 	andi	r2,r2,256
 20328ec:	1000101e 	bne	r2,zero,2032930 <tcp_input+0x1ec8>
#endif
       )
      {
         tcp_pulloutofband(so, ti, m);
 20328f0:	e13fe817 	ldw	r4,-96(fp)
 20328f4:	e17ff217 	ldw	r5,-56(fp)
 20328f8:	e1bffe17 	ldw	r6,-8(fp)
 20328fc:	2032f280 	call	2032f28 <tcp_pulloutofband>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 2032900:	00000b06 	br	2032930 <tcp_input+0x1ec8>
      /*
       * If no out of band data is expected,
       * pull receive urgent pointer along
       * with the receive window.
       */
   if (SEQ_GT(tp->rcv_nxt, tp->rcv_up))
 2032904:	e0bfe617 	ldw	r2,-104(fp)
 2032908:	10c01617 	ldw	r3,88(r2)
 203290c:	e0bfe617 	ldw	r2,-104(fp)
 2032910:	10801717 	ldw	r2,92(r2)
 2032914:	1885c83a 	sub	r2,r3,r2
 2032918:	0080060e 	bge	zero,r2,2032934 <tcp_input+0x1ecc>
      tp->rcv_up = tp->rcv_nxt;
 203291c:	e0bfe617 	ldw	r2,-104(fp)
 2032920:	10c01617 	ldw	r3,88(r2)
 2032924:	e0bfe617 	ldw	r2,-104(fp)
 2032928:	10c01715 	stw	r3,92(r2)
 203292c:	00000106 	br	2032934 <tcp_input+0x1ecc>
       * Remove out of band data so doesn't get presented to user.
       * This can happen independent of advancing the URG pointer,
       * but if two URG's are pending at once, some out-of-band
       * data may creep in... ick.
       */
      if ( (ti->ti_urp <= ti->ti_len)
 2032930:	0001883a 	nop
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 2032934:	e0bff217 	ldw	r2,-56(fp)
 2032938:	1080028b 	ldhu	r2,10(r2)
 203293c:	10bfffcc 	andi	r2,r2,65535
 2032940:	1000031e 	bne	r2,zero,2032950 <tcp_input+0x1ee8>
 2032944:	e0bfe717 	ldw	r2,-100(fp)
 2032948:	1080004c 	andi	r2,r2,1
 203294c:	10005e26 	beq	r2,zero,2032ac8 <tcp_input+0x2060>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 2032950:	e0bfe617 	ldw	r2,-104(fp)
 2032954:	10800217 	ldw	r2,8(r2)
    * This process logically involves adjusting tp->rcv_wnd as data
    * is presented to the user (this happens in tcp_usrreq.c,
    * case PRU_RCVD).  If a FIN has already been received on this
    * connection then we just ignore the text.
    */
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
 2032958:	10800288 	cmpgei	r2,r2,10
 203295c:	10005a1e 	bne	r2,zero,2032ac8 <tcp_input+0x2060>
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 2032960:	e0bff217 	ldw	r2,-56(fp)
 2032964:	10c00617 	ldw	r3,24(r2)
 2032968:	e0bfe617 	ldw	r2,-104(fp)
 203296c:	10801617 	ldw	r2,88(r2)
 2032970:	1880371e 	bne	r3,r2,2032a50 <tcp_input+0x1fe8>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 2032974:	e0bfe617 	ldw	r2,-104(fp)
 2032978:	10c00017 	ldw	r3,0(r2)
   if ((ti->ti_len || (tiflags&TH_FIN)) &&
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
 203297c:	e0bfe617 	ldw	r2,-104(fp)
 2032980:	1880331e 	bne	r3,r2,2032a50 <tcp_input+0x1fe8>
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
         (tp->t_state == TCPS_ESTABLISHED))
 2032984:	e0bfe617 	ldw	r2,-104(fp)
 2032988:	10800217 	ldw	r2,8(r2)
       TCPS_HAVERCVDFIN(tp->t_state) == 0) 
   {

      /* Do the common segment reassembly case inline */
      if((ti->ti_seq == tp->rcv_nxt) &&
         (tp->seg_next == (struct tcpiphdr *)(tp) ) &&
 203298c:	10800118 	cmpnei	r2,r2,4
 2032990:	10002f1e 	bne	r2,zero,2032a50 <tcp_input+0x1fe8>
         else
         {
            tp->t_flags |= TF_ACKNOW;
         }
#else    /* not DO_DELAY_ACKS */
            tp->t_flags |= TF_ACKNOW;
 2032994:	e0bfe617 	ldw	r2,-104(fp)
 2032998:	10800b0b 	ldhu	r2,44(r2)
 203299c:	10800054 	ori	r2,r2,1
 20329a0:	1007883a 	mov	r3,r2
 20329a4:	e0bfe617 	ldw	r2,-104(fp)
 20329a8:	10c00b0d 	sth	r3,44(r2)
#endif   /* DO_DELAY_ACKS */

         tp->rcv_nxt += ti->ti_len;
 20329ac:	e0bfe617 	ldw	r2,-104(fp)
 20329b0:	10c01617 	ldw	r3,88(r2)
 20329b4:	e0bff217 	ldw	r2,-56(fp)
 20329b8:	1080028b 	ldhu	r2,10(r2)
 20329bc:	10bfffcc 	andi	r2,r2,65535
 20329c0:	1887883a 	add	r3,r3,r2
 20329c4:	e0bfe617 	ldw	r2,-104(fp)
 20329c8:	10c01615 	stw	r3,88(r2)
         tiflags = ti->ti_flags & TH_FIN;
 20329cc:	e0bff217 	ldw	r2,-56(fp)
 20329d0:	10800843 	ldbu	r2,33(r2)
 20329d4:	10803fcc 	andi	r2,r2,255
 20329d8:	1080004c 	andi	r2,r2,1
 20329dc:	e0bfe715 	stw	r2,-100(fp)
         tcpstat.tcps_rcvpack++;
 20329e0:	00809934 	movhi	r2,612
 20329e4:	10b6f504 	addi	r2,r2,-9260
 20329e8:	10801a17 	ldw	r2,104(r2)
 20329ec:	10c00044 	addi	r3,r2,1
 20329f0:	00809934 	movhi	r2,612
 20329f4:	10b6f504 	addi	r2,r2,-9260
 20329f8:	10c01a15 	stw	r3,104(r2)
         tcpstat.tcps_rcvbyte += ti->ti_len;
 20329fc:	00809934 	movhi	r2,612
 2032a00:	10b6f504 	addi	r2,r2,-9260
 2032a04:	10c01b17 	ldw	r3,108(r2)
 2032a08:	e0bff217 	ldw	r2,-56(fp)
 2032a0c:	1080028b 	ldhu	r2,10(r2)
 2032a10:	10bfffcc 	andi	r2,r2,65535
 2032a14:	1887883a 	add	r3,r3,r2
 2032a18:	00809934 	movhi	r2,612
 2032a1c:	10b6f504 	addi	r2,r2,-9260
 2032a20:	10c01b15 	stw	r3,108(r2)
         sbappend(&so->so_rcv, (m));
 2032a24:	e0bfe817 	ldw	r2,-96(fp)
 2032a28:	10800a04 	addi	r2,r2,40
 2032a2c:	1009883a 	mov	r4,r2
 2032a30:	e17ffe17 	ldw	r5,-8(fp)
 2032a34:	202f4e40 	call	202f4e4 <sbappend>
         sorwakeup(so);
 2032a38:	e0bfe817 	ldw	r2,-96(fp)
 2032a3c:	10800a04 	addi	r2,r2,40
 2032a40:	e13fe817 	ldw	r4,-96(fp)
 2032a44:	100b883a 	mov	r5,r2
 2032a48:	202f3300 	call	202f330 <sbwakeup>
 2032a4c:	00000b06 	br	2032a7c <tcp_input+0x2014>
#endif /* TCP_SACK */
      }
      else     /* received out of sequence segment */
      {
         /* Drop it in the reassmbly queue */
         tiflags = tcp_reass(tp, ti, m);
 2032a50:	e13fe617 	ldw	r4,-104(fp)
 2032a54:	e17ff217 	ldw	r5,-56(fp)
 2032a58:	e1bffe17 	ldw	r6,-8(fp)
 2032a5c:	203065c0 	call	203065c <tcp_reass>
 2032a60:	e0bfe715 	stw	r2,-100(fp)
         tp->t_flags |= TF_ACKNOW;
 2032a64:	e0bfe617 	ldw	r2,-104(fp)
 2032a68:	10800b0b 	ldhu	r2,44(r2)
 2032a6c:	10800054 	ori	r2,r2,1
 2032a70:	1007883a 	mov	r3,r2
 2032a74:	e0bfe617 	ldw	r2,-104(fp)
 2032a78:	10c00b0d 	sth	r3,44(r2)
      /*
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
 2032a7c:	e0bfe817 	ldw	r2,-96(fp)
 2032a80:	10c00b17 	ldw	r3,44(r2)
 2032a84:	e0bfe617 	ldw	r2,-104(fp)
 2032a88:	11001617 	ldw	r4,88(r2)
 2032a8c:	e0bfe617 	ldw	r2,-104(fp)
 2032a90:	10801917 	ldw	r2,100(r2)
 2032a94:	2085c83a 	sub	r2,r4,r2
 2032a98:	1885883a 	add	r2,r3,r2
 2032a9c:	e0bffc15 	stw	r2,-16(fp)
      if (len > (int)tp->max_rcvd)
 2032aa0:	e0bfe617 	ldw	r2,-104(fp)
 2032aa4:	10802217 	ldw	r2,136(r2)
 2032aa8:	1007883a 	mov	r3,r2
 2032aac:	e0bffc17 	ldw	r2,-16(fp)
 2032ab0:	18800b0e 	bge	r3,r2,2032ae0 <tcp_input+0x2078>
         tp->max_rcvd = (u_short)len;
 2032ab4:	e0bffc17 	ldw	r2,-16(fp)
 2032ab8:	10ffffcc 	andi	r3,r2,65535
 2032abc:	e0bfe617 	ldw	r2,-104(fp)
 2032ac0:	10c02215 	stw	r3,136(r2)
       * Note the amount of data that peer has sent into
       * our window, in order to estimate the sender's
       * buffer size.
       */
      len = (int)(so->so_rcv.sb_hiwat - (tp->rcv_adv - tp->rcv_nxt));
      if (len > (int)tp->max_rcvd)
 2032ac4:	00000606 	br	2032ae0 <tcp_input+0x2078>
      }
#endif   /* TCP_ZEROCOPY */
   } 
   else
   {
      m_freem(m);
 2032ac8:	e13ffe17 	ldw	r4,-8(fp)
 2032acc:	20296780 	call	2029678 <m_freem>
      tiflags &= ~TH_FIN;
 2032ad0:	e0ffe717 	ldw	r3,-100(fp)
 2032ad4:	00bfff84 	movi	r2,-2
 2032ad8:	1884703a 	and	r2,r3,r2
 2032adc:	e0bfe715 	stw	r2,-100(fp)

   /*
    * If FIN is received ACK the FIN and let the user know
    * that the connection is closing.
    */
   if (tiflags & TH_FIN) 
 2032ae0:	e0bfe717 	ldw	r2,-100(fp)
 2032ae4:	1080004c 	andi	r2,r2,1
 2032ae8:	10004426 	beq	r2,zero,2032bfc <tcp_input+0x2194>
   {
      if (TCPS_HAVERCVDFIN(tp->t_state) == 0) 
 2032aec:	e0bfe617 	ldw	r2,-104(fp)
 2032af0:	10800217 	ldw	r2,8(r2)
 2032af4:	10800288 	cmpgei	r2,r2,10
 2032af8:	10000d1e 	bne	r2,zero,2032b30 <tcp_input+0x20c8>
      {
         socantrcvmore(so);
 2032afc:	e13fe817 	ldw	r4,-96(fp)
 2032b00:	202f23c0 	call	202f23c <socantrcvmore>
         tp->t_flags |= TF_ACKNOW;
 2032b04:	e0bfe617 	ldw	r2,-104(fp)
 2032b08:	10800b0b 	ldhu	r2,44(r2)
 2032b0c:	10800054 	ori	r2,r2,1
 2032b10:	1007883a 	mov	r3,r2
 2032b14:	e0bfe617 	ldw	r2,-104(fp)
 2032b18:	10c00b0d 	sth	r3,44(r2)
         tp->rcv_nxt++;
 2032b1c:	e0bfe617 	ldw	r2,-104(fp)
 2032b20:	10801617 	ldw	r2,88(r2)
 2032b24:	10c00044 	addi	r3,r2,1
 2032b28:	e0bfe617 	ldw	r2,-104(fp)
 2032b2c:	10c01615 	stw	r3,88(r2)
      }
      switch (tp->t_state) 
 2032b30:	e0bfe617 	ldw	r2,-104(fp)
 2032b34:	10800217 	ldw	r2,8(r2)
 2032b38:	10bfff44 	addi	r2,r2,-3
 2032b3c:	10c00228 	cmpgeui	r3,r2,8
 2032b40:	18002e1e 	bne	r3,zero,2032bfc <tcp_input+0x2194>
 2032b44:	1085883a 	add	r2,r2,r2
 2032b48:	1087883a 	add	r3,r2,r2
 2032b4c:	008080f4 	movhi	r2,515
 2032b50:	108ad804 	addi	r2,r2,11104
 2032b54:	1885883a 	add	r2,r3,r2
 2032b58:	10800017 	ldw	r2,0(r2)
 2032b5c:	1000683a 	jmp	r2
 2032b60:	02032b80 	call	2032b8 <__alt_mem_descriptor_memory+0x2016b8>
 2032b64:	02032b80 	call	2032b8 <__alt_mem_descriptor_memory+0x2016b8>
 2032b68:	02032bfc 	xorhi	r8,zero,3247
 2032b6c:	02032b90 	cmplti	r8,zero,3246
 2032b70:	02032bfc 	xorhi	r8,zero,3247
 2032b74:	02032bfc 	xorhi	r8,zero,3247
 2032b78:	02032ba0 	cmpeqi	r8,zero,3246
 2032b7c:	02032bdc 	xori	r8,zero,3247
       * In SYN_RECEIVED and ESTABLISHED STATES
       * enter the CLOSE_WAIT state.
       */
      case TCPS_SYN_RECEIVED:
      case TCPS_ESTABLISHED:
         tp->t_state = TCPS_CLOSE_WAIT;
 2032b80:	e0bfe617 	ldw	r2,-104(fp)
 2032b84:	00c00144 	movi	r3,5
 2032b88:	10c00215 	stw	r3,8(r2)
         break;
 2032b8c:	00001b06 	br	2032bfc <tcp_input+0x2194>
       /*
       * If still in FIN_WAIT_1 STATE FIN has not been acked so
       * enter the CLOSING state.
       */
      case TCPS_FIN_WAIT_1:
         tp->t_state = TCPS_CLOSING;
 2032b90:	e0bfe617 	ldw	r2,-104(fp)
 2032b94:	00c001c4 	movi	r3,7
 2032b98:	10c00215 	stw	r3,8(r2)
         break;
 2032b9c:	00001706 	br	2032bfc <tcp_input+0x2194>
       * In FIN_WAIT_2 state enter the TIME_WAIT state,
       * starting the time-wait timer, turning off the other 
       * standard timers.
       */
      case TCPS_FIN_WAIT_2:
         tp->t_state = TCPS_TIME_WAIT;
 2032ba0:	e0bfe617 	ldw	r2,-104(fp)
 2032ba4:	00c00284 	movi	r3,10
 2032ba8:	10c00215 	stw	r3,8(r2)
         tcp_canceltimers(tp);
 2032bac:	e13fe617 	ldw	r4,-104(fp)
 2032bb0:	20351d80 	call	20351d8 <tcp_canceltimers>
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 2032bb4:	00808174 	movhi	r2,517
 2032bb8:	10906b04 	addi	r2,r2,16812
 2032bbc:	10800017 	ldw	r2,0(r2)
 2032bc0:	1085883a 	add	r2,r2,r2
 2032bc4:	1007883a 	mov	r3,r2
 2032bc8:	e0bfe617 	ldw	r2,-104(fp)
 2032bcc:	10c00615 	stw	r3,24(r2)
         soisdisconnected(so);
 2032bd0:	e13fe817 	ldw	r4,-96(fp)
 2032bd4:	202ed580 	call	202ed58 <soisdisconnected>
         break;
 2032bd8:	00000806 	br	2032bfc <tcp_input+0x2194>

      /*
       * In TIME_WAIT state restart the 2 MSL time_wait timer.
       */
      case TCPS_TIME_WAIT:
         tp->t_timer[TCPT_2MSL] = 2 * TCPTV_MSL;
 2032bdc:	00808174 	movhi	r2,517
 2032be0:	10906b04 	addi	r2,r2,16812
 2032be4:	10800017 	ldw	r2,0(r2)
 2032be8:	1085883a 	add	r2,r2,r2
 2032bec:	1007883a 	mov	r3,r2
 2032bf0:	e0bfe617 	ldw	r2,-104(fp)
 2032bf4:	10c00615 	stw	r3,24(r2)
         break;
 2032bf8:	0001883a 	nop
    ostate, tp, &tcp_saveti);
#endif
   /*
    * Return any desired output.
    */
   if (needoutput || (tp->t_flags & TF_ACKNOW))
 2032bfc:	e0bfeb17 	ldw	r2,-84(fp)
 2032c00:	1000051e 	bne	r2,zero,2032c18 <tcp_input+0x21b0>
 2032c04:	e0bfe617 	ldw	r2,-104(fp)
 2032c08:	10800b0b 	ldhu	r2,44(r2)
 2032c0c:	10bfffcc 	andi	r2,r2,65535
 2032c10:	1080004c 	andi	r2,r2,1
 2032c14:	10005f26 	beq	r2,zero,2032d94 <tcp_input+0x232c>
      (void) tcp_output(tp);
 2032c18:	e13fe617 	ldw	r4,-104(fp)
 2032c1c:	20334200 	call	2033420 <tcp_output>
 2032c20:	00005c06 	br	2032d94 <tcp_input+0x232c>
dropafterack:
   /*
    * Generate an ACK dropping incoming segment if it occupies
    * sequence space, where the ACK reflects our state.
    */
   if (tiflags & TH_RST)
 2032c24:	e0bfe717 	ldw	r2,-100(fp)
 2032c28:	1080010c 	andi	r2,r2,4
 2032c2c:	10000326 	beq	r2,zero,2032c3c <tcp_input+0x21d4>
      GOTO_DROP;
 2032c30:	0081a904 	movi	r2,1700
 2032c34:	d0a0a915 	stw	r2,-32092(gp)
 2032c38:	00004c06 	br	2032d6c <tcp_input+0x2304>
   m_freem (m);
 2032c3c:	e13ffe17 	ldw	r4,-8(fp)
 2032c40:	20296780 	call	2029678 <m_freem>
   tp->t_flags |= TF_ACKNOW;
 2032c44:	e0bfe617 	ldw	r2,-104(fp)
 2032c48:	10800b0b 	ldhu	r2,44(r2)
 2032c4c:	10800054 	ori	r2,r2,1
 2032c50:	1007883a 	mov	r3,r2
 2032c54:	e0bfe617 	ldw	r2,-104(fp)
 2032c58:	10c00b0d 	sth	r3,44(r2)
   (void) tcp_output (tp);
 2032c5c:	e13fe617 	ldw	r4,-104(fp)
 2032c60:	20334200 	call	2033420 <tcp_output>
 2032c64:	00004b06 	br	2032d94 <tcp_input+0x232c>
   return;

dropwithreset:
   TCP_MIB_INC(tcpInErrs);    /* keep MIB stats */
 2032c68:	00809934 	movhi	r2,612
 2032c6c:	10b6c704 	addi	r2,r2,-9444
 2032c70:	10800d17 	ldw	r2,52(r2)
 2032c74:	10c00044 	addi	r3,r2,1
 2032c78:	00809934 	movhi	r2,612
 2032c7c:	10b6c704 	addi	r2,r2,-9444
 2032c80:	10c00d15 	stw	r3,52(r2)
   if (om) 
 2032c84:	e0bfe517 	ldw	r2,-108(fp)
 2032c88:	10000326 	beq	r2,zero,2032c98 <tcp_input+0x2230>
   {
      (void) m_free(om);
 2032c8c:	e13fe517 	ldw	r4,-108(fp)
 2032c90:	20295600 	call	2029560 <m_free>
      om = 0;
 2032c94:	e03fe515 	stw	zero,-108(fp)
   }

   /* Don't reset resets */
   if (tiflags & TH_RST)
 2032c98:	e0bfe717 	ldw	r2,-100(fp)
 2032c9c:	1080010c 	andi	r2,r2,4
 2032ca0:	10000326 	beq	r2,zero,2032cb0 <tcp_input+0x2248>
      GOTO_DROP;
 2032ca4:	0081ad04 	movi	r2,1716
 2032ca8:	d0a0a915 	stw	r2,-32092(gp)
 2032cac:	00002f06 	br	2032d6c <tcp_input+0x2304>
    * Generate a RST, dropping incoming segment.
    * Make ACK acceptable to originator of segment.
    * Don't bother to respond if destination was broadcast.
    */
#ifdef IP_V4
   if (in_broadcast(ti->ti_dst.s_addr))
 2032cb0:	e0bff217 	ldw	r2,-56(fp)
 2032cb4:	10800417 	ldw	r2,16(r2)
 2032cb8:	1009883a 	mov	r4,r2
 2032cbc:	202a5e00 	call	202a5e0 <in_broadcast>
 2032cc0:	10000326 	beq	r2,zero,2032cd0 <tcp_input+0x2268>
      GOTO_DROP;
 2032cc4:	0081af44 	movi	r2,1725
 2032cc8:	d0a0a915 	stw	r2,-32092(gp)
 2032ccc:	00002706 	br	2032d6c <tcp_input+0x2304>
      IP6CPY(&(m->pkt->ip6_hdr->ip_src), &ip6_src);
      IP6CPY(&(m->pkt->ip6_hdr->ip_dest), &ip6_dst);
   }
#endif   /* IP_V6 */

   if (tiflags & TH_ACK)
 2032cd0:	e0bfe717 	ldw	r2,-100(fp)
 2032cd4:	1080040c 	andi	r2,r2,16
 2032cd8:	10000c26 	beq	r2,zero,2032d0c <tcp_input+0x22a4>
      tcp_respond (tp, ti, (tcp_seq)0, ti->ti_ack, TH_RST, m);
 2032cdc:	e0bff217 	ldw	r2,-56(fp)
 2032ce0:	10800717 	ldw	r2,28(r2)
 2032ce4:	00c00104 	movi	r3,4
 2032ce8:	d8c00015 	stw	r3,0(sp)
 2032cec:	e0fffe17 	ldw	r3,-8(fp)
 2032cf0:	d8c00115 	stw	r3,4(sp)
 2032cf4:	e13fe617 	ldw	r4,-104(fp)
 2032cf8:	e17ff217 	ldw	r5,-56(fp)
 2032cfc:	000d883a 	mov	r6,zero
 2032d00:	100f883a 	mov	r7,r2
 2032d04:	20347600 	call	2034760 <tcp_respond>
 2032d08:	00001306 	br	2032d58 <tcp_input+0x22f0>
   else
   {
      if (tiflags & TH_SYN)
 2032d0c:	e0bfe717 	ldw	r2,-100(fp)
 2032d10:	1080008c 	andi	r2,r2,2
 2032d14:	10000526 	beq	r2,zero,2032d2c <tcp_input+0x22c4>
         ti->ti_seq++;
 2032d18:	e0bff217 	ldw	r2,-56(fp)
 2032d1c:	10800617 	ldw	r2,24(r2)
 2032d20:	10c00044 	addi	r3,r2,1
 2032d24:	e0bff217 	ldw	r2,-56(fp)
 2032d28:	10c00615 	stw	r3,24(r2)
      tcp_respond(tp, ti, ti->ti_seq, (tcp_seq)0, TH_RST|TH_ACK, m);
 2032d2c:	e0bff217 	ldw	r2,-56(fp)
 2032d30:	10800617 	ldw	r2,24(r2)
 2032d34:	00c00504 	movi	r3,20
 2032d38:	d8c00015 	stw	r3,0(sp)
 2032d3c:	e0fffe17 	ldw	r3,-8(fp)
 2032d40:	d8c00115 	stw	r3,4(sp)
 2032d44:	e13fe617 	ldw	r4,-104(fp)
 2032d48:	e17ff217 	ldw	r5,-56(fp)
 2032d4c:	100d883a 	mov	r6,r2
 2032d50:	000f883a 	mov	r7,zero
 2032d54:	20347600 	call	2034760 <tcp_respond>
   }
   /* destroy temporarily created socket */
   if (dropsocket)
 2032d58:	e0bfec17 	ldw	r2,-80(fp)
 2032d5c:	10000d26 	beq	r2,zero,2032d94 <tcp_input+0x232c>
      (void) soabort(so);
 2032d60:	e13fe817 	ldw	r4,-96(fp)
 2032d64:	202d1d40 	call	202d1d4 <soabort>
 2032d68:	00000a06 	br	2032d94 <tcp_input+0x232c>
   return;

drop:
   if (om)
 2032d6c:	e0bfe517 	ldw	r2,-108(fp)
 2032d70:	10000226 	beq	r2,zero,2032d7c <tcp_input+0x2314>
      (void) m_free(om);
 2032d74:	e13fe517 	ldw	r4,-108(fp)
 2032d78:	20295600 	call	2029560 <m_free>
#ifdef DO_TCPTRACE
   if (tp && (tp->t_inpcb->inp_socket->so_options & SO_DEBUG))
      tcp_trace("drop: state %d, tcpcb: %x, saveti: %x",
    ostate, tp, &tcp_saveti);
#endif
   m_freem(m);
 2032d7c:	e13ffe17 	ldw	r4,-8(fp)
 2032d80:	20296780 	call	2029678 <m_freem>
   /* destroy temporarily created socket */
   if (dropsocket)
 2032d84:	e0bfec17 	ldw	r2,-80(fp)
 2032d88:	10000226 	beq	r2,zero,2032d94 <tcp_input+0x232c>
      (void) soabort(so);
 2032d8c:	e13fe817 	ldw	r4,-96(fp)
 2032d90:	202d1d40 	call	202d1d4 <soabort>
   return;
}
 2032d94:	e037883a 	mov	sp,fp
 2032d98:	dfc00117 	ldw	ra,4(sp)
 2032d9c:	df000017 	ldw	fp,0(sp)
 2032da0:	dec00204 	addi	sp,sp,8
 2032da4:	f800283a 	ret

02032da8 <tcp_dooptions>:

void
tcp_dooptions(struct tcpcb * tp, 
   struct mbuf *  om,
   struct tcpiphdr * ti)
{
 2032da8:	defff504 	addi	sp,sp,-44
 2032dac:	dfc00a15 	stw	ra,40(sp)
 2032db0:	df000915 	stw	fp,36(sp)
 2032db4:	df000904 	addi	fp,sp,36
 2032db8:	e13ffd15 	stw	r4,-12(fp)
 2032dbc:	e17ffe15 	stw	r5,-8(fp)
 2032dc0:	e1bfff15 	stw	r6,-4(fp)
   u_char * cp;   /* pointer into option buffer */
   int   opt;     /* current option code */
   int   optlen;  /* length of current option */
   int   cnt;     /* byte count left in header */
   struct socket * so = tp->t_inpcb->inp_socket;
 2032dc4:	e0bffd17 	ldw	r2,-12(fp)
 2032dc8:	10800d17 	ldw	r2,52(r2)
 2032dcc:	10800817 	ldw	r2,32(r2)
 2032dd0:	e0bffa15 	stw	r2,-24(fp)
#ifdef TCP_TIMESTAMP
   int   gotstamp = FALSE;    /* TRUE if we got a timestamp */
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
 2032dd4:	e0bffe17 	ldw	r2,-8(fp)
 2032dd8:	10800317 	ldw	r2,12(r2)
 2032ddc:	e0bff715 	stw	r2,-36(fp)
   cnt = om->m_len;
 2032de0:	e0bffe17 	ldw	r2,-8(fp)
 2032de4:	10800217 	ldw	r2,8(r2)
 2032de8:	e0bff915 	stw	r2,-28(fp)
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 2032dec:	00004006 	br	2032ef0 <tcp_dooptions+0x148>
   {
      opt = cp[0];
 2032df0:	e0bff717 	ldw	r2,-36(fp)
 2032df4:	10800003 	ldbu	r2,0(r2)
 2032df8:	10803fcc 	andi	r2,r2,255
 2032dfc:	e0bffb15 	stw	r2,-20(fp)
      if (opt == TCPOPT_EOL)
 2032e00:	e0bffb17 	ldw	r2,-20(fp)
 2032e04:	10003d26 	beq	r2,zero,2032efc <tcp_dooptions+0x154>
         break;
      if (opt == TCPOPT_NOP)
 2032e08:	e0bffb17 	ldw	r2,-20(fp)
 2032e0c:	10800058 	cmpnei	r2,r2,1
 2032e10:	1000031e 	bne	r2,zero,2032e20 <tcp_dooptions+0x78>
         optlen = 1;
 2032e14:	00800044 	movi	r2,1
 2032e18:	e0bff815 	stw	r2,-32(fp)
 2032e1c:	00000706 	br	2032e3c <tcp_dooptions+0x94>
      else 
      {
         optlen = cp[1];
 2032e20:	e0bff717 	ldw	r2,-36(fp)
 2032e24:	10800044 	addi	r2,r2,1
 2032e28:	10800003 	ldbu	r2,0(r2)
 2032e2c:	10803fcc 	andi	r2,r2,255
 2032e30:	e0bff815 	stw	r2,-32(fp)
         if (optlen <= 0)
 2032e34:	e0bff817 	ldw	r2,-32(fp)
 2032e38:	0080320e 	bge	zero,r2,2032f04 <tcp_dooptions+0x15c>
            break;
      }

      switch (opt) 
 2032e3c:	e0bffb17 	ldw	r2,-20(fp)
 2032e40:	108000a0 	cmpeqi	r2,r2,2
 2032e44:	10001e26 	beq	r2,zero,2032ec0 <tcp_dooptions+0x118>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
 2032e48:	e0bff817 	ldw	r2,-32(fp)
 2032e4c:	10800120 	cmpeqi	r2,r2,4
 2032e50:	10001c26 	beq	r2,zero,2032ec4 <tcp_dooptions+0x11c>
            continue;
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
 2032e54:	e0bfff17 	ldw	r2,-4(fp)
 2032e58:	10800843 	ldbu	r2,33(r2)
 2032e5c:	10803fcc 	andi	r2,r2,255
 2032e60:	1080008c 	andi	r2,r2,2
 2032e64:	10001926 	beq	r2,zero,2032ecc <tcp_dooptions+0x124>
            continue;
         mssval = *(u_short *)(cp + 2);
 2032e68:	e0bff717 	ldw	r2,-36(fp)
 2032e6c:	1080008b 	ldhu	r2,2(r2)
 2032e70:	e0bffc0d 	sth	r2,-16(fp)
         mssval = ntohs(mssval);
 2032e74:	e0bffc0b 	ldhu	r2,-16(fp)
 2032e78:	1004d23a 	srli	r2,r2,8
 2032e7c:	1007883a 	mov	r3,r2
 2032e80:	e0bffc0b 	ldhu	r2,-16(fp)
 2032e84:	1004923a 	slli	r2,r2,8
 2032e88:	1884b03a 	or	r2,r3,r2
 2032e8c:	e0bffc0d 	sth	r2,-16(fp)
         tp->t_maxseg = (u_short)MIN(mssval, (u_short)tcp_mss(so));
 2032e90:	e13ffa17 	ldw	r4,-24(fp)
 2032e94:	20333280 	call	2033328 <tcp_mss>
 2032e98:	10ffffcc 	andi	r3,r2,65535
 2032e9c:	e0bffc0b 	ldhu	r2,-16(fp)
 2032ea0:	1880032e 	bgeu	r3,r2,2032eb0 <tcp_dooptions+0x108>
 2032ea4:	e13ffa17 	ldw	r4,-24(fp)
 2032ea8:	20333280 	call	2033328 <tcp_mss>
 2032eac:	00000106 	br	2032eb4 <tcp_dooptions+0x10c>
 2032eb0:	e0bffc0b 	ldhu	r2,-16(fp)
 2032eb4:	e0fffd17 	ldw	r3,-12(fp)
 2032eb8:	18800a0d 	sth	r2,40(r3)
         break;
 2032ebc:	00000406 	br	2032ed0 <tcp_dooptions+0x128>
         }
         break;
#endif   /* TCP_TIMESTAMP */

      default:
         break;
 2032ec0:	00000306 	br	2032ed0 <tcp_dooptions+0x128>
      {
      case TCPOPT_MAXSEG:
      {
         u_short mssval;
         if (optlen != 4)
            continue;
 2032ec4:	0001883a 	nop
 2032ec8:	00000106 	br	2032ed0 <tcp_dooptions+0x128>
         if (!(ti->ti_flags & TH_SYN))    /* MSS only on SYN */
            continue;
 2032ecc:	0001883a 	nop
#endif   /* TCP_TIMESTAMP */


   cp = mtod(om, u_char *);
   cnt = om->m_len;
   for (; cnt > 0; cnt -= optlen, cp += optlen) 
 2032ed0:	e0fff917 	ldw	r3,-28(fp)
 2032ed4:	e0bff817 	ldw	r2,-32(fp)
 2032ed8:	1885c83a 	sub	r2,r3,r2
 2032edc:	e0bff915 	stw	r2,-28(fp)
 2032ee0:	e0bff817 	ldw	r2,-32(fp)
 2032ee4:	e0fff717 	ldw	r3,-36(fp)
 2032ee8:	1885883a 	add	r2,r3,r2
 2032eec:	e0bff715 	stw	r2,-36(fp)
 2032ef0:	e0bff917 	ldw	r2,-28(fp)
 2032ef4:	00bfbe16 	blt	zero,r2,2032df0 <tcp_dooptions+0x48>
 2032ef8:	00000306 	br	2032f08 <tcp_dooptions+0x160>
   {
      opt = cp[0];
      if (opt == TCPOPT_EOL)
         break;
 2032efc:	0001883a 	nop
 2032f00:	00000106 	br	2032f08 <tcp_dooptions+0x160>
         optlen = 1;
      else 
      {
         optlen = cp[1];
         if (optlen <= 0)
            break;
 2032f04:	0001883a 	nop

      default:
         break;
      }
   }
   (void) m_free(om);
 2032f08:	e13ffe17 	ldw	r4,-8(fp)
 2032f0c:	20295600 	call	2029560 <m_free>
      if(!gotstamp)
         tp->t_flags &= ~TF_TIMESTAMP;
   }
#endif /* TCP_TIMESTAMP */

   return;
 2032f10:	0001883a 	nop
}
 2032f14:	e037883a 	mov	sp,fp
 2032f18:	dfc00117 	ldw	ra,4(sp)
 2032f1c:	df000017 	ldw	fp,0(sp)
 2032f20:	dec00204 	addi	sp,sp,8
 2032f24:	f800283a 	ret

02032f28 <tcp_pulloutofband>:

void
tcp_pulloutofband(struct socket * so, 
   struct tcpiphdr * ti,
   struct mbuf *  m)
{
 2032f28:	defff804 	addi	sp,sp,-32
 2032f2c:	dfc00715 	stw	ra,28(sp)
 2032f30:	df000615 	stw	fp,24(sp)
 2032f34:	df000604 	addi	fp,sp,24
 2032f38:	e13ffd15 	stw	r4,-12(fp)
 2032f3c:	e17ffe15 	stw	r5,-8(fp)
 2032f40:	e1bfff15 	stw	r6,-4(fp)
   int   cnt   =  ti->ti_urp  -  1;
 2032f44:	e0bffe17 	ldw	r2,-8(fp)
 2032f48:	1080098b 	ldhu	r2,38(r2)
 2032f4c:	10bfffcc 	andi	r2,r2,65535
 2032f50:	10bfffc4 	addi	r2,r2,-1
 2032f54:	e0bffa15 	stw	r2,-24(fp)

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 2032f58:	00003206 	br	2033024 <tcp_pulloutofband+0xfc>
   {
      if (m->m_len > (unsigned)cnt) 
 2032f5c:	e0bfff17 	ldw	r2,-4(fp)
 2032f60:	10800217 	ldw	r2,8(r2)
 2032f64:	e0fffa17 	ldw	r3,-24(fp)
 2032f68:	1880242e 	bgeu	r3,r2,2032ffc <tcp_pulloutofband+0xd4>
      {
         char *   cp =  mtod(m,  char *) +  cnt;
 2032f6c:	e0bfff17 	ldw	r2,-4(fp)
 2032f70:	10c00317 	ldw	r3,12(r2)
 2032f74:	e0bffa17 	ldw	r2,-24(fp)
 2032f78:	1885883a 	add	r2,r3,r2
 2032f7c:	e0bffb15 	stw	r2,-20(fp)
         struct tcpcb * tp =  sototcpcb(so);
 2032f80:	e0bffd17 	ldw	r2,-12(fp)
 2032f84:	10800117 	ldw	r2,4(r2)
 2032f88:	10800917 	ldw	r2,36(r2)
 2032f8c:	e0bffc15 	stw	r2,-16(fp)

         tp->t_iobc = *cp;
 2032f90:	e0bffb17 	ldw	r2,-20(fp)
 2032f94:	10c00003 	ldbu	r3,0(r2)
 2032f98:	e0bffc17 	ldw	r2,-16(fp)
 2032f9c:	10c02445 	stb	r3,145(r2)
         tp->t_oobflags |= TCPOOB_HAVEDATA;
 2032fa0:	e0bffc17 	ldw	r2,-16(fp)
 2032fa4:	10802403 	ldbu	r2,144(r2)
 2032fa8:	10800054 	ori	r2,r2,1
 2032fac:	1007883a 	mov	r3,r2
 2032fb0:	e0bffc17 	ldw	r2,-16(fp)
 2032fb4:	10c02405 	stb	r3,144(r2)
         MEMCPY(cp, cp+1, (unsigned)(m->m_len - cnt - 1));
 2032fb8:	e0bffb17 	ldw	r2,-20(fp)
 2032fbc:	10c00044 	addi	r3,r2,1
 2032fc0:	e0bfff17 	ldw	r2,-4(fp)
 2032fc4:	11000217 	ldw	r4,8(r2)
 2032fc8:	e0bffa17 	ldw	r2,-24(fp)
 2032fcc:	2085c83a 	sub	r2,r4,r2
 2032fd0:	10bfffc4 	addi	r2,r2,-1
 2032fd4:	e13ffb17 	ldw	r4,-20(fp)
 2032fd8:	180b883a 	mov	r5,r3
 2032fdc:	100d883a 	mov	r6,r2
 2032fe0:	200660c0 	call	200660c <memcpy>
         m->m_len--;
 2032fe4:	e0bfff17 	ldw	r2,-4(fp)
 2032fe8:	10800217 	ldw	r2,8(r2)
 2032fec:	10ffffc4 	addi	r3,r2,-1
 2032ff0:	e0bfff17 	ldw	r2,-4(fp)
 2032ff4:	10c00215 	stw	r3,8(r2)
         return;
 2032ff8:	00001106 	br	2033040 <tcp_pulloutofband+0x118>
      }
      cnt -= m->m_len;
 2032ffc:	e0fffa17 	ldw	r3,-24(fp)
 2033000:	e0bfff17 	ldw	r2,-4(fp)
 2033004:	10800217 	ldw	r2,8(r2)
 2033008:	1885c83a 	sub	r2,r3,r2
 203300c:	e0bffa15 	stw	r2,-24(fp)
      m = m->m_next;
 2033010:	e0bfff17 	ldw	r2,-4(fp)
 2033014:	10800617 	ldw	r2,24(r2)
 2033018:	e0bfff15 	stw	r2,-4(fp)
      if (m == 0)
 203301c:	e0bfff17 	ldw	r2,-4(fp)
 2033020:	10000326 	beq	r2,zero,2033030 <tcp_pulloutofband+0x108>
   struct mbuf *  m)
{
   int   cnt   =  ti->ti_urp  -  1;

   /**m = dtom(ti);**/
   while (cnt >= 0) 
 2033024:	e0bffa17 	ldw	r2,-24(fp)
 2033028:	103fcc0e 	bge	r2,zero,2032f5c <tcp_pulloutofband+0x34>
 203302c:	00000106 	br	2033034 <tcp_pulloutofband+0x10c>
         return;
      }
      cnt -= m->m_len;
      m = m->m_next;
      if (m == 0)
         break;
 2033030:	0001883a 	nop
   }
   panic("tcp_pulloutofband");
 2033034:	01008174 	movhi	r4,517
 2033038:	213d7104 	addi	r4,r4,-2620
 203303c:	2026bf80 	call	2026bf8 <panic>
}
 2033040:	e037883a 	mov	sp,fp
 2033044:	dfc00117 	ldw	ra,4(sp)
 2033048:	df000017 	ldw	fp,0(sp)
 203304c:	dec00204 	addi	sp,sp,8
 2033050:	f800283a 	ret

02033054 <tcp_xmit_timer>:
 * RETURNS: 
 */

void
tcp_xmit_timer(struct tcpcb * tp)
{
 2033054:	defffb04 	addi	sp,sp,-20
 2033058:	dfc00415 	stw	ra,16(sp)
 203305c:	df000315 	stw	fp,12(sp)
 2033060:	df000304 	addi	fp,sp,12
 2033064:	e13fff15 	stw	r4,-4(fp)
   int delta;
   int rtt;

#ifdef NPDEBUG
   if(tp->t_rttick == 0){ dtrap(); return; }
 2033068:	e0bfff17 	ldw	r2,-4(fp)
 203306c:	10801e17 	ldw	r2,120(r2)
 2033070:	1000021e 	bne	r2,zero,203307c <tcp_xmit_timer+0x28>
 2033074:	20285c80 	call	20285c8 <dtrap>
 2033078:	00009306 	br	20332c8 <tcp_xmit_timer+0x274>
#endif

   tcpstat.tcps_rttupdated++;
 203307c:	00809934 	movhi	r2,612
 2033080:	10b6f504 	addi	r2,r2,-9260
 2033084:	10800717 	ldw	r2,28(r2)
 2033088:	10c00044 	addi	r3,r2,1
 203308c:	00809934 	movhi	r2,612
 2033090:	10b6f504 	addi	r2,r2,-9260
 2033094:	10c00715 	stw	r3,28(r2)

   /* get  this rtt. Convert from cticks to TCP slow ticks */
   rtt = (int)((cticks - tp->t_rttick) / (TPS/2));
 2033098:	00808174 	movhi	r2,517
 203309c:	1090c904 	addi	r2,r2,17188
 20330a0:	10c00017 	ldw	r3,0(r2)
 20330a4:	e0bfff17 	ldw	r2,-4(fp)
 20330a8:	10801e17 	ldw	r2,120(r2)
 20330ac:	1885c83a 	sub	r2,r3,r2
 20330b0:	1009883a 	mov	r4,r2
 20330b4:	20145600 	call	2014560 <__floatunsidf>
 20330b8:	100b883a 	mov	r5,r2
 20330bc:	180d883a 	mov	r6,r3
 20330c0:	2809883a 	mov	r4,r5
 20330c4:	300b883a 	mov	r5,r6
 20330c8:	000d883a 	mov	r6,zero
 20330cc:	01d01274 	movhi	r7,16457
 20330d0:	2013f6c0 	call	2013f6c <__divdf3>
 20330d4:	1009883a 	mov	r4,r2
 20330d8:	180b883a 	mov	r5,r3
 20330dc:	2005883a 	mov	r2,r4
 20330e0:	2807883a 	mov	r3,r5
 20330e4:	1009883a 	mov	r4,r2
 20330e8:	180b883a 	mov	r5,r3
 20330ec:	201442c0 	call	201442c <__fixdfsi>
 20330f0:	e0bffe15 	stw	r2,-8(fp)
   if(tp->t_srtt != 0)
 20330f4:	e0bfff17 	ldw	r2,-4(fp)
 20330f8:	10802017 	ldw	r2,128(r2)
 20330fc:	10004626 	beq	r2,zero,2033218 <tcp_xmit_timer+0x1c4>
   {
      if(rtt == 0)      /* fast path for small round trip */
 2033100:	e0bffe17 	ldw	r2,-8(fp)
 2033104:	1000131e 	bne	r2,zero,2033154 <tcp_xmit_timer+0x100>
      {
         /* if either the rtt or varience is over 1, reduce it. */
         if(tp->t_srtt > 1)
 2033108:	e0bfff17 	ldw	r2,-4(fp)
 203310c:	10802017 	ldw	r2,128(r2)
 2033110:	10800090 	cmplti	r2,r2,2
 2033114:	1000051e 	bne	r2,zero,203312c <tcp_xmit_timer+0xd8>
            tp->t_srtt--;
 2033118:	e0bfff17 	ldw	r2,-4(fp)
 203311c:	10802017 	ldw	r2,128(r2)
 2033120:	10ffffc4 	addi	r3,r2,-1
 2033124:	e0bfff17 	ldw	r2,-4(fp)
 2033128:	10c02015 	stw	r3,128(r2)
         if(tp->t_rttvar > 1)
 203312c:	e0bfff17 	ldw	r2,-4(fp)
 2033130:	10802117 	ldw	r2,132(r2)
 2033134:	10800090 	cmplti	r2,r2,2
 2033138:	1000441e 	bne	r2,zero,203324c <tcp_xmit_timer+0x1f8>
            tp->t_rttvar--;
 203313c:	e0bfff17 	ldw	r2,-4(fp)
 2033140:	10802117 	ldw	r2,132(r2)
 2033144:	10ffffc4 	addi	r3,r2,-1
 2033148:	e0bfff17 	ldw	r2,-4(fp)
 203314c:	10c02115 	stw	r3,132(r2)
 2033150:	00003e06 	br	203324c <tcp_xmit_timer+0x1f8>
       * The following magic is equivalent
       * to the smoothing algorithm in rfc793
       * with an alpha of .875
       * (srtt = rtt/8 + srtt*7/8 in fixed point).
       */
      delta = ((rtt - 1) << 2) - (int)(tp->t_srtt >> 3);
 2033154:	e0bffe17 	ldw	r2,-8(fp)
 2033158:	10bfffc4 	addi	r2,r2,-1
 203315c:	1085883a 	add	r2,r2,r2
 2033160:	1085883a 	add	r2,r2,r2
 2033164:	1007883a 	mov	r3,r2
 2033168:	e0bfff17 	ldw	r2,-4(fp)
 203316c:	10802017 	ldw	r2,128(r2)
 2033170:	1005d0fa 	srai	r2,r2,3
 2033174:	1885c83a 	sub	r2,r3,r2
 2033178:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_srtt += delta) <= 0)
 203317c:	e0bfff17 	ldw	r2,-4(fp)
 2033180:	10c02017 	ldw	r3,128(r2)
 2033184:	e0bffd17 	ldw	r2,-12(fp)
 2033188:	1887883a 	add	r3,r3,r2
 203318c:	e0bfff17 	ldw	r2,-4(fp)
 2033190:	10c02015 	stw	r3,128(r2)
 2033194:	e0bfff17 	ldw	r2,-4(fp)
 2033198:	10802017 	ldw	r2,128(r2)
 203319c:	00800316 	blt	zero,r2,20331ac <tcp_xmit_timer+0x158>
         tp->t_srtt = 1;
 20331a0:	e0bfff17 	ldw	r2,-4(fp)
 20331a4:	00c00044 	movi	r3,1
 20331a8:	10c02015 	stw	r3,128(r2)
       * (scaled by 4).  The following is equivalent
       * to rfc793 smoothing with an alpha of .75
       * (rttvar = rttvar*3/4 + |delta| / 4).
       * This replaces rfc793's wired-in beta.
       */
      if (delta < 0)
 20331ac:	e0bffd17 	ldw	r2,-12(fp)
 20331b0:	1000030e 	bge	r2,zero,20331c0 <tcp_xmit_timer+0x16c>
         delta = -delta;
 20331b4:	e0bffd17 	ldw	r2,-12(fp)
 20331b8:	0085c83a 	sub	r2,zero,r2
 20331bc:	e0bffd15 	stw	r2,-12(fp)
      delta -= (short)(tp->t_rttvar >> 1);
 20331c0:	e0bfff17 	ldw	r2,-4(fp)
 20331c4:	10802117 	ldw	r2,132(r2)
 20331c8:	1005d07a 	srai	r2,r2,1
 20331cc:	10bfffcc 	andi	r2,r2,65535
 20331d0:	10a0001c 	xori	r2,r2,32768
 20331d4:	10a00004 	addi	r2,r2,-32768
 20331d8:	e0fffd17 	ldw	r3,-12(fp)
 20331dc:	1885c83a 	sub	r2,r3,r2
 20331e0:	e0bffd15 	stw	r2,-12(fp)
      if ((tp->t_rttvar += delta) <= 0)
 20331e4:	e0bfff17 	ldw	r2,-4(fp)
 20331e8:	10c02117 	ldw	r3,132(r2)
 20331ec:	e0bffd17 	ldw	r2,-12(fp)
 20331f0:	1887883a 	add	r3,r3,r2
 20331f4:	e0bfff17 	ldw	r2,-4(fp)
 20331f8:	10c02115 	stw	r3,132(r2)
 20331fc:	e0bfff17 	ldw	r2,-4(fp)
 2033200:	10802117 	ldw	r2,132(r2)
 2033204:	00801116 	blt	zero,r2,203324c <tcp_xmit_timer+0x1f8>
         tp->t_rttvar = 1;
 2033208:	e0bfff17 	ldw	r2,-4(fp)
 203320c:	00c00044 	movi	r3,1
 2033210:	10c02115 	stw	r3,132(r2)
 2033214:	00000d06 	br	203324c <tcp_xmit_timer+0x1f8>
       * No rtt measurement yet - use the
       * unsmoothed rtt.  Set the variance
       * to half the rtt (so our first
       * retransmit happens at 2*rtt)
       */
      if(rtt < 1)
 2033218:	e0bffe17 	ldw	r2,-8(fp)
 203321c:	00800216 	blt	zero,r2,2033228 <tcp_xmit_timer+0x1d4>
         rtt = 1;
 2033220:	00800044 	movi	r2,1
 2033224:	e0bffe15 	stw	r2,-8(fp)
      tp->t_srtt = rtt << 3;
 2033228:	e0bffe17 	ldw	r2,-8(fp)
 203322c:	100690fa 	slli	r3,r2,3
 2033230:	e0bfff17 	ldw	r2,-4(fp)
 2033234:	10c02015 	stw	r3,128(r2)
      tp->t_rttvar = rtt << 1;
 2033238:	e0bffe17 	ldw	r2,-8(fp)
 203323c:	1085883a 	add	r2,r2,r2
 2033240:	1007883a 	mov	r3,r2
 2033244:	e0bfff17 	ldw	r2,-4(fp)
 2033248:	10c02115 	stw	r3,132(r2)
   }
   tp->t_rttick = 0;       /* clear RT timer */
 203324c:	e0bfff17 	ldw	r2,-4(fp)
 2033250:	10001e15 	stw	zero,120(r2)
   tp->t_rxtshift = 0;
 2033254:	e0bfff17 	ldw	r2,-4(fp)
 2033258:	10000715 	stw	zero,28(r2)
   TCPT_RANGESET(tp->t_rxtcur, 
 203325c:	e0bfff17 	ldw	r2,-4(fp)
 2033260:	10802017 	ldw	r2,128(r2)
 2033264:	1007d0ba 	srai	r3,r2,2
 2033268:	e0bfff17 	ldw	r2,-4(fp)
 203326c:	10802117 	ldw	r2,132(r2)
 2033270:	1885883a 	add	r2,r3,r2
 2033274:	1005d07a 	srai	r2,r2,1
 2033278:	10ffffcc 	andi	r3,r2,65535
 203327c:	18e0001c 	xori	r3,r3,32768
 2033280:	18e00004 	addi	r3,r3,-32768
 2033284:	e0bfff17 	ldw	r2,-4(fp)
 2033288:	10c00815 	stw	r3,32(r2)
 203328c:	e0bfff17 	ldw	r2,-4(fp)
 2033290:	10800817 	ldw	r2,32(r2)
 2033294:	10800088 	cmpgei	r2,r2,2
 2033298:	1000041e 	bne	r2,zero,20332ac <tcp_xmit_timer+0x258>
 203329c:	e0bfff17 	ldw	r2,-4(fp)
 20332a0:	00c00084 	movi	r3,2
 20332a4:	10c00815 	stw	r3,32(r2)
 20332a8:	00000706 	br	20332c8 <tcp_xmit_timer+0x274>
 20332ac:	e0bfff17 	ldw	r2,-4(fp)
 20332b0:	10800817 	ldw	r2,32(r2)
 20332b4:	10802050 	cmplti	r2,r2,129
 20332b8:	1000031e 	bne	r2,zero,20332c8 <tcp_xmit_timer+0x274>
 20332bc:	e0bfff17 	ldw	r2,-4(fp)
 20332c0:	00c02004 	movi	r3,128
 20332c4:	10c00815 	stw	r3,32(r2)
    ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1,
    TCPTV_MIN, TCPTV_REXMTMAX);
}
 20332c8:	e037883a 	mov	sp,fp
 20332cc:	dfc00117 	ldw	ra,4(sp)
 20332d0:	df000017 	ldw	fp,0(sp)
 20332d4:	dec00204 	addi	sp,sp,8
 20332d8:	f800283a 	ret

020332dc <ip4_tcpmss>:


#ifdef IP_V4
int
ip4_tcpmss(struct socket * so)
{
 20332dc:	defffd04 	addi	sp,sp,-12
 20332e0:	df000215 	stw	fp,8(sp)
 20332e4:	df000204 	addi	fp,sp,8
 20332e8:	e13fff15 	stw	r4,-4(fp)
   NET ifp;

   ifp = so->so_pcb->ifp;
 20332ec:	e0bfff17 	ldw	r2,-4(fp)
 20332f0:	10800117 	ldw	r2,4(r2)
 20332f4:	10800a17 	ldw	r2,40(r2)
 20332f8:	e0bffe15 	stw	r2,-8(fp)
   return(ifp->n_mtu - (40 + ifp->n_lnh));
 20332fc:	e0bffe17 	ldw	r2,-8(fp)
 2033300:	10c00917 	ldw	r3,36(r2)
 2033304:	e0bffe17 	ldw	r2,-8(fp)
 2033308:	10800817 	ldw	r2,32(r2)
 203330c:	013ff604 	movi	r4,-40
 2033310:	2085c83a 	sub	r2,r4,r2
 2033314:	1885883a 	add	r2,r3,r2
}
 2033318:	e037883a 	mov	sp,fp
 203331c:	df000017 	ldw	fp,0(sp)
 2033320:	dec00104 	addi	sp,sp,4
 2033324:	f800283a 	ret

02033328 <tcp_mss>:
 */


int
tcp_mss(struct socket * so)
{
 2033328:	defffa04 	addi	sp,sp,-24
 203332c:	dfc00515 	stw	ra,20(sp)
 2033330:	df000415 	stw	fp,16(sp)
 2033334:	df000404 	addi	fp,sp,16
 2033338:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 203333c:	e0bfff17 	ldw	r2,-4(fp)
 2033340:	10000726 	beq	r2,zero,2033360 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
 2033344:	e0bfff17 	ldw	r2,-4(fp)
 2033348:	10800117 	ldw	r2,4(r2)
   struct tcpcb * tp;
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
 203334c:	10000426 	beq	r2,zero,2033360 <tcp_mss+0x38>
       (so->so_pcb == NULL) ||
       (so->so_pcb->ifp == NULL))
 2033350:	e0bfff17 	ldw	r2,-4(fp)
 2033354:	10800117 	ldw	r2,4(r2)
 2033358:	10800a17 	ldw	r2,40(r2)
#ifdef IP_V6
   NET  ifp = 0;
#endif

   if ((so == NULL) ||
       (so->so_pcb == NULL) ||
 203335c:	1000061e 	bne	r2,zero,2033378 <tcp_mss+0x50>
       (so->so_pcb->ifp == NULL))
   {
      if (so->so_domain == AF_INET)  /* IPv4 */
 2033360:	e0bfff17 	ldw	r2,-4(fp)
 2033364:	10800517 	ldw	r2,20(r2)
 2033368:	10800098 	cmpnei	r2,r2,2
 203336c:	1000021e 	bne	r2,zero,2033378 <tcp_mss+0x50>
         return TCP_MSS;            /* user defined */
 2033370:	00816d04 	movi	r2,1460
 2033374:	00002506 	br	203340c <tcp_mss+0xe4>
#endif   /* IP_V6 */


#ifdef IP_V4   /* Begin messy domain defines */
#ifndef IP_V6  /* V4 only version */
   mss = ip4_tcpmss(so);
 2033378:	e13fff17 	ldw	r4,-4(fp)
 203337c:	20332dc0 	call	20332dc <ip4_tcpmss>
 2033380:	e0bffc15 	stw	r2,-16(fp)
#endif         /* end of dual mode */
#else          /* no IP_v4, assume V6 only */
      mss = ip6_tcpmss(so, ifp);
#endif         /* end messy domain defines */

   if (mss > TCP_MSS)    /* check upper limit from compile */
 2033384:	e0bffc17 	ldw	r2,-16(fp)
 2033388:	10816d50 	cmplti	r2,r2,1461
 203338c:	1000021e 	bne	r2,zero,2033398 <tcp_mss+0x70>
      mss = TCP_MSS;
 2033390:	00816d04 	movi	r2,1460
 2033394:	e0bffc15 	stw	r2,-16(fp)

   /* check upper limit which may be set by setsockopt() */
   inp = (struct inpcb *)so->so_pcb;         /* Map socket to IP cb */
 2033398:	e0bfff17 	ldw	r2,-4(fp)
 203339c:	10800117 	ldw	r2,4(r2)
 20333a0:	e0bffd15 	stw	r2,-12(fp)
   tp = (struct tcpcb *)inp->inp_ppcb;       /* Map IP to TCP cb */
 20333a4:	e0bffd17 	ldw	r2,-12(fp)
 20333a8:	10800917 	ldw	r2,36(r2)
 20333ac:	e0bffe15 	stw	r2,-8(fp)
   
   /* has user set max seg? */
   if (tp->t_flags & TF_MAXSEG)
 20333b0:	e0bffe17 	ldw	r2,-8(fp)
 20333b4:	10800b0b 	ldhu	r2,44(r2)
 20333b8:	10bfffcc 	andi	r2,r2,65535
 20333bc:	1081000c 	andi	r2,r2,1024
 20333c0:	10000426 	beq	r2,zero,20333d4 <tcp_mss+0xac>
      return tp->t_maxseg;    /* yup */
 20333c4:	e0bffe17 	ldw	r2,-8(fp)
 20333c8:	10800a0b 	ldhu	r2,40(r2)
 20333cc:	10bfffcc 	andi	r2,r2,65535
 20333d0:	00000e06 	br	203340c <tcp_mss+0xe4>
      
   if (tp->t_maxseg && (mss > tp->t_maxseg))  /* check tcp's mss */
 20333d4:	e0bffe17 	ldw	r2,-8(fp)
 20333d8:	10800a0b 	ldhu	r2,40(r2)
 20333dc:	10bfffcc 	andi	r2,r2,65535
 20333e0:	10000926 	beq	r2,zero,2033408 <tcp_mss+0xe0>
 20333e4:	e0bffe17 	ldw	r2,-8(fp)
 20333e8:	10800a0b 	ldhu	r2,40(r2)
 20333ec:	10ffffcc 	andi	r3,r2,65535
 20333f0:	e0bffc17 	ldw	r2,-16(fp)
 20333f4:	1880040e 	bge	r3,r2,2033408 <tcp_mss+0xe0>
   {
      mss = tp->t_maxseg;        /* limit new MSS to set MSS */
 20333f8:	e0bffe17 	ldw	r2,-8(fp)
 20333fc:	10800a0b 	ldhu	r2,40(r2)
 2033400:	10bfffcc 	andi	r2,r2,65535
 2033404:	e0bffc15 	stw	r2,-16(fp)
   }

   return mss;
 2033408:	e0bffc17 	ldw	r2,-16(fp)
}
 203340c:	e037883a 	mov	sp,fp
 2033410:	dfc00117 	ldw	ra,4(sp)
 2033414:	df000017 	ldw	fp,0(sp)
 2033418:	dec00204 	addi	sp,sp,8
 203341c:	f800283a 	ret

02033420 <tcp_output>:
 * RETURNS: 0 if OK, else a sockets error code.
 */

int
tcp_output(struct tcpcb * tp)
{
 2033420:	deffe804 	addi	sp,sp,-96
 2033424:	dfc01715 	stw	ra,92(sp)
 2033428:	df001615 	stw	fp,88(sp)
 203342c:	df001604 	addi	fp,sp,88
 2033430:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 2033434:	e0bfff17 	ldw	r2,-4(fp)
 2033438:	10800d17 	ldw	r2,52(r2)
 203343c:	10800817 	ldw	r2,32(r2)
 2033440:	e0bff215 	stw	r2,-56(fp)
   int   len;
   long  win;
   int   off,  flags,   error;
   struct mbuf *  m;
   struct tcpiphdr * ti;
   unsigned optlen = 0;
 2033444:	e03fee15 	stw	zero,-72(fp)
    * Determine length of data that should be transmitted,
    * and flags that will be used.
    * If there is some data or critical controls (SYN, RST)
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);
 2033448:	e0bfff17 	ldw	r2,-4(fp)
 203344c:	10c01a17 	ldw	r3,104(r2)
 2033450:	e0bfff17 	ldw	r2,-4(fp)
 2033454:	10800e17 	ldw	r2,56(r2)
 2033458:	1885003a 	cmpeq	r2,r3,r2
 203345c:	10803fcc 	andi	r2,r2,255
 2033460:	e0bff315 	stw	r2,-52(fp)
 2033464:	00000106 	br	203346c <tcp_output+0x4c>
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
   if (sendalot)
      goto again;
 2033468:	0001883a 	nop
    * to send, then transmit; otherwise, investigate further.
    */
   idle = (tp->snd_max == tp->snd_una);

again:
   sendalot = 0;
 203346c:	e03fef15 	stw	zero,-68(fp)
   off = (int)(tp->snd_nxt - tp->snd_una);
 2033470:	e0bfff17 	ldw	r2,-4(fp)
 2033474:	10c00f17 	ldw	r3,60(r2)
 2033478:	e0bfff17 	ldw	r2,-4(fp)
 203347c:	10800e17 	ldw	r2,56(r2)
 2033480:	1885c83a 	sub	r2,r3,r2
 2033484:	e0bff415 	stw	r2,-48(fp)
   win = (long)tp->snd_wnd;   /* set basic send window */
 2033488:	e0bfff17 	ldw	r2,-4(fp)
 203348c:	10801417 	ldw	r2,80(r2)
 2033490:	e0bfeb15 	stw	r2,-84(fp)
   if (win > (long)tp->snd_cwnd) /* see if we need congestion control */
 2033494:	e0bfff17 	ldw	r2,-4(fp)
 2033498:	10801b17 	ldw	r2,108(r2)
 203349c:	1007883a 	mov	r3,r2
 20334a0:	e0bfeb17 	ldw	r2,-84(fp)
 20334a4:	1880060e 	bge	r3,r2,20334c0 <tcp_output+0xa0>
   {
      win = (int)(tp->snd_cwnd & ~(ALIGN_TYPE-1)); /* keep data aligned */
 20334a8:	e0bfff17 	ldw	r2,-4(fp)
 20334ac:	10801b17 	ldw	r2,108(r2)
 20334b0:	1007883a 	mov	r3,r2
 20334b4:	00bfff04 	movi	r2,-4
 20334b8:	1884703a 	and	r2,r3,r2
 20334bc:	e0bfeb15 	stw	r2,-84(fp)
    * If in persist timeout with window of 0, send 1 byte.
    * Otherwise, if window is small but nonzero
    * and timer expired, we will send what we can
    * and go to transmit state.
    */
   if (tp->t_force) 
 20334c0:	e0bfff17 	ldw	r2,-4(fp)
 20334c4:	10800a83 	ldbu	r2,42(r2)
 20334c8:	10803fcc 	andi	r2,r2,255
 20334cc:	1080201c 	xori	r2,r2,128
 20334d0:	10bfe004 	addi	r2,r2,-128
 20334d4:	10000926 	beq	r2,zero,20334fc <tcp_output+0xdc>
   {
      if (win == 0)
 20334d8:	e0bfeb17 	ldw	r2,-84(fp)
 20334dc:	1000031e 	bne	r2,zero,20334ec <tcp_output+0xcc>
         win = 1;
 20334e0:	00800044 	movi	r2,1
 20334e4:	e0bfeb15 	stw	r2,-84(fp)
 20334e8:	00000406 	br	20334fc <tcp_output+0xdc>
      else 
      {
         tp->t_timer[TCPT_PERSIST] = 0;
 20334ec:	e0bfff17 	ldw	r2,-4(fp)
 20334f0:	10000415 	stw	zero,16(r2)
         tp->t_rxtshift = 0;
 20334f4:	e0bfff17 	ldw	r2,-4(fp)
 20334f8:	10000715 	stw	zero,28(r2)
   }
   else
#endif /* TCP_SACK */
   {
      /* set length of packets which are not sack resends */
      len = (int)MIN(so->so_snd.sb_cc, (unsigned)win) - off;
 20334fc:	e0bff217 	ldw	r2,-56(fp)
 2033500:	10801217 	ldw	r2,72(r2)
 2033504:	e0ffeb17 	ldw	r3,-84(fp)
 2033508:	1880012e 	bgeu	r3,r2,2033510 <tcp_output+0xf0>
 203350c:	1805883a 	mov	r2,r3
 2033510:	1007883a 	mov	r3,r2
 2033514:	e0bff417 	ldw	r2,-48(fp)
 2033518:	1885c83a 	sub	r2,r3,r2
 203351c:	e0bfea15 	stw	r2,-88(fp)
   }

   flags = tcp_outflags[tp->t_state];
 2033520:	e0bfff17 	ldw	r2,-4(fp)
 2033524:	10800217 	ldw	r2,8(r2)
 2033528:	00c08174 	movhi	r3,517
 203352c:	18cf0e04 	addi	r3,r3,15416
 2033530:	1885883a 	add	r2,r3,r2
 2033534:	10800003 	ldbu	r2,0(r2)
 2033538:	10803fcc 	andi	r2,r2,255
 203353c:	e0bfec15 	stw	r2,-80(fp)
   }
#else
   /* If other options not defined this build then don't bother to call bld_options() except 
    * on SYN packets
    */
   if(flags & TH_SYN)
 2033540:	e0bfec17 	ldw	r2,-80(fp)
 2033544:	1080008c 	andi	r2,r2,2
 2033548:	10000926 	beq	r2,zero,2033570 <tcp_output+0x150>
   {
      optlen = bld_options(tp, &tcp_optionbuf[optlen], flags, so);
 203354c:	e0ffee17 	ldw	r3,-72(fp)
 2033550:	d0a0aa04 	addi	r2,gp,-32088
 2033554:	1885883a 	add	r2,r3,r2
 2033558:	e13fff17 	ldw	r4,-4(fp)
 203355c:	100b883a 	mov	r5,r2
 2033560:	e1bfec17 	ldw	r6,-80(fp)
 2033564:	e1fff217 	ldw	r7,-56(fp)
 2033568:	20345380 	call	2034538 <bld_options>
 203356c:	e0bfee15 	stw	r2,-72(fp)
   }
#endif

   if (len < 0)
 2033570:	e0bfea17 	ldw	r2,-88(fp)
 2033574:	1000090e 	bge	r2,zero,203359c <tcp_output+0x17c>
       * cancel pending retransmit and pull snd_nxt
       * back to (closed) window.  We will enter persist
       * state below.  If the window didn't close completely,
       * just wait for an ACK.
       */
      len = 0;
 2033578:	e03fea15 	stw	zero,-88(fp)
      if (win == 0) 
 203357c:	e0bfeb17 	ldw	r2,-84(fp)
 2033580:	1000061e 	bne	r2,zero,203359c <tcp_output+0x17c>
      {
         tp->t_timer[TCPT_REXMT] = 0;
 2033584:	e0bfff17 	ldw	r2,-4(fp)
 2033588:	10000315 	stw	zero,12(r2)
         tp->snd_nxt = tp->snd_una;
 203358c:	e0bfff17 	ldw	r2,-4(fp)
 2033590:	10c00e17 	ldw	r3,56(r2)
 2033594:	e0bfff17 	ldw	r2,-4(fp)
 2033598:	10c00f15 	stw	r3,60(r2)
      }
   }

   if (len > (int)tp->t_maxseg)
 203359c:	e0bfff17 	ldw	r2,-4(fp)
 20335a0:	10800a0b 	ldhu	r2,40(r2)
 20335a4:	10ffffcc 	andi	r3,r2,65535
 20335a8:	e0bfea17 	ldw	r2,-88(fp)
 20335ac:	1880060e 	bge	r3,r2,20335c8 <tcp_output+0x1a8>
   {
      len = tp->t_maxseg;
 20335b0:	e0bfff17 	ldw	r2,-4(fp)
 20335b4:	10800a0b 	ldhu	r2,40(r2)
 20335b8:	10bfffcc 	andi	r2,r2,65535
 20335bc:	e0bfea15 	stw	r2,-88(fp)
      sendalot = 1;
 20335c0:	00800044 	movi	r2,1
 20335c4:	e0bfef15 	stw	r2,-68(fp)
   /* We don't need a pmtu test for IPv6. V6 code limits t_maxseg to
    * the Path MTU, so the test above the v4 ifdef above covers us.
    */
#endif /* IP_V4 */

   if (SEQ_LT(tp->snd_nxt + len, tp->snd_una + so->so_snd.sb_cc))
 20335c8:	e0bfff17 	ldw	r2,-4(fp)
 20335cc:	10c00f17 	ldw	r3,60(r2)
 20335d0:	e0bfea17 	ldw	r2,-88(fp)
 20335d4:	1887883a 	add	r3,r3,r2
 20335d8:	e0bfff17 	ldw	r2,-4(fp)
 20335dc:	11000e17 	ldw	r4,56(r2)
 20335e0:	e0bff217 	ldw	r2,-56(fp)
 20335e4:	10801217 	ldw	r2,72(r2)
 20335e8:	2085883a 	add	r2,r4,r2
 20335ec:	1885c83a 	sub	r2,r3,r2
 20335f0:	1000040e 	bge	r2,zero,2033604 <tcp_output+0x1e4>
      flags &= ~TH_FIN;
 20335f4:	e0ffec17 	ldw	r3,-80(fp)
 20335f8:	00bfff84 	movi	r2,-2
 20335fc:	1884703a 	and	r2,r3,r2
 2033600:	e0bfec15 	stw	r2,-80(fp)
   win = (long)(sbspace(&so->so_rcv));
 2033604:	e0bff217 	ldw	r2,-56(fp)
 2033608:	10800b17 	ldw	r2,44(r2)
 203360c:	1007883a 	mov	r3,r2
 2033610:	e0bff217 	ldw	r2,-56(fp)
 2033614:	10800a17 	ldw	r2,40(r2)
 2033618:	1885c83a 	sub	r2,r3,r2
 203361c:	10000616 	blt	r2,zero,2033638 <tcp_output+0x218>
 2033620:	e0bff217 	ldw	r2,-56(fp)
 2033624:	10c00b17 	ldw	r3,44(r2)
 2033628:	e0bff217 	ldw	r2,-56(fp)
 203362c:	10800a17 	ldw	r2,40(r2)
 2033630:	1885c83a 	sub	r2,r3,r2
 2033634:	00000106 	br	203363c <tcp_output+0x21c>
 2033638:	0005883a 	mov	r2,zero
 203363c:	e0bfeb15 	stw	r2,-84(fp)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 2033640:	e0bfec17 	ldw	r2,-80(fp)
 2033644:	1080004c 	andi	r2,r2,1
 2033648:	10000d26 	beq	r2,zero,2033680 <tcp_output+0x260>
       (so->so_snd.sb_cc == 0) &&
 203364c:	e0bff217 	ldw	r2,-56(fp)
 2033650:	10801217 	ldw	r2,72(r2)
   /*
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
 2033654:	10000a1e 	bne	r2,zero,2033680 <tcp_output+0x260>
       (so->so_snd.sb_cc == 0) &&
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 2033658:	e0bfff17 	ldw	r2,-4(fp)
 203365c:	10800b0b 	ldhu	r2,44(r2)
 2033660:	10bfffcc 	andi	r2,r2,65535
 2033664:	1080040c 	andi	r2,r2,16
    * If our state indicates that FIN should be sent
    * and we have not yet done so, or we're retransmitting the FIN,
    * then we need to send.
    */
   if ((flags & TH_FIN) &&
       (so->so_snd.sb_cc == 0) &&
 2033668:	10007526 	beq	r2,zero,2033840 <tcp_output+0x420>
       ((tp->t_flags & TF_SENTFIN) == 0 || tp->snd_nxt == tp->snd_una))
 203366c:	e0bfff17 	ldw	r2,-4(fp)
 2033670:	10c00f17 	ldw	r3,60(r2)
 2033674:	e0bfff17 	ldw	r2,-4(fp)
 2033678:	10800e17 	ldw	r2,56(r2)
 203367c:	18807026 	beq	r3,r2,2033840 <tcp_output+0x420>
      goto send;
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
 2033680:	e0bfff17 	ldw	r2,-4(fp)
 2033684:	10800b0b 	ldhu	r2,44(r2)
 2033688:	10bfffcc 	andi	r2,r2,65535
 203368c:	1080004c 	andi	r2,r2,1
 2033690:	1000581e 	bne	r2,zero,20337f4 <tcp_output+0x3d4>
      goto send;
   if (flags & (TH_SYN|TH_RST))
 2033694:	e0bfec17 	ldw	r2,-80(fp)
 2033698:	1080018c 	andi	r2,r2,6
 203369c:	1000571e 	bne	r2,zero,20337fc <tcp_output+0x3dc>
      goto send;
   if (SEQ_GT(tp->snd_up, tp->snd_una))
 20336a0:	e0bfff17 	ldw	r2,-4(fp)
 20336a4:	10c01017 	ldw	r3,64(r2)
 20336a8:	e0bfff17 	ldw	r2,-4(fp)
 20336ac:	10800e17 	ldw	r2,56(r2)
 20336b0:	1885c83a 	sub	r2,r3,r2
 20336b4:	00805316 	blt	zero,r2,2033804 <tcp_output+0x3e4>
    * If peer's buffer is tiny, then send
    * when window is at least half open.
    * If retransmitting (possibly after persist timer forced us
    * to send into a small window), then must resend.
    */
   if (len)
 20336b8:	e0bfea17 	ldw	r2,-88(fp)
 20336bc:	10002326 	beq	r2,zero,203374c <tcp_output+0x32c>
   {
      if (len == (int)tp->t_maxseg)
 20336c0:	e0bfff17 	ldw	r2,-4(fp)
 20336c4:	10800a0b 	ldhu	r2,40(r2)
 20336c8:	10ffffcc 	andi	r3,r2,65535
 20336cc:	e0bfea17 	ldw	r2,-88(fp)
 20336d0:	18804e26 	beq	r3,r2,203380c <tcp_output+0x3ec>
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 20336d4:	e0bff317 	ldw	r2,-52(fp)
 20336d8:	1000051e 	bne	r2,zero,20336f0 <tcp_output+0x2d0>
 20336dc:	e0bfff17 	ldw	r2,-4(fp)
 20336e0:	10800b0b 	ldhu	r2,44(r2)
 20336e4:	10bfffcc 	andi	r2,r2,65535
 20336e8:	1080010c 	andi	r2,r2,4
 20336ec:	10000626 	beq	r2,zero,2033708 <tcp_output+0x2e8>
          len + off >= (int)so->so_snd.sb_cc)
 20336f0:	e0ffea17 	ldw	r3,-88(fp)
 20336f4:	e0bff417 	ldw	r2,-48(fp)
 20336f8:	1887883a 	add	r3,r3,r2
 20336fc:	e0bff217 	ldw	r2,-56(fp)
 2033700:	10801217 	ldw	r2,72(r2)
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
      if ((idle || tp->t_flags & TF_NODELAY) &&
 2033704:	1880430e 	bge	r3,r2,2033814 <tcp_output+0x3f4>
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
      }
      if (tp->t_force)
 2033708:	e0bfff17 	ldw	r2,-4(fp)
 203370c:	10800a83 	ldbu	r2,42(r2)
 2033710:	10803fcc 	andi	r2,r2,255
 2033714:	1080201c 	xori	r2,r2,128
 2033718:	10bfe004 	addi	r2,r2,-128
 203371c:	10003f1e 	bne	r2,zero,203381c <tcp_output+0x3fc>
         goto send;
      if (len >= (int)(tp->max_sndwnd / 2))
 2033720:	e0bfff17 	ldw	r2,-4(fp)
 2033724:	10802317 	ldw	r2,140(r2)
 2033728:	1004d07a 	srli	r2,r2,1
 203372c:	e0ffea17 	ldw	r3,-88(fp)
 2033730:	18803c0e 	bge	r3,r2,2033824 <tcp_output+0x404>
         goto send;
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
 2033734:	e0bfff17 	ldw	r2,-4(fp)
 2033738:	10c00f17 	ldw	r3,60(r2)
 203373c:	e0bfff17 	ldw	r2,-4(fp)
 2033740:	10801a17 	ldw	r2,104(r2)
 2033744:	1885c83a 	sub	r2,r3,r2
 2033748:	10003816 	blt	r2,zero,203382c <tcp_output+0x40c>
    * known to peer (as advertised window less
    * next expected input).  If the difference is at least two
    * max size segments or at least 35% of the maximum possible
    * window, then want to send a window update to peer.
    */
   if (win > 0)
 203374c:	e0bfeb17 	ldw	r2,-84(fp)
 2033750:	0080190e 	bge	zero,r2,20337b8 <tcp_output+0x398>
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);
 2033754:	e0bfff17 	ldw	r2,-4(fp)
 2033758:	10c01617 	ldw	r3,88(r2)
 203375c:	e0bfff17 	ldw	r2,-4(fp)
 2033760:	10801917 	ldw	r2,100(r2)
 2033764:	1885c83a 	sub	r2,r3,r2
 2033768:	1007883a 	mov	r3,r2
 203376c:	e0bfeb17 	ldw	r2,-84(fp)
 2033770:	1885883a 	add	r2,r3,r2
 2033774:	e0bff515 	stw	r2,-44(fp)

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
 2033778:	e0bff217 	ldw	r2,-56(fp)
 203377c:	10800a17 	ldw	r2,40(r2)
 2033780:	1000061e 	bne	r2,zero,203379c <tcp_output+0x37c>
 2033784:	e0bfff17 	ldw	r2,-4(fp)
 2033788:	10800a0b 	ldhu	r2,40(r2)
 203378c:	10bfffcc 	andi	r2,r2,65535
 2033790:	1085883a 	add	r2,r2,r2
 2033794:	e0fff517 	ldw	r3,-44(fp)
 2033798:	1880260e 	bge	r3,r2,2033834 <tcp_output+0x414>
         goto send;
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
 203379c:	e0bff517 	ldw	r2,-44(fp)
 20337a0:	10c01924 	muli	r3,r2,100
 20337a4:	e0bff217 	ldw	r2,-56(fp)
 20337a8:	10800b17 	ldw	r2,44(r2)
 20337ac:	1885203a 	divu	r2,r3,r2
 20337b0:	108008f0 	cmpltui	r2,r2,35
 20337b4:	10002126 	beq	r2,zero,203383c <tcp_output+0x41c>
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 20337b8:	e0bff217 	ldw	r2,-56(fp)
 20337bc:	10801217 	ldw	r2,72(r2)
 20337c0:	10000a26 	beq	r2,zero,20337ec <tcp_output+0x3cc>
 20337c4:	e0bfff17 	ldw	r2,-4(fp)
 20337c8:	10800317 	ldw	r2,12(r2)
 20337cc:	1000071e 	bne	r2,zero,20337ec <tcp_output+0x3cc>
       tp->t_timer[TCPT_PERSIST] == 0) 
 20337d0:	e0bfff17 	ldw	r2,-4(fp)
 20337d4:	10800417 	ldw	r2,16(r2)
    * retransmit or persist is pending, then go to persist state.
    * If nothing happens soon, send when timer expires:
    * if window is nonzero, transmit what we can,
    * otherwise force out a byte.
    */
   if (so->so_snd.sb_cc && tp->t_timer[TCPT_REXMT] == 0 &&
 20337d8:	1000041e 	bne	r2,zero,20337ec <tcp_output+0x3cc>
       tp->t_timer[TCPT_PERSIST] == 0) 
   {
      tp->t_rxtshift = 0;
 20337dc:	e0bfff17 	ldw	r2,-4(fp)
 20337e0:	10000715 	stw	zero,28(r2)
      tcp_setpersist(tp);
 20337e4:	e13fff17 	ldw	r4,-4(fp)
 20337e8:	203443c0 	call	203443c <tcp_setpersist>
   }

   /*
    * No reason to send a segment, just return.
    */
   return (0);
 20337ec:	0005883a 	mov	r2,zero
 20337f0:	00030d06 	br	2034428 <tcp_output+0x1008>
   }
   /*
    * Send if we owe peer an ACK.
    */
   if (tp->t_flags & TF_ACKNOW)
      goto send;
 20337f4:	0001883a 	nop
 20337f8:	00001106 	br	2033840 <tcp_output+0x420>
   if (flags & (TH_SYN|TH_RST))
      goto send;
 20337fc:	0001883a 	nop
 2033800:	00000f06 	br	2033840 <tcp_output+0x420>
   if (SEQ_GT(tp->snd_up, tp->snd_una))
      goto send;
 2033804:	0001883a 	nop
 2033808:	00000d06 	br	2033840 <tcp_output+0x420>
    * to send into a small window), then must resend.
    */
   if (len)
   {
      if (len == (int)tp->t_maxseg)
         goto send;
 203380c:	0001883a 	nop
 2033810:	00000b06 	br	2033840 <tcp_output+0x420>
      if ((idle || tp->t_flags & TF_NODELAY) &&
          len + off >= (int)so->so_snd.sb_cc)
      {
         goto send;
 2033814:	0001883a 	nop
 2033818:	00000906 	br	2033840 <tcp_output+0x420>
      }
      if (tp->t_force)
         goto send;
 203381c:	0001883a 	nop
 2033820:	00000706 	br	2033840 <tcp_output+0x420>
      if (len >= (int)(tp->max_sndwnd / 2))
         goto send;
 2033824:	0001883a 	nop
 2033828:	00000506 	br	2033840 <tcp_output+0x420>
      if (SEQ_LT(tp->snd_nxt, tp->snd_max))
         goto send;
 203382c:	0001883a 	nop
 2033830:	00000306 	br	2033840 <tcp_output+0x420>
   if (win > 0)
   {
      int   adv   =  (int)win -  (int)(tp->rcv_adv -  tp->rcv_nxt);

      if (so->so_rcv.sb_cc == 0 && adv >= (int)(tp->t_maxseg * 2))
         goto send;
 2033834:	0001883a 	nop
 2033838:	00000106 	br	2033840 <tcp_output+0x420>
      if (100 * (u_int)adv / so->so_rcv.sb_hiwat >= 35)
         goto send;
 203383c:	0001883a 	nop
    * No reason to send a segment, just return.
    */
   return (0);

send:
   ENTER_CRIT_SECTION(tp);
 2033840:	20287fc0 	call	20287fc <irq_Mask>

   /* Limit send length to the current buffer so as to
    * avoid doing the "mbuf shuffle" in m_copy().
    */
   bufoff = off;
 2033844:	e0bff417 	ldw	r2,-48(fp)
 2033848:	e0bff115 	stw	r2,-60(fp)
   sendm = so->so_snd.sb_mb;
 203384c:	e0bff217 	ldw	r2,-56(fp)
 2033850:	10801817 	ldw	r2,96(r2)
 2033854:	e0bff015 	stw	r2,-64(fp)
   if (len)
 2033858:	e0bfea17 	ldw	r2,-88(fp)
 203385c:	10005926 	beq	r2,zero,20339c4 <tcp_output+0x5a4>
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 2033860:	00000a06 	br	203388c <tcp_output+0x46c>
      {
         bufoff -= sendm->m_len;
 2033864:	e0fff117 	ldw	r3,-60(fp)
 2033868:	e0bff017 	ldw	r2,-64(fp)
 203386c:	10800217 	ldw	r2,8(r2)
 2033870:	1885c83a 	sub	r2,r3,r2
 2033874:	e0bff115 	stw	r2,-60(fp)
         if (bufoff < 0)   /* if off is in this buffer, break */
 2033878:	e0bff117 	ldw	r2,-60(fp)
 203387c:	10000616 	blt	r2,zero,2033898 <tcp_output+0x478>
            break;
         sendm = sendm->m_next;
 2033880:	e0bff017 	ldw	r2,-64(fp)
 2033884:	10800617 	ldw	r2,24(r2)
 2033888:	e0bff015 	stw	r2,-64(fp)
   bufoff = off;
   sendm = so->so_snd.sb_mb;
   if (len)
   {
      /* find mbuf containing data to send (at "off") */
      while (sendm)  /* loop through socket send list */
 203388c:	e0bff017 	ldw	r2,-64(fp)
 2033890:	103ff41e 	bne	r2,zero,2033864 <tcp_output+0x444>
 2033894:	00000106 	br	203389c <tcp_output+0x47c>
      {
         bufoff -= sendm->m_len;
         if (bufoff < 0)   /* if off is in this buffer, break */
            break;
 2033898:	0001883a 	nop
         sendm = sendm->m_next;
      }
      if (!sendm) { dtrap();  /* shouldn't happen */ }
 203389c:	e0bff017 	ldw	r2,-64(fp)
 20338a0:	1000011e 	bne	r2,zero,20338a8 <tcp_output+0x488>
 20338a4:	20285c80 	call	20285c8 <dtrap>
      bufoff += sendm->m_len; /* index to next data to send in msend */
 20338a8:	e0bff017 	ldw	r2,-64(fp)
 20338ac:	10c00217 	ldw	r3,8(r2)
 20338b0:	e0bff117 	ldw	r2,-60(fp)
 20338b4:	1885883a 	add	r2,r3,r2
 20338b8:	e0bff115 	stw	r2,-60(fp)

      /* if socket has multiple unsent mbufs, set flag for send to loop */
      if ((sendm->m_next) && (len > (int)sendm->m_len))
 20338bc:	e0bff017 	ldw	r2,-64(fp)
 20338c0:	10800617 	ldw	r2,24(r2)
 20338c4:	10000b26 	beq	r2,zero,20338f4 <tcp_output+0x4d4>
 20338c8:	e0bff017 	ldw	r2,-64(fp)
 20338cc:	10800217 	ldw	r2,8(r2)
 20338d0:	1007883a 	mov	r3,r2
 20338d4:	e0bfea17 	ldw	r2,-88(fp)
 20338d8:	1880060e 	bge	r3,r2,20338f4 <tcp_output+0x4d4>
      {
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 20338dc:	e0ffec17 	ldw	r3,-80(fp)
 20338e0:	00bfff84 	movi	r2,-2
 20338e4:	1884703a 	and	r2,r3,r2
 20338e8:	e0bfec15 	stw	r2,-80(fp)
         sendalot = 1;     /* set to send more segments */
 20338ec:	00800044 	movi	r2,1
 20338f0:	e0bfef15 	stw	r2,-68(fp)
      }
      if((flags & TH_FIN) && (so->so_snd.sb_cc > (unsigned)len))
 20338f4:	e0bfec17 	ldw	r2,-80(fp)
 20338f8:	1080004c 	andi	r2,r2,1
 20338fc:	10000826 	beq	r2,zero,2033920 <tcp_output+0x500>
 2033900:	e0bff217 	ldw	r2,-56(fp)
 2033904:	10801217 	ldw	r2,72(r2)
 2033908:	e0ffea17 	ldw	r3,-88(fp)
 203390c:	1880042e 	bgeu	r3,r2,2033920 <tcp_output+0x500>
      {
         /* This can happen on slow links (PPP) which retry the last 
          * segment - the one with the FIN bit attached to data.
          */
         flags &= ~TH_FIN; /* don't FIN on segment prior to last */
 2033910:	e0ffec17 	ldw	r3,-80(fp)
 2033914:	00bfff84 	movi	r2,-2
 2033918:	1884703a 	and	r2,r3,r2
 203391c:	e0bfec15 	stw	r2,-80(fp)
      }

      /* only send the rest of msend */
      len = min(len, (int)sendm->m_len);
 2033920:	e0bff017 	ldw	r2,-64(fp)
 2033924:	10800217 	ldw	r2,8(r2)
 2033928:	e0ffea17 	ldw	r3,-88(fp)
 203392c:	1880010e 	bge	r3,r2,2033934 <tcp_output+0x514>
 2033930:	1805883a 	mov	r2,r3
 2033934:	e0bfea15 	stw	r2,-88(fp)
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 2033938:	e0bff117 	ldw	r2,-60(fp)
 203393c:	1000081e 	bne	r2,zero,2033960 <tcp_output+0x540>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
 2033940:	e0bff017 	ldw	r2,-64(fp)
 2033944:	10800317 	ldw	r2,12(r2)
 2033948:	1007883a 	mov	r3,r2
 203394c:	e0bff017 	ldw	r2,-64(fp)
 2033950:	10800417 	ldw	r2,16(r2)
 2033954:	1885c83a 	sub	r2,r3,r2
 2033958:	108000cc 	andi	r2,r2,3
       * Similarly, if sendm->m_data is not aligned with respect to 
       * sendm->m_base and ALIGN_TYPE, we will copy the data to 
       * ensure that it (and the then-prepended IP/TCP headers) will 
       * be aligned according to ALIGN_TYPE. 
       */
      if ((bufoff != 0) ||       /* data not front aligned in send mbuf? */
 203395c:	10001926 	beq	r2,zero,20339c4 <tcp_output+0x5a4>
          (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) != 0))
      {
         len = min(len, (int)(sendm->m_len - bufoff));   /* limit len again */
 2033960:	e0bff017 	ldw	r2,-64(fp)
 2033964:	10c00217 	ldw	r3,8(r2)
 2033968:	e0bff117 	ldw	r2,-60(fp)
 203396c:	1885c83a 	sub	r2,r3,r2
 2033970:	e0ffea17 	ldw	r3,-88(fp)
 2033974:	1880010e 	bge	r3,r2,203397c <tcp_output+0x55c>
 2033978:	1805883a 	mov	r2,r3
 203397c:	e0bfea15 	stw	r2,-88(fp)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 2033980:	00808174 	movhi	r2,517
 2033984:	10906704 	addi	r2,r2,16796
 2033988:	10800017 	ldw	r2,0(r2)
 203398c:	10bff204 	addi	r2,r2,-56
 2033990:	1007883a 	mov	r3,r2
 2033994:	e0bfea17 	ldw	r2,-88(fp)
 2033998:	18800a0e 	bge	r3,r2,20339c4 <tcp_output+0x5a4>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
 203399c:	00809934 	movhi	r2,612
 20339a0:	10b62c04 	addi	r2,r2,-10064
 20339a4:	10800217 	ldw	r2,8(r2)
          * of the m_data buffer then we can't use it in place, else we
          * might write the IP/TCP header over data that has not yet
          * been acked. In this case we must make sure our send
          * fits into a little buffer and send what we can.
          */
         if ((len > (int)(lilbufsiz - HDRSLEN)) && /* length is bigger the small buffer? */
 20339a8:	10800088 	cmpgei	r2,r2,2
 20339ac:	1000051e 	bne	r2,zero,20339c4 <tcp_output+0x5a4>
             (bigfreeq.q_len < 2))      /* and we are low on big buffers */
         {
            len = lilbufsiz - HDRSLEN;
 20339b0:	00808174 	movhi	r2,517
 20339b4:	10906704 	addi	r2,r2,16796
 20339b8:	10800017 	ldw	r2,0(r2)
 20339bc:	10bff204 	addi	r2,r2,-56
 20339c0:	e0bfea15 	stw	r2,-88(fp)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 20339c4:	e0bfea17 	ldw	r2,-88(fp)
 20339c8:	10003626 	beq	r2,zero,2033aa4 <tcp_output+0x684>
 20339cc:	e0bff117 	ldw	r2,-60(fp)
 20339d0:	1000341e 	bne	r2,zero,2033aa4 <tcp_output+0x684>
       (sendm->pkt->inuse == 1) &&
 20339d4:	e0bff017 	ldw	r2,-64(fp)
 20339d8:	10800117 	ldw	r2,4(r2)
 20339dc:	10800917 	ldw	r2,36(r2)
   }

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
 20339e0:	10800058 	cmpnei	r2,r2,1
 20339e4:	10002f1e 	bne	r2,zero,2033aa4 <tcp_output+0x684>
       (sendm->pkt->inuse == 1) &&
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 20339e8:	e0bff017 	ldw	r2,-64(fp)
 20339ec:	10800317 	ldw	r2,12(r2)
 20339f0:	1007883a 	mov	r3,r2
 20339f4:	e0bff017 	ldw	r2,-64(fp)
 20339f8:	10800417 	ldw	r2,16(r2)
 20339fc:	1885c83a 	sub	r2,r3,r2
 2033a00:	108000cc 	andi	r2,r2,3

   /* if send data is sufficiently aligned in packet, prepend TCP/IP header
    * in the space provided. 
    */
   if (len && (bufoff == 0) && 
       (sendm->pkt->inuse == 1) &&
 2033a04:	1000271e 	bne	r2,zero,2033aa4 <tcp_output+0x684>
       (((sendm->m_data - sendm->m_base) & (ALIGN_TYPE - 1)) == 0) && 
 2033a08:	e0bfee17 	ldw	r2,-72(fp)
 2033a0c:	1000251e 	bne	r2,zero,2033aa4 <tcp_output+0x684>
       (optlen == 0))
   {
      /* get an empty mbuf to "clone" the data */
      m = m_getnbuf(MT_TXDATA, 0);
 2033a10:	01000084 	movi	r4,2
 2033a14:	000b883a 	mov	r5,zero
 2033a18:	20293d80 	call	20293d8 <m_getnbuf>
 2033a1c:	e0bfed15 	stw	r2,-76(fp)
      if (!m)
 2033a20:	e0bfed17 	ldw	r2,-76(fp)
 2033a24:	1000031e 	bne	r2,zero,2033a34 <tcp_output+0x614>
      {
         EXIT_CRIT_SECTION(tp);
 2033a28:	20288580 	call	2028858 <irq_Unmask>
         return (ENOBUFS);
 2033a2c:	00801a44 	movi	r2,105
 2033a30:	00027d06 	br	2034428 <tcp_output+0x1008>
      }
      m->pkt = sendm->pkt; /* copy packet location in new mbuf */
 2033a34:	e0bff017 	ldw	r2,-64(fp)
 2033a38:	10c00117 	ldw	r3,4(r2)
 2033a3c:	e0bfed17 	ldw	r2,-76(fp)
 2033a40:	10c00115 	stw	r3,4(r2)
      m->pkt->inuse++;     /* bump packet's use count */
 2033a44:	e0bfed17 	ldw	r2,-76(fp)
 2033a48:	10800117 	ldw	r2,4(r2)
 2033a4c:	10c00917 	ldw	r3,36(r2)
 2033a50:	18c00044 	addi	r3,r3,1
 2033a54:	10c00915 	stw	r3,36(r2)
      m->m_base = sendm->m_base; /* clone mbuf members */
 2033a58:	e0bff017 	ldw	r2,-64(fp)
 2033a5c:	10c00417 	ldw	r3,16(r2)
 2033a60:	e0bfed17 	ldw	r2,-76(fp)
 2033a64:	10c00415 	stw	r3,16(r2)
      m->m_memsz = sendm->m_memsz;
 2033a68:	e0bff017 	ldw	r2,-64(fp)
 2033a6c:	10c00517 	ldw	r3,20(r2)
 2033a70:	e0bfed17 	ldw	r2,-76(fp)
 2033a74:	10c00515 	stw	r3,20(r2)
      m->m_len = len + TCPIPHDRSZ;  /* adjust clone for header */
 2033a78:	e0bfea17 	ldw	r2,-88(fp)
 2033a7c:	10800a04 	addi	r2,r2,40
 2033a80:	1007883a 	mov	r3,r2
 2033a84:	e0bfed17 	ldw	r2,-76(fp)
 2033a88:	10c00215 	stw	r3,8(r2)
      m->m_data = sendm->m_data - TCPIPHDRSZ;
 2033a8c:	e0bff017 	ldw	r2,-64(fp)
 2033a90:	10800317 	ldw	r2,12(r2)
 2033a94:	10fff604 	addi	r3,r2,-40
 2033a98:	e0bfed17 	ldw	r2,-76(fp)
 2033a9c:	10c00315 	stw	r3,12(r2)
 2033aa0:	00002a06 	br	2033b4c <tcp_output+0x72c>
   {
      /* Grab a header mbuf, attaching a copy of data to be 
       * transmitted, and initialize the header from 
       * the template for sends on this connection.
       */
      m = m_getwithdata (MT_HEADER, IFNETHDR_SIZE + TCPIPHDRSZ);
 2033aa4:	00808174 	movhi	r2,517
 2033aa8:	1090b004 	addi	r2,r2,17088
 2033aac:	10800017 	ldw	r2,0(r2)
 2033ab0:	10800a04 	addi	r2,r2,40
 2033ab4:	010000c4 	movi	r4,3
 2033ab8:	100b883a 	mov	r5,r2
 2033abc:	20293d80 	call	20293d8 <m_getnbuf>
 2033ac0:	e0bfed15 	stw	r2,-76(fp)
      if (m ==(struct mbuf *)NULL)
 2033ac4:	e0bfed17 	ldw	r2,-76(fp)
 2033ac8:	1000031e 	bne	r2,zero,2033ad8 <tcp_output+0x6b8>
      {
         EXIT_CRIT_SECTION(tp);
 2033acc:	20288580 	call	2028858 <irq_Unmask>
         return ENOBUFS;
 2033ad0:	00801a44 	movi	r2,105
 2033ad4:	00025406 	br	2034428 <tcp_output+0x1008>
      }

      m->m_len = TCPIPHDRSZ;
 2033ad8:	e0bfed17 	ldw	r2,-76(fp)
 2033adc:	00c00a04 	movi	r3,40
 2033ae0:	10c00215 	stw	r3,8(r2)
      m->m_data += IFNETHDR_SIZE;/* Move this to sizeof tcpip hdr leave*/
 2033ae4:	e0bfed17 	ldw	r2,-76(fp)
 2033ae8:	10c00317 	ldw	r3,12(r2)
 2033aec:	00808174 	movhi	r2,517
 2033af0:	1090b004 	addi	r2,r2,17088
 2033af4:	10800017 	ldw	r2,0(r2)
 2033af8:	1887883a 	add	r3,r3,r2
 2033afc:	e0bfed17 	ldw	r2,-76(fp)
 2033b00:	10c00315 	stw	r3,12(r2)
      /* 14 bytes for ethernet header      */

      if (len) /* attach any data to send */
 2033b04:	e0bfea17 	ldw	r2,-88(fp)
 2033b08:	10001026 	beq	r2,zero,2033b4c <tcp_output+0x72c>
      {
         m->m_next = m_copy(so->so_snd.sb_mb, off, (int) len);
 2033b0c:	e0bff217 	ldw	r2,-56(fp)
 2033b10:	10801817 	ldw	r2,96(r2)
 2033b14:	1009883a 	mov	r4,r2
 2033b18:	e17ff417 	ldw	r5,-48(fp)
 2033b1c:	e1bfea17 	ldw	r6,-88(fp)
 2033b20:	20296b80 	call	20296b8 <m_copy>
 2033b24:	e0ffed17 	ldw	r3,-76(fp)
 2033b28:	18800615 	stw	r2,24(r3)
         if (m->m_next == 0)
 2033b2c:	e0bfed17 	ldw	r2,-76(fp)
 2033b30:	10800617 	ldw	r2,24(r2)
 2033b34:	1000051e 	bne	r2,zero,2033b4c <tcp_output+0x72c>
         {
            m_freem(m);
 2033b38:	e13fed17 	ldw	r4,-76(fp)
 2033b3c:	20296780 	call	2029678 <m_freem>
            EXIT_CRIT_SECTION(tp);
 2033b40:	20288580 	call	2028858 <irq_Unmask>
            return ENOBUFS;
 2033b44:	00801a44 	movi	r2,105
 2033b48:	00023706 	br	2034428 <tcp_output+0x1008>
         }
      }
   }
   EXIT_CRIT_SECTION(tp);
 2033b4c:	20288580 	call	2028858 <irq_Unmask>

   if (len) 
 2033b50:	e0bfea17 	ldw	r2,-88(fp)
 2033b54:	10003726 	beq	r2,zero,2033c34 <tcp_output+0x814>
   {
      if (tp->t_force && len == 1)
 2033b58:	e0bfff17 	ldw	r2,-4(fp)
 2033b5c:	10800a83 	ldbu	r2,42(r2)
 2033b60:	10803fcc 	andi	r2,r2,255
 2033b64:	1080201c 	xori	r2,r2,128
 2033b68:	10bfe004 	addi	r2,r2,-128
 2033b6c:	10000b26 	beq	r2,zero,2033b9c <tcp_output+0x77c>
 2033b70:	e0bfea17 	ldw	r2,-88(fp)
 2033b74:	10800058 	cmpnei	r2,r2,1
 2033b78:	1000081e 	bne	r2,zero,2033b9c <tcp_output+0x77c>
         tcpstat.tcps_sndprobe++;
 2033b7c:	00809934 	movhi	r2,612
 2033b80:	10b6f504 	addi	r2,r2,-9260
 2033b84:	10801517 	ldw	r2,84(r2)
 2033b88:	10c00044 	addi	r3,r2,1
 2033b8c:	00809934 	movhi	r2,612
 2033b90:	10b6f504 	addi	r2,r2,-9260
 2033b94:	10c01515 	stw	r3,84(r2)
 2033b98:	00005306 	br	2033ce8 <tcp_output+0x8c8>
      else if (SEQ_LT(tp->snd_nxt, tp->snd_max)) 
 2033b9c:	e0bfff17 	ldw	r2,-4(fp)
 2033ba0:	10c00f17 	ldw	r3,60(r2)
 2033ba4:	e0bfff17 	ldw	r2,-4(fp)
 2033ba8:	10801a17 	ldw	r2,104(r2)
 2033bac:	1885c83a 	sub	r2,r3,r2
 2033bb0:	1000100e 	bge	r2,zero,2033bf4 <tcp_output+0x7d4>
      {
         tcpstat.tcps_sndrexmitpack++;
 2033bb4:	00809934 	movhi	r2,612
 2033bb8:	10b6f504 	addi	r2,r2,-9260
 2033bbc:	10801217 	ldw	r2,72(r2)
 2033bc0:	10c00044 	addi	r3,r2,1
 2033bc4:	00809934 	movhi	r2,612
 2033bc8:	10b6f504 	addi	r2,r2,-9260
 2033bcc:	10c01215 	stw	r3,72(r2)
         tcpstat.tcps_sndrexmitbyte += len;
 2033bd0:	00809934 	movhi	r2,612
 2033bd4:	10b6f504 	addi	r2,r2,-9260
 2033bd8:	10c01317 	ldw	r3,76(r2)
 2033bdc:	e0bfea17 	ldw	r2,-88(fp)
 2033be0:	1887883a 	add	r3,r3,r2
 2033be4:	00809934 	movhi	r2,612
 2033be8:	10b6f504 	addi	r2,r2,-9260
 2033bec:	10c01315 	stw	r3,76(r2)
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
         tcpstat.tcps_sndbyte += len;
 2033bf0:	00003d06 	br	2033ce8 <tcp_output+0x8c8>
         tcpstat.tcps_sackresend++;
#endif
      } 
      else 
      {
         tcpstat.tcps_sndpack++;
 2033bf4:	00809934 	movhi	r2,612
 2033bf8:	10b6f504 	addi	r2,r2,-9260
 2033bfc:	10801017 	ldw	r2,64(r2)
 2033c00:	10c00044 	addi	r3,r2,1
 2033c04:	00809934 	movhi	r2,612
 2033c08:	10b6f504 	addi	r2,r2,-9260
 2033c0c:	10c01015 	stw	r3,64(r2)
         tcpstat.tcps_sndbyte += len;
 2033c10:	00809934 	movhi	r2,612
 2033c14:	10b6f504 	addi	r2,r2,-9260
 2033c18:	10c01117 	ldw	r3,68(r2)
 2033c1c:	e0bfea17 	ldw	r2,-88(fp)
 2033c20:	1887883a 	add	r3,r3,r2
 2033c24:	00809934 	movhi	r2,612
 2033c28:	10b6f504 	addi	r2,r2,-9260
 2033c2c:	10c01115 	stw	r3,68(r2)
 2033c30:	00002d06 	br	2033ce8 <tcp_output+0x8c8>
      }
   }
   else if (tp->t_flags & TF_ACKNOW)
 2033c34:	e0bfff17 	ldw	r2,-4(fp)
 2033c38:	10800b0b 	ldhu	r2,44(r2)
 2033c3c:	10bfffcc 	andi	r2,r2,65535
 2033c40:	1080004c 	andi	r2,r2,1
 2033c44:	10000826 	beq	r2,zero,2033c68 <tcp_output+0x848>
   {
      tcpstat.tcps_sndacks++;
 2033c48:	00809934 	movhi	r2,612
 2033c4c:	10b6f504 	addi	r2,r2,-9260
 2033c50:	10801417 	ldw	r2,80(r2)
 2033c54:	10c00044 	addi	r3,r2,1
 2033c58:	00809934 	movhi	r2,612
 2033c5c:	10b6f504 	addi	r2,r2,-9260
 2033c60:	10c01415 	stw	r3,80(r2)
 2033c64:	00002006 	br	2033ce8 <tcp_output+0x8c8>
   }
   else if (flags & (TH_SYN|TH_FIN|TH_RST))
 2033c68:	e0bfec17 	ldw	r2,-80(fp)
 2033c6c:	108001cc 	andi	r2,r2,7
 2033c70:	10000826 	beq	r2,zero,2033c94 <tcp_output+0x874>
      tcpstat.tcps_sndctrl++;
 2033c74:	00809934 	movhi	r2,612
 2033c78:	10b6f504 	addi	r2,r2,-9260
 2033c7c:	10801817 	ldw	r2,96(r2)
 2033c80:	10c00044 	addi	r3,r2,1
 2033c84:	00809934 	movhi	r2,612
 2033c88:	10b6f504 	addi	r2,r2,-9260
 2033c8c:	10c01815 	stw	r3,96(r2)
 2033c90:	00001506 	br	2033ce8 <tcp_output+0x8c8>
   else if (SEQ_GT(tp->snd_up, tp->snd_una))
 2033c94:	e0bfff17 	ldw	r2,-4(fp)
 2033c98:	10c01017 	ldw	r3,64(r2)
 2033c9c:	e0bfff17 	ldw	r2,-4(fp)
 2033ca0:	10800e17 	ldw	r2,56(r2)
 2033ca4:	1885c83a 	sub	r2,r3,r2
 2033ca8:	0080080e 	bge	zero,r2,2033ccc <tcp_output+0x8ac>
      tcpstat.tcps_sndurg++;
 2033cac:	00809934 	movhi	r2,612
 2033cb0:	10b6f504 	addi	r2,r2,-9260
 2033cb4:	10801617 	ldw	r2,88(r2)
 2033cb8:	10c00044 	addi	r3,r2,1
 2033cbc:	00809934 	movhi	r2,612
 2033cc0:	10b6f504 	addi	r2,r2,-9260
 2033cc4:	10c01615 	stw	r3,88(r2)
 2033cc8:	00000706 	br	2033ce8 <tcp_output+0x8c8>
   else
      tcpstat.tcps_sndwinup++;
 2033ccc:	00809934 	movhi	r2,612
 2033cd0:	10b6f504 	addi	r2,r2,-9260
 2033cd4:	10801717 	ldw	r2,92(r2)
 2033cd8:	10c00044 	addi	r3,r2,1
 2033cdc:	00809934 	movhi	r2,612
 2033ce0:	10b6f504 	addi	r2,r2,-9260
 2033ce4:	10c01715 	stw	r3,92(r2)

   ti = (struct tcpiphdr *)(m->m_data+sizeof(struct ip)-sizeof(struct ipovly));
 2033ce8:	e0bfed17 	ldw	r2,-76(fp)
 2033cec:	10800317 	ldw	r2,12(r2)
 2033cf0:	e0bff615 	stw	r2,-40(fp)
   if ((char *)ti < m->pkt->nb_buff)
 2033cf4:	e0bfed17 	ldw	r2,-76(fp)
 2033cf8:	10800117 	ldw	r2,4(r2)
 2033cfc:	10800117 	ldw	r2,4(r2)
 2033d00:	e0fff617 	ldw	r3,-40(fp)
 2033d04:	1880032e 	bgeu	r3,r2,2033d14 <tcp_output+0x8f4>
   {
      panic("tcp_out- packet ptr underflow\n");
 2033d08:	01008174 	movhi	r4,517
 2033d0c:	213d7604 	addi	r4,r4,-2600
 2033d10:	2026bf80 	call	2026bf8 <panic>
   }
   tcp_mbuf = m;        /* flag TCP header mbuf */
 2033d14:	e0bfed17 	ldw	r2,-76(fp)
 2033d18:	e0bff715 	stw	r2,-36(fp)
      tcp_mbuf->m_data += sizeof(struct ipovly);
      tcp_mbuf->m_len -= sizeof(struct ipovly);
   }
#endif   /* end IP_V6 */

   if (tp->t_template == 0)
 2033d1c:	e0bfff17 	ldw	r2,-4(fp)
 2033d20:	10800c17 	ldw	r2,48(r2)
 2033d24:	1000031e 	bne	r2,zero,2033d34 <tcp_output+0x914>
      panic("tcp_output");
 2033d28:	01008174 	movhi	r4,517
 2033d2c:	213d7e04 	addi	r4,r4,-2568
 2033d30:	2026bf80 	call	2026bf8 <panic>

   MEMCPY((char*)ti, (char*)tp->t_template, sizeof(struct tcpiphdr));
 2033d34:	e0bfff17 	ldw	r2,-4(fp)
 2033d38:	10800c17 	ldw	r2,48(r2)
 2033d3c:	e13ff617 	ldw	r4,-40(fp)
 2033d40:	100b883a 	mov	r5,r2
 2033d44:	01800a04 	movi	r6,40
 2033d48:	200660c0 	call	200660c <memcpy>
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 2033d4c:	e0bfec17 	ldw	r2,-80(fp)
 2033d50:	1080004c 	andi	r2,r2,1
 2033d54:	10000f26 	beq	r2,zero,2033d94 <tcp_output+0x974>
 2033d58:	e0bfff17 	ldw	r2,-4(fp)
 2033d5c:	10800b0b 	ldhu	r2,44(r2)
 2033d60:	10bfffcc 	andi	r2,r2,65535
 2033d64:	1080040c 	andi	r2,r2,16
 2033d68:	10000a26 	beq	r2,zero,2033d94 <tcp_output+0x974>
       tp->snd_nxt == tp->snd_max)
 2033d6c:	e0bfff17 	ldw	r2,-4(fp)
 2033d70:	10c00f17 	ldw	r3,60(r2)
 2033d74:	e0bfff17 	ldw	r2,-4(fp)
 2033d78:	10801a17 	ldw	r2,104(r2)
   /*
    * Fill in fields, remembering maximum advertised
    * window for use in delaying messages about window sizes.
    * If resending a FIN, be sure not to use a new sequence number.
    */
   if (flags & TH_FIN && tp->t_flags & TF_SENTFIN && 
 2033d7c:	1880051e 	bne	r3,r2,2033d94 <tcp_output+0x974>
       tp->snd_nxt == tp->snd_max)
   {
      tp->snd_nxt--;
 2033d80:	e0bfff17 	ldw	r2,-4(fp)
 2033d84:	10800f17 	ldw	r2,60(r2)
 2033d88:	10ffffc4 	addi	r3,r2,-1
 2033d8c:	e0bfff17 	ldw	r2,-4(fp)
 2033d90:	10c00f15 	stw	r3,60(r2)
   }

   ti->ti_seq = htonl(tp->snd_nxt);
 2033d94:	e0bfff17 	ldw	r2,-4(fp)
 2033d98:	10800f17 	ldw	r2,60(r2)
 2033d9c:	1006d63a 	srli	r3,r2,24
 2033da0:	e0bfff17 	ldw	r2,-4(fp)
 2033da4:	10800f17 	ldw	r2,60(r2)
 2033da8:	1004d23a 	srli	r2,r2,8
 2033dac:	10bfc00c 	andi	r2,r2,65280
 2033db0:	1886b03a 	or	r3,r3,r2
 2033db4:	e0bfff17 	ldw	r2,-4(fp)
 2033db8:	10800f17 	ldw	r2,60(r2)
 2033dbc:	10bfc00c 	andi	r2,r2,65280
 2033dc0:	1004923a 	slli	r2,r2,8
 2033dc4:	1886b03a 	or	r3,r3,r2
 2033dc8:	e0bfff17 	ldw	r2,-4(fp)
 2033dcc:	10800f17 	ldw	r2,60(r2)
 2033dd0:	1004963a 	slli	r2,r2,24
 2033dd4:	1886b03a 	or	r3,r3,r2
 2033dd8:	e0bff617 	ldw	r2,-40(fp)
 2033ddc:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(tp->rcv_nxt);
 2033de0:	e0bfff17 	ldw	r2,-4(fp)
 2033de4:	10801617 	ldw	r2,88(r2)
 2033de8:	1006d63a 	srli	r3,r2,24
 2033dec:	e0bfff17 	ldw	r2,-4(fp)
 2033df0:	10801617 	ldw	r2,88(r2)
 2033df4:	1004d23a 	srli	r2,r2,8
 2033df8:	10bfc00c 	andi	r2,r2,65280
 2033dfc:	1886b03a 	or	r3,r3,r2
 2033e00:	e0bfff17 	ldw	r2,-4(fp)
 2033e04:	10801617 	ldw	r2,88(r2)
 2033e08:	10bfc00c 	andi	r2,r2,65280
 2033e0c:	1004923a 	slli	r2,r2,8
 2033e10:	1886b03a 	or	r3,r3,r2
 2033e14:	e0bfff17 	ldw	r2,-4(fp)
 2033e18:	10801617 	ldw	r2,88(r2)
 2033e1c:	1004963a 	slli	r2,r2,24
 2033e20:	1886b03a 	or	r3,r3,r2
 2033e24:	e0bff617 	ldw	r2,-40(fp)
 2033e28:	10c00715 	stw	r3,28(r2)
    * a retransmission, and the original SYN caused PPP to start
    * bringing the interface up, and PPP has got a new IP address
    * via IPCP), update the template and the inpcb with the new 
    * address.
    */
   if (flags & TH_SYN)
 2033e2c:	e0bfec17 	ldw	r2,-80(fp)
 2033e30:	1080008c 	andi	r2,r2,2
 2033e34:	10002226 	beq	r2,zero,2033ec0 <tcp_output+0xaa0>
   {
      struct inpcb * inp;
      inp = (struct inpcb *)so->so_pcb;
 2033e38:	e0bff217 	ldw	r2,-56(fp)
 2033e3c:	10800117 	ldw	r2,4(r2)
 2033e40:	e0bff815 	stw	r2,-32(fp)

      switch(so->so_domain)
 2033e44:	e0bff217 	ldw	r2,-56(fp)
 2033e48:	10800517 	ldw	r2,20(r2)
 2033e4c:	108000a0 	cmpeqi	r2,r2,2
 2033e50:	10001a26 	beq	r2,zero,2033ebc <tcp_output+0xa9c>
         }
         }
#endif   /* INCLUDE_PPP */

         /* If this is a SYN (not a SYN/ACK) then set the pmtu */
         if((flags & TH_ACK) == 0)
 2033e54:	e0bfec17 	ldw	r2,-80(fp)
 2033e58:	1080040c 	andi	r2,r2,16
 2033e5c:	1000181e 	bne	r2,zero,2033ec0 <tcp_output+0xaa0>
            inp->inp_pmtu = pmtucache_get(inp->inp_faddr.s_addr);
#else    /* not compiled for pathmtu, guess based on iface */
            {
               NET ifp;
               /* find iface for route. Pass "src" as nexthop return */
               ifp = iproute(ti->ti_dst.s_addr, &src);
 2033e60:	e0bff617 	ldw	r2,-40(fp)
 2033e64:	10c00417 	ldw	r3,16(r2)
 2033e68:	e0bffe04 	addi	r2,fp,-8
 2033e6c:	1809883a 	mov	r4,r3
 2033e70:	100b883a 	mov	r5,r2
 2033e74:	20410e40 	call	20410e4 <iproute>
 2033e78:	e0bff915 	stw	r2,-28(fp)
               if(ifp)
 2033e7c:	e0bff917 	ldw	r2,-28(fp)
 2033e80:	10000a26 	beq	r2,zero,2033eac <tcp_output+0xa8c>
                  inp->inp_pmtu = ifp->n_mtu - (ifp->n_lnh + 40);
 2033e84:	e0bff917 	ldw	r2,-28(fp)
 2033e88:	10c00917 	ldw	r3,36(r2)
 2033e8c:	e0bff917 	ldw	r2,-28(fp)
 2033e90:	10800817 	ldw	r2,32(r2)
 2033e94:	013ff604 	movi	r4,-40
 2033e98:	2085c83a 	sub	r2,r4,r2
 2033e9c:	1887883a 	add	r3,r3,r2
 2033ea0:	e0bff817 	ldw	r2,-32(fp)
 2033ea4:	10c00615 	stw	r3,24(r2)
 2033ea8:	00000506 	br	2033ec0 <tcp_output+0xaa0>
               else
                  inp->inp_pmtu = 580;  /* Ugh. */
 2033eac:	e0bff817 	ldw	r2,-32(fp)
 2033eb0:	00c09104 	movi	r3,580
 2033eb4:	10c00615 	stw	r3,24(r2)
 2033eb8:	00000106 	br	2033ec0 <tcp_output+0xaa0>
         }
         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();    /* bad domain setting */
 2033ebc:	20285c80 	call	20285c8 <dtrap>
      }
   }

   /* fill in options if any are set */
   if (optlen)
 2033ec0:	e0bfee17 	ldw	r2,-72(fp)
 2033ec4:	10002c26 	beq	r2,zero,2033f78 <tcp_output+0xb58>
   {
      struct mbuf * mopt;

      mopt = m_getwithdata(MT_TXDATA, MAXOPTLEN);
 2033ec8:	01000084 	movi	r4,2
 2033ecc:	01404004 	movi	r5,256
 2033ed0:	20293d80 	call	20293d8 <m_getnbuf>
 2033ed4:	e0bffa15 	stw	r2,-24(fp)
      if (mopt == NULL) 
 2033ed8:	e0bffa17 	ldw	r2,-24(fp)
 2033edc:	1000041e 	bne	r2,zero,2033ef0 <tcp_output+0xad0>
      {
         m_freem(m);
 2033ee0:	e13fed17 	ldw	r4,-76(fp)
 2033ee4:	20296780 	call	2029678 <m_freem>
         return (ENOBUFS);
 2033ee8:	00801a44 	movi	r2,105
 2033eec:	00014e06 	br	2034428 <tcp_output+0x1008>
      }

      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
 2033ef0:	e0bff717 	ldw	r2,-36(fp)
 2033ef4:	10c00617 	ldw	r3,24(r2)
 2033ef8:	e0bffa17 	ldw	r2,-24(fp)
 2033efc:	10c00615 	stw	r3,24(r2)
      tcp_mbuf->m_next = mopt;
 2033f00:	e0bff717 	ldw	r2,-36(fp)
 2033f04:	e0fffa17 	ldw	r3,-24(fp)
 2033f08:	10c00615 	stw	r3,24(r2)

      /* extend options to aligned address */
      while(optlen & 0x03)
 2033f0c:	00000706 	br	2033f2c <tcp_output+0xb0c>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;
 2033f10:	e0ffee17 	ldw	r3,-72(fp)
 2033f14:	d0a0aa04 	addi	r2,gp,-32088
 2033f18:	1885883a 	add	r2,r3,r2
 2033f1c:	10000005 	stb	zero,0(r2)
 2033f20:	e0bfee17 	ldw	r2,-72(fp)
 2033f24:	10800044 	addi	r2,r2,1
 2033f28:	e0bfee15 	stw	r2,-72(fp)
      /* insert options mbuf after after tmp_mbuf */
      mopt->m_next = tcp_mbuf->m_next;
      tcp_mbuf->m_next = mopt;

      /* extend options to aligned address */
      while(optlen & 0x03)
 2033f2c:	e0bfee17 	ldw	r2,-72(fp)
 2033f30:	108000cc 	andi	r2,r2,3
 2033f34:	103ff61e 	bne	r2,zero,2033f10 <tcp_output+0xaf0>
         tcp_optionbuf[optlen++] = TCPOPT_EOL;

      MEMCPY(mtod(mopt, char *), tcp_optionbuf, optlen);
 2033f38:	e0bffa17 	ldw	r2,-24(fp)
 2033f3c:	10800317 	ldw	r2,12(r2)
 2033f40:	1009883a 	mov	r4,r2
 2033f44:	d160aa04 	addi	r5,gp,-32088
 2033f48:	e1bfee17 	ldw	r6,-72(fp)
 2033f4c:	200660c0 	call	200660c <memcpy>
      mopt->m_len = optlen;
 2033f50:	e0bffa17 	ldw	r2,-24(fp)
 2033f54:	e0ffee17 	ldw	r3,-72(fp)
 2033f58:	10c00215 	stw	r3,8(r2)
      /* use portable macro to set tcp data offset bits */
      SET_TH_OFF(ti->ti_t, ((sizeof (struct tcphdr) + optlen) >> 2));
 2033f5c:	e0bfee17 	ldw	r2,-72(fp)
 2033f60:	10800504 	addi	r2,r2,20
 2033f64:	1004d0ba 	srli	r2,r2,2
 2033f68:	1004913a 	slli	r2,r2,4
 2033f6c:	1007883a 	mov	r3,r2
 2033f70:	e0bff617 	ldw	r2,-40(fp)
 2033f74:	10c00805 	stb	r3,32(r2)
   }

   ti->ti_flags = (u_char)flags;
 2033f78:	e0bfec17 	ldw	r2,-80(fp)
 2033f7c:	1007883a 	mov	r3,r2
 2033f80:	e0bff617 	ldw	r2,-40(fp)
 2033f84:	10c00845 	stb	r3,33(r2)
   /*
    * Calculate receive window. Don't shrink window,
    * but avoid silly window syndrome.
    */
   if (win < (long)(so->so_rcv.sb_hiwat / 4) && win < (long)tp->t_maxseg)
 2033f88:	e0bff217 	ldw	r2,-56(fp)
 2033f8c:	10800b17 	ldw	r2,44(r2)
 2033f90:	1004d0ba 	srli	r2,r2,2
 2033f94:	e0ffeb17 	ldw	r3,-84(fp)
 2033f98:	1880060e 	bge	r3,r2,2033fb4 <tcp_output+0xb94>
 2033f9c:	e0bfff17 	ldw	r2,-4(fp)
 2033fa0:	10800a0b 	ldhu	r2,40(r2)
 2033fa4:	10bfffcc 	andi	r2,r2,65535
 2033fa8:	e0ffeb17 	ldw	r3,-84(fp)
 2033fac:	1880010e 	bge	r3,r2,2033fb4 <tcp_output+0xb94>
      win = 0;
 2033fb0:	e03feb15 	stw	zero,-84(fp)
   if (win < (long)(tp->rcv_adv - tp->rcv_nxt))
 2033fb4:	e0bfff17 	ldw	r2,-4(fp)
 2033fb8:	10c01917 	ldw	r3,100(r2)
 2033fbc:	e0bfff17 	ldw	r2,-4(fp)
 2033fc0:	10801617 	ldw	r2,88(r2)
 2033fc4:	1885c83a 	sub	r2,r3,r2
 2033fc8:	e0ffeb17 	ldw	r3,-84(fp)
 2033fcc:	1880060e 	bge	r3,r2,2033fe8 <tcp_output+0xbc8>
      win = (long)(tp->rcv_adv - tp->rcv_nxt);
 2033fd0:	e0bfff17 	ldw	r2,-4(fp)
 2033fd4:	10c01917 	ldw	r3,100(r2)
 2033fd8:	e0bfff17 	ldw	r2,-4(fp)
 2033fdc:	10801617 	ldw	r2,88(r2)
 2033fe0:	1885c83a 	sub	r2,r3,r2
 2033fe4:	e0bfeb15 	stw	r2,-84(fp)

   /* do check for Iniche buffer limits -JB- */
   if (bigfreeq.q_len == 0)   /* If queue length is 0, set window to 0 */
 2033fe8:	00809934 	movhi	r2,612
 2033fec:	10b62c04 	addi	r2,r2,-10064
 2033ff0:	10800217 	ldw	r2,8(r2)
 2033ff4:	1000021e 	bne	r2,zero,2034000 <tcp_output+0xbe0>
   {
      win = 0;
 2033ff8:	e03feb15 	stw	zero,-84(fp)
 2033ffc:	00001406 	br	2034050 <tcp_output+0xc30>
   }
   else if(win > (((long)bigfreeq.q_len - 1) * (long)bigbufsiz))
 2034000:	00809934 	movhi	r2,612
 2034004:	10b62c04 	addi	r2,r2,-10064
 2034008:	10800217 	ldw	r2,8(r2)
 203400c:	10ffffc4 	addi	r3,r2,-1
 2034010:	00808174 	movhi	r2,517
 2034014:	10906904 	addi	r2,r2,16804
 2034018:	10800017 	ldw	r2,0(r2)
 203401c:	1887383a 	mul	r3,r3,r2
 2034020:	e0bfeb17 	ldw	r2,-84(fp)
 2034024:	18800a0e 	bge	r3,r2,2034050 <tcp_output+0xc30>
   {
      win = ((long)bigfreeq.q_len - 1) * bigbufsiz;
 2034028:	00809934 	movhi	r2,612
 203402c:	10b62c04 	addi	r2,r2,-10064
 2034030:	10800217 	ldw	r2,8(r2)
 2034034:	10bfffc4 	addi	r2,r2,-1
 2034038:	1007883a 	mov	r3,r2
 203403c:	00808174 	movhi	r2,517
 2034040:	10906904 	addi	r2,r2,16804
 2034044:	10800017 	ldw	r2,0(r2)
 2034048:	1885383a 	mul	r2,r3,r2
 203404c:	e0bfeb15 	stw	r2,-84(fp)
      ti->ti_win = htons((u_short)(win >> tp->rcv_wind_scale)); /* apply scale */
   }
   else
#endif /* TCP_WIN_SCALE */
   {
      ti->ti_win = htons((u_short)win);
 2034050:	e0bfeb17 	ldw	r2,-84(fp)
 2034054:	10bfffcc 	andi	r2,r2,65535
 2034058:	1004d23a 	srli	r2,r2,8
 203405c:	1007883a 	mov	r3,r2
 2034060:	e0bfeb17 	ldw	r2,-84(fp)
 2034064:	10bfffcc 	andi	r2,r2,65535
 2034068:	1004923a 	slli	r2,r2,8
 203406c:	1884b03a 	or	r2,r3,r2
 2034070:	1007883a 	mov	r3,r2
 2034074:	e0bff617 	ldw	r2,-40(fp)
 2034078:	10c0088d 	sth	r3,34(r2)
   }

   if (SEQ_GT(tp->snd_up, tp->snd_nxt)) 
 203407c:	e0bfff17 	ldw	r2,-4(fp)
 2034080:	10c01017 	ldw	r3,64(r2)
 2034084:	e0bfff17 	ldw	r2,-4(fp)
 2034088:	10800f17 	ldw	r2,60(r2)
 203408c:	1885c83a 	sub	r2,r3,r2
 2034090:	00801c0e 	bge	zero,r2,2034104 <tcp_output+0xce4>
   {
      ti->ti_urp = htons((u_short)(tp->snd_up - tp->snd_nxt));
 2034094:	e0bfff17 	ldw	r2,-4(fp)
 2034098:	10801017 	ldw	r2,64(r2)
 203409c:	1007883a 	mov	r3,r2
 20340a0:	e0bfff17 	ldw	r2,-4(fp)
 20340a4:	10800f17 	ldw	r2,60(r2)
 20340a8:	1885c83a 	sub	r2,r3,r2
 20340ac:	10bfffcc 	andi	r2,r2,65535
 20340b0:	1004d23a 	srli	r2,r2,8
 20340b4:	1007883a 	mov	r3,r2
 20340b8:	e0bfff17 	ldw	r2,-4(fp)
 20340bc:	10801017 	ldw	r2,64(r2)
 20340c0:	1009883a 	mov	r4,r2
 20340c4:	e0bfff17 	ldw	r2,-4(fp)
 20340c8:	10800f17 	ldw	r2,60(r2)
 20340cc:	2085c83a 	sub	r2,r4,r2
 20340d0:	10bfffcc 	andi	r2,r2,65535
 20340d4:	1004923a 	slli	r2,r2,8
 20340d8:	1884b03a 	or	r2,r3,r2
 20340dc:	1007883a 	mov	r3,r2
 20340e0:	e0bff617 	ldw	r2,-40(fp)
 20340e4:	10c0098d 	sth	r3,38(r2)
      ti->ti_flags |= TH_URG;
 20340e8:	e0bff617 	ldw	r2,-40(fp)
 20340ec:	10800843 	ldbu	r2,33(r2)
 20340f0:	10800814 	ori	r2,r2,32
 20340f4:	1007883a 	mov	r3,r2
 20340f8:	e0bff617 	ldw	r2,-40(fp)
 20340fc:	10c00845 	stb	r3,33(r2)
 2034100:	00000406 	br	2034114 <tcp_output+0xcf4>
       * If no urgent pointer to send, then we pull
       * the urgent pointer to the left edge of the send window
       * so that it doesn't drift into the send window on sequence
       * number wraparound.
       */
      tp->snd_up = tp->snd_una;        /* drag it along */
 2034104:	e0bfff17 	ldw	r2,-4(fp)
 2034108:	10c00e17 	ldw	r3,56(r2)
 203410c:	e0bfff17 	ldw	r2,-4(fp)
 2034110:	10c01015 	stw	r3,64(r2)
   /*
    * If anything to send and we can send it all, set PUSH.
    * (This will keep happy those implementations which only
    * give data to the user when a buffer fills or a PUSH comes in.)
    */
   if (len && off+len == (int)so->so_snd.sb_cc)
 2034114:	e0bfea17 	ldw	r2,-88(fp)
 2034118:	10000c26 	beq	r2,zero,203414c <tcp_output+0xd2c>
 203411c:	e0fff417 	ldw	r3,-48(fp)
 2034120:	e0bfea17 	ldw	r2,-88(fp)
 2034124:	1887883a 	add	r3,r3,r2
 2034128:	e0bff217 	ldw	r2,-56(fp)
 203412c:	10801217 	ldw	r2,72(r2)
 2034130:	1880061e 	bne	r3,r2,203414c <tcp_output+0xd2c>
      ti->ti_flags |= TH_PUSH;
 2034134:	e0bff617 	ldw	r2,-40(fp)
 2034138:	10800843 	ldbu	r2,33(r2)
 203413c:	10800214 	ori	r2,r2,8
 2034140:	1007883a 	mov	r3,r2
 2034144:	e0bff617 	ldw	r2,-40(fp)
 2034148:	10c00845 	stb	r3,33(r2)

   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
 203414c:	e0bfff17 	ldw	r2,-4(fp)
 2034150:	10800a83 	ldbu	r2,42(r2)
 2034154:	10803fcc 	andi	r2,r2,255
 2034158:	1080201c 	xori	r2,r2,128
 203415c:	10bfe004 	addi	r2,r2,-128
 2034160:	10000326 	beq	r2,zero,2034170 <tcp_output+0xd50>
 2034164:	e0bfff17 	ldw	r2,-4(fp)
 2034168:	10800417 	ldw	r2,16(r2)
 203416c:	10004f1e 	bne	r2,zero,20342ac <tcp_output+0xe8c>
   {
      tcp_seq startseq = tp->snd_nxt;
 2034170:	e0bfff17 	ldw	r2,-4(fp)
 2034174:	10800f17 	ldw	r2,60(r2)
 2034178:	e0bffb15 	stw	r2,-20(fp)

      /*
       * Advance snd_nxt over sequence space of this segment.
       */
      if (flags & TH_SYN)
 203417c:	e0bfec17 	ldw	r2,-80(fp)
 2034180:	1080008c 	andi	r2,r2,2
 2034184:	10000526 	beq	r2,zero,203419c <tcp_output+0xd7c>
         tp->snd_nxt++;
 2034188:	e0bfff17 	ldw	r2,-4(fp)
 203418c:	10800f17 	ldw	r2,60(r2)
 2034190:	10c00044 	addi	r3,r2,1
 2034194:	e0bfff17 	ldw	r2,-4(fp)
 2034198:	10c00f15 	stw	r3,60(r2)

      if (flags & TH_FIN)
 203419c:	e0bfec17 	ldw	r2,-80(fp)
 20341a0:	1080004c 	andi	r2,r2,1
 20341a4:	10000b26 	beq	r2,zero,20341d4 <tcp_output+0xdb4>
      {
         tp->snd_nxt++;
 20341a8:	e0bfff17 	ldw	r2,-4(fp)
 20341ac:	10800f17 	ldw	r2,60(r2)
 20341b0:	10c00044 	addi	r3,r2,1
 20341b4:	e0bfff17 	ldw	r2,-4(fp)
 20341b8:	10c00f15 	stw	r3,60(r2)
         tp->t_flags |= TF_SENTFIN;
 20341bc:	e0bfff17 	ldw	r2,-4(fp)
 20341c0:	10800b0b 	ldhu	r2,44(r2)
 20341c4:	10800414 	ori	r2,r2,16
 20341c8:	1007883a 	mov	r3,r2
 20341cc:	e0bfff17 	ldw	r2,-4(fp)
 20341d0:	10c00b0d 	sth	r3,44(r2)
      }
      tp->snd_nxt += len;
 20341d4:	e0bfff17 	ldw	r2,-4(fp)
 20341d8:	10c00f17 	ldw	r3,60(r2)
 20341dc:	e0bfea17 	ldw	r2,-88(fp)
 20341e0:	1887883a 	add	r3,r3,r2
 20341e4:	e0bfff17 	ldw	r2,-4(fp)
 20341e8:	10c00f15 	stw	r3,60(r2)
      if (SEQ_GT(tp->snd_nxt, tp->snd_max)) 
 20341ec:	e0bfff17 	ldw	r2,-4(fp)
 20341f0:	10c00f17 	ldw	r3,60(r2)
 20341f4:	e0bfff17 	ldw	r2,-4(fp)
 20341f8:	10801a17 	ldw	r2,104(r2)
 20341fc:	1885c83a 	sub	r2,r3,r2
 2034200:	0080160e 	bge	zero,r2,203425c <tcp_output+0xe3c>
      {
         tp->snd_max = tp->snd_nxt;
 2034204:	e0bfff17 	ldw	r2,-4(fp)
 2034208:	10c00f17 	ldw	r3,60(r2)
 203420c:	e0bfff17 	ldw	r2,-4(fp)
 2034210:	10c01a15 	stw	r3,104(r2)
         /*
          * Time this transmission if not a retransmission and
          * not currently timing anything.
          */
         if (tp->t_rttick == 0) 
 2034214:	e0bfff17 	ldw	r2,-4(fp)
 2034218:	10801e17 	ldw	r2,120(r2)
 203421c:	10000f1e 	bne	r2,zero,203425c <tcp_output+0xe3c>
         {
            tp->t_rttick = cticks;
 2034220:	00808174 	movhi	r2,517
 2034224:	1090c904 	addi	r2,r2,17188
 2034228:	10c00017 	ldw	r3,0(r2)
 203422c:	e0bfff17 	ldw	r2,-4(fp)
 2034230:	10c01e15 	stw	r3,120(r2)
            tp->t_rtseq = startseq;
 2034234:	e0bfff17 	ldw	r2,-4(fp)
 2034238:	e0fffb17 	ldw	r3,-20(fp)
 203423c:	10c01f15 	stw	r3,124(r2)
            tcpstat.tcps_segstimed++;
 2034240:	00809934 	movhi	r2,612
 2034244:	10b6f504 	addi	r2,r2,-9260
 2034248:	10800617 	ldw	r2,24(r2)
 203424c:	10c00044 	addi	r3,r2,1
 2034250:	00809934 	movhi	r2,612
 2034254:	10b6f504 	addi	r2,r2,-9260
 2034258:	10c00615 	stw	r3,24(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 203425c:	e0bfff17 	ldw	r2,-4(fp)
 2034260:	10800317 	ldw	r2,12(r2)
 2034264:	1000201e 	bne	r2,zero,20342e8 <tcp_output+0xec8>
          tp->snd_nxt != tp->snd_una) 
 2034268:	e0bfff17 	ldw	r2,-4(fp)
 203426c:	10c00f17 	ldw	r3,60(r2)
 2034270:	e0bfff17 	ldw	r2,-4(fp)
 2034274:	10800e17 	ldw	r2,56(r2)
       * Initial value for retransmit timer is smoothed
       * round-trip time + 2 * round-trip time variance.
       * Initialize shift counter which is used for backoff
       * of retransmit time.
       */
      if (tp->t_timer[TCPT_REXMT] == 0 &&
 2034278:	18801b26 	beq	r3,r2,20342e8 <tcp_output+0xec8>
          tp->snd_nxt != tp->snd_una) 
      {
         tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 203427c:	e0bfff17 	ldw	r2,-4(fp)
 2034280:	10c00817 	ldw	r3,32(r2)
 2034284:	e0bfff17 	ldw	r2,-4(fp)
 2034288:	10c00315 	stw	r3,12(r2)
         if (tp->t_timer[TCPT_PERSIST]) 
 203428c:	e0bfff17 	ldw	r2,-4(fp)
 2034290:	10800417 	ldw	r2,16(r2)
 2034294:	10001426 	beq	r2,zero,20342e8 <tcp_output+0xec8>
         {
            tp->t_timer[TCPT_PERSIST] = 0;
 2034298:	e0bfff17 	ldw	r2,-4(fp)
 203429c:	10000415 	stw	zero,16(r2)
            tp->t_rxtshift = 0;
 20342a0:	e0bfff17 	ldw	r2,-4(fp)
 20342a4:	10000715 	stw	zero,28(r2)
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 20342a8:	00000f06 	br	20342e8 <tcp_output+0xec8>
         }
      }
   }
   else
   {
      if (SEQ_GT(tp->snd_nxt + len, tp->snd_max))
 20342ac:	e0bfff17 	ldw	r2,-4(fp)
 20342b0:	10c00f17 	ldw	r3,60(r2)
 20342b4:	e0bfea17 	ldw	r2,-88(fp)
 20342b8:	1887883a 	add	r3,r3,r2
 20342bc:	e0bfff17 	ldw	r2,-4(fp)
 20342c0:	10801a17 	ldw	r2,104(r2)
 20342c4:	1885c83a 	sub	r2,r3,r2
 20342c8:	0080080e 	bge	zero,r2,20342ec <tcp_output+0xecc>
         tp->snd_max = tp->snd_nxt + len;
 20342cc:	e0bfff17 	ldw	r2,-4(fp)
 20342d0:	10c00f17 	ldw	r3,60(r2)
 20342d4:	e0bfea17 	ldw	r2,-88(fp)
 20342d8:	1887883a 	add	r3,r3,r2
 20342dc:	e0bfff17 	ldw	r2,-4(fp)
 20342e0:	10c01a15 	stw	r3,104(r2)
 20342e4:	00000106 	br	20342ec <tcp_output+0xecc>
   /*
    * In transmit state, time the transmission and arrange for
    * the retransmit.  In persist state, just set snd_max.
    */
   if (tp->t_force == 0 || tp->t_timer[TCPT_PERSIST] == 0) 
   {
 20342e8:	0001883a 	nop
   tcp_trace("tcp_output: sending, state %d, tcpcb: %x",
    tp->t_state, tp );
#endif

#ifdef MUTE_WARNS
   error = 0;
 20342ec:	e03ffc15 	stw	zero,-16(fp)
   if(so->so_domain != AF_INET6)
#endif   /* IP_V6 */
   {
      struct ip * pip;
   
      pip = mtod(m, struct ip *);
 20342f0:	e0bfed17 	ldw	r2,-76(fp)
 20342f4:	10800317 	ldw	r2,12(r2)
 20342f8:	e0bffd15 	stw	r2,-12(fp)
      /* Fill in IP length and send to IP level. */
      pip->ip_len = (u_short)(TCPIPHDRSZ + optlen + len);
 20342fc:	e0bfee17 	ldw	r2,-72(fp)
 2034300:	1007883a 	mov	r3,r2
 2034304:	e0bfea17 	ldw	r2,-88(fp)
 2034308:	1885883a 	add	r2,r3,r2
 203430c:	10800a04 	addi	r2,r2,40
 2034310:	1007883a 	mov	r3,r2
 2034314:	e0bffd17 	ldw	r2,-12(fp)
 2034318:	10c0008d 	sth	r3,2(r2)
      error = ip_output(m, so->so_optsPack);
 203431c:	e0bff217 	ldw	r2,-56(fp)
 2034320:	10801f17 	ldw	r2,124(r2)
 2034324:	e13fed17 	ldw	r4,-76(fp)
 2034328:	100b883a 	mov	r5,r2
 203432c:	202a01c0 	call	202a01c <ip_output>
 2034330:	e0bffc15 	stw	r2,-16(fp)
                    (sizeof(struct ipv6) + sizeof(struct tcphdr) + optlen + len),
                    (struct   ip_socopts *)0);          
   }
#endif   /* IP_V6 */

   if (error)
 2034334:	e0bffc17 	ldw	r2,-16(fp)
 2034338:	10001326 	beq	r2,zero,2034388 <tcp_output+0xf68>
   {
      if (error == ENOBUFS)   /* ip_output needed a copy buffer it couldn't get */
 203433c:	e0bffc17 	ldw	r2,-16(fp)
 2034340:	10801a58 	cmpnei	r2,r2,105
 2034344:	10000e1e 	bne	r2,zero,2034380 <tcp_output+0xf60>
      {
         if (m->m_type == MT_FREE)  /* ip_output() probably freed first mbuf */
 2034348:	e0bfed17 	ldw	r2,-76(fp)
 203434c:	10800817 	ldw	r2,32(r2)
 2034350:	1000031e 	bne	r2,zero,2034360 <tcp_output+0xf40>
            m = m->m_next;
 2034354:	e0bfed17 	ldw	r2,-76(fp)
 2034358:	10800617 	ldw	r2,24(r2)
 203435c:	e0bfed15 	stw	r2,-76(fp)
         m_freem(m); /* free the mbuf chain */
 2034360:	e13fed17 	ldw	r4,-76(fp)
 2034364:	20296780 	call	2029678 <m_freem>
         tcp_quench(tp->t_inpcb);
 2034368:	e0bfff17 	ldw	r2,-4(fp)
 203436c:	10800d17 	ldw	r2,52(r2)
 2034370:	1009883a 	mov	r4,r2
 2034374:	2034e140 	call	2034e14 <tcp_quench>
         return (error);
 2034378:	e0bffc17 	ldw	r2,-16(fp)
 203437c:	00002a06 	br	2034428 <tcp_output+0x1008>
      }
      return (error);
 2034380:	e0bffc17 	ldw	r2,-16(fp)
 2034384:	00002806 	br	2034428 <tcp_output+0x1008>

   /*
    * Data sent (as far as we can tell).
    */

   TCP_MIB_INC(tcpOutSegs);   /* keep MIB stats */
 2034388:	00809934 	movhi	r2,612
 203438c:	10b6c704 	addi	r2,r2,-9444
 2034390:	10800a17 	ldw	r2,40(r2)
 2034394:	10c00044 	addi	r3,r2,1
 2034398:	00809934 	movhi	r2,612
 203439c:	10b6c704 	addi	r2,r2,-9444
 20343a0:	10c00a15 	stw	r3,40(r2)
   tcpstat.tcps_sndtotal++;
 20343a4:	00809934 	movhi	r2,612
 20343a8:	10b6f504 	addi	r2,r2,-9260
 20343ac:	10800f17 	ldw	r2,60(r2)
 20343b0:	10c00044 	addi	r3,r2,1
 20343b4:	00809934 	movhi	r2,612
 20343b8:	10b6f504 	addi	r2,r2,-9260
 20343bc:	10c00f15 	stw	r3,60(r2)
   /*
    * If this advertises a larger window than any other segment,
    * then remember the size of the advertised window.
    * Any pending ACK has now been sent.
    */
   if (win > 0 && SEQ_GT(tp->rcv_nxt+win, tp->rcv_adv))
 20343c0:	e0bfeb17 	ldw	r2,-84(fp)
 20343c4:	00800e0e 	bge	zero,r2,2034400 <tcp_output+0xfe0>
 20343c8:	e0bfff17 	ldw	r2,-4(fp)
 20343cc:	10c01617 	ldw	r3,88(r2)
 20343d0:	e0bfeb17 	ldw	r2,-84(fp)
 20343d4:	1887883a 	add	r3,r3,r2
 20343d8:	e0bfff17 	ldw	r2,-4(fp)
 20343dc:	10801917 	ldw	r2,100(r2)
 20343e0:	1885c83a 	sub	r2,r3,r2
 20343e4:	0080060e 	bge	zero,r2,2034400 <tcp_output+0xfe0>
      tp->rcv_adv = tp->rcv_nxt + (unsigned)win;
 20343e8:	e0bfff17 	ldw	r2,-4(fp)
 20343ec:	10c01617 	ldw	r3,88(r2)
 20343f0:	e0bfeb17 	ldw	r2,-84(fp)
 20343f4:	1887883a 	add	r3,r3,r2
 20343f8:	e0bfff17 	ldw	r2,-4(fp)
 20343fc:	10c01915 	stw	r3,100(r2)
   tp->t_flags &= ~(TF_ACKNOW|TF_SACKNOW|TF_DELACK);
 2034400:	e0bfff17 	ldw	r2,-4(fp)
 2034404:	10c00b0b 	ldhu	r3,44(r2)
 2034408:	00bfef04 	movi	r2,-68
 203440c:	1884703a 	and	r2,r3,r2
 2034410:	1007883a 	mov	r3,r2
 2034414:	e0bfff17 	ldw	r2,-4(fp)
 2034418:	10c00b0d 	sth	r3,44(r2)
   if (sendalot)
 203441c:	e0bfef17 	ldw	r2,-68(fp)
 2034420:	103c111e 	bne	r2,zero,2033468 <tcp_output+0x48>
      goto again;
   return (0);
 2034424:	0005883a 	mov	r2,zero
}
 2034428:	e037883a 	mov	sp,fp
 203442c:	dfc00117 	ldw	ra,4(sp)
 2034430:	df000017 	ldw	fp,0(sp)
 2034434:	dec00204 	addi	sp,sp,8
 2034438:	f800283a 	ret

0203443c <tcp_setpersist>:
 * RETURNS: NA
 */

void
tcp_setpersist(struct tcpcb * tp)
{
 203443c:	defffc04 	addi	sp,sp,-16
 2034440:	dfc00315 	stw	ra,12(sp)
 2034444:	df000215 	stw	fp,8(sp)
 2034448:	df000204 	addi	fp,sp,8
 203444c:	e13fff15 	stw	r4,-4(fp)
   int   t;

   t = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 2034450:	e0bfff17 	ldw	r2,-4(fp)
 2034454:	10802017 	ldw	r2,128(r2)
 2034458:	1007d0ba 	srai	r3,r2,2
 203445c:	e0bfff17 	ldw	r2,-4(fp)
 2034460:	10802117 	ldw	r2,132(r2)
 2034464:	1885883a 	add	r2,r3,r2
 2034468:	1005d07a 	srai	r2,r2,1
 203446c:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_timer[TCPT_REXMT])
 2034470:	e0bfff17 	ldw	r2,-4(fp)
 2034474:	10800317 	ldw	r2,12(r2)
 2034478:	10000326 	beq	r2,zero,2034488 <tcp_setpersist+0x4c>
      panic("tcp_output REXMT");
 203447c:	01008174 	movhi	r4,517
 2034480:	213d8104 	addi	r4,r4,-2556
 2034484:	2026bf80 	call	2026bf8 <panic>
   /*
    * Start/restart persistance timer.
    */
   TCPT_RANGESET(tp->t_timer[TCPT_PERSIST],
 2034488:	e0bffe17 	ldw	r2,-8(fp)
 203448c:	1007883a 	mov	r3,r2
 2034490:	e0bfff17 	ldw	r2,-4(fp)
 2034494:	10800717 	ldw	r2,28(r2)
 2034498:	01008174 	movhi	r4,517
 203449c:	210f10c4 	addi	r4,r4,15427
 20344a0:	2085883a 	add	r2,r4,r2
 20344a4:	10800003 	ldbu	r2,0(r2)
 20344a8:	10803fcc 	andi	r2,r2,255
 20344ac:	1885383a 	mul	r2,r3,r2
 20344b0:	10ffffcc 	andi	r3,r2,65535
 20344b4:	18e0001c 	xori	r3,r3,32768
 20344b8:	18e00004 	addi	r3,r3,-32768
 20344bc:	e0bfff17 	ldw	r2,-4(fp)
 20344c0:	10c00415 	stw	r3,16(r2)
 20344c4:	e0bfff17 	ldw	r2,-4(fp)
 20344c8:	10800417 	ldw	r2,16(r2)
 20344cc:	10800288 	cmpgei	r2,r2,10
 20344d0:	1000041e 	bne	r2,zero,20344e4 <tcp_setpersist+0xa8>
 20344d4:	e0bfff17 	ldw	r2,-4(fp)
 20344d8:	00c00284 	movi	r3,10
 20344dc:	10c00415 	stw	r3,16(r2)
 20344e0:	00000706 	br	2034500 <tcp_setpersist+0xc4>
 20344e4:	e0bfff17 	ldw	r2,-4(fp)
 20344e8:	10800417 	ldw	r2,16(r2)
 20344ec:	10801e50 	cmplti	r2,r2,121
 20344f0:	1000031e 	bne	r2,zero,2034500 <tcp_setpersist+0xc4>
 20344f4:	e0bfff17 	ldw	r2,-4(fp)
 20344f8:	00c01e04 	movi	r3,120
 20344fc:	10c00415 	stw	r3,16(r2)
    t * tcp_backoff[tp->t_rxtshift],
    TCPTV_PERSMIN, TCPTV_PERSMAX);
   if (tp->t_rxtshift < TCP_MAXRXTSHIFT)
 2034500:	e0bfff17 	ldw	r2,-4(fp)
 2034504:	10800717 	ldw	r2,28(r2)
 2034508:	10800308 	cmpgei	r2,r2,12
 203450c:	1000051e 	bne	r2,zero,2034524 <tcp_setpersist+0xe8>
      tp->t_rxtshift++;
 2034510:	e0bfff17 	ldw	r2,-4(fp)
 2034514:	10800717 	ldw	r2,28(r2)
 2034518:	10c00044 	addi	r3,r2,1
 203451c:	e0bfff17 	ldw	r2,-4(fp)
 2034520:	10c00715 	stw	r3,28(r2)

}
 2034524:	e037883a 	mov	sp,fp
 2034528:	dfc00117 	ldw	ra,4(sp)
 203452c:	df000017 	ldw	fp,0(sp)
 2034530:	dec00204 	addi	sp,sp,8
 2034534:	f800283a 	ret

02034538 <bld_options>:
 * RETURNS: length of option data added to buffer
 */

static int
bld_options(struct tcpcb * tp, u_char * cp, int flags, struct socket * so)
{
 2034538:	defff804 	addi	sp,sp,-32
 203453c:	dfc00715 	stw	ra,28(sp)
 2034540:	df000615 	stw	fp,24(sp)
 2034544:	df000604 	addi	fp,sp,24
 2034548:	e13ffc15 	stw	r4,-16(fp)
 203454c:	e17ffd15 	stw	r5,-12(fp)
 2034550:	e1bffe15 	stw	r6,-8(fp)
 2034554:	e1ffff15 	stw	r7,-4(fp)
   int      len;
   u_short  mss;

   if(tp->t_flags & TF_NOOPT)    /* no options allowed? */
 2034558:	e0bffc17 	ldw	r2,-16(fp)
 203455c:	10800b0b 	ldhu	r2,44(r2)
 2034560:	10bfffcc 	andi	r2,r2,65535
 2034564:	1080020c 	andi	r2,r2,8
 2034568:	10000226 	beq	r2,zero,2034574 <bld_options+0x3c>
      return 0;
 203456c:	0005883a 	mov	r2,zero
 2034570:	00001e06 	br	20345ec <bld_options+0xb4>

   /* Alway put MSS option on SYN packets */
   if (flags & TH_SYN)
 2034574:	e0bffe17 	ldw	r2,-8(fp)
 2034578:	1080008c 	andi	r2,r2,2
 203457c:	10001926 	beq	r2,zero,20345e4 <bld_options+0xac>
   {
      mss   =  (u_short)tcp_mss(so);
 2034580:	e13fff17 	ldw	r4,-4(fp)
 2034584:	20333280 	call	2033328 <tcp_mss>
 2034588:	e0bffb0d 	sth	r2,-20(fp)

      /* always send MSS option on SYN, fill in MSS parm */
      *(cp + 0) = TCPOPT_MAXSEG;
 203458c:	e0bffd17 	ldw	r2,-12(fp)
 2034590:	00c00084 	movi	r3,2
 2034594:	10c00005 	stb	r3,0(r2)
      *(cp + 1) = MSSOPT_LEN;               /* length byte */
 2034598:	e0bffd17 	ldw	r2,-12(fp)
 203459c:	10800044 	addi	r2,r2,1
 20345a0:	00c00104 	movi	r3,4
 20345a4:	10c00005 	stb	r3,0(r2)
      *(cp + 2)  = (u_char) ((mss & 0xff00) >> 8);
 20345a8:	e0bffd17 	ldw	r2,-12(fp)
 20345ac:	10800084 	addi	r2,r2,2
 20345b0:	e0fffb0b 	ldhu	r3,-20(fp)
 20345b4:	1806d23a 	srli	r3,r3,8
 20345b8:	10c00005 	stb	r3,0(r2)
      *(cp + 3)  = (u_char) (mss & 0xff);
 20345bc:	e0bffd17 	ldw	r2,-12(fp)
 20345c0:	108000c4 	addi	r2,r2,3
 20345c4:	e0fffb0b 	ldhu	r3,-20(fp)
 20345c8:	10c00005 	stb	r3,0(r2)
      len = 4;
 20345cc:	00800104 	movi	r2,4
 20345d0:	e0bffa15 	stw	r2,-24(fp)
      cp += 4;
 20345d4:	e0bffd17 	ldw	r2,-12(fp)
 20345d8:	10800104 	addi	r2,r2,4
 20345dc:	e0bffd15 	stw	r2,-12(fp)
 20345e0:	00000106 	br	20345e8 <bld_options+0xb0>
   }
   else
      len = 0;
 20345e4:	e03ffa15 	stw	zero,-24(fp)
      len += 10;
   }
#endif   /* TCP_TIMESTAMP */

   USE_ARG(so);
   return len;
 20345e8:	e0bffa17 	ldw	r2,-24(fp)
}
 20345ec:	e037883a 	mov	sp,fp
 20345f0:	dfc00117 	ldw	ra,4(sp)
 20345f4:	df000017 	ldw	fp,0(sp)
 20345f8:	dec00204 	addi	sp,sp,8
 20345fc:	f800283a 	ret

02034600 <tcp_init>:
 * RETURNS: 
 */

void
tcp_init()
{
 2034600:	deffff04 	addi	sp,sp,-4
 2034604:	df000015 	stw	fp,0(sp)
 2034608:	d839883a 	mov	fp,sp
   tcp_iss = 1;      /* wrong */
 203460c:	00808174 	movhi	r2,517
 2034610:	1090d604 	addi	r2,r2,17240
 2034614:	00c00044 	movi	r3,1
 2034618:	10c00015 	stw	r3,0(r2)
   tcb.inp_next = tcb.inp_prev = &tcb;
 203461c:	00809934 	movhi	r2,612
 2034620:	10b6ea04 	addi	r2,r2,-9304
 2034624:	00c09934 	movhi	r3,612
 2034628:	18f6ea04 	addi	r3,r3,-9304
 203462c:	10c00115 	stw	r3,4(r2)
 2034630:	00809934 	movhi	r2,612
 2034634:	10b6ea04 	addi	r2,r2,-9304
 2034638:	10c00117 	ldw	r3,4(r2)
 203463c:	00809934 	movhi	r2,612
 2034640:	10b6ea04 	addi	r2,r2,-9304
 2034644:	10c00015 	stw	r3,0(r2)
}
 2034648:	e037883a 	mov	sp,fp
 203464c:	df000017 	ldw	fp,0(sp)
 2034650:	dec00104 	addi	sp,sp,4
 2034654:	f800283a 	ret

02034658 <tcp_template>:
 * RETURNS: 
 */

struct tcpiphdr * 
tcp_template(struct tcpcb * tp)
{
 2034658:	defffb04 	addi	sp,sp,-20
 203465c:	dfc00415 	stw	ra,16(sp)
 2034660:	df000315 	stw	fp,12(sp)
 2034664:	df000304 	addi	fp,sp,12
 2034668:	e13fff15 	stw	r4,-4(fp)
   struct inpcb * inp   =  tp->t_inpcb;
 203466c:	e0bfff17 	ldw	r2,-4(fp)
 2034670:	10800d17 	ldw	r2,52(r2)
 2034674:	e0bffe15 	stw	r2,-8(fp)
   struct tcpiphdr * n;

   if ((n = tp->t_template) == 0)
 2034678:	e0bfff17 	ldw	r2,-4(fp)
 203467c:	10800c17 	ldw	r2,48(r2)
 2034680:	e0bffd15 	stw	r2,-12(fp)
 2034684:	e0bffd17 	ldw	r2,-12(fp)
 2034688:	1000071e 	bne	r2,zero,20346a8 <tcp_template+0x50>
   {
      n = (struct tcpiphdr *)TPH_ALLOC (sizeof (*n));
 203468c:	01000a04 	movi	r4,40
 2034690:	20290400 	call	2029040 <npalloc>
 2034694:	e0bffd15 	stw	r2,-12(fp)
      if (n == NULL)
 2034698:	e0bffd17 	ldw	r2,-12(fp)
 203469c:	1000021e 	bne	r2,zero,20346a8 <tcp_template+0x50>
         return (0);
 20346a0:	0005883a 	mov	r2,zero
 20346a4:	00002906 	br	203474c <tcp_template+0xf4>
   }
   n->ti_next = n->ti_prev = 0;
 20346a8:	e0bffd17 	ldw	r2,-12(fp)
 20346ac:	10000115 	stw	zero,4(r2)
 20346b0:	e0bffd17 	ldw	r2,-12(fp)
 20346b4:	10c00117 	ldw	r3,4(r2)
 20346b8:	e0bffd17 	ldw	r2,-12(fp)
 20346bc:	10c00015 	stw	r3,0(r2)
   n->ti_len = htons(sizeof (struct tcpiphdr) - sizeof (struct ip));
 20346c0:	e0bffd17 	ldw	r2,-12(fp)
 20346c4:	00c50004 	movi	r3,5120
 20346c8:	10c0028d 	sth	r3,10(r2)
   n->ti_src = inp->inp_laddr;
 20346cc:	e0bffd17 	ldw	r2,-12(fp)
 20346d0:	e0fffe17 	ldw	r3,-8(fp)
 20346d4:	18c00417 	ldw	r3,16(r3)
 20346d8:	10c00315 	stw	r3,12(r2)
   n->ti_dst = inp->inp_faddr;
 20346dc:	e0bffd17 	ldw	r2,-12(fp)
 20346e0:	e0fffe17 	ldw	r3,-8(fp)
 20346e4:	18c00317 	ldw	r3,12(r3)
 20346e8:	10c00415 	stw	r3,16(r2)
   n->ti_sport = inp->inp_lport;
 20346ec:	e0bffe17 	ldw	r2,-8(fp)
 20346f0:	10c0078b 	ldhu	r3,30(r2)
 20346f4:	e0bffd17 	ldw	r2,-12(fp)
 20346f8:	10c0050d 	sth	r3,20(r2)
   n->ti_dport = inp->inp_fport;
 20346fc:	e0bffe17 	ldw	r2,-8(fp)
 2034700:	10c0070b 	ldhu	r3,28(r2)
 2034704:	e0bffd17 	ldw	r2,-12(fp)
 2034708:	10c0058d 	sth	r3,22(r2)
   n->ti_seq = 0;
 203470c:	e0bffd17 	ldw	r2,-12(fp)
 2034710:	10000615 	stw	zero,24(r2)
   n->ti_ack = 0;
 2034714:	e0bffd17 	ldw	r2,-12(fp)
 2034718:	10000715 	stw	zero,28(r2)
   n->ti_t.th_doff = (5 << 4);   /* NetPort */
 203471c:	e0bffd17 	ldw	r2,-12(fp)
 2034720:	00c01404 	movi	r3,80
 2034724:	10c00805 	stb	r3,32(r2)
   n->ti_flags = 0;
 2034728:	e0bffd17 	ldw	r2,-12(fp)
 203472c:	10000845 	stb	zero,33(r2)
   n->ti_win = 0;
 2034730:	e0bffd17 	ldw	r2,-12(fp)
 2034734:	1000088d 	sth	zero,34(r2)
   n->ti_sum = 0;
 2034738:	e0bffd17 	ldw	r2,-12(fp)
 203473c:	1000090d 	sth	zero,36(r2)
   n->ti_urp = 0;
 2034740:	e0bffd17 	ldw	r2,-12(fp)
 2034744:	1000098d 	sth	zero,38(r2)
   return (n);
 2034748:	e0bffd17 	ldw	r2,-12(fp)
}
 203474c:	e037883a 	mov	sp,fp
 2034750:	dfc00117 	ldw	ra,4(sp)
 2034754:	df000017 	ldw	fp,0(sp)
 2034758:	dec00204 	addi	sp,sp,8
 203475c:	f800283a 	ret

02034760 <tcp_respond>:
   struct tcpiphdr * ti,
   tcp_seq  ack,
   tcp_seq  seq,
   int   flags,
   struct mbuf *  ti_mbuf)
{
 2034760:	defff204 	addi	sp,sp,-56
 2034764:	dfc00d15 	stw	ra,52(sp)
 2034768:	df000c15 	stw	fp,48(sp)
 203476c:	df000c04 	addi	fp,sp,48
 2034770:	e13ffc15 	stw	r4,-16(fp)
 2034774:	e17ffd15 	stw	r5,-12(fp)
 2034778:	e1bffe15 	stw	r6,-8(fp)
 203477c:	e1ffff15 	stw	r7,-4(fp)
   int      tlen;       /* tcp data len - 0 or 1 */
   int      domain;     /* AF_INET or AF_INET6 */
   int      win = 0;    /* window to use in sent packet */
 2034780:	e03ff615 	stw	zero,-40(fp)
   struct mbuf *  m;    /* mbuf to send */
   struct tcpiphdr * tmp_thdr;   /* scratch */

   if (tp)
 2034784:	e0bffc17 	ldw	r2,-16(fp)
 2034788:	10001726 	beq	r2,zero,20347e8 <tcp_respond+0x88>
      win = (int)sbspace(&tp->t_inpcb->inp_socket->so_rcv);
 203478c:	e0bffc17 	ldw	r2,-16(fp)
 2034790:	10800d17 	ldw	r2,52(r2)
 2034794:	10800817 	ldw	r2,32(r2)
 2034798:	10800b17 	ldw	r2,44(r2)
 203479c:	1007883a 	mov	r3,r2
 20347a0:	e0bffc17 	ldw	r2,-16(fp)
 20347a4:	10800d17 	ldw	r2,52(r2)
 20347a8:	10800817 	ldw	r2,32(r2)
 20347ac:	10800a17 	ldw	r2,40(r2)
 20347b0:	1885c83a 	sub	r2,r3,r2
 20347b4:	10000a16 	blt	r2,zero,20347e0 <tcp_respond+0x80>
 20347b8:	e0bffc17 	ldw	r2,-16(fp)
 20347bc:	10800d17 	ldw	r2,52(r2)
 20347c0:	10800817 	ldw	r2,32(r2)
 20347c4:	10c00b17 	ldw	r3,44(r2)
 20347c8:	e0bffc17 	ldw	r2,-16(fp)
 20347cc:	10800d17 	ldw	r2,52(r2)
 20347d0:	10800817 	ldw	r2,32(r2)
 20347d4:	10800a17 	ldw	r2,40(r2)
 20347d8:	1885c83a 	sub	r2,r3,r2
 20347dc:	00000106 	br	20347e4 <tcp_respond+0x84>
 20347e0:	0005883a 	mov	r2,zero
 20347e4:	e0bff615 	stw	r2,-40(fp)

   /* Figure out of we can recycle the passed buffer or if we need a 
    * new one. Construct the easy parts of the the TCP and IP headers.
    */
   if (flags == 0)   /* sending keepalive from timer */
 20347e8:	e0800217 	ldw	r2,8(fp)
 20347ec:	1000261e 	bne	r2,zero,2034888 <tcp_respond+0x128>
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
 20347f0:	010000c4 	movi	r4,3
 20347f4:	01401004 	movi	r5,64
 20347f8:	20293d80 	call	20293d8 <m_getnbuf>
 20347fc:	e0bff715 	stw	r2,-36(fp)
      if (m == NULL)
 2034800:	e0bff717 	ldw	r2,-36(fp)
 2034804:	1000d326 	beq	r2,zero,2034b54 <tcp_respond+0x3f4>
         return;
      tlen = 1;   /* Keepalives have one byte of data */
 2034808:	00800044 	movi	r2,1
 203480c:	e0bff415 	stw	r2,-48(fp)
      m->m_len = TCPIPHDRSZ + tlen;
 2034810:	e0bff417 	ldw	r2,-48(fp)
 2034814:	10800a04 	addi	r2,r2,40
 2034818:	1007883a 	mov	r3,r2
 203481c:	e0bff717 	ldw	r2,-36(fp)
 2034820:	10c00215 	stw	r3,8(r2)
      /*
       * Copy template contents into the mbuf and set ti to point
       * to the header structure in the mbuf.
       */
      tmp_thdr = (struct tcpiphdr *)((char *)m->m_data+sizeof(struct ip)
 2034824:	e0bff717 	ldw	r2,-36(fp)
 2034828:	10800317 	ldw	r2,12(r2)
 203482c:	e0bff815 	stw	r2,-32(fp)
         - sizeof(struct ipovly));
      if ((char *)tmp_thdr < m->pkt->nb_buff)
 2034830:	e0bff717 	ldw	r2,-36(fp)
 2034834:	10800117 	ldw	r2,4(r2)
 2034838:	10800117 	ldw	r2,4(r2)
 203483c:	e0fff817 	ldw	r3,-32(fp)
 2034840:	1880032e 	bgeu	r3,r2,2034850 <tcp_respond+0xf0>
      {
         panic("tcp_respond- packet ptr underflow\n");
 2034844:	01008174 	movhi	r4,517
 2034848:	213d8604 	addi	r4,r4,-2536
 203484c:	2026bf80 	call	2026bf8 <panic>
      }
      MEMCPY(tmp_thdr, ti, sizeof(struct tcpiphdr));
 2034850:	e13ff817 	ldw	r4,-32(fp)
 2034854:	e17ffd17 	ldw	r5,-12(fp)
 2034858:	01800a04 	movi	r6,40
 203485c:	200660c0 	call	200660c <memcpy>
      ti = tmp_thdr;
 2034860:	e0bff817 	ldw	r2,-32(fp)
 2034864:	e0bffd15 	stw	r2,-12(fp)
      flags = TH_ACK;
 2034868:	00800404 	movi	r2,16
 203486c:	e0800215 	stw	r2,8(fp)
      domain = tp->t_inpcb->inp_socket->so_domain;
 2034870:	e0bffc17 	ldw	r2,-16(fp)
 2034874:	10800d17 	ldw	r2,52(r2)
 2034878:	10800817 	ldw	r2,32(r2)
 203487c:	10800517 	ldw	r2,20(r2)
 2034880:	e0bff515 	stw	r2,-44(fp)
 2034884:	00003b06 	br	2034974 <tcp_respond+0x214>
   }
   else  /* Flag was passed (e.g. reset); recycle passed mbuf */
   {
      m = ti_mbuf;   /*dtom(ti);*/
 2034888:	e0800317 	ldw	r2,12(fp)
 203488c:	e0bff715 	stw	r2,-36(fp)
      if(m->pkt->type == IPTP)   /* IPv4 packet */
 2034890:	e0bff717 	ldw	r2,-36(fp)
 2034894:	10800117 	ldw	r2,4(r2)
 2034898:	1080080b 	ldhu	r2,32(r2)
 203489c:	10bfffcc 	andi	r2,r2,65535
 20348a0:	10800218 	cmpnei	r2,r2,8
 20348a4:	1000031e 	bne	r2,zero,20348b4 <tcp_respond+0x154>
         domain = AF_INET;
 20348a8:	00800084 	movi	r2,2
 20348ac:	e0bff515 	stw	r2,-44(fp)
 20348b0:	00000206 	br	20348bc <tcp_respond+0x15c>
      else
         domain = AF_INET6;
 20348b4:	008000c4 	movi	r2,3
 20348b8:	e0bff515 	stw	r2,-44(fp)

      m_freem(m->m_next);
 20348bc:	e0bff717 	ldw	r2,-36(fp)
 20348c0:	10800617 	ldw	r2,24(r2)
 20348c4:	1009883a 	mov	r4,r2
 20348c8:	20296780 	call	2029678 <m_freem>
      m->m_next = 0;
 20348cc:	e0bff717 	ldw	r2,-36(fp)
 20348d0:	10000615 	stw	zero,24(r2)
      tlen = 0;         /* NO data */
 20348d4:	e03ff415 	stw	zero,-48(fp)
      m->m_len = TCPIPHDRSZ;
 20348d8:	e0bff717 	ldw	r2,-36(fp)
 20348dc:	00c00a04 	movi	r3,40
 20348e0:	10c00215 	stw	r3,8(r2)
      xchg(ti->ti_dport, ti->ti_sport, u_short);
 20348e4:	e0bffd17 	ldw	r2,-12(fp)
 20348e8:	1080058b 	ldhu	r2,22(r2)
 20348ec:	e0bff90d 	sth	r2,-28(fp)
 20348f0:	e0bffd17 	ldw	r2,-12(fp)
 20348f4:	10c0050b 	ldhu	r3,20(r2)
 20348f8:	e0bffd17 	ldw	r2,-12(fp)
 20348fc:	10c0058d 	sth	r3,22(r2)
 2034900:	e0bffd17 	ldw	r2,-12(fp)
 2034904:	e0fff90b 	ldhu	r3,-28(fp)
 2034908:	10c0050d 	sth	r3,20(r2)
      if(m->pkt->type == IPTP)
 203490c:	e0bff717 	ldw	r2,-36(fp)
 2034910:	10800117 	ldw	r2,4(r2)
 2034914:	1080080b 	ldhu	r2,32(r2)
 2034918:	10bfffcc 	andi	r2,r2,65535
 203491c:	10800218 	cmpnei	r2,r2,8
 2034920:	10000a1e 	bne	r2,zero,203494c <tcp_respond+0x1ec>
         xchg(ti->ti_dst.s_addr, ti->ti_src.s_addr, u_long);
 2034924:	e0bffd17 	ldw	r2,-12(fp)
 2034928:	10800417 	ldw	r2,16(r2)
 203492c:	e0bffa15 	stw	r2,-24(fp)
 2034930:	e0bffd17 	ldw	r2,-12(fp)
 2034934:	10c00317 	ldw	r3,12(r2)
 2034938:	e0bffd17 	ldw	r2,-12(fp)
 203493c:	10c00415 	stw	r3,16(r2)
 2034940:	e0bffd17 	ldw	r2,-12(fp)
 2034944:	e0fffa17 	ldw	r3,-24(fp)
 2034948:	10c00315 	stw	r3,12(r2)
      if (flags & TH_RST)  /* count resets in MIB */
 203494c:	e0800217 	ldw	r2,8(fp)
 2034950:	1080010c 	andi	r2,r2,4
 2034954:	10000726 	beq	r2,zero,2034974 <tcp_respond+0x214>
         TCP_MIB_INC(tcpOutRsts);   /* keep MIB stats */
 2034958:	00809934 	movhi	r2,612
 203495c:	10b6c704 	addi	r2,r2,-9444
 2034960:	10800e17 	ldw	r2,56(r2)
 2034964:	10c00044 	addi	r3,r2,1
 2034968:	00809934 	movhi	r2,612
 203496c:	10b6c704 	addi	r2,r2,-9444
 2034970:	10c00e15 	stw	r3,56(r2)
   }

   /* finish constructing the TCP header */
   ti->ti_seq = htonl(seq);
 2034974:	e0bfff17 	ldw	r2,-4(fp)
 2034978:	1006d63a 	srli	r3,r2,24
 203497c:	e0bfff17 	ldw	r2,-4(fp)
 2034980:	1004d23a 	srli	r2,r2,8
 2034984:	10bfc00c 	andi	r2,r2,65280
 2034988:	1886b03a 	or	r3,r3,r2
 203498c:	e0bfff17 	ldw	r2,-4(fp)
 2034990:	10bfc00c 	andi	r2,r2,65280
 2034994:	1004923a 	slli	r2,r2,8
 2034998:	1886b03a 	or	r3,r3,r2
 203499c:	e0bfff17 	ldw	r2,-4(fp)
 20349a0:	1004963a 	slli	r2,r2,24
 20349a4:	1886b03a 	or	r3,r3,r2
 20349a8:	e0bffd17 	ldw	r2,-12(fp)
 20349ac:	10c00615 	stw	r3,24(r2)
   ti->ti_ack = htonl(ack);
 20349b0:	e0bffe17 	ldw	r2,-8(fp)
 20349b4:	1006d63a 	srli	r3,r2,24
 20349b8:	e0bffe17 	ldw	r2,-8(fp)
 20349bc:	1004d23a 	srli	r2,r2,8
 20349c0:	10bfc00c 	andi	r2,r2,65280
 20349c4:	1886b03a 	or	r3,r3,r2
 20349c8:	e0bffe17 	ldw	r2,-8(fp)
 20349cc:	10bfc00c 	andi	r2,r2,65280
 20349d0:	1004923a 	slli	r2,r2,8
 20349d4:	1886b03a 	or	r3,r3,r2
 20349d8:	e0bffe17 	ldw	r2,-8(fp)
 20349dc:	1004963a 	slli	r2,r2,24
 20349e0:	1886b03a 	or	r3,r3,r2
 20349e4:	e0bffd17 	ldw	r2,-12(fp)
 20349e8:	10c00715 	stw	r3,28(r2)
   ti->ti_t.th_doff = 0x50;      /* NetPort: init data offset bits */
 20349ec:	e0bffd17 	ldw	r2,-12(fp)
 20349f0:	00c01404 	movi	r3,80
 20349f4:	10c00805 	stb	r3,32(r2)
   ti->ti_flags = (u_char)flags;
 20349f8:	e0800217 	ldw	r2,8(fp)
 20349fc:	1007883a 	mov	r3,r2
 2034a00:	e0bffd17 	ldw	r2,-12(fp)
 2034a04:	10c00845 	stb	r3,33(r2)
   ti->ti_win = htons((u_short)win);
 2034a08:	e0bff617 	ldw	r2,-40(fp)
 2034a0c:	10bfffcc 	andi	r2,r2,65535
 2034a10:	1004d23a 	srli	r2,r2,8
 2034a14:	1007883a 	mov	r3,r2
 2034a18:	e0bff617 	ldw	r2,-40(fp)
 2034a1c:	10bfffcc 	andi	r2,r2,65535
 2034a20:	1004923a 	slli	r2,r2,8
 2034a24:	1884b03a 	or	r2,r3,r2
 2034a28:	1007883a 	mov	r3,r2
 2034a2c:	e0bffd17 	ldw	r2,-12(fp)
 2034a30:	10c0088d 	sth	r3,34(r2)
   ti->ti_urp = 0;
 2034a34:	e0bffd17 	ldw	r2,-12(fp)
 2034a38:	1000098d 	sth	zero,38(r2)

   /* Finish constructing IP header and send, based on IP type in use */
   switch(domain)
 2034a3c:	e0bff517 	ldw	r2,-44(fp)
 2034a40:	108000a0 	cmpeqi	r2,r2,2
 2034a44:	10003f26 	beq	r2,zero,2034b44 <tcp_respond+0x3e4>
#ifdef IP_V4
      case AF_INET:
      {
         struct ip * pip;

         pip = (struct ip *)((char*)ti+sizeof(struct ipovly)-sizeof(struct ip));
 2034a48:	e0bffd17 	ldw	r2,-12(fp)
 2034a4c:	e0bffb15 	stw	r2,-20(fp)

         pip->ip_len = (unshort)(TCPIPHDRSZ + tlen);
 2034a50:	e0bff417 	ldw	r2,-48(fp)
 2034a54:	10800a04 	addi	r2,r2,40
 2034a58:	1007883a 	mov	r3,r2
 2034a5c:	e0bffb17 	ldw	r2,-20(fp)
 2034a60:	10c0008d 	sth	r3,2(r2)
         /* If our system's max. MAC header size is geater than the size 
          * of the MAC header in the received packet then we need to 
          * adjust the IP header offset to allow for this. Since the packets 
          * are only headers they should always fit.
          */
         if(pip >= (struct ip *)(m->pkt->nb_buff + MaxLnh))
 2034a64:	e0bff717 	ldw	r2,-36(fp)
 2034a68:	10800117 	ldw	r2,4(r2)
 2034a6c:	10c00117 	ldw	r3,4(r2)
 2034a70:	00808174 	movhi	r2,517
 2034a74:	1090b004 	addi	r2,r2,17088
 2034a78:	10800017 	ldw	r2,0(r2)
 2034a7c:	1885883a 	add	r2,r3,r2
 2034a80:	e0fffb17 	ldw	r3,-20(fp)
 2034a84:	18800436 	bltu	r3,r2,2034a98 <tcp_respond+0x338>
         {
            m->m_data = (char*)pip; /* headers will fit, just set pointer */
 2034a88:	e0bff717 	ldw	r2,-36(fp)
 2034a8c:	e0fffb17 	ldw	r3,-20(fp)
 2034a90:	10c00315 	stw	r3,12(r2)
 2034a94:	00001306 	br	2034ae4 <tcp_respond+0x384>
         }
         else     /* MAC may not fit, adjust pointer and move headers back */
         {
            m->m_data = m->pkt->nb_prot = m->pkt->nb_buff + MaxLnh;  /* new ptr */
 2034a98:	e0bff717 	ldw	r2,-36(fp)
 2034a9c:	10800117 	ldw	r2,4(r2)
 2034aa0:	e0fff717 	ldw	r3,-36(fp)
 2034aa4:	18c00117 	ldw	r3,4(r3)
 2034aa8:	19000117 	ldw	r4,4(r3)
 2034aac:	00c08174 	movhi	r3,517
 2034ab0:	18d0b004 	addi	r3,r3,17088
 2034ab4:	18c00017 	ldw	r3,0(r3)
 2034ab8:	20c7883a 	add	r3,r4,r3
 2034abc:	10c00315 	stw	r3,12(r2)
 2034ac0:	10c00317 	ldw	r3,12(r2)
 2034ac4:	e0bff717 	ldw	r2,-36(fp)
 2034ac8:	10c00315 	stw	r3,12(r2)
            MEMMOVE(m->m_data, pip, TCPIPHDRSZ);  /* move back tcp/ip headers */
 2034acc:	e0bff717 	ldw	r2,-36(fp)
 2034ad0:	10800317 	ldw	r2,12(r2)
 2034ad4:	1009883a 	mov	r4,r2
 2034ad8:	e17ffb17 	ldw	r5,-20(fp)
 2034adc:	01800a04 	movi	r6,40
 2034ae0:	20067040 	call	2006704 <memmove>

         /*
          * In the case of a SYN DOS attack, many RST|ACK replies
          *   have no tp structure and need to be freed.
          */
         if (!tp)
 2034ae4:	e0bffc17 	ldw	r2,-16(fp)
 2034ae8:	1000031e 	bne	r2,zero,2034af8 <tcp_respond+0x398>
              m_freem(m);
 2034aec:	e13ff717 	ldw	r4,-36(fp)
 2034af0:	20296780 	call	2029678 <m_freem>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 2034af4:	00001506 	br	2034b4c <tcp_respond+0x3ec>
          */
         if (!tp)
              m_freem(m);
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
 2034af8:	e0bffc17 	ldw	r2,-16(fp)
 2034afc:	10800d17 	ldw	r2,52(r2)
 2034b00:	10000c26 	beq	r2,zero,2034b34 <tcp_respond+0x3d4>
 2034b04:	e0bffc17 	ldw	r2,-16(fp)
 2034b08:	10800d17 	ldw	r2,52(r2)
 2034b0c:	10800817 	ldw	r2,32(r2)
 2034b10:	10000826 	beq	r2,zero,2034b34 <tcp_respond+0x3d4>
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
 2034b14:	e0bffc17 	ldw	r2,-16(fp)
 2034b18:	10800d17 	ldw	r2,52(r2)
 2034b1c:	10800817 	ldw	r2,32(r2)
 2034b20:	10801f17 	ldw	r2,124(r2)
 2034b24:	e13ff717 	ldw	r4,-36(fp)
 2034b28:	100b883a 	mov	r5,r2
 2034b2c:	202a01c0 	call	202a01c <ip_output>
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
		 }

         break;
 2034b30:	00000606 	br	2034b4c <tcp_respond+0x3ec>
         else
		 {
			 if ((tp->t_inpcb) && (tp->t_inpcb->inp_socket))
				ip_output(m, tp->t_inpcb->inp_socket->so_optsPack);
			 else
				ip_output(m, (struct   ip_socopts *)NULL);
 2034b34:	e13ff717 	ldw	r4,-36(fp)
 2034b38:	000b883a 	mov	r5,zero
 2034b3c:	202a01c0 	call	202a01c <ip_output>
		 }

         break;
 2034b40:	00000206 	br	2034b4c <tcp_respond+0x3ec>

         break;
      }
#endif   /* IP_V6 */
      default:
         dtrap();
 2034b44:	20285c80 	call	20285c8 <dtrap>
         break;
 2034b48:	0001883a 	nop
   }
   return;
 2034b4c:	0001883a 	nop
 2034b50:	00000106 	br	2034b58 <tcp_respond+0x3f8>
   if (flags == 0)   /* sending keepalive from timer */
   {
      /* no flags == need a new buffer */
      m = m_getwithdata (MT_HEADER, 64);
      if (m == NULL)
         return;
 2034b54:	0001883a 	nop
      default:
         dtrap();
         break;
   }
   return;
}
 2034b58:	e037883a 	mov	sp,fp
 2034b5c:	dfc00117 	ldw	ra,4(sp)
 2034b60:	df000017 	ldw	fp,0(sp)
 2034b64:	dec00204 	addi	sp,sp,8
 2034b68:	f800283a 	ret

02034b6c <tcp_newtcpcb>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_newtcpcb(struct inpcb * inp)
{
 2034b6c:	defffb04 	addi	sp,sp,-20
 2034b70:	dfc00415 	stw	ra,16(sp)
 2034b74:	df000315 	stw	fp,12(sp)
 2034b78:	df000304 	addi	fp,sp,12
 2034b7c:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   short t_time;

   tp = TCB_ALLOC(sizeof (*tp));
 2034b80:	01002504 	movi	r4,148
 2034b84:	20290400 	call	2029040 <npalloc>
 2034b88:	e0bffd15 	stw	r2,-12(fp)
   if (tp == NULL)
 2034b8c:	e0bffd17 	ldw	r2,-12(fp)
 2034b90:	1000021e 	bne	r2,zero,2034b9c <tcp_newtcpcb+0x30>
      return (struct tcpcb *)NULL;
 2034b94:	0005883a 	mov	r2,zero
 2034b98:	00003206 	br	2034c64 <tcp_newtcpcb+0xf8>
   tp->seg_next = tp->seg_prev = (struct tcpiphdr *)tp;
 2034b9c:	e0bffd17 	ldw	r2,-12(fp)
 2034ba0:	e0fffd17 	ldw	r3,-12(fp)
 2034ba4:	10c00115 	stw	r3,4(r2)
 2034ba8:	e0bffd17 	ldw	r2,-12(fp)
 2034bac:	10c00117 	ldw	r3,4(r2)
 2034bb0:	e0bffd17 	ldw	r2,-12(fp)
 2034bb4:	10c00015 	stw	r3,0(r2)
   tp->t_maxseg = TCP_MSS;
 2034bb8:	e0bffd17 	ldw	r2,-12(fp)
 2034bbc:	00c16d04 	movi	r3,1460
 2034bc0:	10c00a0d 	sth	r3,40(r2)
   tp->t_flags = 0;        /* sends options! */
 2034bc4:	e0bffd17 	ldw	r2,-12(fp)
 2034bc8:	10000b0d 	sth	zero,44(r2)
   tp->t_inpcb = inp;
 2034bcc:	e0bffd17 	ldw	r2,-12(fp)
 2034bd0:	e0ffff17 	ldw	r3,-4(fp)
 2034bd4:	10c00d15 	stw	r3,52(r2)
   /*
    * Init srtt to TCPTV_SRTTBASE (0), so we can tell that we have no
    * rtt estimate.  Set rttvar so that srtt + 2 * rttvar gives
    * reasonable initial retransmit time.
    */
   tp->t_srtt = TCPTV_SRTTBASE;
 2034bd8:	e0bffd17 	ldw	r2,-12(fp)
 2034bdc:	10002015 	stw	zero,128(r2)
   tp->t_rttvar = TCPTV_SRTTDFLT << 2;
 2034be0:	e0bffd17 	ldw	r2,-12(fp)
 2034be4:	00c00604 	movi	r3,24
 2034be8:	10c02115 	stw	r3,132(r2)

   t_time = ((TCPTV_SRTTBASE >> 2) + (TCPTV_SRTTDFLT << 2)) >> 1;
 2034bec:	00800304 	movi	r2,12
 2034bf0:	e0bffe0d 	sth	r2,-8(fp)
   TCPT_RANGESET(tp->t_rxtcur, t_time, TCPTV_MIN, TCPTV_REXMTMAX);
 2034bf4:	e0fffe0f 	ldh	r3,-8(fp)
 2034bf8:	e0bffd17 	ldw	r2,-12(fp)
 2034bfc:	10c00815 	stw	r3,32(r2)
 2034c00:	e0bffd17 	ldw	r2,-12(fp)
 2034c04:	10800817 	ldw	r2,32(r2)
 2034c08:	10800088 	cmpgei	r2,r2,2
 2034c0c:	1000041e 	bne	r2,zero,2034c20 <tcp_newtcpcb+0xb4>
 2034c10:	e0bffd17 	ldw	r2,-12(fp)
 2034c14:	00c00084 	movi	r3,2
 2034c18:	10c00815 	stw	r3,32(r2)
 2034c1c:	00000706 	br	2034c3c <tcp_newtcpcb+0xd0>
 2034c20:	e0bffd17 	ldw	r2,-12(fp)
 2034c24:	10800817 	ldw	r2,32(r2)
 2034c28:	10802050 	cmplti	r2,r2,129
 2034c2c:	1000031e 	bne	r2,zero,2034c3c <tcp_newtcpcb+0xd0>
 2034c30:	e0bffd17 	ldw	r2,-12(fp)
 2034c34:	00c02004 	movi	r3,128
 2034c38:	10c00815 	stw	r3,32(r2)

   /* Set initial congestion window - RFC-2581, pg 4. */
   tp->snd_cwnd = 2 * TCP_MSS;
 2034c3c:	e0bffd17 	ldw	r2,-12(fp)
 2034c40:	00c2da04 	movi	r3,2920
 2034c44:	10c01b15 	stw	r3,108(r2)

#ifdef DO_DELAY_ACKS
   tp->t_delacktime = 1;
#endif   /* DO_DELAY_ACKS */

   tp->snd_ssthresh = 65535;  /* Start with high slow-start threshold */
 2034c48:	e0bffd17 	ldw	r2,-12(fp)
 2034c4c:	00ffffd4 	movui	r3,65535
 2034c50:	10c01c15 	stw	r3,112(r2)

   inp->inp_ppcb = (char *)tp;
 2034c54:	e0bfff17 	ldw	r2,-4(fp)
 2034c58:	e0fffd17 	ldw	r3,-12(fp)
 2034c5c:	10c00915 	stw	r3,36(r2)
   return (tp);
 2034c60:	e0bffd17 	ldw	r2,-12(fp)
}
 2034c64:	e037883a 	mov	sp,fp
 2034c68:	dfc00117 	ldw	ra,4(sp)
 2034c6c:	df000017 	ldw	fp,0(sp)
 2034c70:	dec00204 	addi	sp,sp,8
 2034c74:	f800283a 	ret

02034c78 <tcp_drop>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_drop(struct tcpcb * tp, int err)
{
 2034c78:	defffb04 	addi	sp,sp,-20
 2034c7c:	dfc00415 	stw	ra,16(sp)
 2034c80:	df000315 	stw	fp,12(sp)
 2034c84:	df000304 	addi	fp,sp,12
 2034c88:	e13ffe15 	stw	r4,-8(fp)
 2034c8c:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 2034c90:	e0bffe17 	ldw	r2,-8(fp)
 2034c94:	10800d17 	ldw	r2,52(r2)
 2034c98:	10800817 	ldw	r2,32(r2)
 2034c9c:	e0bffd15 	stw	r2,-12(fp)

   if (TCPS_HAVERCVDSYN(tp->t_state)) 
 2034ca0:	e0bffe17 	ldw	r2,-8(fp)
 2034ca4:	10800217 	ldw	r2,8(r2)
 2034ca8:	108000d0 	cmplti	r2,r2,3
 2034cac:	10000c1e 	bne	r2,zero,2034ce0 <tcp_drop+0x68>
   {
      tp->t_state = TCPS_CLOSED;
 2034cb0:	e0bffe17 	ldw	r2,-8(fp)
 2034cb4:	10000215 	stw	zero,8(r2)
      (void) tcp_output(tp);
 2034cb8:	e13ffe17 	ldw	r4,-8(fp)
 2034cbc:	20334200 	call	2033420 <tcp_output>
      tcpstat.tcps_drops++;
 2034cc0:	00809934 	movhi	r2,612
 2034cc4:	10b6f504 	addi	r2,r2,-9260
 2034cc8:	10800317 	ldw	r2,12(r2)
 2034ccc:	10c00044 	addi	r3,r2,1
 2034cd0:	00809934 	movhi	r2,612
 2034cd4:	10b6f504 	addi	r2,r2,-9260
 2034cd8:	10c00315 	stw	r3,12(r2)
 2034cdc:	00000706 	br	2034cfc <tcp_drop+0x84>
   }
   else
      tcpstat.tcps_conndrops++;
 2034ce0:	00809934 	movhi	r2,612
 2034ce4:	10b6f504 	addi	r2,r2,-9260
 2034ce8:	10800417 	ldw	r2,16(r2)
 2034cec:	10c00044 	addi	r3,r2,1
 2034cf0:	00809934 	movhi	r2,612
 2034cf4:	10b6f504 	addi	r2,r2,-9260
 2034cf8:	10c00415 	stw	r3,16(r2)
   so->so_error = err;
 2034cfc:	e0bffd17 	ldw	r2,-12(fp)
 2034d00:	e0ffff17 	ldw	r3,-4(fp)
 2034d04:	10c00615 	stw	r3,24(r2)
#ifdef TCP_ZEROCOPY
   if (so->rx_upcall)
      so->rx_upcall(so, NULL, err);
#endif   /* TCP_ZEROCOPY */
   return (tcp_close(tp));
 2034d08:	e13ffe17 	ldw	r4,-8(fp)
 2034d0c:	2034d240 	call	2034d24 <tcp_close>
}
 2034d10:	e037883a 	mov	sp,fp
 2034d14:	dfc00117 	ldw	ra,4(sp)
 2034d18:	df000017 	ldw	fp,0(sp)
 2034d1c:	dec00204 	addi	sp,sp,8
 2034d20:	f800283a 	ret

02034d24 <tcp_close>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_close(struct tcpcb * tp)
{
 2034d24:	defff904 	addi	sp,sp,-28
 2034d28:	dfc00615 	stw	ra,24(sp)
 2034d2c:	df000515 	stw	fp,20(sp)
 2034d30:	df000504 	addi	fp,sp,20
 2034d34:	e13fff15 	stw	r4,-4(fp)
   struct tcpiphdr * t;
   struct inpcb * inp   =  tp->t_inpcb;
 2034d38:	e0bfff17 	ldw	r2,-4(fp)
 2034d3c:	10800d17 	ldw	r2,52(r2)
 2034d40:	e0bffc15 	stw	r2,-16(fp)
   struct socket *   so =  inp->inp_socket;
 2034d44:	e0bffc17 	ldw	r2,-16(fp)
 2034d48:	10800817 	ldw	r2,32(r2)
 2034d4c:	e0bffd15 	stw	r2,-12(fp)
   struct mbuf *  m;

   t = tp->seg_next;
 2034d50:	e0bfff17 	ldw	r2,-4(fp)
 2034d54:	10800017 	ldw	r2,0(r2)
 2034d58:	e0bffb15 	stw	r2,-20(fp)
   while (t != (struct tcpiphdr *)tp) 
 2034d5c:	00000e06 	br	2034d98 <tcp_close+0x74>
   {
      t = (struct tcpiphdr *)t->ti_next;
 2034d60:	e0bffb17 	ldw	r2,-20(fp)
 2034d64:	10800017 	ldw	r2,0(r2)
 2034d68:	e0bffb15 	stw	r2,-20(fp)
      m = dtom(t->ti_prev);
 2034d6c:	e0bffb17 	ldw	r2,-20(fp)
 2034d70:	10800117 	ldw	r2,4(r2)
 2034d74:	1009883a 	mov	r4,r2
 2034d78:	2029bcc0 	call	2029bcc <dtom>
 2034d7c:	e0bffe15 	stw	r2,-8(fp)
      remque(t->ti_prev);
 2034d80:	e0bffb17 	ldw	r2,-20(fp)
 2034d84:	10800117 	ldw	r2,4(r2)
 2034d88:	1009883a 	mov	r4,r2
 2034d8c:	2029c680 	call	2029c68 <remque>
      m_freem (m);
 2034d90:	e13ffe17 	ldw	r4,-8(fp)
 2034d94:	20296780 	call	2029678 <m_freem>
   struct inpcb * inp   =  tp->t_inpcb;
   struct socket *   so =  inp->inp_socket;
   struct mbuf *  m;

   t = tp->seg_next;
   while (t != (struct tcpiphdr *)tp) 
 2034d98:	e0fffb17 	ldw	r3,-20(fp)
 2034d9c:	e0bfff17 	ldw	r2,-4(fp)
 2034da0:	18bfef1e 	bne	r3,r2,2034d60 <tcp_close+0x3c>
      t = (struct tcpiphdr *)t->ti_next;
      m = dtom(t->ti_prev);
      remque(t->ti_prev);
      m_freem (m);
   }
   if (tp->t_template)
 2034da4:	e0bfff17 	ldw	r2,-4(fp)
 2034da8:	10800c17 	ldw	r2,48(r2)
 2034dac:	10000426 	beq	r2,zero,2034dc0 <tcp_close+0x9c>
      TPH_FREE (tp->t_template);
 2034db0:	e0bfff17 	ldw	r2,-4(fp)
 2034db4:	10800c17 	ldw	r2,48(r2)
 2034db8:	1009883a 	mov	r4,r2
 2034dbc:	202912c0 	call	202912c <npfree>
   TCB_FREE (tp);
 2034dc0:	e13fff17 	ldw	r4,-4(fp)
 2034dc4:	202912c0 	call	202912c <npfree>
   inp->inp_ppcb = 0;
 2034dc8:	e0bffc17 	ldw	r2,-16(fp)
 2034dcc:	10000915 	stw	zero,36(r2)
   soisdisconnected(so);
 2034dd0:	e13ffd17 	ldw	r4,-12(fp)
 2034dd4:	202ed580 	call	202ed58 <soisdisconnected>
   in_pcbdetach(inp);
 2034dd8:	e13ffc17 	ldw	r4,-16(fp)
 2034ddc:	20485c00 	call	20485c0 <in_pcbdetach>
   tcpstat.tcps_closed++;
 2034de0:	00809934 	movhi	r2,612
 2034de4:	10b6f504 	addi	r2,r2,-9260
 2034de8:	10800517 	ldw	r2,20(r2)
 2034dec:	10c00044 	addi	r3,r2,1
 2034df0:	00809934 	movhi	r2,612
 2034df4:	10b6f504 	addi	r2,r2,-9260
 2034df8:	10c00515 	stw	r3,20(r2)
   return ((struct tcpcb *)0);
 2034dfc:	0005883a 	mov	r2,zero
}
 2034e00:	e037883a 	mov	sp,fp
 2034e04:	dfc00117 	ldw	ra,4(sp)
 2034e08:	df000017 	ldw	fp,0(sp)
 2034e0c:	dec00204 	addi	sp,sp,8
 2034e10:	f800283a 	ret

02034e14 <tcp_quench>:
 * RETURNS: 
 */

void
tcp_quench(struct inpcb * inp)
{
 2034e14:	defffd04 	addi	sp,sp,-12
 2034e18:	df000215 	stw	fp,8(sp)
 2034e1c:	df000204 	addi	fp,sp,8
 2034e20:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp =  intotcpcb(inp);
 2034e24:	e0bfff17 	ldw	r2,-4(fp)
 2034e28:	10800917 	ldw	r2,36(r2)
 2034e2c:	e0bffe15 	stw	r2,-8(fp)

   if (tp)
 2034e30:	e0bffe17 	ldw	r2,-8(fp)
 2034e34:	10000526 	beq	r2,zero,2034e4c <tcp_quench+0x38>
      tp->snd_cwnd = tp->t_maxseg;
 2034e38:	e0bffe17 	ldw	r2,-8(fp)
 2034e3c:	10800a0b 	ldhu	r2,40(r2)
 2034e40:	10ffffcc 	andi	r3,r2,65535
 2034e44:	e0bffe17 	ldw	r2,-8(fp)
 2034e48:	10c01b15 	stw	r3,108(r2)
}
 2034e4c:	e037883a 	mov	sp,fp
 2034e50:	df000017 	ldw	fp,0(sp)
 2034e54:	dec00104 	addi	sp,sp,4
 2034e58:	f800283a 	ret

02034e5c <tcp_putseq>:

/* tcp_putseq()  */

u_char *
tcp_putseq(u_char * cp, tcp_seq seq)
{
 2034e5c:	defffc04 	addi	sp,sp,-16
 2034e60:	df000315 	stw	fp,12(sp)
 2034e64:	df000304 	addi	fp,sp,12
 2034e68:	e13ffe15 	stw	r4,-8(fp)
 2034e6c:	e17fff15 	stw	r5,-4(fp)
   int   i;

   cp += 3;                /* do low byte first */
 2034e70:	e0bffe17 	ldw	r2,-8(fp)
 2034e74:	108000c4 	addi	r2,r2,3
 2034e78:	e0bffe15 	stw	r2,-8(fp)
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 2034e7c:	e03ffd15 	stw	zero,-12(fp)
 2034e80:	00000d06 	br	2034eb8 <tcp_putseq+0x5c>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
 2034e84:	e0bfff17 	ldw	r2,-4(fp)
 2034e88:	1007883a 	mov	r3,r2
 2034e8c:	e0bffe17 	ldw	r2,-8(fp)
 2034e90:	10c00005 	stb	r3,0(r2)
 2034e94:	e0bffe17 	ldw	r2,-8(fp)
 2034e98:	10bfffc4 	addi	r2,r2,-1
 2034e9c:	e0bffe15 	stw	r2,-8(fp)
      seq >>= 8;
 2034ea0:	e0bfff17 	ldw	r2,-4(fp)
 2034ea4:	1004d23a 	srli	r2,r2,8
 2034ea8:	e0bfff15 	stw	r2,-4(fp)
tcp_putseq(u_char * cp, tcp_seq seq)
{
   int   i;

   cp += 3;                /* do low byte first */
   for(i = 0; i< 4; i++)   /* put 4 bytes into buffer */
 2034eac:	e0bffd17 	ldw	r2,-12(fp)
 2034eb0:	10800044 	addi	r2,r2,1
 2034eb4:	e0bffd15 	stw	r2,-12(fp)
 2034eb8:	e0bffd17 	ldw	r2,-12(fp)
 2034ebc:	10800110 	cmplti	r2,r2,4
 2034ec0:	103ff01e 	bne	r2,zero,2034e84 <tcp_putseq+0x28>
   {
      *cp-- = (u_char)(seq & 0xFF);  /* back through buffer */
      seq >>= 8;
   }
   return (cp + 5);
 2034ec4:	e0bffe17 	ldw	r2,-8(fp)
 2034ec8:	10800144 	addi	r2,r2,5
}
 2034ecc:	e037883a 	mov	sp,fp
 2034ed0:	df000017 	ldw	fp,0(sp)
 2034ed4:	dec00104 	addi	sp,sp,4
 2034ed8:	f800283a 	ret

02034edc <tcp_getseq>:
 * RETURNS: a long in local endian
 */

u_long
tcp_getseq(u_char * cp)
{
 2034edc:	defffc04 	addi	sp,sp,-16
 2034ee0:	df000315 	stw	fp,12(sp)
 2034ee4:	df000304 	addi	fp,sp,12
 2034ee8:	e13fff15 	stw	r4,-4(fp)
   int i;
   ulong seq = 0;
 2034eec:	e03ffe15 	stw	zero,-8(fp)

   for(i = 0; i < 4; i++)
 2034ef0:	e03ffd15 	stw	zero,-12(fp)
 2034ef4:	00000f06 	br	2034f34 <tcp_getseq+0x58>
   {
      seq <<= 8;
 2034ef8:	e0bffe17 	ldw	r2,-8(fp)
 2034efc:	1004923a 	slli	r2,r2,8
 2034f00:	e0bffe15 	stw	r2,-8(fp)
      seq += (u_long)*(cp++);
 2034f04:	e0bfff17 	ldw	r2,-4(fp)
 2034f08:	10800003 	ldbu	r2,0(r2)
 2034f0c:	10803fcc 	andi	r2,r2,255
 2034f10:	e0fffe17 	ldw	r3,-8(fp)
 2034f14:	1885883a 	add	r2,r3,r2
 2034f18:	e0bffe15 	stw	r2,-8(fp)
 2034f1c:	e0bfff17 	ldw	r2,-4(fp)
 2034f20:	10800044 	addi	r2,r2,1
 2034f24:	e0bfff15 	stw	r2,-4(fp)
tcp_getseq(u_char * cp)
{
   int i;
   ulong seq = 0;

   for(i = 0; i < 4; i++)
 2034f28:	e0bffd17 	ldw	r2,-12(fp)
 2034f2c:	10800044 	addi	r2,r2,1
 2034f30:	e0bffd15 	stw	r2,-12(fp)
 2034f34:	e0bffd17 	ldw	r2,-12(fp)
 2034f38:	10800110 	cmplti	r2,r2,4
 2034f3c:	103fee1e 	bne	r2,zero,2034ef8 <tcp_getseq+0x1c>
   {
      seq <<= 8;
      seq += (u_long)*(cp++);
   }
   return seq;
 2034f40:	e0bffe17 	ldw	r2,-8(fp)
}
 2034f44:	e037883a 	mov	sp,fp
 2034f48:	df000017 	ldw	fp,0(sp)
 2034f4c:	dec00104 	addi	sp,sp,4
 2034f50:	f800283a 	ret

02034f54 <tcp_slowtimo>:
 * RETURNS: 
 */

void
tcp_slowtimo(void)
{
 2034f54:	defff704 	addi	sp,sp,-36
 2034f58:	dfc00815 	stw	ra,32(sp)
 2034f5c:	df000715 	stw	fp,28(sp)
 2034f60:	df000704 	addi	fp,sp,28
   struct tcpcb * tp;
   int   i;
   struct socket * so, * sonext;
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;
 2034f64:	d0a04517 	ldw	r2,-32492(gp)
 2034f68:	100490fa 	slli	r2,r2,3
 2034f6c:	d0a0ab15 	stw	r2,-32084(gp)

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 2034f70:	00809934 	movhi	r2,612
 2034f74:	10b6c204 	addi	r2,r2,-9464
 2034f78:	10800017 	ldw	r2,0(r2)
 2034f7c:	e0bffa15 	stw	r2,-24(fp)
 2034f80:	00008606 	br	203519c <tcp_slowtimo+0x248>
   {
      sonext = so->next;
 2034f84:	e0bffa17 	ldw	r2,-24(fp)
 2034f88:	10800017 	ldw	r2,0(r2)
 2034f8c:	e0bffb15 	stw	r2,-20(fp)

      /* for SOCK_STREAM (TCP) sockets, we must do slow-timeout 
       * processing and (optionally) processing of pending 
       * zero-copy socket upcalls.
       */
      if (so->so_type == SOCK_STREAM)
 2034f90:	e0bffa17 	ldw	r2,-24(fp)
 2034f94:	10800983 	ldbu	r2,38(r2)
 2034f98:	10803fcc 	andi	r2,r2,255
 2034f9c:	1080201c 	xori	r2,r2,128
 2034fa0:	10bfe004 	addi	r2,r2,-128
 2034fa4:	10800058 	cmpnei	r2,r2,1
 2034fa8:	1000461e 	bne	r2,zero,20350c4 <tcp_slowtimo+0x170>
      {
         ip = so->so_pcb;
 2034fac:	e0bffa17 	ldw	r2,-24(fp)
 2034fb0:	10800117 	ldw	r2,4(r2)
 2034fb4:	e0bffc15 	stw	r2,-16(fp)
         if (!ip)
 2034fb8:	e0bffc17 	ldw	r2,-16(fp)
 2034fbc:	10007026 	beq	r2,zero,2035180 <tcp_slowtimo+0x22c>
            continue;
         ipnxt = ip->inp_next;
 2034fc0:	e0bffc17 	ldw	r2,-16(fp)
 2034fc4:	10800017 	ldw	r2,0(r2)
 2034fc8:	e0bffd15 	stw	r2,-12(fp)

         tp = intotcpcb(so->so_pcb);
 2034fcc:	e0bffa17 	ldw	r2,-24(fp)
 2034fd0:	10800117 	ldw	r2,4(r2)
 2034fd4:	10800917 	ldw	r2,36(r2)
 2034fd8:	e0bffe15 	stw	r2,-8(fp)
         if (!tp)
 2034fdc:	e0bffe17 	ldw	r2,-8(fp)
 2034fe0:	10006926 	beq	r2,zero,2035188 <tcp_slowtimo+0x234>
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 2034fe4:	e03ff915 	stw	zero,-28(fp)
 2034fe8:	00002e06 	br	20350a4 <tcp_slowtimo+0x150>
         {
            if (tp->t_timer[i] && --tp->t_timer[i] == 0) 
 2034fec:	e0fffe17 	ldw	r3,-8(fp)
 2034ff0:	e0bff917 	ldw	r2,-28(fp)
 2034ff4:	108000c4 	addi	r2,r2,3
 2034ff8:	1085883a 	add	r2,r2,r2
 2034ffc:	1085883a 	add	r2,r2,r2
 2035000:	1885883a 	add	r2,r3,r2
 2035004:	10800017 	ldw	r2,0(r2)
 2035008:	10002326 	beq	r2,zero,2035098 <tcp_slowtimo+0x144>
 203500c:	e0fffe17 	ldw	r3,-8(fp)
 2035010:	e0bff917 	ldw	r2,-28(fp)
 2035014:	108000c4 	addi	r2,r2,3
 2035018:	1085883a 	add	r2,r2,r2
 203501c:	1085883a 	add	r2,r2,r2
 2035020:	1885883a 	add	r2,r3,r2
 2035024:	10800017 	ldw	r2,0(r2)
 2035028:	10ffffc4 	addi	r3,r2,-1
 203502c:	e13ffe17 	ldw	r4,-8(fp)
 2035030:	e0bff917 	ldw	r2,-28(fp)
 2035034:	108000c4 	addi	r2,r2,3
 2035038:	1085883a 	add	r2,r2,r2
 203503c:	1085883a 	add	r2,r2,r2
 2035040:	2085883a 	add	r2,r4,r2
 2035044:	10c00015 	stw	r3,0(r2)
 2035048:	e0fffe17 	ldw	r3,-8(fp)
 203504c:	e0bff917 	ldw	r2,-28(fp)
 2035050:	108000c4 	addi	r2,r2,3
 2035054:	1085883a 	add	r2,r2,r2
 2035058:	1085883a 	add	r2,r2,r2
 203505c:	1885883a 	add	r2,r3,r2
 2035060:	10800017 	ldw	r2,0(r2)
 2035064:	10000c1e 	bne	r2,zero,2035098 <tcp_slowtimo+0x144>
            {
               /* call usrreq to do actual work */
               so->so_req = PRU_SLOWTIMO;
 2035068:	e0bffa17 	ldw	r2,-24(fp)
 203506c:	00c004c4 	movi	r3,19
 2035070:	10c00715 	stw	r3,28(r2)
               (void) tcp_usrreq(so, (struct mbuf *)0, 
 2035074:	e0bff917 	ldw	r2,-28(fp)
 2035078:	e13ffa17 	ldw	r4,-24(fp)
 203507c:	000b883a 	mov	r5,zero
 2035080:	100d883a 	mov	r6,r2
 2035084:	20356a40 	call	20356a4 <tcp_usrreq>
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
 2035088:	e0bffd17 	ldw	r2,-12(fp)
 203508c:	10c00117 	ldw	r3,4(r2)
 2035090:	e0bffc17 	ldw	r2,-16(fp)
 2035094:	18803e1e 	bne	r3,r2,2035190 <tcp_slowtimo+0x23c>

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;

         for (i = 0; i < TCPT_NTIMERS; i++) 
 2035098:	e0bff917 	ldw	r2,-28(fp)
 203509c:	10800044 	addi	r2,r2,1
 20350a0:	e0bff915 	stw	r2,-28(fp)
 20350a4:	e0bff917 	ldw	r2,-28(fp)
 20350a8:	10800110 	cmplti	r2,r2,4
 20350ac:	103fcf1e 	bne	r2,zero,2034fec <tcp_slowtimo+0x98>
               }
            }
         }
#endif   /* TCP_ZEROCOPY */

         tp->t_idle++;
 20350b0:	e0bffe17 	ldw	r2,-8(fp)
 20350b4:	10801d17 	ldw	r2,116(r2)
 20350b8:	10c00044 	addi	r3,r2,1
 20350bc:	e0bffe17 	ldw	r2,-8(fp)
 20350c0:	10c01d15 	stw	r3,116(r2)
      }

      /* wake up anyone sleeping in a select() involving this socket */
      sb = &so->so_rcv;
 20350c4:	e0bffa17 	ldw	r2,-24(fp)
 20350c8:	10800a04 	addi	r2,r2,40
 20350cc:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 20350d0:	e0bfff17 	ldw	r2,-4(fp)
 20350d4:	1080070b 	ldhu	r2,28(r2)
 20350d8:	10bfffcc 	andi	r2,r2,65535
 20350dc:	1080020c 	andi	r2,r2,8
 20350e0:	10000d26 	beq	r2,zero,2035118 <tcp_slowtimo+0x1c4>
      {
         select_wait = 0;
 20350e4:	00808174 	movhi	r2,517
 20350e8:	1090d104 	addi	r2,r2,17220
 20350ec:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 20350f0:	01008174 	movhi	r4,517
 20350f4:	2110d104 	addi	r4,r4,17220
 20350f8:	20276980 	call	2027698 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 20350fc:	e0bfff17 	ldw	r2,-4(fp)
 2035100:	10c0070b 	ldhu	r3,28(r2)
 2035104:	00bffdc4 	movi	r2,-9
 2035108:	1884703a 	and	r2,r3,r2
 203510c:	1007883a 	mov	r3,r2
 2035110:	e0bfff17 	ldw	r2,-4(fp)
 2035114:	10c0070d 	sth	r3,28(r2)
      }
      sb = &so->so_snd;
 2035118:	e0bffa17 	ldw	r2,-24(fp)
 203511c:	10801204 	addi	r2,r2,72
 2035120:	e0bfff15 	stw	r2,-4(fp)
      if (sb->sb_flags & SB_SEL) 
 2035124:	e0bfff17 	ldw	r2,-4(fp)
 2035128:	1080070b 	ldhu	r2,28(r2)
 203512c:	10bfffcc 	andi	r2,r2,65535
 2035130:	1080020c 	andi	r2,r2,8
 2035134:	10000d26 	beq	r2,zero,203516c <tcp_slowtimo+0x218>
      {
         select_wait = 0;         
 2035138:	00808174 	movhi	r2,517
 203513c:	1090d104 	addi	r2,r2,17220
 2035140:	1000000d 	sth	zero,0(r2)
#ifndef SOCK_MAP_EVENTS
         tcp_wakeup ((char *)&select_wait);
 2035144:	01008174 	movhi	r4,517
 2035148:	2110d104 	addi	r4,r4,17220
 203514c:	20276980 	call	2027698 <tcp_wakeup>
#else
         tcp_wakeup2 (so->owner);
#endif
         sb->sb_flags &= ~SB_SEL;
 2035150:	e0bfff17 	ldw	r2,-4(fp)
 2035154:	10c0070b 	ldhu	r3,28(r2)
 2035158:	00bffdc4 	movi	r2,-9
 203515c:	1884703a 	and	r2,r3,r2
 2035160:	1007883a 	mov	r3,r2
 2035164:	e0bfff17 	ldw	r2,-4(fp)
 2035168:	10c0070d 	sth	r3,28(r2)
      }

      /* wake any thread with a timer going for a connection state change */     
      tcp_wakeup((char*)&so->so_timeo);
 203516c:	e0bffa17 	ldw	r2,-24(fp)
 2035170:	10800904 	addi	r2,r2,36
 2035174:	1009883a 	mov	r4,r2
 2035178:	20276980 	call	2027698 <tcp_wakeup>
 203517c:	00000506 	br	2035194 <tcp_slowtimo+0x240>
       */
      if (so->so_type == SOCK_STREAM)
      {
         ip = so->so_pcb;
         if (!ip)
            continue;
 2035180:	0001883a 	nop
 2035184:	00000306 	br	2035194 <tcp_slowtimo+0x240>
         ipnxt = ip->inp_next;

         tp = intotcpcb(so->so_pcb);
         if (!tp)
            continue;
 2035188:	0001883a 	nop
 203518c:	00000106 	br	2035194 <tcp_slowtimo+0x240>
               (void) tcp_usrreq(so, (struct mbuf *)0, 
                                 LONG2MBUF((long)i));

               /* If ip disappeared on us, handle it */
               if (ipnxt->inp_prev != ip)
                  goto tpgone;
 2035190:	0001883a 	nop
   struct sockbuf *  sb;

   tcp_maxidle = TCPTV_KEEPCNT * tcp_keepintvl;

   /* search through open sockets */
   for (so = (struct socket *)soq.q_head; so != NULL; so = sonext)
 2035194:	e0bffb17 	ldw	r2,-20(fp)
 2035198:	e0bffa15 	stw	r2,-24(fp)
 203519c:	e0bffa17 	ldw	r2,-24(fp)
 20351a0:	103f781e 	bne	r2,zero,2034f84 <tcp_slowtimo+0x30>

tpgone:
      ;
   }

   tcp_iss += (unsigned)(TCP_ISSINCR/PR_SLOWHZ);      /* increment iss */
 20351a4:	d0e0ac17 	ldw	r3,-32080(gp)
 20351a8:	00be9fd4 	movui	r2,64127
 20351ac:	1885883a 	add	r2,r3,r2
 20351b0:	d0a0ac15 	stw	r2,-32080(gp)

   if (tcp_iss & 0xff000000)
 20351b4:	d0a0ac17 	ldw	r2,-32080(gp)
 20351b8:	10bfc02c 	andhi	r2,r2,65280
 20351bc:	10000126 	beq	r2,zero,20351c4 <tcp_slowtimo+0x270>
      tcp_iss = 0L;
 20351c0:	d020ac15 	stw	zero,-32080(gp)
}
 20351c4:	e037883a 	mov	sp,fp
 20351c8:	dfc00117 	ldw	ra,4(sp)
 20351cc:	df000017 	ldw	fp,0(sp)
 20351d0:	dec00204 	addi	sp,sp,8
 20351d4:	f800283a 	ret

020351d8 <tcp_canceltimers>:
 * RETURNS: 
 */

void
tcp_canceltimers(struct tcpcb * tp)
{
 20351d8:	defffd04 	addi	sp,sp,-12
 20351dc:	df000215 	stw	fp,8(sp)
 20351e0:	df000204 	addi	fp,sp,8
 20351e4:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 20351e8:	e03ffe15 	stw	zero,-8(fp)
 20351ec:	00000a06 	br	2035218 <tcp_canceltimers+0x40>
      tp->t_timer[i] = 0;
 20351f0:	e0ffff17 	ldw	r3,-4(fp)
 20351f4:	e0bffe17 	ldw	r2,-8(fp)
 20351f8:	108000c4 	addi	r2,r2,3
 20351fc:	1085883a 	add	r2,r2,r2
 2035200:	1085883a 	add	r2,r2,r2
 2035204:	1885883a 	add	r2,r3,r2
 2035208:	10000015 	stw	zero,0(r2)
void
tcp_canceltimers(struct tcpcb * tp)
{
   int   i;

   for (i = 0; i < TCPT_NTIMERS; i++)
 203520c:	e0bffe17 	ldw	r2,-8(fp)
 2035210:	10800044 	addi	r2,r2,1
 2035214:	e0bffe15 	stw	r2,-8(fp)
 2035218:	e0bffe17 	ldw	r2,-8(fp)
 203521c:	10800110 	cmplti	r2,r2,4
 2035220:	103ff31e 	bne	r2,zero,20351f0 <tcp_canceltimers+0x18>
      tp->t_timer[i] = 0;
}
 2035224:	e037883a 	mov	sp,fp
 2035228:	df000017 	ldw	fp,0(sp)
 203522c:	dec00104 	addi	sp,sp,4
 2035230:	f800283a 	ret

02035234 <tcp_timers>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_timers(struct tcpcb * tp, int timer)
{
 2035234:	defff804 	addi	sp,sp,-32
 2035238:	dfc00715 	stw	ra,28(sp)
 203523c:	df000615 	stw	fp,24(sp)
 2035240:	df000604 	addi	fp,sp,24
 2035244:	e13ffe15 	stw	r4,-8(fp)
 2035248:	e17fff15 	stw	r5,-4(fp)
   int   rexmt;

   switch (timer) 
 203524c:	e0bfff17 	ldw	r2,-4(fp)
 2035250:	10c00060 	cmpeqi	r3,r2,1
 2035254:	1800af1e 	bne	r3,zero,2035514 <tcp_timers+0x2e0>
 2035258:	10c00088 	cmpgei	r3,r2,2
 203525c:	1800021e 	bne	r3,zero,2035268 <tcp_timers+0x34>
 2035260:	10001826 	beq	r2,zero,20352c4 <tcp_timers+0x90>
 2035264:	00010906 	br	203568c <tcp_timers+0x458>
 2035268:	10c000a0 	cmpeqi	r3,r2,2
 203526c:	1800ba1e 	bne	r3,zero,2035558 <tcp_timers+0x324>
 2035270:	108000e0 	cmpeqi	r2,r2,3
 2035274:	10010526 	beq	r2,zero,203568c <tcp_timers+0x458>
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 2035278:	e0bffe17 	ldw	r2,-8(fp)
 203527c:	10800217 	ldw	r2,8(r2)
 2035280:	108002a0 	cmpeqi	r2,r2,10
 2035284:	10000b1e 	bne	r2,zero,20352b4 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
 2035288:	e0bffe17 	ldw	r2,-8(fp)
 203528c:	10801d17 	ldw	r2,116(r2)
 2035290:	d0e0ab17 	ldw	r3,-32084(gp)
    * still waiting for peer to close and connection has been idle
    * too long, or if 2MSL time is up from TIME_WAIT, delete connection
    * control block.  Otherwise, check again in a bit.
    */
   case TCPT_2MSL:
      if (tp->t_state != TCPS_TIME_WAIT &&
 2035294:	18800716 	blt	r3,r2,20352b4 <tcp_timers+0x80>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
 2035298:	d0a04517 	ldw	r2,-32492(gp)
 203529c:	10ffffcc 	andi	r3,r2,65535
 20352a0:	18e0001c 	xori	r3,r3,32768
 20352a4:	18e00004 	addi	r3,r3,-32768
 20352a8:	e0bffe17 	ldw	r2,-8(fp)
 20352ac:	10c00615 	stw	r3,24(r2)
      }
      else
         tp = tcp_close(tp);
      break;
 20352b0:	0000f606 	br	203568c <tcp_timers+0x458>
          tp->t_idle <= tcp_maxidle)
      {
         tp->t_timer[TCPT_2MSL] = (short)tcp_keepintvl;
      }
      else
         tp = tcp_close(tp);
 20352b4:	e13ffe17 	ldw	r4,-8(fp)
 20352b8:	2034d240 	call	2034d24 <tcp_close>
 20352bc:	e0bffe15 	stw	r2,-8(fp)
      break;
 20352c0:	0000f206 	br	203568c <tcp_timers+0x458>
    * Retransmission timer went off.  Message has not
    * been acked within retransmit interval.  Back off
    * to a longer retransmit interval and retransmit one segment.
    */
   case TCPT_REXMT:
      TCP_MIB_INC(tcpRetransSegs);     /* keep MIB stats */
 20352c4:	00809934 	movhi	r2,612
 20352c8:	10b6c704 	addi	r2,r2,-9444
 20352cc:	10800b17 	ldw	r2,44(r2)
 20352d0:	10c00044 	addi	r3,r2,1
 20352d4:	00809934 	movhi	r2,612
 20352d8:	10b6c704 	addi	r2,r2,-9444
 20352dc:	10c00b15 	stw	r3,44(r2)
      if (++tp->t_rxtshift > TCP_MAXRXTSHIFT) 
 20352e0:	e0bffe17 	ldw	r2,-8(fp)
 20352e4:	10800717 	ldw	r2,28(r2)
 20352e8:	10c00044 	addi	r3,r2,1
 20352ec:	e0bffe17 	ldw	r2,-8(fp)
 20352f0:	10c00715 	stw	r3,28(r2)
 20352f4:	e0bffe17 	ldw	r2,-8(fp)
 20352f8:	10800717 	ldw	r2,28(r2)
 20352fc:	10800350 	cmplti	r2,r2,13
 2035300:	10000f1e 	bne	r2,zero,2035340 <tcp_timers+0x10c>
      {
         tp->t_rxtshift = TCP_MAXRXTSHIFT;
 2035304:	e0bffe17 	ldw	r2,-8(fp)
 2035308:	00c00304 	movi	r3,12
 203530c:	10c00715 	stw	r3,28(r2)
         tcpstat.tcps_timeoutdrop++;
 2035310:	00809934 	movhi	r2,612
 2035314:	10b6f504 	addi	r2,r2,-9260
 2035318:	10800917 	ldw	r2,36(r2)
 203531c:	10c00044 	addi	r3,r2,1
 2035320:	00809934 	movhi	r2,612
 2035324:	10b6f504 	addi	r2,r2,-9260
 2035328:	10c00915 	stw	r3,36(r2)
         tp = tcp_drop(tp, ETIMEDOUT);
 203532c:	e13ffe17 	ldw	r4,-8(fp)
 2035330:	01401d04 	movi	r5,116
 2035334:	2034c780 	call	2034c78 <tcp_drop>
 2035338:	e0bffe15 	stw	r2,-8(fp)
         break;
 203533c:	0000d306 	br	203568c <tcp_timers+0x458>
      }
      tcpstat.tcps_rexmttimeo++;
 2035340:	00809934 	movhi	r2,612
 2035344:	10b6f504 	addi	r2,r2,-9260
 2035348:	10800a17 	ldw	r2,40(r2)
 203534c:	10c00044 	addi	r3,r2,1
 2035350:	00809934 	movhi	r2,612
 2035354:	10b6f504 	addi	r2,r2,-9260
 2035358:	10c00a15 	stw	r3,40(r2)
      rexmt = ((tp->t_srtt >> 2) + tp->t_rttvar) >> 1;
 203535c:	e0bffe17 	ldw	r2,-8(fp)
 2035360:	10802017 	ldw	r2,128(r2)
 2035364:	1007d0ba 	srai	r3,r2,2
 2035368:	e0bffe17 	ldw	r2,-8(fp)
 203536c:	10802117 	ldw	r2,132(r2)
 2035370:	1885883a 	add	r2,r3,r2
 2035374:	1005d07a 	srai	r2,r2,1
 2035378:	e0bffd15 	stw	r2,-12(fp)
      rexmt *= tcp_backoff[tp->t_rxtshift];
 203537c:	e0bffe17 	ldw	r2,-8(fp)
 2035380:	10800717 	ldw	r2,28(r2)
 2035384:	00c08174 	movhi	r3,517
 2035388:	18cf10c4 	addi	r3,r3,15427
 203538c:	1885883a 	add	r2,r3,r2
 2035390:	10800003 	ldbu	r2,0(r2)
 2035394:	10803fcc 	andi	r2,r2,255
 2035398:	e0fffd17 	ldw	r3,-12(fp)
 203539c:	1885383a 	mul	r2,r3,r2
 20353a0:	e0bffd15 	stw	r2,-12(fp)
      TCPT_RANGESET(tp->t_rxtcur, rexmt, TCPTV_MIN, TCPTV_REXMTMAX);
 20353a4:	e0bffd17 	ldw	r2,-12(fp)
 20353a8:	10ffffcc 	andi	r3,r2,65535
 20353ac:	18e0001c 	xori	r3,r3,32768
 20353b0:	18e00004 	addi	r3,r3,-32768
 20353b4:	e0bffe17 	ldw	r2,-8(fp)
 20353b8:	10c00815 	stw	r3,32(r2)
 20353bc:	e0bffe17 	ldw	r2,-8(fp)
 20353c0:	10800817 	ldw	r2,32(r2)
 20353c4:	10800088 	cmpgei	r2,r2,2
 20353c8:	1000041e 	bne	r2,zero,20353dc <tcp_timers+0x1a8>
 20353cc:	e0bffe17 	ldw	r2,-8(fp)
 20353d0:	00c00084 	movi	r3,2
 20353d4:	10c00815 	stw	r3,32(r2)
 20353d8:	00000706 	br	20353f8 <tcp_timers+0x1c4>
 20353dc:	e0bffe17 	ldw	r2,-8(fp)
 20353e0:	10800817 	ldw	r2,32(r2)
 20353e4:	10802050 	cmplti	r2,r2,129
 20353e8:	1000031e 	bne	r2,zero,20353f8 <tcp_timers+0x1c4>
 20353ec:	e0bffe17 	ldw	r2,-8(fp)
 20353f0:	00c02004 	movi	r3,128
 20353f4:	10c00815 	stw	r3,32(r2)
      tp->t_timer[TCPT_REXMT] = tp->t_rxtcur;
 20353f8:	e0bffe17 	ldw	r2,-8(fp)
 20353fc:	10c00817 	ldw	r3,32(r2)
 2035400:	e0bffe17 	ldw	r2,-8(fp)
 2035404:	10c00315 	stw	r3,12(r2)
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 2035408:	e0bffe17 	ldw	r2,-8(fp)
 203540c:	10800717 	ldw	r2,28(r2)
 2035410:	10800110 	cmplti	r2,r2,4
 2035414:	10000f1e 	bne	r2,zero,2035454 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
 2035418:	e0bffe17 	ldw	r2,-8(fp)
 203541c:	10800b0b 	ldhu	r2,44(r2)
 2035420:	10bfffcc 	andi	r2,r2,65535
 2035424:	1080400c 	andi	r2,r2,256
       * so we'll take the next rtt measurement as our srtt;
       * move the current srtt into rttvar to keep the current
       * retransmit times until then. Don't clobber with rtt
       * if we got it from a timestamp option.
       */
      if((tp->t_rxtshift > TCP_MAXRXTSHIFT / 4) &&
 2035428:	10000a1e 	bne	r2,zero,2035454 <tcp_timers+0x220>
         ((tp->t_flags & TF_TIMESTAMP) == 0))
      {
         tp->t_rttvar += (tp->t_srtt >> 2);
 203542c:	e0bffe17 	ldw	r2,-8(fp)
 2035430:	10c02117 	ldw	r3,132(r2)
 2035434:	e0bffe17 	ldw	r2,-8(fp)
 2035438:	10802017 	ldw	r2,128(r2)
 203543c:	1005d0ba 	srai	r2,r2,2
 2035440:	1887883a 	add	r3,r3,r2
 2035444:	e0bffe17 	ldw	r2,-8(fp)
 2035448:	10c02115 	stw	r3,132(r2)
         tp->t_srtt = 0;
 203544c:	e0bffe17 	ldw	r2,-8(fp)
 2035450:	10002015 	stw	zero,128(r2)
      }
      tp->snd_nxt = tp->snd_una;
 2035454:	e0bffe17 	ldw	r2,-8(fp)
 2035458:	10c00e17 	ldw	r3,56(r2)
 203545c:	e0bffe17 	ldw	r2,-8(fp)
 2035460:	10c00f15 	stw	r3,60(r2)
      /*
       * If timing a segment in this window, stop the timer.
       */
      tp->t_rttick = 0;
 2035464:	e0bffe17 	ldw	r2,-8(fp)
 2035468:	10001e15 	stw	zero,120(r2)
       * to go below this.)
       *
       * Vers 1.9 - Skip slow start if the SO_NOSLOWSTART socket option
       * is set.
       */
      if((tp->t_inpcb->inp_socket->so_options & SO_NOSLOWSTART) == 0)
 203546c:	e0bffe17 	ldw	r2,-8(fp)
 2035470:	10800d17 	ldw	r2,52(r2)
 2035474:	10800817 	ldw	r2,32(r2)
 2035478:	10800417 	ldw	r2,16(r2)
 203547c:	1090000c 	andi	r2,r2,16384
 2035480:	1000211e 	bne	r2,zero,2035508 <tcp_timers+0x2d4>
      {
         u_int win = MIN(tp->snd_wnd, tp->snd_cwnd);
 2035484:	e0bffe17 	ldw	r2,-8(fp)
 2035488:	10801417 	ldw	r2,80(r2)
 203548c:	e0fffe17 	ldw	r3,-8(fp)
 2035490:	18c01b17 	ldw	r3,108(r3)
 2035494:	1880012e 	bgeu	r3,r2,203549c <tcp_timers+0x268>
 2035498:	1805883a 	mov	r2,r3
 203549c:	e0bffc15 	stw	r2,-16(fp)
         win = win / 2 / tp->t_maxseg;
 20354a0:	e0bffc17 	ldw	r2,-16(fp)
 20354a4:	1006d07a 	srli	r3,r2,1
 20354a8:	e0bffe17 	ldw	r2,-8(fp)
 20354ac:	10800a0b 	ldhu	r2,40(r2)
 20354b0:	10bfffcc 	andi	r2,r2,65535
 20354b4:	1885203a 	divu	r2,r3,r2
 20354b8:	e0bffc15 	stw	r2,-16(fp)
         if (win < 2)
 20354bc:	e0bffc17 	ldw	r2,-16(fp)
 20354c0:	108000a8 	cmpgeui	r2,r2,2
 20354c4:	1000021e 	bne	r2,zero,20354d0 <tcp_timers+0x29c>
            win = 2;
 20354c8:	00800084 	movi	r2,2
 20354cc:	e0bffc15 	stw	r2,-16(fp)
         tp->snd_cwnd = tp->t_maxseg;
 20354d0:	e0bffe17 	ldw	r2,-8(fp)
 20354d4:	10800a0b 	ldhu	r2,40(r2)
 20354d8:	10ffffcc 	andi	r3,r2,65535
 20354dc:	e0bffe17 	ldw	r2,-8(fp)
 20354e0:	10c01b15 	stw	r3,108(r2)
         tp->snd_ssthresh = (u_short)win * tp->t_maxseg;
 20354e4:	e0bffc17 	ldw	r2,-16(fp)
 20354e8:	10ffffcc 	andi	r3,r2,65535
 20354ec:	e0bffe17 	ldw	r2,-8(fp)
 20354f0:	10800a0b 	ldhu	r2,40(r2)
 20354f4:	10bfffcc 	andi	r2,r2,65535
 20354f8:	1885383a 	mul	r2,r3,r2
 20354fc:	1007883a 	mov	r3,r2
 2035500:	e0bffe17 	ldw	r2,-8(fp)
 2035504:	10c01c15 	stw	r3,112(r2)
      }
      (void) tcp_output(tp);
 2035508:	e13ffe17 	ldw	r4,-8(fp)
 203550c:	20334200 	call	2033420 <tcp_output>
      break;
 2035510:	00005e06 	br	203568c <tcp_timers+0x458>
   /*
    * Persistance timer into zero window.
    * Force a byte to be output, if possible.
    */
   case TCPT_PERSIST:
      tcpstat.tcps_persisttimeo++;
 2035514:	00809934 	movhi	r2,612
 2035518:	10b6f504 	addi	r2,r2,-9260
 203551c:	10800b17 	ldw	r2,44(r2)
 2035520:	10c00044 	addi	r3,r2,1
 2035524:	00809934 	movhi	r2,612
 2035528:	10b6f504 	addi	r2,r2,-9260
 203552c:	10c00b15 	stw	r3,44(r2)
      tcp_setpersist(tp);
 2035530:	e13ffe17 	ldw	r4,-8(fp)
 2035534:	203443c0 	call	203443c <tcp_setpersist>
      tp->t_force = 1;
 2035538:	e0bffe17 	ldw	r2,-8(fp)
 203553c:	00c00044 	movi	r3,1
 2035540:	10c00a85 	stb	r3,42(r2)
      (void) tcp_output(tp);
 2035544:	e13ffe17 	ldw	r4,-8(fp)
 2035548:	20334200 	call	2033420 <tcp_output>
      tp->t_force = 0;
 203554c:	e0bffe17 	ldw	r2,-8(fp)
 2035550:	10000a85 	stb	zero,42(r2)
      break;
 2035554:	00004d06 	br	203568c <tcp_timers+0x458>
   /*
    * Keep-alive timer went off; send something
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
 2035558:	00809934 	movhi	r2,612
 203555c:	10b6f504 	addi	r2,r2,-9260
 2035560:	10800c17 	ldw	r2,48(r2)
 2035564:	10c00044 	addi	r3,r2,1
 2035568:	00809934 	movhi	r2,612
 203556c:	10b6f504 	addi	r2,r2,-9260
 2035570:	10c00c15 	stw	r3,48(r2)
      if (tp->t_state < TCPS_ESTABLISHED)
 2035574:	e0bffe17 	ldw	r2,-8(fp)
 2035578:	10800217 	ldw	r2,8(r2)
 203557c:	10800108 	cmpgei	r2,r2,4
 2035580:	10003326 	beq	r2,zero,2035650 <tcp_timers+0x41c>
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 2035584:	e0bffe17 	ldw	r2,-8(fp)
 2035588:	10800d17 	ldw	r2,52(r2)
 203558c:	10800817 	ldw	r2,32(r2)
 2035590:	10800417 	ldw	r2,16(r2)
 2035594:	1080020c 	andi	r2,r2,8
 2035598:	10002626 	beq	r2,zero,2035634 <tcp_timers+0x400>
          tp->t_state <= TCPS_CLOSE_WAIT) 
 203559c:	e0bffe17 	ldw	r2,-8(fp)
 20355a0:	10800217 	ldw	r2,8(r2)
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
 20355a4:	10800188 	cmpgei	r2,r2,6
 20355a8:	1000221e 	bne	r2,zero,2035634 <tcp_timers+0x400>
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
 20355ac:	e0bffe17 	ldw	r2,-8(fp)
 20355b0:	10c01d17 	ldw	r3,116(r2)
 20355b4:	d1204417 	ldw	r4,-32496(gp)
 20355b8:	d0a0ab17 	ldw	r2,-32084(gp)
 20355bc:	2085883a 	add	r2,r4,r2
 20355c0:	1880250e 	bge	r3,r2,2035658 <tcp_timers+0x424>
          * causes the transmitted zero-length segment
          * to lie outside the receive window;
          * by the protocol spec, this requires the
          * correspondent TCP to respond.
          */
         tcpstat.tcps_keepprobe++;
 20355c4:	00809934 	movhi	r2,612
 20355c8:	10b6f504 	addi	r2,r2,-9260
 20355cc:	10800d17 	ldw	r2,52(r2)
 20355d0:	10c00044 	addi	r3,r2,1
 20355d4:	00809934 	movhi	r2,612
 20355d8:	10b6f504 	addi	r2,r2,-9260
 20355dc:	10c00d15 	stw	r3,52(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 20355e0:	e0bffe17 	ldw	r2,-8(fp)
 20355e4:	11400c17 	ldw	r5,48(r2)
 20355e8:	e0bffe17 	ldw	r2,-8(fp)
 20355ec:	10801617 	ldw	r2,88(r2)
 20355f0:	10ffffc4 	addi	r3,r2,-1
            tp->snd_una - 1, 0, (struct mbuf *)NULL);
 20355f4:	e0bffe17 	ldw	r2,-8(fp)
 20355f8:	10800e17 	ldw	r2,56(r2)

         /*
          * The keepalive packet must have nonzero length
          * to get a 4.2 host to respond.
          */
         tcp_respond(tp, tp->t_template, tp->rcv_nxt - 1,
 20355fc:	10bfffc4 	addi	r2,r2,-1
 2035600:	d8000015 	stw	zero,0(sp)
 2035604:	d8000115 	stw	zero,4(sp)
 2035608:	e13ffe17 	ldw	r4,-8(fp)
 203560c:	180d883a 	mov	r6,r3
 2035610:	100f883a 	mov	r7,r2
 2035614:	20347600 	call	2034760 <tcp_respond>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
 2035618:	d0a04517 	ldw	r2,-32492(gp)
 203561c:	10ffffcc 	andi	r3,r2,65535
 2035620:	18e0001c 	xori	r3,r3,32768
 2035624:	18e00004 	addi	r3,r3,-32768
 2035628:	e0bffe17 	ldw	r2,-8(fp)
 203562c:	10c00515 	stw	r3,20(r2)
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
 2035630:	00001606 	br	203568c <tcp_timers+0x458>
            tp->snd_una - 1, 0, (struct mbuf *)NULL);

         tp->t_timer[TCPT_KEEP] = (short)tcp_keepintvl;
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
 2035634:	d0a04417 	ldw	r2,-32496(gp)
 2035638:	10ffffcc 	andi	r3,r2,65535
 203563c:	18e0001c 	xori	r3,r3,32768
 2035640:	18e00004 	addi	r3,r3,-32768
 2035644:	e0bffe17 	ldw	r2,-8(fp)
 2035648:	10c00515 	stw	r3,20(r2)
      break;
 203564c:	00000f06 	br	203568c <tcp_timers+0x458>
    * or drop connection if idle for too long.
    */
   case TCPT_KEEP:
      tcpstat.tcps_keeptimeo++;
      if (tp->t_state < TCPS_ESTABLISHED)
         goto dropit;
 2035650:	0001883a 	nop
 2035654:	00000106 	br	203565c <tcp_timers+0x428>
      if (tp->t_inpcb->inp_socket->so_options & SO_KEEPALIVE &&
          tp->t_state <= TCPS_CLOSE_WAIT) 
      {
         if (tp->t_idle >= tcp_keepidle + tcp_maxidle)
            goto dropit;
 2035658:	0001883a 	nop
      }
      else
         tp->t_timer[TCPT_KEEP] = (short)tcp_keepidle;
      break;
      dropit:
      tcpstat.tcps_keepdrops++;
 203565c:	00809934 	movhi	r2,612
 2035660:	10b6f504 	addi	r2,r2,-9260
 2035664:	10800e17 	ldw	r2,56(r2)
 2035668:	10c00044 	addi	r3,r2,1
 203566c:	00809934 	movhi	r2,612
 2035670:	10b6f504 	addi	r2,r2,-9260
 2035674:	10c00e15 	stw	r3,56(r2)
      tp = tcp_drop (tp, ETIMEDOUT);
 2035678:	e13ffe17 	ldw	r4,-8(fp)
 203567c:	01401d04 	movi	r5,116
 2035680:	2034c780 	call	2034c78 <tcp_drop>
 2035684:	e0bffe15 	stw	r2,-8(fp)
      break;
 2035688:	0001883a 	nop
   }
   return tp;
 203568c:	e0bffe17 	ldw	r2,-8(fp)
}
 2035690:	e037883a 	mov	sp,fp
 2035694:	dfc00117 	ldw	ra,4(sp)
 2035698:	df000017 	ldw	fp,0(sp)
 203569c:	dec00204 	addi	sp,sp,8
 20356a0:	f800283a 	ret

020356a4 <tcp_usrreq>:

int
tcp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 20356a4:	defff604 	addi	sp,sp,-40
 20356a8:	dfc00915 	stw	ra,36(sp)
 20356ac:	df000815 	stw	fp,32(sp)
 20356b0:	df000804 	addi	fp,sp,32
 20356b4:	e13ffd15 	stw	r4,-12(fp)
 20356b8:	e17ffe15 	stw	r5,-8(fp)
 20356bc:	e1bfff15 	stw	r6,-4(fp)
   struct inpcb * inp;
   struct tcpcb * tp;
   int   error =  0;
 20356c0:	e03ff915 	stw	zero,-28(fp)

#ifdef DO_TCPTRACE
   int   ostate;
#endif

   req = so->so_req;    /* get request from socket struct */
 20356c4:	e0bffd17 	ldw	r2,-12(fp)
 20356c8:	10800717 	ldw	r2,28(r2)
 20356cc:	e0bffa15 	stw	r2,-24(fp)
   inp = sotoinpcb(so);
 20356d0:	e0bffd17 	ldw	r2,-12(fp)
 20356d4:	10800117 	ldw	r2,4(r2)
 20356d8:	e0bffb15 	stw	r2,-20(fp)
   /*
    * When a TCP is attached to a socket, then there will be
    * a (struct inpcb) pointed at by the socket, and this
    * structure will point at a subsidary (struct tcpcb).
    */
   if (inp == 0 && req != PRU_ATTACH) 
 20356dc:	e0bffb17 	ldw	r2,-20(fp)
 20356e0:	1000041e 	bne	r2,zero,20356f4 <tcp_usrreq+0x50>
 20356e4:	e0bffa17 	ldw	r2,-24(fp)
 20356e8:	10000226 	beq	r2,zero,20356f4 <tcp_usrreq+0x50>
   {
      return (EINVAL);
 20356ec:	00800584 	movi	r2,22
 20356f0:	0001a206 	br	2035d7c <tcp_usrreq+0x6d8>
   }

   if (inp)
 20356f4:	e0bffb17 	ldw	r2,-20(fp)
 20356f8:	10000426 	beq	r2,zero,203570c <tcp_usrreq+0x68>
      tp = intotcpcb(inp);
 20356fc:	e0bffb17 	ldw	r2,-20(fp)
 2035700:	10800917 	ldw	r2,36(r2)
 2035704:	e0bff815 	stw	r2,-32(fp)
 2035708:	00000706 	br	2035728 <tcp_usrreq+0x84>
   else  /* inp and tp not set, make sure this is OK: */
   { 
      if (req == PRU_ATTACH)
 203570c:	e0bffa17 	ldw	r2,-24(fp)
 2035710:	1000021e 	bne	r2,zero,203571c <tcp_usrreq+0x78>
         tp = NULL;  /* stifle compiler warnings about using unassigned tp*/
 2035714:	e03ff815 	stw	zero,-32(fp)
 2035718:	00000306 	br	2035728 <tcp_usrreq+0x84>
      else
      {
         dtrap(); /* programming error? */
 203571c:	20285c80 	call	20285c8 <dtrap>
         return EINVAL;
 2035720:	00800584 	movi	r2,22
 2035724:	00019506 	br	2035d7c <tcp_usrreq+0x6d8>
      }
   }

   switch (req) 
 2035728:	e0bffa17 	ldw	r2,-24(fp)
 203572c:	10800528 	cmpgeui	r2,r2,20
 2035730:	10017c1e 	bne	r2,zero,2035d24 <tcp_usrreq+0x680>
 2035734:	e0bffa17 	ldw	r2,-24(fp)
 2035738:	1085883a 	add	r2,r2,r2
 203573c:	1087883a 	add	r3,r2,r2
 2035740:	008080f4 	movhi	r2,515
 2035744:	1095d504 	addi	r2,r2,22356
 2035748:	1885883a 	add	r2,r3,r2
 203574c:	10800017 	ldw	r2,0(r2)
 2035750:	1000683a 	jmp	r2
 2035754:	020357a4 	muli	r8,zero,3422
 2035758:	02035804 	movi	r8,3424
 203575c:	0203582c 	andhi	r8,zero,3424
 2035760:	02035864 	muli	r8,zero,3425
 2035764:	0203589c 	xori	r8,zero,3426
 2035768:	02035a08 	cmpgei	r8,zero,3432
 203576c:	020359fc 	xorhi	r8,zero,3431
 2035770:	02035ab8 	rdprs	r8,zero,3434
 2035774:	02035ae4 	muli	r8,zero,3435
 2035778:	02035af0 	cmpltui	r8,zero,3435
 203577c:	02035b4c 	andi	r8,zero,3437
 2035780:	02035d24 	muli	r8,zero,3444
 2035784:	02035b5c 	xori	r8,zero,3437
 2035788:	02035b68 	cmpgeui	r8,zero,3437
 203578c:	02035c20 	cmpeqi	r8,zero,3440
 2035790:	02035cf0 	cmpltui	r8,zero,3443
 2035794:	02035d00 	call	2035d0 <__alt_mem_descriptor_memory+0x2019d0>
 2035798:	020359f0 	cmpltui	r8,zero,3431
 203579c:	02035d24 	muli	r8,zero,3444
 20357a0:	02035d10 	cmplti	r8,zero,3444
   /*
    * TCP attaches to socket via PRU_ATTACH, reserving space,
    * and an internet control block.
    */
   case PRU_ATTACH:
      if (inp) 
 20357a4:	e0bffb17 	ldw	r2,-20(fp)
 20357a8:	10000326 	beq	r2,zero,20357b8 <tcp_usrreq+0x114>
      {
         error = EISCONN;
 20357ac:	00801fc4 	movi	r2,127
 20357b0:	e0bff915 	stw	r2,-28(fp)
         break;
 20357b4:	00017006 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      error = tcp_attach(so);
 20357b8:	e13ffd17 	ldw	r4,-12(fp)
 20357bc:	2035d900 	call	2035d90 <tcp_attach>
 20357c0:	e0bff915 	stw	r2,-28(fp)
      if (error)
 20357c4:	e0bff917 	ldw	r2,-28(fp)
 20357c8:	10015a1e 	bne	r2,zero,2035d34 <tcp_usrreq+0x690>
         break;
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 20357cc:	e0bffd17 	ldw	r2,-12(fp)
 20357d0:	10800417 	ldw	r2,16(r2)
 20357d4:	1080200c 	andi	r2,r2,128
 20357d8:	10015826 	beq	r2,zero,2035d3c <tcp_usrreq+0x698>
 20357dc:	e0bffd17 	ldw	r2,-12(fp)
 20357e0:	1080080b 	ldhu	r2,32(r2)
 20357e4:	10bfffcc 	andi	r2,r2,65535
 20357e8:	10a0001c 	xori	r2,r2,32768
 20357ec:	10a00004 	addi	r2,r2,-32768
 20357f0:	1001521e 	bne	r2,zero,2035d3c <tcp_usrreq+0x698>
         so->so_linger = TCP_LINGERTIME;
 20357f4:	e0bffd17 	ldw	r2,-12(fp)
 20357f8:	00c01e04 	movi	r3,120
 20357fc:	10c0080d 	sth	r3,32(r2)
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 2035800:	00014e06 	br	2035d3c <tcp_usrreq+0x698>
    * do this directly: have to initiate a PRU_DISCONNECT,
    * which may finish later; embryonic TCB's can just
    * be discarded here.
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
 2035804:	e0bff817 	ldw	r2,-32(fp)
 2035808:	10800217 	ldw	r2,8(r2)
 203580c:	10800090 	cmplti	r2,r2,2
 2035810:	1000031e 	bne	r2,zero,2035820 <tcp_usrreq+0x17c>
         SETTP(tp, tcp_disconnect(tp));
 2035814:	e13ff817 	ldw	r4,-32(fp)
 2035818:	2035ea80 	call	2035ea8 <tcp_disconnect>
      else
         SETTP(tp, tcp_close(tp));
      break;
 203581c:	00015606 	br	2035d78 <tcp_usrreq+0x6d4>
    */
   case PRU_DETACH:
      if (tp->t_state > TCPS_LISTEN)
         SETTP(tp, tcp_disconnect(tp));
      else
         SETTP(tp, tcp_close(tp));
 2035820:	e13ff817 	ldw	r4,-32(fp)
 2035824:	2034d240 	call	2034d24 <tcp_close>
      break;
 2035828:	00015306 	br	2035d78 <tcp_usrreq+0x6d4>
      /* bind is quite different for IPv4 and v6, so we use two 
       * seperate pcbbind routines. so_domain was checked for 
       * validity way up in t_bind()
       */
#ifdef IP_V4
      if(inp->inp_socket->so_domain == AF_INET)
 203582c:	e0bffb17 	ldw	r2,-20(fp)
 2035830:	10800817 	ldw	r2,32(r2)
 2035834:	10800517 	ldw	r2,20(r2)
 2035838:	10800098 	cmpnei	r2,r2,2
 203583c:	1000051e 	bne	r2,zero,2035854 <tcp_usrreq+0x1b0>
      {
         error = in_pcbbind(inp, nam);
 2035840:	e13ffb17 	ldw	r4,-20(fp)
 2035844:	e17fff17 	ldw	r5,-4(fp)
 2035848:	20486140 	call	2048614 <in_pcbbind>
 203584c:	e0bff915 	stw	r2,-28(fp)
         break;
 2035850:	00014906 	br	2035d78 <tcp_usrreq+0x6d4>
      {
         error = ip6_pcbbind(inp, nam);
         break;
      }
#endif /* IP_V6 */
      dtrap();    /* not v4 or v6? */
 2035854:	20285c80 	call	20285c8 <dtrap>
      error = EINVAL;
 2035858:	00800584 	movi	r2,22
 203585c:	e0bff915 	stw	r2,-28(fp)
      break;
 2035860:	00014506 	br	2035d78 <tcp_usrreq+0x6d4>
   /*
    * Prepare to accept connections.
    */
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
 2035864:	e0bffb17 	ldw	r2,-20(fp)
 2035868:	1080078b 	ldhu	r2,30(r2)
 203586c:	10bfffcc 	andi	r2,r2,65535
 2035870:	1000041e 	bne	r2,zero,2035884 <tcp_usrreq+0x1e0>
         error = in_pcbbind(inp, (struct mbuf *)0);
 2035874:	e13ffb17 	ldw	r4,-20(fp)
 2035878:	000b883a 	mov	r5,zero
 203587c:	20486140 	call	2048614 <in_pcbbind>
 2035880:	e0bff915 	stw	r2,-28(fp)
      if (error == 0)
 2035884:	e0bff917 	ldw	r2,-28(fp)
 2035888:	10012e1e 	bne	r2,zero,2035d44 <tcp_usrreq+0x6a0>
         tp->t_state = TCPS_LISTEN;
 203588c:	e0bff817 	ldw	r2,-32(fp)
 2035890:	00c00044 	movi	r3,1
 2035894:	10c00215 	stw	r3,8(r2)
      break;
 2035898:	00012a06 	br	2035d44 <tcp_usrreq+0x6a0>
    * Enter SYN_SENT state, and mark socket as connecting.
    * Start keep-alive timer, and seed output sequence space.
    * Send initial segment on connection.
    */
   case PRU_CONNECT:
      if (inp->inp_lport == 0) 
 203589c:	e0bffb17 	ldw	r2,-20(fp)
 20358a0:	1080078b 	ldhu	r2,30(r2)
 20358a4:	10bfffcc 	andi	r2,r2,65535
 20358a8:	1000061e 	bne	r2,zero,20358c4 <tcp_usrreq+0x220>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbbind(inp, (struct mbuf *)0);
 20358ac:	e13ffb17 	ldw	r4,-20(fp)
 20358b0:	000b883a 	mov	r5,zero
 20358b4:	20486140 	call	2048614 <in_pcbbind>
 20358b8:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
 20358bc:	e0bff917 	ldw	r2,-28(fp)
 20358c0:	1001221e 	bne	r2,zero,2035d4c <tcp_usrreq+0x6a8>
            break;
      }

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      error = in_pcbconnect(inp, nam);
 20358c4:	e13ffb17 	ldw	r4,-20(fp)
 20358c8:	e17fff17 	ldw	r5,-4(fp)
 20358cc:	20488240 	call	2048824 <in_pcbconnect>
 20358d0:	e0bff915 	stw	r2,-28(fp)
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
 20358d4:	e0bff917 	ldw	r2,-28(fp)
 20358d8:	10011e1e 	bne	r2,zero,2035d54 <tcp_usrreq+0x6b0>
         break;
      tp->t_template = tcp_template(tp);
 20358dc:	e13ff817 	ldw	r4,-32(fp)
 20358e0:	20346580 	call	2034658 <tcp_template>
 20358e4:	e0fff817 	ldw	r3,-32(fp)
 20358e8:	18800c15 	stw	r2,48(r3)
      if (tp->t_template == 0) 
 20358ec:	e0bff817 	ldw	r2,-32(fp)
 20358f0:	10800c17 	ldw	r2,48(r2)
 20358f4:	1000051e 	bne	r2,zero,203590c <tcp_usrreq+0x268>
      {

#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
         in_pcbdisconnect(inp);
 20358f8:	e13ffb17 	ldw	r4,-20(fp)
 20358fc:	2048a000 	call	2048a00 <in_pcbdisconnect>
#endif   /* end dual mode code */
#else    /* no v4, v6 only */
         ip6_pcbdisconnect(inp);
#endif   /* end v6 only */

         error = ENOBUFS;
 2035900:	00801a44 	movi	r2,105
 2035904:	e0bff915 	stw	r2,-28(fp)
         break;
 2035908:	00011b06 	br	2035d78 <tcp_usrreq+0x6d4>
      }

      soisconnecting(so);
 203590c:	e13ffd17 	ldw	r4,-12(fp)
 2035910:	202eb580 	call	202eb58 <soisconnecting>
      tcpstat.tcps_connattempt++;
 2035914:	00809934 	movhi	r2,612
 2035918:	10b6f504 	addi	r2,r2,-9260
 203591c:	10800017 	ldw	r2,0(r2)
 2035920:	10c00044 	addi	r3,r2,1
 2035924:	00809934 	movhi	r2,612
 2035928:	10b6f504 	addi	r2,r2,-9260
 203592c:	10c00015 	stw	r3,0(r2)
      tp->t_state = TCPS_SYN_SENT;
 2035930:	e0bff817 	ldw	r2,-32(fp)
 2035934:	00c00084 	movi	r3,2
 2035938:	10c00215 	stw	r3,8(r2)
      tp->t_timer[TCPT_KEEP] = TCPTV_KEEP_INIT;
 203593c:	e0bff817 	ldw	r2,-32(fp)
 2035940:	00c02584 	movi	r3,150
 2035944:	10c00515 	stw	r3,20(r2)
      tp->iss = tcp_iss; 
 2035948:	00808174 	movhi	r2,517
 203594c:	1090d604 	addi	r2,r2,17240
 2035950:	10c00017 	ldw	r3,0(r2)
 2035954:	e0bff817 	ldw	r2,-32(fp)
 2035958:	10c01315 	stw	r3,76(r2)
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
 203595c:	00808174 	movhi	r2,517
 2035960:	1090d604 	addi	r2,r2,17240
 2035964:	10c00017 	ldw	r3,0(r2)
 2035968:	00be9fd4 	movui	r2,64127
 203596c:	1887883a 	add	r3,r3,r2
 2035970:	00808174 	movhi	r2,517
 2035974:	1090d604 	addi	r2,r2,17240
 2035978:	10c00015 	stw	r3,0(r2)
      tcp_sendseqinit(tp);
 203597c:	e0bff817 	ldw	r2,-32(fp)
 2035980:	10c01317 	ldw	r3,76(r2)
 2035984:	e0bff817 	ldw	r2,-32(fp)
 2035988:	10c01015 	stw	r3,64(r2)
 203598c:	e0bff817 	ldw	r2,-32(fp)
 2035990:	10c01017 	ldw	r3,64(r2)
 2035994:	e0bff817 	ldw	r2,-32(fp)
 2035998:	10c01a15 	stw	r3,104(r2)
 203599c:	e0bff817 	ldw	r2,-32(fp)
 20359a0:	10c01a17 	ldw	r3,104(r2)
 20359a4:	e0bff817 	ldw	r2,-32(fp)
 20359a8:	10c00f15 	stw	r3,60(r2)
 20359ac:	e0bff817 	ldw	r2,-32(fp)
 20359b0:	10c00f17 	ldw	r3,60(r2)
 20359b4:	e0bff817 	ldw	r2,-32(fp)
 20359b8:	10c00e15 	stw	r3,56(r2)
      error = tcp_output(tp);
 20359bc:	e13ff817 	ldw	r4,-32(fp)
 20359c0:	20334200 	call	2033420 <tcp_output>
 20359c4:	e0bff915 	stw	r2,-28(fp)
      if (!error)
 20359c8:	e0bff917 	ldw	r2,-28(fp)
 20359cc:	1000e31e 	bne	r2,zero,2035d5c <tcp_usrreq+0x6b8>
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
 20359d0:	00809934 	movhi	r2,612
 20359d4:	10b6c704 	addi	r2,r2,-9444
 20359d8:	10800417 	ldw	r2,16(r2)
 20359dc:	10c00044 	addi	r3,r2,1
 20359e0:	00809934 	movhi	r2,612
 20359e4:	10b6c704 	addi	r2,r2,-9444
 20359e8:	10c00415 	stw	r3,16(r2)
      break;
 20359ec:	0000db06 	br	2035d5c <tcp_usrreq+0x6b8>

   /*
    * Create a TCP connection between two sockets.
    */
   case PRU_CONNECT2:
      error = EOPNOTSUPP;
 20359f0:	008017c4 	movi	r2,95
 20359f4:	e0bff915 	stw	r2,-28(fp)
      break;
 20359f8:	0000df06 	br	2035d78 <tcp_usrreq+0x6d4>
    * when peer sends FIN and acks ours.
    *
    * SHOULD IMPLEMENT LATER PRU_CONNECT VIA REALLOC TCPCB.
    */
   case PRU_DISCONNECT:
      SETTP(tp, tcp_disconnect(tp));
 20359fc:	e13ff817 	ldw	r4,-32(fp)
 2035a00:	2035ea80 	call	2035ea8 <tcp_disconnect>
      break;
 2035a04:	0000dc06 	br	2035d78 <tcp_usrreq+0x6d4>
    * done at higher levels; just return the address
    * of the peer, storing through addr.
    */
   case PRU_ACCEPT: 
   {
         struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 2035a08:	e0bfff17 	ldw	r2,-4(fp)
 2035a0c:	10800317 	ldw	r2,12(r2)
 2035a10:	e0bffc15 	stw	r2,-16(fp)
            IP6CPY(&sin6->sin6_addr, &inp->ip6_faddr);
         }
#endif

#ifdef IP_V4
         if (so->so_domain == AF_INET)
 2035a14:	e0bffd17 	ldw	r2,-12(fp)
 2035a18:	10800517 	ldw	r2,20(r2)
 2035a1c:	10800098 	cmpnei	r2,r2,2
 2035a20:	10000e1e 	bne	r2,zero,2035a5c <tcp_usrreq+0x3b8>
         {
            nam->m_len = sizeof (struct sockaddr_in);
 2035a24:	e0bfff17 	ldw	r2,-4(fp)
 2035a28:	00c00404 	movi	r3,16
 2035a2c:	10c00215 	stw	r3,8(r2)
            sin->sin_family = AF_INET;
 2035a30:	e0bffc17 	ldw	r2,-16(fp)
 2035a34:	00c00084 	movi	r3,2
 2035a38:	10c0000d 	sth	r3,0(r2)
            sin->sin_port = inp->inp_fport;
 2035a3c:	e0bffb17 	ldw	r2,-20(fp)
 2035a40:	10c0070b 	ldhu	r3,28(r2)
 2035a44:	e0bffc17 	ldw	r2,-16(fp)
 2035a48:	10c0008d 	sth	r3,2(r2)
            sin->sin_addr = inp->inp_faddr;
 2035a4c:	e0bffc17 	ldw	r2,-16(fp)
 2035a50:	e0fffb17 	ldw	r3,-20(fp)
 2035a54:	18c00317 	ldw	r3,12(r3)
 2035a58:	10c00115 	stw	r3,4(r2)
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 2035a5c:	e0bffd17 	ldw	r2,-12(fp)
 2035a60:	10800517 	ldw	r2,20(r2)
 2035a64:	108000a0 	cmpeqi	r2,r2,2
 2035a68:	10000b1e 	bne	r2,zero,2035a98 <tcp_usrreq+0x3f4>
              !(so->so_domain == AF_INET6)
 2035a6c:	e0bffd17 	ldw	r2,-12(fp)
 2035a70:	10800517 	ldw	r2,20(r2)
            sin->sin_family = AF_INET;
            sin->sin_port = inp->inp_fport;
            sin->sin_addr = inp->inp_faddr;
         }
#endif
         if ( !(so->so_domain == AF_INET) &&
 2035a74:	108000e0 	cmpeqi	r2,r2,3
 2035a78:	1000071e 	bne	r2,zero,2035a98 <tcp_usrreq+0x3f4>
              !(so->so_domain == AF_INET6)
             )
         {
            dprintf("*** PRU_ACCEPT bad domain = %d\n", so->so_domain);
 2035a7c:	e0bffd17 	ldw	r2,-12(fp)
 2035a80:	10800517 	ldw	r2,20(r2)
 2035a84:	01008174 	movhi	r4,517
 2035a88:	213d8f04 	addi	r4,r4,-2500
 2035a8c:	100b883a 	mov	r5,r2
 2035a90:	2006a240 	call	2006a24 <printf>
            dtrap();
 2035a94:	20285c80 	call	20285c8 <dtrap>
         } 
         TCP_MIB_INC(tcpPassiveOpens);    /* keep MIB stats */
 2035a98:	00809934 	movhi	r2,612
 2035a9c:	10b6c704 	addi	r2,r2,-9444
 2035aa0:	10800517 	ldw	r2,20(r2)
 2035aa4:	10c00044 	addi	r3,r2,1
 2035aa8:	00809934 	movhi	r2,612
 2035aac:	10b6c704 	addi	r2,r2,-9444
 2035ab0:	10c00515 	stw	r3,20(r2)
         break;
 2035ab4:	0000b006 	br	2035d78 <tcp_usrreq+0x6d4>

   /*
    * Mark the connection as being incapable of further output.
    */
   case PRU_SHUTDOWN:
      socantsendmore(so);
 2035ab8:	e13ffd17 	ldw	r4,-12(fp)
 2035abc:	202f1e80 	call	202f1e8 <socantsendmore>
      tp = tcp_usrclosed(tp);
 2035ac0:	e13ff817 	ldw	r4,-32(fp)
 2035ac4:	2035f740 	call	2035f74 <tcp_usrclosed>
 2035ac8:	e0bff815 	stw	r2,-32(fp)
      if (tp)
 2035acc:	e0bff817 	ldw	r2,-32(fp)
 2035ad0:	1000a426 	beq	r2,zero,2035d64 <tcp_usrreq+0x6c0>
         error = tcp_output(tp);
 2035ad4:	e13ff817 	ldw	r4,-32(fp)
 2035ad8:	20334200 	call	2033420 <tcp_output>
 2035adc:	e0bff915 	stw	r2,-28(fp)
      break;
 2035ae0:	0000a006 	br	2035d64 <tcp_usrreq+0x6c0>

   /*
    * After a receive, possibly send window update to peer.
    */
   case PRU_RCVD:
      (void) tcp_output(tp);
 2035ae4:	e13ff817 	ldw	r4,-32(fp)
 2035ae8:	20334200 	call	2033420 <tcp_output>
      break;
 2035aec:	0000a206 	br	2035d78 <tcp_usrreq+0x6d4>
   /*
    * Do a send by putting data in output queue and updating urgent
    * marker if URG set.  Possibly send more data.
    */
   case PRU_SEND:
      if (so->so_pcb == NULL)
 2035af0:	e0bffd17 	ldw	r2,-12(fp)
 2035af4:	10800117 	ldw	r2,4(r2)
 2035af8:	1000031e 	bne	r2,zero,2035b08 <tcp_usrreq+0x464>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 2035afc:	00800804 	movi	r2,32
 2035b00:	e0bff915 	stw	r2,-28(fp)
         break;
 2035b04:	00009c06 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      sbappend(&so->so_snd, m);
 2035b08:	e0bffd17 	ldw	r2,-12(fp)
 2035b0c:	10801204 	addi	r2,r2,72
 2035b10:	1009883a 	mov	r4,r2
 2035b14:	e17ffe17 	ldw	r5,-8(fp)
 2035b18:	202f4e40 	call	202f4e4 <sbappend>
      error = tcp_output(tp);
 2035b1c:	e13ff817 	ldw	r4,-32(fp)
 2035b20:	20334200 	call	2033420 <tcp_output>
 2035b24:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 2035b28:	e0bff917 	ldw	r2,-28(fp)
 2035b2c:	10801a58 	cmpnei	r2,r2,105
 2035b30:	10008e1e 	bne	r2,zero,2035d6c <tcp_usrreq+0x6c8>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 2035b34:	e0bffd17 	ldw	r2,-12(fp)
 2035b38:	10801204 	addi	r2,r2,72
 2035b3c:	1009883a 	mov	r4,r2
 2035b40:	e17ffe17 	ldw	r5,-8(fp)
 2035b44:	202fc4c0 	call	202fc4c <sbdropend>
      break;
 2035b48:	00008806 	br	2035d6c <tcp_usrreq+0x6c8>

   /*
    * Abort the TCP.
    */
   case PRU_ABORT:
      SETTP(tp, tcp_drop(tp, ECONNABORTED));
 2035b4c:	e13ff817 	ldw	r4,-32(fp)
 2035b50:	01401c44 	movi	r5,113
 2035b54:	2034c780 	call	2034c78 <tcp_drop>
      break;
 2035b58:	00008706 	br	2035d78 <tcp_usrreq+0x6d4>

   case PRU_SENSE:
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
 2035b5c:	20285c80 	call	20285c8 <dtrap>
      return (0);
 2035b60:	0005883a 	mov	r2,zero
 2035b64:	00008506 	br	2035d7c <tcp_usrreq+0x6d8>

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 2035b68:	e0bffd17 	ldw	r2,-12(fp)
 2035b6c:	10801a17 	ldw	r2,104(r2)
 2035b70:	1000051e 	bne	r2,zero,2035b88 <tcp_usrreq+0x4e4>
          (so->so_state & SS_RCVATMARK) == 0) ||
 2035b74:	e0bffd17 	ldw	r2,-12(fp)
 2035b78:	1080088b 	ldhu	r2,34(r2)
 2035b7c:	10bfffcc 	andi	r2,r2,65535
 2035b80:	1080100c 	andi	r2,r2,64
      /*      ((struct stat *) m)->st_blksize = so->so_snd.sb_hiwat; */
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
 2035b84:	10000926 	beq	r2,zero,2035bac <tcp_usrreq+0x508>
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 2035b88:	e0bffd17 	ldw	r2,-12(fp)
 2035b8c:	10800417 	ldw	r2,16(r2)
 2035b90:	1080400c 	andi	r2,r2,256
      dtrap();    /* does this ever happen? */
      return (0);

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
 2035b94:	1000051e 	bne	r2,zero,2035bac <tcp_usrreq+0x508>
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
 2035b98:	e0bff817 	ldw	r2,-32(fp)
 2035b9c:	10802403 	ldbu	r2,144(r2)
 2035ba0:	10803fcc 	andi	r2,r2,255
 2035ba4:	1080008c 	andi	r2,r2,2

   case PRU_RCVOOB:
      if ((so->so_oobmark == 0 &&
          (so->so_state & SS_RCVATMARK) == 0) ||
#ifdef SO_OOBINLINE
       so->so_options & SO_OOBINLINE ||
 2035ba8:	10000326 	beq	r2,zero,2035bb8 <tcp_usrreq+0x514>
#endif
       tp->t_oobflags & TCPOOB_HADDATA) 
       {
         error = EINVAL;
 2035bac:	00800584 	movi	r2,22
 2035bb0:	e0bff915 	stw	r2,-28(fp)
         break;
 2035bb4:	00007006 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      if ((tp->t_oobflags & TCPOOB_HAVEDATA) == 0) 
 2035bb8:	e0bff817 	ldw	r2,-32(fp)
 2035bbc:	10802403 	ldbu	r2,144(r2)
 2035bc0:	10803fcc 	andi	r2,r2,255
 2035bc4:	1080004c 	andi	r2,r2,1
 2035bc8:	1000031e 	bne	r2,zero,2035bd8 <tcp_usrreq+0x534>
      {
         error = EWOULDBLOCK;
 2035bcc:	008002c4 	movi	r2,11
 2035bd0:	e0bff915 	stw	r2,-28(fp)
         break;
 2035bd4:	00006806 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      m->m_len = 1;
 2035bd8:	e0bffe17 	ldw	r2,-8(fp)
 2035bdc:	00c00044 	movi	r3,1
 2035be0:	10c00215 	stw	r3,8(r2)
      *mtod(m, char *) = tp->t_iobc;
 2035be4:	e0bffe17 	ldw	r2,-8(fp)
 2035be8:	10800317 	ldw	r2,12(r2)
 2035bec:	e0fff817 	ldw	r3,-32(fp)
 2035bf0:	18c02443 	ldbu	r3,145(r3)
 2035bf4:	10c00005 	stb	r3,0(r2)
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
 2035bf8:	e0bfff17 	ldw	r2,-4(fp)
 2035bfc:	1080008c 	andi	r2,r2,2
 2035c00:	10005c1e 	bne	r2,zero,2035d74 <tcp_usrreq+0x6d0>
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
 2035c04:	e0bff817 	ldw	r2,-32(fp)
 2035c08:	10802403 	ldbu	r2,144(r2)
 2035c0c:	108000dc 	xori	r2,r2,3
 2035c10:	1007883a 	mov	r3,r2
 2035c14:	e0bff817 	ldw	r2,-32(fp)
 2035c18:	10c02405 	stb	r3,144(r2)
      break;
 2035c1c:	00005506 	br	2035d74 <tcp_usrreq+0x6d0>

   case PRU_SENDOOB:
      if (so->so_pcb == NULL)
 2035c20:	e0bffd17 	ldw	r2,-12(fp)
 2035c24:	10800117 	ldw	r2,4(r2)
 2035c28:	1000031e 	bne	r2,zero,2035c38 <tcp_usrreq+0x594>
      {                    /* Return EPIPE error if socket is not connected */
         error = EPIPE;
 2035c2c:	00800804 	movi	r2,32
 2035c30:	e0bff915 	stw	r2,-28(fp)
         break;
 2035c34:	00005006 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      if (sbspace(&so->so_snd) == 0) 
 2035c38:	e0bffd17 	ldw	r2,-12(fp)
 2035c3c:	10801317 	ldw	r2,76(r2)
 2035c40:	1007883a 	mov	r3,r2
 2035c44:	e0bffd17 	ldw	r2,-12(fp)
 2035c48:	10801217 	ldw	r2,72(r2)
 2035c4c:	1885c83a 	sub	r2,r3,r2
 2035c50:	10000516 	blt	r2,zero,2035c68 <tcp_usrreq+0x5c4>
 2035c54:	e0bffd17 	ldw	r2,-12(fp)
 2035c58:	10c01317 	ldw	r3,76(r2)
 2035c5c:	e0bffd17 	ldw	r2,-12(fp)
 2035c60:	10801217 	ldw	r2,72(r2)
 2035c64:	1880051e 	bne	r3,r2,2035c7c <tcp_usrreq+0x5d8>
      {
         m_freem(m);
 2035c68:	e13ffe17 	ldw	r4,-8(fp)
 2035c6c:	20296780 	call	2029678 <m_freem>
         error = ENOBUFS;
 2035c70:	00801a44 	movi	r2,105
 2035c74:	e0bff915 	stw	r2,-28(fp)
         break;
 2035c78:	00003f06 	br	2035d78 <tcp_usrreq+0x6d4>
       * of urgent data.  We continue, however,
       * to consider it to indicate the first octet
       * of data past the urgent section.
       * Otherwise, snd_up should be one lower.
       */
      sbappend(&so->so_snd, m);
 2035c7c:	e0bffd17 	ldw	r2,-12(fp)
 2035c80:	10801204 	addi	r2,r2,72
 2035c84:	1009883a 	mov	r4,r2
 2035c88:	e17ffe17 	ldw	r5,-8(fp)
 2035c8c:	202f4e40 	call	202f4e4 <sbappend>
      tp->snd_up = tp->snd_una + so->so_snd.sb_cc;
 2035c90:	e0bff817 	ldw	r2,-32(fp)
 2035c94:	10c00e17 	ldw	r3,56(r2)
 2035c98:	e0bffd17 	ldw	r2,-12(fp)
 2035c9c:	10801217 	ldw	r2,72(r2)
 2035ca0:	1887883a 	add	r3,r3,r2
 2035ca4:	e0bff817 	ldw	r2,-32(fp)
 2035ca8:	10c01015 	stw	r3,64(r2)
      tp->t_force = 1;
 2035cac:	e0bff817 	ldw	r2,-32(fp)
 2035cb0:	00c00044 	movi	r3,1
 2035cb4:	10c00a85 	stb	r3,42(r2)
      error = tcp_output(tp);
 2035cb8:	e13ff817 	ldw	r4,-32(fp)
 2035cbc:	20334200 	call	2033420 <tcp_output>
 2035cc0:	e0bff915 	stw	r2,-28(fp)
      if (error == ENOBUFS)
 2035cc4:	e0bff917 	ldw	r2,-28(fp)
 2035cc8:	10801a58 	cmpnei	r2,r2,105
 2035ccc:	1000051e 	bne	r2,zero,2035ce4 <tcp_usrreq+0x640>
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
 2035cd0:	e0bffd17 	ldw	r2,-12(fp)
 2035cd4:	10801204 	addi	r2,r2,72
 2035cd8:	1009883a 	mov	r4,r2
 2035cdc:	e17ffe17 	ldw	r5,-8(fp)
 2035ce0:	202fc4c0 	call	202fc4c <sbdropend>
      tp->t_force = 0;
 2035ce4:	e0bff817 	ldw	r2,-32(fp)
 2035ce8:	10000a85 	stb	zero,42(r2)
      break;
 2035cec:	00002206 	br	2035d78 <tcp_usrreq+0x6d4>
   case PRU_SOCKADDR:

   /* sockaddr and peeraddr have to switch based on IP type */
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setsockaddr(inp, nam);
 2035cf0:	e13ffb17 	ldw	r4,-20(fp)
 2035cf4:	e17fff17 	ldw	r5,-4(fp)
 2035cf8:	2048a580 	call	2048a58 <in_setsockaddr>
         in_setsockaddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setsockaddr(inp, nam);
#endif
      break;         
 2035cfc:	00001e06 	br	2035d78 <tcp_usrreq+0x6d4>

   case PRU_PEERADDR:
#ifdef IP_V4
#ifndef IP_V6  /* v4 only */
      in_setpeeraddr(inp, nam);
 2035d00:	e13ffb17 	ldw	r4,-20(fp)
 2035d04:	e17fff17 	ldw	r5,-4(fp)
 2035d08:	2048ad80 	call	2048ad8 <in_setpeeraddr>
         in_setpeeraddr(inp, nam);
#endif   /* dual mode */
#else    /* IP_V6 */
         ip6_setpeeraddr(inp, nam);
#endif
      break;
 2035d0c:	00001a06 	br	2035d78 <tcp_usrreq+0x6d4>

   case PRU_SLOWTIMO:
      SETTP(tp, tcp_timers(tp, (int)MBUF2LONG(nam)));
 2035d10:	e0bfff17 	ldw	r2,-4(fp)
 2035d14:	e13ff817 	ldw	r4,-32(fp)
 2035d18:	100b883a 	mov	r5,r2
 2035d1c:	20352340 	call	2035234 <tcp_timers>
#ifdef DO_TCPTRACE
      req |= (long)nam << 8;        /* for debug's sake */
#endif
      break;
 2035d20:	00001506 	br	2035d78 <tcp_usrreq+0x6d4>

      default:
      panic("tcp_usrreq");
 2035d24:	01008174 	movhi	r4,517
 2035d28:	213d9704 	addi	r4,r4,-2468
 2035d2c:	2026bf80 	call	2026bf8 <panic>
 2035d30:	00001106 	br	2035d78 <tcp_usrreq+0x6d4>
         error = EISCONN;
         break;
      }
      error = tcp_attach(so);
      if (error)
         break;
 2035d34:	0001883a 	nop
 2035d38:	00000f06 	br	2035d78 <tcp_usrreq+0x6d4>
      if ((so->so_options & SO_LINGER) && so->so_linger == 0)
         so->so_linger = TCP_LINGERTIME;
#ifdef   DO_TCPTRACE
      SETTP(tp, sototcpcb(so));
#endif
      break;
 2035d3c:	0001883a 	nop
 2035d40:	00000d06 	br	2035d78 <tcp_usrreq+0x6d4>
   case PRU_LISTEN:
      if (inp->inp_lport == 0)
         error = in_pcbbind(inp, (struct mbuf *)0);
      if (error == 0)
         tp->t_state = TCPS_LISTEN;
      break;
 2035d44:	0001883a 	nop
 2035d48:	00000b06 	br	2035d78 <tcp_usrreq+0x6d4>
#else    /* no v4, v6 only */
      error = ip6_pcbbind(inp, (struct mbuf *)0);
#endif   /* end v6 only */

         if (error)
            break;
 2035d4c:	0001883a 	nop
 2035d50:	00000906 	br	2035d78 <tcp_usrreq+0x6d4>
#else    /* no v4, v6 only */
      error = ip6_pcbconnect(inp, nam);
#endif   /* end v6 only */

      if (error)
         break;
 2035d54:	0001883a 	nop
 2035d58:	00000706 	br	2035d78 <tcp_usrreq+0x6d4>
      tcp_iss += (tcp_seq)(TCP_ISSINCR/2);
      tcp_sendseqinit(tp);
      error = tcp_output(tp);
      if (!error)
         TCP_MIB_INC(tcpActiveOpens);     /* keep MIB stats */
      break;
 2035d5c:	0001883a 	nop
 2035d60:	00000506 	br	2035d78 <tcp_usrreq+0x6d4>
   case PRU_SHUTDOWN:
      socantsendmore(so);
      tp = tcp_usrclosed(tp);
      if (tp)
         error = tcp_output(tp);
      break;
 2035d64:	0001883a 	nop
 2035d68:	00000306 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      sbappend(&so->so_snd, m);
      error = tcp_output(tp);
      if (error == ENOBUFS)
         sbdropend(&so->so_snd,m);  /* Remove data from socket buffer */
      break;
 2035d6c:	0001883a 	nop
 2035d70:	00000106 	br	2035d78 <tcp_usrreq+0x6d4>
      }
      m->m_len = 1;
      *mtod(m, char *) = tp->t_iobc;
      if ((MBUF2LONG(nam) & MSG_PEEK) == 0)
         tp->t_oobflags ^= (TCPOOB_HAVEDATA | TCPOOB_HADDATA);
      break;
 2035d74:	0001883a 	nop
#ifdef DO_TCPTRACE
   if (tp && (so->so_options & SO_DEBUG))
      tcp_trace("usrreq: state: %d, tcpcb: %x, req: %d",
    ostate, tp, req);
#endif
   return (error);
 2035d78:	e0bff917 	ldw	r2,-28(fp)
}
 2035d7c:	e037883a 	mov	sp,fp
 2035d80:	dfc00117 	ldw	ra,4(sp)
 2035d84:	df000017 	ldw	fp,0(sp)
 2035d88:	dec00204 	addi	sp,sp,8
 2035d8c:	f800283a 	ret

02035d90 <tcp_attach>:
 * RETURNS: 0 if OK, or nonzero error code.
 */

int
tcp_attach(struct socket * so)
{
 2035d90:	defff904 	addi	sp,sp,-28
 2035d94:	dfc00615 	stw	ra,24(sp)
 2035d98:	df000515 	stw	fp,20(sp)
 2035d9c:	df000504 	addi	fp,sp,20
 2035da0:	e13fff15 	stw	r4,-4(fp)
   struct tcpcb * tp;
   struct inpcb * inp;
   int   error;

   if (so->so_snd.sb_hiwat == 0 || so->so_rcv.sb_hiwat == 0) 
 2035da4:	e0bfff17 	ldw	r2,-4(fp)
 2035da8:	10801317 	ldw	r2,76(r2)
 2035dac:	10000326 	beq	r2,zero,2035dbc <tcp_attach+0x2c>
 2035db0:	e0bfff17 	ldw	r2,-4(fp)
 2035db4:	10800b17 	ldw	r2,44(r2)
 2035db8:	10000b1e 	bne	r2,zero,2035de8 <tcp_attach+0x58>
   {
      error = soreserve(so, tcp_sendspace, tcp_recvspace);
 2035dbc:	d0e04617 	ldw	r3,-32488(gp)
 2035dc0:	d0a04717 	ldw	r2,-32484(gp)
 2035dc4:	e13fff17 	ldw	r4,-4(fp)
 2035dc8:	180b883a 	mov	r5,r3
 2035dcc:	100d883a 	mov	r6,r2
 2035dd0:	202f3c40 	call	202f3c4 <soreserve>
 2035dd4:	e0bffb15 	stw	r2,-20(fp)
      if (error)
 2035dd8:	e0bffb17 	ldw	r2,-20(fp)
 2035ddc:	10000226 	beq	r2,zero,2035de8 <tcp_attach+0x58>
         return (error);
 2035de0:	e0bffb17 	ldw	r2,-20(fp)
 2035de4:	00002b06 	br	2035e94 <tcp_attach+0x104>
   }
   error = in_pcballoc(so, &tcb);
 2035de8:	e13fff17 	ldw	r4,-4(fp)
 2035dec:	01409934 	movhi	r5,612
 2035df0:	2976ea04 	addi	r5,r5,-9304
 2035df4:	20485380 	call	2048538 <in_pcballoc>
 2035df8:	e0bffb15 	stw	r2,-20(fp)
   if (error)
 2035dfc:	e0bffb17 	ldw	r2,-20(fp)
 2035e00:	10000226 	beq	r2,zero,2035e0c <tcp_attach+0x7c>
      return (error);
 2035e04:	e0bffb17 	ldw	r2,-20(fp)
 2035e08:	00002206 	br	2035e94 <tcp_attach+0x104>
   inp = sotoinpcb(so);
 2035e0c:	e0bfff17 	ldw	r2,-4(fp)
 2035e10:	10800117 	ldw	r2,4(r2)
 2035e14:	e0bffc15 	stw	r2,-16(fp)
   tp = tcp_newtcpcb(inp);
 2035e18:	e13ffc17 	ldw	r4,-16(fp)
 2035e1c:	2034b6c0 	call	2034b6c <tcp_newtcpcb>
 2035e20:	e0bffd15 	stw	r2,-12(fp)
   if (tp == 0) 
 2035e24:	e0bffd17 	ldw	r2,-12(fp)
 2035e28:	1000171e 	bne	r2,zero,2035e88 <tcp_attach+0xf8>
   {
      int   nofd  =  so->so_state   &  SS_NOFDREF; /* XXX */
 2035e2c:	e0bfff17 	ldw	r2,-4(fp)
 2035e30:	1080088b 	ldhu	r2,34(r2)
 2035e34:	10bfffcc 	andi	r2,r2,65535
 2035e38:	1080004c 	andi	r2,r2,1
 2035e3c:	e0bffe15 	stw	r2,-8(fp)

      so->so_state &= ~SS_NOFDREF;     /* don't free the socket yet */
 2035e40:	e0bfff17 	ldw	r2,-4(fp)
 2035e44:	10c0088b 	ldhu	r3,34(r2)
 2035e48:	00bfff84 	movi	r2,-2
 2035e4c:	1884703a 	and	r2,r3,r2
 2035e50:	1007883a 	mov	r3,r2
 2035e54:	e0bfff17 	ldw	r2,-4(fp)
 2035e58:	10c0088d 	sth	r3,34(r2)
      in_pcbdetach(inp);
 2035e5c:	e13ffc17 	ldw	r4,-16(fp)
 2035e60:	20485c00 	call	20485c0 <in_pcbdetach>
      so->so_state |= nofd;
 2035e64:	e0bfff17 	ldw	r2,-4(fp)
 2035e68:	10c0088b 	ldhu	r3,34(r2)
 2035e6c:	e0bffe17 	ldw	r2,-8(fp)
 2035e70:	1884b03a 	or	r2,r3,r2
 2035e74:	1007883a 	mov	r3,r2
 2035e78:	e0bfff17 	ldw	r2,-4(fp)
 2035e7c:	10c0088d 	sth	r3,34(r2)
      return (ENOBUFS);
 2035e80:	00801a44 	movi	r2,105
 2035e84:	00000306 	br	2035e94 <tcp_attach+0x104>
   }
   tp->t_state = TCPS_CLOSED;
 2035e88:	e0bffd17 	ldw	r2,-12(fp)
 2035e8c:	10000215 	stw	zero,8(r2)
   return (0);
 2035e90:	0005883a 	mov	r2,zero
}
 2035e94:	e037883a 	mov	sp,fp
 2035e98:	dfc00117 	ldw	ra,4(sp)
 2035e9c:	df000017 	ldw	fp,0(sp)
 2035ea0:	dec00204 	addi	sp,sp,8
 2035ea4:	f800283a 	ret

02035ea8 <tcp_disconnect>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_disconnect(struct tcpcb * tp)
{
 2035ea8:	defffc04 	addi	sp,sp,-16
 2035eac:	dfc00315 	stw	ra,12(sp)
 2035eb0:	df000215 	stw	fp,8(sp)
 2035eb4:	df000204 	addi	fp,sp,8
 2035eb8:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  tp->t_inpcb->inp_socket;
 2035ebc:	e0bfff17 	ldw	r2,-4(fp)
 2035ec0:	10800d17 	ldw	r2,52(r2)
 2035ec4:	10800817 	ldw	r2,32(r2)
 2035ec8:	e0bffe15 	stw	r2,-8(fp)

   if (tp->t_state < TCPS_ESTABLISHED)
 2035ecc:	e0bfff17 	ldw	r2,-4(fp)
 2035ed0:	10800217 	ldw	r2,8(r2)
 2035ed4:	10800108 	cmpgei	r2,r2,4
 2035ed8:	1000041e 	bne	r2,zero,2035eec <tcp_disconnect+0x44>
      tp = tcp_close(tp);
 2035edc:	e13fff17 	ldw	r4,-4(fp)
 2035ee0:	2034d240 	call	2034d24 <tcp_close>
 2035ee4:	e0bfff15 	stw	r2,-4(fp)
 2035ee8:	00001c06 	br	2035f5c <tcp_disconnect+0xb4>
   else if ((so->so_options & SO_LINGER) && so->so_linger == 0)
 2035eec:	e0bffe17 	ldw	r2,-8(fp)
 2035ef0:	10800417 	ldw	r2,16(r2)
 2035ef4:	1080200c 	andi	r2,r2,128
 2035ef8:	10000b26 	beq	r2,zero,2035f28 <tcp_disconnect+0x80>
 2035efc:	e0bffe17 	ldw	r2,-8(fp)
 2035f00:	1080080b 	ldhu	r2,32(r2)
 2035f04:	10bfffcc 	andi	r2,r2,65535
 2035f08:	10a0001c 	xori	r2,r2,32768
 2035f0c:	10a00004 	addi	r2,r2,-32768
 2035f10:	1000051e 	bne	r2,zero,2035f28 <tcp_disconnect+0x80>
      tp = tcp_drop(tp, 0);
 2035f14:	e13fff17 	ldw	r4,-4(fp)
 2035f18:	000b883a 	mov	r5,zero
 2035f1c:	2034c780 	call	2034c78 <tcp_drop>
 2035f20:	e0bfff15 	stw	r2,-4(fp)
 2035f24:	00000d06 	br	2035f5c <tcp_disconnect+0xb4>
   else 
   {
      soisdisconnecting(so);
 2035f28:	e13ffe17 	ldw	r4,-8(fp)
 2035f2c:	202ecc40 	call	202ecc4 <soisdisconnecting>
      sbflush(&so->so_rcv);
 2035f30:	e0bffe17 	ldw	r2,-8(fp)
 2035f34:	10800a04 	addi	r2,r2,40
 2035f38:	1009883a 	mov	r4,r2
 2035f3c:	202fa0c0 	call	202fa0c <sbflush>
      tp = tcp_usrclosed(tp);
 2035f40:	e13fff17 	ldw	r4,-4(fp)
 2035f44:	2035f740 	call	2035f74 <tcp_usrclosed>
 2035f48:	e0bfff15 	stw	r2,-4(fp)
      if (tp)
 2035f4c:	e0bfff17 	ldw	r2,-4(fp)
 2035f50:	10000226 	beq	r2,zero,2035f5c <tcp_disconnect+0xb4>
         (void) tcp_output(tp);
 2035f54:	e13fff17 	ldw	r4,-4(fp)
 2035f58:	20334200 	call	2033420 <tcp_output>
   }
   return (tp);
 2035f5c:	e0bfff17 	ldw	r2,-4(fp)
}
 2035f60:	e037883a 	mov	sp,fp
 2035f64:	dfc00117 	ldw	ra,4(sp)
 2035f68:	df000017 	ldw	fp,0(sp)
 2035f6c:	dec00204 	addi	sp,sp,8
 2035f70:	f800283a 	ret

02035f74 <tcp_usrclosed>:
 * RETURNS: 
 */

struct tcpcb * 
tcp_usrclosed(struct tcpcb * tp)
{
 2035f74:	defffd04 	addi	sp,sp,-12
 2035f78:	dfc00215 	stw	ra,8(sp)
 2035f7c:	df000115 	stw	fp,4(sp)
 2035f80:	df000104 	addi	fp,sp,4
 2035f84:	e13fff15 	stw	r4,-4(fp)

   switch (tp->t_state) 
 2035f88:	e0bfff17 	ldw	r2,-4(fp)
 2035f8c:	10800217 	ldw	r2,8(r2)
 2035f90:	10c001a8 	cmpgeui	r3,r2,6
 2035f94:	18001b1e 	bne	r3,zero,2036004 <tcp_usrclosed+0x90>
 2035f98:	1085883a 	add	r2,r2,r2
 2035f9c:	1087883a 	add	r3,r2,r2
 2035fa0:	008080f4 	movhi	r2,515
 2035fa4:	1097ed04 	addi	r2,r2,24500
 2035fa8:	1885883a 	add	r2,r3,r2
 2035fac:	10800017 	ldw	r2,0(r2)
 2035fb0:	1000683a 	jmp	r2
 2035fb4:	02035fcc 	andi	r8,zero,3455
 2035fb8:	02035fcc 	andi	r8,zero,3455
 2035fbc:	02035fcc 	andi	r8,zero,3455
 2035fc0:	02035fe4 	muli	r8,zero,3455
 2035fc4:	02035fe4 	muli	r8,zero,3455
 2035fc8:	02035ff4 	movhi	r8,3455
   {
   case TCPS_CLOSED:
   case TCPS_LISTEN:
   case TCPS_SYN_SENT:
      tp->t_state = TCPS_CLOSED;
 2035fcc:	e0bfff17 	ldw	r2,-4(fp)
 2035fd0:	10000215 	stw	zero,8(r2)
      tp = tcp_close(tp);
 2035fd4:	e13fff17 	ldw	r4,-4(fp)
 2035fd8:	2034d240 	call	2034d24 <tcp_close>
 2035fdc:	e0bfff15 	stw	r2,-4(fp)
      break;
 2035fe0:	00000806 	br	2036004 <tcp_usrclosed+0x90>

   case TCPS_SYN_RECEIVED:
   case TCPS_ESTABLISHED:
      tp->t_state = TCPS_FIN_WAIT_1;
 2035fe4:	e0bfff17 	ldw	r2,-4(fp)
 2035fe8:	00c00184 	movi	r3,6
 2035fec:	10c00215 	stw	r3,8(r2)
      break;
 2035ff0:	00000406 	br	2036004 <tcp_usrclosed+0x90>

   case TCPS_CLOSE_WAIT:
      tp->t_state = TCPS_LAST_ACK;
 2035ff4:	e0bfff17 	ldw	r2,-4(fp)
 2035ff8:	00c00204 	movi	r3,8
 2035ffc:	10c00215 	stw	r3,8(r2)
      break;
 2036000:	0001883a 	nop
   }
   if (tp && tp->t_state >= TCPS_FIN_WAIT_2)
 2036004:	e0bfff17 	ldw	r2,-4(fp)
 2036008:	10000926 	beq	r2,zero,2036030 <tcp_usrclosed+0xbc>
 203600c:	e0bfff17 	ldw	r2,-4(fp)
 2036010:	10800217 	ldw	r2,8(r2)
 2036014:	10800250 	cmplti	r2,r2,9
 2036018:	1000051e 	bne	r2,zero,2036030 <tcp_usrclosed+0xbc>
      soisdisconnected(tp->t_inpcb->inp_socket);
 203601c:	e0bfff17 	ldw	r2,-4(fp)
 2036020:	10800d17 	ldw	r2,52(r2)
 2036024:	10800817 	ldw	r2,32(r2)
 2036028:	1009883a 	mov	r4,r2
 203602c:	202ed580 	call	202ed58 <soisdisconnected>
   return (tp);
 2036030:	e0bfff17 	ldw	r2,-4(fp)
}
 2036034:	e037883a 	mov	sp,fp
 2036038:	dfc00117 	ldw	ra,4(sp)
 203603c:	df000017 	ldw	fp,0(sp)
 2036040:	dec00204 	addi	sp,sp,8
 2036044:	f800283a 	ret

02036048 <tcpinit>:
 * RETURNS: 0 if OK, else one of the ENP_ error codes
 */

int
tcpinit(void)
{
 2036048:	defffd04 	addi	sp,sp,-12
 203604c:	dfc00215 	stw	ra,8(sp)
 2036050:	df000115 	stw	fp,4(sp)
 2036054:	df000104 	addi	fp,sp,4
   tcp_sendspace = (TCP_MSS) * 2;
   tcp_recvspace = (TCP_MSS) * 2;
   TCPTV_MSL =    (4 * PR_SLOWHZ);     /* max seg lifetime default */
#endif

   e = nptcp_init();    /* call the NetPort init in nptcp.c */
 2036058:	2029d500 	call	2029d50 <nptcp_init>
 203605c:	e0bfff15 	stw	r2,-4(fp)
   if (e)
 2036060:	e0bfff17 	ldw	r2,-4(fp)
 2036064:	10000226 	beq	r2,zero,2036070 <tcpinit+0x28>
      return e;
 2036068:	e0bfff17 	ldw	r2,-4(fp)
 203606c:	00000106 	br	2036074 <tcpinit+0x2c>

   return 0;   /* good return */
 2036070:	0005883a 	mov	r2,zero
}
 2036074:	e037883a 	mov	sp,fp
 2036078:	dfc00117 	ldw	ra,4(sp)
 203607c:	df000017 	ldw	fp,0(sp)
 2036080:	dec00204 	addi	sp,sp,8
 2036084:	f800283a 	ret

02036088 <udp_lookup>:
 * RETURNS: 
 */

UDPCONN
udp_lookup(struct socket * so)
{
 2036088:	defffd04 	addi	sp,sp,-12
 203608c:	df000215 	stw	fp,8(sp)
 2036090:	df000204 	addi	fp,sp,8
 2036094:	e13fff15 	stw	r4,-4(fp)
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 2036098:	00808174 	movhi	r2,517
 203609c:	1090f204 	addi	r2,r2,17352
 20360a0:	10800017 	ldw	r2,0(r2)
 20360a4:	e0bffe15 	stw	r2,-8(fp)
 20360a8:	00000906 	br	20360d0 <udp_lookup+0x48>
      if (tmp->u_data == (void*)so)
 20360ac:	e0bffe17 	ldw	r2,-8(fp)
 20360b0:	10c00617 	ldw	r3,24(r2)
 20360b4:	e0bfff17 	ldw	r2,-4(fp)
 20360b8:	1880021e 	bne	r3,r2,20360c4 <udp_lookup+0x3c>
      return (tmp);
 20360bc:	e0bffe17 	ldw	r2,-8(fp)
 20360c0:	00000606 	br	20360dc <udp_lookup+0x54>
UDPCONN
udp_lookup(struct socket * so)
{
   UDPCONN tmp;

   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 20360c4:	e0bffe17 	ldw	r2,-8(fp)
 20360c8:	10800017 	ldw	r2,0(r2)
 20360cc:	e0bffe15 	stw	r2,-8(fp)
 20360d0:	e0bffe17 	ldw	r2,-8(fp)
 20360d4:	103ff51e 	bne	r2,zero,20360ac <udp_lookup+0x24>
      if (tmp->u_data == (void*)so)
      return (tmp);

   return NULL;   /* didn't find it */
 20360d8:	0005883a 	mov	r2,zero
}
 20360dc:	e037883a 	mov	sp,fp
 20360e0:	df000017 	ldw	fp,0(sp)
 20360e4:	dec00104 	addi	sp,sp,4
 20360e8:	f800283a 	ret

020360ec <udp_soinput>:
 * RETURNS: 
 */

int
udp_soinput(PACKET pkt, void * so_ptr)
{
 20360ec:	defff504 	addi	sp,sp,-44
 20360f0:	dfc00a15 	stw	ra,40(sp)
 20360f4:	df000915 	stw	fp,36(sp)
 20360f8:	df000904 	addi	fp,sp,36
 20360fc:	e13ffe15 	stw	r4,-8(fp)
 2036100:	e17fff15 	stw	r5,-4(fp)
   struct mbuf *  m_in;    /* packet/data mbuf */
   struct socket *   so =  (struct  socket *)so_ptr;
 2036104:	e0bfff17 	ldw	r2,-4(fp)
 2036108:	e0bff715 	stw	r2,-36(fp)
   struct sockaddr_in   sin;
   struct udp *   udpp;

   LOCK_NET_RESOURCE(NET_RESID); 
 203610c:	0009883a 	mov	r4,zero
 2036110:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   /* make sure we're not flooding input buffers */
   if ((so->so_rcv.sb_cc + pkt->nb_plen) >= so->so_rcv.sb_hiwat)
 2036114:	e0bff717 	ldw	r2,-36(fp)
 2036118:	10c00a17 	ldw	r3,40(r2)
 203611c:	e0bffe17 	ldw	r2,-8(fp)
 2036120:	10800417 	ldw	r2,16(r2)
 2036124:	1887883a 	add	r3,r3,r2
 2036128:	e0bff717 	ldw	r2,-36(fp)
 203612c:	10800b17 	ldw	r2,44(r2)
 2036130:	18800436 	bltu	r3,r2,2036144 <udp_soinput+0x58>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 2036134:	0009883a 	mov	r4,zero
 2036138:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 203613c:	00801a44 	movi	r2,105
 2036140:	00004d06 	br	2036278 <udp_soinput+0x18c>
   }

   /* alloc mbuf for received data */
   m_in = m_getnbuf(MT_RXDATA, 0);
 2036144:	01000044 	movi	r4,1
 2036148:	000b883a 	mov	r5,zero
 203614c:	20293d80 	call	20293d8 <m_getnbuf>
 2036150:	e0bff815 	stw	r2,-32(fp)
   if (!m_in)
 2036154:	e0bff817 	ldw	r2,-32(fp)
 2036158:	1000041e 	bne	r2,zero,203616c <udp_soinput+0x80>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 203615c:	0009883a 	mov	r4,zero
 2036160:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 2036164:	00801a44 	movi	r2,105
 2036168:	00004306 	br	2036278 <udp_soinput+0x18c>
   }

   /* set data mbuf to point to start of UDP data */
   m_in->pkt = pkt;
 203616c:	e0bff817 	ldw	r2,-32(fp)
 2036170:	e0fffe17 	ldw	r3,-8(fp)
 2036174:	10c00115 	stw	r3,4(r2)
   m_in->m_data = pkt->nb_prot;
 2036178:	e0bffe17 	ldw	r2,-8(fp)
 203617c:	10c00317 	ldw	r3,12(r2)
 2036180:	e0bff817 	ldw	r2,-32(fp)
 2036184:	10c00315 	stw	r3,12(r2)
   m_in->m_len = pkt->nb_plen;
 2036188:	e0bffe17 	ldw	r2,-8(fp)
 203618c:	10c00417 	ldw	r3,16(r2)
 2036190:	e0bff817 	ldw	r2,-32(fp)
 2036194:	10c00215 	stw	r3,8(r2)
   m_in->m_base = pkt->nb_buff;
 2036198:	e0bffe17 	ldw	r2,-8(fp)
 203619c:	10c00117 	ldw	r3,4(r2)
 20361a0:	e0bff817 	ldw	r2,-32(fp)
 20361a4:	10c00415 	stw	r3,16(r2)
   m_in->m_memsz = pkt->nb_blen;
 20361a8:	e0bffe17 	ldw	r2,-8(fp)
 20361ac:	10c00217 	ldw	r3,8(r2)
 20361b0:	e0bff817 	ldw	r2,-32(fp)
 20361b4:	10c00515 	stw	r3,20(r2)

   /* fill in net address info for pass to socket append()ers */
   sin.sin_addr.s_addr = pkt->fhost;
 20361b8:	e0bffe17 	ldw	r2,-8(fp)
 20361bc:	10800717 	ldw	r2,28(r2)
 20361c0:	e0bffb15 	stw	r2,-20(fp)
   udpp = (struct udp *)(pkt->nb_prot - sizeof(struct udp));
 20361c4:	e0bffe17 	ldw	r2,-8(fp)
 20361c8:	10800317 	ldw	r2,12(r2)
 20361cc:	10bffe04 	addi	r2,r2,-8
 20361d0:	e0bff915 	stw	r2,-28(fp)
   sin.sin_port = htons(udpp->ud_srcp);
 20361d4:	e0bff917 	ldw	r2,-28(fp)
 20361d8:	1080000b 	ldhu	r2,0(r2)
 20361dc:	10bfffcc 	andi	r2,r2,65535
 20361e0:	1004d23a 	srli	r2,r2,8
 20361e4:	1007883a 	mov	r3,r2
 20361e8:	e0bff917 	ldw	r2,-28(fp)
 20361ec:	1080000b 	ldhu	r2,0(r2)
 20361f0:	10bfffcc 	andi	r2,r2,65535
 20361f4:	1004923a 	slli	r2,r2,8
 20361f8:	1884b03a 	or	r2,r3,r2
 20361fc:	e0bffa8d 	sth	r2,-22(fp)
   sin.sin_family = AF_INET;
 2036200:	00800084 	movi	r2,2
 2036204:	e0bffa0d 	sth	r2,-24(fp)

   /* attempt to append address information to mbuf */
   if (!sbappendaddr(&so->so_rcv, (struct sockaddr *)&sin, m_in))
 2036208:	e0bff717 	ldw	r2,-36(fp)
 203620c:	10c00a04 	addi	r3,r2,40
 2036210:	e0bffa04 	addi	r2,fp,-24
 2036214:	1809883a 	mov	r4,r3
 2036218:	100b883a 	mov	r5,r2
 203621c:	e1bff817 	ldw	r6,-32(fp)
 2036220:	202f65c0 	call	202f65c <sbappendaddr>
 2036224:	1000081e 	bne	r2,zero,2036248 <udp_soinput+0x15c>
   {
      /* set the pkt field in the mbuf to NULL so m_free() below wont 
       * free the packet buffer, because that is left to the 
       */
      m_in->pkt = NULL;
 2036228:	e0bff817 	ldw	r2,-32(fp)
 203622c:	10000115 	stw	zero,4(r2)
      /* free only the mbuf itself */
      m_free(m_in);
 2036230:	e13ff817 	ldw	r4,-32(fp)
 2036234:	20295600 	call	2029560 <m_free>
      /* return error condition so caller can free the packet buffer */
      UNLOCK_NET_RESOURCE(NET_RESID);
 2036238:	0009883a 	mov	r4,zero
 203623c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENOBUFS;
 2036240:	00801a44 	movi	r2,105
 2036244:	00000c06 	br	2036278 <udp_soinput+0x18c>
   }

   tcp_wakeup(&so->so_rcv);   /* wake anyone waiting for this */
 2036248:	e0bff717 	ldw	r2,-36(fp)
 203624c:	10800a04 	addi	r2,r2,40
 2036250:	1009883a 	mov	r4,r2
 2036254:	20276980 	call	2027698 <tcp_wakeup>

   sorwakeup(so);    /* wake up selects too */
 2036258:	e0bff717 	ldw	r2,-36(fp)
 203625c:	10800a04 	addi	r2,r2,40
 2036260:	e13ff717 	ldw	r4,-36(fp)
 2036264:	100b883a 	mov	r5,r2
 2036268:	202f3300 	call	202f330 <sbwakeup>

   UNLOCK_NET_RESOURCE(NET_RESID);
 203626c:	0009883a 	mov	r4,zero
 2036270:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return 0;
 2036274:	0005883a 	mov	r2,zero
}
 2036278:	e037883a 	mov	sp,fp
 203627c:	dfc00117 	ldw	ra,4(sp)
 2036280:	df000017 	ldw	fp,0(sp)
 2036284:	dec00204 	addi	sp,sp,8
 2036288:	f800283a 	ret

0203628c <udp_usrreq>:

int
udp_usrreq(struct socket * so, 
   struct mbuf *  m,
   struct mbuf *  nam)
{
 203628c:	defff804 	addi	sp,sp,-32
 2036290:	dfc00715 	stw	ra,28(sp)
 2036294:	df000615 	stw	fp,24(sp)
 2036298:	df000604 	addi	fp,sp,24
 203629c:	e13ffd15 	stw	r4,-12(fp)
 20362a0:	e17ffe15 	stw	r5,-8(fp)
 20362a4:	e1bfff15 	stw	r6,-4(fp)
   UDPCONN udpconn = (UDPCONN)NULL;
 20362a8:	e03ffb15 	stw	zero,-20(fp)
   int   req;

   req = so->so_req;    /* get request from socket struct */
 20362ac:	e0bffd17 	ldw	r2,-12(fp)
 20362b0:	10800717 	ldw	r2,28(r2)
 20362b4:	e0bffc15 	stw	r2,-16(fp)

   switch (req) 
 20362b8:	e0bffc17 	ldw	r2,-16(fp)
 20362bc:	10800468 	cmpgeui	r2,r2,17
 20362c0:	10007c1e 	bne	r2,zero,20364b4 <udp_usrreq+0x228>
 20362c4:	e0bffc17 	ldw	r2,-16(fp)
 20362c8:	1085883a 	add	r2,r2,r2
 20362cc:	1087883a 	add	r3,r2,r2
 20362d0:	008080f4 	movhi	r2,515
 20362d4:	1098b904 	addi	r2,r2,25316
 20362d8:	1885883a 	add	r2,r3,r2
 20362dc:	10800017 	ldw	r2,0(r2)
 20362e0:	1000683a 	jmp	r2
 20362e4:	02036328 	cmpgeui	r8,zero,3468
 20362e8:	020363ac 	andhi	r8,zero,3470
 20362ec:	020363e8 	cmpgeui	r8,zero,3471
 20362f0:	020364b4 	movhi	r8,3474
 20362f4:	020363e8 	cmpgeui	r8,zero,3471
 20362f8:	020364b4 	movhi	r8,3474
 20362fc:	020364a8 	cmpgeui	r8,zero,3474
 2036300:	020364b4 	movhi	r8,3474
 2036304:	020364a8 	cmpgeui	r8,zero,3474
 2036308:	02036428 	cmpgeui	r8,zero,3472
 203630c:	020364b4 	movhi	r8,3474
 2036310:	020364b4 	movhi	r8,3474
 2036314:	020364b4 	movhi	r8,3474
 2036318:	020364b4 	movhi	r8,3474
 203631c:	020364b4 	movhi	r8,3474
 2036320:	02036468 	cmpgeui	r8,zero,3473
 2036324:	02036468 	cmpgeui	r8,zero,3473
   {
   case PRU_ATTACH:
      /* fake small windows so sockets asks us to move data */
      so->so_rcv.sb_hiwat = so->so_snd.sb_hiwat = udp_maxalloc();
 2036328:	2045b000 	call	2045b00 <udp_maxalloc>
 203632c:	1007883a 	mov	r3,r2
 2036330:	e0bffd17 	ldw	r2,-12(fp)
 2036334:	10c01315 	stw	r3,76(r2)
 2036338:	e0bffd17 	ldw	r2,-12(fp)
 203633c:	10c01317 	ldw	r3,76(r2)
 2036340:	e0bffd17 	ldw	r2,-12(fp)
 2036344:	10c00b15 	stw	r3,44(r2)

#ifdef IP_V4
      /* make a NetPort UDP connection */
      /* unlock the net resource; UDP will immediatly re-lock it */
      if (so->so_domain  == AF_INET){
 2036348:	e0bffd17 	ldw	r2,-12(fp)
 203634c:	10800517 	ldw	r2,20(r2)
 2036350:	10800098 	cmpnei	r2,r2,2
 2036354:	10000f1e 	bne	r2,zero,2036394 <udp_usrreq+0x108>
        UNLOCK_NET_RESOURCE(NET_RESID);
 2036358:	0009883a 	mov	r4,zero
 203635c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
        udpconn = udp_open(0L, 0, udp_socket(), udp_soinput, so);
 2036360:	20459740 	call	2045974 <udp_socket>
 2036364:	10bfffcc 	andi	r2,r2,65535
 2036368:	e0fffd17 	ldw	r3,-12(fp)
 203636c:	d8c00015 	stw	r3,0(sp)
 2036370:	0009883a 	mov	r4,zero
 2036374:	000b883a 	mov	r5,zero
 2036378:	100d883a 	mov	r6,r2
 203637c:	01c080f4 	movhi	r7,515
 2036380:	39d83b04 	addi	r7,r7,24812
 2036384:	20482480 	call	2048248 <udp_open>
 2036388:	e0bffb15 	stw	r2,-20(fp)
        LOCK_NET_RESOURCE(NET_RESID);
 203638c:	0009883a 	mov	r4,zero
 2036390:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
        UNLOCK_NET_RESOURCE(NET_RESID);
        udpconn = udp6_open(0L, 0, udp_socket(), udp6_soinput, so);
        LOCK_NET_RESOURCE(NET_RESID);
      }
#endif
      if (!udpconn)
 2036394:	e0bffb17 	ldw	r2,-20(fp)
 2036398:	1000021e 	bne	r2,zero,20363a4 <udp_usrreq+0x118>
         return(EINVAL);
 203639c:	00800584 	movi	r2,22
 20363a0:	00004506 	br	20364b8 <udp_usrreq+0x22c>
      return 0;
 20363a4:	0005883a 	mov	r2,zero
 20363a8:	00004306 	br	20364b8 <udp_usrreq+0x22c>
   case PRU_DETACH:
      /* delete the NetPort UDP connection */
      udpconn = udp_lookup(so);
 20363ac:	e13ffd17 	ldw	r4,-12(fp)
 20363b0:	20360880 	call	2036088 <udp_lookup>
 20363b4:	e0bffb15 	stw	r2,-20(fp)
      if (!udpconn)
 20363b8:	e0bffb17 	ldw	r2,-20(fp)
 20363bc:	1000021e 	bne	r2,zero,20363c8 <udp_usrreq+0x13c>
         return(EINVAL);
 20363c0:	00800584 	movi	r2,22
 20363c4:	00003c06 	br	20364b8 <udp_usrreq+0x22c>
      /* unlock the net resource; UDP will immediatly re-lock it */
      UNLOCK_NET_RESOURCE(NET_RESID);
 20363c8:	0009883a 	mov	r4,zero
 20363cc:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      udp_close(udpconn);
 20363d0:	e13ffb17 	ldw	r4,-20(fp)
 20363d4:	20484600 	call	2048460 <udp_close>
      LOCK_NET_RESOURCE(NET_RESID);
 20363d8:	0009883a 	mov	r4,zero
 20363dc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      return 0;
 20363e0:	0005883a 	mov	r2,zero
 20363e4:	00003406 	br	20364b8 <udp_usrreq+0x22c>
   case PRU_CONNECT:
      /* Install foreign port for UDP, making a virtual connection */
      /* fall to shared bind logic */
   case PRU_BIND:
      /* do bind parameters lookups and tests */
      if (nam == NULL)
 20363e8:	e0bfff17 	ldw	r2,-4(fp)
 20363ec:	1000021e 	bne	r2,zero,20363f8 <udp_usrreq+0x16c>
         return(EINVAL);
 20363f0:	00800584 	movi	r2,22
 20363f4:	00003006 	br	20364b8 <udp_usrreq+0x22c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 20363f8:	e0bffd17 	ldw	r2,-12(fp)
 20363fc:	10800517 	ldw	r2,20(r2)
 2036400:	10800098 	cmpnei	r2,r2,2
 2036404:	1000051e 	bne	r2,zero,203641c <udp_usrreq+0x190>
        return udp4_sockbind(so, nam, req );
 2036408:	e13ffd17 	ldw	r4,-12(fp)
 203640c:	e17fff17 	ldw	r5,-4(fp)
 2036410:	e1bffc17 	ldw	r6,-16(fp)
 2036414:	20364cc0 	call	20364cc <udp4_sockbind>
 2036418:	00002706 	br	20364b8 <udp_usrreq+0x22c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockbind(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 203641c:	20285c80 	call	20285c8 <dtrap>
      return EINVAL;
 2036420:	00800584 	movi	r2,22
 2036424:	00002406 	br	20364b8 <udp_usrreq+0x22c>
   case PRU_SEND:
      /* do parameter lookups and tests */
      if (!m)  /* no data passed? */
 2036428:	e0bffe17 	ldw	r2,-8(fp)
 203642c:	1000021e 	bne	r2,zero,2036438 <udp_usrreq+0x1ac>
         return(EINVAL);
 2036430:	00800584 	movi	r2,22
 2036434:	00002006 	br	20364b8 <udp_usrreq+0x22c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 2036438:	e0bffd17 	ldw	r2,-12(fp)
 203643c:	10800517 	ldw	r2,20(r2)
 2036440:	10800098 	cmpnei	r2,r2,2
 2036444:	1000051e 	bne	r2,zero,203645c <udp_usrreq+0x1d0>
        return udp4_socksend(so, m, nam );
 2036448:	e13ffd17 	ldw	r4,-12(fp)
 203644c:	e17ffe17 	ldw	r5,-8(fp)
 2036450:	e1bfff17 	ldw	r6,-4(fp)
 2036454:	20367a80 	call	20367a8 <udp4_socksend>
 2036458:	00001706 	br	20364b8 <udp_usrreq+0x22c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_socksend(so, m, nam);
      }
#endif
      dtrap();   /* invalid address */
 203645c:	20285c80 	call	20285c8 <dtrap>
      return EINVAL;
 2036460:	00800584 	movi	r2,22
 2036464:	00001406 	br	20364b8 <udp_usrreq+0x22c>

   case PRU_SOCKADDR:
      /* fall through to share PRU_PEERADDR prefix */
   case PRU_PEERADDR:
      if (nam == NULL)
 2036468:	e0bfff17 	ldw	r2,-4(fp)
 203646c:	1000021e 	bne	r2,zero,2036478 <udp_usrreq+0x1ec>
         return(EINVAL);
 2036470:	00800584 	movi	r2,22
 2036474:	00001006 	br	20364b8 <udp_usrreq+0x22c>
#ifdef IP_V4
      if (so->so_domain == AF_INET){
 2036478:	e0bffd17 	ldw	r2,-12(fp)
 203647c:	10800517 	ldw	r2,20(r2)
 2036480:	10800098 	cmpnei	r2,r2,2
 2036484:	1000051e 	bne	r2,zero,203649c <udp_usrreq+0x210>
        return udp4_sockaddr(so, nam, req );
 2036488:	e13ffd17 	ldw	r4,-12(fp)
 203648c:	e17fff17 	ldw	r5,-4(fp)
 2036490:	e1bffc17 	ldw	r6,-16(fp)
 2036494:	2036b240 	call	2036b24 <udp4_sockaddr>
 2036498:	00000706 	br	20364b8 <udp_usrreq+0x22c>
#ifdef IP_V6
      if (so->so_domain == AF_INET6){
        return udp6_sockaddr(so, nam, req);
      }
#endif
      dtrap();   /* invalid address */
 203649c:	20285c80 	call	20285c8 <dtrap>
      return EINVAL;
 20364a0:	00800584 	movi	r2,22
 20364a4:	00000406 	br	20364b8 <udp_usrreq+0x22c>

   case PRU_DISCONNECT:
   case PRU_RCVD:
      dtrap();
 20364a8:	20285c80 	call	20285c8 <dtrap>
      return 0;
 20364ac:	0005883a 	mov	r2,zero
 20364b0:	00000106 	br	20364b8 <udp_usrreq+0x22c>
   case PRU_LISTEN:     /* don't support these for UDP */
   case PRU_ACCEPT:
   default:
      return EOPNOTSUPP;
 20364b4:	008017c4 	movi	r2,95
   }
}
 20364b8:	e037883a 	mov	sp,fp
 20364bc:	dfc00117 	ldw	ra,4(sp)
 20364c0:	df000017 	ldw	fp,0(sp)
 20364c4:	dec00204 	addi	sp,sp,8
 20364c8:	f800283a 	ret

020364cc <udp4_sockbind>:

#ifdef IP_V4
int udp4_sockbind(struct socket *so, struct mbuf *nam, int req ) 
{
 20364cc:	defff304 	addi	sp,sp,-52
 20364d0:	dfc00c15 	stw	ra,48(sp)
 20364d4:	df000b15 	stw	fp,44(sp)
 20364d8:	df000b04 	addi	fp,sp,44
 20364dc:	e13ffd15 	stw	r4,-12(fp)
 20364e0:	e17ffe15 	stw	r5,-8(fp)
 20364e4:	e1bfff15 	stw	r6,-4(fp)
  u_short  lport;   /* local port (local byte order) */
  ip_addr fhost; /* host to send to/recv from (network byte order) */
  ip_addr lhost; /* local IP address to bind to (network byte order) */
  NET ifp;

  sin = mtod(nam, struct sockaddr_in *);
 20364e8:	e0bffe17 	ldw	r2,-8(fp)
 20364ec:	10800317 	ldw	r2,12(r2)
 20364f0:	e0bffa15 	stw	r2,-24(fp)
  if (sin == NULL)
 20364f4:	e0bffa17 	ldw	r2,-24(fp)
 20364f8:	1000021e 	bne	r2,zero,2036504 <udp4_sockbind+0x38>
    return(EINVAL);
 20364fc:	00800584 	movi	r2,22
 2036500:	0000a406 	br	2036794 <udp4_sockbind+0x2c8>
  if (nam->m_len != sizeof (*sin))
 2036504:	e0bffe17 	ldw	r2,-8(fp)
 2036508:	10800217 	ldw	r2,8(r2)
 203650c:	10800420 	cmpeqi	r2,r2,16
 2036510:	1000021e 	bne	r2,zero,203651c <udp4_sockbind+0x50>
    return(EINVAL);
 2036514:	00800584 	movi	r2,22
 2036518:	00009e06 	br	2036794 <udp4_sockbind+0x2c8>
  udpconn = udp_lookup(so);
 203651c:	e13ffd17 	ldw	r4,-12(fp)
 2036520:	20360880 	call	2036088 <udp_lookup>
 2036524:	e0bffb15 	stw	r2,-20(fp)
  if (!udpconn)
 2036528:	e0bffb17 	ldw	r2,-20(fp)
 203652c:	1000021e 	bne	r2,zero,2036538 <udp4_sockbind+0x6c>
     return(EINVAL);
 2036530:	00800584 	movi	r2,22
 2036534:	00009706 	br	2036794 <udp4_sockbind+0x2c8>
  if (req == PRU_BIND)
 2036538:	e0bfff17 	ldw	r2,-4(fp)
 203653c:	10800098 	cmpnei	r2,r2,2
 2036540:	1000551e 	bne	r2,zero,2036698 <udp4_sockbind+0x1cc>
     * if the caller-supplied port is 0, try to get
     * the port from the UDP endpoint, or pick a new
     * unique port; else, use the caller-supplied
     * port
     */
    if (sin->sin_port == 0)
 2036544:	e0bffa17 	ldw	r2,-24(fp)
 2036548:	1080008b 	ldhu	r2,2(r2)
 203654c:	10bfffcc 	andi	r2,r2,65535
 2036550:	10000b1e 	bne	r2,zero,2036580 <udp4_sockbind+0xb4>
    {
      if (udpconn->u_lport != 0)
 2036554:	e0bffb17 	ldw	r2,-20(fp)
 2036558:	1080018b 	ldhu	r2,6(r2)
 203655c:	10bfffcc 	andi	r2,r2,65535
 2036560:	10000426 	beq	r2,zero,2036574 <udp4_sockbind+0xa8>
        lport = udpconn->u_lport;
 2036564:	e0bffb17 	ldw	r2,-20(fp)
 2036568:	1080018b 	ldhu	r2,6(r2)
 203656c:	e0bff60d 	sth	r2,-40(fp)
 2036570:	00000e06 	br	20365ac <udp4_sockbind+0xe0>
      else
        lport = udp_socket();
 2036574:	20459740 	call	2045974 <udp_socket>
 2036578:	e0bff60d 	sth	r2,-40(fp)
 203657c:	00000b06 	br	20365ac <udp4_sockbind+0xe0>
    }
    else
    {
      lport = ntohs(sin->sin_port);
 2036580:	e0bffa17 	ldw	r2,-24(fp)
 2036584:	1080008b 	ldhu	r2,2(r2)
 2036588:	10bfffcc 	andi	r2,r2,65535
 203658c:	1004d23a 	srli	r2,r2,8
 2036590:	1007883a 	mov	r3,r2
 2036594:	e0bffa17 	ldw	r2,-24(fp)
 2036598:	1080008b 	ldhu	r2,2(r2)
 203659c:	10bfffcc 	andi	r2,r2,65535
 20365a0:	1004923a 	slli	r2,r2,8
 20365a4:	1884b03a 	or	r2,r3,r2
 20365a8:	e0bff60d 	sth	r2,-40(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * don't bind to a specific address; else, 
     * make sure the caller-supplied address is
     * an interface IP address and if so, bind to that
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 20365ac:	e0bffa17 	ldw	r2,-24(fp)
 20365b0:	10800117 	ldw	r2,4(r2)
 20365b4:	1000021e 	bne	r2,zero,20365c0 <udp4_sockbind+0xf4>
    {
      lhost = 0L;
 20365b8:	e03ff815 	stw	zero,-32(fp)
 20365bc:	00001706 	br	203661c <udp4_sockbind+0x150>
    }
    else
    {
      lhost = sin->sin_addr.s_addr;
 20365c0:	e0bffa17 	ldw	r2,-24(fp)
 20365c4:	10800117 	ldw	r2,4(r2)
 20365c8:	e0bff815 	stw	r2,-32(fp)
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 20365cc:	00809934 	movhi	r2,612
 20365d0:	10b7ce04 	addi	r2,r2,-8392
 20365d4:	10800017 	ldw	r2,0(r2)
 20365d8:	e0bff915 	stw	r2,-28(fp)
 20365dc:	00000706 	br	20365fc <udp4_sockbind+0x130>
        if (ifp->n_ipaddr == lhost)
 20365e0:	e0bff917 	ldw	r2,-28(fp)
 20365e4:	10c00a17 	ldw	r3,40(r2)
 20365e8:	e0bff817 	ldw	r2,-32(fp)
 20365ec:	18800626 	beq	r3,r2,2036608 <udp4_sockbind+0x13c>
    else
    {
      lhost = sin->sin_addr.s_addr;
#ifndef UDP_SKIP_LCL_ADDR_CHECK
      /* verify that lhost is a local interface address */
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 20365f0:	e0bff917 	ldw	r2,-28(fp)
 20365f4:	10800017 	ldw	r2,0(r2)
 20365f8:	e0bff915 	stw	r2,-28(fp)
 20365fc:	e0bff917 	ldw	r2,-28(fp)
 2036600:	103ff71e 	bne	r2,zero,20365e0 <udp4_sockbind+0x114>
 2036604:	00000106 	br	203660c <udp4_sockbind+0x140>
        if (ifp->n_ipaddr == lhost)
          break;
 2036608:	0001883a 	nop
      if (ifp == NULL)
 203660c:	e0bff917 	ldw	r2,-28(fp)
 2036610:	1000021e 	bne	r2,zero,203661c <udp4_sockbind+0x150>
        return(EADDRNOTAVAIL);
 2036614:	00801f44 	movi	r2,125
 2036618:	00005e06 	br	2036794 <udp4_sockbind+0x2c8>
    }

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
 203661c:	e0bffd17 	ldw	r2,-12(fp)
 2036620:	10800417 	ldw	r2,16(r2)
 2036624:	1080010c 	andi	r2,r2,4
 2036628:	1000141e 	bne	r2,zero,203667c <udp4_sockbind+0x1b0>
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 203662c:	00808174 	movhi	r2,517
 2036630:	1090f204 	addi	r2,r2,17352
 2036634:	10800017 	ldw	r2,0(r2)
 2036638:	e0bff515 	stw	r2,-44(fp)
 203663c:	00000d06 	br	2036674 <udp4_sockbind+0x1a8>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
 2036640:	e0bff517 	ldw	r2,-44(fp)
 2036644:	1080018b 	ldhu	r2,6(r2)
 2036648:	10ffffcc 	andi	r3,r2,65535
 203664c:	e0bff60b 	ldhu	r2,-40(fp)
 2036650:	1880051e 	bne	r3,r2,2036668 <udp4_sockbind+0x19c>
 2036654:	e0fff517 	ldw	r3,-44(fp)
 2036658:	e0bffb17 	ldw	r2,-20(fp)
 203665c:	18800226 	beq	r3,r2,2036668 <udp4_sockbind+0x19c>
          return(EADDRINUSE);
 2036660:	00801c04 	movi	r2,112
 2036664:	00004b06 	br	2036794 <udp4_sockbind+0x2c8>

    /* make sure we're not about to collide with an
     * existing binding
     */
    if (!(so->so_options & SO_REUSEADDR))
      for (udptmp = firstudp; udptmp; udptmp = udptmp->u_next)
 2036668:	e0bff517 	ldw	r2,-44(fp)
 203666c:	10800017 	ldw	r2,0(r2)
 2036670:	e0bff515 	stw	r2,-44(fp)
 2036674:	e0bff517 	ldw	r2,-44(fp)
 2036678:	103ff11e 	bne	r2,zero,2036640 <udp4_sockbind+0x174>
        if ((udptmp->u_lport == lport) && (udptmp != udpconn))
          return(EADDRINUSE);
    /* bind the UDP endpoint */
    udpconn->u_lport = lport;
 203667c:	e0bffb17 	ldw	r2,-20(fp)
 2036680:	e0fff60b 	ldhu	r3,-40(fp)
 2036684:	10c0018d 	sth	r3,6(r2)
    udpconn->u_lhost = lhost;
 2036688:	e0bffb17 	ldw	r2,-20(fp)
 203668c:	e0fff817 	ldw	r3,-32(fp)
 2036690:	10c00315 	stw	r3,12(r2)
 2036694:	00003e06 	br	2036790 <udp4_sockbind+0x2c4>
  else /* PRU_CONNECT */
  {
    /* connect the socket to a remote IP address and
     * UDP port.
     */
    fport = ntohs(sin->sin_port);
 2036698:	e0bffa17 	ldw	r2,-24(fp)
 203669c:	1080008b 	ldhu	r2,2(r2)
 20366a0:	10bfffcc 	andi	r2,r2,65535
 20366a4:	1004d23a 	srli	r2,r2,8
 20366a8:	1007883a 	mov	r3,r2
 20366ac:	e0bffa17 	ldw	r2,-24(fp)
 20366b0:	1080008b 	ldhu	r2,2(r2)
 20366b4:	10bfffcc 	andi	r2,r2,65535
 20366b8:	1004923a 	slli	r2,r2,8
 20366bc:	1884b03a 	or	r2,r3,r2
 20366c0:	e0bffc0d 	sth	r2,-16(fp)
    /* if the caller-supplied address is INADDR_ANY,
     * use the wildcard address; else, use the caller-
     * supplied address
     */
    if (sin->sin_addr.s_addr == INADDR_ANY)
 20366c4:	e0bffa17 	ldw	r2,-24(fp)
 20366c8:	10800117 	ldw	r2,4(r2)
 20366cc:	1000021e 	bne	r2,zero,20366d8 <udp4_sockbind+0x20c>
      fhost = 0L;
 20366d0:	e03ff715 	stw	zero,-36(fp)
 20366d4:	00000306 	br	20366e4 <udp4_sockbind+0x218>
    else
      fhost = sin->sin_addr.s_addr;
 20366d8:	e0bffa17 	ldw	r2,-24(fp)
 20366dc:	10800117 	ldw	r2,4(r2)
 20366e0:	e0bff715 	stw	r2,-36(fp)
    /* prepare to bind the socket to the appropriate 
     * local interface address for the to-be-connected 
     * peer
     */
    lhost = ip_mymach(fhost);
 20366e4:	e13ff717 	ldw	r4,-36(fp)
 20366e8:	2040d940 	call	2040d94 <ip_mymach>
 20366ec:	e0bff815 	stw	r2,-32(fp)
    if (lhost == 0)
 20366f0:	e0bff817 	ldw	r2,-32(fp)
 20366f4:	1000021e 	bne	r2,zero,2036700 <udp4_sockbind+0x234>
      return(ENETUNREACH);
 20366f8:	00801c84 	movi	r2,114
 20366fc:	00002506 	br	2036794 <udp4_sockbind+0x2c8>
    /* if the socket hasn't been bound to a local
     * port yet, do so now
     */
    lport = udpconn->u_lport;
 2036700:	e0bffb17 	ldw	r2,-20(fp)
 2036704:	1080018b 	ldhu	r2,6(r2)
 2036708:	e0bff60d 	sth	r2,-40(fp)
    if (lport == 0)
 203670c:	e0bff60b 	ldhu	r2,-40(fp)
 2036710:	1000021e 	bne	r2,zero,203671c <udp4_sockbind+0x250>
      lport = udp_socket();
 2036714:	20459740 	call	2045974 <udp_socket>
 2036718:	e0bff60d 	sth	r2,-40(fp)
    /* bind and connect the UDP endpoint */
    udpconn->u_lhost = lhost;
 203671c:	e0bffb17 	ldw	r2,-20(fp)
 2036720:	e0fff817 	ldw	r3,-32(fp)
 2036724:	10c00315 	stw	r3,12(r2)
    udpconn->u_lport = lport;
 2036728:	e0bffb17 	ldw	r2,-20(fp)
 203672c:	e0fff60b 	ldhu	r3,-40(fp)
 2036730:	10c0018d 	sth	r3,6(r2)
    udpconn->u_fhost = fhost;
 2036734:	e0bffb17 	ldw	r2,-20(fp)
 2036738:	e0fff717 	ldw	r3,-36(fp)
 203673c:	10c00415 	stw	r3,16(r2)
    udpconn->u_fport = fport;
 2036740:	e0bffb17 	ldw	r2,-20(fp)
 2036744:	e0fffc0b 	ldhu	r3,-16(fp)
 2036748:	10c0020d 	sth	r3,8(r2)
    /* mark the socket as connected */
    so->so_state &= ~(SS_ISCONNECTING|SS_ISDISCONNECTING);
 203674c:	e0bffd17 	ldw	r2,-12(fp)
 2036750:	10c0088b 	ldhu	r3,34(r2)
 2036754:	00bffcc4 	movi	r2,-13
 2036758:	1884703a 	and	r2,r3,r2
 203675c:	1007883a 	mov	r3,r2
 2036760:	e0bffd17 	ldw	r2,-12(fp)
 2036764:	10c0088d 	sth	r3,34(r2)
    so->so_state |= SS_ISCONNECTED;
 2036768:	e0bffd17 	ldw	r2,-12(fp)
 203676c:	1080088b 	ldhu	r2,34(r2)
 2036770:	10800094 	ori	r2,r2,2
 2036774:	1007883a 	mov	r3,r2
 2036778:	e0bffd17 	ldw	r2,-12(fp)
 203677c:	10c0088d 	sth	r3,34(r2)
    /* since socket was in listen state, packets may be queued */
    sbflush(&so->so_rcv);   /* dump these now */
 2036780:	e0bffd17 	ldw	r2,-12(fp)
 2036784:	10800a04 	addi	r2,r2,40
 2036788:	1009883a 	mov	r4,r2
 203678c:	202fa0c0 	call	202fa0c <sbflush>
  }
  return 0;
 2036790:	0005883a 	mov	r2,zero
}
 2036794:	e037883a 	mov	sp,fp
 2036798:	dfc00117 	ldw	ra,4(sp)
 203679c:	df000017 	ldw	fp,0(sp)
 20367a0:	dec00204 	addi	sp,sp,8
 20367a4:	f800283a 	ret

020367a8 <udp4_socksend>:

int udp4_socksend(struct socket *so, struct mbuf *m, 
		struct mbuf *nam ) 
{
 20367a8:	defff304 	addi	sp,sp,-52
 20367ac:	dfc00c15 	stw	ra,48(sp)
 20367b0:	df000b15 	stw	fp,44(sp)
 20367b4:	dc000a15 	stw	r16,40(sp)
 20367b8:	df000a04 	addi	fp,sp,40
 20367bc:	e13ffd15 	stw	r4,-12(fp)
 20367c0:	e17ffe15 	stw	r5,-8(fp)
 20367c4:	e1bfff15 	stw	r6,-4(fp)
  PACKET pkt;
#ifdef MULTI_HOMED
  NET ifp;
#endif

  udpconn = udp_lookup(so);
 20367c8:	e13ffd17 	ldw	r4,-12(fp)
 20367cc:	20360880 	call	2036088 <udp_lookup>
 20367d0:	e0bff915 	stw	r2,-28(fp)
  if (!udpconn)
 20367d4:	e0bff917 	ldw	r2,-28(fp)
 20367d8:	1000041e 	bne	r2,zero,20367ec <udp4_socksend+0x44>
  {
    m_free(m);
 20367dc:	e13ffe17 	ldw	r4,-8(fp)
 20367e0:	20295600 	call	2029560 <m_free>
    /* may be bogus socket, but more likely the connection may 
       have closed due to ICMP dest unreachable from other side. */
    return(ECONNREFUSED);
 20367e4:	00801bc4 	movi	r2,111
 20367e8:	0000c806 	br	2036b0c <udp4_socksend+0x364>
  }

  if (nam == NULL)  /* no sendto() info passed, must be send() */
 20367ec:	e0bfff17 	ldw	r2,-4(fp)
 20367f0:	10000e1e 	bne	r2,zero,203682c <udp4_socksend+0x84>
  { 
    if (so->so_state & SS_ISCONNECTED)
 20367f4:	e0bffd17 	ldw	r2,-12(fp)
 20367f8:	1080088b 	ldhu	r2,34(r2)
 20367fc:	10bfffcc 	andi	r2,r2,65535
 2036800:	1080008c 	andi	r2,r2,2
 2036804:	10000726 	beq	r2,zero,2036824 <udp4_socksend+0x7c>
    {
      fport = udpconn->u_fport;
 2036808:	e0bff917 	ldw	r2,-28(fp)
 203680c:	1080020b 	ldhu	r2,8(r2)
 2036810:	e0bff60d 	sth	r2,-40(fp)
      fhost = udpconn->u_fhost;
 2036814:	e0bff917 	ldw	r2,-28(fp)
 2036818:	10800417 	ldw	r2,16(r2)
 203681c:	e0bff715 	stw	r2,-36(fp)
 2036820:	00002806 	br	20368c4 <udp4_socksend+0x11c>
    }
    else
      return (EINVAL);
 2036824:	00800584 	movi	r2,22
 2036828:	0000b806 	br	2036b0c <udp4_socksend+0x364>
  }
  else if(nam->m_len != sizeof (*sin))
 203682c:	e0bfff17 	ldw	r2,-4(fp)
 2036830:	10800217 	ldw	r2,8(r2)
 2036834:	10800420 	cmpeqi	r2,r2,16
 2036838:	1000031e 	bne	r2,zero,2036848 <udp4_socksend+0xa0>
  {
    dtrap();
 203683c:	20285c80 	call	20285c8 <dtrap>
    return (EINVAL);
 2036840:	00800584 	movi	r2,22
 2036844:	0000b106 	br	2036b0c <udp4_socksend+0x364>
  }
  else
  {
    sin = mtod(nam, struct sockaddr_in *);
 2036848:	e0bfff17 	ldw	r2,-4(fp)
 203684c:	10800317 	ldw	r2,12(r2)
 2036850:	e0bffa15 	stw	r2,-24(fp)
    fhost = sin->sin_addr.s_addr;
 2036854:	e0bffa17 	ldw	r2,-24(fp)
 2036858:	10800117 	ldw	r2,4(r2)
 203685c:	e0bff715 	stw	r2,-36(fp)
    /* use caller's fport if specified, ours may be a wildcard */
    if (sin->sin_port)   /* caller gets to change fport on the fly */
 2036860:	e0bffa17 	ldw	r2,-24(fp)
 2036864:	1080008b 	ldhu	r2,2(r2)
 2036868:	10bfffcc 	andi	r2,r2,65535
 203686c:	10000c26 	beq	r2,zero,20368a0 <udp4_socksend+0xf8>
      fport = ntohs(sin->sin_port);
 2036870:	e0bffa17 	ldw	r2,-24(fp)
 2036874:	1080008b 	ldhu	r2,2(r2)
 2036878:	10bfffcc 	andi	r2,r2,65535
 203687c:	1004d23a 	srli	r2,r2,8
 2036880:	1007883a 	mov	r3,r2
 2036884:	e0bffa17 	ldw	r2,-24(fp)
 2036888:	1080008b 	ldhu	r2,2(r2)
 203688c:	10bfffcc 	andi	r2,r2,65535
 2036890:	1004923a 	slli	r2,r2,8
 2036894:	1884b03a 	or	r2,r3,r2
 2036898:	e0bff60d 	sth	r2,-40(fp)
 203689c:	00000906 	br	20368c4 <udp4_socksend+0x11c>
    else  /* use port already set in UDP connection */
    {
      if (udpconn->u_fport == 0) /* don't send to port 0 */
 20368a0:	e0bff917 	ldw	r2,-28(fp)
 20368a4:	1080020b 	ldhu	r2,8(r2)
 20368a8:	10bfffcc 	andi	r2,r2,65535
 20368ac:	1000021e 	bne	r2,zero,20368b8 <udp4_socksend+0x110>
        return (EINVAL);
 20368b0:	00800584 	movi	r2,22
 20368b4:	00009506 	br	2036b0c <udp4_socksend+0x364>
      fport = udpconn->u_fport;
 20368b8:	e0bff917 	ldw	r2,-28(fp)
 20368bc:	1080020b 	ldhu	r2,8(r2)
 20368c0:	e0bff60d 	sth	r2,-40(fp)

  /* since our pkt->nb_buff size is tied to max packet size, we 
   * assume our UDP datagrams are always in one mbuf and that the 
   * mbuf 
   */
  if (m->m_len > (unsigned)udp_maxalloc()) /* but check anyway:*/
 20368c4:	e0bffe17 	ldw	r2,-8(fp)
 20368c8:	14000217 	ldw	r16,8(r2)
 20368cc:	2045b000 	call	2045b00 <udp_maxalloc>
 20368d0:	1400032e 	bgeu	r2,r16,20368e0 <udp4_socksend+0x138>
  {
    dtrap(); /* should never happen */
 20368d4:	20285c80 	call	20285c8 <dtrap>
    return EMSGSIZE;  /* try to recover */
 20368d8:	00801e84 	movi	r2,122
 20368dc:	00008b06 	br	2036b0c <udp4_socksend+0x364>
  }
  pkt = udp_alloc(m->m_len, 0);    /* get a NetPort buffer for send */
 20368e0:	e0bffe17 	ldw	r2,-8(fp)
 20368e4:	10800217 	ldw	r2,8(r2)
 20368e8:	1009883a 	mov	r4,r2
 20368ec:	000b883a 	mov	r5,zero
 20368f0:	2045a440 	call	2045a44 <udp_alloc>
 20368f4:	e0bffb15 	stw	r2,-20(fp)
  if (!pkt)
 20368f8:	e0bffb17 	ldw	r2,-20(fp)
 20368fc:	1000041e 	bne	r2,zero,2036910 <udp4_socksend+0x168>
  {
    m_free(m);
 2036900:	e13ffe17 	ldw	r4,-8(fp)
 2036904:	20295600 	call	2029560 <m_free>
    return ENOBUFS;   /* report buffer shortages */
 2036908:	00801a44 	movi	r2,105
 203690c:	00007f06 	br	2036b0c <udp4_socksend+0x364>
  }
  MEMCPY(pkt->nb_prot, m->m_data, m->m_len);
 2036910:	e0bffb17 	ldw	r2,-20(fp)
 2036914:	11000317 	ldw	r4,12(r2)
 2036918:	e0bffe17 	ldw	r2,-8(fp)
 203691c:	10c00317 	ldw	r3,12(r2)
 2036920:	e0bffe17 	ldw	r2,-8(fp)
 2036924:	10800217 	ldw	r2,8(r2)
 2036928:	180b883a 	mov	r5,r3
 203692c:	100d883a 	mov	r6,r2
 2036930:	200660c0 	call	200660c <memcpy>
  pkt->nb_plen = m->m_len;
 2036934:	e0bffe17 	ldw	r2,-8(fp)
 2036938:	10c00217 	ldw	r3,8(r2)
 203693c:	e0bffb17 	ldw	r2,-20(fp)
 2036940:	10c00415 	stw	r3,16(r2)
  /* finished with mbuf, free it now */
  m_free(m);
 2036944:	e13ffe17 	ldw	r4,-8(fp)
 2036948:	20295600 	call	2029560 <m_free>
  pkt->fhost = fhost;
 203694c:	e0bffb17 	ldw	r2,-20(fp)
 2036950:	e0fff717 	ldw	r3,-36(fp)
 2036954:	10c00715 	stw	r3,28(r2)
     * is up; if (after all that) we don't have an interface then we
     * fail with error EADDRNOTAVAIL; and finally, if we're built
     * for a single-homed configuration where there's only one
     * interface, we might as well use it, so we do.  
   */
  if (fhost == 0xffffffff)
 2036958:	e0bff717 	ldw	r2,-36(fp)
 203695c:	10bfffd8 	cmpnei	r2,r2,-1
 2036960:	10004a1e 	bne	r2,zero,2036a8c <udp4_socksend+0x2e4>
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
 2036964:	e0bff917 	ldw	r2,-28(fp)
 2036968:	10800317 	ldw	r2,12(r2)
 203696c:	10001026 	beq	r2,zero,20369b0 <udp4_socksend+0x208>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 2036970:	00809934 	movhi	r2,612
 2036974:	10b7ce04 	addi	r2,r2,-8392
 2036978:	10800017 	ldw	r2,0(r2)
 203697c:	e0bff815 	stw	r2,-32(fp)
 2036980:	00000806 	br	20369a4 <udp4_socksend+0x1fc>
        if (ifp->n_ipaddr == udpconn->u_lhost)
 2036984:	e0bff817 	ldw	r2,-32(fp)
 2036988:	10c00a17 	ldw	r3,40(r2)
 203698c:	e0bff917 	ldw	r2,-28(fp)
 2036990:	10800317 	ldw	r2,12(r2)
 2036994:	18801d26 	beq	r3,r2,2036a0c <udp4_socksend+0x264>
  if (fhost == 0xffffffff)
  {
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 2036998:	e0bff817 	ldw	r2,-32(fp)
 203699c:	10800017 	ldw	r2,0(r2)
 20369a0:	e0bff815 	stw	r2,-32(fp)
 20369a4:	e0bff817 	ldw	r2,-32(fp)
 20369a8:	103ff61e 	bne	r2,zero,2036984 <udp4_socksend+0x1dc>
 20369ac:	00001a06 	br	2036a18 <udp4_socksend+0x270>
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 20369b0:	00809934 	movhi	r2,612
 20369b4:	10b7ce04 	addi	r2,r2,-8392
 20369b8:	10800017 	ldw	r2,0(r2)
 20369bc:	e0bff815 	stw	r2,-32(fp)
 20369c0:	00000f06 	br	2036a00 <udp4_socksend+0x258>
        if ((ifp->n_flags & NF_BCAST) &&
 20369c4:	e0bff817 	ldw	r2,-32(fp)
 20369c8:	10802a17 	ldw	r2,168(r2)
 20369cc:	1080004c 	andi	r2,r2,1
 20369d0:	10000826 	beq	r2,zero,20369f4 <udp4_socksend+0x24c>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 20369d4:	e0bff817 	ldw	r2,-32(fp)
 20369d8:	10802717 	ldw	r2,156(r2)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
 20369dc:	10000526 	beq	r2,zero,20369f4 <udp4_socksend+0x24c>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 20369e0:	e0bff817 	ldw	r2,-32(fp)
 20369e4:	10802717 	ldw	r2,156(r2)
 20369e8:	10800617 	ldw	r2,24(r2)
 20369ec:	10800058 	cmpnei	r2,r2,1
 20369f0:	10000826 	beq	r2,zero,2036a14 <udp4_socksend+0x26c>
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 20369f4:	e0bff817 	ldw	r2,-32(fp)
 20369f8:	10800017 	ldw	r2,0(r2)
 20369fc:	e0bff815 	stw	r2,-32(fp)
 2036a00:	e0bff817 	ldw	r2,-32(fp)
 2036a04:	103fef1e 	bne	r2,zero,20369c4 <udp4_socksend+0x21c>
 2036a08:	00000306 	br	2036a18 <udp4_socksend+0x270>
#ifdef MULTI_HOMED
    if (udpconn->u_lhost != 0L)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if (ifp->n_ipaddr == udpconn->u_lhost)
          break;
 2036a0c:	0001883a 	nop
 2036a10:	00000106 	br	2036a18 <udp4_socksend+0x270>
    }
    else {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
        if ((ifp->n_flags & NF_BCAST) &&
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
 2036a14:	0001883a 	nop
    }
    if (ifp == NULL)
 2036a18:	e0bff817 	ldw	r2,-32(fp)
 2036a1c:	1000181e 	bne	r2,zero,2036a80 <udp4_socksend+0x2d8>
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 2036a20:	00809934 	movhi	r2,612
 2036a24:	10b7ce04 	addi	r2,r2,-8392
 2036a28:	10800017 	ldw	r2,0(r2)
 2036a2c:	e0bff815 	stw	r2,-32(fp)
 2036a30:	00000b06 	br	2036a60 <udp4_socksend+0x2b8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
 2036a34:	e0bff817 	ldw	r2,-32(fp)
 2036a38:	10802717 	ldw	r2,156(r2)
 2036a3c:	10000526 	beq	r2,zero,2036a54 <udp4_socksend+0x2ac>
 2036a40:	e0bff817 	ldw	r2,-32(fp)
 2036a44:	10802717 	ldw	r2,156(r2)
 2036a48:	10800617 	ldw	r2,24(r2)
 2036a4c:	10800058 	cmpnei	r2,r2,1
 2036a50:	10000626 	beq	r2,zero,2036a6c <udp4_socksend+0x2c4>
          (ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
           break;
    }
    if (ifp == NULL)
    {
      for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 2036a54:	e0bff817 	ldw	r2,-32(fp)
 2036a58:	10800017 	ldw	r2,0(r2)
 2036a5c:	e0bff815 	stw	r2,-32(fp)
 2036a60:	e0bff817 	ldw	r2,-32(fp)
 2036a64:	103ff31e 	bne	r2,zero,2036a34 <udp4_socksend+0x28c>
 2036a68:	00000106 	br	2036a70 <udp4_socksend+0x2c8>
        if ((ifp->n_mib) && (ifp->n_mib->ifAdminStatus == NI_UP))
          break;
 2036a6c:	0001883a 	nop
      if (ifp == NULL)
 2036a70:	e0bff817 	ldw	r2,-32(fp)
 2036a74:	1000021e 	bne	r2,zero,2036a80 <udp4_socksend+0x2d8>
        return(EADDRNOTAVAIL);
 2036a78:	00801f44 	movi	r2,125
 2036a7c:	00002306 	br	2036b0c <udp4_socksend+0x364>
    }
    pkt->net = ifp;
 2036a80:	e0bffb17 	ldw	r2,-20(fp)
 2036a84:	e0fff817 	ldw	r3,-32(fp)
 2036a88:	10c00615 	stw	r3,24(r2)
#ifdef IP_MULTICAST

  /* If the socket has an IP moptions structure for multicast options,
   * place a pointer to this structure in the PACKET structure.
   */
  if (so->inp_moptions)
 2036a8c:	e0bffd17 	ldw	r2,-12(fp)
 2036a90:	10800317 	ldw	r2,12(r2)
 2036a94:	10000426 	beq	r2,zero,2036aa8 <udp4_socksend+0x300>
     pkt->imo = so->inp_moptions;
 2036a98:	e0bffd17 	ldw	r2,-12(fp)
 2036a9c:	10c00317 	ldw	r3,12(r2)
 2036aa0:	e0bffb17 	ldw	r2,-20(fp)
 2036aa4:	10c00b15 	stw	r3,44(r2)

#endif   /* IP_MULTICAST */

   /* have we set options? */
   if (so->so_optsPack)
 2036aa8:	e0bffd17 	ldw	r2,-12(fp)
 2036aac:	10801f17 	ldw	r2,124(r2)
 2036ab0:	10000426 	beq	r2,zero,2036ac4 <udp4_socksend+0x31c>
	   pkt->soxopts = so->so_optsPack; /* yup - copy to pkt */
 2036ab4:	e0bffd17 	ldw	r2,-12(fp)
 2036ab8:	10c01f17 	ldw	r3,124(r2)
 2036abc:	e0bffb17 	ldw	r2,-20(fp)
 2036ac0:	10c00c15 	stw	r3,48(r2)

  /* unlock the net resource; UDP will immediately re-lock it */
  UNLOCK_NET_RESOURCE(NET_RESID);
 2036ac4:	0009883a 	mov	r4,zero
 2036ac8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
  e = udp_send(fport, udpconn->u_lport, pkt);
 2036acc:	e0fff60b 	ldhu	r3,-40(fp)
 2036ad0:	e0bff917 	ldw	r2,-28(fp)
 2036ad4:	1080018b 	ldhu	r2,6(r2)
 2036ad8:	10bfffcc 	andi	r2,r2,65535
 2036adc:	1809883a 	mov	r4,r3
 2036ae0:	100b883a 	mov	r5,r2
 2036ae4:	e1bffb17 	ldw	r6,-20(fp)
 2036ae8:	20455e40 	call	20455e4 <udp_send>
 2036aec:	e0bffc15 	stw	r2,-16(fp)
  LOCK_NET_RESOURCE(NET_RESID);
 2036af0:	0009883a 	mov	r4,zero
 2036af4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
  if (e < 0) 
 2036af8:	e0bffc17 	ldw	r2,-16(fp)
 2036afc:	1000020e 	bge	r2,zero,2036b08 <udp4_socksend+0x360>
     return(e);
 2036b00:	e0bffc17 	ldw	r2,-16(fp)
 2036b04:	00000106 	br	2036b0c <udp4_socksend+0x364>
  return 0;
 2036b08:	0005883a 	mov	r2,zero
}
 2036b0c:	e037883a 	mov	sp,fp
 2036b10:	dfc00217 	ldw	ra,8(sp)
 2036b14:	df000117 	ldw	fp,4(sp)
 2036b18:	dc000017 	ldw	r16,0(sp)
 2036b1c:	dec00304 	addi	sp,sp,12
 2036b20:	f800283a 	ret

02036b24 <udp4_sockaddr>:

int udp4_sockaddr(struct socket *so, struct mbuf *nam , int req)
{
 2036b24:	defff904 	addi	sp,sp,-28
 2036b28:	dfc00615 	stw	ra,24(sp)
 2036b2c:	df000515 	stw	fp,20(sp)
 2036b30:	df000504 	addi	fp,sp,20
 2036b34:	e13ffd15 	stw	r4,-12(fp)
 2036b38:	e17ffe15 	stw	r5,-8(fp)
 2036b3c:	e1bfff15 	stw	r6,-4(fp)
  struct sockaddr_in * sin;
  UDPCONN udpconn;

  sin = mtod(nam, struct sockaddr_in *);
 2036b40:	e0bffe17 	ldw	r2,-8(fp)
 2036b44:	10800317 	ldw	r2,12(r2)
 2036b48:	e0bffb15 	stw	r2,-20(fp)
  if (sin == NULL)
 2036b4c:	e0bffb17 	ldw	r2,-20(fp)
 2036b50:	1000021e 	bne	r2,zero,2036b5c <udp4_sockaddr+0x38>
     return(EINVAL);
 2036b54:	00800584 	movi	r2,22
 2036b58:	00003706 	br	2036c38 <udp4_sockaddr+0x114>
  udpconn = udp_lookup(so);
 2036b5c:	e13ffd17 	ldw	r4,-12(fp)
 2036b60:	20360880 	call	2036088 <udp_lookup>
 2036b64:	e0bffc15 	stw	r2,-16(fp)
  if (!udpconn)
 2036b68:	e0bffc17 	ldw	r2,-16(fp)
 2036b6c:	1000021e 	bne	r2,zero,2036b78 <udp4_sockaddr+0x54>
     return(EINVAL);
 2036b70:	00800584 	movi	r2,22
 2036b74:	00003006 	br	2036c38 <udp4_sockaddr+0x114>
  nam->m_len = sizeof(*sin);
 2036b78:	e0bffe17 	ldw	r2,-8(fp)
 2036b7c:	00c00404 	movi	r3,16
 2036b80:	10c00215 	stw	r3,8(r2)
  if (req == PRU_SOCKADDR)
 2036b84:	e0bfff17 	ldw	r2,-4(fp)
 2036b88:	108003d8 	cmpnei	r2,r2,15
 2036b8c:	1000151e 	bne	r2,zero,2036be4 <udp4_sockaddr+0xc0>
  {
     sin->sin_family = AF_INET;
 2036b90:	e0bffb17 	ldw	r2,-20(fp)
 2036b94:	00c00084 	movi	r3,2
 2036b98:	10c0000d 	sth	r3,0(r2)
     sin->sin_port = htons(udpconn->u_lport);
 2036b9c:	e0bffc17 	ldw	r2,-16(fp)
 2036ba0:	1080018b 	ldhu	r2,6(r2)
 2036ba4:	10bfffcc 	andi	r2,r2,65535
 2036ba8:	1004d23a 	srli	r2,r2,8
 2036bac:	1007883a 	mov	r3,r2
 2036bb0:	e0bffc17 	ldw	r2,-16(fp)
 2036bb4:	1080018b 	ldhu	r2,6(r2)
 2036bb8:	10bfffcc 	andi	r2,r2,65535
 2036bbc:	1004923a 	slli	r2,r2,8
 2036bc0:	1884b03a 	or	r2,r3,r2
 2036bc4:	1007883a 	mov	r3,r2
 2036bc8:	e0bffb17 	ldw	r2,-20(fp)
 2036bcc:	10c0008d 	sth	r3,2(r2)
     sin->sin_addr.s_addr = udpconn->u_lhost;
 2036bd0:	e0bffc17 	ldw	r2,-16(fp)
 2036bd4:	10c00317 	ldw	r3,12(r2)
 2036bd8:	e0bffb17 	ldw	r2,-20(fp)
 2036bdc:	10c00115 	stw	r3,4(r2)
 2036be0:	00001406 	br	2036c34 <udp4_sockaddr+0x110>
  }
  else /* PRU_PEERADDR */
  {
    sin->sin_family = AF_INET;
 2036be4:	e0bffb17 	ldw	r2,-20(fp)
 2036be8:	00c00084 	movi	r3,2
 2036bec:	10c0000d 	sth	r3,0(r2)
    sin->sin_port = htons(udpconn->u_fport);
 2036bf0:	e0bffc17 	ldw	r2,-16(fp)
 2036bf4:	1080020b 	ldhu	r2,8(r2)
 2036bf8:	10bfffcc 	andi	r2,r2,65535
 2036bfc:	1004d23a 	srli	r2,r2,8
 2036c00:	1007883a 	mov	r3,r2
 2036c04:	e0bffc17 	ldw	r2,-16(fp)
 2036c08:	1080020b 	ldhu	r2,8(r2)
 2036c0c:	10bfffcc 	andi	r2,r2,65535
 2036c10:	1004923a 	slli	r2,r2,8
 2036c14:	1884b03a 	or	r2,r3,r2
 2036c18:	1007883a 	mov	r3,r2
 2036c1c:	e0bffb17 	ldw	r2,-20(fp)
 2036c20:	10c0008d 	sth	r3,2(r2)
    sin->sin_addr.s_addr = udpconn->u_fhost;
 2036c24:	e0bffc17 	ldw	r2,-16(fp)
 2036c28:	10c00417 	ldw	r3,16(r2)
 2036c2c:	e0bffb17 	ldw	r2,-20(fp)
 2036c30:	10c00115 	stw	r3,4(r2)
  }
  return 0;
 2036c34:	0005883a 	mov	r2,zero
}
 2036c38:	e037883a 	mov	sp,fp
 2036c3c:	dfc00117 	ldw	ra,4(sp)
 2036c40:	df000017 	ldw	fp,0(sp)
 2036c44:	dec00204 	addi	sp,sp,8
 2036c48:	f800283a 	ret

02036c4c <alt_alarm_start>:
 */ 

int alt_alarm_start (alt_alarm* alarm, alt_u32 nticks,
                     alt_u32 (*callback) (void* context),
                     void* context)
{
 2036c4c:	defff504 	addi	sp,sp,-44
 2036c50:	df000a15 	stw	fp,40(sp)
 2036c54:	df000a04 	addi	fp,sp,40
 2036c58:	e13ffc15 	stw	r4,-16(fp)
 2036c5c:	e17ffd15 	stw	r5,-12(fp)
 2036c60:	e1bffe15 	stw	r6,-8(fp)
 2036c64:	e1ffff15 	stw	r7,-4(fp)
  alt_irq_context irq_context;
  alt_u32 current_nticks = 0;
 2036c68:	e03ff615 	stw	zero,-40(fp)
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 2036c6c:	00808174 	movhi	r2,517
 2036c70:	10909504 	addi	r2,r2,16980
 2036c74:	10800017 	ldw	r2,0(r2)
  
  if (alt_ticks_per_second ())
 2036c78:	10003f26 	beq	r2,zero,2036d78 <alt_alarm_start+0x12c>
  {
    if (alarm)
 2036c7c:	e0bffc17 	ldw	r2,-16(fp)
 2036c80:	10003b26 	beq	r2,zero,2036d70 <alt_alarm_start+0x124>
    {
      alarm->callback = callback;
 2036c84:	e0bffc17 	ldw	r2,-16(fp)
 2036c88:	e0fffe17 	ldw	r3,-8(fp)
 2036c8c:	10c00315 	stw	r3,12(r2)
      alarm->context  = context;
 2036c90:	e0bffc17 	ldw	r2,-16(fp)
 2036c94:	e0ffff17 	ldw	r3,-4(fp)
 2036c98:	10c00515 	stw	r3,20(r2)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2036c9c:	0005303a 	rdctl	r2,status
 2036ca0:	e0bff815 	stw	r2,-32(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2036ca4:	e0fff817 	ldw	r3,-32(fp)
 2036ca8:	00bfff84 	movi	r2,-2
 2036cac:	1884703a 	and	r2,r3,r2
 2036cb0:	1001703a 	wrctl	status,r2
  
  return context;
 2036cb4:	e0bff817 	ldw	r2,-32(fp)
 
      irq_context = alt_irq_disable_all ();
 2036cb8:	e0bff715 	stw	r2,-36(fp)
 * alt_nticks() returns the elapsed number of system clock ticks since reset.
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_nticks (void)
{
  return _alt_nticks;
 2036cbc:	00808174 	movhi	r2,517
 2036cc0:	10909604 	addi	r2,r2,16984
 2036cc4:	10800017 	ldw	r2,0(r2)
      
      current_nticks = alt_nticks();
 2036cc8:	e0bff615 	stw	r2,-40(fp)
      
      alarm->time = nticks + current_nticks + 1; 
 2036ccc:	e0fffd17 	ldw	r3,-12(fp)
 2036cd0:	e0bff617 	ldw	r2,-40(fp)
 2036cd4:	1885883a 	add	r2,r3,r2
 2036cd8:	10c00044 	addi	r3,r2,1
 2036cdc:	e0bffc17 	ldw	r2,-16(fp)
 2036ce0:	10c00215 	stw	r3,8(r2)
      /* 
       * If the desired alarm time causes a roll-over, set the rollover
       * flag. This will prevent the subsequent tick event from causing
       * an alarm too early.
       */
      if(alarm->time < current_nticks)
 2036ce4:	e0bffc17 	ldw	r2,-16(fp)
 2036ce8:	10c00217 	ldw	r3,8(r2)
 2036cec:	e0bff617 	ldw	r2,-40(fp)
 2036cf0:	1880042e 	bgeu	r3,r2,2036d04 <alt_alarm_start+0xb8>
      {
        alarm->rollover = 1;
 2036cf4:	e0bffc17 	ldw	r2,-16(fp)
 2036cf8:	00c00044 	movi	r3,1
 2036cfc:	10c00405 	stb	r3,16(r2)
 2036d00:	00000206 	br	2036d0c <alt_alarm_start+0xc0>
      }
      else
      {
        alarm->rollover = 0;
 2036d04:	e0bffc17 	ldw	r2,-16(fp)
 2036d08:	10000405 	stb	zero,16(r2)
      }
    
      alt_llist_insert (&alt_alarm_list, &alarm->llist);
 2036d0c:	e0bffc17 	ldw	r2,-16(fp)
 2036d10:	00c08174 	movhi	r3,517
 2036d14:	18d03d04 	addi	r3,r3,16628
 2036d18:	e0fff915 	stw	r3,-28(fp)
 2036d1c:	e0bffa15 	stw	r2,-24(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 2036d20:	e0bffa17 	ldw	r2,-24(fp)
 2036d24:	e0fff917 	ldw	r3,-28(fp)
 2036d28:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 2036d2c:	e0bff917 	ldw	r2,-28(fp)
 2036d30:	10c00017 	ldw	r3,0(r2)
 2036d34:	e0bffa17 	ldw	r2,-24(fp)
 2036d38:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 2036d3c:	e0bff917 	ldw	r2,-28(fp)
 2036d40:	10800017 	ldw	r2,0(r2)
 2036d44:	e0fffa17 	ldw	r3,-24(fp)
 2036d48:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 2036d4c:	e0bff917 	ldw	r2,-28(fp)
 2036d50:	e0fffa17 	ldw	r3,-24(fp)
 2036d54:	10c00015 	stw	r3,0(r2)
 2036d58:	e0bff717 	ldw	r2,-36(fp)
 2036d5c:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2036d60:	e0bffb17 	ldw	r2,-20(fp)
 2036d64:	1001703a 	wrctl	status,r2
      alt_irq_enable_all (irq_context);

      return 0;
 2036d68:	0005883a 	mov	r2,zero
 2036d6c:	00000306 	br	2036d7c <alt_alarm_start+0x130>
    }
    else
    {
      return -EINVAL;
 2036d70:	00bffa84 	movi	r2,-22
 2036d74:	00000106 	br	2036d7c <alt_alarm_start+0x130>
    }
  }
  else
  {
    return -ENOTSUP;
 2036d78:	00bfde84 	movi	r2,-134
  }
}
 2036d7c:	e037883a 	mov	sp,fp
 2036d80:	df000017 	ldw	fp,0(sp)
 2036d84:	dec00104 	addi	sp,sp,4
 2036d88:	f800283a 	ret

02036d8c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2036d8c:	defffe04 	addi	sp,sp,-8
 2036d90:	dfc00115 	stw	ra,4(sp)
 2036d94:	df000015 	stw	fp,0(sp)
 2036d98:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2036d9c:	00808174 	movhi	r2,517
 2036da0:	10907704 	addi	r2,r2,16860
 2036da4:	10800017 	ldw	r2,0(r2)
 2036da8:	10000526 	beq	r2,zero,2036dc0 <alt_get_errno+0x34>
 2036dac:	00808174 	movhi	r2,517
 2036db0:	10907704 	addi	r2,r2,16860
 2036db4:	10800017 	ldw	r2,0(r2)
 2036db8:	103ee83a 	callr	r2
 2036dbc:	00000206 	br	2036dc8 <alt_get_errno+0x3c>
 2036dc0:	00808174 	movhi	r2,517
 2036dc4:	10908b04 	addi	r2,r2,16940
}
 2036dc8:	e037883a 	mov	sp,fp
 2036dcc:	dfc00117 	ldw	ra,4(sp)
 2036dd0:	df000017 	ldw	fp,0(sp)
 2036dd4:	dec00204 	addi	sp,sp,8
 2036dd8:	f800283a 	ret

02036ddc <alt_close>:
 *
 * ALT_CLOSE is mapped onto the close() system call in alt_syscall.h
 */
 
int ALT_CLOSE (int fildes)
{
 2036ddc:	defffb04 	addi	sp,sp,-20
 2036de0:	dfc00415 	stw	ra,16(sp)
 2036de4:	df000315 	stw	fp,12(sp)
 2036de8:	df000304 	addi	fp,sp,12
 2036dec:	e13fff15 	stw	r4,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (fildes < 0) ? NULL : &alt_fd_list[fildes];
 2036df0:	e0bfff17 	ldw	r2,-4(fp)
 2036df4:	10000616 	blt	r2,zero,2036e10 <alt_close+0x34>
 2036df8:	e0bfff17 	ldw	r2,-4(fp)
 2036dfc:	10c00324 	muli	r3,r2,12
 2036e00:	00808174 	movhi	r2,517
 2036e04:	108f1e04 	addi	r2,r2,15480
 2036e08:	1885883a 	add	r2,r3,r2
 2036e0c:	00000106 	br	2036e14 <alt_close+0x38>
 2036e10:	0005883a 	mov	r2,zero
 2036e14:	e0bffd15 	stw	r2,-12(fp)

  if (fd)
 2036e18:	e0bffd17 	ldw	r2,-12(fp)
 2036e1c:	10001826 	beq	r2,zero,2036e80 <alt_close+0xa4>
    /*
     * If the associated file system/device has a close function, call it so 
     * that any necessary cleanup code can run.
     */

    rval = (fd->dev->close) ? fd->dev->close(fd) : 0;
 2036e20:	e0bffd17 	ldw	r2,-12(fp)
 2036e24:	10800017 	ldw	r2,0(r2)
 2036e28:	10800417 	ldw	r2,16(r2)
 2036e2c:	10000626 	beq	r2,zero,2036e48 <alt_close+0x6c>
 2036e30:	e0bffd17 	ldw	r2,-12(fp)
 2036e34:	10800017 	ldw	r2,0(r2)
 2036e38:	10800417 	ldw	r2,16(r2)
 2036e3c:	e13ffd17 	ldw	r4,-12(fp)
 2036e40:	103ee83a 	callr	r2
 2036e44:	00000106 	br	2036e4c <alt_close+0x70>
 2036e48:	0005883a 	mov	r2,zero
 2036e4c:	e0bffe15 	stw	r2,-8(fp)

    /* Free the file descriptor structure and return. */

    alt_release_fd (fildes);
 2036e50:	e13fff17 	ldw	r4,-4(fp)
 2036e54:	20157280 	call	2015728 <alt_release_fd>
    if (rval < 0)
 2036e58:	e0bffe17 	ldw	r2,-8(fp)
 2036e5c:	1000060e 	bge	r2,zero,2036e78 <alt_close+0x9c>
    {
      ALT_ERRNO = -rval;
 2036e60:	2036d8c0 	call	2036d8c <alt_get_errno>
 2036e64:	e0fffe17 	ldw	r3,-8(fp)
 2036e68:	00c7c83a 	sub	r3,zero,r3
 2036e6c:	10c00015 	stw	r3,0(r2)
      return -1;
 2036e70:	00bfffc4 	movi	r2,-1
 2036e74:	00000606 	br	2036e90 <alt_close+0xb4>
    }
    return 0;
 2036e78:	0005883a 	mov	r2,zero
 2036e7c:	00000406 	br	2036e90 <alt_close+0xb4>
  }
  else
  {
    ALT_ERRNO = EBADFD;
 2036e80:	2036d8c0 	call	2036d8c <alt_get_errno>
 2036e84:	00c01444 	movi	r3,81
 2036e88:	10c00015 	stw	r3,0(r2)
    return -1;
 2036e8c:	00bfffc4 	movi	r2,-1
  }
}
 2036e90:	e037883a 	mov	sp,fp
 2036e94:	dfc00117 	ldw	ra,4(sp)
 2036e98:	df000017 	ldw	fp,0(sp)
 2036e9c:	dec00204 	addi	sp,sp,8
 2036ea0:	f800283a 	ret

02036ea4 <alt_dev_null_write>:
 * by the alt_dev_null device. It simple discards all data passed to it, and
 * indicates that the data has been successfully transmitted.
 */

static int alt_dev_null_write (alt_fd* fd, const char* ptr, int len)
{
 2036ea4:	defffc04 	addi	sp,sp,-16
 2036ea8:	df000315 	stw	fp,12(sp)
 2036eac:	df000304 	addi	fp,sp,12
 2036eb0:	e13ffd15 	stw	r4,-12(fp)
 2036eb4:	e17ffe15 	stw	r5,-8(fp)
 2036eb8:	e1bfff15 	stw	r6,-4(fp)
  return len;
 2036ebc:	e0bfff17 	ldw	r2,-4(fp)
}
 2036ec0:	e037883a 	mov	sp,fp
 2036ec4:	df000017 	ldw	fp,0(sp)
 2036ec8:	dec00104 	addi	sp,sp,4
 2036ecc:	f800283a 	ret

02036ed0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 2036ed0:	defffe04 	addi	sp,sp,-8
 2036ed4:	dfc00115 	stw	ra,4(sp)
 2036ed8:	df000015 	stw	fp,0(sp)
 2036edc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 2036ee0:	00808174 	movhi	r2,517
 2036ee4:	10907704 	addi	r2,r2,16860
 2036ee8:	10800017 	ldw	r2,0(r2)
 2036eec:	10000526 	beq	r2,zero,2036f04 <alt_get_errno+0x34>
 2036ef0:	00808174 	movhi	r2,517
 2036ef4:	10907704 	addi	r2,r2,16860
 2036ef8:	10800017 	ldw	r2,0(r2)
 2036efc:	103ee83a 	callr	r2
 2036f00:	00000206 	br	2036f0c <alt_get_errno+0x3c>
 2036f04:	00808174 	movhi	r2,517
 2036f08:	10908b04 	addi	r2,r2,16940
}
 2036f0c:	e037883a 	mov	sp,fp
 2036f10:	dfc00117 	ldw	ra,4(sp)
 2036f14:	df000017 	ldw	fp,0(sp)
 2036f18:	dec00204 	addi	sp,sp,8
 2036f1c:	f800283a 	ret

02036f20 <alt_dev_llist_insert>:
/*
 *
 */

int alt_dev_llist_insert (alt_dev_llist* dev, alt_llist* list)
{
 2036f20:	defffa04 	addi	sp,sp,-24
 2036f24:	dfc00515 	stw	ra,20(sp)
 2036f28:	df000415 	stw	fp,16(sp)
 2036f2c:	df000404 	addi	fp,sp,16
 2036f30:	e13ffe15 	stw	r4,-8(fp)
 2036f34:	e17fff15 	stw	r5,-4(fp)
  /*
   * check that the device exists, and that it has a valid name.
   */

  if (!dev || !dev->name)
 2036f38:	e0bffe17 	ldw	r2,-8(fp)
 2036f3c:	10000326 	beq	r2,zero,2036f4c <alt_dev_llist_insert+0x2c>
 2036f40:	e0bffe17 	ldw	r2,-8(fp)
 2036f44:	10800217 	ldw	r2,8(r2)
 2036f48:	1000051e 	bne	r2,zero,2036f60 <alt_dev_llist_insert+0x40>
  {
    ALT_ERRNO = EINVAL;
 2036f4c:	2036ed00 	call	2036ed0 <alt_get_errno>
 2036f50:	00c00584 	movi	r3,22
 2036f54:	10c00015 	stw	r3,0(r2)
    return -EINVAL;
 2036f58:	00bffa84 	movi	r2,-22
 2036f5c:	00001306 	br	2036fac <alt_dev_llist_insert+0x8c>
  
  /*
   * register the device.
   */
  
  alt_llist_insert(list, &dev->llist);
 2036f60:	e0bffe17 	ldw	r2,-8(fp)
 2036f64:	e0ffff17 	ldw	r3,-4(fp)
 2036f68:	e0fffc15 	stw	r3,-16(fp)
 2036f6c:	e0bffd15 	stw	r2,-12(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 2036f70:	e0bffd17 	ldw	r2,-12(fp)
 2036f74:	e0fffc17 	ldw	r3,-16(fp)
 2036f78:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 2036f7c:	e0bffc17 	ldw	r2,-16(fp)
 2036f80:	10c00017 	ldw	r3,0(r2)
 2036f84:	e0bffd17 	ldw	r2,-12(fp)
 2036f88:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 2036f8c:	e0bffc17 	ldw	r2,-16(fp)
 2036f90:	10800017 	ldw	r2,0(r2)
 2036f94:	e0fffd17 	ldw	r3,-12(fp)
 2036f98:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 2036f9c:	e0bffc17 	ldw	r2,-16(fp)
 2036fa0:	e0fffd17 	ldw	r3,-12(fp)
 2036fa4:	10c00015 	stw	r3,0(r2)

  return 0;  
 2036fa8:	0005883a 	mov	r2,zero
}
 2036fac:	e037883a 	mov	sp,fp
 2036fb0:	dfc00117 	ldw	ra,4(sp)
 2036fb4:	df000017 	ldw	fp,0(sp)
 2036fb8:	dec00204 	addi	sp,sp,8
 2036fbc:	f800283a 	ret

02036fc0 <_do_ctors>:
/*
 * Run the C++ static constructors.
 */

void _do_ctors(void)
{
 2036fc0:	defffd04 	addi	sp,sp,-12
 2036fc4:	dfc00215 	stw	ra,8(sp)
 2036fc8:	df000115 	stw	fp,4(sp)
 2036fcc:	df000104 	addi	fp,sp,4
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 2036fd0:	00808174 	movhi	r2,517
 2036fd4:	10b04904 	addi	r2,r2,-16092
 2036fd8:	e0bfff15 	stw	r2,-4(fp)
 2036fdc:	00000606 	br	2036ff8 <_do_ctors+0x38>
        (*ctor) (); 
 2036fe0:	e0bfff17 	ldw	r2,-4(fp)
 2036fe4:	10800017 	ldw	r2,0(r2)
 2036fe8:	103ee83a 	callr	r2

void _do_ctors(void)
{
  constructor* ctor;

  for (ctor = &__CTOR_END__[-1]; ctor >= __CTOR_LIST__; ctor--)
 2036fec:	e0bfff17 	ldw	r2,-4(fp)
 2036ff0:	10bfff04 	addi	r2,r2,-4
 2036ff4:	e0bfff15 	stw	r2,-4(fp)
 2036ff8:	e0ffff17 	ldw	r3,-4(fp)
 2036ffc:	00808174 	movhi	r2,517
 2037000:	10b04a04 	addi	r2,r2,-16088
 2037004:	18bff62e 	bgeu	r3,r2,2036fe0 <_do_ctors+0x20>
        (*ctor) (); 
}
 2037008:	e037883a 	mov	sp,fp
 203700c:	dfc00117 	ldw	ra,4(sp)
 2037010:	df000017 	ldw	fp,0(sp)
 2037014:	dec00204 	addi	sp,sp,8
 2037018:	f800283a 	ret

0203701c <_do_dtors>:
/*
 * Run the C++ static destructors.
 */

void _do_dtors(void)
{
 203701c:	defffd04 	addi	sp,sp,-12
 2037020:	dfc00215 	stw	ra,8(sp)
 2037024:	df000115 	stw	fp,4(sp)
 2037028:	df000104 	addi	fp,sp,4
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 203702c:	00808174 	movhi	r2,517
 2037030:	10b04904 	addi	r2,r2,-16092
 2037034:	e0bfff15 	stw	r2,-4(fp)
 2037038:	00000606 	br	2037054 <_do_dtors+0x38>
        (*dtor) (); 
 203703c:	e0bfff17 	ldw	r2,-4(fp)
 2037040:	10800017 	ldw	r2,0(r2)
 2037044:	103ee83a 	callr	r2

void _do_dtors(void)
{
  destructor* dtor;

  for (dtor = &__DTOR_END__[-1]; dtor >= __DTOR_LIST__; dtor--)
 2037048:	e0bfff17 	ldw	r2,-4(fp)
 203704c:	10bfff04 	addi	r2,r2,-4
 2037050:	e0bfff15 	stw	r2,-4(fp)
 2037054:	e0ffff17 	ldw	r3,-4(fp)
 2037058:	00808174 	movhi	r2,517
 203705c:	10b04a04 	addi	r2,r2,-16088
 2037060:	18bff62e 	bgeu	r3,r2,203703c <_do_dtors+0x20>
        (*dtor) (); 
}
 2037064:	e037883a 	mov	sp,fp
 2037068:	dfc00117 	ldw	ra,4(sp)
 203706c:	df000017 	ldw	fp,0(sp)
 2037070:	dec00204 	addi	sp,sp,8
 2037074:	f800283a 	ret

02037078 <alt_find_dev>:
 * "name" must be an exact match for the devices registered name for a match to
 * be found.
 */
 
alt_dev* alt_find_dev(const char* name, alt_llist* llist)
{
 2037078:	defffa04 	addi	sp,sp,-24
 203707c:	dfc00515 	stw	ra,20(sp)
 2037080:	df000415 	stw	fp,16(sp)
 2037084:	df000404 	addi	fp,sp,16
 2037088:	e13ffe15 	stw	r4,-8(fp)
 203708c:	e17fff15 	stw	r5,-4(fp)
  alt_dev* next = (alt_dev*) llist->next;
 2037090:	e0bfff17 	ldw	r2,-4(fp)
 2037094:	10800017 	ldw	r2,0(r2)
 2037098:	e0bffc15 	stw	r2,-16(fp)
  alt_32 len;

  len  = strlen(name) + 1;
 203709c:	e13ffe17 	ldw	r4,-8(fp)
 20370a0:	2007c640 	call	2007c64 <strlen>
 20370a4:	10800044 	addi	r2,r2,1
 20370a8:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 20370ac:	00000d06 	br	20370e4 <alt_find_dev+0x6c>
    /* 
     * memcmp() is used here rather than strcmp() in order to reduce the size
     * of the executable.
     */

    if (!memcmp (next->name, name, len))
 20370b0:	e0bffc17 	ldw	r2,-16(fp)
 20370b4:	10c00217 	ldw	r3,8(r2)
 20370b8:	e0bffd17 	ldw	r2,-12(fp)
 20370bc:	1809883a 	mov	r4,r3
 20370c0:	e17ffe17 	ldw	r5,-8(fp)
 20370c4:	100d883a 	mov	r6,r2
 20370c8:	200e5b80 	call	200e5b8 <memcmp>
 20370cc:	1000021e 	bne	r2,zero,20370d8 <alt_find_dev+0x60>
    {
      /* match found */

      return next;
 20370d0:	e0bffc17 	ldw	r2,-16(fp)
 20370d4:	00000706 	br	20370f4 <alt_find_dev+0x7c>
    }
    next = (alt_dev*) next->llist.next;
 20370d8:	e0bffc17 	ldw	r2,-16(fp)
 20370dc:	10800017 	ldw	r2,0(r2)
 20370e0:	e0bffc15 	stw	r2,-16(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 

  while (next != (alt_dev*) llist)
 20370e4:	e0fffc17 	ldw	r3,-16(fp)
 20370e8:	e0bfff17 	ldw	r2,-4(fp)
 20370ec:	18bff01e 	bne	r3,r2,20370b0 <alt_find_dev+0x38>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;
 20370f0:	0005883a 	mov	r2,zero
}
 20370f4:	e037883a 	mov	sp,fp
 20370f8:	dfc00117 	ldw	ra,4(sp)
 20370fc:	df000017 	ldw	fp,0(sp)
 2037100:	dec00204 	addi	sp,sp,8
 2037104:	f800283a 	ret

02037108 <alt_find_file>:
 * either '/' or '\0' is the prefix of the filename. For example the filename:
 * "/myfilesystem/junk.txt" would match: "/myfilesystem", but not: "/myfile". 
 */
 
alt_dev* alt_find_file (const char* name)
{
 2037108:	defffb04 	addi	sp,sp,-20
 203710c:	dfc00415 	stw	ra,16(sp)
 2037110:	df000315 	stw	fp,12(sp)
 2037114:	df000304 	addi	fp,sp,12
 2037118:	e13fff15 	stw	r4,-4(fp)
  alt_dev* next = (alt_dev*) alt_fs_list.next;   
 203711c:	00808174 	movhi	r2,517
 2037120:	10907204 	addi	r2,r2,16840
 2037124:	10800017 	ldw	r2,0(r2)
 2037128:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 203712c:	00003106 	br	20371f4 <alt_find_file+0xec>
  {
    len = strlen(next->name);
 2037130:	e0bffd17 	ldw	r2,-12(fp)
 2037134:	10800217 	ldw	r2,8(r2)
 2037138:	1009883a 	mov	r4,r2
 203713c:	2007c640 	call	2007c64 <strlen>
 2037140:	e0bffe15 	stw	r2,-8(fp)
    
    if (next->name[len-1] == '/')
 2037144:	e0bffd17 	ldw	r2,-12(fp)
 2037148:	10c00217 	ldw	r3,8(r2)
 203714c:	e0bffe17 	ldw	r2,-8(fp)
 2037150:	10bfffc4 	addi	r2,r2,-1
 2037154:	1885883a 	add	r2,r3,r2
 2037158:	10800003 	ldbu	r2,0(r2)
 203715c:	10803fcc 	andi	r2,r2,255
 2037160:	1080201c 	xori	r2,r2,128
 2037164:	10bfe004 	addi	r2,r2,-128
 2037168:	10800bd8 	cmpnei	r2,r2,47
 203716c:	1000031e 	bne	r2,zero,203717c <alt_find_file+0x74>
    {
      len -= 1;
 2037170:	e0bffe17 	ldw	r2,-8(fp)
 2037174:	10bfffc4 	addi	r2,r2,-1
 2037178:	e0bffe15 	stw	r2,-8(fp)
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 203717c:	e0bffe17 	ldw	r2,-8(fp)
 2037180:	e0ffff17 	ldw	r3,-4(fp)
 2037184:	1885883a 	add	r2,r3,r2
 2037188:	10800003 	ldbu	r2,0(r2)
 203718c:	10803fcc 	andi	r2,r2,255
 2037190:	1080201c 	xori	r2,r2,128
 2037194:	10bfe004 	addi	r2,r2,-128
 2037198:	10800be0 	cmpeqi	r2,r2,47
 203719c:	1000081e 	bne	r2,zero,20371c0 <alt_find_file+0xb8>
 20371a0:	e0bffe17 	ldw	r2,-8(fp)
 20371a4:	e0ffff17 	ldw	r3,-4(fp)
 20371a8:	1885883a 	add	r2,r3,r2
 20371ac:	10800003 	ldbu	r2,0(r2)
 20371b0:	10803fcc 	andi	r2,r2,255
 20371b4:	1080201c 	xori	r2,r2,128
 20371b8:	10bfe004 	addi	r2,r2,-128
 20371bc:	10000a1e 	bne	r2,zero,20371e8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
 20371c0:	e0bffd17 	ldw	r2,-12(fp)
 20371c4:	10c00217 	ldw	r3,8(r2)
 20371c8:	e0bffe17 	ldw	r2,-8(fp)
 20371cc:	1809883a 	mov	r4,r3
 20371d0:	e17fff17 	ldw	r5,-4(fp)
 20371d4:	100d883a 	mov	r6,r2
 20371d8:	200e5b80 	call	200e5b8 <memcmp>
    if (next->name[len-1] == '/')
    {
      len -= 1;
    }

    if (((name[len] == '/') || (name[len] == '\0')) && 
 20371dc:	1000021e 	bne	r2,zero,20371e8 <alt_find_file+0xe0>
        !memcmp (next->name, name, len))
    {
      /* match found */

      return next;
 20371e0:	e0bffd17 	ldw	r2,-12(fp)
 20371e4:	00000806 	br	2037208 <alt_find_file+0x100>
    }
    next = (alt_dev*) next->llist.next;
 20371e8:	e0bffd17 	ldw	r2,-12(fp)
 20371ec:	10800017 	ldw	r2,0(r2)
 20371f0:	e0bffd15 	stw	r2,-12(fp)
  /*
   * Check each list entry in turn, until a match is found, or we reach the
   * end of the list (i.e. next winds up pointing back to the list head).
   */ 
 
  while (next != (alt_dev*) &alt_fs_list)
 20371f4:	e0fffd17 	ldw	r3,-12(fp)
 20371f8:	00808174 	movhi	r2,517
 20371fc:	10907204 	addi	r2,r2,16840
 2037200:	18bfcb1e 	bne	r3,r2,2037130 <alt_find_file+0x28>
    next = (alt_dev*) next->llist.next;
  }
  
  /* No match found */
  
  return NULL;     
 2037204:	0005883a 	mov	r2,zero
}
 2037208:	e037883a 	mov	sp,fp
 203720c:	dfc00117 	ldw	ra,4(sp)
 2037210:	df000017 	ldw	fp,0(sp)
 2037214:	dec00204 	addi	sp,sp,8
 2037218:	f800283a 	ret

0203721c <alt_fs_reg>:
 * A return value of zero indicates success. A negative return value indicates
 * failure. 
 */
 
int alt_fs_reg (alt_dev* dev)
{
 203721c:	defffc04 	addi	sp,sp,-16
 2037220:	df000315 	stw	fp,12(sp)
 2037224:	df000304 	addi	fp,sp,12
 2037228:	e13fff15 	stw	r4,-4(fp)
  /*
   * check that the device has a name.
   */

  if (!dev->name)
 203722c:	e0bfff17 	ldw	r2,-4(fp)
 2037230:	10800217 	ldw	r2,8(r2)
 2037234:	1000021e 	bne	r2,zero,2037240 <alt_fs_reg+0x24>
  {
    return -ENODEV;
 2037238:	00bffb44 	movi	r2,-19
 203723c:	00001406 	br	2037290 <alt_fs_reg+0x74>
  
  /*
   * register the file system.
   */

  alt_llist_insert(&alt_fs_list, &dev->llist);
 2037240:	e0bfff17 	ldw	r2,-4(fp)
 2037244:	00c08174 	movhi	r3,517
 2037248:	18d07204 	addi	r3,r3,16840
 203724c:	e0fffd15 	stw	r3,-12(fp)
 2037250:	e0bffe15 	stw	r2,-8(fp)
 */

static ALT_INLINE void ALT_ALWAYS_INLINE alt_llist_insert(alt_llist* list, 
                alt_llist* entry)
{
  entry->previous = list;
 2037254:	e0bffe17 	ldw	r2,-8(fp)
 2037258:	e0fffd17 	ldw	r3,-12(fp)
 203725c:	10c00115 	stw	r3,4(r2)
  entry->next     = list->next;
 2037260:	e0bffd17 	ldw	r2,-12(fp)
 2037264:	10c00017 	ldw	r3,0(r2)
 2037268:	e0bffe17 	ldw	r2,-8(fp)
 203726c:	10c00015 	stw	r3,0(r2)

  list->next->previous = entry;
 2037270:	e0bffd17 	ldw	r2,-12(fp)
 2037274:	10800017 	ldw	r2,0(r2)
 2037278:	e0fffe17 	ldw	r3,-8(fp)
 203727c:	10c00115 	stw	r3,4(r2)
  list->next           = entry;
 2037280:	e0bffd17 	ldw	r2,-12(fp)
 2037284:	e0fffe17 	ldw	r3,-8(fp)
 2037288:	10c00015 	stw	r3,0(r2)

  return 0;
 203728c:	0005883a 	mov	r2,zero
} 
 2037290:	e037883a 	mov	sp,fp
 2037294:	df000017 	ldw	fp,0(sp)
 2037298:	dec00104 	addi	sp,sp,4
 203729c:	f800283a 	ret

020372a0 <alt_get_fd>:
 * the offset of the file descriptor within the file descriptor array). A
 * negative value indicates failure.
 */

int alt_get_fd (alt_dev* dev)
{
 20372a0:	defff904 	addi	sp,sp,-28
 20372a4:	dfc00615 	stw	ra,24(sp)
 20372a8:	df000515 	stw	fp,20(sp)
 20372ac:	df000504 	addi	fp,sp,20
 20372b0:	e13fff15 	stw	r4,-4(fp)
  alt_32 i;
  int rc = -EMFILE;
 20372b4:	00bffa04 	movi	r2,-24
 20372b8:	e0bffc15 	stw	r2,-16(fp)
  /* 
   * Take the alt_fd_list_lock semaphore in order to avoid races when 
   * accessing the file descriptor pool.
   */
  
  ALT_SEM_PEND(alt_fd_list_lock, 0);
 20372bc:	00808174 	movhi	r2,517
 20372c0:	1090d704 	addi	r2,r2,17244
 20372c4:	10800017 	ldw	r2,0(r2)
 20372c8:	e0bffd15 	stw	r2,-12(fp)
 20372cc:	e03ffe0d 	sth	zero,-8(fp)
 20372d0:	e0fffe0b 	ldhu	r3,-8(fp)
 20372d4:	e0bffe84 	addi	r2,fp,-6
 20372d8:	e13ffd17 	ldw	r4,-12(fp)
 20372dc:	180b883a 	mov	r5,r3
 20372e0:	100d883a 	mov	r6,r2
 20372e4:	201c0180 	call	201c018 <OSSemPend>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 20372e8:	e03ffb15 	stw	zero,-20(fp)
 20372ec:	00001d06 	br	2037364 <alt_get_fd+0xc4>
  {
    if (!alt_fd_list[i].dev)
 20372f0:	00c08174 	movhi	r3,517
 20372f4:	18cf1e04 	addi	r3,r3,15480
 20372f8:	e0bffb17 	ldw	r2,-20(fp)
 20372fc:	10800324 	muli	r2,r2,12
 2037300:	1885883a 	add	r2,r3,r2
 2037304:	10800017 	ldw	r2,0(r2)
 2037308:	1000131e 	bne	r2,zero,2037358 <alt_get_fd+0xb8>
    {
      alt_fd_list[i].dev = dev;
 203730c:	00c08174 	movhi	r3,517
 2037310:	18cf1e04 	addi	r3,r3,15480
 2037314:	e0bffb17 	ldw	r2,-20(fp)
 2037318:	10800324 	muli	r2,r2,12
 203731c:	1885883a 	add	r2,r3,r2
 2037320:	e0ffff17 	ldw	r3,-4(fp)
 2037324:	10c00015 	stw	r3,0(r2)
      if (i > alt_max_fd)
 2037328:	00808174 	movhi	r2,517
 203732c:	10907604 	addi	r2,r2,16856
 2037330:	10c00017 	ldw	r3,0(r2)
 2037334:	e0bffb17 	ldw	r2,-20(fp)
 2037338:	1880040e 	bge	r3,r2,203734c <alt_get_fd+0xac>
      {
        alt_max_fd = i;
 203733c:	00808174 	movhi	r2,517
 2037340:	10907604 	addi	r2,r2,16856
 2037344:	e0fffb17 	ldw	r3,-20(fp)
 2037348:	10c00015 	stw	r3,0(r2)
      }
      rc = i;
 203734c:	e0bffb17 	ldw	r2,-20(fp)
 2037350:	e0bffc15 	stw	r2,-16(fp)
      goto alt_get_fd_exit;
 2037354:	00000606 	br	2037370 <alt_get_fd+0xd0>
   * indicates the highest file descriptor ever allocated. This is used to
   * improve efficency when searching the file descriptor list, and 
   * therefore reduce contention on the alt_fd_list_lock semaphore. 
   */

  for (i = 0; i < ALT_MAX_FD; i++)
 2037358:	e0bffb17 	ldw	r2,-20(fp)
 203735c:	10800044 	addi	r2,r2,1
 2037360:	e0bffb15 	stw	r2,-20(fp)
 2037364:	e0bffb17 	ldw	r2,-20(fp)
 2037368:	10800810 	cmplti	r2,r2,32
 203736c:	103fe01e 	bne	r2,zero,20372f0 <alt_get_fd+0x50>
  /*
   * Release the alt_fd_list_lock semaphore now that we are done with the
   * file descriptor pool.
   */

  ALT_SEM_POST(alt_fd_list_lock);
 2037370:	00808174 	movhi	r2,517
 2037374:	1090d704 	addi	r2,r2,17244
 2037378:	10800017 	ldw	r2,0(r2)
 203737c:	1009883a 	mov	r4,r2
 2037380:	201c3f80 	call	201c3f8 <OSSemPost>

  return rc;
 2037384:	e0bffc17 	ldw	r2,-16(fp)
}
 2037388:	e037883a 	mov	sp,fp
 203738c:	dfc00117 	ldw	ra,4(sp)
 2037390:	df000017 	ldw	fp,0(sp)
 2037394:	dec00204 	addi	sp,sp,8
 2037398:	f800283a 	ret

0203739c <alt_ic_isr_register>:
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 203739c:	defff904 	addi	sp,sp,-28
 20373a0:	dfc00615 	stw	ra,24(sp)
 20373a4:	df000515 	stw	fp,20(sp)
 20373a8:	df000504 	addi	fp,sp,20
 20373ac:	e13ffc15 	stw	r4,-16(fp)
 20373b0:	e17ffd15 	stw	r5,-12(fp)
 20373b4:	e1bffe15 	stw	r6,-8(fp)
 20373b8:	e1ffff15 	stw	r7,-4(fp)
    return alt_iic_isr_register(ic_id, irq, isr, isr_context, flags);
 20373bc:	e0800217 	ldw	r2,8(fp)
 20373c0:	d8800015 	stw	r2,0(sp)
 20373c4:	e13ffc17 	ldw	r4,-16(fp)
 20373c8:	e17ffd17 	ldw	r5,-12(fp)
 20373cc:	e1bffe17 	ldw	r6,-8(fp)
 20373d0:	e1ffff17 	ldw	r7,-4(fp)
 20373d4:	20375740 	call	2037574 <alt_iic_isr_register>
}  
 20373d8:	e037883a 	mov	sp,fp
 20373dc:	dfc00117 	ldw	ra,4(sp)
 20373e0:	df000017 	ldw	fp,0(sp)
 20373e4:	dec00204 	addi	sp,sp,8
 20373e8:	f800283a 	ret

020373ec <alt_ic_irq_enable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_enable (alt_u32 ic_id, alt_u32 irq)
{
 20373ec:	defff904 	addi	sp,sp,-28
 20373f0:	df000615 	stw	fp,24(sp)
 20373f4:	df000604 	addi	fp,sp,24
 20373f8:	e13ffe15 	stw	r4,-8(fp)
 20373fc:	e17fff15 	stw	r5,-4(fp)
 2037400:	e0bfff17 	ldw	r2,-4(fp)
 2037404:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 2037408:	0005303a 	rdctl	r2,status
 203740c:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 2037410:	e0fffb17 	ldw	r3,-20(fp)
 2037414:	00bfff84 	movi	r2,-2
 2037418:	1884703a 	and	r2,r3,r2
 203741c:	1001703a 	wrctl	status,r2
  
  return context;
 2037420:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_enable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 2037424:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active |= (1 << id);
 2037428:	e0bffa17 	ldw	r2,-24(fp)
 203742c:	00c00044 	movi	r3,1
 2037430:	1884983a 	sll	r2,r3,r2
 2037434:	1007883a 	mov	r3,r2
 2037438:	00808174 	movhi	r2,517
 203743c:	1090d804 	addi	r2,r2,17248
 2037440:	10800017 	ldw	r2,0(r2)
 2037444:	1886b03a 	or	r3,r3,r2
 2037448:	00808174 	movhi	r2,517
 203744c:	1090d804 	addi	r2,r2,17248
 2037450:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 2037454:	00808174 	movhi	r2,517
 2037458:	1090d804 	addi	r2,r2,17248
 203745c:	10800017 	ldw	r2,0(r2)
 2037460:	100170fa 	wrctl	ienable,r2
 2037464:	e0bffc17 	ldw	r2,-16(fp)
 2037468:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 203746c:	e0bffd17 	ldw	r2,-12(fp)
 2037470:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 2037474:	0005883a 	mov	r2,zero
    return alt_irq_enable(irq);
}
 2037478:	e037883a 	mov	sp,fp
 203747c:	df000017 	ldw	fp,0(sp)
 2037480:	dec00104 	addi	sp,sp,4
 2037484:	f800283a 	ret

02037488 <alt_ic_irq_disable>:
  * @param ic_id            Ignored.
  * @param irq              IRQ number
  * @return                 0 if successful, else error (-1)
  */
int alt_ic_irq_disable(alt_u32 ic_id, alt_u32 irq)
{
 2037488:	defff904 	addi	sp,sp,-28
 203748c:	df000615 	stw	fp,24(sp)
 2037490:	df000604 	addi	fp,sp,24
 2037494:	e13ffe15 	stw	r4,-8(fp)
 2037498:	e17fff15 	stw	r5,-4(fp)
 203749c:	e0bfff17 	ldw	r2,-4(fp)
 20374a0:	e0bffa15 	stw	r2,-24(fp)
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20374a4:	0005303a 	rdctl	r2,status
 20374a8:	e0bffb15 	stw	r2,-20(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20374ac:	e0fffb17 	ldw	r3,-20(fp)
 20374b0:	00bfff84 	movi	r2,-2
 20374b4:	1884703a 	and	r2,r3,r2
 20374b8:	1001703a 	wrctl	status,r2
  
  return context;
 20374bc:	e0bffb17 	ldw	r2,-20(fp)
static ALT_INLINE int ALT_ALWAYS_INLINE alt_irq_disable (alt_u32 id)
{
  alt_irq_context  status;
  extern volatile alt_u32 alt_irq_active;

  status = alt_irq_disable_all ();
 20374c0:	e0bffc15 	stw	r2,-16(fp)

  alt_irq_active &= ~(1 << id);
 20374c4:	e0bffa17 	ldw	r2,-24(fp)
 20374c8:	00c00044 	movi	r3,1
 20374cc:	1884983a 	sll	r2,r3,r2
 20374d0:	0084303a 	nor	r2,zero,r2
 20374d4:	1007883a 	mov	r3,r2
 20374d8:	00808174 	movhi	r2,517
 20374dc:	1090d804 	addi	r2,r2,17248
 20374e0:	10800017 	ldw	r2,0(r2)
 20374e4:	1886703a 	and	r3,r3,r2
 20374e8:	00808174 	movhi	r2,517
 20374ec:	1090d804 	addi	r2,r2,17248
 20374f0:	10c00015 	stw	r3,0(r2)
  NIOS2_WRITE_IENABLE (alt_irq_active);
 20374f4:	00808174 	movhi	r2,517
 20374f8:	1090d804 	addi	r2,r2,17248
 20374fc:	10800017 	ldw	r2,0(r2)
 2037500:	100170fa 	wrctl	ienable,r2
 2037504:	e0bffc17 	ldw	r2,-16(fp)
 2037508:	e0bffd15 	stw	r2,-12(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 203750c:	e0bffd17 	ldw	r2,-12(fp)
 2037510:	1001703a 	wrctl	status,r2

  alt_irq_enable_all(status);

  return 0;
 2037514:	0005883a 	mov	r2,zero
    return alt_irq_disable(irq);
}
 2037518:	e037883a 	mov	sp,fp
 203751c:	df000017 	ldw	fp,0(sp)
 2037520:	dec00104 	addi	sp,sp,4
 2037524:	f800283a 	ret

02037528 <alt_ic_irq_enabled>:
  * @param irq              IRQ number
  * @return                 Zero if corresponding interrupt is disabled and
  *                         non-zero otherwise.
  */
alt_u32 alt_ic_irq_enabled(alt_u32 ic_id, alt_u32 irq)
{
 2037528:	defffc04 	addi	sp,sp,-16
 203752c:	df000315 	stw	fp,12(sp)
 2037530:	df000304 	addi	fp,sp,12
 2037534:	e13ffe15 	stw	r4,-8(fp)
 2037538:	e17fff15 	stw	r5,-4(fp)
    alt_u32 irq_enabled;

    NIOS2_READ_IENABLE(irq_enabled);
 203753c:	000530fa 	rdctl	r2,ienable
 2037540:	e0bffd15 	stw	r2,-12(fp)

    return (irq_enabled & (1 << irq)) ? 1: 0;
 2037544:	e0bfff17 	ldw	r2,-4(fp)
 2037548:	00c00044 	movi	r3,1
 203754c:	1884983a 	sll	r2,r3,r2
 2037550:	1007883a 	mov	r3,r2
 2037554:	e0bffd17 	ldw	r2,-12(fp)
 2037558:	1884703a 	and	r2,r3,r2
 203755c:	1004c03a 	cmpne	r2,r2,zero
 2037560:	10803fcc 	andi	r2,r2,255
}
 2037564:	e037883a 	mov	sp,fp
 2037568:	df000017 	ldw	fp,0(sp)
 203756c:	dec00104 	addi	sp,sp,4
 2037570:	f800283a 	ret

02037574 <alt_iic_isr_register>:
  * @param flags            
  * @return                 0 if successful, else error (-1)
  */
int alt_iic_isr_register(alt_u32 ic_id, alt_u32 irq, alt_isr_func isr, 
  void *isr_context, void *flags)
{
 2037574:	defff504 	addi	sp,sp,-44
 2037578:	dfc00a15 	stw	ra,40(sp)
 203757c:	df000915 	stw	fp,36(sp)
 2037580:	df000904 	addi	fp,sp,36
 2037584:	e13ffc15 	stw	r4,-16(fp)
 2037588:	e17ffd15 	stw	r5,-12(fp)
 203758c:	e1bffe15 	stw	r6,-8(fp)
 2037590:	e1ffff15 	stw	r7,-4(fp)
  int rc = -EINVAL;  
 2037594:	00bffa84 	movi	r2,-22
 2037598:	e0bff715 	stw	r2,-36(fp)
  int id = irq;             /* IRQ interpreted as the interrupt ID. */
 203759c:	e0bffd17 	ldw	r2,-12(fp)
 20375a0:	e0bff815 	stw	r2,-32(fp)
  alt_irq_context status;

  if (id < ALT_NIRQ)
 20375a4:	e0bff817 	ldw	r2,-32(fp)
 20375a8:	10800808 	cmpgei	r2,r2,32
 20375ac:	1000271e 	bne	r2,zero,203764c <alt_iic_isr_register+0xd8>
static ALT_INLINE alt_irq_context ALT_ALWAYS_INLINE 
       alt_irq_disable_all (void)
{
  alt_irq_context context;

  NIOS2_READ_STATUS (context);
 20375b0:	0005303a 	rdctl	r2,status
 20375b4:	e0bffa15 	stw	r2,-24(fp)

  NIOS2_WRITE_STATUS (context & ~NIOS2_STATUS_PIE_MSK);
 20375b8:	e0fffa17 	ldw	r3,-24(fp)
 20375bc:	00bfff84 	movi	r2,-2
 20375c0:	1884703a 	and	r2,r3,r2
 20375c4:	1001703a 	wrctl	status,r2
  
  return context;
 20375c8:	e0bffa17 	ldw	r2,-24(fp)
     * interrupts are disabled while the handler tables are updated to ensure
     * that an interrupt doesn't occur while the tables are in an inconsistant
     * state.
     */

    status = alt_irq_disable_all();
 20375cc:	e0bff915 	stw	r2,-28(fp)

    alt_irq[id].handler = isr;
 20375d0:	00c09934 	movhi	r3,612
 20375d4:	18f72d04 	addi	r3,r3,-9036
 20375d8:	e0bff817 	ldw	r2,-32(fp)
 20375dc:	100490fa 	slli	r2,r2,3
 20375e0:	1885883a 	add	r2,r3,r2
 20375e4:	e0fffe17 	ldw	r3,-8(fp)
 20375e8:	10c00015 	stw	r3,0(r2)
    alt_irq[id].context = isr_context;
 20375ec:	00c09934 	movhi	r3,612
 20375f0:	18f72d04 	addi	r3,r3,-9036
 20375f4:	e0bff817 	ldw	r2,-32(fp)
 20375f8:	100490fa 	slli	r2,r2,3
 20375fc:	1885883a 	add	r2,r3,r2
 2037600:	10800104 	addi	r2,r2,4
 2037604:	e0ffff17 	ldw	r3,-4(fp)
 2037608:	10c00015 	stw	r3,0(r2)

    rc = (isr) ? alt_ic_irq_enable(ic_id, id) : alt_ic_irq_disable(ic_id, id);
 203760c:	e0bffe17 	ldw	r2,-8(fp)
 2037610:	10000526 	beq	r2,zero,2037628 <alt_iic_isr_register+0xb4>
 2037614:	e0bff817 	ldw	r2,-32(fp)
 2037618:	e13ffc17 	ldw	r4,-16(fp)
 203761c:	100b883a 	mov	r5,r2
 2037620:	20373ec0 	call	20373ec <alt_ic_irq_enable>
 2037624:	00000406 	br	2037638 <alt_iic_isr_register+0xc4>
 2037628:	e0bff817 	ldw	r2,-32(fp)
 203762c:	e13ffc17 	ldw	r4,-16(fp)
 2037630:	100b883a 	mov	r5,r2
 2037634:	20374880 	call	2037488 <alt_ic_irq_disable>
 2037638:	e0bff715 	stw	r2,-36(fp)
 203763c:	e0bff917 	ldw	r2,-28(fp)
 2037640:	e0bffb15 	stw	r2,-20(fp)
  status &= ~NIOS2_STATUS_PIE_MSK;
  status |= (context & NIOS2_STATUS_PIE_MSK);
  
  NIOS2_WRITE_STATUS (status);
#else
  NIOS2_WRITE_STATUS (context);
 2037644:	e0bffb17 	ldw	r2,-20(fp)
 2037648:	1001703a 	wrctl	status,r2

    alt_irq_enable_all(status);
  }

  return rc; 
 203764c:	e0bff717 	ldw	r2,-36(fp)
}
 2037650:	e037883a 	mov	sp,fp
 2037654:	dfc00117 	ldw	ra,4(sp)
 2037658:	df000017 	ldw	fp,0(sp)
 203765c:	dec00204 	addi	sp,sp,8
 2037660:	f800283a 	ret

02037664 <alt_open_fd>:
 * If the device can not be succesfully opened, then the input file descriptor
 * remains unchanged.
 */

static void alt_open_fd(alt_fd* fd, const char* name, int flags, int mode)
{
 2037664:	defff904 	addi	sp,sp,-28
 2037668:	dfc00615 	stw	ra,24(sp)
 203766c:	df000515 	stw	fp,20(sp)
 2037670:	df000504 	addi	fp,sp,20
 2037674:	e13ffc15 	stw	r4,-16(fp)
 2037678:	e17ffd15 	stw	r5,-12(fp)
 203767c:	e1bffe15 	stw	r6,-8(fp)
 2037680:	e1ffff15 	stw	r7,-4(fp)
  int old;

  old = open (name, flags, mode);
 2037684:	e13ffd17 	ldw	r4,-12(fp)
 2037688:	e17ffe17 	ldw	r5,-8(fp)
 203768c:	e1bfff17 	ldw	r6,-4(fp)
 2037690:	20155d40 	call	20155d4 <open>
 2037694:	e0bffb15 	stw	r2,-20(fp)

  if (old >= 0)
 2037698:	e0bffb17 	ldw	r2,-20(fp)
 203769c:	10001c16 	blt	r2,zero,2037710 <alt_open_fd+0xac>
  {
    fd->dev      = alt_fd_list[old].dev;
 20376a0:	00c08174 	movhi	r3,517
 20376a4:	18cf1e04 	addi	r3,r3,15480
 20376a8:	e0bffb17 	ldw	r2,-20(fp)
 20376ac:	10800324 	muli	r2,r2,12
 20376b0:	1885883a 	add	r2,r3,r2
 20376b4:	10c00017 	ldw	r3,0(r2)
 20376b8:	e0bffc17 	ldw	r2,-16(fp)
 20376bc:	10c00015 	stw	r3,0(r2)
    fd->priv     = alt_fd_list[old].priv;
 20376c0:	00c08174 	movhi	r3,517
 20376c4:	18cf1e04 	addi	r3,r3,15480
 20376c8:	e0bffb17 	ldw	r2,-20(fp)
 20376cc:	10800324 	muli	r2,r2,12
 20376d0:	1885883a 	add	r2,r3,r2
 20376d4:	10800104 	addi	r2,r2,4
 20376d8:	10c00017 	ldw	r3,0(r2)
 20376dc:	e0bffc17 	ldw	r2,-16(fp)
 20376e0:	10c00115 	stw	r3,4(r2)
    fd->fd_flags = alt_fd_list[old].fd_flags;
 20376e4:	00c08174 	movhi	r3,517
 20376e8:	18cf1e04 	addi	r3,r3,15480
 20376ec:	e0bffb17 	ldw	r2,-20(fp)
 20376f0:	10800324 	muli	r2,r2,12
 20376f4:	1885883a 	add	r2,r3,r2
 20376f8:	10800204 	addi	r2,r2,8
 20376fc:	10c00017 	ldw	r3,0(r2)
 2037700:	e0bffc17 	ldw	r2,-16(fp)
 2037704:	10c00215 	stw	r3,8(r2)

    alt_release_fd (old);
 2037708:	e13ffb17 	ldw	r4,-20(fp)
 203770c:	20157280 	call	2015728 <alt_release_fd>
  }
} 
 2037710:	e037883a 	mov	sp,fp
 2037714:	dfc00117 	ldw	ra,4(sp)
 2037718:	df000017 	ldw	fp,0(sp)
 203771c:	dec00204 	addi	sp,sp,8
 2037720:	f800283a 	ret

02037724 <alt_io_redirect>:
 */
 
void alt_io_redirect(const char* stdout_dev, 
                     const char* stdin_dev, 
                     const char* stderr_dev)
{
 2037724:	defffb04 	addi	sp,sp,-20
 2037728:	dfc00415 	stw	ra,16(sp)
 203772c:	df000315 	stw	fp,12(sp)
 2037730:	df000304 	addi	fp,sp,12
 2037734:	e13ffd15 	stw	r4,-12(fp)
 2037738:	e17ffe15 	stw	r5,-8(fp)
 203773c:	e1bfff15 	stw	r6,-4(fp)
  /* Redirect the channels */

  alt_open_fd (&alt_fd_list[STDOUT_FILENO], stdout_dev, O_WRONLY, 0777);
 2037740:	01008174 	movhi	r4,517
 2037744:	210f2104 	addi	r4,r4,15492
 2037748:	e17ffd17 	ldw	r5,-12(fp)
 203774c:	01800044 	movi	r6,1
 2037750:	01c07fc4 	movi	r7,511
 2037754:	20376640 	call	2037664 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDIN_FILENO], stdin_dev, O_RDONLY, 0777);
 2037758:	01008174 	movhi	r4,517
 203775c:	210f1e04 	addi	r4,r4,15480
 2037760:	e17ffe17 	ldw	r5,-8(fp)
 2037764:	000d883a 	mov	r6,zero
 2037768:	01c07fc4 	movi	r7,511
 203776c:	20376640 	call	2037664 <alt_open_fd>
  alt_open_fd (&alt_fd_list[STDERR_FILENO], stderr_dev, O_WRONLY, 0777);
 2037770:	01008174 	movhi	r4,517
 2037774:	210f2404 	addi	r4,r4,15504
 2037778:	e17fff17 	ldw	r5,-4(fp)
 203777c:	01800044 	movi	r6,1
 2037780:	01c07fc4 	movi	r7,511
 2037784:	20376640 	call	2037664 <alt_open_fd>
}  
 2037788:	e037883a 	mov	sp,fp
 203778c:	dfc00117 	ldw	ra,4(sp)
 2037790:	df000017 	ldw	fp,0(sp)
 2037794:	dec00204 	addi	sp,sp,8
 2037798:	f800283a 	ret

0203779c <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 203779c:	defffe04 	addi	sp,sp,-8
 20377a0:	dfc00115 	stw	ra,4(sp)
 20377a4:	df000015 	stw	fp,0(sp)
 20377a8:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20377ac:	00808174 	movhi	r2,517
 20377b0:	10907704 	addi	r2,r2,16860
 20377b4:	10800017 	ldw	r2,0(r2)
 20377b8:	10000526 	beq	r2,zero,20377d0 <alt_get_errno+0x34>
 20377bc:	00808174 	movhi	r2,517
 20377c0:	10907704 	addi	r2,r2,16860
 20377c4:	10800017 	ldw	r2,0(r2)
 20377c8:	103ee83a 	callr	r2
 20377cc:	00000206 	br	20377d8 <alt_get_errno+0x3c>
 20377d0:	00808174 	movhi	r2,517
 20377d4:	10908b04 	addi	r2,r2,16940
}
 20377d8:	e037883a 	mov	sp,fp
 20377dc:	dfc00117 	ldw	ra,4(sp)
 20377e0:	df000017 	ldw	fp,0(sp)
 20377e4:	dec00204 	addi	sp,sp,8
 20377e8:	f800283a 	ret

020377ec <alt_read>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_READ (int file, void *ptr, size_t len)
{
 20377ec:	defff904 	addi	sp,sp,-28
 20377f0:	dfc00615 	stw	ra,24(sp)
 20377f4:	df000515 	stw	fp,20(sp)
 20377f8:	df000504 	addi	fp,sp,20
 20377fc:	e13ffd15 	stw	r4,-12(fp)
 2037800:	e17ffe15 	stw	r5,-8(fp)
 2037804:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2037808:	e0bffd17 	ldw	r2,-12(fp)
 203780c:	10000616 	blt	r2,zero,2037828 <alt_read+0x3c>
 2037810:	e0bffd17 	ldw	r2,-12(fp)
 2037814:	10c00324 	muli	r3,r2,12
 2037818:	00808174 	movhi	r2,517
 203781c:	108f1e04 	addi	r2,r2,15480
 2037820:	1885883a 	add	r2,r3,r2
 2037824:	00000106 	br	203782c <alt_read+0x40>
 2037828:	0005883a 	mov	r2,zero
 203782c:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 2037830:	e0bffb17 	ldw	r2,-20(fp)
 2037834:	10002026 	beq	r2,zero,20378b8 <alt_read+0xcc>
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 2037838:	e0bffb17 	ldw	r2,-20(fp)
 203783c:	10800217 	ldw	r2,8(r2)
 2037840:	108000cc 	andi	r2,r2,3
 2037844:	10800060 	cmpeqi	r2,r2,1
 2037848:	1000171e 	bne	r2,zero,20378a8 <alt_read+0xbc>
        (fd->dev->read))
 203784c:	e0bffb17 	ldw	r2,-20(fp)
 2037850:	10800017 	ldw	r2,0(r2)
 2037854:	10800517 	ldw	r2,20(r2)
     * If the file has not been opened with read access, or if the driver does
     * not provide an implementation of read(), generate an error. Otherwise
     * call the drivers read() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_WRONLY) && 
 2037858:	10001326 	beq	r2,zero,20378a8 <alt_read+0xbc>
        (fd->dev->read))
      {
        if ((rval = fd->dev->read(fd, ptr, len)) < 0)
 203785c:	e0bffb17 	ldw	r2,-20(fp)
 2037860:	10800017 	ldw	r2,0(r2)
 2037864:	10c00517 	ldw	r3,20(r2)
 2037868:	e0bfff17 	ldw	r2,-4(fp)
 203786c:	e13ffb17 	ldw	r4,-20(fp)
 2037870:	e17ffe17 	ldw	r5,-8(fp)
 2037874:	100d883a 	mov	r6,r2
 2037878:	183ee83a 	callr	r3
 203787c:	e0bffc15 	stw	r2,-16(fp)
 2037880:	e0bffc17 	ldw	r2,-16(fp)
 2037884:	1000060e 	bge	r2,zero,20378a0 <alt_read+0xb4>
        {
          ALT_ERRNO = -rval;
 2037888:	203779c0 	call	203779c <alt_get_errno>
 203788c:	e0fffc17 	ldw	r3,-16(fp)
 2037890:	00c7c83a 	sub	r3,zero,r3
 2037894:	10c00015 	stw	r3,0(r2)
          return -1;
 2037898:	00bfffc4 	movi	r2,-1
 203789c:	00000a06 	br	20378c8 <alt_read+0xdc>
        }
        return rval;
 20378a0:	e0bffc17 	ldw	r2,-16(fp)
 20378a4:	00000806 	br	20378c8 <alt_read+0xdc>
      }
      else
      {
        ALT_ERRNO = EACCES;
 20378a8:	203779c0 	call	203779c <alt_get_errno>
 20378ac:	00c00344 	movi	r3,13
 20378b0:	10c00015 	stw	r3,0(r2)
 20378b4:	00000306 	br	20378c4 <alt_read+0xd8>
      }
    }
  else
  {
    ALT_ERRNO = EBADFD;
 20378b8:	203779c0 	call	203779c <alt_get_errno>
 20378bc:	00c01444 	movi	r3,81
 20378c0:	10c00015 	stw	r3,0(r2)
  }
  return -1;
 20378c4:	00bfffc4 	movi	r2,-1
}
 20378c8:	e037883a 	mov	sp,fp
 20378cc:	dfc00117 	ldw	ra,4(sp)
 20378d0:	df000017 	ldw	fp,0(sp)
 20378d4:	dec00204 	addi	sp,sp,8
 20378d8:	f800283a 	ret

020378dc <alt_remap_cached>:
 * Convert a pointer to a block of uncached memory, into a block of
 * cached memory.
 */

void* alt_remap_cached (volatile void* ptr, alt_u32 len)
{
 20378dc:	defffd04 	addi	sp,sp,-12
 20378e0:	df000215 	stw	fp,8(sp)
 20378e4:	df000204 	addi	fp,sp,8
 20378e8:	e13ffe15 	stw	r4,-8(fp)
 20378ec:	e17fff15 	stw	r5,-4(fp)
  return (void*) (((alt_u32) ptr) & ~BYPASS_DCACHE_MASK);
 20378f0:	e0fffe17 	ldw	r3,-8(fp)
 20378f4:	00a00034 	movhi	r2,32768
 20378f8:	10bfffc4 	addi	r2,r2,-1
 20378fc:	1884703a 	and	r2,r3,r2
}
 2037900:	e037883a 	mov	sp,fp
 2037904:	df000017 	ldw	fp,0(sp)
 2037908:	dec00104 	addi	sp,sp,4
 203790c:	f800283a 	ret

02037910 <alt_remap_uncached>:
 * Convert a pointer to a block of cached memory, into a block of
 * uncached memory.
 */

volatile void* alt_remap_uncached (void* ptr, alt_u32 len)
{
 2037910:	defffc04 	addi	sp,sp,-16
 2037914:	dfc00315 	stw	ra,12(sp)
 2037918:	df000215 	stw	fp,8(sp)
 203791c:	df000204 	addi	fp,sp,8
 2037920:	e13ffe15 	stw	r4,-8(fp)
 2037924:	e17fff15 	stw	r5,-4(fp)
  alt_dcache_flush (ptr, len);
 2037928:	e13ffe17 	ldw	r4,-8(fp)
 203792c:	e17fff17 	ldw	r5,-4(fp)
 2037930:	2014fb40 	call	2014fb4 <alt_dcache_flush>
  return (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK);
 2037934:	e0bffe17 	ldw	r2,-8(fp)
 2037938:	10a00034 	orhi	r2,r2,32768
}
 203793c:	e037883a 	mov	sp,fp
 2037940:	dfc00117 	ldw	ra,4(sp)
 2037944:	df000017 	ldw	fp,0(sp)
 2037948:	dec00204 	addi	sp,sp,8
 203794c:	f800283a 	ret

02037950 <alt_uncached_malloc>:
/*
 * Allocate a block of uncached memory.
 */

volatile void* alt_uncached_malloc (size_t size)
{
 2037950:	defffc04 	addi	sp,sp,-16
 2037954:	dfc00315 	stw	ra,12(sp)
 2037958:	df000215 	stw	fp,8(sp)
 203795c:	df000204 	addi	fp,sp,8
 2037960:	e13fff15 	stw	r4,-4(fp)
  void* ptr;

  ptr = malloc (size);
 2037964:	e13fff17 	ldw	r4,-4(fp)
 2037968:	204bd440 	call	204bd44 <malloc>
 203796c:	e0bffe15 	stw	r2,-8(fp)

  alt_dcache_flush (ptr, size);
 2037970:	e13ffe17 	ldw	r4,-8(fp)
 2037974:	e17fff17 	ldw	r5,-4(fp)
 2037978:	2014fb40 	call	2014fb4 <alt_dcache_flush>

  return ptr ? (volatile void*) (((alt_u32) ptr) | BYPASS_DCACHE_MASK) : NULL;
 203797c:	e0bffe17 	ldw	r2,-8(fp)
 2037980:	10000326 	beq	r2,zero,2037990 <alt_uncached_malloc+0x40>
 2037984:	e0bffe17 	ldw	r2,-8(fp)
 2037988:	10a00034 	orhi	r2,r2,32768
 203798c:	00000106 	br	2037994 <alt_uncached_malloc+0x44>
 2037990:	0005883a 	mov	r2,zero
}
 2037994:	e037883a 	mov	sp,fp
 2037998:	dfc00117 	ldw	ra,4(sp)
 203799c:	df000017 	ldw	fp,0(sp)
 20379a0:	dec00204 	addi	sp,sp,8
 20379a4:	f800283a 	ret

020379a8 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 20379a8:	defffe04 	addi	sp,sp,-8
 20379ac:	dfc00115 	stw	ra,4(sp)
 20379b0:	df000015 	stw	fp,0(sp)
 20379b4:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 20379b8:	00808174 	movhi	r2,517
 20379bc:	10907704 	addi	r2,r2,16860
 20379c0:	10800017 	ldw	r2,0(r2)
 20379c4:	10000526 	beq	r2,zero,20379dc <alt_get_errno+0x34>
 20379c8:	00808174 	movhi	r2,517
 20379cc:	10907704 	addi	r2,r2,16860
 20379d0:	10800017 	ldw	r2,0(r2)
 20379d4:	103ee83a 	callr	r2
 20379d8:	00000206 	br	20379e4 <alt_get_errno+0x3c>
 20379dc:	00808174 	movhi	r2,517
 20379e0:	10908b04 	addi	r2,r2,16940
}
 20379e4:	e037883a 	mov	sp,fp
 20379e8:	dfc00117 	ldw	ra,4(sp)
 20379ec:	df000017 	ldw	fp,0(sp)
 20379f0:	dec00204 	addi	sp,sp,8
 20379f4:	f800283a 	ret

020379f8 <alt_write>:
}

#else /* !ALT_USE_DIRECT_DRIVERS */

int ALT_WRITE (int file, const void *ptr, size_t len)
{
 20379f8:	defff904 	addi	sp,sp,-28
 20379fc:	dfc00615 	stw	ra,24(sp)
 2037a00:	df000515 	stw	fp,20(sp)
 2037a04:	df000504 	addi	fp,sp,20
 2037a08:	e13ffd15 	stw	r4,-12(fp)
 2037a0c:	e17ffe15 	stw	r5,-8(fp)
 2037a10:	e1bfff15 	stw	r6,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 2037a14:	e0bffd17 	ldw	r2,-12(fp)
 2037a18:	10000616 	blt	r2,zero,2037a34 <alt_write+0x3c>
 2037a1c:	e0bffd17 	ldw	r2,-12(fp)
 2037a20:	10c00324 	muli	r3,r2,12
 2037a24:	00808174 	movhi	r2,517
 2037a28:	108f1e04 	addi	r2,r2,15480
 2037a2c:	1885883a 	add	r2,r3,r2
 2037a30:	00000106 	br	2037a38 <alt_write+0x40>
 2037a34:	0005883a 	mov	r2,zero
 2037a38:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 2037a3c:	e0bffb17 	ldw	r2,-20(fp)
 2037a40:	10001f26 	beq	r2,zero,2037ac0 <alt_write+0xc8>
     * If the file has not been opened with write access, or if the driver does
     * not provide an implementation of write(), generate an error. Otherwise
     * call the drivers write() function to process the request.
     */

    if (((fd->fd_flags & O_ACCMODE) != O_RDONLY) && fd->dev->write)
 2037a44:	e0bffb17 	ldw	r2,-20(fp)
 2037a48:	10800217 	ldw	r2,8(r2)
 2037a4c:	108000cc 	andi	r2,r2,3
 2037a50:	10001726 	beq	r2,zero,2037ab0 <alt_write+0xb8>
 2037a54:	e0bffb17 	ldw	r2,-20(fp)
 2037a58:	10800017 	ldw	r2,0(r2)
 2037a5c:	10800617 	ldw	r2,24(r2)
 2037a60:	10001326 	beq	r2,zero,2037ab0 <alt_write+0xb8>
    {
      
      /* ALT_LOG - see altera_hal/HAL/inc/sys/alt_log_printf.h */
      ALT_LOG_WRITE_FUNCTION(ptr,len);

      if ((rval = fd->dev->write(fd, ptr, len)) < 0)
 2037a64:	e0bffb17 	ldw	r2,-20(fp)
 2037a68:	10800017 	ldw	r2,0(r2)
 2037a6c:	10c00617 	ldw	r3,24(r2)
 2037a70:	e0bfff17 	ldw	r2,-4(fp)
 2037a74:	e13ffb17 	ldw	r4,-20(fp)
 2037a78:	e17ffe17 	ldw	r5,-8(fp)
 2037a7c:	100d883a 	mov	r6,r2
 2037a80:	183ee83a 	callr	r3
 2037a84:	e0bffc15 	stw	r2,-16(fp)
 2037a88:	e0bffc17 	ldw	r2,-16(fp)
 2037a8c:	1000060e 	bge	r2,zero,2037aa8 <alt_write+0xb0>
      {
        ALT_ERRNO = -rval;
 2037a90:	20379a80 	call	20379a8 <alt_get_errno>
 2037a94:	e0fffc17 	ldw	r3,-16(fp)
 2037a98:	00c7c83a 	sub	r3,zero,r3
 2037a9c:	10c00015 	stw	r3,0(r2)
        return -1;
 2037aa0:	00bfffc4 	movi	r2,-1
 2037aa4:	00000a06 	br	2037ad0 <alt_write+0xd8>
      }
      return rval;
 2037aa8:	e0bffc17 	ldw	r2,-16(fp)
 2037aac:	00000806 	br	2037ad0 <alt_write+0xd8>
    }
    else
    {
      ALT_ERRNO = EACCES;
 2037ab0:	20379a80 	call	20379a8 <alt_get_errno>
 2037ab4:	00c00344 	movi	r3,13
 2037ab8:	10c00015 	stw	r3,0(r2)
 2037abc:	00000306 	br	2037acc <alt_write+0xd4>
    }
  }
  else  
  {
    ALT_ERRNO = EBADFD;
 2037ac0:	20379a80 	call	20379a8 <alt_get_errno>
 2037ac4:	00c01444 	movi	r3,81
 2037ac8:	10c00015 	stw	r3,0(r2)
  }
  return -1;
 2037acc:	00bfffc4 	movi	r2,-1
}
 2037ad0:	e037883a 	mov	sp,fp
 2037ad4:	dfc00117 	ldw	ra,4(sp)
 2037ad8:	df000017 	ldw	fp,0(sp)
 2037adc:	dec00204 	addi	sp,sp,8
 2037ae0:	f800283a 	ret

02037ae4 <altera_nios2_qsys_irq_init>:
/*
 * To initialize the internal interrupt controller, just clear the IENABLE
 * register so that all possible IRQs are disabled.
 */
void altera_nios2_qsys_irq_init(void) 
{
 2037ae4:	deffff04 	addi	sp,sp,-4
 2037ae8:	df000015 	stw	fp,0(sp)
 2037aec:	d839883a 	mov	fp,sp
    NIOS2_WRITE_IENABLE(0);
 2037af0:	000170fa 	wrctl	ienable,zero
}
 2037af4:	e037883a 	mov	sp,fp
 2037af8:	df000017 	ldw	fp,0(sp)
 2037afc:	dec00104 	addi	sp,sp,4
 2037b00:	f800283a 	ret

02037b04 <OSCtxSw>:

      /* 
       * Save the remaining registers to the stack. 
       */

      addi sp, sp, -44
 2037b04:	defff504 	addi	sp,sp,-44
      bltu  sp, et, .Lstack_overflow

#endif

#if OS_THREAD_SAFE_NEWLIB
      ldw r3, %gprel(_impure_ptr)(gp)   /* load the pointer */
 2037b08:	d0e00c17 	ldw	r3,-32720(gp)
#endif /* OS_THREAD_SAFE_NEWLIB */

      ldw r4, %gprel(OSTCBCur)(gp)
 2037b0c:	d1208017 	ldw	r4,-32256(gp)

      stw ra,  0(sp)
 2037b10:	dfc00015 	stw	ra,0(sp)
      stw fp,  4(sp)
 2037b14:	df000115 	stw	fp,4(sp)
      stw r23, 8(sp)
 2037b18:	ddc00215 	stw	r23,8(sp)
      stw r22, 12(sp)
 2037b1c:	dd800315 	stw	r22,12(sp)
      stw r21, 16(sp)
 2037b20:	dd400415 	stw	r21,16(sp)
      stw r20, 20(sp)
 2037b24:	dd000515 	stw	r20,20(sp)
      stw r19, 24(sp)
 2037b28:	dcc00615 	stw	r19,24(sp)
      stw r18, 28(sp)
 2037b2c:	dc800715 	stw	r18,28(sp)
      stw r17, 32(sp)
 2037b30:	dc400815 	stw	r17,32(sp)
      stw r16, 36(sp)
 2037b34:	dc000915 	stw	r16,36(sp)
       * store the current value of _impure_ptr so it can be restored
       * later; _impure_ptr is asigned on a per task basis. It is used
       * by Newlib to achieve reentrancy.	
       */

      stw r3, 40(sp)                  /* save the impure pointer */
 2037b38:	d8c00a15 	stw	r3,40(sp)
      /* 
       * Save the current tasks stack pointer into the current tasks OS_TCB.
       * i.e. OSTCBCur->OSTCBStkPtr = sp;
       */

      stw sp, (r4)                  /* save the stack pointer (OSTCBStkPtr */
 2037b3c:	26c00015 	stw	sp,0(r4)

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 2037b40:	2037f080 	call	2037f08 <OSTaskSwHook>
      /*
       * OSTCBCur = OSTCBHighRdy; 
       * OSPrioCur = OSPrioHighRdy; 
       */

      ldw r4, %gprel(OSTCBHighRdy)(gp)
 2037b44:	d1207b17 	ldw	r4,-32276(gp)
      ldb r5, %gprel(OSPrioHighRdy)(gp)
 2037b48:	d1607307 	ldb	r5,-32308(gp)

      stw r4, %gprel(OSTCBCur)(gp)     /* set the current task to be the new task */
 2037b4c:	d1208015 	stw	r4,-32256(gp)
      stb r5, %gprel(OSPrioCur)(gp)    /* store the new task's priority as the current */
 2037b50:	d1607345 	stb	r5,-32307(gp)

      /*
       * Set the stack pointer to point to the new task's stack
       */

      ldw sp, (r4) /* the stack pointer is the first entry in the OS_TCB structure */
 2037b54:	26c00017 	ldw	sp,0(r4)
      /*
       * restore the value of _impure_ptr ; _impure_ptr is asigned on a 
       * per task basis. It is used by Newlib to achieve reentrancy.	
       */

      ldw r3, 40(sp)                  /* load the new impure pointer */
 2037b58:	d8c00a17 	ldw	r3,40(sp)

      /*
       * Restore the saved registers for the new task.
       */

      ldw ra,  0(sp)
 2037b5c:	dfc00017 	ldw	ra,0(sp)
      ldw fp,  4(sp)
 2037b60:	df000117 	ldw	fp,4(sp)
      ldw r23, 8(sp)
 2037b64:	ddc00217 	ldw	r23,8(sp)
      ldw r22, 12(sp)
 2037b68:	dd800317 	ldw	r22,12(sp)
      ldw r21, 16(sp)
 2037b6c:	dd400417 	ldw	r21,16(sp)
      ldw r20, 20(sp)
 2037b70:	dd000517 	ldw	r20,20(sp)
      ldw r19, 24(sp)
 2037b74:	dcc00617 	ldw	r19,24(sp)
      ldw r18, 28(sp)
 2037b78:	dc800717 	ldw	r18,28(sp)
      ldw r17, 32(sp)
 2037b7c:	dc400817 	ldw	r17,32(sp)
      ldw r16, 36(sp)
 2037b80:	dc000917 	ldw	r16,36(sp)

#if OS_THREAD_SAFE_NEWLIB

      stw r3, %gprel(_impure_ptr)(gp) /* update _impure_ptr */
 2037b84:	d0e00c15 	stw	r3,-32720(gp)

      stw et, %gprel(alt_stack_limit_value)(gp)

#endif

      addi sp, sp, 44
 2037b88:	dec00b04 	addi	sp,sp,44

      /*
       * resume execution of the new task.
       */

      ret
 2037b8c:	f800283a 	ret

02037b90 <OSStartHighRdy>:

      /*
       * disable interrupts so that the scheduler doesn't run while
       * we're initialising this task.
       */  
      rdctl r18, status
 2037b90:	0025303a 	rdctl	r18,status
      subi  r17, zero, 2   /* r17 = 0xfffffffe */
 2037b94:	047fff84 	movi	r17,-2
      and   r18, r18, r17
 2037b98:	9464703a 	and	r18,r18,r17
      wrctl status, r18
 2037b9c:	9001703a 	wrctl	status,r18

      /*
       * Call the user definable OSTaskSWHook()
       */

      call OSTaskSwHook
 2037ba0:	2037f080 	call	2037f08 <OSTaskSwHook>

      /* 
       * set OSRunning = TRUE.
       */

      movi r18, 1                    /* set r18 to the value 'TRUE' */
 2037ba4:	04800044 	movi	r18,1
      stb r18, %gprel(OSRunning)(gp) /* save this to OSRunning */
 2037ba8:	d4a07145 	stb	r18,-32315(gp)

      /*
       * start execution of the new task.
       */

      br 9b
 2037bac:	003fe506 	br	2037b44 <OSCtxSw+0x40>

02037bb0 <OSStartTsk>:

OSStartTsk:
      /* This instruction is never executed.  Its here to make the
       * backtrace work right 
       */
      movi sp, 0
 2037bb0:	06c00004 	movi	sp,0

      /* Enable interrupts */
      rdctl r2, status
 2037bb4:	0005303a 	rdctl	r2,status
      ori   r2, r2, 0x1
 2037bb8:	10800054 	ori	r2,r2,1
      wrctl status, r2
 2037bbc:	1001703a 	wrctl	status,r2

      ldw r2, 4(sp)
 2037bc0:	d8800117 	ldw	r2,4(sp)
      ldw r4, 0(sp)
 2037bc4:	d9000017 	ldw	r4,0(sp)

      addi sp, sp, 8
 2037bc8:	dec00204 	addi	sp,sp,8

      callr r2
 2037bcc:	103ee83a 	callr	r2

      nop
 2037bd0:	0001883a 	nop

02037bd4 <OSTaskStkInit>:
 *              been placed on the stack in the proper order.
 *
 ***********************************************************************************************/

OS_STK *OSTaskStkInit(void (*task)(void *pd), void *pdata, OS_STK *pstk, INT16U opt)
{
 2037bd4:	defff704 	addi	sp,sp,-36
 2037bd8:	dfc00815 	stw	ra,32(sp)
 2037bdc:	df000715 	stw	fp,28(sp)
 2037be0:	df000704 	addi	fp,sp,28
 2037be4:	e13ffc15 	stw	r4,-16(fp)
 2037be8:	e17ffd15 	stw	r5,-12(fp)
 2037bec:	e1bffe15 	stw	r6,-8(fp)
 2037bf0:	3805883a 	mov	r2,r7
 2037bf4:	e0bfff0d 	sth	r2,-4(fp)
    * create and initialise the impure pointer used for Newlib thread local storage.
    * This is only done if the C library is being used in a thread safe mode. Otherwise
    * a single reent structure is used for all threads, which saves memory.
    */

   local_impure_ptr = (struct _reent*)((((INT32U)(pstk)) & ~0x3) - sizeof(struct _reent));
 2037bf8:	e0fffe17 	ldw	r3,-8(fp)
 2037bfc:	00bfff04 	movi	r2,-4
 2037c00:	1884703a 	and	r2,r3,r2
 2037c04:	10bf0004 	addi	r2,r2,-1024
 2037c08:	e0bff915 	stw	r2,-28(fp)

   _REENT_INIT_PTR (local_impure_ptr);
 2037c0c:	e0bff917 	ldw	r2,-28(fp)
 2037c10:	10000015 	stw	zero,0(r2)
 2037c14:	e0bff917 	ldw	r2,-28(fp)
 2037c18:	10c0bb04 	addi	r3,r2,748
 2037c1c:	e0bff917 	ldw	r2,-28(fp)
 2037c20:	10c00115 	stw	r3,4(r2)
 2037c24:	e0bff917 	ldw	r2,-28(fp)
 2037c28:	10c0d204 	addi	r3,r2,840
 2037c2c:	e0bff917 	ldw	r2,-28(fp)
 2037c30:	10c00215 	stw	r3,8(r2)
 2037c34:	e0bff917 	ldw	r2,-28(fp)
 2037c38:	10c0e904 	addi	r3,r2,932
 2037c3c:	e0bff917 	ldw	r2,-28(fp)
 2037c40:	10c00315 	stw	r3,12(r2)
 2037c44:	e0bff917 	ldw	r2,-28(fp)
 2037c48:	10000415 	stw	zero,16(r2)
 2037c4c:	e0bff917 	ldw	r2,-28(fp)
 2037c50:	10800504 	addi	r2,r2,20
 2037c54:	1009883a 	mov	r4,r2
 2037c58:	000b883a 	mov	r5,zero
 2037c5c:	01800644 	movi	r6,25
 2037c60:	200682c0 	call	200682c <memset>
 2037c64:	e0bff917 	ldw	r2,-28(fp)
 2037c68:	10000c15 	stw	zero,48(r2)
 2037c6c:	e0bff917 	ldw	r2,-28(fp)
 2037c70:	00c08174 	movhi	r3,517
 2037c74:	18fd9d04 	addi	r3,r3,-2444
 2037c78:	10c00d15 	stw	r3,52(r2)
 2037c7c:	e0bff917 	ldw	r2,-28(fp)
 2037c80:	10000e15 	stw	zero,56(r2)
 2037c84:	e0bff917 	ldw	r2,-28(fp)
 2037c88:	10000f15 	stw	zero,60(r2)
 2037c8c:	e0bff917 	ldw	r2,-28(fp)
 2037c90:	10001015 	stw	zero,64(r2)
 2037c94:	e0bff917 	ldw	r2,-28(fp)
 2037c98:	10001115 	stw	zero,68(r2)
 2037c9c:	e0bff917 	ldw	r2,-28(fp)
 2037ca0:	10001215 	stw	zero,72(r2)
 2037ca4:	e0bff917 	ldw	r2,-28(fp)
 2037ca8:	10001315 	stw	zero,76(r2)
 2037cac:	e0bff917 	ldw	r2,-28(fp)
 2037cb0:	10001415 	stw	zero,80(r2)
 2037cb4:	e0bff917 	ldw	r2,-28(fp)
 2037cb8:	10001515 	stw	zero,84(r2)
 2037cbc:	e0bff917 	ldw	r2,-28(fp)
 2037cc0:	10001615 	stw	zero,88(r2)
 2037cc4:	e0bff917 	ldw	r2,-28(fp)
 2037cc8:	10001715 	stw	zero,92(r2)
 2037ccc:	e0bff917 	ldw	r2,-28(fp)
 2037cd0:	10001805 	stb	zero,96(r2)
 2037cd4:	e0bff917 	ldw	r2,-28(fp)
 2037cd8:	10801f04 	addi	r2,r2,124
 2037cdc:	1009883a 	mov	r4,r2
 2037ce0:	000b883a 	mov	r5,zero
 2037ce4:	01800904 	movi	r6,36
 2037ce8:	200682c0 	call	200682c <memset>
 2037cec:	e0bff917 	ldw	r2,-28(fp)
 2037cf0:	10002815 	stw	zero,160(r2)
 2037cf4:	e0bff917 	ldw	r2,-28(fp)
 2037cf8:	00c00044 	movi	r3,1
 2037cfc:	10c02915 	stw	r3,164(r2)
 2037d00:	10002a15 	stw	zero,168(r2)
 2037d04:	e0bff917 	ldw	r2,-28(fp)
 2037d08:	00ccc384 	movi	r3,13070
 2037d0c:	10c02b0d 	sth	r3,172(r2)
 2037d10:	e0bff917 	ldw	r2,-28(fp)
 2037d14:	00eaf344 	movi	r3,-21555
 2037d18:	10c02b8d 	sth	r3,174(r2)
 2037d1c:	e0bff917 	ldw	r2,-28(fp)
 2037d20:	00c48d04 	movi	r3,4660
 2037d24:	10c02c0d 	sth	r3,176(r2)
 2037d28:	e0bff917 	ldw	r2,-28(fp)
 2037d2c:	00f99b44 	movi	r3,-6547
 2037d30:	10c02c8d 	sth	r3,178(r2)
 2037d34:	e0bff917 	ldw	r2,-28(fp)
 2037d38:	00f7bb04 	movi	r3,-8468
 2037d3c:	10c02d0d 	sth	r3,180(r2)
 2037d40:	e0bff917 	ldw	r2,-28(fp)
 2037d44:	00c00144 	movi	r3,5
 2037d48:	10c02d8d 	sth	r3,182(r2)
 2037d4c:	e0bff917 	ldw	r2,-28(fp)
 2037d50:	00c002c4 	movi	r3,11
 2037d54:	10c02e0d 	sth	r3,184(r2)
 2037d58:	e0bff917 	ldw	r2,-28(fp)
 2037d5c:	10002f15 	stw	zero,188(r2)
 2037d60:	e0bff917 	ldw	r2,-28(fp)
 2037d64:	10003015 	stw	zero,192(r2)
 2037d68:	e0bff917 	ldw	r2,-28(fp)
 2037d6c:	10003115 	stw	zero,196(r2)
 2037d70:	e0bff917 	ldw	r2,-28(fp)
 2037d74:	10003215 	stw	zero,200(r2)
 2037d78:	e0bff917 	ldw	r2,-28(fp)
 2037d7c:	10003315 	stw	zero,204(r2)
 2037d80:	e0bff917 	ldw	r2,-28(fp)
 2037d84:	10003415 	stw	zero,208(r2)
 2037d88:	e0bff917 	ldw	r2,-28(fp)
 2037d8c:	10003e15 	stw	zero,248(r2)
 2037d90:	e0bff917 	ldw	r2,-28(fp)
 2037d94:	10003f15 	stw	zero,252(r2)
 2037d98:	e0bff917 	ldw	r2,-28(fp)
 2037d9c:	10004015 	stw	zero,256(r2)
 2037da0:	e0bff917 	ldw	r2,-28(fp)
 2037da4:	10004115 	stw	zero,260(r2)
 2037da8:	e0bff917 	ldw	r2,-28(fp)
 2037dac:	10004215 	stw	zero,264(r2)
 2037db0:	e0bff917 	ldw	r2,-28(fp)
 2037db4:	10004315 	stw	zero,268(r2)
 2037db8:	e0bff917 	ldw	r2,-28(fp)
 2037dbc:	10004415 	stw	zero,272(r2)
 2037dc0:	e0bff917 	ldw	r2,-28(fp)
 2037dc4:	10004515 	stw	zero,276(r2)
 2037dc8:	e0bff917 	ldw	r2,-28(fp)
 2037dcc:	10004615 	stw	zero,280(r2)
 2037dd0:	e0bff917 	ldw	r2,-28(fp)
 2037dd4:	10004715 	stw	zero,284(r2)
 2037dd8:	e0bff917 	ldw	r2,-28(fp)
 2037ddc:	10003505 	stb	zero,212(r2)
 2037de0:	e0bff917 	ldw	r2,-28(fp)
 2037de4:	10003705 	stb	zero,220(r2)
 2037de8:	e0bff917 	ldw	r2,-28(fp)
 2037dec:	10003d15 	stw	zero,244(r2)
 2037df0:	e0bff917 	ldw	r2,-28(fp)
 2037df4:	10005215 	stw	zero,328(r2)
 2037df8:	e0bff917 	ldw	r2,-28(fp)
 2037dfc:	10005315 	stw	zero,332(r2)
 2037e00:	e0bff917 	ldw	r2,-28(fp)
 2037e04:	10005415 	stw	zero,336(r2)
 2037e08:	e0bff917 	ldw	r2,-28(fp)
 2037e0c:	10005515 	stw	zero,340(r2)
 2037e10:	e0bff917 	ldw	r2,-28(fp)
 2037e14:	1000b515 	stw	zero,724(r2)
 2037e18:	e0bff917 	ldw	r2,-28(fp)
 2037e1c:	10007515 	stw	zero,468(r2)
 2037e20:	e0bff917 	ldw	r2,-28(fp)
 2037e24:	1000b715 	stw	zero,732(r2)
 2037e28:	e0bff917 	ldw	r2,-28(fp)
 2037e2c:	1000b815 	stw	zero,736(r2)
 2037e30:	e0bff917 	ldw	r2,-28(fp)
 2037e34:	1000b915 	stw	zero,740(r2)
 2037e38:	e0bff917 	ldw	r2,-28(fp)
 2037e3c:	1000ba15 	stw	zero,744(r2)
 2037e40:	e0bff917 	ldw	r2,-28(fp)
 2037e44:	1080bb04 	addi	r2,r2,748
 2037e48:	1009883a 	mov	r4,r2
 2037e4c:	000b883a 	mov	r5,zero
 2037e50:	01804504 	movi	r6,276
 2037e54:	200682c0 	call	200682c <memset>
   /* 
    * create a stack frame at the top of the stack (leaving space for the 
    * reentrant data structure).
    */

   frame_pointer = (INT32U*) local_impure_ptr;
 2037e58:	e0bff917 	ldw	r2,-28(fp)
 2037e5c:	e0bffa15 	stw	r2,-24(fp)
#else
   frame_pointer =   (INT32U*) (((INT32U)(pstk)) & ~0x3);
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk = frame_pointer - 13;
 2037e60:	e0bffa17 	ldw	r2,-24(fp)
 2037e64:	10bff304 	addi	r2,r2,-52
 2037e68:	e0bffb15 	stw	r2,-20(fp)

   /* Now fill the stack frame. */

   stk[12] = (INT32U)task;            /* task address (ra) */
 2037e6c:	e0bffb17 	ldw	r2,-20(fp)
 2037e70:	10800c04 	addi	r2,r2,48
 2037e74:	e0fffc17 	ldw	r3,-16(fp)
 2037e78:	10c00015 	stw	r3,0(r2)
   stk[11] = (INT32U) pdata;          /* first register argument (r4) */
 2037e7c:	e0bffb17 	ldw	r2,-20(fp)
 2037e80:	10800b04 	addi	r2,r2,44
 2037e84:	e0fffd17 	ldw	r3,-12(fp)
 2037e88:	10c00015 	stw	r3,0(r2)

#if OS_THREAD_SAFE_NEWLIB
   stk[10] = (INT32U) local_impure_ptr; /* value of _impure_ptr for this thread */
 2037e8c:	e0bffb17 	ldw	r2,-20(fp)
 2037e90:	10800a04 	addi	r2,r2,40
 2037e94:	e0fff917 	ldw	r3,-28(fp)
 2037e98:	10c00015 	stw	r3,0(r2)
#endif /* OS_THREAD_SAFE_NEWLIB */
   stk[0]  = ((INT32U)&OSStartTsk) + 4;/* exception return address (ea) */  
 2037e9c:	008080f4 	movhi	r2,515
 2037ea0:	109eec04 	addi	r2,r2,31664
 2037ea4:	10c00104 	addi	r3,r2,4
 2037ea8:	e0bffb17 	ldw	r2,-20(fp)
 2037eac:	10c00015 	stw	r3,0(r2)
    */
   __asm__ (".set OSTCBNext_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBNext)));
   __asm__ (".set OSTCBPrio_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBPrio)));
   __asm__ (".set OSTCBStkPtr_OFFSET,%0" :: "i" (offsetof(OS_TCB, OSTCBStkPtr)));
  
   return((OS_STK *)stk);
 2037eb0:	e0bffb17 	ldw	r2,-20(fp)
}
 2037eb4:	e037883a 	mov	sp,fp
 2037eb8:	dfc00117 	ldw	ra,4(sp)
 2037ebc:	df000017 	ldw	fp,0(sp)
 2037ec0:	dec00204 	addi	sp,sp,8
 2037ec4:	f800283a 	ret

02037ec8 <OSTaskCreateHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskCreateHook (OS_TCB *ptcb)
{
 2037ec8:	defffe04 	addi	sp,sp,-8
 2037ecc:	df000115 	stw	fp,4(sp)
 2037ed0:	df000104 	addi	fp,sp,4
 2037ed4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning */
}
 2037ed8:	e037883a 	mov	sp,fp
 2037edc:	df000017 	ldw	fp,0(sp)
 2037ee0:	dec00104 	addi	sp,sp,4
 2037ee4:	f800283a 	ret

02037ee8 <OSTaskDelHook>:
*
* Note(s)    : 1) Interrupts are disabled during this call.
*********************************************************************************************************
*/
void OSTaskDelHook (OS_TCB *ptcb)
{
 2037ee8:	defffe04 	addi	sp,sp,-8
 2037eec:	df000115 	stw	fp,4(sp)
 2037ef0:	df000104 	addi	fp,sp,4
 2037ef4:	e13fff15 	stw	r4,-4(fp)
    ptcb = ptcb;                       /* Prevent compiler warning                                     */
}
 2037ef8:	e037883a 	mov	sp,fp
 2037efc:	df000017 	ldw	fp,0(sp)
 2037f00:	dec00104 	addi	sp,sp,4
 2037f04:	f800283a 	ret

02037f08 <OSTaskSwHook>:
*                 will be 'switched in' (i.e. the highest priority task) and, 'OSTCBCur' points to the
*                 task being switched out (i.e. the preempted task).
*********************************************************************************************************
*/
void OSTaskSwHook (void)
{
 2037f08:	deffff04 	addi	sp,sp,-4
 2037f0c:	df000015 	stw	fp,0(sp)
 2037f10:	d839883a 	mov	fp,sp
}
 2037f14:	e037883a 	mov	sp,fp
 2037f18:	df000017 	ldw	fp,0(sp)
 2037f1c:	dec00104 	addi	sp,sp,4
 2037f20:	f800283a 	ret

02037f24 <OSTaskStatHook>:
*
* Arguments  : none
*********************************************************************************************************
*/
void OSTaskStatHook (void)
{
 2037f24:	deffff04 	addi	sp,sp,-4
 2037f28:	df000015 	stw	fp,0(sp)
 2037f2c:	d839883a 	mov	fp,sp
}
 2037f30:	e037883a 	mov	sp,fp
 2037f34:	df000017 	ldw	fp,0(sp)
 2037f38:	dec00104 	addi	sp,sp,4
 2037f3c:	f800283a 	ret

02037f40 <OSTimeTickHook>:
#ifdef ALT_INICHE
void cticks_hook(void);
#endif

void OSTimeTickHook (void)
{
 2037f40:	defffe04 	addi	sp,sp,-8
 2037f44:	dfc00115 	stw	ra,4(sp)
 2037f48:	df000015 	stw	fp,0(sp)
 2037f4c:	d839883a 	mov	fp,sp
    }
#endif  
    
#ifdef ALT_INICHE
    /* Service the Interniche timer */
    cticks_hook();
 2037f50:	20287500 	call	2028750 <cticks_hook>
#endif
}
 2037f54:	e037883a 	mov	sp,fp
 2037f58:	dfc00117 	ldw	ra,4(sp)
 2037f5c:	df000017 	ldw	fp,0(sp)
 2037f60:	dec00204 	addi	sp,sp,8
 2037f64:	f800283a 	ret

02037f68 <OSInitHookBegin>:

void OSInitHookBegin(void)
{
 2037f68:	deffff04 	addi	sp,sp,-4
 2037f6c:	df000015 	stw	fp,0(sp)
 2037f70:	d839883a 	mov	fp,sp
#if OS_TMR_EN > 0
    OSTmrCtr = 0;
#endif
}
 2037f74:	e037883a 	mov	sp,fp
 2037f78:	df000017 	ldw	fp,0(sp)
 2037f7c:	dec00104 	addi	sp,sp,4
 2037f80:	f800283a 	ret

02037f84 <OSInitHookEnd>:

void OSInitHookEnd(void)
{
 2037f84:	deffff04 	addi	sp,sp,-4
 2037f88:	df000015 	stw	fp,0(sp)
 2037f8c:	d839883a 	mov	fp,sp
}
 2037f90:	e037883a 	mov	sp,fp
 2037f94:	df000017 	ldw	fp,0(sp)
 2037f98:	dec00104 	addi	sp,sp,4
 2037f9c:	f800283a 	ret

02037fa0 <OSTaskIdleHook>:

void OSTaskIdleHook(void)
{
 2037fa0:	deffff04 	addi	sp,sp,-4
 2037fa4:	df000015 	stw	fp,0(sp)
 2037fa8:	d839883a 	mov	fp,sp
}
 2037fac:	e037883a 	mov	sp,fp
 2037fb0:	df000017 	ldw	fp,0(sp)
 2037fb4:	dec00104 	addi	sp,sp,4
 2037fb8:	f800283a 	ret

02037fbc <OSTCBInitHook>:

void OSTCBInitHook(OS_TCB *ptcb)
{
 2037fbc:	defffe04 	addi	sp,sp,-8
 2037fc0:	df000115 	stw	fp,4(sp)
 2037fc4:	df000104 	addi	fp,sp,4
 2037fc8:	e13fff15 	stw	r4,-4(fp)
}
 2037fcc:	e037883a 	mov	sp,fp
 2037fd0:	df000017 	ldw	fp,0(sp)
 2037fd4:	dec00104 	addi	sp,sp,4
 2037fd8:	f800283a 	ret

02037fdc <alt_avalon_spi_command>:

int alt_avalon_spi_command(alt_u32 base, alt_u32 slave,
                           alt_u32 write_length, const alt_u8 * write_data,
                           alt_u32 read_length, alt_u8 * read_data,
                           alt_u32 flags)
{
 2037fdc:	defff404 	addi	sp,sp,-48
 2037fe0:	df000b15 	stw	fp,44(sp)
 2037fe4:	df000b04 	addi	fp,sp,44
 2037fe8:	e13ffc15 	stw	r4,-16(fp)
 2037fec:	e17ffd15 	stw	r5,-12(fp)
 2037ff0:	e1bffe15 	stw	r6,-8(fp)
 2037ff4:	e1ffff15 	stw	r7,-4(fp)
  const alt_u8 * write_end = write_data + write_length;
 2037ff8:	e0ffff17 	ldw	r3,-4(fp)
 2037ffc:	e0bffe17 	ldw	r2,-8(fp)
 2038000:	1885883a 	add	r2,r3,r2
 2038004:	e0bff815 	stw	r2,-32(fp)
  alt_u8 * read_end = read_data + read_length;
 2038008:	e0c00217 	ldw	r3,8(fp)
 203800c:	e0800117 	ldw	r2,4(fp)
 2038010:	1885883a 	add	r2,r3,r2
 2038014:	e0bff915 	stw	r2,-28(fp)

  alt_u32 write_zeros = read_length;
 2038018:	e0800117 	ldw	r2,4(fp)
 203801c:	e0bff515 	stw	r2,-44(fp)
  alt_u32 read_ignore = write_length;
 2038020:	e0bffe17 	ldw	r2,-8(fp)
 2038024:	e0bff615 	stw	r2,-40(fp)

  /* We must not send more than two bytes to the target before it has
   * returned any as otherwise it will overflow. */
  /* Unfortunately the hardware does not seem to work with credits > 1,
   * leave it at 1 for now. */
  alt_32 credits = 1;
 2038028:	00800044 	movi	r2,1
 203802c:	e0bff715 	stw	r2,-36(fp)
  /* Warning: this function is not currently safe if called in a multi-threaded
   * environment, something above must perform locking to make it safe if more
   * than one thread intends to use it.
   */

  IOWR_ALTERA_AVALON_SPI_SLAVE_SEL(base, 1 << slave);
 2038030:	e0bffc17 	ldw	r2,-16(fp)
 2038034:	10800504 	addi	r2,r2,20
 2038038:	e0fffd17 	ldw	r3,-12(fp)
 203803c:	01000044 	movi	r4,1
 2038040:	20c6983a 	sll	r3,r4,r3
 2038044:	10c00035 	stwio	r3,0(r2)
  
  /* Set the SSO bit (force chipselect) only if the toggle flag is not set */
  if ((flags & ALT_AVALON_SPI_COMMAND_TOGGLE_SS_N) == 0) {
 2038048:	e0800317 	ldw	r2,12(fp)
 203804c:	1080008c 	andi	r2,r2,2
 2038050:	1000041e 	bne	r2,zero,2038064 <alt_avalon_spi_command+0x88>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, ALTERA_AVALON_SPI_CONTROL_SSO_MSK);
 2038054:	e0bffc17 	ldw	r2,-16(fp)
 2038058:	10800304 	addi	r2,r2,12
 203805c:	00c10004 	movi	r3,1024
 2038060:	10c00035 	stwio	r3,0(r2)
  /*
   * Discard any stale data present in the RXDATA register, in case
   * previous communication was interrupted and stale data was left
   * behind.
   */
  IORD_ALTERA_AVALON_SPI_RXDATA(base);
 2038064:	e0bffc17 	ldw	r2,-16(fp)
 2038068:	10800037 	ldwio	r2,0(r2)
 203806c:	00000106 	br	2038074 <alt_avalon_spi_command+0x98>

      if (read_ignore == 0 && read_data == read_end)
        break;
    }
    
  }
 2038070:	0001883a 	nop
  for ( ; ; )
  {
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 2038074:	e0bffc17 	ldw	r2,-16(fp)
 2038078:	10800204 	addi	r2,r2,8
 203807c:	10800037 	ldwio	r2,0(r2)
 2038080:	e0bffa15 	stw	r2,-24(fp)
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 2038084:	e0bffa17 	ldw	r2,-24(fp)
 2038088:	1080100c 	andi	r2,r2,64
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 203808c:	10000226 	beq	r2,zero,2038098 <alt_avalon_spi_command+0xbc>
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 2038090:	e0bff717 	ldw	r2,-36(fp)
 2038094:	1000031e 	bne	r2,zero,20380a4 <alt_avalon_spi_command+0xc8>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);
 2038098:	e0bffa17 	ldw	r2,-24(fp)
 203809c:	1080200c 	andi	r2,r2,128
    
    do
    {
      status = IORD_ALTERA_AVALON_SPI_STATUS(base);
    }
    while (((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) == 0 || credits == 0) &&
 20380a0:	103ff426 	beq	r2,zero,2038074 <alt_avalon_spi_command+0x98>
            (status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) == 0);

    if ((status & ALTERA_AVALON_SPI_STATUS_TRDY_MSK) != 0 && credits > 0)
 20380a4:	e0bffa17 	ldw	r2,-24(fp)
 20380a8:	1080100c 	andi	r2,r2,64
 20380ac:	10001e26 	beq	r2,zero,2038128 <alt_avalon_spi_command+0x14c>
 20380b0:	e0bff717 	ldw	r2,-36(fp)
 20380b4:	00801c0e 	bge	zero,r2,2038128 <alt_avalon_spi_command+0x14c>
    {
      credits--;
 20380b8:	e0bff717 	ldw	r2,-36(fp)
 20380bc:	10bfffc4 	addi	r2,r2,-1
 20380c0:	e0bff715 	stw	r2,-36(fp)

      if (write_data < write_end)
 20380c4:	e0ffff17 	ldw	r3,-4(fp)
 20380c8:	e0bff817 	ldw	r2,-32(fp)
 20380cc:	18800a2e 	bgeu	r3,r2,20380f8 <alt_avalon_spi_command+0x11c>
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, *write_data++);
 20380d0:	e0bffc17 	ldw	r2,-16(fp)
 20380d4:	10800104 	addi	r2,r2,4
 20380d8:	e0ffff17 	ldw	r3,-4(fp)
 20380dc:	18c00003 	ldbu	r3,0(r3)
 20380e0:	18c03fcc 	andi	r3,r3,255
 20380e4:	e13fff17 	ldw	r4,-4(fp)
 20380e8:	21000044 	addi	r4,r4,1
 20380ec:	e13fff15 	stw	r4,-4(fp)
 20380f0:	10c00035 	stwio	r3,0(r2)
 20380f4:	00000c06 	br	2038128 <alt_avalon_spi_command+0x14c>
      else if (write_zeros > 0)
 20380f8:	e0bff517 	ldw	r2,-44(fp)
 20380fc:	10000826 	beq	r2,zero,2038120 <alt_avalon_spi_command+0x144>
      {
        write_zeros--;
 2038100:	e0bff517 	ldw	r2,-44(fp)
 2038104:	10bfffc4 	addi	r2,r2,-1
 2038108:	e0bff515 	stw	r2,-44(fp)
        IOWR_ALTERA_AVALON_SPI_TXDATA(base, 0);
 203810c:	e0bffc17 	ldw	r2,-16(fp)
 2038110:	10800104 	addi	r2,r2,4
 2038114:	0007883a 	mov	r3,zero
 2038118:	10c00035 	stwio	r3,0(r2)
 203811c:	00000206 	br	2038128 <alt_avalon_spi_command+0x14c>
      }
      else
        credits = -1024;
 2038120:	00bf0004 	movi	r2,-1024
 2038124:	e0bff715 	stw	r2,-36(fp)
    };

    if ((status & ALTERA_AVALON_SPI_STATUS_RRDY_MSK) != 0)
 2038128:	e0bffa17 	ldw	r2,-24(fp)
 203812c:	1080200c 	andi	r2,r2,128
 2038130:	103fcf26 	beq	r2,zero,2038070 <alt_avalon_spi_command+0x94>
    {
      alt_u32 rxdata = IORD_ALTERA_AVALON_SPI_RXDATA(base);
 2038134:	e0bffc17 	ldw	r2,-16(fp)
 2038138:	10800037 	ldwio	r2,0(r2)
 203813c:	e0bffb15 	stw	r2,-20(fp)

      if (read_ignore > 0)
 2038140:	e0bff617 	ldw	r2,-40(fp)
 2038144:	10000426 	beq	r2,zero,2038158 <alt_avalon_spi_command+0x17c>
        read_ignore--;
 2038148:	e0bff617 	ldw	r2,-40(fp)
 203814c:	10bfffc4 	addi	r2,r2,-1
 2038150:	e0bff615 	stw	r2,-40(fp)
 2038154:	00000706 	br	2038174 <alt_avalon_spi_command+0x198>
      else
        *read_data++ = (alt_u8)rxdata;
 2038158:	e0bffb17 	ldw	r2,-20(fp)
 203815c:	1007883a 	mov	r3,r2
 2038160:	e0800217 	ldw	r2,8(fp)
 2038164:	10c00005 	stb	r3,0(r2)
 2038168:	e0800217 	ldw	r2,8(fp)
 203816c:	10800044 	addi	r2,r2,1
 2038170:	e0800215 	stw	r2,8(fp)
      credits++;
 2038174:	e0bff717 	ldw	r2,-36(fp)
 2038178:	10800044 	addi	r2,r2,1
 203817c:	e0bff715 	stw	r2,-36(fp)

      if (read_ignore == 0 && read_data == read_end)
 2038180:	e0bff617 	ldw	r2,-40(fp)
 2038184:	103fba1e 	bne	r2,zero,2038070 <alt_avalon_spi_command+0x94>
 2038188:	e0c00217 	ldw	r3,8(fp)
 203818c:	e0bff917 	ldw	r2,-28(fp)
 2038190:	18bfb71e 	bne	r3,r2,2038070 <alt_avalon_spi_command+0x94>
        break;
 2038194:	0001883a 	nop
  }

  /* Wait until the interface has finished transmitting */
  do
  {
    status = IORD_ALTERA_AVALON_SPI_STATUS(base);
 2038198:	e0bffc17 	ldw	r2,-16(fp)
 203819c:	10800204 	addi	r2,r2,8
 20381a0:	10800037 	ldwio	r2,0(r2)
 20381a4:	e0bffa15 	stw	r2,-24(fp)
  }
  while ((status & ALTERA_AVALON_SPI_STATUS_TMT_MSK) == 0);
 20381a8:	e0bffa17 	ldw	r2,-24(fp)
 20381ac:	1080080c 	andi	r2,r2,32
 20381b0:	103ff926 	beq	r2,zero,2038198 <alt_avalon_spi_command+0x1bc>

  /* Clear SSO (release chipselect) unless the caller is going to
   * keep using this chip
   */
  if ((flags & ALT_AVALON_SPI_COMMAND_MERGE) == 0)
 20381b4:	e0800317 	ldw	r2,12(fp)
 20381b8:	1080004c 	andi	r2,r2,1
 20381bc:	1000041e 	bne	r2,zero,20381d0 <alt_avalon_spi_command+0x1f4>
    IOWR_ALTERA_AVALON_SPI_CONTROL(base, 0);
 20381c0:	e0bffc17 	ldw	r2,-16(fp)
 20381c4:	10800304 	addi	r2,r2,12
 20381c8:	0007883a 	mov	r3,zero
 20381cc:	10c00035 	stwio	r3,0(r2)

  return read_length;
 20381d0:	e0800117 	ldw	r2,4(fp)
}
 20381d4:	e037883a 	mov	sp,fp
 20381d8:	df000017 	ldw	fp,0(sp)
 20381dc:	dec00104 	addi	sp,sp,4
 20381e0:	f800283a 	ret

020381e4 <no_printf>:
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

void no_printf (char *fmt, ...) {}
 20381e4:	defffb04 	addi	sp,sp,-20
 20381e8:	df000115 	stw	fp,4(sp)
 20381ec:	df000104 	addi	fp,sp,4
 20381f0:	e1400115 	stw	r5,4(fp)
 20381f4:	e1800215 	stw	r6,8(fp)
 20381f8:	e1c00315 	stw	r7,12(fp)
 20381fc:	e13fff15 	stw	r4,-4(fp)
 2038200:	e037883a 	mov	sp,fp
 2038204:	df000017 	ldw	fp,0(sp)
 2038208:	dec00404 	addi	sp,sp,16
 203820c:	f800283a 	ret

02038210 <tse_mac_initTransInfo2>:

alt_32 tse_mac_initTransInfo2( tse_mac_trans_info *mi,
                                        alt_u32 mac_base,
                                        alt_32 tx_sgdma,
                                        alt_32 rx_sgdma,
                                        alt_32 cfgflags) {
 2038210:	defffb04 	addi	sp,sp,-20
 2038214:	df000415 	stw	fp,16(sp)
 2038218:	df000404 	addi	fp,sp,16
 203821c:	e13ffc15 	stw	r4,-16(fp)
 2038220:	e17ffd15 	stw	r5,-12(fp)
 2038224:	e1bffe15 	stw	r6,-8(fp)
 2038228:	e1ffff15 	stw	r7,-4(fp)
                                              
        mi->base     = (np_tse_mac*)mac_base;
 203822c:	e0fffd17 	ldw	r3,-12(fp)
 2038230:	e0bffc17 	ldw	r2,-16(fp)
 2038234:	10c00015 	stw	r3,0(r2)
        mi->tx_sgdma = (alt_sgdma_dev *)tx_sgdma;
 2038238:	e0fffe17 	ldw	r3,-8(fp)
 203823c:	e0bffc17 	ldw	r2,-16(fp)
 2038240:	10c00115 	stw	r3,4(r2)
        mi->rx_sgdma = (alt_sgdma_dev *)rx_sgdma;
 2038244:	e0ffff17 	ldw	r3,-4(fp)
 2038248:	e0bffc17 	ldw	r2,-16(fp)
 203824c:	10c00215 	stw	r3,8(r2)
        mi->cfgflags = cfgflags;     
 2038250:	e0c00117 	ldw	r3,4(fp)
 2038254:	e0bffc17 	ldw	r2,-16(fp)
 2038258:	10c00415 	stw	r3,16(r2)
        return SUCCESS;
 203825c:	0005883a 	mov	r2,zero
}
 2038260:	e037883a 	mov	sp,fp
 2038264:	df000017 	ldw	fp,0(sp)
 2038268:	dec00104 	addi	sp,sp,4
 203826c:	f800283a 	ret

02038270 <tse_mac_sTxWrite>:
  * @param txDesc           Pointer to the transmit SGDMA descriptor
  * @return actual bytes transferred if ok, else error (-1)
  */
alt_32 tse_mac_sTxWrite( tse_mac_trans_info *mi, 
                       alt_sgdma_descriptor *txDesc)   
{ 
 2038270:	defffa04 	addi	sp,sp,-24
 2038274:	dfc00515 	stw	ra,20(sp)
 2038278:	df000415 	stw	fp,16(sp)
 203827c:	df000404 	addi	fp,sp,16
 2038280:	e13ffe15 	stw	r4,-8(fp)
 2038284:	e17fff15 	stw	r5,-4(fp)

  alt_32 timeout;
  alt_u8 result = 0;
 2038288:	e03ffd05 	stb	zero,-12(fp)
  alt_u16 actualBytesTransferred;
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
 203828c:	e03ffc15 	stw	zero,-16(fp)
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 2038290:	00000e06 	br	20382cc <tse_mac_sTxWrite+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
           if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 2038294:	e0fffc17 	ldw	r3,-16(fp)
 2038298:	008003f4 	movhi	r2,15
 203829c:	10909004 	addi	r2,r2,16960
 20382a0:	1885003a 	cmpeq	r2,r3,r2
 20382a4:	e0fffc17 	ldw	r3,-16(fp)
 20382a8:	18c00044 	addi	r3,r3,1
 20382ac:	e0fffc15 	stw	r3,-16(fp)
 20382b0:	10803fcc 	andi	r2,r2,255
 20382b4:	10000526 	beq	r2,zero,20382cc <tse_mac_sTxWrite+0x5c>
            tse_dprintf(4, "WARNING : TX SGDMA Timeout\n");
 20382b8:	01008174 	movhi	r4,517
 20382bc:	213d9e04 	addi	r4,r4,-2440
 20382c0:	2006cb40 	call	2006cb4 <puts>
            return ENP_RESOURCE;  // avoid being stuck here
 20382c4:	00bffa84 	movi	r2,-22
 20382c8:	00001c06 	br	203833c <tse_mac_sTxWrite+0xcc>
    
  // Make sure DMA controller is not busy from a former command
  // and TX is able to accept data
  timeout = 0;
  //tse_dprintf("\nWaiting while tx SGDMA is busy......... ");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->tx_sgdma->base) & 
 20382cc:	e0bffe17 	ldw	r2,-8(fp)
 20382d0:	10800117 	ldw	r2,4(r2)
 20382d4:	10800317 	ldw	r2,12(r2)
 20382d8:	10800037 	ldwio	r2,0(r2)
 20382dc:	1080040c 	andi	r2,r2,16
 20382e0:	103fec1e 	bne	r2,zero,2038294 <tse_mac_sTxWrite+0x24>
           }
  }

  // Set up the SGDMA
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
 20382e4:	e0bffe17 	ldw	r2,-8(fp)
 20382e8:	10800117 	ldw	r2,4(r2)
 20382ec:	10800317 	ldw	r2,12(r2)
 20382f0:	10800404 	addi	r2,r2,16
 20382f4:	0007883a 	mov	r3,zero
 20382f8:	10c00035 	stwio	r3,0(r2)
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
 20382fc:	e0bffe17 	ldw	r2,-8(fp)
 2038300:	10800117 	ldw	r2,4(r2)
 2038304:	10800317 	ldw	r2,12(r2)
 2038308:	00c03fc4 	movi	r3,255
 203830c:	10c00035 	stwio	r3,0(r2)
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
                mi->tx_sgdma, 
 2038310:	e0bffe17 	ldw	r2,-8(fp)
  // Clear the status and control bits of the SGDMA descriptor
  IOWR_ALTERA_AVALON_SGDMA_CONTROL (mi->tx_sgdma->base, 0);
  IOWR_ALTERA_AVALON_SGDMA_STATUS (mi->tx_sgdma->base, 0xFF);
  
  // Start SGDMA (blocking call)
  result = alt_avalon_sgdma_do_sync_transfer(
 2038314:	10800117 	ldw	r2,4(r2)
 2038318:	1009883a 	mov	r4,r2
 203831c:	e17fff17 	ldw	r5,-4(fp)
 2038320:	202015c0 	call	202015c <alt_avalon_sgdma_do_sync_transfer>
 2038324:	e0bffd05 	stb	r2,-12(fp)
                mi->tx_sgdma, 
                (alt_sgdma_descriptor *) &txDesc[0]);
  
  /* perform cache save read to obtain actual bytes transferred for current sgdma descriptor */
  actualBytesTransferred = IORD_ALTERA_TSE_SGDMA_DESC_ACTUAL_BYTES_TRANSFERRED(&txDesc[0]);
 2038328:	e0bfff17 	ldw	r2,-4(fp)
 203832c:	10800704 	addi	r2,r2,28
 2038330:	10800037 	ldwio	r2,0(r2)
 2038334:	e0bffd8d 	sth	r2,-10(fp)

  return actualBytesTransferred;
 2038338:	e0bffd8b 	ldhu	r2,-10(fp)
}
 203833c:	e037883a 	mov	sp,fp
 2038340:	dfc00117 	ldw	ra,4(sp)
 2038344:	df000017 	ldw	fp,0(sp)
 2038348:	dec00204 	addi	sp,sp,8
 203834c:	f800283a 	ret

02038350 <tse_mac_aRxRead>:
  *        the actual bytes transferred for current descriptor
  */
alt_32 tse_mac_aRxRead( 
  tse_mac_trans_info *mi,       
  alt_sgdma_descriptor *rxDesc)  
{
 2038350:	defffa04 	addi	sp,sp,-24
 2038354:	dfc00515 	stw	ra,20(sp)
 2038358:	df000415 	stw	fp,16(sp)
 203835c:	df000404 	addi	fp,sp,16
 2038360:	e13ffe15 	stw	r4,-8(fp)
 2038364:	e17fff15 	stw	r5,-4(fp)
  alt_32 timeout;
  
  alt_u8 result = 0;
 2038368:	e03ffd05 	stb	zero,-12(fp)
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
 203836c:	e03ffc15 	stw	zero,-16(fp)
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 2038370:	00000e06 	br	20383ac <tse_mac_aRxRead+0x5c>
           ALTERA_AVALON_SGDMA_STATUS_BUSY_MSK) ) {
    if(timeout++ == ALTERA_TSE_SGDMA_BUSY_TIME_OUT_CNT) {
 2038374:	e0fffc17 	ldw	r3,-16(fp)
 2038378:	008003f4 	movhi	r2,15
 203837c:	10909004 	addi	r2,r2,16960
 2038380:	1885003a 	cmpeq	r2,r3,r2
 2038384:	e0fffc17 	ldw	r3,-16(fp)
 2038388:	18c00044 	addi	r3,r3,1
 203838c:	e0fffc15 	stw	r3,-16(fp)
 2038390:	10803fcc 	andi	r2,r2,255
 2038394:	10000526 	beq	r2,zero,20383ac <tse_mac_aRxRead+0x5c>
        tse_dprintf(4, "WARNING : RX SGDMA Timeout\n");
 2038398:	01008174 	movhi	r4,517
 203839c:	213da504 	addi	r4,r4,-2412
 20383a0:	2006cb40 	call	2006cb4 <puts>
        return ENP_RESOURCE;  // avoid being stuck here
 20383a4:	00bffa84 	movi	r2,-22
 20383a8:	00000d06 	br	20383e0 <tse_mac_aRxRead+0x90>
  alt_u8 result = 0;
         
  // Make sure SGDMA controller is not busy from a former command
  timeout = 0;
//  tse_dprintf("\nWaiting while rx SGDMA is busy.........");
  while ( (IORD_ALTERA_AVALON_SGDMA_STATUS(mi->rx_sgdma->base) & 
 20383ac:	e0bffe17 	ldw	r2,-8(fp)
 20383b0:	10800217 	ldw	r2,8(r2)
 20383b4:	10800317 	ldw	r2,12(r2)
 20383b8:	10800037 	ldwio	r2,0(r2)
 20383bc:	1080040c 	andi	r2,r2,16
 20383c0:	103fec1e 	bne	r2,zero,2038374 <tse_mac_aRxRead+0x24>
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
                mi->rx_sgdma, 
 20383c4:	e0bffe17 	ldw	r2,-8(fp)
    }
  }

 
  // SGDMA operation invoked for RX (non-blocking call)
  result = alt_avalon_sgdma_do_async_transfer(
 20383c8:	10800217 	ldw	r2,8(r2)
 20383cc:	1009883a 	mov	r4,r2
 20383d0:	e17fff17 	ldw	r5,-4(fp)
 20383d4:	20200380 	call	2020038 <alt_avalon_sgdma_do_async_transfer>
 20383d8:	e0bffd05 	stb	r2,-12(fp)
                mi->rx_sgdma, 
                (alt_sgdma_descriptor *) &rxDesc[0]);

 
  return SUCCESS;
 20383dc:	0005883a 	mov	r2,zero
}
 20383e0:	e037883a 	mov	sp,fp
 20383e4:	dfc00117 	ldw	ra,4(sp)
 20383e8:	df000017 	ldw	fp,0(sp)
 20383ec:	dec00204 	addi	sp,sp,8
 20383f0:	f800283a 	ret

020383f4 <tse_mac_SwReset>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_SwReset(np_tse_mac *pmac) 
{
 20383f4:	defffc04 	addi	sp,sp,-16
 20383f8:	df000315 	stw	fp,12(sp)
 20383fc:	df000304 	addi	fp,sp,12
 2038400:	e13fff15 	stw	r4,-4(fp)
	alt_32 timeout;
	alt_32 cc;
        
    cc = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 2038404:	e0bfff17 	ldw	r2,-4(fp)
 2038408:	10800204 	addi	r2,r2,8
 203840c:	10800037 	ldwio	r2,0(r2)
 2038410:	e0bffe15 	stw	r2,-8(fp)
    
    // set reset and Gig-Speed bits to make sure we have an incoming clock on
    // tx side. If there is a 10/100 PHY, we will still have a valid clock on
    // tx_clk no matter what setting we have here, but on a Gig phy the
    // MII clock may be missing.
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,(ALTERA_TSEMAC_CMD_SW_RESET_MSK | ALTERA_TSEMAC_CMD_ETH_SPEED_MSK));
 2038414:	e0bfff17 	ldw	r2,-4(fp)
 2038418:	10800204 	addi	r2,r2,8
 203841c:	00c80204 	movi	r3,8200
 2038420:	10c00035 	stwio	r3,0(r2)

    
    // wait for completion with fallback in case there is no PHY or it is
    // not connected and hence might not provide any clocks at all.
    timeout=0;
 2038424:	e03ffd15 	stw	zero,-12(fp)
    while( (IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac) & ALTERA_TSEMAC_CMD_SW_RESET_MSK) != 0 && timeout < ALTERA_TSE_SW_RESET_TIME_OUT_CNT) timeout++;
 2038428:	00000306 	br	2038438 <tse_mac_SwReset+0x44>
 203842c:	e0bffd17 	ldw	r2,-12(fp)
 2038430:	10800044 	addi	r2,r2,1
 2038434:	e0bffd15 	stw	r2,-12(fp)
 2038438:	e0bfff17 	ldw	r2,-4(fp)
 203843c:	10800204 	addi	r2,r2,8
 2038440:	10800037 	ldwio	r2,0(r2)
 2038444:	1088000c 	andi	r2,r2,8192
 2038448:	10000326 	beq	r2,zero,2038458 <tse_mac_SwReset+0x64>
 203844c:	e0bffd17 	ldw	r2,-12(fp)
 2038450:	1089c410 	cmplti	r2,r2,10000
 2038454:	103ff51e 	bne	r2,zero,203842c <tse_mac_SwReset+0x38>
   
    IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,cc); // Restore
 2038458:	e0bfff17 	ldw	r2,-4(fp)
 203845c:	10800204 	addi	r2,r2,8
 2038460:	e0fffe17 	ldw	r3,-8(fp)
 2038464:	10c00035 	stwio	r3,0(r2)
    return SUCCESS;
 2038468:	0005883a 	mov	r2,zero
}
 203846c:	e037883a 	mov	sp,fp
 2038470:	df000017 	ldw	fp,0(sp)
 2038474:	dec00104 	addi	sp,sp,4
 2038478:	f800283a 	ret

0203847c <tse_mac_setMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
*/
alt_32 tse_mac_setMIImode(np_tse_mac *pmac)
{
 203847c:	defffd04 	addi	sp,sp,-12
 2038480:	df000215 	stw	fp,8(sp)
 2038484:	df000204 	addi	fp,sp,8
 2038488:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 203848c:	e0bfff17 	ldw	r2,-4(fp)
 2038490:	10800204 	addi	r2,r2,8
 2038494:	10800037 	ldwio	r2,0(r2)
 2038498:	e0bffe15 	stw	r2,-8(fp)
  helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK; 
 203849c:	e0fffe17 	ldw	r3,-8(fp)
 20384a0:	00bffdc4 	movi	r2,-9
 20384a4:	1884703a 	and	r2,r3,r2
 20384a8:	e0bffe15 	stw	r2,-8(fp)
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 20384ac:	e0bfff17 	ldw	r2,-4(fp)
 20384b0:	10800204 	addi	r2,r2,8
 20384b4:	e0fffe17 	ldw	r3,-8(fp)
 20384b8:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 20384bc:	0005883a 	mov	r2,zero
}
 20384c0:	e037883a 	mov	sp,fp
 20384c4:	df000017 	ldw	fp,0(sp)
 20384c8:	dec00104 	addi	sp,sp,4
 20384cc:	f800283a 	ret

020384d0 <tse_mac_setGMIImode>:
 *                        COMMAND_CONFIG register is restored after reset.
 * @API Type:   Public
 * @param pmac  Pointer to the TSE MAC Control Interface Base address 
 */
alt_32 tse_mac_setGMIImode(np_tse_mac *pmac)
{
 20384d0:	defffd04 	addi	sp,sp,-12
 20384d4:	df000215 	stw	fp,8(sp)
 20384d8:	df000204 	addi	fp,sp,8
 20384dc:	e13fff15 	stw	r4,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 20384e0:	e0bfff17 	ldw	r2,-4(fp)
 20384e4:	10800204 	addi	r2,r2,8
 20384e8:	10800037 	ldwio	r2,0(r2)
 20384ec:	e0bffe15 	stw	r2,-8(fp)
  helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20384f0:	e0bffe17 	ldw	r2,-8(fp)
 20384f4:	10800214 	ori	r2,r2,8
 20384f8:	e0bffe15 	stw	r2,-8(fp)

  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac,helpvar);
 20384fc:	e0bfff17 	ldw	r2,-4(fp)
 2038500:	10800204 	addi	r2,r2,8
 2038504:	e0fffe17 	ldw	r3,-8(fp)
 2038508:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 203850c:	0005883a 	mov	r2,zero
}
 2038510:	e037883a 	mov	sp,fp
 2038514:	df000017 	ldw	fp,0(sp)
 2038518:	dec00104 	addi	sp,sp,4
 203851c:	f800283a 	ret

02038520 <alt_tse_phy_add_profile>:
 * @param  phy  pointer to alt_tse_phy_profile structure describing PHY registers
 * @return      index of PHY added in PHY profile on success, else return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 * PHY which are currently supported by default :  Marvell 88E1111, Marvell Quad PHY 88E1145, National DP83865, and National DP83848C
 */
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
 2038520:	defffb04 	addi	sp,sp,-20
 2038524:	dfc00415 	stw	ra,16(sp)
 2038528:	df000315 	stw	fp,12(sp)
 203852c:	dc000215 	stw	r16,8(sp)
 2038530:	df000204 	addi	fp,sp,8
 2038534:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 2038538:	e03ffe15 	stw	zero,-8(fp)
 203853c:	00002906 	br	20385e4 <alt_tse_phy_add_profile+0xc4>
    {
        if(pphy_profiles[i]->oui == phy->oui && pphy_profiles[i]->model_number == phy->model_number)
 2038540:	00c09934 	movhi	r3,612
 2038544:	18f77104 	addi	r3,r3,-8764
 2038548:	e0bffe17 	ldw	r2,-8(fp)
 203854c:	1085883a 	add	r2,r2,r2
 2038550:	1085883a 	add	r2,r2,r2
 2038554:	1885883a 	add	r2,r3,r2
 2038558:	10800017 	ldw	r2,0(r2)
 203855c:	10c01417 	ldw	r3,80(r2)
 2038560:	e0bfff17 	ldw	r2,-4(fp)
 2038564:	10801417 	ldw	r2,80(r2)
 2038568:	18801b1e 	bne	r3,r2,20385d8 <alt_tse_phy_add_profile+0xb8>
 203856c:	00c09934 	movhi	r3,612
 2038570:	18f77104 	addi	r3,r3,-8764
 2038574:	e0bffe17 	ldw	r2,-8(fp)
 2038578:	1085883a 	add	r2,r2,r2
 203857c:	1085883a 	add	r2,r2,r2
 2038580:	1885883a 	add	r2,r3,r2
 2038584:	10800017 	ldw	r2,0(r2)
 2038588:	10c01503 	ldbu	r3,84(r2)
 203858c:	e0bfff17 	ldw	r2,-4(fp)
 2038590:	10801503 	ldbu	r2,84(r2)
 2038594:	18c03fcc 	andi	r3,r3,255
 2038598:	10803fcc 	andi	r2,r2,255
 203859c:	18800e1e 	bne	r3,r2,20385d8 <alt_tse_phy_add_profile+0xb8>
        {
            tse_dprintf(4, "WARNING : PHY OUI 0x%06x, PHY Model Number 0x%02x already exist in PHY profile\n", (int) phy->oui, phy->model_number);
 20385a0:	e0bfff17 	ldw	r2,-4(fp)
 20385a4:	10801417 	ldw	r2,80(r2)
 20385a8:	1007883a 	mov	r3,r2
 20385ac:	e0bfff17 	ldw	r2,-4(fp)
 20385b0:	10801503 	ldbu	r2,84(r2)
 20385b4:	10803fcc 	andi	r2,r2,255
 20385b8:	01008174 	movhi	r4,517
 20385bc:	213dac04 	addi	r4,r4,-2384
 20385c0:	180b883a 	mov	r5,r3
 20385c4:	100d883a 	mov	r6,r2
 20385c8:	2006a240 	call	2006a24 <printf>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
 20385cc:	01008174 	movhi	r4,517
 20385d0:	213dc004 	addi	r4,r4,-2304
 20385d4:	2006cb40 	call	2006cb4 <puts>
alt_32 alt_tse_phy_add_profile(alt_tse_phy_profile *phy)
{
	alt_32 i;
    
    /* search PHY profile for same ID */
    for(i = 0; i < phy_profile_count; i++)
 20385d8:	e0bffe17 	ldw	r2,-8(fp)
 20385dc:	10800044 	addi	r2,r2,1
 20385e0:	e0bffe15 	stw	r2,-8(fp)
 20385e4:	d0a0af03 	ldbu	r2,-32068(gp)
 20385e8:	10803fcc 	andi	r2,r2,255
 20385ec:	e0fffe17 	ldw	r3,-8(fp)
 20385f0:	18bfd316 	blt	r3,r2,2038540 <alt_tse_phy_add_profile+0x20>
            tse_dprintf(4, "In case of same PHY OUI and PHY Model Number in profile, first added PHY setting will be used\n");
        }
    }

    /* Allocate memory space to store the profile */    
    pphy_profiles[phy_profile_count] = (alt_tse_phy_profile *) malloc(sizeof(alt_tse_phy_profile));
 20385f4:	d0a0af03 	ldbu	r2,-32068(gp)
 20385f8:	14003fcc 	andi	r16,r2,255
 20385fc:	01001904 	movi	r4,100
 2038600:	204bd440 	call	204bd44 <malloc>
 2038604:	1007883a 	mov	r3,r2
 2038608:	01009934 	movhi	r4,612
 203860c:	21377104 	addi	r4,r4,-8764
 2038610:	8405883a 	add	r2,r16,r16
 2038614:	1085883a 	add	r2,r2,r2
 2038618:	2085883a 	add	r2,r4,r2
 203861c:	10c00015 	stw	r3,0(r2)
    if(!pphy_profiles[phy_profile_count]) {
 2038620:	d0a0af03 	ldbu	r2,-32068(gp)
 2038624:	10803fcc 	andi	r2,r2,255
 2038628:	00c09934 	movhi	r3,612
 203862c:	18f77104 	addi	r3,r3,-8764
 2038630:	1085883a 	add	r2,r2,r2
 2038634:	1085883a 	add	r2,r2,r2
 2038638:	1885883a 	add	r2,r3,r2
 203863c:	10800017 	ldw	r2,0(r2)
 2038640:	1000081e 	bne	r2,zero,2038664 <alt_tse_phy_add_profile+0x144>
        tse_dprintf(1, "ERROR   : Unable to allocate memory for pphy_profile[%d]\n", phy_profile_count);
 2038644:	d0a0af03 	ldbu	r2,-32068(gp)
 2038648:	10803fcc 	andi	r2,r2,255
 203864c:	01008174 	movhi	r4,517
 2038650:	213dd804 	addi	r4,r4,-2208
 2038654:	100b883a 	mov	r5,r2
 2038658:	2006a240 	call	2006a24 <printf>
        return ALTERA_TSE_MALLOC_FAILED;
 203865c:	00bfffc4 	movi	r2,-1
 2038660:	00002206 	br	20386ec <alt_tse_phy_add_profile+0x1cc>
    }

    /* Store PHY information */
    *pphy_profiles[phy_profile_count] = *phy;
 2038664:	d0a0af03 	ldbu	r2,-32068(gp)
 2038668:	10803fcc 	andi	r2,r2,255
 203866c:	00c09934 	movhi	r3,612
 2038670:	18f77104 	addi	r3,r3,-8764
 2038674:	1085883a 	add	r2,r2,r2
 2038678:	1085883a 	add	r2,r2,r2
 203867c:	1885883a 	add	r2,r3,r2
 2038680:	10c00017 	ldw	r3,0(r2)
 2038684:	e0bfff17 	ldw	r2,-4(fp)
 2038688:	1809883a 	mov	r4,r3
 203868c:	1007883a 	mov	r3,r2
 2038690:	00801904 	movi	r2,100
 2038694:	180b883a 	mov	r5,r3
 2038698:	100d883a 	mov	r6,r2
 203869c:	200660c0 	call	200660c <memcpy>
    strcpy(pphy_profiles[phy_profile_count]->name, phy->name);
 20386a0:	d0a0af03 	ldbu	r2,-32068(gp)
 20386a4:	10803fcc 	andi	r2,r2,255
 20386a8:	00c09934 	movhi	r3,612
 20386ac:	18f77104 	addi	r3,r3,-8764
 20386b0:	1085883a 	add	r2,r2,r2
 20386b4:	1085883a 	add	r2,r2,r2
 20386b8:	1885883a 	add	r2,r3,r2
 20386bc:	10800017 	ldw	r2,0(r2)
 20386c0:	1007883a 	mov	r3,r2
 20386c4:	e0bfff17 	ldw	r2,-4(fp)
 20386c8:	1809883a 	mov	r4,r3
 20386cc:	100b883a 	mov	r5,r2
 20386d0:	200756c0 	call	200756c <strcpy>
    
    phy_profile_count++;
 20386d4:	d0a0af03 	ldbu	r2,-32068(gp)
 20386d8:	10800044 	addi	r2,r2,1
 20386dc:	d0a0af05 	stb	r2,-32068(gp)
    
    return phy_profile_count - 1;
 20386e0:	d0a0af03 	ldbu	r2,-32068(gp)
 20386e4:	10803fcc 	andi	r2,r2,255
 20386e8:	10bfffc4 	addi	r2,r2,-1
}
 20386ec:	e037883a 	mov	sp,fp
 20386f0:	dfc00217 	ldw	ra,8(sp)
 20386f4:	df000117 	ldw	fp,4(sp)
 20386f8:	dc000017 	ldw	r16,0(sp)
 20386fc:	dec00304 	addi	sp,sp,12
 2038700:	f800283a 	ret

02038704 <alt_tse_system_add_sys>:
alt_32 alt_tse_system_add_sys(
	alt_tse_system_mac					*psys_mac,
	alt_tse_system_sgdma				*psys_sgdma,
	alt_tse_system_desc_mem				*psys_mem,
	alt_tse_system_shared_fifo			*psys_shared_fifo,
	alt_tse_system_phy 					*psys_phy ) {
 2038704:	defff204 	addi	sp,sp,-56
 2038708:	dfc00d15 	stw	ra,52(sp)
 203870c:	df000c15 	stw	fp,48(sp)
 2038710:	dc000b15 	stw	r16,44(sp)
 2038714:	df000b04 	addi	fp,sp,44
 2038718:	e13ffc15 	stw	r4,-16(fp)
 203871c:	e17ffd15 	stw	r5,-12(fp)
 2038720:	e1bffe15 	stw	r6,-8(fp)
 2038724:	e1ffff15 	stw	r7,-4(fp)

	int i;
	int loop_end;
	
	alt_tse_system_mac					*pmac	= psys_mac;
 2038728:	e0bffc17 	ldw	r2,-16(fp)
 203872c:	e0bffb15 	stw	r2,-20(fp)
	alt_tse_system_sgdma				*psgdma	= psys_sgdma;
 2038730:	e0bffd17 	ldw	r2,-12(fp)
 2038734:	e0bff715 	stw	r2,-36(fp)
	alt_tse_system_desc_mem				*pmem	= psys_mem;
 2038738:	e0bffe17 	ldw	r2,-8(fp)
 203873c:	e0bff815 	stw	r2,-32(fp)
	alt_tse_system_shared_fifo			*pfifo	= psys_shared_fifo;
 2038740:	e0bfff17 	ldw	r2,-4(fp)
 2038744:	e0bff915 	stw	r2,-28(fp)
	alt_tse_system_phy 					*pphy	= psys_phy;
 2038748:	e0800317 	ldw	r2,12(fp)
 203874c:	e0bffa15 	stw	r2,-24(fp)
	
	static alt_8 tse_system_count = 0;
	
	/* Determine number of loop */
	/* Run at least one for non-multi-channel MAC */
	if(pmac->tse_num_of_channel == 0) {
 2038750:	e0bffb17 	ldw	r2,-20(fp)
 2038754:	10800303 	ldbu	r2,12(r2)
 2038758:	10803fcc 	andi	r2,r2,255
 203875c:	1000031e 	bne	r2,zero,203876c <alt_tse_system_add_sys+0x68>
		loop_end = 1;
 2038760:	00800044 	movi	r2,1
 2038764:	e0bff615 	stw	r2,-40(fp)
 2038768:	00000e06 	br	20387a4 <alt_tse_system_add_sys+0xa0>
	}
	else if(pmac->tse_num_of_channel > 0) {
 203876c:	e0bffb17 	ldw	r2,-20(fp)
 2038770:	10800303 	ldbu	r2,12(r2)
 2038774:	10803fcc 	andi	r2,r2,255
 2038778:	10000526 	beq	r2,zero,2038790 <alt_tse_system_add_sys+0x8c>
		loop_end = pmac->tse_num_of_channel; 
 203877c:	e0bffb17 	ldw	r2,-20(fp)
 2038780:	10800303 	ldbu	r2,12(r2)
 2038784:	10803fcc 	andi	r2,r2,255
 2038788:	e0bff615 	stw	r2,-40(fp)
 203878c:	00000506 	br	20387a4 <alt_tse_system_add_sys+0xa0>
	}
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
 2038790:	01008174 	movhi	r4,517
 2038794:	213de704 	addi	r4,r4,-2148
 2038798:	2006cb40 	call	2006cb4 <puts>
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
 203879c:	00bfffc4 	movi	r2,-1
 20387a0:	00025106 	br	20390e8 <alt_tse_system_add_sys+0x9e4>
	}

	for(i = 0; i < loop_end; i++) {
 20387a4:	e03ff515 	stw	zero,-44(fp)
 20387a8:	00024b06 	br	20390d8 <alt_tse_system_add_sys+0x9d4>
		
		/* Make sure the boundary of array is not exceeded */
		if(tse_system_count >= MAXNETS) {
 20387ac:	d0a0afc3 	ldbu	r2,-32065(gp)
 20387b0:	10803fcc 	andi	r2,r2,255
 20387b4:	1080201c 	xori	r2,r2,128
 20387b8:	10bfe004 	addi	r2,r2,-128
 20387bc:	10800110 	cmplti	r2,r2,4
 20387c0:	10000c1e 	bne	r2,zero,20387f4 <alt_tse_system_add_sys+0xf0>
			tse_dprintf(2, "ERROR   : Number of TSE System added exceed the size of array!\n");
 20387c4:	01008174 	movhi	r4,517
 20387c8:	213df304 	addi	r4,r4,-2100
 20387cc:	2006cb40 	call	2006cb4 <puts>
			tse_dprintf(2, "ERROR   : Size of array = %d, Number of TSE System = %d\n", MAXNETS, tse_system_count);
 20387d0:	d0a0afc3 	ldbu	r2,-32065(gp)
 20387d4:	10803fcc 	andi	r2,r2,255
 20387d8:	1080201c 	xori	r2,r2,128
 20387dc:	10bfe004 	addi	r2,r2,-128
 20387e0:	01008174 	movhi	r4,517
 20387e4:	213e0304 	addi	r4,r4,-2036
 20387e8:	01400104 	movi	r5,4
 20387ec:	100d883a 	mov	r6,r2
 20387f0:	2006a240 	call	2006a24 <printf>
		}

		/* Add MAC info to alt_tse_system_info structure */
		if(pmac == 0) {
 20387f4:	e0bffb17 	ldw	r2,-20(fp)
 20387f8:	1000081e 	bne	r2,zero,203881c <alt_tse_system_add_sys+0x118>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 20387fc:	01008174 	movhi	r4,517
 2038800:	213e1204 	addi	r4,r4,-1976
 2038804:	2006cb40 	call	2006cb4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys()\n");
 2038808:	01008174 	movhi	r4,517
 203880c:	213e1c04 	addi	r4,r4,-1936
 2038810:	2006cb40 	call	2006cb4 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2038814:	00bfffc4 	movi	r2,-1
 2038818:	00023306 	br	20390e8 <alt_tse_system_add_sys+0x9e4>
		}		
		
		tse_mac_device[tse_system_count].tse_mac_base 					= pmac->tse_mac_base + (i * 0x400);
 203881c:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038820:	10803fcc 	andi	r2,r2,255
 2038824:	1080201c 	xori	r2,r2,128
 2038828:	10bfe004 	addi	r2,r2,-128
 203882c:	e0fffb17 	ldw	r3,-20(fp)
 2038830:	19000017 	ldw	r4,0(r3)
 2038834:	e0fff517 	ldw	r3,-44(fp)
 2038838:	180692ba 	slli	r3,r3,10
 203883c:	20c7883a 	add	r3,r4,r3
 2038840:	01008174 	movhi	r4,517
 2038844:	210f7e04 	addi	r4,r4,15864
 2038848:	10801224 	muli	r2,r2,72
 203884c:	2085883a 	add	r2,r4,r2
 2038850:	10c00015 	stw	r3,0(r2)
		tse_mac_device[tse_system_count].tse_tx_depth 					= pmac->tse_tx_depth;
 2038854:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038858:	10803fcc 	andi	r2,r2,255
 203885c:	1080201c 	xori	r2,r2,128
 2038860:	10bfe004 	addi	r2,r2,-128
 2038864:	e0fffb17 	ldw	r3,-20(fp)
 2038868:	18c0010b 	ldhu	r3,4(r3)
 203886c:	01008174 	movhi	r4,517
 2038870:	210f7e04 	addi	r4,r4,15864
 2038874:	10801224 	muli	r2,r2,72
 2038878:	2085883a 	add	r2,r4,r2
 203887c:	10800104 	addi	r2,r2,4
 2038880:	10c0000d 	sth	r3,0(r2)
		tse_mac_device[tse_system_count].tse_rx_depth 					= pmac->tse_rx_depth;
 2038884:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038888:	10803fcc 	andi	r2,r2,255
 203888c:	1080201c 	xori	r2,r2,128
 2038890:	10bfe004 	addi	r2,r2,-128
 2038894:	e0fffb17 	ldw	r3,-20(fp)
 2038898:	18c0018b 	ldhu	r3,6(r3)
 203889c:	01008174 	movhi	r4,517
 20388a0:	210f7e04 	addi	r4,r4,15864
 20388a4:	10801224 	muli	r2,r2,72
 20388a8:	2085883a 	add	r2,r4,r2
 20388ac:	10800104 	addi	r2,r2,4
 20388b0:	10c0008d 	sth	r3,2(r2)
		tse_mac_device[tse_system_count].tse_use_mdio 					= pmac->tse_use_mdio;
 20388b4:	d0a0afc3 	ldbu	r2,-32065(gp)
 20388b8:	10803fcc 	andi	r2,r2,255
 20388bc:	1080201c 	xori	r2,r2,128
 20388c0:	10bfe004 	addi	r2,r2,-128
 20388c4:	e0fffb17 	ldw	r3,-20(fp)
 20388c8:	18c00203 	ldbu	r3,8(r3)
 20388cc:	01008174 	movhi	r4,517
 20388d0:	210f7e04 	addi	r4,r4,15864
 20388d4:	10801224 	muli	r2,r2,72
 20388d8:	2085883a 	add	r2,r4,r2
 20388dc:	10800204 	addi	r2,r2,8
 20388e0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_en_maclite 				= pmac->tse_en_maclite;
 20388e4:	d0a0afc3 	ldbu	r2,-32065(gp)
 20388e8:	10803fcc 	andi	r2,r2,255
 20388ec:	1080201c 	xori	r2,r2,128
 20388f0:	10bfe004 	addi	r2,r2,-128
 20388f4:	e0fffb17 	ldw	r3,-20(fp)
 20388f8:	18c00243 	ldbu	r3,9(r3)
 20388fc:	01008174 	movhi	r4,517
 2038900:	210f7e04 	addi	r4,r4,15864
 2038904:	10801224 	muli	r2,r2,72
 2038908:	2085883a 	add	r2,r4,r2
 203890c:	10800204 	addi	r2,r2,8
 2038910:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_maclite_gige 				= pmac->tse_maclite_gige;
 2038914:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038918:	10803fcc 	andi	r2,r2,255
 203891c:	1080201c 	xori	r2,r2,128
 2038920:	10bfe004 	addi	r2,r2,-128
 2038924:	e0fffb17 	ldw	r3,-20(fp)
 2038928:	18c00283 	ldbu	r3,10(r3)
 203892c:	01008174 	movhi	r4,517
 2038930:	210f7e04 	addi	r4,r4,15864
 2038934:	10801224 	muli	r2,r2,72
 2038938:	2085883a 	add	r2,r4,r2
 203893c:	10800204 	addi	r2,r2,8
 2038940:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_multichannel_mac 			= pmac->tse_multichannel_mac;
 2038944:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038948:	10803fcc 	andi	r2,r2,255
 203894c:	1080201c 	xori	r2,r2,128
 2038950:	10bfe004 	addi	r2,r2,-128
 2038954:	e0fffb17 	ldw	r3,-20(fp)
 2038958:	18c002c3 	ldbu	r3,11(r3)
 203895c:	01008174 	movhi	r4,517
 2038960:	210f7e04 	addi	r4,r4,15864
 2038964:	10801224 	muli	r2,r2,72
 2038968:	2085883a 	add	r2,r4,r2
 203896c:	10800204 	addi	r2,r2,8
 2038970:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_num_of_channel 			= pmac->tse_num_of_channel;
 2038974:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038978:	10803fcc 	andi	r2,r2,255
 203897c:	1080201c 	xori	r2,r2,128
 2038980:	10bfe004 	addi	r2,r2,-128
 2038984:	e0fffb17 	ldw	r3,-20(fp)
 2038988:	18c00303 	ldbu	r3,12(r3)
 203898c:	01008174 	movhi	r4,517
 2038990:	210f7e04 	addi	r4,r4,15864
 2038994:	10801224 	muli	r2,r2,72
 2038998:	2085883a 	add	r2,r4,r2
 203899c:	10800304 	addi	r2,r2,12
 20389a0:	10c00005 	stb	r3,0(r2)
		tse_mac_device[tse_system_count].tse_mdio_shared 				= pmac->tse_mdio_shared;
 20389a4:	d0a0afc3 	ldbu	r2,-32065(gp)
 20389a8:	10803fcc 	andi	r2,r2,255
 20389ac:	1080201c 	xori	r2,r2,128
 20389b0:	10bfe004 	addi	r2,r2,-128
 20389b4:	e0fffb17 	ldw	r3,-20(fp)
 20389b8:	18c00343 	ldbu	r3,13(r3)
 20389bc:	01008174 	movhi	r4,517
 20389c0:	210f7e04 	addi	r4,r4,15864
 20389c4:	10801224 	muli	r2,r2,72
 20389c8:	2085883a 	add	r2,r4,r2
 20389cc:	10800304 	addi	r2,r2,12
 20389d0:	10c00045 	stb	r3,1(r2)
		tse_mac_device[tse_system_count].tse_number_of_mac_mdio_shared	= pmac->tse_number_of_mac_mdio_shared;
 20389d4:	d0a0afc3 	ldbu	r2,-32065(gp)
 20389d8:	10803fcc 	andi	r2,r2,255
 20389dc:	1080201c 	xori	r2,r2,128
 20389e0:	10bfe004 	addi	r2,r2,-128
 20389e4:	e0fffb17 	ldw	r3,-20(fp)
 20389e8:	18c00383 	ldbu	r3,14(r3)
 20389ec:	01008174 	movhi	r4,517
 20389f0:	210f7e04 	addi	r4,r4,15864
 20389f4:	10801224 	muli	r2,r2,72
 20389f8:	2085883a 	add	r2,r4,r2
 20389fc:	10800304 	addi	r2,r2,12
 2038a00:	10c00085 	stb	r3,2(r2)
		tse_mac_device[tse_system_count].tse_pcs_ena 					= pmac->tse_pcs_ena;
 2038a04:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038a08:	10803fcc 	andi	r2,r2,255
 2038a0c:	1080201c 	xori	r2,r2,128
 2038a10:	10bfe004 	addi	r2,r2,-128
 2038a14:	e0fffb17 	ldw	r3,-20(fp)
 2038a18:	18c003c3 	ldbu	r3,15(r3)
 2038a1c:	01008174 	movhi	r4,517
 2038a20:	210f7e04 	addi	r4,r4,15864
 2038a24:	10801224 	muli	r2,r2,72
 2038a28:	2085883a 	add	r2,r4,r2
 2038a2c:	10800304 	addi	r2,r2,12
 2038a30:	10c000c5 	stb	r3,3(r2)
		tse_mac_device[tse_system_count].tse_pcs_sgmii 					= pmac->tse_pcs_sgmii;
 2038a34:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038a38:	10803fcc 	andi	r2,r2,255
 2038a3c:	1080201c 	xori	r2,r2,128
 2038a40:	10bfe004 	addi	r2,r2,-128
 2038a44:	e0fffb17 	ldw	r3,-20(fp)
 2038a48:	18c00403 	ldbu	r3,16(r3)
 2038a4c:	01008174 	movhi	r4,517
 2038a50:	210f7e04 	addi	r4,r4,15864
 2038a54:	10801224 	muli	r2,r2,72
 2038a58:	2085883a 	add	r2,r4,r2
 2038a5c:	10800404 	addi	r2,r2,16
 2038a60:	10c00005 	stb	r3,0(r2)
		
		/* Add SGDMA info to alt_tse_system_info structure */
		if(psgdma == 0) {
 2038a64:	e0bff717 	ldw	r2,-36(fp)
 2038a68:	10000d1e 	bne	r2,zero,2038aa0 <alt_tse_system_add_sys+0x39c>
			tse_dprintf(2, "ERROR   : SGDMA system structure == NULL\n");
 2038a6c:	01008174 	movhi	r4,517
 2038a70:	213e2e04 	addi	r4,r4,-1864
 2038a74:	2006cb40 	call	2006cb4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_system_add_sys() for tse_mac_device[%d]\n", tse_system_count);
 2038a78:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038a7c:	10803fcc 	andi	r2,r2,255
 2038a80:	1080201c 	xori	r2,r2,128
 2038a84:	10bfe004 	addi	r2,r2,-128
 2038a88:	01008174 	movhi	r4,517
 2038a8c:	213e3904 	addi	r4,r4,-1820
 2038a90:	100b883a 	mov	r5,r2
 2038a94:	2006a240 	call	2006a24 <printf>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2038a98:	00bfffc4 	movi	r2,-1
 2038a9c:	00019206 	br	20390e8 <alt_tse_system_add_sys+0x9e4>
		}
		
		tse_mac_device[tse_system_count].tse_sgdma_tx = (char *) malloc(strlen(psgdma->tse_sgdma_tx) + 1);
 2038aa0:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038aa4:	14003fcc 	andi	r16,r2,255
 2038aa8:	8400201c 	xori	r16,r16,128
 2038aac:	843fe004 	addi	r16,r16,-128
 2038ab0:	e0bff717 	ldw	r2,-36(fp)
 2038ab4:	10800017 	ldw	r2,0(r2)
 2038ab8:	1009883a 	mov	r4,r2
 2038abc:	2007c640 	call	2007c64 <strlen>
 2038ac0:	10800044 	addi	r2,r2,1
 2038ac4:	1009883a 	mov	r4,r2
 2038ac8:	204bd440 	call	204bd44 <malloc>
 2038acc:	1007883a 	mov	r3,r2
 2038ad0:	01008174 	movhi	r4,517
 2038ad4:	210f7e04 	addi	r4,r4,15864
 2038ad8:	80801224 	muli	r2,r16,72
 2038adc:	2085883a 	add	r2,r4,r2
 2038ae0:	10800504 	addi	r2,r2,20
 2038ae4:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_tx) {
 2038ae8:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038aec:	10803fcc 	andi	r2,r2,255
 2038af0:	1080201c 	xori	r2,r2,128
 2038af4:	10bfe004 	addi	r2,r2,-128
 2038af8:	00c08174 	movhi	r3,517
 2038afc:	18cf7e04 	addi	r3,r3,15864
 2038b00:	10801224 	muli	r2,r2,72
 2038b04:	1885883a 	add	r2,r3,r2
 2038b08:	10800504 	addi	r2,r2,20
 2038b0c:	10800017 	ldw	r2,0(r2)
 2038b10:	10000a1e 	bne	r2,zero,2038b3c <alt_tse_system_add_sys+0x438>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_tx\n", tse_system_count);
 2038b14:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038b18:	10803fcc 	andi	r2,r2,255
 2038b1c:	1080201c 	xori	r2,r2,128
 2038b20:	10bfe004 	addi	r2,r2,-128
 2038b24:	01008174 	movhi	r4,517
 2038b28:	213e5104 	addi	r4,r4,-1724
 2038b2c:	100b883a 	mov	r5,r2
 2038b30:	2006a240 	call	2006a24 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 2038b34:	00bfffc4 	movi	r2,-1
 2038b38:	00016b06 	br	20390e8 <alt_tse_system_add_sys+0x9e4>
	    }   
		strcpy(tse_mac_device[tse_system_count].tse_sgdma_tx, psgdma->tse_sgdma_tx);
 2038b3c:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038b40:	10803fcc 	andi	r2,r2,255
 2038b44:	1080201c 	xori	r2,r2,128
 2038b48:	10bfe004 	addi	r2,r2,-128
 2038b4c:	00c08174 	movhi	r3,517
 2038b50:	18cf7e04 	addi	r3,r3,15864
 2038b54:	10801224 	muli	r2,r2,72
 2038b58:	1885883a 	add	r2,r3,r2
 2038b5c:	10800504 	addi	r2,r2,20
 2038b60:	10c00017 	ldw	r3,0(r2)
 2038b64:	e0bff717 	ldw	r2,-36(fp)
 2038b68:	10800017 	ldw	r2,0(r2)
 2038b6c:	1809883a 	mov	r4,r3
 2038b70:	100b883a 	mov	r5,r2
 2038b74:	200756c0 	call	200756c <strcpy>
		
		tse_mac_device[tse_system_count].tse_sgdma_rx = (char *) malloc(strlen(psgdma->tse_sgdma_rx) + 1);
 2038b78:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038b7c:	14003fcc 	andi	r16,r2,255
 2038b80:	8400201c 	xori	r16,r16,128
 2038b84:	843fe004 	addi	r16,r16,-128
 2038b88:	e0bff717 	ldw	r2,-36(fp)
 2038b8c:	10800117 	ldw	r2,4(r2)
 2038b90:	1009883a 	mov	r4,r2
 2038b94:	2007c640 	call	2007c64 <strlen>
 2038b98:	10800044 	addi	r2,r2,1
 2038b9c:	1009883a 	mov	r4,r2
 2038ba0:	204bd440 	call	204bd44 <malloc>
 2038ba4:	1007883a 	mov	r3,r2
 2038ba8:	01008174 	movhi	r4,517
 2038bac:	210f7e04 	addi	r4,r4,15864
 2038bb0:	80801224 	muli	r2,r16,72
 2038bb4:	2085883a 	add	r2,r4,r2
 2038bb8:	10800604 	addi	r2,r2,24
 2038bbc:	10c00015 	stw	r3,0(r2)
	    if(!tse_mac_device[tse_system_count].tse_sgdma_rx) {
 2038bc0:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038bc4:	10803fcc 	andi	r2,r2,255
 2038bc8:	1080201c 	xori	r2,r2,128
 2038bcc:	10bfe004 	addi	r2,r2,-128
 2038bd0:	00c08174 	movhi	r3,517
 2038bd4:	18cf7e04 	addi	r3,r3,15864
 2038bd8:	10801224 	muli	r2,r2,72
 2038bdc:	1885883a 	add	r2,r3,r2
 2038be0:	10800604 	addi	r2,r2,24
 2038be4:	10800017 	ldw	r2,0(r2)
 2038be8:	10000a1e 	bne	r2,zero,2038c14 <alt_tse_system_add_sys+0x510>
	        tse_dprintf(1, "ERROR   : Unable to allocate memory for tse_mac_device[%d].tse_sgdma_rx\n", tse_system_count);
 2038bec:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038bf0:	10803fcc 	andi	r2,r2,255
 2038bf4:	1080201c 	xori	r2,r2,128
 2038bf8:	10bfe004 	addi	r2,r2,-128
 2038bfc:	01008174 	movhi	r4,517
 2038c00:	213e6404 	addi	r4,r4,-1648
 2038c04:	100b883a 	mov	r5,r2
 2038c08:	2006a240 	call	2006a24 <printf>
	        return ALTERA_TSE_MALLOC_FAILED;
 2038c0c:	00bfffc4 	movi	r2,-1
 2038c10:	00013506 	br	20390e8 <alt_tse_system_add_sys+0x9e4>
	    }
	    strcpy(tse_mac_device[tse_system_count].tse_sgdma_rx, psgdma->tse_sgdma_rx);
 2038c14:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038c18:	10803fcc 	andi	r2,r2,255
 2038c1c:	1080201c 	xori	r2,r2,128
 2038c20:	10bfe004 	addi	r2,r2,-128
 2038c24:	00c08174 	movhi	r3,517
 2038c28:	18cf7e04 	addi	r3,r3,15864
 2038c2c:	10801224 	muli	r2,r2,72
 2038c30:	1885883a 	add	r2,r3,r2
 2038c34:	10800604 	addi	r2,r2,24
 2038c38:	10c00017 	ldw	r3,0(r2)
 2038c3c:	e0bff717 	ldw	r2,-36(fp)
 2038c40:	10800117 	ldw	r2,4(r2)
 2038c44:	1809883a 	mov	r4,r3
 2038c48:	100b883a 	mov	r5,r2
 2038c4c:	200756c0 	call	200756c <strcpy>
	    
		tse_mac_device[tse_system_count].tse_sgdma_rx_irq = psgdma->tse_sgdma_rx_irq;
 2038c50:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038c54:	10803fcc 	andi	r2,r2,255
 2038c58:	1080201c 	xori	r2,r2,128
 2038c5c:	10bfe004 	addi	r2,r2,-128
 2038c60:	e0fff717 	ldw	r3,-36(fp)
 2038c64:	18c0020b 	ldhu	r3,8(r3)
 2038c68:	01008174 	movhi	r4,517
 2038c6c:	210f7e04 	addi	r4,r4,15864
 2038c70:	10801224 	muli	r2,r2,72
 2038c74:	2085883a 	add	r2,r4,r2
 2038c78:	10800704 	addi	r2,r2,28
 2038c7c:	10c0000d 	sth	r3,0(r2)
		
		/* Add descriptor memory info to alt_tse_system_info structure */
		if(pmem == 0) {
 2038c80:	e0bff817 	ldw	r2,-32(fp)
 2038c84:	1000151e 	bne	r2,zero,2038cdc <alt_tse_system_add_sys+0x5d8>
			tse_mac_device[tse_system_count].ext_desc_mem	= TSE_INT_DESC_MEM;
 2038c88:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038c8c:	10803fcc 	andi	r2,r2,255
 2038c90:	1080201c 	xori	r2,r2,128
 2038c94:	10bfe004 	addi	r2,r2,-128
 2038c98:	00c08174 	movhi	r3,517
 2038c9c:	18cf7e04 	addi	r3,r3,15864
 2038ca0:	10801224 	muli	r2,r2,72
 2038ca4:	1885883a 	add	r2,r3,r2
 2038ca8:	10800704 	addi	r2,r2,28
 2038cac:	10000085 	stb	zero,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= TSE_INT_DESC_MEM;
 2038cb0:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038cb4:	10803fcc 	andi	r2,r2,255
 2038cb8:	1080201c 	xori	r2,r2,128
 2038cbc:	10bfe004 	addi	r2,r2,-128
 2038cc0:	00c08174 	movhi	r3,517
 2038cc4:	18cf7e04 	addi	r3,r3,15864
 2038cc8:	10801224 	muli	r2,r2,72
 2038ccc:	1885883a 	add	r2,r3,r2
 2038cd0:	10800804 	addi	r2,r2,32
 2038cd4:	10000015 	stw	zero,0(r2)
 2038cd8:	00001806 	br	2038d3c <alt_tse_system_add_sys+0x638>
		}
		else {
			tse_mac_device[tse_system_count].ext_desc_mem	= pmem->ext_desc_mem;
 2038cdc:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038ce0:	10803fcc 	andi	r2,r2,255
 2038ce4:	1080201c 	xori	r2,r2,128
 2038ce8:	10bfe004 	addi	r2,r2,-128
 2038cec:	e0fff817 	ldw	r3,-32(fp)
 2038cf0:	18c00003 	ldbu	r3,0(r3)
 2038cf4:	01008174 	movhi	r4,517
 2038cf8:	210f7e04 	addi	r4,r4,15864
 2038cfc:	10801224 	muli	r2,r2,72
 2038d00:	2085883a 	add	r2,r4,r2
 2038d04:	10800704 	addi	r2,r2,28
 2038d08:	10c00085 	stb	r3,2(r2)
			tse_mac_device[tse_system_count].desc_mem_base	= pmem->desc_mem_base;
 2038d0c:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038d10:	10803fcc 	andi	r2,r2,255
 2038d14:	1080201c 	xori	r2,r2,128
 2038d18:	10bfe004 	addi	r2,r2,-128
 2038d1c:	e0fff817 	ldw	r3,-32(fp)
 2038d20:	18c00117 	ldw	r3,4(r3)
 2038d24:	01008174 	movhi	r4,517
 2038d28:	210f7e04 	addi	r4,r4,15864
 2038d2c:	10801224 	muli	r2,r2,72
 2038d30:	2085883a 	add	r2,r4,r2
 2038d34:	10800804 	addi	r2,r2,32
 2038d38:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add shared fifo info to alt_tse_system_info structure */
		if(pfifo == 0) {
 2038d3c:	e0bff917 	ldw	r2,-28(fp)
 2038d40:	1000471e 	bne	r2,zero,2038e60 <alt_tse_system_add_sys+0x75c>
			tse_mac_device[tse_system_count].use_shared_fifo                = TSE_NO_SHARED_FIFO;
 2038d44:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038d48:	10803fcc 	andi	r2,r2,255
 2038d4c:	1080201c 	xori	r2,r2,128
 2038d50:	10bfe004 	addi	r2,r2,-128
 2038d54:	00c08174 	movhi	r3,517
 2038d58:	18cf7e04 	addi	r3,r3,15864
 2038d5c:	10801224 	muli	r2,r2,72
 2038d60:	1885883a 	add	r2,r3,r2
 2038d64:	10800904 	addi	r2,r2,36
 2038d68:	10000005 	stb	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= TSE_NO_SHARED_FIFO;
 2038d6c:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038d70:	10803fcc 	andi	r2,r2,255
 2038d74:	1080201c 	xori	r2,r2,128
 2038d78:	10bfe004 	addi	r2,r2,-128
 2038d7c:	00c08174 	movhi	r3,517
 2038d80:	18cf7e04 	addi	r3,r3,15864
 2038d84:	10801224 	muli	r2,r2,72
 2038d88:	1885883a 	add	r2,r3,r2
 2038d8c:	10800a04 	addi	r2,r2,40
 2038d90:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= TSE_NO_SHARED_FIFO;
 2038d94:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038d98:	10803fcc 	andi	r2,r2,255
 2038d9c:	1080201c 	xori	r2,r2,128
 2038da0:	10bfe004 	addi	r2,r2,-128
 2038da4:	00c08174 	movhi	r3,517
 2038da8:	18cf7e04 	addi	r3,r3,15864
 2038dac:	10801224 	muli	r2,r2,72
 2038db0:	1885883a 	add	r2,r3,r2
 2038db4:	10800b04 	addi	r2,r2,44
 2038db8:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = TSE_NO_SHARED_FIFO;
 2038dbc:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038dc0:	10803fcc 	andi	r2,r2,255
 2038dc4:	1080201c 	xori	r2,r2,128
 2038dc8:	10bfe004 	addi	r2,r2,-128
 2038dcc:	00c08174 	movhi	r3,517
 2038dd0:	18cf7e04 	addi	r3,r3,15864
 2038dd4:	10801224 	muli	r2,r2,72
 2038dd8:	1885883a 	add	r2,r3,r2
 2038ddc:	10800c04 	addi	r2,r2,48
 2038de0:	10000015 	stw	zero,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= TSE_NO_SHARED_FIFO;
 2038de4:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038de8:	10803fcc 	andi	r2,r2,255
 2038dec:	1080201c 	xori	r2,r2,128
 2038df0:	10bfe004 	addi	r2,r2,-128
 2038df4:	00c08174 	movhi	r3,517
 2038df8:	18cf7e04 	addi	r3,r3,15864
 2038dfc:	10801224 	muli	r2,r2,72
 2038e00:	1885883a 	add	r2,r3,r2
 2038e04:	10800d04 	addi	r2,r2,52
 2038e08:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= TSE_NO_SHARED_FIFO;
 2038e0c:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038e10:	10803fcc 	andi	r2,r2,255
 2038e14:	1080201c 	xori	r2,r2,128
 2038e18:	10bfe004 	addi	r2,r2,-128
 2038e1c:	00c08174 	movhi	r3,517
 2038e20:	18cf7e04 	addi	r3,r3,15864
 2038e24:	10801224 	muli	r2,r2,72
 2038e28:	1885883a 	add	r2,r3,r2
 2038e2c:	10800e04 	addi	r2,r2,56
 2038e30:	10000015 	stw	zero,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = TSE_NO_SHARED_FIFO;
 2038e34:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038e38:	10803fcc 	andi	r2,r2,255
 2038e3c:	1080201c 	xori	r2,r2,128
 2038e40:	10bfe004 	addi	r2,r2,-128
 2038e44:	00c08174 	movhi	r3,517
 2038e48:	18cf7e04 	addi	r3,r3,15864
 2038e4c:	10801224 	muli	r2,r2,72
 2038e50:	1885883a 	add	r2,r3,r2
 2038e54:	10800f04 	addi	r2,r2,60
 2038e58:	10000015 	stw	zero,0(r2)
 2038e5c:	00005406 	br	2038fb0 <alt_tse_system_add_sys+0x8ac>
		}
		else {
			tse_mac_device[tse_system_count].use_shared_fifo                = pfifo->use_shared_fifo;
 2038e60:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038e64:	10803fcc 	andi	r2,r2,255
 2038e68:	1080201c 	xori	r2,r2,128
 2038e6c:	10bfe004 	addi	r2,r2,-128
 2038e70:	e0fff917 	ldw	r3,-28(fp)
 2038e74:	18c00003 	ldbu	r3,0(r3)
 2038e78:	01008174 	movhi	r4,517
 2038e7c:	210f7e04 	addi	r4,r4,15864
 2038e80:	10801224 	muli	r2,r2,72
 2038e84:	2085883a 	add	r2,r4,r2
 2038e88:	10800904 	addi	r2,r2,36
 2038e8c:	10c00005 	stb	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_ctrl_base	= pfifo->tse_shared_fifo_tx_ctrl_base;
 2038e90:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038e94:	10803fcc 	andi	r2,r2,255
 2038e98:	1080201c 	xori	r2,r2,128
 2038e9c:	10bfe004 	addi	r2,r2,-128
 2038ea0:	e0fff917 	ldw	r3,-28(fp)
 2038ea4:	18c00117 	ldw	r3,4(r3)
 2038ea8:	01008174 	movhi	r4,517
 2038eac:	210f7e04 	addi	r4,r4,15864
 2038eb0:	10801224 	muli	r2,r2,72
 2038eb4:	2085883a 	add	r2,r4,r2
 2038eb8:	10800a04 	addi	r2,r2,40
 2038ebc:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_stat_base	= pfifo->tse_shared_fifo_tx_stat_base;
 2038ec0:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038ec4:	10803fcc 	andi	r2,r2,255
 2038ec8:	1080201c 	xori	r2,r2,128
 2038ecc:	10bfe004 	addi	r2,r2,-128
 2038ed0:	e0fff917 	ldw	r3,-28(fp)
 2038ed4:	18c00217 	ldw	r3,8(r3)
 2038ed8:	01008174 	movhi	r4,517
 2038edc:	210f7e04 	addi	r4,r4,15864
 2038ee0:	10801224 	muli	r2,r2,72
 2038ee4:	2085883a 	add	r2,r4,r2
 2038ee8:	10800b04 	addi	r2,r2,44
 2038eec:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_tx_depth       = pfifo->tse_shared_fifo_tx_depth;
 2038ef0:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038ef4:	10803fcc 	andi	r2,r2,255
 2038ef8:	1080201c 	xori	r2,r2,128
 2038efc:	10bfe004 	addi	r2,r2,-128
 2038f00:	e0fff917 	ldw	r3,-28(fp)
 2038f04:	18c00317 	ldw	r3,12(r3)
 2038f08:	01008174 	movhi	r4,517
 2038f0c:	210f7e04 	addi	r4,r4,15864
 2038f10:	10801224 	muli	r2,r2,72
 2038f14:	2085883a 	add	r2,r4,r2
 2038f18:	10800c04 	addi	r2,r2,48
 2038f1c:	10c00015 	stw	r3,0(r2)
			
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_ctrl_base	= pfifo->tse_shared_fifo_rx_ctrl_base;
 2038f20:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038f24:	10803fcc 	andi	r2,r2,255
 2038f28:	1080201c 	xori	r2,r2,128
 2038f2c:	10bfe004 	addi	r2,r2,-128
 2038f30:	e0fff917 	ldw	r3,-28(fp)
 2038f34:	18c00417 	ldw	r3,16(r3)
 2038f38:	01008174 	movhi	r4,517
 2038f3c:	210f7e04 	addi	r4,r4,15864
 2038f40:	10801224 	muli	r2,r2,72
 2038f44:	2085883a 	add	r2,r4,r2
 2038f48:	10800d04 	addi	r2,r2,52
 2038f4c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_stat_base	= pfifo->tse_shared_fifo_rx_stat_base;
 2038f50:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038f54:	10803fcc 	andi	r2,r2,255
 2038f58:	1080201c 	xori	r2,r2,128
 2038f5c:	10bfe004 	addi	r2,r2,-128
 2038f60:	e0fff917 	ldw	r3,-28(fp)
 2038f64:	18c00517 	ldw	r3,20(r3)
 2038f68:	01008174 	movhi	r4,517
 2038f6c:	210f7e04 	addi	r4,r4,15864
 2038f70:	10801224 	muli	r2,r2,72
 2038f74:	2085883a 	add	r2,r4,r2
 2038f78:	10800e04 	addi	r2,r2,56
 2038f7c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_shared_fifo_rx_depth       = pfifo->tse_shared_fifo_rx_depth;
 2038f80:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038f84:	10803fcc 	andi	r2,r2,255
 2038f88:	1080201c 	xori	r2,r2,128
 2038f8c:	10bfe004 	addi	r2,r2,-128
 2038f90:	e0fff917 	ldw	r3,-28(fp)
 2038f94:	18c00617 	ldw	r3,24(r3)
 2038f98:	01008174 	movhi	r4,517
 2038f9c:	210f7e04 	addi	r4,r4,15864
 2038fa0:	10801224 	muli	r2,r2,72
 2038fa4:	2085883a 	add	r2,r4,r2
 2038fa8:	10800f04 	addi	r2,r2,60
 2038fac:	10c00015 	stw	r3,0(r2)
		}
		
		/* Add PHY info to alt_tse_system_info structure */
		if(pphy == 0) {
 2038fb0:	e0bffa17 	ldw	r2,-24(fp)
 2038fb4:	1000161e 	bne	r2,zero,2039010 <alt_tse_system_add_sys+0x90c>
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= TSE_PHY_AUTO_ADDRESS;
 2038fb8:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038fbc:	10803fcc 	andi	r2,r2,255
 2038fc0:	1080201c 	xori	r2,r2,128
 2038fc4:	10bfe004 	addi	r2,r2,-128
 2038fc8:	00c08174 	movhi	r3,517
 2038fcc:	18cf7e04 	addi	r3,r3,15864
 2038fd0:	10801224 	muli	r2,r2,72
 2038fd4:	1885883a 	add	r2,r3,r2
 2038fd8:	10801004 	addi	r2,r2,64
 2038fdc:	00ffffc4 	movi	r3,-1
 2038fe0:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= 0;
 2038fe4:	d0a0afc3 	ldbu	r2,-32065(gp)
 2038fe8:	10803fcc 	andi	r2,r2,255
 2038fec:	1080201c 	xori	r2,r2,128
 2038ff0:	10bfe004 	addi	r2,r2,-128
 2038ff4:	00c08174 	movhi	r3,517
 2038ff8:	18cf7e04 	addi	r3,r3,15864
 2038ffc:	10801224 	muli	r2,r2,72
 2039000:	1885883a 	add	r2,r3,r2
 2039004:	10801104 	addi	r2,r2,68
 2039008:	10000015 	stw	zero,0(r2)
 203900c:	00001806 	br	2039070 <alt_tse_system_add_sys+0x96c>
		}
		else {
			tse_mac_device[tse_system_count].tse_phy_mdio_address	= pphy->tse_phy_mdio_address;
 2039010:	d0a0afc3 	ldbu	r2,-32065(gp)
 2039014:	10803fcc 	andi	r2,r2,255
 2039018:	1080201c 	xori	r2,r2,128
 203901c:	10bfe004 	addi	r2,r2,-128
 2039020:	e0fffa17 	ldw	r3,-24(fp)
 2039024:	18c00017 	ldw	r3,0(r3)
 2039028:	01008174 	movhi	r4,517
 203902c:	210f7e04 	addi	r4,r4,15864
 2039030:	10801224 	muli	r2,r2,72
 2039034:	2085883a 	add	r2,r4,r2
 2039038:	10801004 	addi	r2,r2,64
 203903c:	10c00015 	stw	r3,0(r2)
			tse_mac_device[tse_system_count].tse_phy_cfg 			= pphy->tse_phy_cfg;
 2039040:	d0a0afc3 	ldbu	r2,-32065(gp)
 2039044:	10803fcc 	andi	r2,r2,255
 2039048:	1080201c 	xori	r2,r2,128
 203904c:	10bfe004 	addi	r2,r2,-128
 2039050:	e0fffa17 	ldw	r3,-24(fp)
 2039054:	18c00117 	ldw	r3,4(r3)
 2039058:	01008174 	movhi	r4,517
 203905c:	210f7e04 	addi	r4,r4,15864
 2039060:	10801224 	muli	r2,r2,72
 2039064:	2085883a 	add	r2,r4,r2
 2039068:	10801104 	addi	r2,r2,68
 203906c:	10c00015 	stw	r3,0(r2)
		}
		
		/* Point to next structure */
		psgdma++;
 2039070:	e0bff717 	ldw	r2,-36(fp)
 2039074:	10800304 	addi	r2,r2,12
 2039078:	e0bff715 	stw	r2,-36(fp)
		if(pmem) pmem++;
 203907c:	e0bff817 	ldw	r2,-32(fp)
 2039080:	10000326 	beq	r2,zero,2039090 <alt_tse_system_add_sys+0x98c>
 2039084:	e0bff817 	ldw	r2,-32(fp)
 2039088:	10800204 	addi	r2,r2,8
 203908c:	e0bff815 	stw	r2,-32(fp)
		if(pfifo) pfifo++;
 2039090:	e0bff917 	ldw	r2,-28(fp)
 2039094:	10000326 	beq	r2,zero,20390a4 <alt_tse_system_add_sys+0x9a0>
 2039098:	e0bff917 	ldw	r2,-28(fp)
 203909c:	10800704 	addi	r2,r2,28
 20390a0:	e0bff915 	stw	r2,-28(fp)
		if(pphy) pphy++;
 20390a4:	e0bffa17 	ldw	r2,-24(fp)
 20390a8:	10000326 	beq	r2,zero,20390b8 <alt_tse_system_add_sys+0x9b4>
 20390ac:	e0bffa17 	ldw	r2,-24(fp)
 20390b0:	10800204 	addi	r2,r2,8
 20390b4:	e0bffa15 	stw	r2,-24(fp)
		
		tse_system_count++;
 20390b8:	d0a0afc3 	ldbu	r2,-32065(gp)
 20390bc:	10800044 	addi	r2,r2,1
 20390c0:	d0a0afc5 	stb	r2,-32065(gp)
		max_mac_system = tse_system_count;
 20390c4:	d0a0afc3 	ldbu	r2,-32065(gp)
 20390c8:	d0a04f05 	stb	r2,-32452(gp)
	else {
		tse_dprintf(2, "ERROR   : Invalid number of channel specified!\n");
		return ALTERA_TSE_SYSTEM_DEF_ERROR;
	}

	for(i = 0; i < loop_end; i++) {
 20390cc:	e0bff517 	ldw	r2,-44(fp)
 20390d0:	10800044 	addi	r2,r2,1
 20390d4:	e0bff515 	stw	r2,-44(fp)
 20390d8:	e0fff517 	ldw	r3,-44(fp)
 20390dc:	e0bff617 	ldw	r2,-40(fp)
 20390e0:	18bdb216 	blt	r3,r2,20387ac <alt_tse_system_add_sys+0xa8>
		
		tse_system_count++;
		max_mac_system = tse_system_count;
	}
	
	return SUCCESS;
 20390e4:	0005883a 	mov	r2,zero
	
}
 20390e8:	e037883a 	mov	sp,fp
 20390ec:	dfc00217 	ldw	ra,8(sp)
 20390f0:	df000117 	ldw	fp,4(sp)
 20390f4:	dc000017 	ldw	r16,0(sp)
 20390f8:	dec00304 	addi	sp,sp,12
 20390fc:	f800283a 	ret

02039100 <alt_tse_sys_enable_mdio_sharing>:
 * @param		number_of_mac  number of MAC sharing MDIO block
 * @return      SUCCESS on success
 * 				ALTERA_TSE_SYSTEM_DEF_ERROR if definition of system incorrect or pointer == NULL
 * Multi-channel MAC not supported
 */
alt_32 alt_tse_sys_enable_mdio_sharing(alt_tse_system_mac **psys_mac_list, alt_u8 number_of_mac) {
 2039100:	defff904 	addi	sp,sp,-28
 2039104:	dfc00615 	stw	ra,24(sp)
 2039108:	df000515 	stw	fp,20(sp)
 203910c:	df000504 	addi	fp,sp,20
 2039110:	e13ffe15 	stw	r4,-8(fp)
 2039114:	2805883a 	mov	r2,r5
 2039118:	e0bfff05 	stb	r2,-4(fp)
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 203911c:	e03ffb15 	stw	zero,-20(fp)
 2039120:	00004706 	br	2039240 <alt_tse_sys_enable_mdio_sharing+0x140>
		psys_mac = psys_mac_list[i];
 2039124:	e0bffb17 	ldw	r2,-20(fp)
 2039128:	1085883a 	add	r2,r2,r2
 203912c:	1085883a 	add	r2,r2,r2
 2039130:	e0fffe17 	ldw	r3,-8(fp)
 2039134:	1885883a 	add	r2,r3,r2
 2039138:	10800017 	ldw	r2,0(r2)
 203913c:	e0bffd15 	stw	r2,-12(fp)
		
		if(psys_mac == 0) {
 2039140:	e0bffd17 	ldw	r2,-12(fp)
 2039144:	1000081e 	bne	r2,zero,2039168 <alt_tse_sys_enable_mdio_sharing+0x68>
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
 2039148:	01008174 	movhi	r4,517
 203914c:	213e1204 	addi	r4,r4,-1976
 2039150:	2006cb40 	call	2006cb4 <puts>
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
 2039154:	01008174 	movhi	r4,517
 2039158:	213e7704 	addi	r4,r4,-1572
 203915c:	2006cb40 	call	2006cb4 <puts>
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
 2039160:	00bfffc4 	movi	r2,-1
 2039164:	00003a06 	br	2039250 <alt_tse_sys_enable_mdio_sharing+0x150>
		}
		
		for(j = 0; j < max_mac_system; j++) {
 2039168:	e03ffc15 	stw	zero,-16(fp)
 203916c:	00002d06 	br	2039224 <alt_tse_sys_enable_mdio_sharing+0x124>
			
			if(psys_mac->tse_mac_base == tse_mac_device[j].tse_mac_base) {
 2039170:	e0bffd17 	ldw	r2,-12(fp)
 2039174:	10c00017 	ldw	r3,0(r2)
 2039178:	01008174 	movhi	r4,517
 203917c:	210f7e04 	addi	r4,r4,15864
 2039180:	e0bffc17 	ldw	r2,-16(fp)
 2039184:	10801224 	muli	r2,r2,72
 2039188:	2085883a 	add	r2,r4,r2
 203918c:	10800017 	ldw	r2,0(r2)
 2039190:	1880211e 	bne	r3,r2,2039218 <alt_tse_sys_enable_mdio_sharing+0x118>
				if(tse_mac_device[j].tse_multichannel_mac) {
 2039194:	00c08174 	movhi	r3,517
 2039198:	18cf7e04 	addi	r3,r3,15864
 203919c:	e0bffc17 	ldw	r2,-16(fp)
 20391a0:	10801224 	muli	r2,r2,72
 20391a4:	1885883a 	add	r2,r3,r2
 20391a8:	10800204 	addi	r2,r2,8
 20391ac:	108000c3 	ldbu	r2,3(r2)
 20391b0:	10803fcc 	andi	r2,r2,255
 20391b4:	10000826 	beq	r2,zero,20391d8 <alt_tse_sys_enable_mdio_sharing+0xd8>
					tse_dprintf(2, "ERROR   : MDIO sharing supported by default for Multi-channel MAC\n");
 20391b8:	01008174 	movhi	r4,517
 20391bc:	213e8b04 	addi	r4,r4,-1492
 20391c0:	2006cb40 	call	2006cb4 <puts>
					tse_dprintf(2, "ERROR   : Do not include Multi-channel MAC in the MAC List\n");
 20391c4:	01008174 	movhi	r4,517
 20391c8:	213e9c04 	addi	r4,r4,-1424
 20391cc:	2006cb40 	call	2006cb4 <puts>
					return ALTERA_TSE_SYSTEM_DEF_ERROR;
 20391d0:	00bfffc4 	movi	r2,-1
 20391d4:	00001e06 	br	2039250 <alt_tse_sys_enable_mdio_sharing+0x150>
				}
				
				tse_mac_device[j].tse_mdio_shared = 1;
 20391d8:	00c08174 	movhi	r3,517
 20391dc:	18cf7e04 	addi	r3,r3,15864
 20391e0:	e0bffc17 	ldw	r2,-16(fp)
 20391e4:	10801224 	muli	r2,r2,72
 20391e8:	1885883a 	add	r2,r3,r2
 20391ec:	10800304 	addi	r2,r2,12
 20391f0:	00c00044 	movi	r3,1
 20391f4:	10c00045 	stb	r3,1(r2)
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
 20391f8:	00c08174 	movhi	r3,517
 20391fc:	18cf7e04 	addi	r3,r3,15864
 2039200:	e0bffc17 	ldw	r2,-16(fp)
 2039204:	10801224 	muli	r2,r2,72
 2039208:	1885883a 	add	r2,r3,r2
 203920c:	10800304 	addi	r2,r2,12
 2039210:	e0ffff03 	ldbu	r3,-4(fp)
 2039214:	10c00085 	stb	r3,2(r2)
			tse_dprintf(2, "ERROR   : MAC system structure == NULL\n");
			tse_dprintf(2, "ERROR   : Please pass in correct pointer to alt_tse_sys_enable_mdio_sharing()\n");
			return ALTERA_TSE_SYSTEM_DEF_ERROR;
		}
		
		for(j = 0; j < max_mac_system; j++) {
 2039218:	e0bffc17 	ldw	r2,-16(fp)
 203921c:	10800044 	addi	r2,r2,1
 2039220:	e0bffc15 	stw	r2,-16(fp)
 2039224:	d0a04f03 	ldbu	r2,-32452(gp)
 2039228:	10803fcc 	andi	r2,r2,255
 203922c:	e0fffc17 	ldw	r3,-16(fp)
 2039230:	18bfcf16 	blt	r3,r2,2039170 <alt_tse_sys_enable_mdio_sharing+0x70>
	alt_32 i;
	alt_32 j;
	
	alt_tse_system_mac *psys_mac;
	
	for(i = 0; i < number_of_mac; i++) {
 2039234:	e0bffb17 	ldw	r2,-20(fp)
 2039238:	10800044 	addi	r2,r2,1
 203923c:	e0bffb15 	stw	r2,-20(fp)
 2039240:	e0bfff03 	ldbu	r2,-4(fp)
 2039244:	e0fffb17 	ldw	r3,-20(fp)
 2039248:	18bfb616 	blt	r3,r2,2039124 <alt_tse_sys_enable_mdio_sharing+0x24>
				tse_mac_device[j].tse_number_of_mac_mdio_shared = number_of_mac;
			}
		}	
	}
	
	return SUCCESS;
 203924c:	0005883a 	mov	r2,zero
}
 2039250:	e037883a 	mov	sp,fp
 2039254:	dfc00117 	ldw	ra,4(sp)
 2039258:	df000017 	ldw	fp,0(sp)
 203925c:	dec00204 	addi	sp,sp,8
 2039260:	f800283a 	ret

02039264 <alt_tse_mac_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Public
 * @param pmac          Pointer to the TSE MAC Control Interface Base address
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_mac_get_common_speed(np_tse_mac *pmac) {
 2039264:	defffc04 	addi	sp,sp,-16
 2039268:	dfc00315 	stw	ra,12(sp)
 203926c:	df000215 	stw	fp,8(sp)
 2039270:	df000204 	addi	fp,sp,8
 2039274:	e13fff15 	stw	r4,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 2039278:	e13fff17 	ldw	r4,-4(fp)
 203927c:	203944c0 	call	203944c <alt_tse_get_mac_info>
 2039280:	10800317 	ldw	r2,12(r2)
 2039284:	e0bffe15 	stw	r2,-8(fp)
    return alt_tse_phy_get_common_speed(pmac_group);
 2039288:	e13ffe17 	ldw	r4,-8(fp)
 203928c:	203c5e40 	call	203c5e4 <alt_tse_phy_get_common_speed>
}
 2039290:	e037883a 	mov	sp,fp
 2039294:	dfc00117 	ldw	ra,4(sp)
 2039298:	df000017 	ldw	fp,0(sp)
 203929c:	dec00204 	addi	sp,sp,8
 20392a0:	f800283a 	ret

020392a4 <alt_tse_mac_set_common_speed>:
 * @API Type:               Public
 * @param pmac              Pointer to the TSE MAC Control Interface Base address
 *        common_speed      common speed supported by all PHYs
 * @return                  common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_mac_set_common_speed(np_tse_mac *pmac, alt_32 common_speed) {
 20392a4:	defffb04 	addi	sp,sp,-20
 20392a8:	dfc00415 	stw	ra,16(sp)
 20392ac:	df000315 	stw	fp,12(sp)
 20392b0:	df000304 	addi	fp,sp,12
 20392b4:	e13ffe15 	stw	r4,-8(fp)
 20392b8:	e17fff15 	stw	r5,-4(fp)
    alt_tse_mac_group *pmac_group = alt_tse_get_mac_info(pmac)->pmac_group;
 20392bc:	e13ffe17 	ldw	r4,-8(fp)
 20392c0:	203944c0 	call	203944c <alt_tse_get_mac_info>
 20392c4:	10800317 	ldw	r2,12(r2)
 20392c8:	e0bffd15 	stw	r2,-12(fp)
    return alt_tse_phy_set_common_speed(pmac_group, common_speed);
 20392cc:	e13ffd17 	ldw	r4,-12(fp)
 20392d0:	e17fff17 	ldw	r5,-4(fp)
 20392d4:	203c90c0 	call	203c90c <alt_tse_phy_set_common_speed>
}
 20392d8:	e037883a 	mov	sp,fp
 20392dc:	dfc00117 	ldw	ra,4(sp)
 20392e0:	df000017 	ldw	fp,0(sp)
 20392e4:	dec00204 	addi	sp,sp,8
 20392e8:	f800283a 	ret

020392ec <alt_tse_get_system_index>:
/* @Function Description: Get the index of alt_tse_system_info structure in tse_mac_device[]
 * @API Type:        Internal
 * @param psys_info  Pointer to the alt_tse_system_info structure
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
 20392ec:	defffd04 	addi	sp,sp,-12
 20392f0:	df000215 	stw	fp,8(sp)
 20392f4:	df000204 	addi	fp,sp,8
 20392f8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 20392fc:	e03ffe15 	stw	zero,-8(fp)
 2039300:	00000c06 	br	2039334 <alt_tse_get_system_index+0x48>
        if(psys_info == &tse_mac_device[i]) {
 2039304:	e0bffe17 	ldw	r2,-8(fp)
 2039308:	10c01224 	muli	r3,r2,72
 203930c:	00808174 	movhi	r2,517
 2039310:	108f7e04 	addi	r2,r2,15864
 2039314:	1887883a 	add	r3,r3,r2
 2039318:	e0bfff17 	ldw	r2,-4(fp)
 203931c:	1880021e 	bne	r3,r2,2039328 <alt_tse_get_system_index+0x3c>
            return i;
 2039320:	e0bffe17 	ldw	r2,-8(fp)
 2039324:	00000806 	br	2039348 <alt_tse_get_system_index+0x5c>
 * @return           Index of alt_tse_system_info structure in tse_mac_device[]
 */
alt_32 alt_tse_get_system_index(alt_tse_system_info *psys_info) {
	alt_32 i;
    
    for(i = 0; i < max_mac_system; i++) {
 2039328:	e0bffe17 	ldw	r2,-8(fp)
 203932c:	10800044 	addi	r2,r2,1
 2039330:	e0bffe15 	stw	r2,-8(fp)
 2039334:	d0a04f03 	ldbu	r2,-32452(gp)
 2039338:	10803fcc 	andi	r2,r2,255
 203933c:	e0fffe17 	ldw	r3,-8(fp)
 2039340:	18bff016 	blt	r3,r2,2039304 <alt_tse_get_system_index+0x18>
        if(psys_info == &tse_mac_device[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 2039344:	00bfffc4 	movi	r2,-1
}
 2039348:	e037883a 	mov	sp,fp
 203934c:	df000017 	ldw	fp,0(sp)
 2039350:	dec00104 	addi	sp,sp,4
 2039354:	f800283a 	ret

02039358 <alt_tse_get_mac_group_index>:
/* @Function Description: Get the index of alt_tse_mac_group structure in pmac_groups[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_group structure
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
 2039358:	defffd04 	addi	sp,sp,-12
 203935c:	df000215 	stw	fp,8(sp)
 2039360:	df000204 	addi	fp,sp,8
 2039364:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 2039368:	e03ffe15 	stw	zero,-8(fp)
 203936c:	00000e06 	br	20393a8 <alt_tse_get_mac_group_index+0x50>
        if(pmac_group == pmac_groups[i]) {
 2039370:	00c09934 	movhi	r3,612
 2039374:	18f76d04 	addi	r3,r3,-8780
 2039378:	e0bffe17 	ldw	r2,-8(fp)
 203937c:	1085883a 	add	r2,r2,r2
 2039380:	1085883a 	add	r2,r2,r2
 2039384:	1885883a 	add	r2,r3,r2
 2039388:	10c00017 	ldw	r3,0(r2)
 203938c:	e0bfff17 	ldw	r2,-4(fp)
 2039390:	1880021e 	bne	r3,r2,203939c <alt_tse_get_mac_group_index+0x44>
            return i;
 2039394:	e0bffe17 	ldw	r2,-8(fp)
 2039398:	00000806 	br	20393bc <alt_tse_get_mac_group_index+0x64>
 * @return            Index of alt_tse_mac_group structure in pmac_groups[]
 */
alt_32 alt_tse_get_mac_group_index(alt_tse_mac_group *pmac_group) {
	alt_32 i;
    
    for(i = 0; i < mac_group_count; i++) {
 203939c:	e0bffe17 	ldw	r2,-8(fp)
 20393a0:	10800044 	addi	r2,r2,1
 20393a4:	e0bffe15 	stw	r2,-8(fp)
 20393a8:	d0a0af43 	ldbu	r2,-32067(gp)
 20393ac:	10803fcc 	andi	r2,r2,255
 20393b0:	e0fffe17 	ldw	r3,-8(fp)
 20393b4:	18bfee16 	blt	r3,r2,2039370 <alt_tse_get_mac_group_index+0x18>
        if(pmac_group == pmac_groups[i]) {
            return i;
        }
    }
    return ALTERA_TSE_NO_INDEX_FOUND;
 20393b8:	00bfffc4 	movi	r2,-1
}
 20393bc:	e037883a 	mov	sp,fp
 20393c0:	df000017 	ldw	fp,0(sp)
 20393c4:	dec00104 	addi	sp,sp,4
 20393c8:	f800283a 	ret

020393cc <alt_tse_get_mac_info_index>:
/* @Function Description: Get the index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac_group  Pointer to the alt_tse_mac_info structure
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
 20393cc:	defffd04 	addi	sp,sp,-12
 20393d0:	df000215 	stw	fp,8(sp)
 20393d4:	df000204 	addi	fp,sp,8
 20393d8:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 20393dc:	e03ffe15 	stw	zero,-8(fp)
 20393e0:	00000f06 	br	2039420 <alt_tse_get_mac_info_index+0x54>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
 20393e4:	e0bfff17 	ldw	r2,-4(fp)
 20393e8:	10c00317 	ldw	r3,12(r2)
 20393ec:	e0bffe17 	ldw	r2,-8(fp)
 20393f0:	10800044 	addi	r2,r2,1
 20393f4:	1085883a 	add	r2,r2,r2
 20393f8:	1085883a 	add	r2,r2,r2
 20393fc:	1885883a 	add	r2,r3,r2
 2039400:	10c00017 	ldw	r3,0(r2)
 2039404:	e0bfff17 	ldw	r2,-4(fp)
 2039408:	1880021e 	bne	r3,r2,2039414 <alt_tse_get_mac_info_index+0x48>
            return i;
 203940c:	e0bffe17 	ldw	r2,-8(fp)
 2039410:	00000a06 	br	203943c <alt_tse_get_mac_info_index+0x70>
 * @return            Index of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_32 alt_tse_get_mac_info_index(alt_tse_mac_info *pmac_info) {
	alt_32 i;
    
    for(i = 0; i < pmac_info->pmac_group->channel; i++) {
 2039414:	e0bffe17 	ldw	r2,-8(fp)
 2039418:	10800044 	addi	r2,r2,1
 203941c:	e0bffe15 	stw	r2,-8(fp)
 2039420:	e0bfff17 	ldw	r2,-4(fp)
 2039424:	10800317 	ldw	r2,12(r2)
 2039428:	10800003 	ldbu	r2,0(r2)
 203942c:	10803fcc 	andi	r2,r2,255
 2039430:	e0fffe17 	ldw	r3,-8(fp)
 2039434:	18bfeb16 	blt	r3,r2,20393e4 <alt_tse_get_mac_info_index+0x18>
        if(pmac_info == pmac_info->pmac_group->pmac_info[i]) {
            return i;
        }
    }
    
    return ALTERA_TSE_NO_INDEX_FOUND;
 2039438:	00bfffc4 	movi	r2,-1
}
 203943c:	e037883a 	mov	sp,fp
 2039440:	df000017 	ldw	fp,0(sp)
 2039444:	dec00104 	addi	sp,sp,4
 2039448:	f800283a 	ret

0203944c <alt_tse_get_mac_info>:
/* @Function Description: Get the pointer of alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 * @API Type:         Internal
 * @param pmac        Pointer to the TSE MAC Control Interface Base address
 * @return            Pointer to alt_tse_mac_info structure in pmac_groups[]->pmac_info[]
 */
alt_tse_mac_info *alt_tse_get_mac_info(np_tse_mac *pmac) {
 203944c:	defffa04 	addi	sp,sp,-24
 2039450:	df000515 	stw	fp,20(sp)
 2039454:	df000504 	addi	fp,sp,20
 2039458:	e13fff15 	stw	r4,-4(fp)
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
 203945c:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 2039460:	e03ffe15 	stw	zero,-8(fp)
    
    for(i = 0; i < mac_group_count; i++) {
 2039464:	e03ffb15 	stw	zero,-20(fp)
 2039468:	00002506 	br	2039500 <alt_tse_get_mac_info+0xb4>
        pmac_group = pmac_groups[i];
 203946c:	00c09934 	movhi	r3,612
 2039470:	18f76d04 	addi	r3,r3,-8780
 2039474:	e0bffb17 	ldw	r2,-20(fp)
 2039478:	1085883a 	add	r2,r2,r2
 203947c:	1085883a 	add	r2,r2,r2
 2039480:	1885883a 	add	r2,r3,r2
 2039484:	10800017 	ldw	r2,0(r2)
 2039488:	e0bffd15 	stw	r2,-12(fp)
        for(j = 0; j < pmac_group->channel; j++) {
 203948c:	e03ffc15 	stw	zero,-16(fp)
 2039490:	00001306 	br	20394e0 <alt_tse_get_mac_info+0x94>
            pmac_info = pmac_group->pmac_info[j];
 2039494:	e0fffd17 	ldw	r3,-12(fp)
 2039498:	e0bffc17 	ldw	r2,-16(fp)
 203949c:	10800044 	addi	r2,r2,1
 20394a0:	1085883a 	add	r2,r2,r2
 20394a4:	1085883a 	add	r2,r2,r2
 20394a8:	1885883a 	add	r2,r3,r2
 20394ac:	10800017 	ldw	r2,0(r2)
 20394b0:	e0bffe15 	stw	r2,-8(fp)
            if(((np_tse_mac *) pmac_info->psys_info->tse_mac_base) == pmac) {
 20394b4:	e0bffe17 	ldw	r2,-8(fp)
 20394b8:	10800217 	ldw	r2,8(r2)
 20394bc:	10800017 	ldw	r2,0(r2)
 20394c0:	1007883a 	mov	r3,r2
 20394c4:	e0bfff17 	ldw	r2,-4(fp)
 20394c8:	1880021e 	bne	r3,r2,20394d4 <alt_tse_get_mac_info+0x88>
                return pmac_info;
 20394cc:	e0bffe17 	ldw	r2,-8(fp)
 20394d0:	00001006 	br	2039514 <alt_tse_get_mac_info+0xc8>
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
        pmac_group = pmac_groups[i];
        for(j = 0; j < pmac_group->channel; j++) {
 20394d4:	e0bffc17 	ldw	r2,-16(fp)
 20394d8:	10800044 	addi	r2,r2,1
 20394dc:	e0bffc15 	stw	r2,-16(fp)
 20394e0:	e0bffd17 	ldw	r2,-12(fp)
 20394e4:	10800003 	ldbu	r2,0(r2)
 20394e8:	10803fcc 	andi	r2,r2,255
 20394ec:	e0fffc17 	ldw	r3,-16(fp)
 20394f0:	18bfe816 	blt	r3,r2,2039494 <alt_tse_get_mac_info+0x48>
	alt_32 i;
	alt_32 j;
    alt_tse_mac_group *pmac_group = 0;
    alt_tse_mac_info *pmac_info = 0;
    
    for(i = 0; i < mac_group_count; i++) {
 20394f4:	e0bffb17 	ldw	r2,-20(fp)
 20394f8:	10800044 	addi	r2,r2,1
 20394fc:	e0bffb15 	stw	r2,-20(fp)
 2039500:	d0a0af43 	ldbu	r2,-32067(gp)
 2039504:	10803fcc 	andi	r2,r2,255
 2039508:	e0fffb17 	ldw	r3,-20(fp)
 203950c:	18bfd716 	blt	r3,r2,203946c <alt_tse_get_mac_info+0x20>
                return pmac_info;
            }
        }        
    }
    
    return 0;
 2039510:	0005883a 	mov	r2,zero
}
 2039514:	e037883a 	mov	sp,fp
 2039518:	df000017 	ldw	fp,0(sp)
 203951c:	dec00104 	addi	sp,sp,4
 2039520:	f800283a 	ret

02039524 <alt_tse_mac_set_speed>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param speed 2 = 1000 Mbps, 1 = 100 Mbps, 0 = 10 Mbps
 * @return ENP_PARAM if invalid speed specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_speed(np_tse_mac *pmac, alt_u8 speed)
{
 2039524:	defffc04 	addi	sp,sp,-16
 2039528:	df000315 	stw	fp,12(sp)
 203952c:	df000304 	addi	fp,sp,12
 2039530:	e13ffe15 	stw	r4,-8(fp)
 2039534:	2805883a 	mov	r2,r5
 2039538:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 203953c:	e0bffe17 	ldw	r2,-8(fp)
 2039540:	10800204 	addi	r2,r2,8
 2039544:	10800037 	ldwio	r2,0(r2)
 2039548:	e0bffd15 	stw	r2,-12(fp)
  
  /* 1000 Mbps */
  if(speed == TSE_PHY_SPEED_1000) {
 203954c:	e0bfff03 	ldbu	r2,-4(fp)
 2039550:	10800098 	cmpnei	r2,r2,2
 2039554:	1000091e 	bne	r2,zero,203957c <alt_tse_mac_set_speed+0x58>
    helpvar |= ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2039558:	e0bffd17 	ldw	r2,-12(fp)
 203955c:	10800214 	ori	r2,r2,8
 2039560:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2039564:	e0fffd17 	ldw	r3,-12(fp)
 2039568:	00bf8034 	movhi	r2,65024
 203956c:	10bfffc4 	addi	r2,r2,-1
 2039570:	1884703a 	and	r2,r3,r2
 2039574:	e0bffd15 	stw	r2,-12(fp)
 2039578:	00001906 	br	20395e0 <alt_tse_mac_set_speed+0xbc>
  }
  /* 100 Mbps */
  else if(speed == TSE_PHY_SPEED_100) {
 203957c:	e0bfff03 	ldbu	r2,-4(fp)
 2039580:	10800058 	cmpnei	r2,r2,1
 2039584:	10000a1e 	bne	r2,zero,20395b0 <alt_tse_mac_set_speed+0x8c>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 2039588:	e0fffd17 	ldw	r3,-12(fp)
 203958c:	00bffdc4 	movi	r2,-9
 2039590:	1884703a 	and	r2,r3,r2
 2039594:	e0bffd15 	stw	r2,-12(fp)
	helpvar &= ~ALTERA_TSEMAC_CMD_ENA_10_MSK;
 2039598:	e0fffd17 	ldw	r3,-12(fp)
 203959c:	00bf8034 	movhi	r2,65024
 20395a0:	10bfffc4 	addi	r2,r2,-1
 20395a4:	1884703a 	and	r2,r3,r2
 20395a8:	e0bffd15 	stw	r2,-12(fp)
 20395ac:	00000c06 	br	20395e0 <alt_tse_mac_set_speed+0xbc>
  }
  /* 10 Mbps */
  else if(speed == TSE_PHY_SPEED_10) {
 20395b0:	e0bfff03 	ldbu	r2,-4(fp)
 20395b4:	1000081e 	bne	r2,zero,20395d8 <alt_tse_mac_set_speed+0xb4>
    helpvar &= ~ALTERA_TSEMAC_CMD_ETH_SPEED_MSK;
 20395b8:	e0fffd17 	ldw	r3,-12(fp)
 20395bc:	00bffdc4 	movi	r2,-9
 20395c0:	1884703a 	and	r2,r3,r2
 20395c4:	e0bffd15 	stw	r2,-12(fp)
	helpvar |= ALTERA_TSEMAC_CMD_ENA_10_MSK;
 20395c8:	e0bffd17 	ldw	r2,-12(fp)
 20395cc:	10808034 	orhi	r2,r2,512
 20395d0:	e0bffd15 	stw	r2,-12(fp)
 20395d4:	00000206 	br	20395e0 <alt_tse_mac_set_speed+0xbc>
  }  
  else {
    return ENP_PARAM;
 20395d8:	00bffd84 	movi	r2,-10
 20395dc:	00000506 	br	20395f4 <alt_tse_mac_set_speed+0xd0>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 20395e0:	e0bffe17 	ldw	r2,-8(fp)
 20395e4:	10800204 	addi	r2,r2,8
 20395e8:	e0fffd17 	ldw	r3,-12(fp)
 20395ec:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 20395f0:	0005883a 	mov	r2,zero
}
 20395f4:	e037883a 	mov	sp,fp
 20395f8:	df000017 	ldw	fp,0(sp)
 20395fc:	dec00104 	addi	sp,sp,4
 2039600:	f800283a 	ret

02039604 <alt_tse_mac_set_duplex>:
 * @param pmac  Pointer to the TSE MAC Control Interface Base address
 * @param duplex 1 = Full Duplex, 0 = Half Duplex
 * @return ENP_PARAM if invalid duplex specified, else return SUCCESS
 */
alt_32 alt_tse_mac_set_duplex(np_tse_mac *pmac, alt_u8 duplex)
{
 2039604:	defffc04 	addi	sp,sp,-16
 2039608:	df000315 	stw	fp,12(sp)
 203960c:	df000304 	addi	fp,sp,12
 2039610:	e13ffe15 	stw	r4,-8(fp)
 2039614:	2805883a 	mov	r2,r5
 2039618:	e0bfff05 	stb	r2,-4(fp)
  alt_32 helpvar;
  
  helpvar = IORD_ALTERA_TSEMAC_CMD_CONFIG(pmac);
 203961c:	e0bffe17 	ldw	r2,-8(fp)
 2039620:	10800204 	addi	r2,r2,8
 2039624:	10800037 	ldwio	r2,0(r2)
 2039628:	e0bffd15 	stw	r2,-12(fp)
  
  /* Half Duplex */
  if(duplex == TSE_PHY_DUPLEX_HALF) {
 203962c:	e0bfff03 	ldbu	r2,-4(fp)
 2039630:	1000041e 	bne	r2,zero,2039644 <alt_tse_mac_set_duplex+0x40>
    helpvar |= ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 2039634:	e0bffd17 	ldw	r2,-12(fp)
 2039638:	10810014 	ori	r2,r2,1024
 203963c:	e0bffd15 	stw	r2,-12(fp)
 2039640:	00000a06 	br	203966c <alt_tse_mac_set_duplex+0x68>
  } 
  /* Full Duplex */
  else if(duplex == TSE_PHY_DUPLEX_FULL) {
 2039644:	e0bfff03 	ldbu	r2,-4(fp)
 2039648:	10800058 	cmpnei	r2,r2,1
 203964c:	1000051e 	bne	r2,zero,2039664 <alt_tse_mac_set_duplex+0x60>
    helpvar &= ~ALTERA_TSEMAC_CMD_HD_ENA_MSK;
 2039650:	e0fffd17 	ldw	r3,-12(fp)
 2039654:	00beffc4 	movi	r2,-1025
 2039658:	1884703a 	and	r2,r3,r2
 203965c:	e0bffd15 	stw	r2,-12(fp)
 2039660:	00000206 	br	203966c <alt_tse_mac_set_duplex+0x68>
  }
  else {
    return ENP_PARAM;
 2039664:	00bffd84 	movi	r2,-10
 2039668:	00000506 	br	2039680 <alt_tse_mac_set_duplex+0x7c>
  }
  
  IOWR_ALTERA_TSEMAC_CMD_CONFIG(pmac, helpvar);
 203966c:	e0bffe17 	ldw	r2,-8(fp)
 2039670:	10800204 	addi	r2,r2,8
 2039674:	e0fffd17 	ldw	r3,-12(fp)
 2039678:	10c00035 	stwio	r3,0(r2)
  return SUCCESS;
 203967c:	0005883a 	mov	r2,zero

}
 2039680:	e037883a 	mov	sp,fp
 2039684:	df000017 	ldw	fp,0(sp)
 2039688:	dec00104 	addi	sp,sp,4
 203968c:	f800283a 	ret

02039690 <getPHYSpeed>:
  	(((speed == TSE_PHY_SPEED_1000) ? 1 : 0) << 1) |   \
	(((speed == TSE_PHY_SPEED_100) ? 1 : 0) << 2) |     \
	(((speed == TSE_PHY_SPEED_10) ? 1 : 0) << 3) |      \
	((speed == TSE_PHY_SPEED_INVALID) ? ALT_TSE_E_INVALID_SPEED : 0))
  
alt_32 getPHYSpeed(np_tse_mac *pmac) {
 2039690:	defff404 	addi	sp,sp,-48
 2039694:	dfc00b15 	stw	ra,44(sp)
 2039698:	df000a15 	stw	fp,40(sp)
 203969c:	df000a04 	addi	fp,sp,40
 20396a0:	e13fff15 	stw	r4,-4(fp)

	alt_u8 speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 20396a4:	00800044 	movi	r2,1
 20396a8:	e0bff705 	stb	r2,-36(fp)
	alt_u8 duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;     /* 1 = full ; 0 = half*/
 20396ac:	00800044 	movi	r2,1
 20396b0:	e0bff745 	stb	r2,-35(fp)
	alt_32 result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 20396b4:	e0bff743 	ldbu	r2,-35(fp)
 20396b8:	10c0004c 	andi	r3,r2,1
 20396bc:	e0bff703 	ldbu	r2,-36(fp)
 20396c0:	10800098 	cmpnei	r2,r2,2
 20396c4:	1000021e 	bne	r2,zero,20396d0 <getPHYSpeed+0x40>
 20396c8:	00800084 	movi	r2,2
 20396cc:	00000106 	br	20396d4 <getPHYSpeed+0x44>
 20396d0:	0005883a 	mov	r2,zero
 20396d4:	1886b03a 	or	r3,r3,r2
 20396d8:	e0bff703 	ldbu	r2,-36(fp)
 20396dc:	10800058 	cmpnei	r2,r2,1
 20396e0:	1000021e 	bne	r2,zero,20396ec <getPHYSpeed+0x5c>
 20396e4:	00800104 	movi	r2,4
 20396e8:	00000106 	br	20396f0 <getPHYSpeed+0x60>
 20396ec:	0005883a 	mov	r2,zero
 20396f0:	1886b03a 	or	r3,r3,r2
 20396f4:	e0bff703 	ldbu	r2,-36(fp)
 20396f8:	1000021e 	bne	r2,zero,2039704 <getPHYSpeed+0x74>
 20396fc:	00800204 	movi	r2,8
 2039700:	00000106 	br	2039708 <getPHYSpeed+0x78>
 2039704:	0005883a 	mov	r2,zero
 2039708:	1886b03a 	or	r3,r3,r2
 203970c:	e0bff703 	ldbu	r2,-36(fp)
 2039710:	108000d8 	cmpnei	r2,r2,3
 2039714:	1000021e 	bne	r2,zero,2039720 <getPHYSpeed+0x90>
 2039718:	00800074 	movhi	r2,1
 203971c:	00000106 	br	2039724 <getPHYSpeed+0x94>
 2039720:	0005883a 	mov	r2,zero
 2039724:	1884b03a 	or	r2,r3,r2
 2039728:	e0bff815 	stw	r2,-32(fp)
    
    alt_tse_phy_info *pphy = 0;
 203972c:	e03ff915 	stw	zero,-28(fp)
    alt_tse_mac_info *pmac_info = 0;
 2039730:	e03ffa15 	stw	zero,-24(fp)
    alt_tse_mac_group *pmac_group = 0;
 2039734:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_system_info *psys = 0;
 2039738:	e03ffc15 	stw	zero,-16(fp)
    
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 203973c:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = 0;
 2039740:	e03ffd45 	stb	zero,-11(fp)
    
    /* initialized PHYs only once */
    static alt_u8 is_init = 0;
    if(is_init == 0) {
 2039744:	d0a0af83 	ldbu	r2,-32066(gp)
 2039748:	10803fcc 	andi	r2,r2,255
 203974c:	1000031e 	bne	r2,zero,203975c <getPHYSpeed+0xcc>
        alt_tse_phy_init();
 2039750:	203b6640 	call	203b664 <alt_tse_phy_init>
        is_init = 1;
 2039754:	00800044 	movi	r2,1
 2039758:	d0a0af85 	stb	r2,-32066(gp)
    }
    
    /* Look for pmac_group and pmac_info structure based on pmac or iface */
    pmac_info = alt_tse_get_mac_info(pmac);
 203975c:	e13fff17 	ldw	r4,-4(fp)
 2039760:	203944c0 	call	203944c <alt_tse_get_mac_info>
 2039764:	e0bffa15 	stw	r2,-24(fp)
    
    if(pmac_info == 0) {
 2039768:	e0bffa17 	ldw	r2,-24(fp)
 203976c:	1000491e 	bne	r2,zero,2039894 <getPHYSpeed+0x204>
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2039770:	00800044 	movi	r2,1
 2039774:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2039778:	00800044 	movi	r2,1
 203977c:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PMAC_FOUND;
 2039780:	e0bff743 	ldbu	r2,-35(fp)
 2039784:	10c0004c 	andi	r3,r2,1
 2039788:	e0bff703 	ldbu	r2,-36(fp)
 203978c:	10800098 	cmpnei	r2,r2,2
 2039790:	1000021e 	bne	r2,zero,203979c <getPHYSpeed+0x10c>
 2039794:	00800084 	movi	r2,2
 2039798:	00000106 	br	20397a0 <getPHYSpeed+0x110>
 203979c:	0005883a 	mov	r2,zero
 20397a0:	1886b03a 	or	r3,r3,r2
 20397a4:	e0bff703 	ldbu	r2,-36(fp)
 20397a8:	10800058 	cmpnei	r2,r2,1
 20397ac:	1000021e 	bne	r2,zero,20397b8 <getPHYSpeed+0x128>
 20397b0:	00800104 	movi	r2,4
 20397b4:	00000106 	br	20397bc <getPHYSpeed+0x12c>
 20397b8:	0005883a 	mov	r2,zero
 20397bc:	1886b03a 	or	r3,r3,r2
 20397c0:	e0bff703 	ldbu	r2,-36(fp)
 20397c4:	1000021e 	bne	r2,zero,20397d0 <getPHYSpeed+0x140>
 20397c8:	00800204 	movi	r2,8
 20397cc:	00000106 	br	20397d4 <getPHYSpeed+0x144>
 20397d0:	0005883a 	mov	r2,zero
 20397d4:	1886b03a 	or	r3,r3,r2
 20397d8:	e0bff703 	ldbu	r2,-36(fp)
 20397dc:	108000d8 	cmpnei	r2,r2,3
 20397e0:	1000021e 	bne	r2,zero,20397ec <getPHYSpeed+0x15c>
 20397e4:	00800074 	movhi	r2,1
 20397e8:	00000106 	br	20397f0 <getPHYSpeed+0x160>
 20397ec:	0005883a 	mov	r2,zero
 20397f0:	1884b03a 	or	r2,r3,r2
 20397f4:	10802034 	orhi	r2,r2,128
 20397f8:	e0bff815 	stw	r2,-32(fp)
        tse_dprintf(2, "ERROR   : [getPHYSpeed] pmac not found from list of pmac_info[]! Speed = %s Mbps, Duplex = %s\n", speed == TSE_PHY_SPEED_1000 ? "1000" :
 20397fc:	e0bff703 	ldbu	r2,-36(fp)
 2039800:	108000a0 	cmpeqi	r2,r2,2
 2039804:	10000f1e 	bne	r2,zero,2039844 <getPHYSpeed+0x1b4>
 2039808:	e0bff703 	ldbu	r2,-36(fp)
 203980c:	10800060 	cmpeqi	r2,r2,1
 2039810:	1000081e 	bne	r2,zero,2039834 <getPHYSpeed+0x1a4>
 2039814:	e0bff703 	ldbu	r2,-36(fp)
 2039818:	1000031e 	bne	r2,zero,2039828 <getPHYSpeed+0x198>
 203981c:	00808174 	movhi	r2,517
 2039820:	10beab04 	addi	r2,r2,-1364
 2039824:	00000206 	br	2039830 <getPHYSpeed+0x1a0>
 2039828:	00808174 	movhi	r2,517
 203982c:	10beac04 	addi	r2,r2,-1360
 2039830:	00000206 	br	203983c <getPHYSpeed+0x1ac>
 2039834:	00808174 	movhi	r2,517
 2039838:	10beae04 	addi	r2,r2,-1352
 203983c:	1007883a 	mov	r3,r2
 2039840:	00000206 	br	203984c <getPHYSpeed+0x1bc>
 2039844:	00c08174 	movhi	r3,517
 2039848:	18feaf04 	addi	r3,r3,-1348
 203984c:	e0bff743 	ldbu	r2,-35(fp)
 2039850:	10800058 	cmpnei	r2,r2,1
 2039854:	1000031e 	bne	r2,zero,2039864 <getPHYSpeed+0x1d4>
 2039858:	00808174 	movhi	r2,517
 203985c:	10beb104 	addi	r2,r2,-1340
 2039860:	00000206 	br	203986c <getPHYSpeed+0x1dc>
 2039864:	00808174 	movhi	r2,517
 2039868:	10beb304 	addi	r2,r2,-1332
 203986c:	01008174 	movhi	r4,517
 2039870:	213eb504 	addi	r4,r4,-1324
 2039874:	180b883a 	mov	r5,r3
 2039878:	100d883a 	mov	r6,r2
 203987c:	2006a240 	call	2006a24 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        tse_dprintf(2, "ERROR   : [getPHYSpeed] Please define tse_mac_device[] correctly\n");
 2039880:	01008174 	movhi	r4,517
 2039884:	213ecd04 	addi	r4,r4,-1228
 2039888:	2006cb40 	call	2006cb4 <puts>
        return result;
 203988c:	e0bff817 	ldw	r2,-32(fp)
 2039890:	00021706 	br	203a0f0 <getPHYSpeed+0xa60>
    }
    
    pphy = pmac_info->pphy_info;
 2039894:	e0bffa17 	ldw	r2,-24(fp)
 2039898:	10800117 	ldw	r2,4(r2)
 203989c:	e0bff915 	stw	r2,-28(fp)
    pmac_group = pmac_info->pmac_group;
 20398a0:	e0bffa17 	ldw	r2,-24(fp)
 20398a4:	10800317 	ldw	r2,12(r2)
 20398a8:	e0bffb15 	stw	r2,-20(fp)
    psys = pmac_info->psys_info;
 20398ac:	e0bffa17 	ldw	r2,-24(fp)
 20398b0:	10800217 	ldw	r2,8(r2)
 20398b4:	e0bffc15 	stw	r2,-16(fp)
    
    mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 20398b8:	e13ffa17 	ldw	r4,-24(fp)
 20398bc:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 20398c0:	e0bffd05 	stb	r2,-12(fp)
    mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 20398c4:	e13ffb17 	ldw	r4,-20(fp)
 20398c8:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 20398cc:	e0bffd45 	stb	r2,-11(fp)
         
    /* MDIO is not used */
    if (pmac_group->pmac_info[0]->psys_info->tse_use_mdio == 0)
 20398d0:	e0bffb17 	ldw	r2,-20(fp)
 20398d4:	10800117 	ldw	r2,4(r2)
 20398d8:	10800217 	ldw	r2,8(r2)
 20398dc:	10800203 	ldbu	r2,8(r2)
 20398e0:	10803fcc 	andi	r2,r2,255
 20398e4:	10005a1e 	bne	r2,zero,2039a50 <getPHYSpeed+0x3c0>
    {
        speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 20398e8:	00800044 	movi	r2,1
 20398ec:	e0bff705 	stb	r2,-36(fp)
        duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 20398f0:	00800044 	movi	r2,1
 20398f4:	e0bff745 	stb	r2,-35(fp)
        result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_MDIO;
 20398f8:	e0bff743 	ldbu	r2,-35(fp)
 20398fc:	10c0004c 	andi	r3,r2,1
 2039900:	e0bff703 	ldbu	r2,-36(fp)
 2039904:	10800098 	cmpnei	r2,r2,2
 2039908:	1000021e 	bne	r2,zero,2039914 <getPHYSpeed+0x284>
 203990c:	00800084 	movi	r2,2
 2039910:	00000106 	br	2039918 <getPHYSpeed+0x288>
 2039914:	0005883a 	mov	r2,zero
 2039918:	1886b03a 	or	r3,r3,r2
 203991c:	e0bff703 	ldbu	r2,-36(fp)
 2039920:	10800058 	cmpnei	r2,r2,1
 2039924:	1000021e 	bne	r2,zero,2039930 <getPHYSpeed+0x2a0>
 2039928:	00800104 	movi	r2,4
 203992c:	00000106 	br	2039934 <getPHYSpeed+0x2a4>
 2039930:	0005883a 	mov	r2,zero
 2039934:	1886b03a 	or	r3,r3,r2
 2039938:	e0bff703 	ldbu	r2,-36(fp)
 203993c:	1000021e 	bne	r2,zero,2039948 <getPHYSpeed+0x2b8>
 2039940:	00800204 	movi	r2,8
 2039944:	00000106 	br	203994c <getPHYSpeed+0x2bc>
 2039948:	0005883a 	mov	r2,zero
 203994c:	1886b03a 	or	r3,r3,r2
 2039950:	e0bff703 	ldbu	r2,-36(fp)
 2039954:	108000d8 	cmpnei	r2,r2,3
 2039958:	1000021e 	bne	r2,zero,2039964 <getPHYSpeed+0x2d4>
 203995c:	00800074 	movhi	r2,1
 2039960:	00000106 	br	2039968 <getPHYSpeed+0x2d8>
 2039964:	0005883a 	mov	r2,zero
 2039968:	1884b03a 	or	r2,r3,r2
 203996c:	10801034 	orhi	r2,r2,64
 2039970:	e0bff815 	stw	r2,-32(fp)
        usleep(ALTERA_NOMDIO_TIMEOUT_THRESHOLD);
 2039974:	010003f4 	movhi	r4,15
 2039978:	21109004 	addi	r4,r4,16960
 203997c:	204a8180 	call	204a818 <usleep>
        if(psys->tse_phy_cfg) {
 2039980:	e0bffc17 	ldw	r2,-16(fp)
 2039984:	10801117 	ldw	r2,68(r2)
 2039988:	10000d26 	beq	r2,zero,20399c0 <getPHYSpeed+0x330>
        	tse_dprintf(4, "WARNING : PHY[%d.%d] - MDIO not enabled! Running user configuration...\n", mac_group_index, mac_info_index);
 203998c:	e0fffd47 	ldb	r3,-11(fp)
 2039990:	e0bffd07 	ldb	r2,-12(fp)
 2039994:	01008174 	movhi	r4,517
 2039998:	213ede04 	addi	r4,r4,-1160
 203999c:	180b883a 	mov	r5,r3
 20399a0:	100d883a 	mov	r6,r2
 20399a4:	2006a240 	call	2006a24 <printf>
        	result = psys->tse_phy_cfg(pmac);
 20399a8:	e0bffc17 	ldw	r2,-16(fp)
 20399ac:	10801117 	ldw	r2,68(r2)
 20399b0:	e13fff17 	ldw	r4,-4(fp)
 20399b4:	103ee83a 	callr	r2
 20399b8:	e0bff815 	stw	r2,-32(fp)
 20399bc:	00002206 	br	2039a48 <getPHYSpeed+0x3b8>
        }
        else {
        	tse_dprintf(4, "WARNING : MAC Group[%d] - MDIO not enabled! Speed = %s, Duplex = %s\n", mac_group_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 20399c0:	e17ffd47 	ldb	r5,-11(fp)
 20399c4:	e0bff703 	ldbu	r2,-36(fp)
 20399c8:	108000a0 	cmpeqi	r2,r2,2
 20399cc:	10000f1e 	bne	r2,zero,2039a0c <getPHYSpeed+0x37c>
 20399d0:	e0bff703 	ldbu	r2,-36(fp)
 20399d4:	10800060 	cmpeqi	r2,r2,1
 20399d8:	1000081e 	bne	r2,zero,20399fc <getPHYSpeed+0x36c>
 20399dc:	e0bff703 	ldbu	r2,-36(fp)
 20399e0:	1000031e 	bne	r2,zero,20399f0 <getPHYSpeed+0x360>
 20399e4:	00808174 	movhi	r2,517
 20399e8:	10beab04 	addi	r2,r2,-1364
 20399ec:	00000206 	br	20399f8 <getPHYSpeed+0x368>
 20399f0:	00808174 	movhi	r2,517
 20399f4:	10beac04 	addi	r2,r2,-1360
 20399f8:	00000206 	br	2039a04 <getPHYSpeed+0x374>
 20399fc:	00808174 	movhi	r2,517
 2039a00:	10beae04 	addi	r2,r2,-1352
 2039a04:	1007883a 	mov	r3,r2
 2039a08:	00000206 	br	2039a14 <getPHYSpeed+0x384>
 2039a0c:	00c08174 	movhi	r3,517
 2039a10:	18feaf04 	addi	r3,r3,-1348
 2039a14:	e0bff743 	ldbu	r2,-35(fp)
 2039a18:	10800058 	cmpnei	r2,r2,1
 2039a1c:	1000031e 	bne	r2,zero,2039a2c <getPHYSpeed+0x39c>
 2039a20:	00808174 	movhi	r2,517
 2039a24:	10beb104 	addi	r2,r2,-1340
 2039a28:	00000206 	br	2039a34 <getPHYSpeed+0x3a4>
 2039a2c:	00808174 	movhi	r2,517
 2039a30:	10beb304 	addi	r2,r2,-1332
 2039a34:	01008174 	movhi	r4,517
 2039a38:	213ef004 	addi	r4,r4,-1088
 2039a3c:	180d883a 	mov	r6,r3
 2039a40:	100f883a 	mov	r7,r2
 2039a44:	2006a240 	call	2006a24 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
        }
        return result;
 2039a48:	e0bff817 	ldw	r2,-32(fp)
 2039a4c:	0001a806 	br	203a0f0 <getPHYSpeed+0xa60>

    /* Not running simulation */
    #ifndef ALT_SIM_OPTIMIZE
	
		/* These variables declaration are here to avoid "warning: unused variable" message when compile for simulation */
		np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 2039a50:	e0bffb17 	ldw	r2,-20(fp)
 2039a54:	10800117 	ldw	r2,4(r2)
 2039a58:	10800217 	ldw	r2,8(r2)
 2039a5c:	10800017 	ldw	r2,0(r2)
 2039a60:	e0bffe15 	stw	r2,-8(fp)
    
        /* if no PHY connected to the MAC */
        if(pphy == 0) {
 2039a64:	e0bff917 	ldw	r2,-28(fp)
 2039a68:	1000471e 	bne	r2,zero,2039b88 <getPHYSpeed+0x4f8>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2039a6c:	00800044 	movi	r2,1
 2039a70:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2039a74:	00800044 	movi	r2,1
 2039a78:	e0bff745 	stb	r2,-35(fp)
            result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY;
 2039a7c:	e0bff743 	ldbu	r2,-35(fp)
 2039a80:	10c0004c 	andi	r3,r2,1
 2039a84:	e0bff703 	ldbu	r2,-36(fp)
 2039a88:	10800098 	cmpnei	r2,r2,2
 2039a8c:	1000021e 	bne	r2,zero,2039a98 <getPHYSpeed+0x408>
 2039a90:	00800084 	movi	r2,2
 2039a94:	00000106 	br	2039a9c <getPHYSpeed+0x40c>
 2039a98:	0005883a 	mov	r2,zero
 2039a9c:	1886b03a 	or	r3,r3,r2
 2039aa0:	e0bff703 	ldbu	r2,-36(fp)
 2039aa4:	10800058 	cmpnei	r2,r2,1
 2039aa8:	1000021e 	bne	r2,zero,2039ab4 <getPHYSpeed+0x424>
 2039aac:	00800104 	movi	r2,4
 2039ab0:	00000106 	br	2039ab8 <getPHYSpeed+0x428>
 2039ab4:	0005883a 	mov	r2,zero
 2039ab8:	1886b03a 	or	r3,r3,r2
 2039abc:	e0bff703 	ldbu	r2,-36(fp)
 2039ac0:	1000021e 	bne	r2,zero,2039acc <getPHYSpeed+0x43c>
 2039ac4:	00800204 	movi	r2,8
 2039ac8:	00000106 	br	2039ad0 <getPHYSpeed+0x440>
 2039acc:	0005883a 	mov	r2,zero
 2039ad0:	1886b03a 	or	r3,r3,r2
 2039ad4:	e0bff703 	ldbu	r2,-36(fp)
 2039ad8:	108000d8 	cmpnei	r2,r2,3
 2039adc:	1000021e 	bne	r2,zero,2039ae8 <getPHYSpeed+0x458>
 2039ae0:	00800074 	movhi	r2,1
 2039ae4:	00000106 	br	2039aec <getPHYSpeed+0x45c>
 2039ae8:	0005883a 	mov	r2,zero
 2039aec:	1884b03a 	or	r2,r3,r2
 2039af0:	10800834 	orhi	r2,r2,32
 2039af4:	e0bff815 	stw	r2,-32(fp)
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - No PHY connected! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2039af8:	e17ffd47 	ldb	r5,-11(fp)
 2039afc:	e1bffd07 	ldb	r6,-12(fp)
 2039b00:	e0bff703 	ldbu	r2,-36(fp)
 2039b04:	108000a0 	cmpeqi	r2,r2,2
 2039b08:	10000e1e 	bne	r2,zero,2039b44 <getPHYSpeed+0x4b4>
 2039b0c:	e0bff703 	ldbu	r2,-36(fp)
 2039b10:	10800060 	cmpeqi	r2,r2,1
 2039b14:	1000081e 	bne	r2,zero,2039b38 <getPHYSpeed+0x4a8>
 2039b18:	e0bff703 	ldbu	r2,-36(fp)
 2039b1c:	1000031e 	bne	r2,zero,2039b2c <getPHYSpeed+0x49c>
 2039b20:	00808174 	movhi	r2,517
 2039b24:	10beab04 	addi	r2,r2,-1364
 2039b28:	00000206 	br	2039b34 <getPHYSpeed+0x4a4>
 2039b2c:	00808174 	movhi	r2,517
 2039b30:	10beac04 	addi	r2,r2,-1360
 2039b34:	00000206 	br	2039b40 <getPHYSpeed+0x4b0>
 2039b38:	00808174 	movhi	r2,517
 2039b3c:	10beae04 	addi	r2,r2,-1352
 2039b40:	00000206 	br	2039b4c <getPHYSpeed+0x4bc>
 2039b44:	00808174 	movhi	r2,517
 2039b48:	10beaf04 	addi	r2,r2,-1348
 2039b4c:	e0fff743 	ldbu	r3,-35(fp)
 2039b50:	18c00058 	cmpnei	r3,r3,1
 2039b54:	1800031e 	bne	r3,zero,2039b64 <getPHYSpeed+0x4d4>
 2039b58:	00c08174 	movhi	r3,517
 2039b5c:	18feb104 	addi	r3,r3,-1340
 2039b60:	00000206 	br	2039b6c <getPHYSpeed+0x4dc>
 2039b64:	00c08174 	movhi	r3,517
 2039b68:	18feb304 	addi	r3,r3,-1332
 2039b6c:	d8c00015 	stw	r3,0(sp)
 2039b70:	01008174 	movhi	r4,517
 2039b74:	213f0204 	addi	r4,r4,-1016
 2039b78:	100f883a 	mov	r7,r2
 2039b7c:	2006a240 	call	2006a24 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");
            return result;
 2039b80:	e0bff817 	ldw	r2,-32(fp)
 2039b84:	00015a06 	br	203a0f0 <getPHYSpeed+0xa60>
        }

		/* Small MAC */
		if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 2039b88:	e0bffa17 	ldw	r2,-24(fp)
 2039b8c:	10800003 	ldbu	r2,0(r2)
 2039b90:	10803fcc 	andi	r2,r2,255
 2039b94:	10800058 	cmpnei	r2,r2,1
 2039b98:	1000081e 	bne	r2,zero,2039bbc <getPHYSpeed+0x52c>
			alt_tse_phy_set_adv_1000(pphy, 0);
 2039b9c:	e13ff917 	ldw	r4,-28(fp)
 2039ba0:	000b883a 	mov	r5,zero
 2039ba4:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2039ba8:	e13ff917 	ldw	r4,-28(fp)
 2039bac:	01400134 	movhi	r5,4
 2039bb0:	29742404 	addi	r5,r5,-12144
 2039bb4:	203b77c0 	call	203b77c <alt_tse_phy_restart_an>
 2039bb8:	00000f06 	br	2039bf8 <getPHYSpeed+0x568>
		}
		else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 2039bbc:	e0bffa17 	ldw	r2,-24(fp)
 2039bc0:	10800003 	ldbu	r2,0(r2)
 2039bc4:	10803fcc 	andi	r2,r2,255
 2039bc8:	10800098 	cmpnei	r2,r2,2
 2039bcc:	10000a1e 	bne	r2,zero,2039bf8 <getPHYSpeed+0x568>
			alt_tse_phy_set_adv_100(pphy, 0);
 2039bd0:	e13ff917 	ldw	r4,-28(fp)
 2039bd4:	000b883a 	mov	r5,zero
 2039bd8:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
			alt_tse_phy_set_adv_10(pphy, 0);
 2039bdc:	e13ff917 	ldw	r4,-28(fp)
 2039be0:	000b883a 	mov	r5,zero
 2039be4:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
			alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 2039be8:	e13ff917 	ldw	r4,-28(fp)
 2039bec:	01400134 	movhi	r5,4
 2039bf0:	29742404 	addi	r5,r5,-12144
 2039bf4:	203b77c0 	call	203b77c <alt_tse_phy_restart_an>
		}
		
		/* check link connection for this PHY */
		if(alt_tse_phy_check_link(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD) == TSE_PHY_AN_NOT_COMPLETE) {
 2039bf8:	e13ff917 	ldw	r4,-28(fp)
 2039bfc:	01400134 	movhi	r5,4
 2039c00:	29742404 	addi	r5,r5,-12144
 2039c04:	203b9400 	call	203b940 <alt_tse_phy_check_link>
 2039c08:	10bfffd8 	cmpnei	r2,r2,-1
 2039c0c:	1000471e 	bne	r2,zero,2039d2c <getPHYSpeed+0x69c>
			speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2039c10:	00800044 	movi	r2,1
 2039c14:	e0bff705 	stb	r2,-36(fp)
			duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2039c18:	00800044 	movi	r2,1
 2039c1c:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_AN_NOT_COMPLETE;
 2039c20:	e0bff743 	ldbu	r2,-35(fp)
 2039c24:	10c0004c 	andi	r3,r2,1
 2039c28:	e0bff703 	ldbu	r2,-36(fp)
 2039c2c:	10800098 	cmpnei	r2,r2,2
 2039c30:	1000021e 	bne	r2,zero,2039c3c <getPHYSpeed+0x5ac>
 2039c34:	00800084 	movi	r2,2
 2039c38:	00000106 	br	2039c40 <getPHYSpeed+0x5b0>
 2039c3c:	0005883a 	mov	r2,zero
 2039c40:	1886b03a 	or	r3,r3,r2
 2039c44:	e0bff703 	ldbu	r2,-36(fp)
 2039c48:	10800058 	cmpnei	r2,r2,1
 2039c4c:	1000021e 	bne	r2,zero,2039c58 <getPHYSpeed+0x5c8>
 2039c50:	00800104 	movi	r2,4
 2039c54:	00000106 	br	2039c5c <getPHYSpeed+0x5cc>
 2039c58:	0005883a 	mov	r2,zero
 2039c5c:	1886b03a 	or	r3,r3,r2
 2039c60:	e0bff703 	ldbu	r2,-36(fp)
 2039c64:	1000021e 	bne	r2,zero,2039c70 <getPHYSpeed+0x5e0>
 2039c68:	00800204 	movi	r2,8
 2039c6c:	00000106 	br	2039c74 <getPHYSpeed+0x5e4>
 2039c70:	0005883a 	mov	r2,zero
 2039c74:	1886b03a 	or	r3,r3,r2
 2039c78:	e0bff703 	ldbu	r2,-36(fp)
 2039c7c:	108000d8 	cmpnei	r2,r2,3
 2039c80:	1000021e 	bne	r2,zero,2039c8c <getPHYSpeed+0x5fc>
 2039c84:	00800074 	movhi	r2,1
 2039c88:	00000106 	br	2039c90 <getPHYSpeed+0x600>
 2039c8c:	0005883a 	mov	r2,zero
 2039c90:	1884b03a 	or	r2,r3,r2
 2039c94:	10800234 	orhi	r2,r2,8
 2039c98:	e0bff815 	stw	r2,-32(fp)
			tse_dprintf(3, "WARNING : PHY[%d.%d] - Auto-Negotiation not completed! Speed = %s, Duplex = %s\n", mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 2039c9c:	e17ffd47 	ldb	r5,-11(fp)
 2039ca0:	e1bffd07 	ldb	r6,-12(fp)
 2039ca4:	e0bff703 	ldbu	r2,-36(fp)
 2039ca8:	108000a0 	cmpeqi	r2,r2,2
 2039cac:	10000e1e 	bne	r2,zero,2039ce8 <getPHYSpeed+0x658>
 2039cb0:	e0bff703 	ldbu	r2,-36(fp)
 2039cb4:	10800060 	cmpeqi	r2,r2,1
 2039cb8:	1000081e 	bne	r2,zero,2039cdc <getPHYSpeed+0x64c>
 2039cbc:	e0bff703 	ldbu	r2,-36(fp)
 2039cc0:	1000031e 	bne	r2,zero,2039cd0 <getPHYSpeed+0x640>
 2039cc4:	00808174 	movhi	r2,517
 2039cc8:	10beab04 	addi	r2,r2,-1364
 2039ccc:	00000206 	br	2039cd8 <getPHYSpeed+0x648>
 2039cd0:	00808174 	movhi	r2,517
 2039cd4:	10beac04 	addi	r2,r2,-1360
 2039cd8:	00000206 	br	2039ce4 <getPHYSpeed+0x654>
 2039cdc:	00808174 	movhi	r2,517
 2039ce0:	10beae04 	addi	r2,r2,-1352
 2039ce4:	00000206 	br	2039cf0 <getPHYSpeed+0x660>
 2039ce8:	00808174 	movhi	r2,517
 2039cec:	10beaf04 	addi	r2,r2,-1348
 2039cf0:	e0fff743 	ldbu	r3,-35(fp)
 2039cf4:	18c00058 	cmpnei	r3,r3,1
 2039cf8:	1800031e 	bne	r3,zero,2039d08 <getPHYSpeed+0x678>
 2039cfc:	00c08174 	movhi	r3,517
 2039d00:	18feb104 	addi	r3,r3,-1340
 2039d04:	00000206 	br	2039d10 <getPHYSpeed+0x680>
 2039d08:	00c08174 	movhi	r3,517
 2039d0c:	18feb304 	addi	r3,r3,-1332
 2039d10:	d8c00015 	stw	r3,0(sp)
 2039d14:	01008174 	movhi	r4,517
 2039d18:	213f1304 	addi	r4,r4,-948
 2039d1c:	100f883a 	mov	r7,r2
 2039d20:	2006a240 	call	2006a24 <printf>
																			 speed == TSE_PHY_SPEED_100 ? "100" :
																			 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
																			 duplex == 1 ? "Full" : "Half");
			return result;
 2039d24:	e0bff817 	ldw	r2,-32(fp)
 2039d28:	0000f106 	br	203a0f0 <getPHYSpeed+0xa60>
		}

        IOWR(&pmac_group_base->MDIO_ADDR1, 0, pphy->mdio_address);
 2039d2c:	e0bffe17 	ldw	r2,-8(fp)
 2039d30:	10801004 	addi	r2,r2,64
 2039d34:	e0fff917 	ldw	r3,-28(fp)
 2039d38:	18c00003 	ldbu	r3,0(r3)
 2039d3c:	18c03fcc 	andi	r3,r3,255
 2039d40:	10c00035 	stwio	r3,0(r2)
        /* To enable PHY loopback */
        #if ENABLE_PHY_LOOPBACK
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Putting PHY in loopback\n", mac_group_index, mac_info_index);
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 1);   // enable PHY loopback
		#else
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 2039d44:	d8000015 	stw	zero,0(sp)
 2039d48:	e13ff917 	ldw	r4,-28(fp)
 2039d4c:	000b883a 	mov	r5,zero
 2039d50:	01800384 	movi	r6,14
 2039d54:	01c00044 	movi	r7,1
 2039d58:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        #endif
       
        /* if PHY not found in profile */
        if(pphy->pphy_profile == 0) {
 2039d5c:	e0bff917 	ldw	r2,-28(fp)
 2039d60:	10800517 	ldw	r2,20(r2)
 2039d64:	10002b1e 	bne	r2,zero,2039e14 <getPHYSpeed+0x784>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not found in PHY profile\n", mac_group_index, mac_info_index);
 2039d68:	e0fffd47 	ldb	r3,-11(fp)
 2039d6c:	e0bffd07 	ldb	r2,-12(fp)
 2039d70:	01008174 	movhi	r4,517
 2039d74:	213f2704 	addi	r4,r4,-868
 2039d78:	180b883a 	mov	r5,r3
 2039d7c:	100d883a 	mov	r6,r2
 2039d80:	2006a240 	call	2006a24 <printf>
            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2039d84:	00800044 	movi	r2,1
 2039d88:	e0bff705 	stb	r2,-36(fp)
            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2039d8c:	00800044 	movi	r2,1
 2039d90:	e0bff745 	stb	r2,-35(fp)
			result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_NO_PHY_PROFILE;
 2039d94:	e0bff743 	ldbu	r2,-35(fp)
 2039d98:	10c0004c 	andi	r3,r2,1
 2039d9c:	e0bff703 	ldbu	r2,-36(fp)
 2039da0:	10800098 	cmpnei	r2,r2,2
 2039da4:	1000021e 	bne	r2,zero,2039db0 <getPHYSpeed+0x720>
 2039da8:	00800084 	movi	r2,2
 2039dac:	00000106 	br	2039db4 <getPHYSpeed+0x724>
 2039db0:	0005883a 	mov	r2,zero
 2039db4:	1886b03a 	or	r3,r3,r2
 2039db8:	e0bff703 	ldbu	r2,-36(fp)
 2039dbc:	10800058 	cmpnei	r2,r2,1
 2039dc0:	1000021e 	bne	r2,zero,2039dcc <getPHYSpeed+0x73c>
 2039dc4:	00800104 	movi	r2,4
 2039dc8:	00000106 	br	2039dd0 <getPHYSpeed+0x740>
 2039dcc:	0005883a 	mov	r2,zero
 2039dd0:	1886b03a 	or	r3,r3,r2
 2039dd4:	e0bff703 	ldbu	r2,-36(fp)
 2039dd8:	1000021e 	bne	r2,zero,2039de4 <getPHYSpeed+0x754>
 2039ddc:	00800204 	movi	r2,8
 2039de0:	00000106 	br	2039de8 <getPHYSpeed+0x758>
 2039de4:	0005883a 	mov	r2,zero
 2039de8:	1886b03a 	or	r3,r3,r2
 2039dec:	e0bff703 	ldbu	r2,-36(fp)
 2039df0:	108000d8 	cmpnei	r2,r2,3
 2039df4:	1000021e 	bne	r2,zero,2039e00 <getPHYSpeed+0x770>
 2039df8:	00800074 	movhi	r2,1
 2039dfc:	00000106 	br	2039e04 <getPHYSpeed+0x774>
 2039e00:	0005883a 	mov	r2,zero
 2039e04:	1884b03a 	or	r2,r3,r2
 2039e08:	10800134 	orhi	r2,r2,4
 2039e0c:	e0bff815 	stw	r2,-32(fp)
 2039e10:	00009406 	br	203a064 <getPHYSpeed+0x9d4>
        }
        // retrieve duplex information from PHY
		else
		{
			if(pphy->pphy_profile->link_status_read)
 2039e14:	e0bff917 	ldw	r2,-28(fp)
 2039e18:	10800517 	ldw	r2,20(r2)
 2039e1c:	10801817 	ldw	r2,96(r2)
 2039e20:	10002626 	beq	r2,zero,2039ebc <getPHYSpeed+0x82c>
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
 2039e24:	e0bff917 	ldw	r2,-28(fp)
 2039e28:	10800517 	ldw	r2,20(r2)
 2039e2c:	10801817 	ldw	r2,96(r2)
 2039e30:	e13ffe17 	ldw	r4,-8(fp)
 2039e34:	103ee83a 	callr	r2
 2039e38:	e0bff815 	stw	r2,-32(fp)
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2039e3c:	e0bff817 	ldw	r2,-32(fp)
 2039e40:	1080008c 	andi	r2,r2,2
 2039e44:	10000c1e 	bne	r2,zero,2039e78 <getPHYSpeed+0x7e8>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
 2039e48:	e0bff817 	ldw	r2,-32(fp)
 2039e4c:	1080010c 	andi	r2,r2,4
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2039e50:	1000071e 	bne	r2,zero,2039e70 <getPHYSpeed+0x7e0>
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
 2039e54:	e0bff817 	ldw	r2,-32(fp)
 2039e58:	1080020c 	andi	r2,r2,8
		else
		{
			if(pphy->pphy_profile->link_status_read)
			{
				result = pphy->pphy_profile->link_status_read(pmac_group_base);
				speed = (result & 0x02) ? TSE_PHY_SPEED_1000 :
 2039e5c:	10000226 	beq	r2,zero,2039e68 <getPHYSpeed+0x7d8>
 2039e60:	0005883a 	mov	r2,zero
 2039e64:	00000106 	br	2039e6c <getPHYSpeed+0x7dc>
 2039e68:	008000c4 	movi	r2,3
 2039e6c:	00000106 	br	2039e74 <getPHYSpeed+0x7e4>
 2039e70:	00800044 	movi	r2,1
 2039e74:	00000106 	br	2039e7c <getPHYSpeed+0x7ec>
 2039e78:	00800084 	movi	r2,2
 2039e7c:	e0bff705 	stb	r2,-36(fp)
				        (result & 0x04) ? TSE_PHY_SPEED_100  :
						(result & 0x08) ? TSE_PHY_SPEED_10  : TSE_PHY_SPEED_INVALID;
				duplex = (result & 0x01) ? TSE_PHY_DUPLEX_FULL : TSE_PHY_DUPLEX_HALF;
 2039e80:	e0bff817 	ldw	r2,-32(fp)
 2039e84:	1080004c 	andi	r2,r2,1
 2039e88:	1004c03a 	cmpne	r2,r2,zero
 2039e8c:	e0bff745 	stb	r2,-35(fp)
				
				if(result & ALT_TSE_E_INVALID_SPEED)
 2039e90:	e0bff817 	ldw	r2,-32(fp)
 2039e94:	1080006c 	andhi	r2,r2,1
 2039e98:	10007226 	beq	r2,zero,203a064 <getPHYSpeed+0x9d4>
				{
					tse_dprintf(3, "WARNING : PHY[%d.%d] - Invalid speed read from PHY\n", mac_group_index, mac_info_index);
 2039e9c:	e0fffd47 	ldb	r3,-11(fp)
 2039ea0:	e0bffd07 	ldb	r2,-12(fp)
 2039ea4:	01008174 	movhi	r4,517
 2039ea8:	213f3504 	addi	r4,r4,-812
 2039eac:	180b883a 	mov	r5,r3
 2039eb0:	100d883a 	mov	r6,r2
 2039eb4:	2006a240 	call	2006a24 <printf>
 2039eb8:	00006a06 	br	203a064 <getPHYSpeed+0x9d4>
				}
			}
			else if(pphy->pphy_profile->status_reg_location == 0)
 2039ebc:	e0bff917 	ldw	r2,-28(fp)
 2039ec0:	10800517 	ldw	r2,20(r2)
 2039ec4:	10801583 	ldbu	r2,86(r2)
 2039ec8:	10803fcc 	andi	r2,r2,255
 2039ecc:	10002b1e 	bne	r2,zero,2039f7c <getPHYSpeed+0x8ec>
	        {
	            tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY Specific Status register information not provided in profile\n", mac_group_index, mac_info_index);
 2039ed0:	e0fffd47 	ldb	r3,-11(fp)
 2039ed4:	e0bffd07 	ldb	r2,-12(fp)
 2039ed8:	01008174 	movhi	r4,517
 2039edc:	213f4204 	addi	r4,r4,-760
 2039ee0:	180b883a 	mov	r5,r3
 2039ee4:	100d883a 	mov	r6,r2
 2039ee8:	2006a240 	call	2006a24 <printf>
	            speed = ALTERA_TSE_MAC_SPEED_DEFAULT;
 2039eec:	00800044 	movi	r2,1
 2039ef0:	e0bff705 	stb	r2,-36(fp)
	            duplex = ALTERA_TSE_DUPLEX_MODE_DEFAULT;
 2039ef4:	00800044 	movi	r2,1
 2039ef8:	e0bff745 	stb	r2,-35(fp)
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex) | ALT_TSE_E_PROFILE_INCORRECT_DEFINED;
 2039efc:	e0bff743 	ldbu	r2,-35(fp)
 2039f00:	10c0004c 	andi	r3,r2,1
 2039f04:	e0bff703 	ldbu	r2,-36(fp)
 2039f08:	10800098 	cmpnei	r2,r2,2
 2039f0c:	1000021e 	bne	r2,zero,2039f18 <getPHYSpeed+0x888>
 2039f10:	00800084 	movi	r2,2
 2039f14:	00000106 	br	2039f1c <getPHYSpeed+0x88c>
 2039f18:	0005883a 	mov	r2,zero
 2039f1c:	1886b03a 	or	r3,r3,r2
 2039f20:	e0bff703 	ldbu	r2,-36(fp)
 2039f24:	10800058 	cmpnei	r2,r2,1
 2039f28:	1000021e 	bne	r2,zero,2039f34 <getPHYSpeed+0x8a4>
 2039f2c:	00800104 	movi	r2,4
 2039f30:	00000106 	br	2039f38 <getPHYSpeed+0x8a8>
 2039f34:	0005883a 	mov	r2,zero
 2039f38:	1886b03a 	or	r3,r3,r2
 2039f3c:	e0bff703 	ldbu	r2,-36(fp)
 2039f40:	1000021e 	bne	r2,zero,2039f4c <getPHYSpeed+0x8bc>
 2039f44:	00800204 	movi	r2,8
 2039f48:	00000106 	br	2039f50 <getPHYSpeed+0x8c0>
 2039f4c:	0005883a 	mov	r2,zero
 2039f50:	1886b03a 	or	r3,r3,r2
 2039f54:	e0bff703 	ldbu	r2,-36(fp)
 2039f58:	108000d8 	cmpnei	r2,r2,3
 2039f5c:	1000021e 	bne	r2,zero,2039f68 <getPHYSpeed+0x8d8>
 2039f60:	00800074 	movhi	r2,1
 2039f64:	00000106 	br	2039f6c <getPHYSpeed+0x8dc>
 2039f68:	0005883a 	mov	r2,zero
 2039f6c:	1884b03a 	or	r2,r3,r2
 2039f70:	108000b4 	orhi	r2,r2,2
 2039f74:	e0bff815 	stw	r2,-32(fp)
 2039f78:	00003a06 	br	203a064 <getPHYSpeed+0x9d4>
	        }
	        else
	        {
	            /* extract connection speed and duplex information */
	        	speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 2039f7c:	e0bff917 	ldw	r2,-28(fp)
 2039f80:	10800517 	ldw	r2,20(r2)
 2039f84:	10801583 	ldbu	r2,86(r2)
 2039f88:	10c03fcc 	andi	r3,r2,255
 2039f8c:	e0bff917 	ldw	r2,-28(fp)
 2039f90:	10800517 	ldw	r2,20(r2)
 2039f94:	108015c3 	ldbu	r2,87(r2)
 2039f98:	10803fcc 	andi	r2,r2,255
 2039f9c:	e13ff917 	ldw	r4,-28(fp)
 2039fa0:	180b883a 	mov	r5,r3
 2039fa4:	100d883a 	mov	r6,r2
 2039fa8:	01c00084 	movi	r7,2
 2039fac:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 2039fb0:	e0bff705 	stb	r2,-36(fp)
	            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 2039fb4:	e0bff917 	ldw	r2,-28(fp)
 2039fb8:	10800517 	ldw	r2,20(r2)
 2039fbc:	10801583 	ldbu	r2,86(r2)
 2039fc0:	10c03fcc 	andi	r3,r2,255
 2039fc4:	e0bff917 	ldw	r2,-28(fp)
 2039fc8:	10800517 	ldw	r2,20(r2)
 2039fcc:	10801603 	ldbu	r2,88(r2)
 2039fd0:	10803fcc 	andi	r2,r2,255
 2039fd4:	e13ff917 	ldw	r4,-28(fp)
 2039fd8:	180b883a 	mov	r5,r3
 2039fdc:	100d883a 	mov	r6,r2
 2039fe0:	01c00044 	movi	r7,1
 2039fe4:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 2039fe8:	e0bff745 	stb	r2,-35(fp)
				
				result = ALT_TSE_SPEED_DUPLEX(speed, duplex);
 2039fec:	e0bff743 	ldbu	r2,-35(fp)
 2039ff0:	10c0004c 	andi	r3,r2,1
 2039ff4:	e0bff703 	ldbu	r2,-36(fp)
 2039ff8:	10800098 	cmpnei	r2,r2,2
 2039ffc:	1000021e 	bne	r2,zero,203a008 <getPHYSpeed+0x978>
 203a000:	00800084 	movi	r2,2
 203a004:	00000106 	br	203a00c <getPHYSpeed+0x97c>
 203a008:	0005883a 	mov	r2,zero
 203a00c:	1886b03a 	or	r3,r3,r2
 203a010:	e0bff703 	ldbu	r2,-36(fp)
 203a014:	10800058 	cmpnei	r2,r2,1
 203a018:	1000021e 	bne	r2,zero,203a024 <getPHYSpeed+0x994>
 203a01c:	00800104 	movi	r2,4
 203a020:	00000106 	br	203a028 <getPHYSpeed+0x998>
 203a024:	0005883a 	mov	r2,zero
 203a028:	1886b03a 	or	r3,r3,r2
 203a02c:	e0bff703 	ldbu	r2,-36(fp)
 203a030:	1000021e 	bne	r2,zero,203a03c <getPHYSpeed+0x9ac>
 203a034:	00800204 	movi	r2,8
 203a038:	00000106 	br	203a040 <getPHYSpeed+0x9b0>
 203a03c:	0005883a 	mov	r2,zero
 203a040:	1886b03a 	or	r3,r3,r2
 203a044:	e0bff703 	ldbu	r2,-36(fp)
 203a048:	108000d8 	cmpnei	r2,r2,3
 203a04c:	1000021e 	bne	r2,zero,203a058 <getPHYSpeed+0x9c8>
 203a050:	00800074 	movhi	r2,1
 203a054:	00000106 	br	203a05c <getPHYSpeed+0x9cc>
 203a058:	0005883a 	mov	r2,zero
 203a05c:	1884b03a 	or	r2,r3,r2
 203a060:	e0bff815 	stw	r2,-32(fp)
        /* for simulation purpose, default to gigabit mode */
        speed = 1;
        duplex = 1;
    #endif

    tse_dprintf(5, "INFO    : PHY[%d.%d] - Speed = %s, Duplex = %s\n",  mac_group_index, mac_info_index, speed == TSE_PHY_SPEED_1000 ? "1000" :
 203a064:	e17ffd47 	ldb	r5,-11(fp)
 203a068:	e1bffd07 	ldb	r6,-12(fp)
 203a06c:	e0bff703 	ldbu	r2,-36(fp)
 203a070:	108000a0 	cmpeqi	r2,r2,2
 203a074:	10000e1e 	bne	r2,zero,203a0b0 <getPHYSpeed+0xa20>
 203a078:	e0bff703 	ldbu	r2,-36(fp)
 203a07c:	10800060 	cmpeqi	r2,r2,1
 203a080:	1000081e 	bne	r2,zero,203a0a4 <getPHYSpeed+0xa14>
 203a084:	e0bff703 	ldbu	r2,-36(fp)
 203a088:	1000031e 	bne	r2,zero,203a098 <getPHYSpeed+0xa08>
 203a08c:	00808174 	movhi	r2,517
 203a090:	10beab04 	addi	r2,r2,-1364
 203a094:	00000206 	br	203a0a0 <getPHYSpeed+0xa10>
 203a098:	00808174 	movhi	r2,517
 203a09c:	10beac04 	addi	r2,r2,-1360
 203a0a0:	00000206 	br	203a0ac <getPHYSpeed+0xa1c>
 203a0a4:	00808174 	movhi	r2,517
 203a0a8:	10beae04 	addi	r2,r2,-1352
 203a0ac:	00000206 	br	203a0b8 <getPHYSpeed+0xa28>
 203a0b0:	00808174 	movhi	r2,517
 203a0b4:	10beaf04 	addi	r2,r2,-1348
 203a0b8:	e0fff743 	ldbu	r3,-35(fp)
 203a0bc:	18c00058 	cmpnei	r3,r3,1
 203a0c0:	1800031e 	bne	r3,zero,203a0d0 <getPHYSpeed+0xa40>
 203a0c4:	00c08174 	movhi	r3,517
 203a0c8:	18feb104 	addi	r3,r3,-1340
 203a0cc:	00000206 	br	203a0d8 <getPHYSpeed+0xa48>
 203a0d0:	00c08174 	movhi	r3,517
 203a0d4:	18feb304 	addi	r3,r3,-1332
 203a0d8:	d8c00015 	stw	r3,0(sp)
 203a0dc:	01008174 	movhi	r4,517
 203a0e0:	213f5904 	addi	r4,r4,-668
 203a0e4:	100f883a 	mov	r7,r2
 203a0e8:	2006a240 	call	2006a24 <printf>
                                                                                 speed == TSE_PHY_SPEED_100 ? "100" :
                                                                                 speed == TSE_PHY_SPEED_10 ? "10" : "Unknown",
                                                                                 duplex == 1 ? "Full" : "Half");

    return result;
 203a0ec:	e0bff817 	ldw	r2,-32(fp)
}
 203a0f0:	e037883a 	mov	sp,fp
 203a0f4:	dfc00117 	ldw	ra,4(sp)
 203a0f8:	df000017 	ldw	fp,0(sp)
 203a0fc:	dec00204 	addi	sp,sp,8
 203a100:	f800283a 	ret

0203a104 <alt_tse_phy_rd_mdio_addr>:
/* @Function Description: Read MDIO address from the MDIO address1 register of first MAC within MAC group
 * @API Type:    Internal
 * @param pmac   Pointer to the alt_tse_phy_info structure
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_rd_mdio_addr(alt_tse_phy_info *pphy) {
 203a104:	defffd04 	addi	sp,sp,-12
 203a108:	df000215 	stw	fp,8(sp)
 203a10c:	df000204 	addi	fp,sp,8
 203a110:	e13fff15 	stw	r4,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203a114:	e0bfff17 	ldw	r2,-4(fp)
 203a118:	10800617 	ldw	r2,24(r2)
 203a11c:	10800317 	ldw	r2,12(r2)
 203a120:	10800117 	ldw	r2,4(r2)
 203a124:	10800217 	ldw	r2,8(r2)
 203a128:	10800017 	ldw	r2,0(r2)
 203a12c:	e0bffe15 	stw	r2,-8(fp)
    return IORD(&pmac_group_base->MDIO_ADDR1, 0);
 203a130:	e0bffe17 	ldw	r2,-8(fp)
 203a134:	10801004 	addi	r2,r2,64
 203a138:	10800037 	ldwio	r2,0(r2)
}
 203a13c:	e037883a 	mov	sp,fp
 203a140:	df000017 	ldw	fp,0(sp)
 203a144:	dec00104 	addi	sp,sp,4
 203a148:	f800283a 	ret

0203a14c <alt_tse_phy_wr_mdio_addr>:
 * @API Type:           Internal
 * @param pmac          Pointer to the alt_tse_phy_info structure
 * @param mdio_address  MDIO address to be written
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_wr_mdio_addr(alt_tse_phy_info *pphy, alt_u8 mdio_address) {
 203a14c:	defffc04 	addi	sp,sp,-16
 203a150:	df000315 	stw	fp,12(sp)
 203a154:	df000304 	addi	fp,sp,12
 203a158:	e13ffe15 	stw	r4,-8(fp)
 203a15c:	2805883a 	mov	r2,r5
 203a160:	e0bfff05 	stb	r2,-4(fp)
    np_tse_mac *pmac_group_base = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203a164:	e0bffe17 	ldw	r2,-8(fp)
 203a168:	10800617 	ldw	r2,24(r2)
 203a16c:	10800317 	ldw	r2,12(r2)
 203a170:	10800117 	ldw	r2,4(r2)
 203a174:	10800217 	ldw	r2,8(r2)
 203a178:	10800017 	ldw	r2,0(r2)
 203a17c:	e0bffd15 	stw	r2,-12(fp)
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdio_address);
 203a180:	e0bffd17 	ldw	r2,-12(fp)
 203a184:	10801004 	addi	r2,r2,64
 203a188:	e0ffff03 	ldbu	r3,-4(fp)
 203a18c:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 203a190:	0005883a 	mov	r2,zero
}
 203a194:	e037883a 	mov	sp,fp
 203a198:	df000017 	ldw	fp,0(sp)
 203a19c:	dec00104 	addi	sp,sp,4
 203a1a0:	f800283a 	ret

0203a1a4 <alt_tse_phy_wr_mdio_reg>:
  * @param  bit_length       number of bits to be written to the register.
  * @param  data             data to be written to the register at specific bit location of register.
  * @return SUCCESS 
  */
alt_32 alt_tse_phy_wr_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length, alt_u16 data)
{
 203a1a4:	defff604 	addi	sp,sp,-40
 203a1a8:	df000915 	stw	fp,36(sp)
 203a1ac:	df000904 	addi	fp,sp,36
 203a1b0:	e13ffb15 	stw	r4,-20(fp)
 203a1b4:	2809883a 	mov	r4,r5
 203a1b8:	3007883a 	mov	r3,r6
 203a1bc:	3805883a 	mov	r2,r7
 203a1c0:	e1400117 	ldw	r5,4(fp)
 203a1c4:	e13ffc05 	stb	r4,-16(fp)
 203a1c8:	e0fffd05 	stb	r3,-12(fp)
 203a1cc:	e0bffe05 	stb	r2,-8(fp)
 203a1d0:	e17fff0d 	sth	r5,-4(fp)
    
    alt_u16 temp_data;
    alt_u16 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203a1d4:	e0bffb17 	ldw	r2,-20(fp)
 203a1d8:	10800617 	ldw	r2,24(r2)
 203a1dc:	10800317 	ldw	r2,12(r2)
 203a1e0:	10800117 	ldw	r2,4(r2)
 203a1e4:	10800217 	ldw	r2,8(r2)
 203a1e8:	10800017 	ldw	r2,0(r2)
 203a1ec:	e0bff915 	stw	r2,-28(fp)
    
    bit_mask = 0x00;
 203a1f0:	e03ff70d 	sth	zero,-36(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 203a1f4:	e03ff815 	stw	zero,-32(fp)
 203a1f8:	00000906 	br	203a220 <alt_tse_phy_wr_mdio_reg+0x7c>
    {
        bit_mask <<= 1;
 203a1fc:	e0bff70b 	ldhu	r2,-36(fp)
 203a200:	1085883a 	add	r2,r2,r2
 203a204:	e0bff70d 	sth	r2,-36(fp)
        bit_mask |= 0x01;        
 203a208:	e0bff70b 	ldhu	r2,-36(fp)
 203a20c:	10800054 	ori	r2,r2,1
 203a210:	e0bff70d 	sth	r2,-36(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 203a214:	e0bff817 	ldw	r2,-32(fp)
 203a218:	10800044 	addi	r2,r2,1
 203a21c:	e0bff815 	stw	r2,-32(fp)
 203a220:	e0bffe03 	ldbu	r2,-8(fp)
 203a224:	e0fff817 	ldw	r3,-32(fp)
 203a228:	18bff416 	blt	r3,r2,203a1fc <alt_tse_phy_wr_mdio_reg+0x58>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* shifting mask to left by bit_num */
    bit_mask <<= lsb_num;
 203a22c:	e0fff70b 	ldhu	r3,-36(fp)
 203a230:	e0bffd03 	ldbu	r2,-12(fp)
 203a234:	1884983a 	sll	r2,r3,r2
 203a238:	e0bff70d 	sth	r2,-36(fp)

    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 203a23c:	e0bff917 	ldw	r2,-28(fp)
 203a240:	10c0a004 	addi	r3,r2,640
 203a244:	e0bffc03 	ldbu	r2,-16(fp)
 203a248:	1085883a 	add	r2,r2,r2
 203a24c:	1085883a 	add	r2,r2,r2
 203a250:	1885883a 	add	r2,r3,r2
 203a254:	10800037 	ldwio	r2,0(r2)
 203a258:	e0bffa0d 	sth	r2,-24(fp)
    
    /* clear bits to be written */
    temp_data &= ~bit_mask;
 203a25c:	e0bff70b 	ldhu	r2,-36(fp)
 203a260:	0084303a 	nor	r2,zero,r2
 203a264:	1007883a 	mov	r3,r2
 203a268:	e0bffa0b 	ldhu	r2,-24(fp)
 203a26c:	1884703a 	and	r2,r3,r2
 203a270:	e0bffa0d 	sth	r2,-24(fp)
    
    /* OR-ed together corresponding bits data */
    temp_data |= ((data << lsb_num) & bit_mask);    
 203a274:	e0ffff0b 	ldhu	r3,-4(fp)
 203a278:	e0bffd03 	ldbu	r2,-12(fp)
 203a27c:	1884983a 	sll	r2,r3,r2
 203a280:	1007883a 	mov	r3,r2
 203a284:	e0bff70b 	ldhu	r2,-36(fp)
 203a288:	1884703a 	and	r2,r3,r2
 203a28c:	1007883a 	mov	r3,r2
 203a290:	e0bffa0b 	ldhu	r2,-24(fp)
 203a294:	1884b03a 	or	r2,r3,r2
 203a298:	e0bffa0d 	sth	r2,-24(fp)
    
    /* write data to MDIO register */
    IOWR(&pmac->mdio1, reg_num, temp_data);
 203a29c:	e0bff917 	ldw	r2,-28(fp)
 203a2a0:	10c0a004 	addi	r3,r2,640
 203a2a4:	e0bffc03 	ldbu	r2,-16(fp)
 203a2a8:	1085883a 	add	r2,r2,r2
 203a2ac:	1085883a 	add	r2,r2,r2
 203a2b0:	1885883a 	add	r2,r3,r2
 203a2b4:	e0fffa0b 	ldhu	r3,-24(fp)
 203a2b8:	10c00035 	stwio	r3,0(r2)
    
    return SUCCESS;
 203a2bc:	0005883a 	mov	r2,zero
    
}
 203a2c0:	e037883a 	mov	sp,fp
 203a2c4:	df000017 	ldw	fp,0(sp)
 203a2c8:	dec00104 	addi	sp,sp,4
 203a2cc:	f800283a 	ret

0203a2d0 <alt_tse_phy_rd_mdio_reg>:
 * @param  bit_length       number of bits to be read from the register.
 * @return data read from MDIO register 
 */

alt_u32 alt_tse_phy_rd_mdio_reg(alt_tse_phy_info *pphy, alt_u8 reg_num, alt_u8 lsb_num, alt_u8 bit_length)
{
 203a2d0:	defff704 	addi	sp,sp,-36
 203a2d4:	df000815 	stw	fp,32(sp)
 203a2d8:	df000804 	addi	fp,sp,32
 203a2dc:	e13ffc15 	stw	r4,-16(fp)
 203a2e0:	2809883a 	mov	r4,r5
 203a2e4:	3007883a 	mov	r3,r6
 203a2e8:	3805883a 	mov	r2,r7
 203a2ec:	e13ffd05 	stb	r4,-12(fp)
 203a2f0:	e0fffe05 	stb	r3,-8(fp)
 203a2f4:	e0bfff05 	stb	r2,-4(fp)
    alt_u16 temp_data;
    alt_u32 bit_mask;
    alt_32 i;
    np_tse_mac *pmac = (np_tse_mac *) pphy->pmac_info->pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203a2f8:	e0bffc17 	ldw	r2,-16(fp)
 203a2fc:	10800617 	ldw	r2,24(r2)
 203a300:	10800317 	ldw	r2,12(r2)
 203a304:	10800117 	ldw	r2,4(r2)
 203a308:	10800217 	ldw	r2,8(r2)
 203a30c:	10800017 	ldw	r2,0(r2)
 203a310:	e0bffa15 	stw	r2,-24(fp)
    
    bit_mask = 0x00;
 203a314:	e03ff815 	stw	zero,-32(fp)
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 203a318:	e03ff915 	stw	zero,-28(fp)
 203a31c:	00000906 	br	203a344 <alt_tse_phy_rd_mdio_reg+0x74>
    {
        bit_mask <<= 1;
 203a320:	e0bff817 	ldw	r2,-32(fp)
 203a324:	1085883a 	add	r2,r2,r2
 203a328:	e0bff815 	stw	r2,-32(fp)
        bit_mask |= 0x01;        
 203a32c:	e0bff817 	ldw	r2,-32(fp)
 203a330:	10800054 	ori	r2,r2,1
 203a334:	e0bff815 	stw	r2,-32(fp)
    
    bit_mask = 0x00;
    /* generate mask consist of bit_length number of 1
     * eg: bit_length = 3, bit_mask = 0b0000 0000 0000 0111
     */
    for(i = 0; i < bit_length; i++)
 203a338:	e0bff917 	ldw	r2,-28(fp)
 203a33c:	10800044 	addi	r2,r2,1
 203a340:	e0bff915 	stw	r2,-28(fp)
 203a344:	e0bfff03 	ldbu	r2,-4(fp)
 203a348:	e0fff917 	ldw	r3,-28(fp)
 203a34c:	18bff416 	blt	r3,r2,203a320 <alt_tse_phy_rd_mdio_reg+0x50>
        bit_mask <<= 1;
        bit_mask |= 0x01;        
    }
    
    /* read register data */
    temp_data = IORD(&pmac->mdio1, reg_num);
 203a350:	e0bffa17 	ldw	r2,-24(fp)
 203a354:	10c0a004 	addi	r3,r2,640
 203a358:	e0bffd03 	ldbu	r2,-12(fp)
 203a35c:	1085883a 	add	r2,r2,r2
 203a360:	1085883a 	add	r2,r2,r2
 203a364:	1885883a 	add	r2,r3,r2
 203a368:	10800037 	ldwio	r2,0(r2)
 203a36c:	e0bffb0d 	sth	r2,-20(fp)
    
    /* shifting read data */
    temp_data >>= lsb_num;
 203a370:	e0fffb0b 	ldhu	r3,-20(fp)
 203a374:	e0bffe03 	ldbu	r2,-8(fp)
 203a378:	1885d83a 	sra	r2,r3,r2
 203a37c:	e0bffb0d 	sth	r2,-20(fp)
    
    return (temp_data & bit_mask);
 203a380:	e0fffb0b 	ldhu	r3,-20(fp)
 203a384:	e0bff817 	ldw	r2,-32(fp)
 203a388:	1884703a 	and	r2,r3,r2
}
 203a38c:	e037883a 	mov	sp,fp
 203a390:	df000017 	ldw	fp,0(sp)
 203a394:	dec00104 	addi	sp,sp,4
 203a398:	f800283a 	ret

0203a39c <alt_tse_phy_add_profile_default>:
 * @param pmac  N/A
 * @return      Number of PHY in profile
 * 
 * User might add their own PHY by calling alt_tse_phy_add_profile()
 */
alt_32 alt_tse_phy_add_profile_default() {
 203a39c:	deff9a04 	addi	sp,sp,-408
 203a3a0:	dfc06515 	stw	ra,404(sp)
 203a3a4:	df006415 	stw	fp,400(sp)
 203a3a8:	df006404 	addi	fp,sp,400
        
    /* ------------------------------ */
    /* Marvell PHY on PHYWORKX board  */
    /* ------------------------------ */
    
    alt_tse_phy_profile MV88E1111 = {"Marvell 88E1111",      /* Marvell 88E1111                                  */
 203a3ac:	e0ff9c04 	addi	r3,fp,-400
 203a3b0:	00801904 	movi	r2,100
 203a3b4:	1809883a 	mov	r4,r3
 203a3b8:	000b883a 	mov	r5,zero
 203a3bc:	100d883a 	mov	r6,r2
 203a3c0:	200682c0 	call	200682c <memset>
 203a3c4:	009d9cb4 	movhi	r2,30322
 203a3c8:	10985344 	addi	r2,r2,24909
 203a3cc:	e0bf9c15 	stw	r2,-400(fp)
 203a3d0:	00881b34 	movhi	r2,8300
 203a3d4:	109b1944 	addi	r2,r2,27749
 203a3d8:	e0bf9d15 	stw	r2,-396(fp)
 203a3dc:	008c5174 	movhi	r2,12613
 203a3e0:	108e0e04 	addi	r2,r2,14392
 203a3e4:	e0bf9e15 	stw	r2,-392(fp)
 203a3e8:	00800c74 	movhi	r2,49
 203a3ec:	108c4c44 	addi	r2,r2,12593
 203a3f0:	e0bf9f15 	stw	r2,-388(fp)
 203a3f4:	e0ffa004 	addi	r3,fp,-384
 203a3f8:	00801004 	movi	r2,64
 203a3fc:	1809883a 	mov	r4,r3
 203a400:	000b883a 	mov	r5,zero
 203a404:	100d883a 	mov	r6,r2
 203a408:	200682c0 	call	200682c <memset>
 203a40c:	009410c4 	movi	r2,20547
 203a410:	e0bfb015 	stw	r2,-320(fp)
 203a414:	00800304 	movi	r2,12
 203a418:	e0bfb105 	stb	r2,-316(fp)
 203a41c:	00800084 	movi	r2,2
 203a420:	e0bfb145 	stb	r2,-315(fp)
 203a424:	00800444 	movi	r2,17
 203a428:	e0bfb185 	stb	r2,-314(fp)
 203a42c:	00800384 	movi	r2,14
 203a430:	e0bfb1c5 	stb	r2,-313(fp)
 203a434:	00800344 	movi	r2,13
 203a438:	e0bfb205 	stb	r2,-312(fp)
 203a43c:	00800284 	movi	r2,10
 203a440:	e0bfb245 	stb	r2,-311(fp)
 203a444:	00808134 	movhi	r2,516
 203a448:	10b37104 	addi	r2,r2,-12860
 203a44c:	e0bfb315 	stw	r2,-308(fp)
    
    /* ---------------------------------- */
    /* Marvell Quad PHY on PHYWORKX board */
    /* ---------------------------------- */
    
    alt_tse_phy_profile MV88E1145 = {"Marvell Quad PHY 88E1145",      /* Marvell 88E1145                                  */
 203a450:	e0ffb504 	addi	r3,fp,-300
 203a454:	00801904 	movi	r2,100
 203a458:	1809883a 	mov	r4,r3
 203a45c:	000b883a 	mov	r5,zero
 203a460:	100d883a 	mov	r6,r2
 203a464:	200682c0 	call	200682c <memset>
 203a468:	009d9cb4 	movhi	r2,30322
 203a46c:	10985344 	addi	r2,r2,24909
 203a470:	e0bfb515 	stw	r2,-300(fp)
 203a474:	00881b34 	movhi	r2,8300
 203a478:	109b1944 	addi	r2,r2,27749
 203a47c:	e0bfb615 	stw	r2,-296(fp)
 203a480:	00991874 	movhi	r2,25697
 203a484:	109d5444 	addi	r2,r2,30033
 203a488:	e0bfb715 	stw	r2,-292(fp)
 203a48c:	00965234 	movhi	r2,22856
 203a490:	10940804 	addi	r2,r2,20512
 203a494:	e0bfb815 	stw	r2,-288(fp)
 203a498:	00914e34 	movhi	r2,17720
 203a49c:	108e0804 	addi	r2,r2,14368
 203a4a0:	e0bfb915 	stw	r2,-284(fp)
 203a4a4:	008d4d34 	movhi	r2,13620
 203a4a8:	108c4c44 	addi	r2,r2,12593
 203a4ac:	e0bfba15 	stw	r2,-280(fp)
 203a4b0:	e03fbb15 	stw	zero,-276(fp)
 203a4b4:	e03fbc15 	stw	zero,-272(fp)
 203a4b8:	e03fbd15 	stw	zero,-268(fp)
 203a4bc:	e03fbe15 	stw	zero,-264(fp)
 203a4c0:	e03fbf15 	stw	zero,-260(fp)
 203a4c4:	e03fc015 	stw	zero,-256(fp)
 203a4c8:	e03fc115 	stw	zero,-252(fp)
 203a4cc:	e03fc215 	stw	zero,-248(fp)
 203a4d0:	e03fc315 	stw	zero,-244(fp)
 203a4d4:	e03fc415 	stw	zero,-240(fp)
 203a4d8:	e03fc515 	stw	zero,-236(fp)
 203a4dc:	e03fc615 	stw	zero,-232(fp)
 203a4e0:	e03fc715 	stw	zero,-228(fp)
 203a4e4:	e03fc815 	stw	zero,-224(fp)
 203a4e8:	009410c4 	movi	r2,20547
 203a4ec:	e0bfc915 	stw	r2,-220(fp)
 203a4f0:	00800344 	movi	r2,13
 203a4f4:	e0bfca05 	stb	r2,-216(fp)
 203a4f8:	00800084 	movi	r2,2
 203a4fc:	e0bfca45 	stb	r2,-215(fp)
 203a500:	00800444 	movi	r2,17
 203a504:	e0bfca85 	stb	r2,-214(fp)
 203a508:	00800384 	movi	r2,14
 203a50c:	e0bfcac5 	stb	r2,-213(fp)
 203a510:	00800344 	movi	r2,13
 203a514:	e0bfcb05 	stb	r2,-212(fp)
 203a518:	00800284 	movi	r2,10
 203a51c:	e0bfcb45 	stb	r2,-211(fp)
 203a520:	00808134 	movhi	r2,516
 203a524:	10b37104 	addi	r2,r2,-12860
 203a528:	e0bfcc15 	stw	r2,-208(fp)
                      
    /* ------------------------------ */
    /* National PHY on PHYWORKX board */
    /* ------------------------------ */  
    
    alt_tse_phy_profile DP83865 = {"National DP83865",     /* National DP83865                                 */
 203a52c:	e0ffce04 	addi	r3,fp,-200
 203a530:	00801904 	movi	r2,100
 203a534:	1809883a 	mov	r4,r3
 203a538:	000b883a 	mov	r5,zero
 203a53c:	100d883a 	mov	r6,r2
 203a540:	200682c0 	call	200682c <memset>
 203a544:	009a5d34 	movhi	r2,26996
 203a548:	10985384 	addi	r2,r2,24910
 203a54c:	e0bfce15 	stw	r2,-200(fp)
 203a550:	009b1874 	movhi	r2,27745
 203a554:	109b9bc4 	addi	r2,r2,28271
 203a558:	e0bfcf15 	stw	r2,-196(fp)
 203a55c:	008e1434 	movhi	r2,14416
 203a560:	10910804 	addi	r2,r2,17440
 203a564:	e0bfd015 	stw	r2,-192(fp)
 203a568:	008d4db4 	movhi	r2,13622
 203a56c:	108e0cc4 	addi	r2,r2,14387
 203a570:	e0bfd115 	stw	r2,-188(fp)
 203a574:	e03fd215 	stw	zero,-184(fp)
 203a578:	e0ffd304 	addi	r3,fp,-180
 203a57c:	00800f04 	movi	r2,60
 203a580:	1809883a 	mov	r4,r3
 203a584:	000b883a 	mov	r5,zero
 203a588:	100d883a 	mov	r6,r2
 203a58c:	200682c0 	call	200682c <memset>
 203a590:	00800234 	movhi	r2,8
 203a594:	108005c4 	addi	r2,r2,23
 203a598:	e0bfe215 	stw	r2,-120(fp)
 203a59c:	008001c4 	movi	r2,7
 203a5a0:	e0bfe305 	stb	r2,-116(fp)
 203a5a4:	00800284 	movi	r2,10
 203a5a8:	e0bfe345 	stb	r2,-115(fp)
 203a5ac:	00800444 	movi	r2,17
 203a5b0:	e0bfe385 	stb	r2,-114(fp)
 203a5b4:	008000c4 	movi	r2,3
 203a5b8:	e0bfe3c5 	stb	r2,-113(fp)
 203a5bc:	00800044 	movi	r2,1
 203a5c0:	e0bfe405 	stb	r2,-112(fp)
 203a5c4:	00800084 	movi	r2,2
 203a5c8:	e0bfe445 	stb	r2,-111(fp)
                      
    /* -------------------------------------- */
    /* National 10/100 PHY on PHYWORKX board  */
    /* -------------------------------------- */ 
                      
    alt_tse_phy_profile DP83848C = {"National DP83848C",  /* National DP83848C                                          */
 203a5cc:	00808174 	movhi	r2,517
 203a5d0:	10bf6504 	addi	r2,r2,-620
 203a5d4:	e13fe704 	addi	r4,fp,-100
 203a5d8:	1007883a 	mov	r3,r2
 203a5dc:	00801904 	movi	r2,100
 203a5e0:	180b883a 	mov	r5,r3
 203a5e4:	100d883a 	mov	r6,r2
 203a5e8:	200660c0 	call	200660c <memcpy>
						   0,                              /* No function pointer configure National DP83848C            */
						   &DP83848C_link_status_read      /* Function pointer to read from PHY specific status register */           
                          };
                      
    /* add supported PHY to profile */                          
    alt_tse_phy_add_profile(&MV88E1111);
 203a5ec:	e13f9c04 	addi	r4,fp,-400
 203a5f0:	20385200 	call	2038520 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&MV88E1145);
 203a5f4:	e0bfb504 	addi	r2,fp,-300
 203a5f8:	1009883a 	mov	r4,r2
 203a5fc:	20385200 	call	2038520 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83865);
 203a600:	e0bfce04 	addi	r2,fp,-200
 203a604:	1009883a 	mov	r4,r2
 203a608:	20385200 	call	2038520 <alt_tse_phy_add_profile>
    alt_tse_phy_add_profile(&DP83848C);
 203a60c:	e0bfe704 	addi	r2,fp,-100
 203a610:	1009883a 	mov	r4,r2
 203a614:	20385200 	call	2038520 <alt_tse_phy_add_profile>
    
    
    return phy_profile_count;
 203a618:	d0a0af03 	ldbu	r2,-32068(gp)
 203a61c:	10803fcc 	andi	r2,r2,255
}
 203a620:	e037883a 	mov	sp,fp
 203a624:	dfc00117 	ldw	ra,4(sp)
 203a628:	df000017 	ldw	fp,0(sp)
 203a62c:	dec00204 	addi	sp,sp,8
 203a630:	f800283a 	ret

0203a634 <alt_tse_phy_print_profile>:
/* @Function Description: Display PHYs available in profile
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      Number of PHY in profile
 */
alt_32 alt_tse_phy_print_profile() {
 203a634:	defffd04 	addi	sp,sp,-12
 203a638:	dfc00215 	stw	ra,8(sp)
 203a63c:	df000115 	stw	fp,4(sp)
 203a640:	df000104 	addi	fp,sp,4
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
 203a644:	d0a0af03 	ldbu	r2,-32068(gp)
 203a648:	10803fcc 	andi	r2,r2,255
 203a64c:	01008174 	movhi	r4,517
 203a650:	213f7e04 	addi	r4,r4,-520
 203a654:	100b883a 	mov	r5,r2
 203a658:	20381e40 	call	20381e4 <no_printf>
    
    for(i = 0; i < phy_profile_count; i++)
 203a65c:	e03fff05 	stb	zero,-4(fp)
 203a660:	00006d06 	br	203a818 <alt_tse_phy_print_profile+0x1e4>
    {
        tse_dprintf(6, "Profile No.%2d   :\n", i);
 203a664:	e0bfff07 	ldb	r2,-4(fp)
 203a668:	01008174 	movhi	r4,517
 203a66c:	213f8d04 	addi	r4,r4,-460
 203a670:	100b883a 	mov	r5,r2
 203a674:	20381e40 	call	20381e4 <no_printf>
        tse_dprintf(6, "PHY Name        : %s\n", pphy_profiles[i]->name);
 203a678:	e0bfff07 	ldb	r2,-4(fp)
 203a67c:	00c09934 	movhi	r3,612
 203a680:	18f77104 	addi	r3,r3,-8764
 203a684:	1085883a 	add	r2,r2,r2
 203a688:	1085883a 	add	r2,r2,r2
 203a68c:	1885883a 	add	r2,r3,r2
 203a690:	10800017 	ldw	r2,0(r2)
 203a694:	01008174 	movhi	r4,517
 203a698:	213f9204 	addi	r4,r4,-440
 203a69c:	100b883a 	mov	r5,r2
 203a6a0:	20381e40 	call	20381e4 <no_printf>
   
        tse_dprintf(6, "PHY OUI         : 0x%06x\n", (int)pphy_profiles[i]->oui);
 203a6a4:	e0bfff07 	ldb	r2,-4(fp)
 203a6a8:	00c09934 	movhi	r3,612
 203a6ac:	18f77104 	addi	r3,r3,-8764
 203a6b0:	1085883a 	add	r2,r2,r2
 203a6b4:	1085883a 	add	r2,r2,r2
 203a6b8:	1885883a 	add	r2,r3,r2
 203a6bc:	10800017 	ldw	r2,0(r2)
 203a6c0:	10801417 	ldw	r2,80(r2)
 203a6c4:	01008174 	movhi	r4,517
 203a6c8:	213f9804 	addi	r4,r4,-416
 203a6cc:	100b883a 	mov	r5,r2
 203a6d0:	20381e40 	call	20381e4 <no_printf>
        tse_dprintf(6, "PHY Model Num.  : 0x%02x\n", pphy_profiles[i]->model_number);
 203a6d4:	e0bfff07 	ldb	r2,-4(fp)
 203a6d8:	00c09934 	movhi	r3,612
 203a6dc:	18f77104 	addi	r3,r3,-8764
 203a6e0:	1085883a 	add	r2,r2,r2
 203a6e4:	1085883a 	add	r2,r2,r2
 203a6e8:	1885883a 	add	r2,r3,r2
 203a6ec:	10800017 	ldw	r2,0(r2)
 203a6f0:	10801503 	ldbu	r2,84(r2)
 203a6f4:	10803fcc 	andi	r2,r2,255
 203a6f8:	01008174 	movhi	r4,517
 203a6fc:	213f9f04 	addi	r4,r4,-388
 203a700:	100b883a 	mov	r5,r2
 203a704:	20381e40 	call	20381e4 <no_printf>
        tse_dprintf(6, "PHY Rev. Num.   : 0x%02x\n", pphy_profiles[i]->revision_number);
 203a708:	e0bfff07 	ldb	r2,-4(fp)
 203a70c:	00c09934 	movhi	r3,612
 203a710:	18f77104 	addi	r3,r3,-8764
 203a714:	1085883a 	add	r2,r2,r2
 203a718:	1085883a 	add	r2,r2,r2
 203a71c:	1885883a 	add	r2,r3,r2
 203a720:	10800017 	ldw	r2,0(r2)
 203a724:	10801543 	ldbu	r2,85(r2)
 203a728:	10803fcc 	andi	r2,r2,255
 203a72c:	01008174 	movhi	r4,517
 203a730:	213fa604 	addi	r4,r4,-360
 203a734:	100b883a 	mov	r5,r2
 203a738:	20381e40 	call	20381e4 <no_printf>
        
        tse_dprintf(6, "Status Register : 0x%02x\n", pphy_profiles[i]->status_reg_location); 
 203a73c:	e0bfff07 	ldb	r2,-4(fp)
 203a740:	00c09934 	movhi	r3,612
 203a744:	18f77104 	addi	r3,r3,-8764
 203a748:	1085883a 	add	r2,r2,r2
 203a74c:	1085883a 	add	r2,r2,r2
 203a750:	1885883a 	add	r2,r3,r2
 203a754:	10800017 	ldw	r2,0(r2)
 203a758:	10801583 	ldbu	r2,86(r2)
 203a75c:	10803fcc 	andi	r2,r2,255
 203a760:	01008174 	movhi	r4,517
 203a764:	213fad04 	addi	r4,r4,-332
 203a768:	100b883a 	mov	r5,r2
 203a76c:	20381e40 	call	20381e4 <no_printf>
        
        tse_dprintf(6, "Speed Bit       : %d\n", pphy_profiles[i]->speed_lsb_location);
 203a770:	e0bfff07 	ldb	r2,-4(fp)
 203a774:	00c09934 	movhi	r3,612
 203a778:	18f77104 	addi	r3,r3,-8764
 203a77c:	1085883a 	add	r2,r2,r2
 203a780:	1085883a 	add	r2,r2,r2
 203a784:	1885883a 	add	r2,r3,r2
 203a788:	10800017 	ldw	r2,0(r2)
 203a78c:	108015c3 	ldbu	r2,87(r2)
 203a790:	10803fcc 	andi	r2,r2,255
 203a794:	01008174 	movhi	r4,517
 203a798:	213fb404 	addi	r4,r4,-304
 203a79c:	100b883a 	mov	r5,r2
 203a7a0:	20381e40 	call	20381e4 <no_printf>
        
        tse_dprintf(6, "Duplex Bit      : %d\n", pphy_profiles[i]->duplex_bit_location);
 203a7a4:	e0bfff07 	ldb	r2,-4(fp)
 203a7a8:	00c09934 	movhi	r3,612
 203a7ac:	18f77104 	addi	r3,r3,-8764
 203a7b0:	1085883a 	add	r2,r2,r2
 203a7b4:	1085883a 	add	r2,r2,r2
 203a7b8:	1885883a 	add	r2,r3,r2
 203a7bc:	10800017 	ldw	r2,0(r2)
 203a7c0:	10801603 	ldbu	r2,88(r2)
 203a7c4:	10803fcc 	andi	r2,r2,255
 203a7c8:	01008174 	movhi	r4,517
 203a7cc:	213fba04 	addi	r4,r4,-280
 203a7d0:	100b883a 	mov	r5,r2
 203a7d4:	20381e40 	call	20381e4 <no_printf>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 203a7d8:	e0bfff07 	ldb	r2,-4(fp)
 203a7dc:	00c09934 	movhi	r3,612
 203a7e0:	18f77104 	addi	r3,r3,-8764
 203a7e4:	1085883a 	add	r2,r2,r2
 203a7e8:	1085883a 	add	r2,r2,r2
 203a7ec:	1885883a 	add	r2,r3,r2
 203a7f0:	10800017 	ldw	r2,0(r2)
 203a7f4:	10801643 	ldbu	r2,89(r2)
 203a7f8:	10803fcc 	andi	r2,r2,255
 203a7fc:	01008174 	movhi	r4,517
 203a800:	213fc004 	addi	r4,r4,-256
 203a804:	100b883a 	mov	r5,r2
 203a808:	20381e40 	call	20381e4 <no_printf>
   
	alt_8 i;
    /* display PHY in profile */
    tse_dprintf(6, "List of PHY profiles supported (Total profiles = %d)...\n", phy_profile_count);
    
    for(i = 0; i < phy_profile_count; i++)
 203a80c:	e0bfff03 	ldbu	r2,-4(fp)
 203a810:	10800044 	addi	r2,r2,1
 203a814:	e0bfff05 	stb	r2,-4(fp)
 203a818:	e0ffff07 	ldb	r3,-4(fp)
 203a81c:	d0a0af03 	ldbu	r2,-32068(gp)
 203a820:	10803fcc 	andi	r2,r2,255
 203a824:	18bf8f16 	blt	r3,r2,203a664 <alt_tse_phy_print_profile+0x30>
        
        tse_dprintf(6, "Link Bit        : %d\n\n", pphy_profiles[i]->link_bit_location);
 
    }
    
    return phy_profile_count;
 203a828:	d0a0af03 	ldbu	r2,-32068(gp)
 203a82c:	10803fcc 	andi	r2,r2,255
}
 203a830:	e037883a 	mov	sp,fp
 203a834:	dfc00117 	ldw	ra,4(sp)
 203a838:	df000017 	ldw	fp,0(sp)
 203a83c:	dec00204 	addi	sp,sp,8
 203a840:	f800283a 	ret

0203a844 <alt_tse_mac_group_init>:
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      return SUCCESS
 *              return ALTERA_TSE_SYSTEM_DEF_ERROR if alt_tse_system_info structure definition error
 */
alt_32 alt_tse_mac_group_init() {
 203a844:	defffa04 	addi	sp,sp,-24
 203a848:	dfc00515 	stw	ra,20(sp)
 203a84c:	df000415 	stw	fp,16(sp)
 203a850:	df000404 	addi	fp,sp,16
    
	alt_8 i;
	alt_8 j;
    
    alt_tse_mac_group *pmac_group = 0;
 203a854:	e03ffd15 	stw	zero,-12(fp)
    alt_tse_mac_info *pmac_info = 0;
 203a858:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_system_info *psys = 0;
 203a85c:	e03fff15 	stw	zero,-4(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
 203a860:	d020af45 	stb	zero,-32067(gp)
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 203a864:	e03ffc05 	stb	zero,-16(fp)
 203a868:	00019306 	br	203aeb8 <alt_tse_mac_group_init+0x674>
        psys = &tse_mac_device[i];
 203a86c:	e0bffc07 	ldb	r2,-16(fp)
 203a870:	10c01224 	muli	r3,r2,72
 203a874:	00808174 	movhi	r2,517
 203a878:	108f7e04 	addi	r2,r2,15864
 203a87c:	1885883a 	add	r2,r3,r2
 203a880:	e0bfff15 	stw	r2,-4(fp)

        if((psys->tse_sgdma_tx != 0) && (psys->tse_sgdma_rx != 0)) {    	
 203a884:	e0bfff17 	ldw	r2,-4(fp)
 203a888:	10800517 	ldw	r2,20(r2)
 203a88c:	10018726 	beq	r2,zero,203aeac <alt_tse_mac_group_init+0x668>
 203a890:	e0bfff17 	ldw	r2,-4(fp)
 203a894:	10800617 	ldw	r2,24(r2)
 203a898:	10018426 	beq	r2,zero,203aeac <alt_tse_mac_group_init+0x668>
            tse_dprintf(5, "INFO    : TSE MAC %d found at address 0x%08x\n", mac_group_count, (int) psys->tse_mac_base);
 203a89c:	d0a0af43 	ldbu	r2,-32067(gp)
 203a8a0:	10c03fcc 	andi	r3,r2,255
 203a8a4:	e0bfff17 	ldw	r2,-4(fp)
 203a8a8:	10800017 	ldw	r2,0(r2)
 203a8ac:	01008174 	movhi	r4,517
 203a8b0:	213fc604 	addi	r4,r4,-232
 203a8b4:	180b883a 	mov	r5,r3
 203a8b8:	100d883a 	mov	r6,r2
 203a8bc:	2006a240 	call	2006a24 <printf>
            
            /* Allocate memory for the structure */
            pmac_group = (alt_tse_mac_group *) malloc(sizeof(alt_tse_mac_group));
 203a8c0:	01000504 	movi	r4,20
 203a8c4:	204bd440 	call	204bd44 <malloc>
 203a8c8:	e0bffd15 	stw	r2,-12(fp)
            if(!pmac_group) {
 203a8cc:	e0bffd17 	ldw	r2,-12(fp)
 203a8d0:	1000081e 	bne	r2,zero,203a8f4 <alt_tse_mac_group_init+0xb0>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]\n", mac_group_count);
 203a8d4:	d0a0af43 	ldbu	r2,-32067(gp)
 203a8d8:	10803fcc 	andi	r2,r2,255
 203a8dc:	01008174 	movhi	r4,517
 203a8e0:	213fd204 	addi	r4,r4,-184
 203a8e4:	100b883a 	mov	r5,r2
 203a8e8:	2006a240 	call	2006a24 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 203a8ec:	00bfffc4 	movi	r2,-1
 203a8f0:	00017606 	br	203aecc <alt_tse_mac_group_init+0x688>
            }
           
            /* Non-multi-channel MAC considered as 1 channel */
            if(psys->tse_multichannel_mac) {
 203a8f4:	e0bfff17 	ldw	r2,-4(fp)
 203a8f8:	108002c3 	ldbu	r2,11(r2)
 203a8fc:	10803fcc 	andi	r2,r2,255
 203a900:	10001226 	beq	r2,zero,203a94c <alt_tse_mac_group_init+0x108>
                pmac_group->channel = psys->tse_num_of_channel;
 203a904:	e0bfff17 	ldw	r2,-4(fp)
 203a908:	10c00303 	ldbu	r3,12(r2)
 203a90c:	e0bffd17 	ldw	r2,-12(fp)
 203a910:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = Yes\n");
 203a914:	01008174 	movhi	r4,517
 203a918:	213fe004 	addi	r4,r4,-128
 203a91c:	20381e40 	call	20381e4 <no_printf>
                tse_dprintf(6, "INFO    : Number of channel        = %d\n", pmac_group->channel);
 203a920:	e0bffd17 	ldw	r2,-12(fp)
 203a924:	10800003 	ldbu	r2,0(r2)
 203a928:	10803fcc 	andi	r2,r2,255
 203a92c:	01008174 	movhi	r4,517
 203a930:	213feb04 	addi	r4,r4,-84
 203a934:	100b883a 	mov	r5,r2
 203a938:	20381e40 	call	20381e4 <no_printf>
            	tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 203a93c:	01008174 	movhi	r4,517
 203a940:	213ff604 	addi	r4,r4,-40
 203a944:	20381e40 	call	20381e4 <no_printf>
 203a948:	00001f06 	br	203a9c8 <alt_tse_mac_group_init+0x184>
            }
            else if(psys->tse_mdio_shared) {
 203a94c:	e0bfff17 	ldw	r2,-4(fp)
 203a950:	10800343 	ldbu	r2,13(r2)
 203a954:	10803fcc 	andi	r2,r2,255
 203a958:	10001226 	beq	r2,zero,203a9a4 <alt_tse_mac_group_init+0x160>
                pmac_group->channel = psys->tse_number_of_mac_mdio_shared;
 203a95c:	e0bfff17 	ldw	r2,-4(fp)
 203a960:	10c00383 	ldbu	r3,14(r2)
 203a964:	e0bffd17 	ldw	r2,-12(fp)
 203a968:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 203a96c:	01008174 	movhi	r4,517
 203a970:	21000104 	addi	r4,r4,4
 203a974:	20381e40 	call	20381e4 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = Yes\n");
 203a978:	01008174 	movhi	r4,517
 203a97c:	213ff604 	addi	r4,r4,-40
 203a980:	20381e40 	call	20381e4 <no_printf>
                tse_dprintf(6, "INFO    : Number of MAC Share MDIO = %d\n", pmac_group->channel);
 203a984:	e0bffd17 	ldw	r2,-12(fp)
 203a988:	10800003 	ldbu	r2,0(r2)
 203a98c:	10803fcc 	andi	r2,r2,255
 203a990:	01008174 	movhi	r4,517
 203a994:	21000c04 	addi	r4,r4,48
 203a998:	100b883a 	mov	r5,r2
 203a99c:	20381e40 	call	20381e4 <no_printf>
 203a9a0:	00000906 	br	203a9c8 <alt_tse_mac_group_init+0x184>
            }
            else {
                pmac_group->channel = 1;
 203a9a4:	e0bffd17 	ldw	r2,-12(fp)
 203a9a8:	00c00044 	movi	r3,1
 203a9ac:	10c00005 	stb	r3,0(r2)
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
 203a9b0:	01008174 	movhi	r4,517
 203a9b4:	21000104 	addi	r4,r4,4
 203a9b8:	20381e40 	call	20381e4 <no_printf>
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
 203a9bc:	01008174 	movhi	r4,517
 203a9c0:	21001704 	addi	r4,r4,92
 203a9c4:	20381e40 	call	20381e4 <no_printf>
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 203a9c8:	e03ffc45 	stb	zero,-15(fp)
 203a9cc:	00012006 	br	203ae50 <alt_tse_mac_group_init+0x60c>
                /* Allocate memory for the structure */
                pmac_info = (alt_tse_mac_info *) malloc(sizeof(alt_tse_mac_info));
 203a9d0:	01000404 	movi	r4,16
 203a9d4:	204bd440 	call	204bd44 <malloc>
 203a9d8:	e0bffe15 	stw	r2,-8(fp)
                if(!pmac_info) {
 203a9dc:	e0bffe17 	ldw	r2,-8(fp)
 203a9e0:	10000a1e 	bne	r2,zero,203aa0c <alt_tse_mac_group_init+0x1c8>
                    tse_dprintf(1, "ERROR   : Unable to allocate memory for MAC Group[%d]->pmac_info[%d]\n", mac_group_count, j);
 203a9e4:	d0a0af43 	ldbu	r2,-32067(gp)
 203a9e8:	10c03fcc 	andi	r3,r2,255
 203a9ec:	e0bffc47 	ldb	r2,-15(fp)
 203a9f0:	01008174 	movhi	r4,517
 203a9f4:	21002204 	addi	r4,r4,136
 203a9f8:	180b883a 	mov	r5,r3
 203a9fc:	100d883a 	mov	r6,r2
 203aa00:	2006a240 	call	2006a24 <printf>
                    return ALTERA_TSE_MALLOC_FAILED;
 203aa04:	00bfffc4 	movi	r2,-1
 203aa08:	00013006 	br	203aecc <alt_tse_mac_group_init+0x688>
                }
                
                pmac_info->pmac_group = pmac_group;
 203aa0c:	e0bffe17 	ldw	r2,-8(fp)
 203aa10:	e0fffd17 	ldw	r3,-12(fp)
 203aa14:	10c00315 	stw	r3,12(r2)
                
                pmac_info->pphy_info = 0;
 203aa18:	e0bffe17 	ldw	r2,-8(fp)
 203aa1c:	10000115 	stw	zero,4(r2)
                
                pmac_info->psys_info = &tse_mac_device[i + j];
 203aa20:	e0fffc07 	ldb	r3,-16(fp)
 203aa24:	e0bffc47 	ldb	r2,-15(fp)
 203aa28:	1885883a 	add	r2,r3,r2
 203aa2c:	10c01224 	muli	r3,r2,72
 203aa30:	00808174 	movhi	r2,517
 203aa34:	108f7e04 	addi	r2,r2,15864
 203aa38:	1887883a 	add	r3,r3,r2
 203aa3c:	e0bffe17 	ldw	r2,-8(fp)
 203aa40:	10c00215 	stw	r3,8(r2)
                
                /* check to make sure the alt_tse_system_info defined correctly or has been defined */
                if((pmac_info->psys_info->tse_sgdma_tx == 0) || (pmac_info->psys_info->tse_sgdma_rx == 0)){                	
 203aa44:	e0bffe17 	ldw	r2,-8(fp)
 203aa48:	10800217 	ldw	r2,8(r2)
 203aa4c:	10800517 	ldw	r2,20(r2)
 203aa50:	10000426 	beq	r2,zero,203aa64 <alt_tse_mac_group_init+0x220>
 203aa54:	e0bffe17 	ldw	r2,-8(fp)
 203aa58:	10800217 	ldw	r2,8(r2)
 203aa5c:	10800617 	ldw	r2,24(r2)
 203aa60:	1000091e 	bne	r2,zero,203aa88 <alt_tse_mac_group_init+0x244>
                    tse_dprintf(2, "ERROR   : tse_mac_device[%d] does not defined correctly!\n", i + j);
 203aa64:	e0fffc07 	ldb	r3,-16(fp)
 203aa68:	e0bffc47 	ldb	r2,-15(fp)
 203aa6c:	1885883a 	add	r2,r3,r2
 203aa70:	01008174 	movhi	r4,517
 203aa74:	21003404 	addi	r4,r4,208
 203aa78:	100b883a 	mov	r5,r2
 203aa7c:	2006a240 	call	2006a24 <printf>
                    return ALTERA_TSE_SYSTEM_DEF_ERROR;
 203aa80:	00bfffc4 	movi	r2,-1
 203aa84:	00011106 	br	203aecc <alt_tse_mac_group_init+0x688>
                }
                
                /* MAC type detection */
                if(pmac_info->psys_info->tse_en_maclite) {
 203aa88:	e0bffe17 	ldw	r2,-8(fp)
 203aa8c:	10800217 	ldw	r2,8(r2)
 203aa90:	10800243 	ldbu	r2,9(r2)
 203aa94:	10803fcc 	andi	r2,r2,255
 203aa98:	10000d26 	beq	r2,zero,203aad0 <alt_tse_mac_group_init+0x28c>
                    if(pmac_info->psys_info->tse_maclite_gige) {
 203aa9c:	e0bffe17 	ldw	r2,-8(fp)
 203aaa0:	10800217 	ldw	r2,8(r2)
 203aaa4:	10800283 	ldbu	r2,10(r2)
 203aaa8:	10803fcc 	andi	r2,r2,255
 203aaac:	10000426 	beq	r2,zero,203aac0 <alt_tse_mac_group_init+0x27c>
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_1000;
 203aab0:	e0bffe17 	ldw	r2,-8(fp)
 203aab4:	00c00084 	movi	r3,2
 203aab8:	10c00005 	stb	r3,0(r2)
 203aabc:	00000606 	br	203aad8 <alt_tse_mac_group_init+0x294>
                    }
                    else {
                        pmac_info->mac_type = ALTERA_TSE_MACLITE_10_100;
 203aac0:	e0bffe17 	ldw	r2,-8(fp)
 203aac4:	00c00044 	movi	r3,1
 203aac8:	10c00005 	stb	r3,0(r2)
 203aacc:	00000206 	br	203aad8 <alt_tse_mac_group_init+0x294>
                    }
                }
                else {
                    pmac_info->mac_type = ALTERA_TSE_FULL_MAC;                    
 203aad0:	e0bffe17 	ldw	r2,-8(fp)
 203aad4:	10000005 	stb	zero,0(r2)
                }
                
                if((pmac_info->psys_info->tse_mdio_shared) && (!pmac_info->psys_info->tse_multichannel_mac)){
 203aad8:	e0bffe17 	ldw	r2,-8(fp)
 203aadc:	10800217 	ldw	r2,8(r2)
 203aae0:	10800343 	ldbu	r2,13(r2)
 203aae4:	10803fcc 	andi	r2,r2,255
 203aae8:	10006526 	beq	r2,zero,203ac80 <alt_tse_mac_group_init+0x43c>
 203aaec:	e0bffe17 	ldw	r2,-8(fp)
 203aaf0:	10800217 	ldw	r2,8(r2)
 203aaf4:	108002c3 	ldbu	r2,11(r2)
 203aaf8:	10803fcc 	andi	r2,r2,255
 203aafc:	1000601e 	bne	r2,zero,203ac80 <alt_tse_mac_group_init+0x43c>
                	tse_dprintf(6, "INFO    : MAC %2d Address           = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 203ab00:	e0fffc47 	ldb	r3,-15(fp)
 203ab04:	e0bffe17 	ldw	r2,-8(fp)
 203ab08:	10800217 	ldw	r2,8(r2)
 203ab0c:	10800017 	ldw	r2,0(r2)
 203ab10:	01008174 	movhi	r4,517
 203ab14:	21004304 	addi	r4,r4,268
 203ab18:	180b883a 	mov	r5,r3
 203ab1c:	100d883a 	mov	r6,r2
 203ab20:	20381e40 	call	20381e4 <no_printf>
                    tse_dprintf(6, "INFO    : MAC %2d Device            = tse_mac_device[%d]\n", j, i + j);
 203ab24:	e0fffc47 	ldb	r3,-15(fp)
 203ab28:	e13ffc07 	ldb	r4,-16(fp)
 203ab2c:	e0bffc47 	ldb	r2,-15(fp)
 203ab30:	2085883a 	add	r2,r4,r2
 203ab34:	01008174 	movhi	r4,517
 203ab38:	21004f04 	addi	r4,r4,316
 203ab3c:	180b883a 	mov	r5,r3
 203ab40:	100d883a 	mov	r6,r2
 203ab44:	20381e40 	call	20381e4 <no_printf>
                    
                	switch(pmac_info->mac_type) {
 203ab48:	e0bffe17 	ldw	r2,-8(fp)
 203ab4c:	10800003 	ldbu	r2,0(r2)
 203ab50:	10803fcc 	andi	r2,r2,255
 203ab54:	10c00060 	cmpeqi	r3,r2,1
 203ab58:	18000c1e 	bne	r3,zero,203ab8c <alt_tse_mac_group_init+0x348>
 203ab5c:	10c000a0 	cmpeqi	r3,r2,2
 203ab60:	1800021e 	bne	r3,zero,203ab6c <alt_tse_mac_group_init+0x328>
 203ab64:	10001126 	beq	r2,zero,203abac <alt_tse_mac_group_init+0x368>
 203ab68:	00001806 	br	203abcc <alt_tse_mac_group_init+0x388>
                        case ALTERA_TSE_MACLITE_1000:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "1000 Mbps Small MAC");
 203ab6c:	e0bffc47 	ldb	r2,-15(fp)
 203ab70:	01008174 	movhi	r4,517
 203ab74:	21005e04 	addi	r4,r4,376
 203ab78:	100b883a 	mov	r5,r2
 203ab7c:	01808174 	movhi	r6,517
 203ab80:	31806904 	addi	r6,r6,420
 203ab84:	20381e40 	call	20381e4 <no_printf>
                            break;
 203ab88:	00001706 	br	203abe8 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_MACLITE_10_100:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100 Mbps Small MAC");
 203ab8c:	e0bffc47 	ldb	r2,-15(fp)
 203ab90:	01008174 	movhi	r4,517
 203ab94:	21005e04 	addi	r4,r4,376
 203ab98:	100b883a 	mov	r5,r2
 203ab9c:	01808174 	movhi	r6,517
 203aba0:	31806e04 	addi	r6,r6,440
 203aba4:	20381e40 	call	20381e4 <no_printf>
                            break;
 203aba8:	00000f06 	br	203abe8 <alt_tse_mac_group_init+0x3a4>
                        case ALTERA_TSE_FULL_MAC:
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "10/100/1000 Ethernet MAC");
 203abac:	e0bffc47 	ldb	r2,-15(fp)
 203abb0:	01008174 	movhi	r4,517
 203abb4:	21005e04 	addi	r4,r4,376
 203abb8:	100b883a 	mov	r5,r2
 203abbc:	01808174 	movhi	r6,517
 203abc0:	31807404 	addi	r6,r6,464
 203abc4:	20381e40 	call	20381e4 <no_printf>
                            break;
 203abc8:	00000706 	br	203abe8 <alt_tse_mac_group_init+0x3a4>
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
 203abcc:	e0bffc47 	ldb	r2,-15(fp)
 203abd0:	01008174 	movhi	r4,517
 203abd4:	21005e04 	addi	r4,r4,376
 203abd8:	100b883a 	mov	r5,r2
 203abdc:	01808174 	movhi	r6,517
 203abe0:	31beac04 	addi	r6,r6,-1360
 203abe4:	20381e40 	call	20381e4 <no_printf>
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 203abe8:	e0bffe17 	ldw	r2,-8(fp)
 203abec:	10800217 	ldw	r2,8(r2)
 203abf0:	108003c3 	ldbu	r2,15(r2)
 203abf4:	10803fcc 	andi	r2,r2,255
 203abf8:	10008a26 	beq	r2,zero,203ae24 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d Enable            = %s\n", j, pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 203abfc:	e0fffc47 	ldb	r3,-15(fp)
 203ac00:	e0bffe17 	ldw	r2,-8(fp)
 203ac04:	10800217 	ldw	r2,8(r2)
 203ac08:	108003c3 	ldbu	r2,15(r2)
 203ac0c:	10803fcc 	andi	r2,r2,255
 203ac10:	10000326 	beq	r2,zero,203ac20 <alt_tse_mac_group_init+0x3dc>
 203ac14:	00808174 	movhi	r2,517
 203ac18:	10807b04 	addi	r2,r2,492
 203ac1c:	00000206 	br	203ac28 <alt_tse_mac_group_init+0x3e4>
 203ac20:	00808174 	movhi	r2,517
 203ac24:	10807c04 	addi	r2,r2,496
 203ac28:	01008174 	movhi	r4,517
 203ac2c:	21007d04 	addi	r4,r4,500
 203ac30:	180b883a 	mov	r5,r3
 203ac34:	100d883a 	mov	r6,r2
 203ac38:	20381e40 	call	20381e4 <no_printf>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
 203ac3c:	e0fffc47 	ldb	r3,-15(fp)
 203ac40:	e0bffe17 	ldw	r2,-8(fp)
 203ac44:	10800217 	ldw	r2,8(r2)
 203ac48:	10800403 	ldbu	r2,16(r2)
 203ac4c:	10803fcc 	andi	r2,r2,255
 203ac50:	10000326 	beq	r2,zero,203ac60 <alt_tse_mac_group_init+0x41c>
 203ac54:	00808174 	movhi	r2,517
 203ac58:	10807b04 	addi	r2,r2,492
 203ac5c:	00000206 	br	203ac68 <alt_tse_mac_group_init+0x424>
 203ac60:	00808174 	movhi	r2,517
 203ac64:	10807c04 	addi	r2,r2,496
 203ac68:	01008174 	movhi	r4,517
 203ac6c:	21008804 	addi	r4,r4,544
 203ac70:	180b883a 	mov	r5,r3
 203ac74:	100d883a 	mov	r6,r2
 203ac78:	20381e40 	call	20381e4 <no_printf>
                            break;
                        default :
                            tse_dprintf(6, "INFO    : MAC %2d Type              = %s\n", j, "Unknown");
                    }
                    
                    if(pmac_info->psys_info->tse_pcs_ena) {
 203ac7c:	00006906 	br	203ae24 <alt_tse_mac_group_init+0x5e0>
                        tse_dprintf(6, "INFO    : PCS %2d SGMII Enable      = %s\n", j, pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");                        
                    }
                }
                else {
                	/* display only once for all MAC, except shared MDIO MACs */
	                if(j == 0) {
 203ac80:	e0bffc47 	ldb	r2,-15(fp)
 203ac84:	1000411e 	bne	r2,zero,203ad8c <alt_tse_mac_group_init+0x548>
	                    switch(pmac_info->mac_type) {
 203ac88:	e0bffe17 	ldw	r2,-8(fp)
 203ac8c:	10800003 	ldbu	r2,0(r2)
 203ac90:	10803fcc 	andi	r2,r2,255
 203ac94:	10c00060 	cmpeqi	r3,r2,1
 203ac98:	18000a1e 	bne	r3,zero,203acc4 <alt_tse_mac_group_init+0x480>
 203ac9c:	10c000a0 	cmpeqi	r3,r2,2
 203aca0:	1800021e 	bne	r3,zero,203acac <alt_tse_mac_group_init+0x468>
 203aca4:	10000d26 	beq	r2,zero,203acdc <alt_tse_mac_group_init+0x498>
 203aca8:	00001206 	br	203acf4 <alt_tse_mac_group_init+0x4b0>
	                        case ALTERA_TSE_MACLITE_1000:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "1000 Mbps Small MAC");
 203acac:	01008174 	movhi	r4,517
 203acb0:	21009304 	addi	r4,r4,588
 203acb4:	01408174 	movhi	r5,517
 203acb8:	29406904 	addi	r5,r5,420
 203acbc:	20381e40 	call	20381e4 <no_printf>
	                            break;
 203acc0:	00001106 	br	203ad08 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_MACLITE_10_100:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100 Mbps Small MAC");
 203acc4:	01008174 	movhi	r4,517
 203acc8:	21009304 	addi	r4,r4,588
 203accc:	01408174 	movhi	r5,517
 203acd0:	29406e04 	addi	r5,r5,440
 203acd4:	20381e40 	call	20381e4 <no_printf>
	                            break;
 203acd8:	00000b06 	br	203ad08 <alt_tse_mac_group_init+0x4c4>
	                        case ALTERA_TSE_FULL_MAC:
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "10/100/1000 Ethernet MAC");
 203acdc:	01008174 	movhi	r4,517
 203ace0:	21009304 	addi	r4,r4,588
 203ace4:	01408174 	movhi	r5,517
 203ace8:	29407404 	addi	r5,r5,464
 203acec:	20381e40 	call	20381e4 <no_printf>
	                            break;
 203acf0:	00000506 	br	203ad08 <alt_tse_mac_group_init+0x4c4>
	                        default :
	                            tse_dprintf(6, "INFO    : MAC Type                 = %s\n", "Unknown");
 203acf4:	01008174 	movhi	r4,517
 203acf8:	21009304 	addi	r4,r4,588
 203acfc:	01408174 	movhi	r5,517
 203ad00:	297eac04 	addi	r5,r5,-1360
 203ad04:	20381e40 	call	20381e4 <no_printf>
	                    }
	                    
	                    if(pmac_info->psys_info->tse_pcs_ena) {
 203ad08:	e0bffe17 	ldw	r2,-8(fp)
 203ad0c:	10800217 	ldw	r2,8(r2)
 203ad10:	108003c3 	ldbu	r2,15(r2)
 203ad14:	10803fcc 	andi	r2,r2,255
 203ad18:	10001c26 	beq	r2,zero,203ad8c <alt_tse_mac_group_init+0x548>
	                        tse_dprintf(6, "INFO    : PCS Enable               = %s\n", pmac_info->psys_info->tse_pcs_ena ? "Yes" : "No");
 203ad1c:	e0bffe17 	ldw	r2,-8(fp)
 203ad20:	10800217 	ldw	r2,8(r2)
 203ad24:	108003c3 	ldbu	r2,15(r2)
 203ad28:	10803fcc 	andi	r2,r2,255
 203ad2c:	10000326 	beq	r2,zero,203ad3c <alt_tse_mac_group_init+0x4f8>
 203ad30:	00808174 	movhi	r2,517
 203ad34:	10807b04 	addi	r2,r2,492
 203ad38:	00000206 	br	203ad44 <alt_tse_mac_group_init+0x500>
 203ad3c:	00808174 	movhi	r2,517
 203ad40:	10807c04 	addi	r2,r2,496
 203ad44:	01008174 	movhi	r4,517
 203ad48:	21009e04 	addi	r4,r4,632
 203ad4c:	100b883a 	mov	r5,r2
 203ad50:	20381e40 	call	20381e4 <no_printf>
	                        tse_dprintf(6, "INFO    : PCS SGMII Enable         = %s\n", pmac_info->psys_info->tse_pcs_sgmii ? "Yes" : "No");	                        
 203ad54:	e0bffe17 	ldw	r2,-8(fp)
 203ad58:	10800217 	ldw	r2,8(r2)
 203ad5c:	10800403 	ldbu	r2,16(r2)
 203ad60:	10803fcc 	andi	r2,r2,255
 203ad64:	10000326 	beq	r2,zero,203ad74 <alt_tse_mac_group_init+0x530>
 203ad68:	00808174 	movhi	r2,517
 203ad6c:	10807b04 	addi	r2,r2,492
 203ad70:	00000206 	br	203ad7c <alt_tse_mac_group_init+0x538>
 203ad74:	00808174 	movhi	r2,517
 203ad78:	10807c04 	addi	r2,r2,496
 203ad7c:	01008174 	movhi	r4,517
 203ad80:	2100a904 	addi	r4,r4,676
 203ad84:	100b883a 	mov	r5,r2
 203ad88:	20381e40 	call	20381e4 <no_printf>
	                    }
	                }
	                
                	if(pmac_info->psys_info->tse_multichannel_mac) {
 203ad8c:	e0bffe17 	ldw	r2,-8(fp)
 203ad90:	10800217 	ldw	r2,8(r2)
 203ad94:	108002c3 	ldbu	r2,11(r2)
 203ad98:	10803fcc 	andi	r2,r2,255
 203ad9c:	10001326 	beq	r2,zero,203adec <alt_tse_mac_group_init+0x5a8>
                		tse_dprintf(6, "INFO    : Channel %2d Address       = 0x%08x\n", j, (int) pmac_info->psys_info->tse_mac_base);
 203ada0:	e0fffc47 	ldb	r3,-15(fp)
 203ada4:	e0bffe17 	ldw	r2,-8(fp)
 203ada8:	10800217 	ldw	r2,8(r2)
 203adac:	10800017 	ldw	r2,0(r2)
 203adb0:	01008174 	movhi	r4,517
 203adb4:	2100b404 	addi	r4,r4,720
 203adb8:	180b883a 	mov	r5,r3
 203adbc:	100d883a 	mov	r6,r2
 203adc0:	20381e40 	call	20381e4 <no_printf>
	                    tse_dprintf(6, "INFO    : Channel %2d Device        = tse_mac_device[%d]\n", j, i + j);
 203adc4:	e0fffc47 	ldb	r3,-15(fp)
 203adc8:	e13ffc07 	ldb	r4,-16(fp)
 203adcc:	e0bffc47 	ldb	r2,-15(fp)
 203add0:	2085883a 	add	r2,r4,r2
 203add4:	01008174 	movhi	r4,517
 203add8:	2100c004 	addi	r4,r4,768
 203addc:	180b883a 	mov	r5,r3
 203ade0:	100d883a 	mov	r6,r2
 203ade4:	20381e40 	call	20381e4 <no_printf>
 203ade8:	00000e06 	br	203ae24 <alt_tse_mac_group_init+0x5e0>
	            	}                
	                else {
	                    tse_dprintf(6, "INFO    : MAC Address              = 0x%08x\n", (int) pmac_info->psys_info->tse_mac_base);
 203adec:	e0bffe17 	ldw	r2,-8(fp)
 203adf0:	10800217 	ldw	r2,8(r2)
 203adf4:	10800017 	ldw	r2,0(r2)
 203adf8:	01008174 	movhi	r4,517
 203adfc:	2100cf04 	addi	r4,r4,828
 203ae00:	100b883a 	mov	r5,r2
 203ae04:	20381e40 	call	20381e4 <no_printf>
	                    tse_dprintf(6, "INFO    : MAC Device               = tse_mac_device[%d]\n", i + j);
 203ae08:	e0fffc07 	ldb	r3,-16(fp)
 203ae0c:	e0bffc47 	ldb	r2,-15(fp)
 203ae10:	1885883a 	add	r2,r3,r2
 203ae14:	01008174 	movhi	r4,517
 203ae18:	2100db04 	addi	r4,r4,876
 203ae1c:	100b883a 	mov	r5,r2
 203ae20:	20381e40 	call	20381e4 <no_printf>
	                }
                }
                
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
 203ae24:	e0bffc47 	ldb	r2,-15(fp)
 203ae28:	e0fffd17 	ldw	r3,-12(fp)
 203ae2c:	10800044 	addi	r2,r2,1
 203ae30:	1085883a 	add	r2,r2,r2
 203ae34:	1085883a 	add	r2,r2,r2
 203ae38:	1885883a 	add	r2,r3,r2
 203ae3c:	e0fffe17 	ldw	r3,-8(fp)
 203ae40:	10c00015 	stw	r3,0(r2)
                pmac_group->channel = 1;
                tse_dprintf(6, "INFO    : Multi Channel            = No\n");
                tse_dprintf(6, "INFO    : MDIO Shared              = No\n");
            }
            
            for(j = 0; j < pmac_group->channel; j++) {
 203ae44:	e0bffc43 	ldbu	r2,-15(fp)
 203ae48:	10800044 	addi	r2,r2,1
 203ae4c:	e0bffc45 	stb	r2,-15(fp)
 203ae50:	e0fffc47 	ldb	r3,-15(fp)
 203ae54:	e0bffd17 	ldw	r2,-12(fp)
 203ae58:	10800003 	ldbu	r2,0(r2)
 203ae5c:	10803fcc 	andi	r2,r2,255
 203ae60:	18bedb16 	blt	r3,r2,203a9d0 <alt_tse_mac_group_init+0x18c>
                /* store the pointer in MAC group variable for the detected channel */
                pmac_group->pmac_info[j] = pmac_info;
            }
            
            /* store the pointer in global variable */
            pmac_groups[mac_group_count] = pmac_group;
 203ae64:	d0a0af43 	ldbu	r2,-32067(gp)
 203ae68:	10803fcc 	andi	r2,r2,255
 203ae6c:	00c09934 	movhi	r3,612
 203ae70:	18f76d04 	addi	r3,r3,-8780
 203ae74:	1085883a 	add	r2,r2,r2
 203ae78:	1085883a 	add	r2,r2,r2
 203ae7c:	1885883a 	add	r2,r3,r2
 203ae80:	e0fffd17 	ldw	r3,-12(fp)
 203ae84:	10c00015 	stw	r3,0(r2)
            
            mac_group_count++;
 203ae88:	d0a0af43 	ldbu	r2,-32067(gp)
 203ae8c:	10800044 	addi	r2,r2,1
 203ae90:	d0a0af45 	stb	r2,-32067(gp)

            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
 203ae94:	e0bffd17 	ldw	r2,-12(fp)
 203ae98:	10c00003 	ldbu	r3,0(r2)
 203ae9c:	e0bffc03 	ldbu	r2,-16(fp)
 203aea0:	1885883a 	add	r2,r3,r2
 203aea4:	10bfffc4 	addi	r2,r2,-1
 203aea8:	e0bffc05 	stb	r2,-16(fp)

    /* reset number of MAC group */
    mac_group_count = 0;
    
    /* loop through every alt_tse_system_info structure */
    for(i = 0; i < max_mac_system; i++) {
 203aeac:	e0bffc03 	ldbu	r2,-16(fp)
 203aeb0:	10800044 	addi	r2,r2,1
 203aeb4:	e0bffc05 	stb	r2,-16(fp)
 203aeb8:	e0fffc07 	ldb	r3,-16(fp)
 203aebc:	d0a04f03 	ldbu	r2,-32452(gp)
 203aec0:	10803fcc 	andi	r2,r2,255
 203aec4:	18be6916 	blt	r3,r2,203a86c <alt_tse_mac_group_init+0x28>
            /* skip for subsequent Multi-channel MAC */
            i += (pmac_group->channel - 1);
                        
        }
    }
    return SUCCESS;
 203aec8:	0005883a 	mov	r2,zero
}
 203aecc:	e037883a 	mov	sp,fp
 203aed0:	dfc00117 	ldw	ra,4(sp)
 203aed4:	df000017 	ldw	fp,0(sp)
 203aed8:	dec00204 	addi	sp,sp,8
 203aedc:	f800283a 	ret

0203aee0 <alt_tse_mac_get_phy>:
/* @Function Description: Store information of all the PHYs connected to MAC to phy_list
 * @API Type:         Internal
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @return            Number of PHY not in profile, return ALTERA_TSE_MALLOC_FAILED if memory allocation failed
 */
alt_32 alt_tse_mac_get_phy(alt_tse_mac_group *pmac_group) {
 203aee0:	deffed04 	addi	sp,sp,-76
 203aee4:	dfc01215 	stw	ra,72(sp)
 203aee8:	df001115 	stw	fp,68(sp)
 203aeec:	df001104 	addi	fp,sp,68
 203aef0:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 phyid; 
	alt_32 phyid2 = 0;
 203aef4:	e03ff515 	stw	zero,-44(fp)
    alt_u8 revision_number;

    alt_32 i;

    alt_u8 is_phy_in_profile;
    alt_32 return_value = 0;
 203aef8:	e03ff315 	stw	zero,-52(fp)
    
    alt_8 phy_info_count = 0;
 203aefc:	e03ff405 	stb	zero,-48(fp)
    
    alt_tse_phy_info *pphy = 0;
 203af00:	e03ff615 	stw	zero,-40(fp)
    alt_tse_mac_info *pmac_info = 0;
 203af04:	e03ff715 	stw	zero,-36(fp)
    alt_tse_system_info *psys = 0;
 203af08:	e03ff815 	stw	zero,-32(fp)
    
    np_tse_mac *pmac_group_base = (np_tse_mac *) pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203af0c:	e0bfff17 	ldw	r2,-4(fp)
 203af10:	10800117 	ldw	r2,4(r2)
 203af14:	10800217 	ldw	r2,8(r2)
 203af18:	10800017 	ldw	r2,0(r2)
 203af1c:	e0bff915 	stw	r2,-28(fp)
            
    /* Record previous MDIO address, to be restored at the end of function */
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 203af20:	e0bff917 	ldw	r2,-28(fp)
 203af24:	10801004 	addi	r2,r2,64
 203af28:	10800037 	ldwio	r2,0(r2)
 203af2c:	e0bffa15 	stw	r2,-24(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203af30:	e13fff17 	ldw	r4,-4(fp)
 203af34:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203af38:	e0bffb05 	stb	r2,-20(fp)
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 203af3c:	e03ff005 	stb	zero,-64(fp)
 203af40:	0000ca06 	br	203b26c <alt_tse_mac_get_phy+0x38c>
    {        
        IOWR(&pmac_group_base->MDIO_ADDR1, 0, phyadd);
 203af44:	e0bff917 	ldw	r2,-28(fp)
 203af48:	10801004 	addi	r2,r2,64
 203af4c:	e0fff003 	ldbu	r3,-64(fp)
 203af50:	10c00035 	stwio	r3,0(r2)
        phyid = IORD(&pmac_group_base->mdio1.PHY_ID1,0);     // read PHY ID
 203af54:	e0bff917 	ldw	r2,-28(fp)
 203af58:	1080a204 	addi	r2,r2,648
 203af5c:	10800037 	ldwio	r2,0(r2)
 203af60:	e0bffc15 	stw	r2,-16(fp)
        phyid2 = IORD(&pmac_group_base->mdio1.PHY_ID2,0);     // read PHY ID
 203af64:	e0bff917 	ldw	r2,-28(fp)
 203af68:	1080a304 	addi	r2,r2,652
 203af6c:	10800037 	ldwio	r2,0(r2)
 203af70:	e0bff515 	stw	r2,-44(fp)
        
        /* PHY found */
        if (phyid != phyid2)
 203af74:	e0fffc17 	ldw	r3,-16(fp)
 203af78:	e0bff517 	ldw	r2,-44(fp)
 203af7c:	1880b826 	beq	r3,r2,203b260 <alt_tse_mac_get_phy+0x380>
        {
            pphy = (alt_tse_phy_info *) malloc(sizeof(alt_tse_phy_info));
 203af80:	01000704 	movi	r4,28
 203af84:	204bd440 	call	204bd44 <malloc>
 203af88:	e0bff615 	stw	r2,-40(fp)
            if(!pphy) {
 203af8c:	e0bff617 	ldw	r2,-40(fp)
 203af90:	1000091e 	bne	r2,zero,203afb8 <alt_tse_mac_get_phy+0xd8>
                tse_dprintf(1, "ERROR   : Unable to allocate memory for phy_info[%d.%d]\n", mac_group_index, phy_info_count);
 203af94:	e0fffb07 	ldb	r3,-20(fp)
 203af98:	e0bff407 	ldb	r2,-48(fp)
 203af9c:	01008174 	movhi	r4,517
 203afa0:	2100ea04 	addi	r4,r4,936
 203afa4:	180b883a 	mov	r5,r3
 203afa8:	100d883a 	mov	r6,r2
 203afac:	2006a240 	call	2006a24 <printf>
                return ALTERA_TSE_MALLOC_FAILED;
 203afb0:	00bfffc4 	movi	r2,-1
 203afb4:	0000cc06 	br	203b2e8 <alt_tse_mac_get_phy+0x408>
            }
            
            /* store PHY address */
            pphy->mdio_address = phyadd;
 203afb8:	e0bff617 	ldw	r2,-40(fp)
 203afbc:	e0fff003 	ldbu	r3,-64(fp)
 203afc0:	10c00005 	stb	r3,0(r2)

            /* get oui, model number, and revision number from PHYID and PHYID2 */
            oui = (phyid << 6) | ((phyid2 >> 10) & 0x3f);
 203afc4:	e0bffc17 	ldw	r2,-16(fp)
 203afc8:	100691ba 	slli	r3,r2,6
 203afcc:	e0bff517 	ldw	r2,-44(fp)
 203afd0:	1005d2ba 	srai	r2,r2,10
 203afd4:	10800fcc 	andi	r2,r2,63
 203afd8:	1884b03a 	or	r2,r3,r2
 203afdc:	e0bffd15 	stw	r2,-12(fp)
            model_number = (phyid2 >> 4) & 0x3f;
 203afe0:	e0bff517 	ldw	r2,-44(fp)
 203afe4:	1005d13a 	srai	r2,r2,4
 203afe8:	10800fcc 	andi	r2,r2,63
 203afec:	e0bffe05 	stb	r2,-8(fp)
            revision_number = phyid2 & 0x0f;
 203aff0:	e0bff517 	ldw	r2,-44(fp)
 203aff4:	108003cc 	andi	r2,r2,15
 203aff8:	e0bffe45 	stb	r2,-7(fp)
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
 203affc:	e03ff205 	stb	zero,-56(fp)
            for(i = 0; i < phy_profile_count; i++) {
 203b000:	e03ff115 	stw	zero,-60(fp)
 203b004:	00003306 	br	203b0d4 <alt_tse_mac_get_phy+0x1f4>
                
                /* if PHY match with PHY in profile */
                if((pphy_profiles[i]->oui == oui) && (pphy_profiles[i]->model_number == model_number))
 203b008:	00c09934 	movhi	r3,612
 203b00c:	18f77104 	addi	r3,r3,-8764
 203b010:	e0bff117 	ldw	r2,-60(fp)
 203b014:	1085883a 	add	r2,r2,r2
 203b018:	1085883a 	add	r2,r2,r2
 203b01c:	1885883a 	add	r2,r3,r2
 203b020:	10800017 	ldw	r2,0(r2)
 203b024:	10c01417 	ldw	r3,80(r2)
 203b028:	e0bffd17 	ldw	r2,-12(fp)
 203b02c:	1880261e 	bne	r3,r2,203b0c8 <alt_tse_mac_get_phy+0x1e8>
 203b030:	00c09934 	movhi	r3,612
 203b034:	18f77104 	addi	r3,r3,-8764
 203b038:	e0bff117 	ldw	r2,-60(fp)
 203b03c:	1085883a 	add	r2,r2,r2
 203b040:	1085883a 	add	r2,r2,r2
 203b044:	1885883a 	add	r2,r3,r2
 203b048:	10800017 	ldw	r2,0(r2)
 203b04c:	10801503 	ldbu	r2,84(r2)
 203b050:	10c03fcc 	andi	r3,r2,255
 203b054:	e0bffe03 	ldbu	r2,-8(fp)
 203b058:	18801b1e 	bne	r3,r2,203b0c8 <alt_tse_mac_get_phy+0x1e8>
                {
                    pphy->pphy_profile = pphy_profiles[i];
 203b05c:	00c09934 	movhi	r3,612
 203b060:	18f77104 	addi	r3,r3,-8764
 203b064:	e0bff117 	ldw	r2,-60(fp)
 203b068:	1085883a 	add	r2,r2,r2
 203b06c:	1085883a 	add	r2,r2,r2
 203b070:	1885883a 	add	r2,r3,r2
 203b074:	10c00017 	ldw	r3,0(r2)
 203b078:	e0bff617 	ldw	r2,-40(fp)
 203b07c:	10c00515 	stw	r3,20(r2)
                    
                    /* PHY found, add it to phy_list */
                    tse_dprintf(5, "INFO    : PHY %s found at PHY address 0x%02x of MAC Group[%d]\n", pphy_profiles[i]->name, phyadd, mac_group_index);
 203b080:	00c09934 	movhi	r3,612
 203b084:	18f77104 	addi	r3,r3,-8764
 203b088:	e0bff117 	ldw	r2,-60(fp)
 203b08c:	1085883a 	add	r2,r2,r2
 203b090:	1085883a 	add	r2,r2,r2
 203b094:	1885883a 	add	r2,r3,r2
 203b098:	10800017 	ldw	r2,0(r2)
 203b09c:	100b883a 	mov	r5,r2
 203b0a0:	e0fff003 	ldbu	r3,-64(fp)
 203b0a4:	e0bffb07 	ldb	r2,-20(fp)
 203b0a8:	01008174 	movhi	r4,517
 203b0ac:	2100f904 	addi	r4,r4,996
 203b0b0:	180d883a 	mov	r6,r3
 203b0b4:	100f883a 	mov	r7,r2
 203b0b8:	2006a240 	call	2006a24 <printf>
                    is_phy_in_profile = 1;
 203b0bc:	00800044 	movi	r2,1
 203b0c0:	e0bff205 	stb	r2,-56(fp)
                    break;
 203b0c4:	00000706 	br	203b0e4 <alt_tse_mac_get_phy+0x204>
            model_number = (phyid2 >> 4) & 0x3f;
            revision_number = phyid2 & 0x0f;
			
            /* map the PHY with PHY in profile */
            is_phy_in_profile = 0;
            for(i = 0; i < phy_profile_count; i++) {
 203b0c8:	e0bff117 	ldw	r2,-60(fp)
 203b0cc:	10800044 	addi	r2,r2,1
 203b0d0:	e0bff115 	stw	r2,-60(fp)
 203b0d4:	d0a0af03 	ldbu	r2,-32068(gp)
 203b0d8:	10803fcc 	andi	r2,r2,255
 203b0dc:	e0fff117 	ldw	r3,-60(fp)
 203b0e0:	18bfc916 	blt	r3,r2,203b008 <alt_tse_mac_get_phy+0x128>
                    is_phy_in_profile = 1;
                    break;
                }
            }
            /* PHY not found in PHY profile */
            if(is_phy_in_profile == 0) {
 203b0e4:	e0bff203 	ldbu	r2,-56(fp)
 203b0e8:	10000f1e 	bne	r2,zero,203b128 <alt_tse_mac_get_phy+0x248>
                pphy->pphy_profile = 0;
 203b0ec:	e0bff617 	ldw	r2,-40(fp)
 203b0f0:	10000515 	stw	zero,20(r2)
                tse_dprintf(3, "WARNING : Unknown PHY found at PHY address 0x%02x of MAC Group[%d]\n", phyadd, mac_group_index);
 203b0f4:	e0fff003 	ldbu	r3,-64(fp)
 203b0f8:	e0bffb07 	ldb	r2,-20(fp)
 203b0fc:	01008174 	movhi	r4,517
 203b100:	21010904 	addi	r4,r4,1060
 203b104:	180b883a 	mov	r5,r3
 203b108:	100d883a 	mov	r6,r2
 203b10c:	2006a240 	call	2006a24 <printf>
                tse_dprintf(3, "WARNING : Please add PHY information to PHY profile\n");
 203b110:	01008174 	movhi	r4,517
 203b114:	21011a04 	addi	r4,r4,1128
 203b118:	2006cb40 	call	2006cb4 <puts>
                return_value++;
 203b11c:	e0bff317 	ldw	r2,-52(fp)
 203b120:	10800044 	addi	r2,r2,1
 203b124:	e0bff315 	stw	r2,-52(fp)
            }
            
            tse_dprintf(6, "INFO    : PHY OUI             =  0x%06x\n", (int) oui);
 203b128:	e0bffd17 	ldw	r2,-12(fp)
 203b12c:	01008174 	movhi	r4,517
 203b130:	21012704 	addi	r4,r4,1180
 203b134:	100b883a 	mov	r5,r2
 203b138:	20381e40 	call	20381e4 <no_printf>
            tse_dprintf(6, "INFO    : PHY Model Number    =  0x%02x\n", model_number);
 203b13c:	e0bffe03 	ldbu	r2,-8(fp)
 203b140:	01008174 	movhi	r4,517
 203b144:	21013204 	addi	r4,r4,1224
 203b148:	100b883a 	mov	r5,r2
 203b14c:	20381e40 	call	20381e4 <no_printf>
            tse_dprintf(6, "INFO    : PHY Revision Number =  0x%01x\n", revision_number);
 203b150:	e0bffe43 	ldbu	r2,-7(fp)
 203b154:	01008174 	movhi	r4,517
 203b158:	21013d04 	addi	r4,r4,1268
 203b15c:	100b883a 	mov	r5,r2
 203b160:	20381e40 	call	20381e4 <no_printf>
            
            /* map the detected PHY to connected MAC */
            if(alt_tse_mac_associate_phy(pmac_group, pphy) == TSE_PHY_MAP_SUCCESS) {
 203b164:	e13fff17 	ldw	r4,-4(fp)
 203b168:	e17ff617 	ldw	r5,-40(fp)
 203b16c:	203b2fc0 	call	203b2fc <alt_tse_mac_associate_phy>
 203b170:	1000351e 	bne	r2,zero,203b248 <alt_tse_mac_get_phy+0x368>
            	
            	pmac_info = pphy->pmac_info;
 203b174:	e0bff617 	ldw	r2,-40(fp)
 203b178:	10800617 	ldw	r2,24(r2)
 203b17c:	e0bff715 	stw	r2,-36(fp)
            	psys = pmac_info->psys_info;
 203b180:	e0bff717 	ldw	r2,-36(fp)
 203b184:	10800217 	ldw	r2,8(r2)
 203b188:	e0bff815 	stw	r2,-32(fp)
            	
            	/* Disable PHY loopback to allow Auto-Negotiation completed */
    	        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1, 0);   // disable PHY loopback
 203b18c:	d8000015 	stw	zero,0(sp)
 203b190:	e13ff617 	ldw	r4,-40(fp)
 203b194:	000b883a 	mov	r5,zero
 203b198:	01800384 	movi	r6,14
 203b19c:	01c00044 	movi	r7,1
 203b1a0:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
				
				/* Reset auto-negotiation advertisement */
				alt_tse_phy_set_adv_1000(pphy, 1);
 203b1a4:	e13ff617 	ldw	r4,-40(fp)
 203b1a8:	01400044 	movi	r5,1
 203b1ac:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
				alt_tse_phy_set_adv_100(pphy, 1);
 203b1b0:	e13ff617 	ldw	r4,-40(fp)
 203b1b4:	01400044 	movi	r5,1
 203b1b8:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
				alt_tse_phy_set_adv_10(pphy, 1);
 203b1bc:	e13ff617 	ldw	r4,-40(fp)
 203b1c0:	01400044 	movi	r5,1
 203b1c4:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
            	            	
	            /* check link connection for this PHY */
	            alt_tse_phy_restart_an(pphy, ALTERA_CHECKLINK_TIMEOUT_THRESHOLD);
 203b1c8:	e13ff617 	ldw	r4,-40(fp)
 203b1cc:	014003f4 	movhi	r5,15
 203b1d0:	29509004 	addi	r5,r5,16960
 203b1d4:	203b77c0 	call	203b77c <alt_tse_phy_restart_an>
	            
	            /* Perform additional setting if there is any */
	            /* Profile specific */
	            if(pphy->pphy_profile) {
 203b1d8:	e0bff617 	ldw	r2,-40(fp)
 203b1dc:	10800517 	ldw	r2,20(r2)
 203b1e0:	10000f26 	beq	r2,zero,203b220 <alt_tse_mac_get_phy+0x340>
		            if(pphy->pphy_profile->phy_cfg) {
 203b1e4:	e0bff617 	ldw	r2,-40(fp)
 203b1e8:	10800517 	ldw	r2,20(r2)
 203b1ec:	10801717 	ldw	r2,92(r2)
 203b1f0:	10000b26 	beq	r2,zero,203b220 <alt_tse_mac_get_phy+0x340>
		                tse_dprintf(6, "INFO    : Applying additional PHY configuration of %s\n", pphy->pphy_profile->name);
 203b1f4:	e0bff617 	ldw	r2,-40(fp)
 203b1f8:	10800517 	ldw	r2,20(r2)
 203b1fc:	01008174 	movhi	r4,517
 203b200:	21014804 	addi	r4,r4,1312
 203b204:	100b883a 	mov	r5,r2
 203b208:	20381e40 	call	20381e4 <no_printf>
		                pphy->pphy_profile->phy_cfg(pmac_group_base);
 203b20c:	e0bff617 	ldw	r2,-40(fp)
 203b210:	10800517 	ldw	r2,20(r2)
 203b214:	10801717 	ldw	r2,92(r2)
 203b218:	e13ff917 	ldw	r4,-28(fp)
 203b21c:	103ee83a 	callr	r2
		            }
	            }
	            
	            /* Initialize PHY, call user's function pointer in alt_tse_system_info structure */
	            /* Individual PHY specific */
            	if(psys->tse_phy_cfg) {
 203b220:	e0bff817 	ldw	r2,-32(fp)
 203b224:	10801117 	ldw	r2,68(r2)
 203b228:	10000726 	beq	r2,zero,203b248 <alt_tse_mac_get_phy+0x368>
            		tse_dprintf(6, "INFO    : Applying additional user PHY configuration\n");
 203b22c:	01008174 	movhi	r4,517
 203b230:	21015604 	addi	r4,r4,1368
 203b234:	20381e40 	call	20381e4 <no_printf>
            		psys->tse_phy_cfg(pmac_group_base);
 203b238:	e0bff817 	ldw	r2,-32(fp)
 203b23c:	10801117 	ldw	r2,68(r2)
 203b240:	e13ff917 	ldw	r4,-28(fp)
 203b244:	103ee83a 	callr	r2
            	}
            }
            
            tse_dprintf(6, "\n");
 203b248:	01008174 	movhi	r4,517
 203b24c:	21016404 	addi	r4,r4,1424
 203b250:	20381e40 	call	20381e4 <no_printf>
	            
            phy_info_count++;
 203b254:	e0bff403 	ldbu	r2,-48(fp)
 203b258:	10800044 	addi	r2,r2,1
 203b25c:	e0bff405 	stb	r2,-48(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* loop all valid PHY address to look for connected PHY */
    for (phyadd = 0x00; phyadd < 0x20; phyadd++)
 203b260:	e0bff003 	ldbu	r2,-64(fp)
 203b264:	10800044 	addi	r2,r2,1
 203b268:	e0bff005 	stb	r2,-64(fp)
 203b26c:	e0bff003 	ldbu	r2,-64(fp)
 203b270:	10800830 	cmpltui	r2,r2,32
 203b274:	103f331e 	bne	r2,zero,203af44 <alt_tse_mac_get_phy+0x64>
            phy_info_count++;
        }
    }
    
    /* check to verify the number of connected PHY match the number of channel */
    if(pmac_group->channel != phy_info_count) {
 203b278:	e0bfff17 	ldw	r2,-4(fp)
 203b27c:	10800003 	ldbu	r2,0(r2)
 203b280:	10c03fcc 	andi	r3,r2,255
 203b284:	e0bff407 	ldb	r2,-48(fp)
 203b288:	18801226 	beq	r3,r2,203b2d4 <alt_tse_mac_get_phy+0x3f4>
        if(phy_info_count == 0) {
 203b28c:	e0bff407 	ldb	r2,-48(fp)
 203b290:	1000061e 	bne	r2,zero,203b2ac <alt_tse_mac_get_phy+0x3cc>
            tse_dprintf(2, "ERROR   : MAC Group[%d] - No PHY connected!\n", mac_group_index);
 203b294:	e0bffb07 	ldb	r2,-20(fp)
 203b298:	01008174 	movhi	r4,517
 203b29c:	21016504 	addi	r4,r4,1428
 203b2a0:	100b883a 	mov	r5,r2
 203b2a4:	2006a240 	call	2006a24 <printf>
 203b2a8:	00000a06 	br	203b2d4 <alt_tse_mac_get_phy+0x3f4>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Group[%d] - Number of PHY connected is not equal to the number of channel, Number of PHY : %d, Channel : %d\n", mac_group_index, phy_info_count, pmac_group->channel);
 203b2ac:	e17ffb07 	ldb	r5,-20(fp)
 203b2b0:	e0fff407 	ldb	r3,-48(fp)
 203b2b4:	e0bfff17 	ldw	r2,-4(fp)
 203b2b8:	10800003 	ldbu	r2,0(r2)
 203b2bc:	10803fcc 	andi	r2,r2,255
 203b2c0:	01008174 	movhi	r4,517
 203b2c4:	21017104 	addi	r4,r4,1476
 203b2c8:	180d883a 	mov	r6,r3
 203b2cc:	100f883a 	mov	r7,r2
 203b2d0:	2006a240 	call	2006a24 <printf>
        }
    }
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 203b2d4:	e0bff917 	ldw	r2,-28(fp)
 203b2d8:	10801004 	addi	r2,r2,64
 203b2dc:	e0fffa17 	ldw	r3,-24(fp)
 203b2e0:	10c00035 	stwio	r3,0(r2)
    
    return return_value;
 203b2e4:	e0bff317 	ldw	r2,-52(fp)
}
 203b2e8:	e037883a 	mov	sp,fp
 203b2ec:	dfc00117 	ldw	ra,4(sp)
 203b2f0:	df000017 	ldw	fp,0(sp)
 203b2f4:	dec00204 	addi	sp,sp,8
 203b2f8:	f800283a 	ret

0203b2fc <alt_tse_mac_associate_phy>:
 * @param pmac_group  Pointer to the TSE MAC grouping structure
 * @param pphy        Pointer to the TSE PHY info structure which hold information of PHY
 * @return            return TSE_PHY_MAP_ERROR if mapping error
 *                    return TSE_PHY_MAP_SUCCESS otherwise
 */
alt_32 alt_tse_mac_associate_phy(alt_tse_mac_group *pmac_group, alt_tse_phy_info *pphy) {
 203b2fc:	defff604 	addi	sp,sp,-40
 203b300:	dfc00915 	stw	ra,36(sp)
 203b304:	df000815 	stw	fp,32(sp)
 203b308:	df000804 	addi	fp,sp,32
 203b30c:	e13ffe15 	stw	r4,-8(fp)
 203b310:	e17fff15 	stw	r5,-4(fp)
    
	alt_32 i;
	alt_32 return_value = TSE_PHY_MAP_SUCCESS;
 203b314:	e03ff915 	stw	zero,-28(fp)
    
	alt_u8 is_mapped;

    alt_tse_system_info *psys = 0;
 203b318:	e03ffb15 	stw	zero,-20(fp)
    alt_tse_mac_info *pmac_info = 0;
 203b31c:	e03ffc15 	stw	zero,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 203b320:	e03ffd05 	stb	zero,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203b324:	e13ffe17 	ldw	r4,-8(fp)
 203b328:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203b32c:	e0bffd45 	stb	r2,-11(fp)
    alt_8 sys_info_index = 0;
 203b330:	e03ffd85 	stb	zero,-10(fp)
    
    is_mapped = 0;
 203b334:	e03ffa05 	stb	zero,-24(fp)
    
    for(i = 0; i < pmac_group->channel; i++) {
 203b338:	e03ff815 	stw	zero,-32(fp)
 203b33c:	00002b06 	br	203b3ec <alt_tse_mac_associate_phy+0xf0>
        pmac_info = pmac_group->pmac_info[i];
 203b340:	e0fffe17 	ldw	r3,-8(fp)
 203b344:	e0bff817 	ldw	r2,-32(fp)
 203b348:	10800044 	addi	r2,r2,1
 203b34c:	1085883a 	add	r2,r2,r2
 203b350:	1085883a 	add	r2,r2,r2
 203b354:	1885883a 	add	r2,r3,r2
 203b358:	10800017 	ldw	r2,0(r2)
 203b35c:	e0bffc15 	stw	r2,-16(fp)
        psys = pmac_info->psys_info;
 203b360:	e0bffc17 	ldw	r2,-16(fp)
 203b364:	10800217 	ldw	r2,8(r2)
 203b368:	e0bffb15 	stw	r2,-20(fp)
       
        /* map according to the PHY address in alt_tse_system_info.h */
        if(psys->tse_phy_mdio_address == pphy->mdio_address) {
 203b36c:	e0bffb17 	ldw	r2,-20(fp)
 203b370:	10c01017 	ldw	r3,64(r2)
 203b374:	e0bfff17 	ldw	r2,-4(fp)
 203b378:	10800003 	ldbu	r2,0(r2)
 203b37c:	10803fcc 	andi	r2,r2,255
 203b380:	1880171e 	bne	r3,r2,203b3e0 <alt_tse_mac_associate_phy+0xe4>
        	mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203b384:	e13ffc17 	ldw	r4,-16(fp)
 203b388:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203b38c:	e0bffd05 	stb	r2,-12(fp)
	        sys_info_index = alt_tse_get_system_index(psys);
 203b390:	e13ffb17 	ldw	r4,-20(fp)
 203b394:	20392ec0 	call	20392ec <alt_tse_get_system_index>
 203b398:	e0bffd85 	stb	r2,-10(fp)
	        
            pmac_info->pphy_info = pphy;
 203b39c:	e0bffc17 	ldw	r2,-16(fp)
 203b3a0:	e0ffff17 	ldw	r3,-4(fp)
 203b3a4:	10c00115 	stw	r3,4(r2)
            pphy->pmac_info = pmac_info;
 203b3a8:	e0bfff17 	ldw	r2,-4(fp)
 203b3ac:	e0fffc17 	ldw	r3,-16(fp)
 203b3b0:	10c00615 	stw	r3,24(r2)
            tse_dprintf(5, "INFO    : PHY[%d.%d] - Explicitly mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 203b3b4:	e17ffd47 	ldb	r5,-11(fp)
 203b3b8:	e0fffd07 	ldb	r3,-12(fp)
 203b3bc:	e0bffd87 	ldb	r2,-10(fp)
 203b3c0:	01008174 	movhi	r4,517
 203b3c4:	21019004 	addi	r4,r4,1600
 203b3c8:	180d883a 	mov	r6,r3
 203b3cc:	100f883a 	mov	r7,r2
 203b3d0:	2006a240 	call	2006a24 <printf>
            is_mapped = 1;
 203b3d4:	00800044 	movi	r2,1
 203b3d8:	e0bffa05 	stb	r2,-24(fp)
            break;
 203b3dc:	00000806 	br	203b400 <alt_tse_mac_associate_phy+0x104>
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    alt_8 sys_info_index = 0;
    
    is_mapped = 0;
    
    for(i = 0; i < pmac_group->channel; i++) {
 203b3e0:	e0bff817 	ldw	r2,-32(fp)
 203b3e4:	10800044 	addi	r2,r2,1
 203b3e8:	e0bff815 	stw	r2,-32(fp)
 203b3ec:	e0bffe17 	ldw	r2,-8(fp)
 203b3f0:	10800003 	ldbu	r2,0(r2)
 203b3f4:	10803fcc 	andi	r2,r2,255
 203b3f8:	e0fff817 	ldw	r3,-32(fp)
 203b3fc:	18bfd016 	blt	r3,r2,203b340 <alt_tse_mac_associate_phy+0x44>
            break;
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
 203b400:	e0bffa03 	ldbu	r2,-24(fp)
 203b404:	10003c1e 	bne	r2,zero,203b4f8 <alt_tse_mac_associate_phy+0x1fc>
        for(i = 0; i < pmac_group->channel; i++) {
 203b408:	e03ff815 	stw	zero,-32(fp)
 203b40c:	00003506 	br	203b4e4 <alt_tse_mac_associate_phy+0x1e8>
            pmac_info = pmac_group->pmac_info[i];
 203b410:	e0fffe17 	ldw	r3,-8(fp)
 203b414:	e0bff817 	ldw	r2,-32(fp)
 203b418:	10800044 	addi	r2,r2,1
 203b41c:	1085883a 	add	r2,r2,r2
 203b420:	1085883a 	add	r2,r2,r2
 203b424:	1885883a 	add	r2,r3,r2
 203b428:	10800017 	ldw	r2,0(r2)
 203b42c:	e0bffc15 	stw	r2,-16(fp)
            psys = pmac_info->psys_info;
 203b430:	e0bffc17 	ldw	r2,-16(fp)
 203b434:	10800217 	ldw	r2,8(r2)
 203b438:	e0bffb15 	stw	r2,-20(fp)
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
 203b43c:	e0bffb17 	ldw	r2,-20(fp)
 203b440:	10800517 	ldw	r2,20(r2)
 203b444:	10002326 	beq	r2,zero,203b4d4 <alt_tse_mac_associate_phy+0x1d8>
 203b448:	e0bffb17 	ldw	r2,-20(fp)
 203b44c:	10800617 	ldw	r2,24(r2)
 203b450:	10002026 	beq	r2,zero,203b4d4 <alt_tse_mac_associate_phy+0x1d8>
            	continue;
            }
            
            if(psys->tse_phy_mdio_address == TSE_PHY_AUTO_ADDRESS) {
 203b454:	e0bffb17 	ldw	r2,-20(fp)
 203b458:	10801017 	ldw	r2,64(r2)
 203b45c:	10bfffd8 	cmpnei	r2,r2,-1
 203b460:	10001d1e 	bne	r2,zero,203b4d8 <alt_tse_mac_associate_phy+0x1dc>
                mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203b464:	e13ffc17 	ldw	r4,-16(fp)
 203b468:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203b46c:	e0bffd05 	stb	r2,-12(fp)
                sys_info_index = alt_tse_get_system_index(psys);
 203b470:	e13ffb17 	ldw	r4,-20(fp)
 203b474:	20392ec0 	call	20392ec <alt_tse_get_system_index>
 203b478:	e0bffd85 	stb	r2,-10(fp)
                
                pmac_info->pphy_info = pphy;
 203b47c:	e0bffc17 	ldw	r2,-16(fp)
 203b480:	e0ffff17 	ldw	r3,-4(fp)
 203b484:	10c00115 	stw	r3,4(r2)
                pphy->pmac_info = pmac_info;
 203b488:	e0bfff17 	ldw	r2,-4(fp)
 203b48c:	e0fffc17 	ldw	r3,-16(fp)
 203b490:	10c00615 	stw	r3,24(r2)
                psys->tse_phy_mdio_address = pphy->mdio_address;
 203b494:	e0bfff17 	ldw	r2,-4(fp)
 203b498:	10800003 	ldbu	r2,0(r2)
 203b49c:	10c03fcc 	andi	r3,r2,255
 203b4a0:	e0bffb17 	ldw	r2,-20(fp)
 203b4a4:	10c01015 	stw	r3,64(r2)
                tse_dprintf(5, "INFO    : PHY[%d.%d] - Automatically mapped to tse_mac_device[%d]\n", mac_group_index, mac_info_index, sys_info_index);
 203b4a8:	e17ffd47 	ldb	r5,-11(fp)
 203b4ac:	e0fffd07 	ldb	r3,-12(fp)
 203b4b0:	e0bffd87 	ldb	r2,-10(fp)
 203b4b4:	01008174 	movhi	r4,517
 203b4b8:	2101a004 	addi	r4,r4,1664
 203b4bc:	180d883a 	mov	r6,r3
 203b4c0:	100f883a 	mov	r7,r2
 203b4c4:	2006a240 	call	2006a24 <printf>
                is_mapped = 1;
 203b4c8:	00800044 	movi	r2,1
 203b4cc:	e0bffa05 	stb	r2,-24(fp)
                break;
 203b4d0:	00000906 	br	203b4f8 <alt_tse_mac_associate_phy+0x1fc>
            pmac_info = pmac_group->pmac_info[i];
            psys = pmac_info->psys_info;
            
            /* alt_tse_system_info structure definition error */
            if((psys->tse_sgdma_tx == 0) || (psys->tse_sgdma_rx == 0)){
            	continue;
 203b4d4:	0001883a 	nop
        }
    }
    
    /* if not yet map, it will automatically mapped to the first TSE device encountered with tse_phy_mdio_address = TSE_PHY_AUTO_ADDRESS */
    if(is_mapped == 0) {
        for(i = 0; i < pmac_group->channel; i++) {
 203b4d8:	e0bff817 	ldw	r2,-32(fp)
 203b4dc:	10800044 	addi	r2,r2,1
 203b4e0:	e0bff815 	stw	r2,-32(fp)
 203b4e4:	e0bffe17 	ldw	r2,-8(fp)
 203b4e8:	10800003 	ldbu	r2,0(r2)
 203b4ec:	10803fcc 	andi	r2,r2,255
 203b4f0:	e0fff817 	ldw	r3,-32(fp)
 203b4f4:	18bfc616 	blt	r3,r2,203b410 <alt_tse_mac_associate_phy+0x114>
            }
        }
    }
    
    /* Still cannot find any matched MAC-PHY */
    if(is_mapped == 0) {
 203b4f8:	e0bffa03 	ldbu	r2,-24(fp)
 203b4fc:	1000091e 	bne	r2,zero,203b524 <alt_tse_mac_associate_phy+0x228>
    	pphy->pmac_info = 0;
 203b500:	e0bfff17 	ldw	r2,-4(fp)
 203b504:	10000615 	stw	zero,24(r2)
        tse_dprintf(2, "WARNING : PHY[%d.X] - Mapping of PHY to MAC failed! Make sure the PHY address is defined correctly in tse_mac_device[] structure, and number of PHYs connected is equivalent to number of channel\n", mac_group_index);
 203b508:	e0bffd47 	ldb	r2,-11(fp)
 203b50c:	01008174 	movhi	r4,517
 203b510:	2101b104 	addi	r4,r4,1732
 203b514:	100b883a 	mov	r5,r2
 203b518:	2006a240 	call	2006a24 <printf>
        return_value = TSE_PHY_MAP_ERROR;
 203b51c:	00bfffc4 	movi	r2,-1
 203b520:	e0bff915 	stw	r2,-28(fp)
    }
    
    return return_value;
 203b524:	e0bff917 	ldw	r2,-28(fp)
}
 203b528:	e037883a 	mov	sp,fp
 203b52c:	dfc00117 	ldw	ra,4(sp)
 203b530:	df000017 	ldw	fp,0(sp)
 203b534:	dec00204 	addi	sp,sp,8
 203b538:	f800283a 	ret

0203b53c <alt_tse_phy_cfg_pcs>:
/* @Function Description: Configure operating mode of Altera PCS if available
 * @API Type:           Internal
 * @param pmac_info     pointer to MAC info variable
 * @return              return SUCCESS
 */
alt_32 alt_tse_phy_cfg_pcs(alt_tse_mac_info *pmac_info) {
 203b53c:	defff804 	addi	sp,sp,-32
 203b540:	dfc00715 	stw	ra,28(sp)
 203b544:	df000615 	stw	fp,24(sp)
 203b548:	df000604 	addi	fp,sp,24
 203b54c:	e13fff15 	stw	r4,-4(fp)
    
    alt_tse_system_info *psys = pmac_info->psys_info;
 203b550:	e0bfff17 	ldw	r2,-4(fp)
 203b554:	10800217 	ldw	r2,8(r2)
 203b558:	e0bffa15 	stw	r2,-24(fp)
    np_tse_mac *pmac = (np_tse_mac *) psys->tse_mac_base;
 203b55c:	e0bffa17 	ldw	r2,-24(fp)
 203b560:	10800017 	ldw	r2,0(r2)
 203b564:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203b568:	e0bfff17 	ldw	r2,-4(fp)
 203b56c:	10800317 	ldw	r2,12(r2)
 203b570:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203b574:	e13fff17 	ldw	r4,-4(fp)
 203b578:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203b57c:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203b580:	e13ffc17 	ldw	r4,-16(fp)
 203b584:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203b588:	e0bffd45 	stb	r2,-11(fp)

    if(psys->tse_pcs_ena) {
 203b58c:	e0bffa17 	ldw	r2,-24(fp)
 203b590:	108003c3 	ldbu	r2,15(r2)
 203b594:	10803fcc 	andi	r2,r2,255
 203b598:	10002c26 	beq	r2,zero,203b64c <alt_tse_phy_cfg_pcs+0x110>
        tse_dprintf(5, "INFO    : PCS[%d.%d] - Configuring PCS operating mode\n", mac_group_index, mac_info_index);
 203b59c:	e0fffd47 	ldb	r3,-11(fp)
 203b5a0:	e0bffd07 	ldb	r2,-12(fp)
 203b5a4:	01008174 	movhi	r4,517
 203b5a8:	2101e204 	addi	r4,r4,1928
 203b5ac:	180b883a 	mov	r5,r3
 203b5b0:	100d883a 	mov	r6,r2
 203b5b4:	2006a240 	call	2006a24 <printf>
        
        alt_32 data = IORD(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE); 
 203b5b8:	e0bffb17 	ldw	r2,-20(fp)
 203b5bc:	10808004 	addi	r2,r2,512
 203b5c0:	10801404 	addi	r2,r2,80
 203b5c4:	10800037 	ldwio	r2,0(r2)
 203b5c8:	e0bffe15 	stw	r2,-8(fp)
        
        if(psys->tse_pcs_sgmii) {
 203b5cc:	e0bffa17 	ldw	r2,-24(fp)
 203b5d0:	10800403 	ldbu	r2,16(r2)
 203b5d4:	10803fcc 	andi	r2,r2,255
 203b5d8:	10000e26 	beq	r2,zero,203b614 <alt_tse_phy_cfg_pcs+0xd8>
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode enabled\n", mac_group_index, mac_info_index);
 203b5dc:	e0fffd47 	ldb	r3,-11(fp)
 203b5e0:	e0bffd07 	ldb	r2,-12(fp)
 203b5e4:	01008174 	movhi	r4,517
 203b5e8:	2101f004 	addi	r4,r4,1984
 203b5ec:	180b883a 	mov	r5,r3
 203b5f0:	100d883a 	mov	r6,r2
 203b5f4:	2006a240 	call	2006a24 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data | 0x03);
 203b5f8:	e0bffb17 	ldw	r2,-20(fp)
 203b5fc:	10808004 	addi	r2,r2,512
 203b600:	10801404 	addi	r2,r2,80
 203b604:	e0fffe17 	ldw	r3,-8(fp)
 203b608:	18c000d4 	ori	r3,r3,3
 203b60c:	10c00035 	stwio	r3,0(r2)
 203b610:	00000e06 	br	203b64c <alt_tse_phy_cfg_pcs+0x110>
            }
        else {
            tse_dprintf(5, "INFO    : PCS[%d.%d] - PCS SGMII mode disabled\n", mac_group_index, mac_info_index);
 203b614:	e0fffd47 	ldb	r3,-11(fp)
 203b618:	e0bffd07 	ldb	r2,-12(fp)
 203b61c:	01008174 	movhi	r4,517
 203b620:	2101fc04 	addi	r4,r4,2032
 203b624:	180b883a 	mov	r5,r3
 203b628:	100d883a 	mov	r6,r2
 203b62c:	2006a240 	call	2006a24 <printf>
            IOWR(&pmac->mdio0.CONTROL, ALTERA_TSE_PCS_IF_MODE, data & ~0x03);
 203b630:	e0bffb17 	ldw	r2,-20(fp)
 203b634:	10808004 	addi	r2,r2,512
 203b638:	10801404 	addi	r2,r2,80
 203b63c:	e13ffe17 	ldw	r4,-8(fp)
 203b640:	00ffff04 	movi	r3,-4
 203b644:	20c6703a 	and	r3,r4,r3
 203b648:	10c00035 	stwio	r3,0(r2)
        }
    }
    
    return SUCCESS;
 203b64c:	0005883a 	mov	r2,zero
}
 203b650:	e037883a 	mov	sp,fp
 203b654:	dfc00117 	ldw	ra,4(sp)
 203b658:	df000017 	ldw	fp,0(sp)
 203b65c:	dec00204 	addi	sp,sp,8
 203b660:	f800283a 	ret

0203b664 <alt_tse_phy_init>:
/* @Function Description: Detect and initialize all the PHYs connected
 * @API Type:   Internal
 * @param pmac  N/A
 * @return      SUCCESS
 */
alt_32 alt_tse_phy_init() {
 203b664:	defffb04 	addi	sp,sp,-20
 203b668:	dfc00415 	stw	ra,16(sp)
 203b66c:	df000315 	stw	fp,12(sp)
 203b670:	df000304 	addi	fp,sp,12
	alt_8 i = 0;
 203b674:	e03ffd05 	stb	zero,-12(fp)
	alt_8 j = 0;
 203b678:	e03ffd45 	stb	zero,-11(fp)
    
    alt_tse_mac_group *pmac_group = 0;
 203b67c:	e03ffe15 	stw	zero,-8(fp)
    alt_tse_mac_info *pmac_info = 0;
 203b680:	e03fff15 	stw	zero,-4(fp)
    
    /* add supported PHYs */
    alt_tse_phy_add_profile_default();
 203b684:	203a39c0 	call	203a39c <alt_tse_phy_add_profile_default>
    
    /* display PHY in profile */
    alt_tse_phy_print_profile();
 203b688:	203a6340 	call	203a634 <alt_tse_phy_print_profile>
    
    alt_tse_mac_group_init();
 203b68c:	203a8440 	call	203a844 <alt_tse_mac_group_init>
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 203b690:	e03ffd05 	stb	zero,-12(fp)
 203b694:	00002f06 	br	203b754 <alt_tse_phy_init+0xf0>
        pmac_group = pmac_groups[i];
 203b698:	e0bffd07 	ldb	r2,-12(fp)
 203b69c:	00c09934 	movhi	r3,612
 203b6a0:	18f76d04 	addi	r3,r3,-8780
 203b6a4:	1085883a 	add	r2,r2,r2
 203b6a8:	1085883a 	add	r2,r2,r2
 203b6ac:	1885883a 	add	r2,r3,r2
 203b6b0:	10800017 	ldw	r2,0(r2)
 203b6b4:	e0bffe15 	stw	r2,-8(fp)
        
        if(pmac_group->pmac_info[0]->psys_info->tse_use_mdio) {
 203b6b8:	e0bffe17 	ldw	r2,-8(fp)
 203b6bc:	10800117 	ldw	r2,4(r2)
 203b6c0:	10800217 	ldw	r2,8(r2)
 203b6c4:	10800203 	ldbu	r2,8(r2)
 203b6c8:	10803fcc 	andi	r2,r2,255
 203b6cc:	10000326 	beq	r2,zero,203b6dc <alt_tse_phy_init+0x78>
            
        	/* get connected PHYs */
            alt_tse_mac_get_phy(pmac_group);
 203b6d0:	e13ffe17 	ldw	r4,-8(fp)
 203b6d4:	203aee00 	call	203aee0 <alt_tse_mac_get_phy>
 203b6d8:	00000706 	br	203b6f8 <alt_tse_phy_init+0x94>
        }
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
 203b6dc:	e0fffd07 	ldb	r3,-12(fp)
 203b6e0:	e0bffd47 	ldb	r2,-11(fp)
 203b6e4:	01008174 	movhi	r4,517
 203b6e8:	21020804 	addi	r4,r4,2080
 203b6ec:	180b883a 	mov	r5,r3
 203b6f0:	100d883a 	mov	r6,r2
 203b6f4:	2006a240 	call	2006a24 <printf>
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 203b6f8:	e03ffd45 	stb	zero,-11(fp)
 203b6fc:	00000d06 	br	203b734 <alt_tse_phy_init+0xd0>
            pmac_info = pmac_group->pmac_info[j];
 203b700:	e0bffd47 	ldb	r2,-11(fp)
 203b704:	e0fffe17 	ldw	r3,-8(fp)
 203b708:	10800044 	addi	r2,r2,1
 203b70c:	1085883a 	add	r2,r2,r2
 203b710:	1085883a 	add	r2,r2,r2
 203b714:	1885883a 	add	r2,r3,r2
 203b718:	10800017 	ldw	r2,0(r2)
 203b71c:	e0bfff15 	stw	r2,-4(fp)
            
            alt_tse_phy_cfg_pcs(pmac_info);
 203b720:	e13fff17 	ldw	r4,-4(fp)
 203b724:	203b53c0 	call	203b53c <alt_tse_phy_cfg_pcs>
        else {
            tse_dprintf(3, "WARNING : MAC Groups[%d]->pmac_info[%d] MDIO is not used, unable to run PHY detection\n", i, j);
        }
        
        /* Configure PCS mode if MAC+PCS system is used */
        for(j = 0; j < pmac_group->channel; j++) {
 203b728:	e0bffd43 	ldbu	r2,-11(fp)
 203b72c:	10800044 	addi	r2,r2,1
 203b730:	e0bffd45 	stb	r2,-11(fp)
 203b734:	e0fffd47 	ldb	r3,-11(fp)
 203b738:	e0bffe17 	ldw	r2,-8(fp)
 203b73c:	10800003 	ldbu	r2,0(r2)
 203b740:	10803fcc 	andi	r2,r2,255
 203b744:	18bfee16 	blt	r3,r2,203b700 <alt_tse_phy_init+0x9c>
    
    alt_tse_mac_group_init();
        
    /* initialize for each TSE MAC */
    /* run once only for multi-channel MAC */
    for(i = 0; i < mac_group_count; i++) {
 203b748:	e0bffd03 	ldbu	r2,-12(fp)
 203b74c:	10800044 	addi	r2,r2,1
 203b750:	e0bffd05 	stb	r2,-12(fp)
 203b754:	e0fffd07 	ldb	r3,-12(fp)
 203b758:	d0a0af43 	ldbu	r2,-32067(gp)
 203b75c:	10803fcc 	andi	r2,r2,255
 203b760:	18bfcd16 	blt	r3,r2,203b698 <alt_tse_phy_init+0x34>
            
            alt_tse_phy_cfg_pcs(pmac_info);
        }
    }
                
    return SUCCESS;
 203b764:	0005883a 	mov	r2,zero
}
 203b768:	e037883a 	mov	sp,fp
 203b76c:	dfc00117 	ldw	ra,4(sp)
 203b770:	df000017 	ldw	fp,0(sp)
 203b774:	dec00204 	addi	sp,sp,8
 203b778:	f800283a 	ret

0203b77c <alt_tse_phy_restart_an>:
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *                              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_restart_an(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 203b77c:	defff704 	addi	sp,sp,-36
 203b780:	dfc00815 	stw	ra,32(sp)
 203b784:	df000715 	stw	fp,28(sp)
 203b788:	df000704 	addi	fp,sp,28
 203b78c:	e13ffe15 	stw	r4,-8(fp)
 203b790:	e17fff15 	stw	r5,-4(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203b794:	e0bffe17 	ldw	r2,-8(fp)
 203b798:	10800617 	ldw	r2,24(r2)
 203b79c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203b7a0:	e0bffb17 	ldw	r2,-20(fp)
 203b7a4:	10800317 	ldw	r2,12(r2)
 203b7a8:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203b7ac:	e13ffb17 	ldw	r4,-20(fp)
 203b7b0:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203b7b4:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203b7b8:	e13ffc17 	ldw	r4,-16(fp)
 203b7bc:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203b7c0:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203b7c4:	e13ffe17 	ldw	r4,-8(fp)
 203b7c8:	203a1040 	call	203a104 <alt_tse_phy_rd_mdio_addr>
 203b7cc:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203b7d0:	e0bffe17 	ldw	r2,-8(fp)
 203b7d4:	10800003 	ldbu	r2,0(r2)
 203b7d8:	10803fcc 	andi	r2,r2,255
 203b7dc:	e13ffe17 	ldw	r4,-8(fp)
 203b7e0:	100b883a 	mov	r5,r2
 203b7e4:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 203b7e8:	e13ffe17 	ldw	r4,-8(fp)
 203b7ec:	01400044 	movi	r5,1
 203b7f0:	018000c4 	movi	r6,3
 203b7f4:	01c00044 	movi	r7,1
 203b7f8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203b7fc:	10000d1e 	bne	r2,zero,203b834 <alt_tse_phy_restart_an+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 203b800:	e0fffd47 	ldb	r3,-11(fp)
 203b804:	e0bffd07 	ldb	r2,-12(fp)
 203b808:	01008174 	movhi	r4,517
 203b80c:	21021e04 	addi	r4,r4,2168
 203b810:	180b883a 	mov	r5,r3
 203b814:	100d883a 	mov	r6,r2
 203b818:	2006a240 	call	2006a24 <printf>
        
		/* Restore previous MDIO address */
		alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203b81c:	e0bffd83 	ldbu	r2,-10(fp)
 203b820:	e13ffe17 	ldw	r4,-8(fp)
 203b824:	100b883a 	mov	r5,r2
 203b828:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
		
		return TSE_PHY_AN_NOT_CAPABLE;
 203b82c:	00bfff84 	movi	r2,-2
 203b830:	00003e06 	br	203b92c <alt_tse_phy_restart_an+0x1b0>
    }
    
    /* enable Auto-Negotiation */    
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_AN_ENA, 1, 1);
 203b834:	00800044 	movi	r2,1
 203b838:	d8800015 	stw	r2,0(sp)
 203b83c:	e13ffe17 	ldw	r4,-8(fp)
 203b840:	000b883a 	mov	r5,zero
 203b844:	01800304 	movi	r6,12
 203b848:	01c00044 	movi	r7,1
 203b84c:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
    
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
 203b850:	00800044 	movi	r2,1
 203b854:	d8800015 	stw	r2,0(sp)
 203b858:	e13ffe17 	ldw	r4,-8(fp)
 203b85c:	000b883a 	mov	r5,zero
 203b860:	01800244 	movi	r6,9
 203b864:	01c00044 	movi	r7,1
 203b868:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
 203b86c:	e0fffd47 	ldb	r3,-11(fp)
 203b870:	e0bffd07 	ldb	r2,-12(fp)
 203b874:	01008174 	movhi	r4,517
 203b878:	21022e04 	addi	r4,r4,2232
 203b87c:	180b883a 	mov	r5,r3
 203b880:	100d883a 	mov	r6,r2
 203b884:	2006a240 	call	2006a24 <printf>
    
    alt_32 timeout = 0;
 203b888:	e03ffa15 	stw	zero,-24(fp)
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 203b88c:	00001506 	br	203b8e4 <alt_tse_phy_restart_an+0x168>
        if(timeout++ > timeout_threshold) {
 203b890:	e0bffa17 	ldw	r2,-24(fp)
 203b894:	e0ffff17 	ldw	r3,-4(fp)
 203b898:	1885803a 	cmpltu	r2,r3,r2
 203b89c:	e0fffa17 	ldw	r3,-24(fp)
 203b8a0:	18c00044 	addi	r3,r3,1
 203b8a4:	e0fffa15 	stw	r3,-24(fp)
 203b8a8:	10803fcc 	andi	r2,r2,255
 203b8ac:	10000d26 	beq	r2,zero,203b8e4 <alt_tse_phy_restart_an+0x168>
           tse_dprintf(4, "WARNING : PHY[%d.%d] - Auto-Negotiation FAILED\n", mac_group_index, mac_info_index);
 203b8b0:	e0fffd47 	ldb	r3,-11(fp)
 203b8b4:	e0bffd07 	ldb	r2,-12(fp)
 203b8b8:	01008174 	movhi	r4,517
 203b8bc:	21024004 	addi	r4,r4,2304
 203b8c0:	180b883a 	mov	r5,r3
 203b8c4:	100d883a 	mov	r6,r2
 203b8c8:	2006a240 	call	2006a24 <printf>
		   
		   /* Restore previous MDIO address */
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203b8cc:	e0bffd83 	ldbu	r2,-10(fp)
 203b8d0:	e13ffe17 	ldw	r4,-8(fp)
 203b8d4:	100b883a 	mov	r5,r2
 203b8d8:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
           
		   return TSE_PHY_AN_NOT_COMPLETE;
 203b8dc:	00bfffc4 	movi	r2,-1
 203b8e0:	00001206 	br	203b92c <alt_tse_phy_restart_an+0x1b0>
    /* send PHY reset command */
    alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_RESTART_AN, 1, 1);
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Restart Auto-Negotiation, checking PHY link...\n", mac_group_index, mac_info_index);
    
    alt_32 timeout = 0;
    while(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0 ){ 
 203b8e4:	e13ffe17 	ldw	r4,-8(fp)
 203b8e8:	01400044 	movi	r5,1
 203b8ec:	01800144 	movi	r6,5
 203b8f0:	01c00044 	movi	r7,1
 203b8f4:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203b8f8:	103fe526 	beq	r2,zero,203b890 <alt_tse_phy_restart_an+0x114>
           alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
           
		   return TSE_PHY_AN_NOT_COMPLETE;
        }
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Auto-Negotiation PASSED\n", mac_group_index, mac_info_index);
 203b8fc:	e0fffd47 	ldb	r3,-11(fp)
 203b900:	e0bffd07 	ldb	r2,-12(fp)
 203b904:	01008174 	movhi	r4,517
 203b908:	21024c04 	addi	r4,r4,2352
 203b90c:	180b883a 	mov	r5,r3
 203b910:	100d883a 	mov	r6,r2
 203b914:	2006a240 	call	2006a24 <printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203b918:	e0bffd83 	ldbu	r2,-10(fp)
 203b91c:	e13ffe17 	ldw	r4,-8(fp)
 203b920:	100b883a 	mov	r5,r2
 203b924:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE;
 203b928:	0005883a 	mov	r2,zero
}
 203b92c:	e037883a 	mov	sp,fp
 203b930:	dfc00117 	ldw	ra,4(sp)
 203b934:	df000017 	ldw	fp,0(sp)
 203b938:	dec00204 	addi	sp,sp,8
 203b93c:	f800283a 	ret

0203b940 <alt_tse_phy_check_link>:
 * @param pphy                  Pointer to the alt_tse_phy_info structure
 *        timeout_threshold     timeout value of Auto-Negotiation
 * @return                      return TSE_PHY_AN_COMPLETE if success
 *                              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 */
alt_32 alt_tse_phy_check_link(alt_tse_phy_info *pphy, alt_u32 timeout_threshold) {
 203b940:	defff904 	addi	sp,sp,-28
 203b944:	dfc00615 	stw	ra,24(sp)
 203b948:	df000515 	stw	fp,20(sp)
 203b94c:	df000504 	addi	fp,sp,20
 203b950:	e13ffe15 	stw	r4,-8(fp)
 203b954:	e17fff15 	stw	r5,-4(fp)

    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203b958:	e0bffe17 	ldw	r2,-8(fp)
 203b95c:	10800617 	ldw	r2,24(r2)
 203b960:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203b964:	e0bffb17 	ldw	r2,-20(fp)
 203b968:	10800317 	ldw	r2,12(r2)
 203b96c:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203b970:	e13ffb17 	ldw	r4,-20(fp)
 203b974:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203b978:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group); 
 203b97c:	e13ffc17 	ldw	r4,-16(fp)
 203b980:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203b984:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203b988:	e13ffe17 	ldw	r4,-8(fp)
 203b98c:	203a1040 	call	203a104 <alt_tse_phy_rd_mdio_addr>
 203b990:	e0bffd85 	stb	r2,-10(fp)
    
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203b994:	e0bffe17 	ldw	r2,-8(fp)
 203b998:	10800003 	ldbu	r2,0(r2)
 203b99c:	10803fcc 	andi	r2,r2,255
 203b9a0:	e13ffe17 	ldw	r4,-8(fp)
 203b9a4:	100b883a 	mov	r5,r2
 203b9a8:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    /* Issue a PHY reset here and wait for the link
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
 203b9ac:	e0fffd47 	ldb	r3,-11(fp)
 203b9b0:	e0bffd07 	ldb	r2,-12(fp)
 203b9b4:	01008174 	movhi	r4,517
 203b9b8:	21025804 	addi	r4,r4,2400
 203b9bc:	180b883a 	mov	r5,r3
 203b9c0:	100d883a 	mov	r6,r2
 203b9c4:	2006a240 	call	2006a24 <printf>
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 203b9c8:	e13ffe17 	ldw	r4,-8(fp)
 203b9cc:	000b883a 	mov	r5,zero
 203b9d0:	01800384 	movi	r6,14
 203b9d4:	01c00044 	movi	r7,1
 203b9d8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203b9dc:	1000061e 	bne	r2,zero,203b9f8 <alt_tse_phy_check_link+0xb8>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
 203b9e0:	e13ffe17 	ldw	r4,-8(fp)
 203b9e4:	01400044 	movi	r5,1
 203b9e8:	01800144 	movi	r6,5
 203b9ec:	01c00044 	movi	r7,1
 203b9f0:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
     * autonegotiation complete again... this takes several SECONDS(!)
     * so be very careful not to do it frequently
     * perform this when PHY is configured in loopback or has no link yet.
     */
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Checking link...\n", mac_group_index, mac_info_index);
    if( ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_LOOPBACK, 1)) != 0) ||
 203b9f4:	1000191e 	bne	r2,zero,203ba5c <alt_tse_phy_check_link+0x11c>
        ((alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1)) == 0) ) {                 
        
        tse_dprintf(5, "INFO    : PHY[%d.%d] - Link not yet established, restart auto-negotiation...\n", mac_group_index, mac_info_index);
 203b9f8:	e0fffd47 	ldb	r3,-11(fp)
 203b9fc:	e0bffd07 	ldb	r2,-12(fp)
 203ba00:	01008174 	movhi	r4,517
 203ba04:	21026304 	addi	r4,r4,2444
 203ba08:	180b883a 	mov	r5,r3
 203ba0c:	100d883a 	mov	r6,r2
 203ba10:	2006a240 	call	2006a24 <printf>
        /* restart Auto-Negotiation */
        /* if Auto-Negotiation still cannot complete, then go to next PHY */
        if(alt_tse_phy_restart_an(pphy, timeout_threshold) == TSE_PHY_AN_NOT_COMPLETE) {
 203ba14:	e13ffe17 	ldw	r4,-8(fp)
 203ba18:	e17fff17 	ldw	r5,-4(fp)
 203ba1c:	203b77c0 	call	203b77c <alt_tse_phy_restart_an>
 203ba20:	10bfffd8 	cmpnei	r2,r2,-1
 203ba24:	10000d1e 	bne	r2,zero,203ba5c <alt_tse_phy_check_link+0x11c>
            tse_dprintf(3, "WARNING : PHY[%d.%d] - Link could not established\n", mac_group_index, mac_info_index);
 203ba28:	e0fffd47 	ldb	r3,-11(fp)
 203ba2c:	e0bffd07 	ldb	r2,-12(fp)
 203ba30:	01008174 	movhi	r4,517
 203ba34:	21027704 	addi	r4,r4,2524
 203ba38:	180b883a 	mov	r5,r3
 203ba3c:	100d883a 	mov	r6,r2
 203ba40:	2006a240 	call	2006a24 <printf>
			
			/* Restore previous MDIO address */
			alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203ba44:	e0bffd83 	ldbu	r2,-10(fp)
 203ba48:	e13ffe17 	ldw	r4,-8(fp)
 203ba4c:	100b883a 	mov	r5,r2
 203ba50:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
	
            return TSE_PHY_AN_NOT_COMPLETE;
 203ba54:	00bfffc4 	movi	r2,-1
 203ba58:	00000c06 	br	203ba8c <alt_tse_phy_check_link+0x14c>
        }            
    }
    tse_dprintf(5, "INFO    : PHY[%d.%d] - Link established\n", mac_group_index, mac_info_index);
 203ba5c:	e0fffd47 	ldb	r3,-11(fp)
 203ba60:	e0bffd07 	ldb	r2,-12(fp)
 203ba64:	01008174 	movhi	r4,517
 203ba68:	21028404 	addi	r4,r4,2576
 203ba6c:	180b883a 	mov	r5,r3
 203ba70:	100d883a 	mov	r6,r2
 203ba74:	2006a240 	call	2006a24 <printf>
            
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203ba78:	e0bffd83 	ldbu	r2,-10(fp)
 203ba7c:	e13ffe17 	ldw	r4,-8(fp)
 203ba80:	100b883a 	mov	r5,r2
 203ba84:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    return TSE_PHY_AN_COMPLETE; 
 203ba88:	0005883a 	mov	r2,zero
}
 203ba8c:	e037883a 	mov	sp,fp
 203ba90:	dfc00117 	ldw	ra,4(sp)
 203ba94:	df000017 	ldw	fp,0(sp)
 203ba98:	dec00204 	addi	sp,sp,8
 203ba9c:	f800283a 	ret

0203baa0 <alt_tse_phy_get_cap>:
 * @param pmac  Pointer to the alt_tse_phy_info structure
 * @return      return TSE_PHY_AN_COMPLETE if success
 *              return TSE_PHY_AN_NOT_COMPLETE if auto-negotiation not completed
 *              return TSE_PHY_AN_NOT_CAPABLE if the PHY not capable for AN
 */
alt_32 alt_tse_phy_get_cap(alt_tse_phy_info *pphy) {
 203baa0:	defff904 	addi	sp,sp,-28
 203baa4:	dfc00615 	stw	ra,24(sp)
 203baa8:	df000515 	stw	fp,20(sp)
 203baac:	df000504 	addi	fp,sp,20
 203bab0:	e13fff15 	stw	r4,-4(fp)
	alt_32 return_value = TSE_PHY_AN_COMPLETE;
 203bab4:	e03ffb15 	stw	zero,-20(fp)
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203bab8:	e0bfff17 	ldw	r2,-4(fp)
 203babc:	10800617 	ldw	r2,24(r2)
 203bac0:	e0bffc15 	stw	r2,-16(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203bac4:	e0bffc17 	ldw	r2,-16(fp)
 203bac8:	10800317 	ldw	r2,12(r2)
 203bacc:	e0bffd15 	stw	r2,-12(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203bad0:	e13ffc17 	ldw	r4,-16(fp)
 203bad4:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203bad8:	e0bffe05 	stb	r2,-8(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);    
 203badc:	e13ffd17 	ldw	r4,-12(fp)
 203bae0:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203bae4:	e0bffe45 	stb	r2,-7(fp)
        
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203bae8:	e13fff17 	ldw	r4,-4(fp)
 203baec:	203a1040 	call	203a104 <alt_tse_phy_rd_mdio_addr>
 203baf0:	e0bffe85 	stb	r2,-6(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203baf4:	e0bfff17 	ldw	r2,-4(fp)
 203baf8:	10800003 	ldbu	r2,0(r2)
 203bafc:	10803fcc 	andi	r2,r2,255
 203bb00:	e13fff17 	ldw	r4,-4(fp)
 203bb04:	100b883a 	mov	r5,r2
 203bb08:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
            
    if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 203bb0c:	e13fff17 	ldw	r4,-4(fp)
 203bb10:	01400044 	movi	r5,1
 203bb14:	018000c4 	movi	r6,3
 203bb18:	01c00044 	movi	r7,1
 203bb1c:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bb20:	10000d1e 	bne	r2,zero,203bb58 <alt_tse_phy_get_cap+0xb8>
        tse_dprintf(3, "WARNING : PHY[%d.%d] - PHY not capable for Auto-Negotiation\n", mac_group_index, mac_info_index);
 203bb24:	e0fffe47 	ldb	r3,-7(fp)
 203bb28:	e0bffe07 	ldb	r2,-8(fp)
 203bb2c:	01008174 	movhi	r4,517
 203bb30:	21021e04 	addi	r4,r4,2168
 203bb34:	180b883a 	mov	r5,r3
 203bb38:	100d883a 	mov	r6,r2
 203bb3c:	2006a240 	call	2006a24 <printf>
        
        /* Restore previous MDIO address */
        alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203bb40:	e0bffe83 	ldbu	r2,-6(fp)
 203bb44:	e13fff17 	ldw	r4,-4(fp)
 203bb48:	100b883a 	mov	r5,r2
 203bb4c:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
        
        return TSE_PHY_AN_NOT_CAPABLE;
 203bb50:	00bfff84 	movi	r2,-2
 203bb54:	00013306 	br	203c024 <alt_tse_phy_get_cap+0x584>
    }
    
    /* check whether link has been established */
    alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 203bb58:	e13fff17 	ldw	r4,-4(fp)
 203bb5c:	01400134 	movhi	r5,4
 203bb60:	29742404 	addi	r5,r5,-12144
 203bb64:	203b77c0 	call	203b77c <alt_tse_phy_restart_an>
    
    if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 0) {
 203bb68:	e13fff17 	ldw	r4,-4(fp)
 203bb6c:	01400044 	movi	r5,1
 203bb70:	01800144 	movi	r6,5
 203bb74:	01c00044 	movi	r7,1
 203bb78:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bb7c:	1000021e 	bne	r2,zero,203bb88 <alt_tse_phy_get_cap+0xe8>
        return_value = TSE_PHY_AN_NOT_COMPLETE;
 203bb80:	00bfffc4 	movi	r2,-1
 203bb84:	e0bffb15 	stw	r2,-20(fp)
    }
    
    /* get PHY capabilities */
    pphy->link_capability.cap_1000_base_x_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_FULL, 1);
 203bb88:	e13fff17 	ldw	r4,-4(fp)
 203bb8c:	014003c4 	movi	r5,15
 203bb90:	018003c4 	movi	r6,15
 203bb94:	01c00044 	movi	r7,1
 203bb98:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bb9c:	1007883a 	mov	r3,r2
 203bba0:	e0bfff17 	ldw	r2,-4(fp)
 203bba4:	10c00045 	stb	r3,1(r2)
    pphy->link_capability.cap_1000_base_x_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_X_HALF, 1);
 203bba8:	e13fff17 	ldw	r4,-4(fp)
 203bbac:	014003c4 	movi	r5,15
 203bbb0:	01800384 	movi	r6,14
 203bbb4:	01c00044 	movi	r7,1
 203bbb8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bbbc:	1007883a 	mov	r3,r2
 203bbc0:	e0bfff17 	ldw	r2,-4(fp)
 203bbc4:	10c00085 	stb	r3,2(r2)
    pphy->link_capability.cap_1000_base_t_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1);
 203bbc8:	e13fff17 	ldw	r4,-4(fp)
 203bbcc:	014003c4 	movi	r5,15
 203bbd0:	01800344 	movi	r6,13
 203bbd4:	01c00044 	movi	r7,1
 203bbd8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bbdc:	1007883a 	mov	r3,r2
 203bbe0:	e0bfff17 	ldw	r2,-4(fp)
 203bbe4:	10c000c5 	stb	r3,3(r2)
    pphy->link_capability.cap_1000_base_t_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 203bbe8:	e13fff17 	ldw	r4,-4(fp)
 203bbec:	014003c4 	movi	r5,15
 203bbf0:	01800304 	movi	r6,12
 203bbf4:	01c00044 	movi	r7,1
 203bbf8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bbfc:	1007883a 	mov	r3,r2
 203bc00:	e0bfff17 	ldw	r2,-4(fp)
 203bc04:	10c00105 	stb	r3,4(r2)
    
    pphy->link_capability.cap_100_base_t4      = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 203bc08:	e13fff17 	ldw	r4,-4(fp)
 203bc0c:	01400044 	movi	r5,1
 203bc10:	018003c4 	movi	r6,15
 203bc14:	01c00044 	movi	r7,1
 203bc18:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bc1c:	1007883a 	mov	r3,r2
 203bc20:	e0bfff17 	ldw	r2,-4(fp)
 203bc24:	10c00145 	stb	r3,5(r2)
    pphy->link_capability.cap_100_base_x_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 203bc28:	e13fff17 	ldw	r4,-4(fp)
 203bc2c:	01400044 	movi	r5,1
 203bc30:	01800384 	movi	r6,14
 203bc34:	01c00044 	movi	r7,1
 203bc38:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bc3c:	1007883a 	mov	r3,r2
 203bc40:	e0bfff17 	ldw	r2,-4(fp)
 203bc44:	10c00185 	stb	r3,6(r2)
    pphy->link_capability.cap_100_base_x_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 203bc48:	e13fff17 	ldw	r4,-4(fp)
 203bc4c:	01400044 	movi	r5,1
 203bc50:	01800344 	movi	r6,13
 203bc54:	01c00044 	movi	r7,1
 203bc58:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bc5c:	1007883a 	mov	r3,r2
 203bc60:	e0bfff17 	ldw	r2,-4(fp)
 203bc64:	10c001c5 	stb	r3,7(r2)
    pphy->link_capability.cap_100_base_t2_full = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_FULL, 1);
 203bc68:	e13fff17 	ldw	r4,-4(fp)
 203bc6c:	01400044 	movi	r5,1
 203bc70:	01800284 	movi	r6,10
 203bc74:	01c00044 	movi	r7,1
 203bc78:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bc7c:	1007883a 	mov	r3,r2
 203bc80:	e0bfff17 	ldw	r2,-4(fp)
 203bc84:	10c00205 	stb	r3,8(r2)
    pphy->link_capability.cap_100_base_t2_half = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T2_HALF, 1);
 203bc88:	e13fff17 	ldw	r4,-4(fp)
 203bc8c:	01400044 	movi	r5,1
 203bc90:	01800244 	movi	r6,9
 203bc94:	01c00044 	movi	r7,1
 203bc98:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bc9c:	1007883a 	mov	r3,r2
 203bca0:	e0bfff17 	ldw	r2,-4(fp)
 203bca4:	10c00245 	stb	r3,9(r2)
    pphy->link_capability.cap_10_base_t_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 203bca8:	e13fff17 	ldw	r4,-4(fp)
 203bcac:	01400044 	movi	r5,1
 203bcb0:	01800304 	movi	r6,12
 203bcb4:	01c00044 	movi	r7,1
 203bcb8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bcbc:	1007883a 	mov	r3,r2
 203bcc0:	e0bfff17 	ldw	r2,-4(fp)
 203bcc4:	10c00285 	stb	r3,10(r2)
    pphy->link_capability.cap_10_base_t_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 203bcc8:	e13fff17 	ldw	r4,-4(fp)
 203bccc:	01400044 	movi	r5,1
 203bcd0:	018002c4 	movi	r6,11
 203bcd4:	01c00044 	movi	r7,1
 203bcd8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bcdc:	1007883a 	mov	r3,r2
 203bce0:	e0bfff17 	ldw	r2,-4(fp)
 203bce4:	10c002c5 	stb	r3,11(r2)
    
    /* get link partner capability */
    pphy->link_capability.lp_1000_base_t_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_FULL_ADV, 1);
 203bce8:	e13fff17 	ldw	r4,-4(fp)
 203bcec:	01400284 	movi	r5,10
 203bcf0:	018002c4 	movi	r6,11
 203bcf4:	01c00044 	movi	r7,1
 203bcf8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bcfc:	1007883a 	mov	r3,r2
 203bd00:	e0bfff17 	ldw	r2,-4(fp)
 203bd04:	10c00305 	stb	r3,12(r2)
    pphy->link_capability.lp_1000_base_t_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_STATUS, TSE_PHY_MDIO_1000BASE_T_STATUS_LP_HALF_ADV, 1);
 203bd08:	e13fff17 	ldw	r4,-4(fp)
 203bd0c:	01400284 	movi	r5,10
 203bd10:	01800284 	movi	r6,10
 203bd14:	01c00044 	movi	r7,1
 203bd18:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bd1c:	1007883a 	mov	r3,r2
 203bd20:	e0bfff17 	ldw	r2,-4(fp)
 203bd24:	10c00345 	stb	r3,13(r2)
    
    pphy->link_capability.lp_100_base_t4       = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1);
 203bd28:	e13fff17 	ldw	r4,-4(fp)
 203bd2c:	01400144 	movi	r5,5
 203bd30:	01800244 	movi	r6,9
 203bd34:	01c00044 	movi	r7,1
 203bd38:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bd3c:	1007883a 	mov	r3,r2
 203bd40:	e0bfff17 	ldw	r2,-4(fp)
 203bd44:	10c00385 	stb	r3,14(r2)
    pphy->link_capability.lp_100_base_tx_full  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1);
 203bd48:	e13fff17 	ldw	r4,-4(fp)
 203bd4c:	01400144 	movi	r5,5
 203bd50:	01800204 	movi	r6,8
 203bd54:	01c00044 	movi	r7,1
 203bd58:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bd5c:	1007883a 	mov	r3,r2
 203bd60:	e0bfff17 	ldw	r2,-4(fp)
 203bd64:	10c003c5 	stb	r3,15(r2)
    pphy->link_capability.lp_100_base_tx_half  = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1);
 203bd68:	e13fff17 	ldw	r4,-4(fp)
 203bd6c:	01400144 	movi	r5,5
 203bd70:	018001c4 	movi	r6,7
 203bd74:	01c00044 	movi	r7,1
 203bd78:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bd7c:	1007883a 	mov	r3,r2
 203bd80:	e0bfff17 	ldw	r2,-4(fp)
 203bd84:	10c00405 	stb	r3,16(r2)
    pphy->link_capability.lp_10_base_tx_full   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1);
 203bd88:	e13fff17 	ldw	r4,-4(fp)
 203bd8c:	01400144 	movi	r5,5
 203bd90:	01800184 	movi	r6,6
 203bd94:	01c00044 	movi	r7,1
 203bd98:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bd9c:	1007883a 	mov	r3,r2
 203bda0:	e0bfff17 	ldw	r2,-4(fp)
 203bda4:	10c00445 	stb	r3,17(r2)
    pphy->link_capability.lp_10_base_tx_half   = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_REMADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1);
 203bda8:	e13fff17 	ldw	r4,-4(fp)
 203bdac:	01400144 	movi	r5,5
 203bdb0:	01800144 	movi	r6,5
 203bdb4:	01c00044 	movi	r7,1
 203bdb8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203bdbc:	1007883a 	mov	r3,r2
 203bdc0:	e0bfff17 	ldw	r2,-4(fp)
 203bdc4:	10c00485 	stb	r3,18(r2)
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Capability of PHY :\n", mac_group_index, mac_info_index);
 203bdc8:	e0fffe47 	ldb	r3,-7(fp)
 203bdcc:	e0bffe07 	ldb	r2,-8(fp)
 203bdd0:	01008174 	movhi	r4,517
 203bdd4:	21028f04 	addi	r4,r4,2620
 203bdd8:	180b883a 	mov	r5,r3
 203bddc:	100d883a 	mov	r6,r2
 203bde0:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Full Duplex = %d\n", pphy->link_capability.cap_1000_base_x_full);
 203bde4:	e0bfff17 	ldw	r2,-4(fp)
 203bde8:	10800043 	ldbu	r2,1(r2)
 203bdec:	10803fcc 	andi	r2,r2,255
 203bdf0:	01008174 	movhi	r4,517
 203bdf4:	21029a04 	addi	r4,r4,2664
 203bdf8:	100b883a 	mov	r5,r2
 203bdfc:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-X Half Duplex = %d\n", pphy->link_capability.cap_1000_base_x_half);
 203be00:	e0bfff17 	ldw	r2,-4(fp)
 203be04:	10800083 	ldbu	r2,2(r2)
 203be08:	10803fcc 	andi	r2,r2,255
 203be0c:	01008174 	movhi	r4,517
 203be10:	2102a404 	addi	r4,r4,2704
 203be14:	100b883a 	mov	r5,r2
 203be18:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.cap_1000_base_t_full);
 203be1c:	e0bfff17 	ldw	r2,-4(fp)
 203be20:	108000c3 	ldbu	r2,3(r2)
 203be24:	10803fcc 	andi	r2,r2,255
 203be28:	01008174 	movhi	r4,517
 203be2c:	2102ae04 	addi	r4,r4,2744
 203be30:	100b883a 	mov	r5,r2
 203be34:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.cap_1000_base_t_half);
 203be38:	e0bfff17 	ldw	r2,-4(fp)
 203be3c:	10800103 	ldbu	r2,4(r2)
 203be40:	10803fcc 	andi	r2,r2,255
 203be44:	01008174 	movhi	r4,517
 203be48:	2102b804 	addi	r4,r4,2784
 203be4c:	100b883a 	mov	r5,r2
 203be50:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.cap_100_base_t4);
 203be54:	e0bfff17 	ldw	r2,-4(fp)
 203be58:	10800143 	ldbu	r2,5(r2)
 203be5c:	10803fcc 	andi	r2,r2,255
 203be60:	01008174 	movhi	r4,517
 203be64:	2102c204 	addi	r4,r4,2824
 203be68:	100b883a 	mov	r5,r2
 203be6c:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Full Duplex  = %d\n", pphy->link_capability.cap_100_base_x_full);
 203be70:	e0bfff17 	ldw	r2,-4(fp)
 203be74:	10800183 	ldbu	r2,6(r2)
 203be78:	10803fcc 	andi	r2,r2,255
 203be7c:	01008174 	movhi	r4,517
 203be80:	2102cc04 	addi	r4,r4,2864
 203be84:	100b883a 	mov	r5,r2
 203be88:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-X Half Duplex  = %d\n", pphy->link_capability.cap_100_base_x_half);
 203be8c:	e0bfff17 	ldw	r2,-4(fp)
 203be90:	108001c3 	ldbu	r2,7(r2)
 203be94:	10803fcc 	andi	r2,r2,255
 203be98:	01008174 	movhi	r4,517
 203be9c:	2102d604 	addi	r4,r4,2904
 203bea0:	100b883a 	mov	r5,r2
 203bea4:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Full Duplex = %d\n", pphy->link_capability.cap_100_base_t2_full);
 203bea8:	e0bfff17 	ldw	r2,-4(fp)
 203beac:	10800203 	ldbu	r2,8(r2)
 203beb0:	10803fcc 	andi	r2,r2,255
 203beb4:	01008174 	movhi	r4,517
 203beb8:	2102e004 	addi	r4,r4,2944
 203bebc:	100b883a 	mov	r5,r2
 203bec0:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T2 Half Duplex = %d\n", pphy->link_capability.cap_100_base_t2_half);
 203bec4:	e0bfff17 	ldw	r2,-4(fp)
 203bec8:	10800243 	ldbu	r2,9(r2)
 203becc:	10803fcc 	andi	r2,r2,255
 203bed0:	01008174 	movhi	r4,517
 203bed4:	2102ea04 	addi	r4,r4,2984
 203bed8:	100b883a 	mov	r5,r2
 203bedc:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Full Duplex   = %d\n", pphy->link_capability.cap_10_base_t_full);
 203bee0:	e0bfff17 	ldw	r2,-4(fp)
 203bee4:	10800283 	ldbu	r2,10(r2)
 203bee8:	10803fcc 	andi	r2,r2,255
 203beec:	01008174 	movhi	r4,517
 203bef0:	2102f404 	addi	r4,r4,3024
 203bef4:	100b883a 	mov	r5,r2
 203bef8:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-T Half Duplex   = %d\n", pphy->link_capability.cap_10_base_t_half);
 203befc:	e0bfff17 	ldw	r2,-4(fp)
 203bf00:	108002c3 	ldbu	r2,11(r2)
 203bf04:	10803fcc 	andi	r2,r2,255
 203bf08:	01008174 	movhi	r4,517
 203bf0c:	2102fe04 	addi	r4,r4,3064
 203bf10:	100b883a 	mov	r5,r2
 203bf14:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "\n");
 203bf18:	01008174 	movhi	r4,517
 203bf1c:	21016404 	addi	r4,r4,1424
 203bf20:	20381e40 	call	20381e4 <no_printf>
    
    tse_dprintf(6, "INFO    : PHY[%d.%d] - Link Partner Capability :\n", mac_group_index, mac_info_index);
 203bf24:	e0fffe47 	ldb	r3,-7(fp)
 203bf28:	e0bffe07 	ldb	r2,-8(fp)
 203bf2c:	01008174 	movhi	r4,517
 203bf30:	21030804 	addi	r4,r4,3104
 203bf34:	180b883a 	mov	r5,r3
 203bf38:	100d883a 	mov	r6,r2
 203bf3c:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Full Duplex = %d\n", pphy->link_capability.lp_1000_base_t_full);
 203bf40:	e0bfff17 	ldw	r2,-4(fp)
 203bf44:	10800303 	ldbu	r2,12(r2)
 203bf48:	10803fcc 	andi	r2,r2,255
 203bf4c:	01008174 	movhi	r4,517
 203bf50:	2102ae04 	addi	r4,r4,2744
 203bf54:	100b883a 	mov	r5,r2
 203bf58:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 1000 Base-T Half Duplex = %d\n", pphy->link_capability.lp_1000_base_t_half);
 203bf5c:	e0bfff17 	ldw	r2,-4(fp)
 203bf60:	10800343 	ldbu	r2,13(r2)
 203bf64:	10803fcc 	andi	r2,r2,255
 203bf68:	01008174 	movhi	r4,517
 203bf6c:	2102b804 	addi	r4,r4,2784
 203bf70:	100b883a 	mov	r5,r2
 203bf74:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-T4             = %d\n", pphy->link_capability.lp_100_base_t4);
 203bf78:	e0bfff17 	ldw	r2,-4(fp)
 203bf7c:	10800383 	ldbu	r2,14(r2)
 203bf80:	10803fcc 	andi	r2,r2,255
 203bf84:	01008174 	movhi	r4,517
 203bf88:	2102c204 	addi	r4,r4,2824
 203bf8c:	100b883a 	mov	r5,r2
 203bf90:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Full Duplex = %d\n", pphy->link_capability.lp_100_base_tx_full);
 203bf94:	e0bfff17 	ldw	r2,-4(fp)
 203bf98:	108003c3 	ldbu	r2,15(r2)
 203bf9c:	10803fcc 	andi	r2,r2,255
 203bfa0:	01008174 	movhi	r4,517
 203bfa4:	21031504 	addi	r4,r4,3156
 203bfa8:	100b883a 	mov	r5,r2
 203bfac:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 100 Base-TX Half Duplex = %d\n", pphy->link_capability.lp_100_base_tx_half);
 203bfb0:	e0bfff17 	ldw	r2,-4(fp)
 203bfb4:	10800403 	ldbu	r2,16(r2)
 203bfb8:	10803fcc 	andi	r2,r2,255
 203bfbc:	01008174 	movhi	r4,517
 203bfc0:	21031f04 	addi	r4,r4,3196
 203bfc4:	100b883a 	mov	r5,r2
 203bfc8:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Full Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_full);
 203bfcc:	e0bfff17 	ldw	r2,-4(fp)
 203bfd0:	10800443 	ldbu	r2,17(r2)
 203bfd4:	10803fcc 	andi	r2,r2,255
 203bfd8:	01008174 	movhi	r4,517
 203bfdc:	21032904 	addi	r4,r4,3236
 203bfe0:	100b883a 	mov	r5,r2
 203bfe4:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "INFO    : 10 Base-TX Half Duplex  = %d\n", pphy->link_capability.lp_10_base_tx_half);
 203bfe8:	e0bfff17 	ldw	r2,-4(fp)
 203bfec:	10800483 	ldbu	r2,18(r2)
 203bff0:	10803fcc 	andi	r2,r2,255
 203bff4:	01008174 	movhi	r4,517
 203bff8:	21033304 	addi	r4,r4,3276
 203bffc:	100b883a 	mov	r5,r2
 203c000:	20381e40 	call	20381e4 <no_printf>
    tse_dprintf(6, "\n");
 203c004:	01008174 	movhi	r4,517
 203c008:	21016404 	addi	r4,r4,1424
 203c00c:	20381e40 	call	20381e4 <no_printf>
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203c010:	e0bffe83 	ldbu	r2,-6(fp)
 203c014:	e13fff17 	ldw	r4,-4(fp)
 203c018:	100b883a 	mov	r5,r2
 203c01c:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    return return_value;
 203c020:	e0bffb17 	ldw	r2,-20(fp)
    
}
 203c024:	e037883a 	mov	sp,fp
 203c028:	dfc00117 	ldw	ra,4(sp)
 203c02c:	df000017 	ldw	fp,0(sp)
 203c030:	dec00204 	addi	sp,sp,8
 203c034:	f800283a 	ret

0203c038 <alt_tse_phy_set_adv_1000>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_1000(alt_tse_phy_info *pphy, alt_u8 enable) {
 203c038:	defff804 	addi	sp,sp,-32
 203c03c:	dfc00715 	stw	ra,28(sp)
 203c040:	df000615 	stw	fp,24(sp)
 203c044:	df000604 	addi	fp,sp,24
 203c048:	e13ffe15 	stw	r4,-8(fp)
 203c04c:	2805883a 	mov	r2,r5
 203c050:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203c054:	e0bffe17 	ldw	r2,-8(fp)
 203c058:	10800617 	ldw	r2,24(r2)
 203c05c:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203c060:	e0bffb17 	ldw	r2,-20(fp)
 203c064:	10800317 	ldw	r2,12(r2)
 203c068:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203c06c:	e13ffb17 	ldw	r4,-20(fp)
 203c070:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203c074:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203c078:	e13ffc17 	ldw	r4,-16(fp)
 203c07c:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203c080:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203c084:	e13ffe17 	ldw	r4,-8(fp)
 203c088:	203a1040 	call	203a104 <alt_tse_phy_rd_mdio_addr>
 203c08c:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203c090:	e0bffe17 	ldw	r2,-8(fp)
 203c094:	10800003 	ldbu	r2,0(r2)
 203c098:	10803fcc 	andi	r2,r2,255
 203c09c:	e13ffe17 	ldw	r4,-8(fp)
 203c0a0:	100b883a 	mov	r5,r2
 203c0a4:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 203c0a8:	e0bfff03 	ldbu	r2,-4(fp)
 203c0ac:	10002b26 	beq	r2,zero,203c15c <alt_tse_phy_set_adv_1000+0x124>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_FULL, 1); 
 203c0b0:	e13ffe17 	ldw	r4,-8(fp)
 203c0b4:	014003c4 	movi	r5,15
 203c0b8:	01800344 	movi	r6,13
 203c0bc:	01c00044 	movi	r7,1
 203c0c0:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c0c4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, cap);
 203c0c8:	e0bffdc3 	ldbu	r2,-9(fp)
 203c0cc:	d8800015 	stw	r2,0(sp)
 203c0d0:	e13ffe17 	ldw	r4,-8(fp)
 203c0d4:	01400244 	movi	r5,9
 203c0d8:	01800244 	movi	r6,9
 203c0dc:	01c00044 	movi	r7,1
 203c0e0:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 203c0e4:	e17ffd47 	ldb	r5,-11(fp)
 203c0e8:	e0fffd07 	ldb	r3,-12(fp)
 203c0ec:	e0bffdc3 	ldbu	r2,-9(fp)
 203c0f0:	01008174 	movhi	r4,517
 203c0f4:	21033d04 	addi	r4,r4,3316
 203c0f8:	180d883a 	mov	r6,r3
 203c0fc:	100f883a 	mov	r7,r2
 203c100:	20381e40 	call	20381e4 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_EXT_STATUS, TSE_PHY_MDIO_EXT_STATUS_1000BASE_T_HALF, 1);
 203c104:	e13ffe17 	ldw	r4,-8(fp)
 203c108:	014003c4 	movi	r5,15
 203c10c:	01800304 	movi	r6,12
 203c110:	01c00044 	movi	r7,1
 203c114:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c118:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, cap);
 203c11c:	e0bffdc3 	ldbu	r2,-9(fp)
 203c120:	d8800015 	stw	r2,0(sp)
 203c124:	e13ffe17 	ldw	r4,-8(fp)
 203c128:	01400244 	movi	r5,9
 203c12c:	01800204 	movi	r6,8
 203c130:	01c00044 	movi	r7,1
 203c134:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 203c138:	e17ffd47 	ldb	r5,-11(fp)
 203c13c:	e0fffd07 	ldb	r3,-12(fp)
 203c140:	e0bffdc3 	ldbu	r2,-9(fp)
 203c144:	01008174 	movhi	r4,517
 203c148:	21035004 	addi	r4,r4,3392
 203c14c:	180d883a 	mov	r6,r3
 203c150:	100f883a 	mov	r7,r2
 203c154:	20381e40 	call	20381e4 <no_printf>
 203c158:	00001c06 	br	203c1cc <alt_tse_phy_set_adv_1000+0x194>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_FULL_ADV, 1, 0);
 203c15c:	d8000015 	stw	zero,0(sp)
 203c160:	e13ffe17 	ldw	r4,-8(fp)
 203c164:	01400244 	movi	r5,9
 203c168:	01800244 	movi	r6,9
 203c16c:	01c00044 	movi	r7,1
 203c170:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 1000 Base-T Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203c174:	e0fffd47 	ldb	r3,-11(fp)
 203c178:	e0bffd07 	ldb	r2,-12(fp)
 203c17c:	01008174 	movhi	r4,517
 203c180:	21033d04 	addi	r4,r4,3316
 203c184:	180b883a 	mov	r5,r3
 203c188:	100d883a 	mov	r6,r2
 203c18c:	000f883a 	mov	r7,zero
 203c190:	20381e40 	call	20381e4 <no_printf>
        
        /* 1000 Mbps Half duplex not supported by TSE MAC */
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_1000BASE_T_CTRL, TSE_PHY_MDIO_1000BASE_T_CTRL_HALF_ADV, 1, 0);
 203c194:	d8000015 	stw	zero,0(sp)
 203c198:	e13ffe17 	ldw	r4,-8(fp)
 203c19c:	01400244 	movi	r5,9
 203c1a0:	01800204 	movi	r6,8
 203c1a4:	01c00044 	movi	r7,1
 203c1a8:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement 1000 Base-T half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203c1ac:	e0fffd47 	ldb	r3,-11(fp)
 203c1b0:	e0bffd07 	ldb	r2,-12(fp)
 203c1b4:	01008174 	movhi	r4,517
 203c1b8:	21036304 	addi	r4,r4,3468
 203c1bc:	180b883a 	mov	r5,r3
 203c1c0:	100d883a 	mov	r6,r2
 203c1c4:	000f883a 	mov	r7,zero
 203c1c8:	20381e40 	call	20381e4 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);    
 203c1cc:	e0bffd83 	ldbu	r2,-10(fp)
 203c1d0:	e13ffe17 	ldw	r4,-8(fp)
 203c1d4:	100b883a 	mov	r5,r2
 203c1d8:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>

    return SUCCESS;
 203c1dc:	0005883a 	mov	r2,zero
}
 203c1e0:	e037883a 	mov	sp,fp
 203c1e4:	dfc00117 	ldw	ra,4(sp)
 203c1e8:	df000017 	ldw	fp,0(sp)
 203c1ec:	dec00204 	addi	sp,sp,8
 203c1f0:	f800283a 	ret

0203c1f4 <alt_tse_phy_set_adv_100>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_100(alt_tse_phy_info *pphy, alt_u8 enable) {
 203c1f4:	defff804 	addi	sp,sp,-32
 203c1f8:	dfc00715 	stw	ra,28(sp)
 203c1fc:	df000615 	stw	fp,24(sp)
 203c200:	df000604 	addi	fp,sp,24
 203c204:	e13ffe15 	stw	r4,-8(fp)
 203c208:	2805883a 	mov	r2,r5
 203c20c:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203c210:	e0bffe17 	ldw	r2,-8(fp)
 203c214:	10800617 	ldw	r2,24(r2)
 203c218:	e0bffb15 	stw	r2,-20(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203c21c:	e0bffb17 	ldw	r2,-20(fp)
 203c220:	10800317 	ldw	r2,12(r2)
 203c224:	e0bffc15 	stw	r2,-16(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203c228:	e13ffb17 	ldw	r4,-20(fp)
 203c22c:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203c230:	e0bffd05 	stb	r2,-12(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203c234:	e13ffc17 	ldw	r4,-16(fp)
 203c238:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203c23c:	e0bffd45 	stb	r2,-11(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    alt_u8 mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203c240:	e13ffe17 	ldw	r4,-8(fp)
 203c244:	203a1040 	call	203a104 <alt_tse_phy_rd_mdio_addr>
 203c248:	e0bffd85 	stb	r2,-10(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203c24c:	e0bffe17 	ldw	r2,-8(fp)
 203c250:	10800003 	ldbu	r2,0(r2)
 203c254:	10803fcc 	andi	r2,r2,255
 203c258:	e13ffe17 	ldw	r4,-8(fp)
 203c25c:	100b883a 	mov	r5,r2
 203c260:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 203c264:	e0bfff03 	ldbu	r2,-4(fp)
 203c268:	10004026 	beq	r2,zero,203c36c <alt_tse_phy_set_adv_100+0x178>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_T4, 1);
 203c26c:	e13ffe17 	ldw	r4,-8(fp)
 203c270:	01400044 	movi	r5,1
 203c274:	018003c4 	movi	r6,15
 203c278:	01c00044 	movi	r7,1
 203c27c:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c280:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, cap);
 203c284:	e0bffdc3 	ldbu	r2,-9(fp)
 203c288:	d8800015 	stw	r2,0(sp)
 203c28c:	e13ffe17 	ldw	r4,-8(fp)
 203c290:	01400104 	movi	r5,4
 203c294:	01800244 	movi	r6,9
 203c298:	01c00044 	movi	r7,1
 203c29c:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, cap);
 203c2a0:	e17ffd47 	ldb	r5,-11(fp)
 203c2a4:	e0fffd07 	ldb	r3,-12(fp)
 203c2a8:	e0bffdc3 	ldbu	r2,-9(fp)
 203c2ac:	01008174 	movhi	r4,517
 203c2b0:	21037504 	addi	r4,r4,3540
 203c2b4:	180d883a 	mov	r6,r3
 203c2b8:	100f883a 	mov	r7,r2
 203c2bc:	20381e40 	call	20381e4 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_FULL, 1);
 203c2c0:	e13ffe17 	ldw	r4,-8(fp)
 203c2c4:	01400044 	movi	r5,1
 203c2c8:	01800384 	movi	r6,14
 203c2cc:	01c00044 	movi	r7,1
 203c2d0:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c2d4:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, cap);
 203c2d8:	e0bffdc3 	ldbu	r2,-9(fp)
 203c2dc:	d8800015 	stw	r2,0(sp)
 203c2e0:	e13ffe17 	ldw	r4,-8(fp)
 203c2e4:	01400104 	movi	r5,4
 203c2e8:	01800204 	movi	r6,8
 203c2ec:	01c00044 	movi	r7,1
 203c2f0:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 203c2f4:	e17ffd47 	ldb	r5,-11(fp)
 203c2f8:	e0fffd07 	ldb	r3,-12(fp)
 203c2fc:	e0bffdc3 	ldbu	r2,-9(fp)
 203c300:	01008174 	movhi	r4,517
 203c304:	21038504 	addi	r4,r4,3604
 203c308:	180d883a 	mov	r6,r3
 203c30c:	100f883a 	mov	r7,r2
 203c310:	20381e40 	call	20381e4 <no_printf>
        
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_100BASE_X_HALF, 1);
 203c314:	e13ffe17 	ldw	r4,-8(fp)
 203c318:	01400044 	movi	r5,1
 203c31c:	01800344 	movi	r6,13
 203c320:	01c00044 	movi	r7,1
 203c324:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c328:	e0bffdc5 	stb	r2,-9(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, cap);
 203c32c:	e0bffdc3 	ldbu	r2,-9(fp)
 203c330:	d8800015 	stw	r2,0(sp)
 203c334:	e13ffe17 	ldw	r4,-8(fp)
 203c338:	01400104 	movi	r5,4
 203c33c:	018001c4 	movi	r6,7
 203c340:	01c00044 	movi	r7,1
 203c344:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 203c348:	e17ffd47 	ldb	r5,-11(fp)
 203c34c:	e0fffd07 	ldb	r3,-12(fp)
 203c350:	e0bffdc3 	ldbu	r2,-9(fp)
 203c354:	01008174 	movhi	r4,517
 203c358:	21039804 	addi	r4,r4,3680
 203c35c:	180d883a 	mov	r6,r3
 203c360:	100f883a 	mov	r7,r2
 203c364:	20381e40 	call	20381e4 <no_printf>
 203c368:	00002a06 	br	203c414 <alt_tse_phy_set_adv_100+0x220>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_T4, 1, 0);
 203c36c:	d8000015 	stw	zero,0(sp)
 203c370:	e13ffe17 	ldw	r4,-8(fp)
 203c374:	01400104 	movi	r5,4
 203c378:	01800244 	movi	r6,9
 203c37c:	01c00044 	movi	r7,1
 203c380:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-T4 set to %d\n", mac_group_index, mac_info_index, 0);
 203c384:	e0fffd47 	ldb	r3,-11(fp)
 203c388:	e0bffd07 	ldb	r2,-12(fp)
 203c38c:	01008174 	movhi	r4,517
 203c390:	21037504 	addi	r4,r4,3540
 203c394:	180b883a 	mov	r5,r3
 203c398:	100d883a 	mov	r6,r2
 203c39c:	000f883a 	mov	r7,zero
 203c3a0:	20381e40 	call	20381e4 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_FULL, 1, 0);
 203c3a4:	d8000015 	stw	zero,0(sp)
 203c3a8:	e13ffe17 	ldw	r4,-8(fp)
 203c3ac:	01400104 	movi	r5,4
 203c3b0:	01800204 	movi	r6,8
 203c3b4:	01c00044 	movi	r7,1
 203c3b8:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203c3bc:	e0fffd47 	ldb	r3,-11(fp)
 203c3c0:	e0bffd07 	ldb	r2,-12(fp)
 203c3c4:	01008174 	movhi	r4,517
 203c3c8:	21038504 	addi	r4,r4,3604
 203c3cc:	180b883a 	mov	r5,r3
 203c3d0:	100d883a 	mov	r6,r2
 203c3d4:	000f883a 	mov	r7,zero
 203c3d8:	20381e40 	call	20381e4 <no_printf>
        
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_100BASE_TX_HALF, 1, 0);
 203c3dc:	d8000015 	stw	zero,0(sp)
 203c3e0:	e13ffe17 	ldw	r4,-8(fp)
 203c3e4:	01400104 	movi	r5,4
 203c3e8:	018001c4 	movi	r6,7
 203c3ec:	01c00044 	movi	r7,1
 203c3f0:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 100 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203c3f4:	e0fffd47 	ldb	r3,-11(fp)
 203c3f8:	e0bffd07 	ldb	r2,-12(fp)
 203c3fc:	01008174 	movhi	r4,517
 203c400:	21039804 	addi	r4,r4,3680
 203c404:	180b883a 	mov	r5,r3
 203c408:	100d883a 	mov	r6,r2
 203c40c:	000f883a 	mov	r7,zero
 203c410:	20381e40 	call	20381e4 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);  
 203c414:	e0bffd83 	ldbu	r2,-10(fp)
 203c418:	e13ffe17 	ldw	r4,-8(fp)
 203c41c:	100b883a 	mov	r5,r2
 203c420:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 203c424:	0005883a 	mov	r2,zero
}
 203c428:	e037883a 	mov	sp,fp
 203c42c:	dfc00117 	ldw	ra,4(sp)
 203c430:	df000017 	ldw	fp,0(sp)
 203c434:	dec00204 	addi	sp,sp,8
 203c438:	f800283a 	ret

0203c43c <alt_tse_phy_set_adv_10>:
 * @param pmac   Pointer to the alt_tse_phy_info structure
 *        enable set Enable = 1 to advertise this speed if the PHY capable
 *               set Enable = 0 to disable advertise of this speed
 * @return       return SUCCESS
 */
alt_32 alt_tse_phy_set_adv_10(alt_tse_phy_info *pphy, alt_u8 enable) {
 203c43c:	defff504 	addi	sp,sp,-44
 203c440:	dfc00a15 	stw	ra,40(sp)
 203c444:	df000915 	stw	fp,36(sp)
 203c448:	df000904 	addi	fp,sp,36
 203c44c:	e13ffe15 	stw	r4,-8(fp)
 203c450:	2805883a 	mov	r2,r5
 203c454:	e0bfff05 	stb	r2,-4(fp)
	alt_u8 cap;
    
    /* pointer to MAC associated and MAC group */
    alt_tse_mac_info *pmac_info = pphy->pmac_info;
 203c458:	e0bffe17 	ldw	r2,-8(fp)
 203c45c:	10800617 	ldw	r2,24(r2)
 203c460:	e0bff815 	stw	r2,-32(fp)
    alt_tse_mac_group *pmac_group = pmac_info->pmac_group;
 203c464:	e0bff817 	ldw	r2,-32(fp)
 203c468:	10800317 	ldw	r2,12(r2)
 203c46c:	e0bff915 	stw	r2,-28(fp)
    
    /* get index of the pointers in pointer array list */
    int mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203c470:	e13ff817 	ldw	r4,-32(fp)
 203c474:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203c478:	e0bffa15 	stw	r2,-24(fp)
    int mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203c47c:	e13ff917 	ldw	r4,-28(fp)
 203c480:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203c484:	e0bffb15 	stw	r2,-20(fp)
    
    /* Record previous MDIO address, to be restored at the end of function */
    int mdioadd_prev = alt_tse_phy_rd_mdio_addr(pphy); 
 203c488:	e13ffe17 	ldw	r4,-8(fp)
 203c48c:	203a1040 	call	203a104 <alt_tse_phy_rd_mdio_addr>
 203c490:	e0bffc15 	stw	r2,-16(fp)
       
    /* write PHY address to MDIO to access the i-th PHY */
    alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203c494:	e0bffe17 	ldw	r2,-8(fp)
 203c498:	10800003 	ldbu	r2,0(r2)
 203c49c:	10803fcc 	andi	r2,r2,255
 203c4a0:	e13ffe17 	ldw	r4,-8(fp)
 203c4a4:	100b883a 	mov	r5,r2
 203c4a8:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    /* if enable = 1, set advertisement based on PHY capability */
    if(enable) {
 203c4ac:	e0bfff03 	ldbu	r2,-4(fp)
 203c4b0:	10002926 	beq	r2,zero,203c558 <alt_tse_phy_set_adv_10+0x11c>
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_FULL, 1);
 203c4b4:	e13ffe17 	ldw	r4,-8(fp)
 203c4b8:	01400044 	movi	r5,1
 203c4bc:	01800304 	movi	r6,12
 203c4c0:	01c00044 	movi	r7,1
 203c4c4:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c4c8:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, cap);
 203c4cc:	e0bffd03 	ldbu	r2,-12(fp)
 203c4d0:	d8800015 	stw	r2,0(sp)
 203c4d4:	e13ffe17 	ldw	r4,-8(fp)
 203c4d8:	01400104 	movi	r5,4
 203c4dc:	01800184 	movi	r6,6
 203c4e0:	01c00044 	movi	r7,1
 203c4e4:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 203c4e8:	e0bffd03 	ldbu	r2,-12(fp)
 203c4ec:	01008174 	movhi	r4,517
 203c4f0:	2103ab04 	addi	r4,r4,3756
 203c4f4:	e17ffb17 	ldw	r5,-20(fp)
 203c4f8:	e1bffa17 	ldw	r6,-24(fp)
 203c4fc:	100f883a 	mov	r7,r2
 203c500:	20381e40 	call	20381e4 <no_printf>
    
        cap = alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_10BASE_T_HALF, 1);
 203c504:	e13ffe17 	ldw	r4,-8(fp)
 203c508:	01400044 	movi	r5,1
 203c50c:	018002c4 	movi	r6,11
 203c510:	01c00044 	movi	r7,1
 203c514:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203c518:	e0bffd05 	stb	r2,-12(fp)
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, cap);
 203c51c:	e0bffd03 	ldbu	r2,-12(fp)
 203c520:	d8800015 	stw	r2,0(sp)
 203c524:	e13ffe17 	ldw	r4,-8(fp)
 203c528:	01400104 	movi	r5,4
 203c52c:	01800144 	movi	r6,5
 203c530:	01c00044 	movi	r7,1
 203c534:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, cap);
 203c538:	e0bffd03 	ldbu	r2,-12(fp)
 203c53c:	01008174 	movhi	r4,517
 203c540:	2103be04 	addi	r4,r4,3832
 203c544:	e17ffb17 	ldw	r5,-20(fp)
 203c548:	e1bffa17 	ldw	r6,-24(fp)
 203c54c:	100f883a 	mov	r7,r2
 203c550:	20381e40 	call	20381e4 <no_printf>
 203c554:	00001806 	br	203c5b8 <alt_tse_phy_set_adv_10+0x17c>
    }
    /* else disable advertisement of this speed */
    else {
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_FULL, 1, 0);
 203c558:	d8000015 	stw	zero,0(sp)
 203c55c:	e13ffe17 	ldw	r4,-8(fp)
 203c560:	01400104 	movi	r5,4
 203c564:	01800184 	movi	r6,6
 203c568:	01c00044 	movi	r7,1
 203c56c:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Full Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203c570:	01008174 	movhi	r4,517
 203c574:	2103ab04 	addi	r4,r4,3756
 203c578:	e17ffb17 	ldw	r5,-20(fp)
 203c57c:	e1bffa17 	ldw	r6,-24(fp)
 203c580:	000f883a 	mov	r7,zero
 203c584:	20381e40 	call	20381e4 <no_printf>
    
        alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_ADV, TSE_PHY_MDIO_ADV_10BASE_TX_HALF, 1, 0);
 203c588:	d8000015 	stw	zero,0(sp)
 203c58c:	e13ffe17 	ldw	r4,-8(fp)
 203c590:	01400104 	movi	r5,4
 203c594:	01800144 	movi	r6,5
 203c598:	01c00044 	movi	r7,1
 203c59c:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
        tse_dprintf(6, "INFO    : PHY[%d.%d] - Advertisement of 10 Base-TX Half Duplex set to %d\n", mac_group_index, mac_info_index, 0);
 203c5a0:	01008174 	movhi	r4,517
 203c5a4:	2103be04 	addi	r4,r4,3832
 203c5a8:	e17ffb17 	ldw	r5,-20(fp)
 203c5ac:	e1bffa17 	ldw	r6,-24(fp)
 203c5b0:	000f883a 	mov	r7,zero
 203c5b4:	20381e40 	call	20381e4 <no_printf>
    }
    
    /* Restore previous MDIO address */
    alt_tse_phy_wr_mdio_addr(pphy, mdioadd_prev);
 203c5b8:	e0bffc17 	ldw	r2,-16(fp)
 203c5bc:	10803fcc 	andi	r2,r2,255
 203c5c0:	e13ffe17 	ldw	r4,-8(fp)
 203c5c4:	100b883a 	mov	r5,r2
 203c5c8:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>
    
    return SUCCESS;
 203c5cc:	0005883a 	mov	r2,zero
}
 203c5d0:	e037883a 	mov	sp,fp
 203c5d4:	dfc00117 	ldw	ra,4(sp)
 203c5d8:	df000017 	ldw	fp,0(sp)
 203c5dc:	dec00204 	addi	sp,sp,8
 203c5e0:	f800283a 	ret

0203c5e4 <alt_tse_phy_get_common_speed>:
/* @Function Description: Get the common speed supported by all PHYs connected to the MAC within the same group
 * @API Type:           Internal
 * @param pmac_group    Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 * @return              common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if no common speed found
 */
alt_32 alt_tse_phy_get_common_speed(alt_tse_mac_group *pmac_group) {
 203c5e4:	defff604 	addi	sp,sp,-40
 203c5e8:	dfc00915 	stw	ra,36(sp)
 203c5ec:	df000815 	stw	fp,32(sp)
 203c5f0:	df000804 	addi	fp,sp,32
 203c5f4:	e13fff15 	stw	r4,-4(fp)
    
	alt_32 i;
	alt_u8 common_1000 = 1;
 203c5f8:	00800044 	movi	r2,1
 203c5fc:	e0bff905 	stb	r2,-28(fp)
	alt_u8 common_100 = 1;
 203c600:	00800044 	movi	r2,1
 203c604:	e0bff945 	stb	r2,-27(fp)
	alt_u8 common_10 = 1;
 203c608:	00800044 	movi	r2,1
 203c60c:	e0bff985 	stb	r2,-26(fp)
    
	alt_32 common_speed;
    
	alt_u8 none_an_complete = 1;
 203c610:	00800044 	movi	r2,1
 203c614:	e0bffb05 	stb	r2,-20(fp)
    
    alt_tse_mac_info *pmac_info = 0;
 203c618:	e03ffc15 	stw	zero,-16(fp)
    alt_tse_phy_info *pphy = 0;
 203c61c:	e03ffd15 	stw	zero,-12(fp)
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203c620:	e13fff17 	ldw	r4,-4(fp)
 203c624:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203c628:	e0bffe05 	stb	r2,-8(fp)
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 203c62c:	e03ff815 	stw	zero,-32(fp)
 203c630:	00001c06 	br	203c6a4 <alt_tse_phy_get_common_speed+0xc0>
        pmac_info = pmac_group->pmac_info[i];
 203c634:	e0ffff17 	ldw	r3,-4(fp)
 203c638:	e0bff817 	ldw	r2,-32(fp)
 203c63c:	10800044 	addi	r2,r2,1
 203c640:	1085883a 	add	r2,r2,r2
 203c644:	1085883a 	add	r2,r2,r2
 203c648:	1885883a 	add	r2,r3,r2
 203c64c:	10800017 	ldw	r2,0(r2)
 203c650:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 203c654:	e0bffc17 	ldw	r2,-16(fp)
 203c658:	10800117 	ldw	r2,4(r2)
 203c65c:	e0bffd15 	stw	r2,-12(fp)
        
        /* run only if PHY connected */
        if(pphy) {
 203c660:	e0bffd17 	ldw	r2,-12(fp)
 203c664:	10000926 	beq	r2,zero,203c68c <alt_tse_phy_get_common_speed+0xa8>
            alt_tse_phy_set_adv_1000(pphy, 1);
 203c668:	e13ffd17 	ldw	r4,-12(fp)
 203c66c:	01400044 	movi	r5,1
 203c670:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 203c674:	e13ffd17 	ldw	r4,-12(fp)
 203c678:	01400044 	movi	r5,1
 203c67c:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 203c680:	e13ffd17 	ldw	r4,-12(fp)
 203c684:	01400044 	movi	r5,1
 203c688:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
        }
        tse_dprintf(6, "\n");
 203c68c:	01008174 	movhi	r4,517
 203c690:	21016404 	addi	r4,r4,1424
 203c694:	20381e40 	call	20381e4 <no_printf>
    alt_tse_phy_info *pphy = 0;
    
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
    
    /* reset Auto-Negotiation advertisement */
    for(i = 0; i < pmac_group->channel; i++) {
 203c698:	e0bff817 	ldw	r2,-32(fp)
 203c69c:	10800044 	addi	r2,r2,1
 203c6a0:	e0bff815 	stw	r2,-32(fp)
 203c6a4:	e0bfff17 	ldw	r2,-4(fp)
 203c6a8:	10800003 	ldbu	r2,0(r2)
 203c6ac:	10803fcc 	andi	r2,r2,255
 203c6b0:	e0fff817 	ldw	r3,-32(fp)
 203c6b4:	18bfdf16 	blt	r3,r2,203c634 <alt_tse_phy_get_common_speed+0x50>
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 203c6b8:	e03ff815 	stw	zero,-32(fp)
 203c6bc:	00005606 	br	203c818 <alt_tse_phy_get_common_speed+0x234>

        pmac_info = pmac_group->pmac_info[i];
 203c6c0:	e0ffff17 	ldw	r3,-4(fp)
 203c6c4:	e0bff817 	ldw	r2,-32(fp)
 203c6c8:	10800044 	addi	r2,r2,1
 203c6cc:	1085883a 	add	r2,r2,r2
 203c6d0:	1085883a 	add	r2,r2,r2
 203c6d4:	1885883a 	add	r2,r3,r2
 203c6d8:	10800017 	ldw	r2,0(r2)
 203c6dc:	e0bffc15 	stw	r2,-16(fp)
        pphy = pmac_info->pphy_info;
 203c6e0:	e0bffc17 	ldw	r2,-16(fp)
 203c6e4:	10800117 	ldw	r2,4(r2)
 203c6e8:	e0bffd15 	stw	r2,-12(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 203c6ec:	e0bffd17 	ldw	r2,-12(fp)
 203c6f0:	10004326 	beq	r2,zero,203c800 <alt_tse_phy_get_common_speed+0x21c>
            continue;
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
 203c6f4:	e13ffd17 	ldw	r4,-12(fp)
 203c6f8:	203baa00 	call	203baa0 <alt_tse_phy_get_cap>
 203c6fc:	1000421e 	bne	r2,zero,203c808 <alt_tse_phy_get_common_speed+0x224>
            continue;
        }
        
        none_an_complete = 0;
 203c700:	e03ffb05 	stb	zero,-20(fp)
        
        /* Small MAC */
        if(pmac_info->mac_type == ALTERA_TSE_MACLITE_10_100) {
 203c704:	e0bffc17 	ldw	r2,-16(fp)
 203c708:	10800003 	ldbu	r2,0(r2)
 203c70c:	10803fcc 	andi	r2,r2,255
 203c710:	10800058 	cmpnei	r2,r2,1
 203c714:	1000021e 	bne	r2,zero,203c720 <alt_tse_phy_get_common_speed+0x13c>
            common_1000 = 0;
 203c718:	e03ff905 	stb	zero,-28(fp)
 203c71c:	00000706 	br	203c73c <alt_tse_phy_get_common_speed+0x158>
        }
        else if(pmac_info->mac_type == ALTERA_TSE_MACLITE_1000) {
 203c720:	e0bffc17 	ldw	r2,-16(fp)
 203c724:	10800003 	ldbu	r2,0(r2)
 203c728:	10803fcc 	andi	r2,r2,255
 203c72c:	10800098 	cmpnei	r2,r2,2
 203c730:	1000021e 	bne	r2,zero,203c73c <alt_tse_phy_get_common_speed+0x158>
            common_100 = 0;
 203c734:	e03ff945 	stb	zero,-27(fp)
            common_10 = 0;            
 203c738:	e03ff985 	stb	zero,-26(fp)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
 203c73c:	e0bffd17 	ldw	r2,-12(fp)
 203c740:	10c000c3 	ldbu	r3,3(r2)
 203c744:	e0bffd17 	ldw	r2,-12(fp)
 203c748:	10800303 	ldbu	r2,12(r2)
 203c74c:	1884703a 	and	r2,r3,r2
 203c750:	1007883a 	mov	r3,r2
 203c754:	e0bff903 	ldbu	r2,-28(fp)
 203c758:	1884703a 	and	r2,r3,r2
 203c75c:	e0bff905 	stb	r2,-28(fp)
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 203c760:	e0bffd17 	ldw	r2,-12(fp)
 203c764:	10c00183 	ldbu	r3,6(r2)
 203c768:	e0bffd17 	ldw	r2,-12(fp)
 203c76c:	108003c3 	ldbu	r2,15(r2)
 203c770:	1884703a 	and	r2,r3,r2
 203c774:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
 203c778:	e0bffd17 	ldw	r2,-12(fp)
 203c77c:	110001c3 	ldbu	r4,7(r2)
 203c780:	e0bffd17 	ldw	r2,-12(fp)
 203c784:	10800403 	ldbu	r2,16(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 203c788:	2084703a 	and	r2,r4,r2
 203c78c:	1884b03a 	or	r2,r3,r2
 203c790:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
 203c794:	e0bffd17 	ldw	r2,-12(fp)
 203c798:	11000143 	ldbu	r4,5(r2)
 203c79c:	e0bffd17 	ldw	r2,-12(fp)
 203c7a0:	10800383 	ldbu	r2,14(r2)
        }
        
        /* get common capabilities for all PHYs and link partners */
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
 203c7a4:	2084703a 	and	r2,r4,r2
 203c7a8:	1884b03a 	or	r2,r3,r2
 203c7ac:	1007883a 	mov	r3,r2
 203c7b0:	e0bff943 	ldbu	r2,-27(fp)
 203c7b4:	1884703a 	and	r2,r3,r2
 203c7b8:	e0bff945 	stb	r2,-27(fp)
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 203c7bc:	e0bffd17 	ldw	r2,-12(fp)
 203c7c0:	10c00283 	ldbu	r3,10(r2)
 203c7c4:	e0bffd17 	ldw	r2,-12(fp)
 203c7c8:	10800443 	ldbu	r2,17(r2)
 203c7cc:	1884703a 	and	r2,r3,r2
 203c7d0:	1007883a 	mov	r3,r2
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));
 203c7d4:	e0bffd17 	ldw	r2,-12(fp)
 203c7d8:	110002c3 	ldbu	r4,11(r2)
 203c7dc:	e0bffd17 	ldw	r2,-12(fp)
 203c7e0:	10800483 	ldbu	r2,18(r2)
        common_1000 &= ((pphy->link_capability.cap_1000_base_t_full & pphy->link_capability.lp_1000_base_t_full));
                        //(pphy->link_capability.cap_1000_base_t_half & pphy->link_capability.lp_1000_base_t_half));
        common_100 &= ((pphy->link_capability.cap_100_base_x_full & pphy->link_capability.lp_100_base_tx_full) |
                        (pphy->link_capability.cap_100_base_x_half & pphy->link_capability.lp_100_base_tx_half) |
                        (pphy->link_capability.cap_100_base_t4 & pphy->link_capability.lp_100_base_t4));
        common_10 &= ((pphy->link_capability.cap_10_base_t_full & pphy->link_capability.lp_10_base_tx_full) |
 203c7e4:	2084703a 	and	r2,r4,r2
 203c7e8:	1884b03a 	or	r2,r3,r2
 203c7ec:	1007883a 	mov	r3,r2
 203c7f0:	e0bff983 	ldbu	r2,-26(fp)
 203c7f4:	1884703a 	and	r2,r3,r2
 203c7f8:	e0bff985 	stb	r2,-26(fp)
 203c7fc:	00000306 	br	203c80c <alt_tse_phy_get_common_speed+0x228>
        pmac_info = pmac_group->pmac_info[i];
        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 203c800:	0001883a 	nop
 203c804:	00000106 	br	203c80c <alt_tse_phy_get_common_speed+0x228>
        }
        
        /* get PHY capability */
        /* skip for PHY with Auto-Negotiation not completed */
        if(alt_tse_phy_get_cap(pphy) != TSE_PHY_AN_COMPLETE) {
            continue;
 203c808:	0001883a 	nop
        }
        tse_dprintf(6, "\n");
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 203c80c:	e0bff817 	ldw	r2,-32(fp)
 203c810:	10800044 	addi	r2,r2,1
 203c814:	e0bff815 	stw	r2,-32(fp)
 203c818:	e0bfff17 	ldw	r2,-4(fp)
 203c81c:	10800003 	ldbu	r2,0(r2)
 203c820:	10803fcc 	andi	r2,r2,255
 203c824:	e0fff817 	ldw	r3,-32(fp)
 203c828:	18bfa516 	blt	r3,r2,203c6c0 <alt_tse_phy_get_common_speed+0xdc>
                        (pphy->link_capability.cap_10_base_t_half & pphy->link_capability.lp_10_base_tx_half));

    }
    
    /* get common speed based on capabilities */
    if(none_an_complete == 1) {
 203c82c:	e0bffb03 	ldbu	r2,-20(fp)
 203c830:	10800058 	cmpnei	r2,r2,1
 203c834:	1000081e 	bne	r2,zero,203c858 <alt_tse_phy_get_common_speed+0x274>
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 203c838:	00bfffc4 	movi	r2,-1
 203c83c:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - None of the PHYs Auto-Negotiation completed!\n", mac_group_index);
 203c840:	e0bffe07 	ldb	r2,-8(fp)
 203c844:	01008174 	movhi	r4,517
 203c848:	2103d104 	addi	r4,r4,3908
 203c84c:	100b883a 	mov	r5,r2
 203c850:	2006a240 	call	2006a24 <printf>
 203c854:	00002706 	br	203c8f4 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_1000) {
 203c858:	e0bff903 	ldbu	r2,-28(fp)
 203c85c:	10000926 	beq	r2,zero,203c884 <alt_tse_phy_get_common_speed+0x2a0>
        common_speed = TSE_PHY_SPEED_1000;
 203c860:	00800084 	movi	r2,2
 203c864:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 1000);
 203c868:	e0bffe07 	ldb	r2,-8(fp)
 203c86c:	01008174 	movhi	r4,517
 203c870:	2103e304 	addi	r4,r4,3980
 203c874:	100b883a 	mov	r5,r2
 203c878:	0180fa04 	movi	r6,1000
 203c87c:	2006a240 	call	2006a24 <printf>
 203c880:	00001c06 	br	203c8f4 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_100) {
 203c884:	e0bff943 	ldbu	r2,-27(fp)
 203c888:	10000926 	beq	r2,zero,203c8b0 <alt_tse_phy_get_common_speed+0x2cc>
        common_speed = TSE_PHY_SPEED_100;
 203c88c:	00800044 	movi	r2,1
 203c890:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 100);
 203c894:	e0bffe07 	ldb	r2,-8(fp)
 203c898:	01008174 	movhi	r4,517
 203c89c:	2103e304 	addi	r4,r4,3980
 203c8a0:	100b883a 	mov	r5,r2
 203c8a4:	01801904 	movi	r6,100
 203c8a8:	2006a240 	call	2006a24 <printf>
 203c8ac:	00001106 	br	203c8f4 <alt_tse_phy_get_common_speed+0x310>
    }
    else if(common_10) {
 203c8b0:	e0bff983 	ldbu	r2,-26(fp)
 203c8b4:	10000826 	beq	r2,zero,203c8d8 <alt_tse_phy_get_common_speed+0x2f4>
        common_speed = TSE_PHY_SPEED_10;
 203c8b8:	e03ffa15 	stw	zero,-24(fp)
        tse_dprintf(5, "INFO    : MAC Group[%d] - Common Speed : %d Mbps\n", mac_group_index, 10);
 203c8bc:	e0bffe07 	ldb	r2,-8(fp)
 203c8c0:	01008174 	movhi	r4,517
 203c8c4:	2103e304 	addi	r4,r4,3980
 203c8c8:	100b883a 	mov	r5,r2
 203c8cc:	01800284 	movi	r6,10
 203c8d0:	2006a240 	call	2006a24 <printf>
 203c8d4:	00000706 	br	203c8f4 <alt_tse_phy_get_common_speed+0x310>
    }
    else {
        common_speed = TSE_PHY_SPEED_NO_COMMON;
 203c8d8:	00bfffc4 	movi	r2,-1
 203c8dc:	e0bffa15 	stw	r2,-24(fp)
        tse_dprintf(2, "ERROR   : MAC Group[%d] - No common speed at all!\n", mac_group_index);    }
 203c8e0:	e0bffe07 	ldb	r2,-8(fp)
 203c8e4:	01008174 	movhi	r4,517
 203c8e8:	2103f004 	addi	r4,r4,4032
 203c8ec:	100b883a 	mov	r5,r2
 203c8f0:	2006a240 	call	2006a24 <printf>

    return common_speed;
 203c8f4:	e0bffa17 	ldw	r2,-24(fp)
}
 203c8f8:	e037883a 	mov	sp,fp
 203c8fc:	dfc00117 	ldw	ra,4(sp)
 203c900:	df000017 	ldw	fp,0(sp)
 203c904:	dec00204 	addi	sp,sp,8
 203c908:	f800283a 	ret

0203c90c <alt_tse_phy_set_common_speed>:
 * @API Type:               Internal
 * @param pmac_group        Pointer to the TSE MAC Group structure which group all the MACs that should use the same speed
 *        common_speed      common speed supported by all PHYs
 * @return      common speed supported by all PHYs connected to the MAC, return TSE_PHY_SPEED_NO_COMMON if invalid common speed specified
 */
alt_32 alt_tse_phy_set_common_speed(alt_tse_mac_group *pmac_group, alt_32 common_speed) {
 203c90c:	defff004 	addi	sp,sp,-64
 203c910:	dfc00f15 	stw	ra,60(sp)
 203c914:	df000e15 	stw	fp,56(sp)
 203c918:	dc400d15 	stw	r17,52(sp)
 203c91c:	dc000c15 	stw	r16,48(sp)
 203c920:	df000c04 	addi	fp,sp,48
 203c924:	e13ffe15 	stw	r4,-8(fp)
 203c928:	e17fff15 	stw	r5,-4(fp)
	alt_u8 speed;
	alt_u8 duplex;
    
	alt_u8 gb_capable;
    
    alt_tse_phy_info *pphy = 0;
 203c92c:	e03ff715 	stw	zero,-36(fp)
    alt_tse_mac_info *pmac_info = 0;
 203c930:	e03ff815 	stw	zero,-32(fp)
    alt_tse_system_info *psys = 0;
 203c934:	e03ff915 	stw	zero,-28(fp)
    
    /* get index of the pointers in pointer array list */
    alt_8 mac_info_index = 0;
 203c938:	e03ffa05 	stb	zero,-24(fp)
    alt_8 mac_group_index = alt_tse_get_mac_group_index(pmac_group);
 203c93c:	e13ffe17 	ldw	r4,-8(fp)
 203c940:	20393580 	call	2039358 <alt_tse_get_mac_group_index>
 203c944:	e0bffa45 	stb	r2,-23(fp)
         
    /* Record previous MDIO address, to be restored at the end of function */
    np_tse_mac *pmac_group_base = (np_tse_mac *)pmac_group->pmac_info[0]->psys_info->tse_mac_base;
 203c948:	e0bffe17 	ldw	r2,-8(fp)
 203c94c:	10800117 	ldw	r2,4(r2)
 203c950:	10800217 	ldw	r2,8(r2)
 203c954:	10800017 	ldw	r2,0(r2)
 203c958:	e0bffb15 	stw	r2,-20(fp)
    alt_32 mdioadd_prev = IORD(&pmac_group_base->MDIO_ADDR1, 0);
 203c95c:	e0bffb17 	ldw	r2,-20(fp)
 203c960:	10801004 	addi	r2,r2,64
 203c964:	10800037 	ldwio	r2,0(r2)
 203c968:	e0bffc15 	stw	r2,-16(fp)
    
    if((common_speed < TSE_PHY_SPEED_10) || (common_speed > TSE_PHY_SPEED_1000)) {
 203c96c:	e0bfff17 	ldw	r2,-4(fp)
 203c970:	10000316 	blt	r2,zero,203c980 <alt_tse_phy_set_common_speed+0x74>
 203c974:	e0bfff17 	ldw	r2,-4(fp)
 203c978:	108000d0 	cmplti	r2,r2,3
 203c97c:	10000c1e 	bne	r2,zero,203c9b0 <alt_tse_phy_set_common_speed+0xa4>
        tse_dprintf(2, "ERROR   : MAC Group[%d] - Invalid common speed specified! common speed = %d\n", mac_group_index, (int)common_speed);
 203c980:	e0bffa47 	ldb	r2,-23(fp)
 203c984:	01008174 	movhi	r4,517
 203c988:	2103fd04 	addi	r4,r4,4084
 203c98c:	100b883a 	mov	r5,r2
 203c990:	e1bfff17 	ldw	r6,-4(fp)
 203c994:	2006a240 	call	2006a24 <printf>
		/* Restore previous MDIO address */
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 203c998:	e0bffb17 	ldw	r2,-20(fp)
 203c99c:	10801004 	addi	r2,r2,64
 203c9a0:	e0fffc17 	ldw	r3,-16(fp)
 203c9a4:	10c00035 	stwio	r3,0(r2)
        return TSE_PHY_SPEED_NO_COMMON;
 203c9a8:	00bfffc4 	movi	r2,-1
 203c9ac:	0000fe06 	br	203cda8 <alt_tse_phy_set_common_speed+0x49c>
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 203c9b0:	e03ff515 	stw	zero,-44(fp)
 203c9b4:	0000dc06 	br	203cd28 <alt_tse_phy_set_common_speed+0x41c>
        pmac_info = pmac_group->pmac_info[i];
 203c9b8:	e0fffe17 	ldw	r3,-8(fp)
 203c9bc:	e0bff517 	ldw	r2,-44(fp)
 203c9c0:	10800044 	addi	r2,r2,1
 203c9c4:	1085883a 	add	r2,r2,r2
 203c9c8:	1085883a 	add	r2,r2,r2
 203c9cc:	1885883a 	add	r2,r3,r2
 203c9d0:	10800017 	ldw	r2,0(r2)
 203c9d4:	e0bff815 	stw	r2,-32(fp)
        mac_info_index = alt_tse_get_mac_info_index(pmac_info);
 203c9d8:	e13ff817 	ldw	r4,-32(fp)
 203c9dc:	20393cc0 	call	20393cc <alt_tse_get_mac_info_index>
 203c9e0:	e0bffa05 	stb	r2,-24(fp)

        pphy = pmac_info->pphy_info;
 203c9e4:	e0bff817 	ldw	r2,-32(fp)
 203c9e8:	10800117 	ldw	r2,4(r2)
 203c9ec:	e0bff715 	stw	r2,-36(fp)
        
        /* if no PHY connected */
        if(!pphy) {
 203c9f0:	e0bff717 	ldw	r2,-36(fp)
 203c9f4:	1000c826 	beq	r2,zero,203cd18 <alt_tse_phy_set_common_speed+0x40c>
            continue;
        }
        
        psys = pmac_info->psys_info; 
 203c9f8:	e0bff817 	ldw	r2,-32(fp)
 203c9fc:	10800217 	ldw	r2,8(r2)
 203ca00:	e0bff915 	stw	r2,-28(fp)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);
 203ca04:	e0bff717 	ldw	r2,-36(fp)
 203ca08:	10800003 	ldbu	r2,0(r2)
 203ca0c:	10803fcc 	andi	r2,r2,255
 203ca10:	e13ff717 	ldw	r4,-36(fp)
 203ca14:	100b883a 	mov	r5,r2
 203ca18:	203a14c0 	call	203a14c <alt_tse_phy_wr_mdio_addr>

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 203ca1c:	e0bff717 	ldw	r2,-36(fp)
 203ca20:	108000c3 	ldbu	r2,3(r2)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 203ca24:	10803fcc 	andi	r2,r2,255
 203ca28:	10000c1e 	bne	r2,zero,203ca5c <alt_tse_phy_set_common_speed+0x150>
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 203ca2c:	e0bff717 	ldw	r2,-36(fp)
 203ca30:	10800103 	ldbu	r2,4(r2)
 203ca34:	10803fcc 	andi	r2,r2,255
 203ca38:	1000081e 	bne	r2,zero,203ca5c <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 203ca3c:	e0bff717 	ldw	r2,-36(fp)
 203ca40:	10800043 	ldbu	r2,1(r2)
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 203ca44:	10803fcc 	andi	r2,r2,255
 203ca48:	1000041e 	bne	r2,zero,203ca5c <alt_tse_phy_set_common_speed+0x150>
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
 203ca4c:	e0bff717 	ldw	r2,-36(fp)
 203ca50:	10800083 	ldbu	r2,2(r2)
 203ca54:	10803fcc 	andi	r2,r2,255
 203ca58:	10000226 	beq	r2,zero,203ca64 <alt_tse_phy_set_common_speed+0x158>
 203ca5c:	00800044 	movi	r2,1
 203ca60:	00000106 	br	203ca68 <alt_tse_phy_set_common_speed+0x15c>
 203ca64:	0005883a 	mov	r2,zero
        	
        /* write PHY address to MDIO to access the i-th PHY */
        alt_tse_phy_wr_mdio_addr(pphy, pphy->mdio_address);

        /* capability of PHY supports 1000 Mbps */
        gb_capable = pphy->link_capability.cap_1000_base_t_full || pphy->link_capability.cap_1000_base_t_half || 
 203ca68:	e0bffd05 	stb	r2,-12(fp)
                 pphy->link_capability.cap_1000_base_x_full || pphy->link_capability.cap_1000_base_x_half;
        
        /* if PHY does not supports 1000 Mbps, and common speed is 1000 Mbps */
        if((!gb_capable) && (common_speed == TSE_PHY_SPEED_1000)) {
 203ca6c:	e0bffd03 	ldbu	r2,-12(fp)
 203ca70:	1000101e 	bne	r2,zero,203cab4 <alt_tse_phy_set_common_speed+0x1a8>
 203ca74:	e0bfff17 	ldw	r2,-4(fp)
 203ca78:	10800098 	cmpnei	r2,r2,2
 203ca7c:	10000d1e 	bne	r2,zero,203cab4 <alt_tse_phy_set_common_speed+0x1a8>
            tse_dprintf(2, "ERROR   : PHY[%d.%d] - PHY does not support 1000 Mbps, please specify valid common speed\n", mac_group_index, mac_info_index);
 203ca80:	e0fffa47 	ldb	r3,-23(fp)
 203ca84:	e0bffa07 	ldb	r2,-24(fp)
 203ca88:	01008174 	movhi	r4,517
 203ca8c:	21041104 	addi	r4,r4,4164
 203ca90:	180b883a 	mov	r5,r3
 203ca94:	100d883a 	mov	r6,r2
 203ca98:	2006a240 	call	2006a24 <printf>
			/* Restore previous MDIO address */
			IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 203ca9c:	e0bffb17 	ldw	r2,-20(fp)
 203caa0:	10801004 	addi	r2,r2,64
 203caa4:	e0fffc17 	ldw	r3,-16(fp)
 203caa8:	10c00035 	stwio	r3,0(r2)
            return TSE_PHY_SPEED_NO_COMMON;
 203caac:	00bfffc4 	movi	r2,-1
 203cab0:	0000bd06 	br	203cda8 <alt_tse_phy_set_common_speed+0x49c>
        }
        
        /* if PHY is not Auto-Negotiation capable */
        if(!alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_ABILITY, 1)) {
 203cab4:	e13ff717 	ldw	r4,-36(fp)
 203cab8:	01400044 	movi	r5,1
 203cabc:	018000c4 	movi	r6,3
 203cac0:	01c00044 	movi	r7,1
 203cac4:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203cac8:	1000141e 	bne	r2,zero,203cb1c <alt_tse_phy_set_common_speed+0x210>
            
            /* if PHY supports 1000 Mbps, write msb of speed */
            if(gb_capable) {
 203cacc:	e0bffd03 	ldbu	r2,-12(fp)
 203cad0:	10000926 	beq	r2,zero,203caf8 <alt_tse_phy_set_common_speed+0x1ec>
                alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_MSB, 1, common_speed >> 1);
 203cad4:	e0bfff17 	ldw	r2,-4(fp)
 203cad8:	1005d07a 	srai	r2,r2,1
 203cadc:	10bfffcc 	andi	r2,r2,65535
 203cae0:	d8800015 	stw	r2,0(sp)
 203cae4:	e13ff717 	ldw	r4,-36(fp)
 203cae8:	000b883a 	mov	r5,zero
 203caec:	01800184 	movi	r6,6
 203caf0:	01c00044 	movi	r7,1
 203caf4:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
            }
            /* write lsb of speed */
            alt_tse_phy_wr_mdio_reg(pphy, TSE_PHY_MDIO_CONTROL, TSE_PHY_MDIO_CONTROL_SPEED_LSB, 1, common_speed);
 203caf8:	e0bfff17 	ldw	r2,-4(fp)
 203cafc:	10bfffcc 	andi	r2,r2,65535
 203cb00:	d8800015 	stw	r2,0(sp)
 203cb04:	e13ff717 	ldw	r4,-36(fp)
 203cb08:	000b883a 	mov	r5,zero
 203cb0c:	01800344 	movi	r6,13
 203cb10:	01c00044 	movi	r7,1
 203cb14:	203a1a40 	call	203a1a4 <alt_tse_phy_wr_mdio_reg>
            
            /* continue to next PHY */
            continue;
 203cb18:	00008006 	br	203cd1c <alt_tse_phy_set_common_speed+0x410>
        }
        
        /* set Auto-Negotiation advertisement based on common speed */
        if(common_speed == TSE_PHY_SPEED_1000) {
 203cb1c:	e0bfff17 	ldw	r2,-4(fp)
 203cb20:	10800098 	cmpnei	r2,r2,2
 203cb24:	10000a1e 	bne	r2,zero,203cb50 <alt_tse_phy_set_common_speed+0x244>
            alt_tse_phy_set_adv_1000(pphy, 1);
 203cb28:	e13ff717 	ldw	r4,-36(fp)
 203cb2c:	01400044 	movi	r5,1
 203cb30:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 203cb34:	e13ff717 	ldw	r4,-36(fp)
 203cb38:	01400044 	movi	r5,1
 203cb3c:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 203cb40:	e13ff717 	ldw	r4,-36(fp)
 203cb44:	01400044 	movi	r5,1
 203cb48:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
 203cb4c:	00002206 	br	203cbd8 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else if(common_speed == TSE_PHY_SPEED_100) {
 203cb50:	e0bfff17 	ldw	r2,-4(fp)
 203cb54:	10800058 	cmpnei	r2,r2,1
 203cb58:	10000a1e 	bne	r2,zero,203cb84 <alt_tse_phy_set_common_speed+0x278>
            alt_tse_phy_set_adv_1000(pphy, 0);
 203cb5c:	e13ff717 	ldw	r4,-36(fp)
 203cb60:	000b883a 	mov	r5,zero
 203cb64:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 1);
 203cb68:	e13ff717 	ldw	r4,-36(fp)
 203cb6c:	01400044 	movi	r5,1
 203cb70:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 203cb74:	e13ff717 	ldw	r4,-36(fp)
 203cb78:	01400044 	movi	r5,1
 203cb7c:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
 203cb80:	00001506 	br	203cbd8 <alt_tse_phy_set_common_speed+0x2cc>
        }    
        else if(common_speed == TSE_PHY_SPEED_10) {
 203cb84:	e0bfff17 	ldw	r2,-4(fp)
 203cb88:	10000a1e 	bne	r2,zero,203cbb4 <alt_tse_phy_set_common_speed+0x2a8>
            alt_tse_phy_set_adv_1000(pphy, 0);
 203cb8c:	e13ff717 	ldw	r4,-36(fp)
 203cb90:	000b883a 	mov	r5,zero
 203cb94:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 203cb98:	e13ff717 	ldw	r4,-36(fp)
 203cb9c:	000b883a 	mov	r5,zero
 203cba0:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 1);
 203cba4:	e13ff717 	ldw	r4,-36(fp)
 203cba8:	01400044 	movi	r5,1
 203cbac:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
 203cbb0:	00000906 	br	203cbd8 <alt_tse_phy_set_common_speed+0x2cc>
        }
        else {
            alt_tse_phy_set_adv_1000(pphy, 0);
 203cbb4:	e13ff717 	ldw	r4,-36(fp)
 203cbb8:	000b883a 	mov	r5,zero
 203cbbc:	203c0380 	call	203c038 <alt_tse_phy_set_adv_1000>
            alt_tse_phy_set_adv_100(pphy, 0);
 203cbc0:	e13ff717 	ldw	r4,-36(fp)
 203cbc4:	000b883a 	mov	r5,zero
 203cbc8:	203c1f40 	call	203c1f4 <alt_tse_phy_set_adv_100>
            alt_tse_phy_set_adv_10(pphy, 0);
 203cbcc:	e13ff717 	ldw	r4,-36(fp)
 203cbd0:	000b883a 	mov	r5,zero
 203cbd4:	203c43c0 	call	203c43c <alt_tse_phy_set_adv_10>
        }
        
        /* if PHY Auto-Negotiation is completed */
        if(alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, TSE_PHY_MDIO_STATUS_AN_COMPLETE, 1) == 1) {
 203cbd8:	e13ff717 	ldw	r4,-36(fp)
 203cbdc:	01400044 	movi	r5,1
 203cbe0:	01800144 	movi	r6,5
 203cbe4:	01c00044 	movi	r7,1
 203cbe8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203cbec:	10800058 	cmpnei	r2,r2,1
 203cbf0:	10003b1e 	bne	r2,zero,203cce0 <alt_tse_phy_set_common_speed+0x3d4>
            
            /* read both msb and lsb of speed bits if PHY support 1000 Mbps */
            if(gb_capable) {
 203cbf4:	e0bffd03 	ldbu	r2,-12(fp)
 203cbf8:	10000f26 	beq	r2,zero,203cc38 <alt_tse_phy_set_common_speed+0x32c>
        
                /* get speed information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 2);
 203cbfc:	e0bff717 	ldw	r2,-36(fp)
 203cc00:	10800517 	ldw	r2,20(r2)
 203cc04:	10801583 	ldbu	r2,86(r2)
 203cc08:	10c03fcc 	andi	r3,r2,255
 203cc0c:	e0bff717 	ldw	r2,-36(fp)
 203cc10:	10800517 	ldw	r2,20(r2)
 203cc14:	108015c3 	ldbu	r2,87(r2)
 203cc18:	10803fcc 	andi	r2,r2,255
 203cc1c:	e13ff717 	ldw	r4,-36(fp)
 203cc20:	180b883a 	mov	r5,r3
 203cc24:	100d883a 	mov	r6,r2
 203cc28:	01c00084 	movi	r7,2
 203cc2c:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203cc30:	e0bff605 	stb	r2,-40(fp)
 203cc34:	00000e06 	br	203cc70 <alt_tse_phy_set_common_speed+0x364>
            }
            
            /* read lsb of speed only if PHY support only 10/100 Mbps */
            else {
                /* get speed and link information after Auto-Negotiation */
                speed = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->speed_lsb_location, 1);
 203cc38:	e0bff717 	ldw	r2,-36(fp)
 203cc3c:	10800517 	ldw	r2,20(r2)
 203cc40:	10801583 	ldbu	r2,86(r2)
 203cc44:	10c03fcc 	andi	r3,r2,255
 203cc48:	e0bff717 	ldw	r2,-36(fp)
 203cc4c:	10800517 	ldw	r2,20(r2)
 203cc50:	108015c3 	ldbu	r2,87(r2)
 203cc54:	10803fcc 	andi	r2,r2,255
 203cc58:	e13ff717 	ldw	r4,-36(fp)
 203cc5c:	180b883a 	mov	r5,r3
 203cc60:	100d883a 	mov	r6,r2
 203cc64:	01c00044 	movi	r7,1
 203cc68:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203cc6c:	e0bff605 	stb	r2,-40(fp)
            }
            
            /* if current speed != common speed, then restart Auto-Negotiation */
            if(speed != common_speed) {
 203cc70:	e0fff603 	ldbu	r3,-40(fp)
 203cc74:	e0bfff17 	ldw	r2,-4(fp)
 203cc78:	18800426 	beq	r3,r2,203cc8c <alt_tse_phy_set_common_speed+0x380>
                alt_tse_phy_restart_an(pphy, ALTERA_AUTONEG_TIMEOUT_THRESHOLD);
 203cc7c:	e13ff717 	ldw	r4,-36(fp)
 203cc80:	01400134 	movhi	r5,4
 203cc84:	29742404 	addi	r5,r5,-12144
 203cc88:	203b77c0 	call	203b77c <alt_tse_phy_restart_an>
            }
            
            /* get speed information after Auto-Negotiation */
            duplex = alt_tse_phy_rd_mdio_reg(pphy, pphy->pphy_profile->status_reg_location, pphy->pphy_profile->duplex_bit_location, 1);
 203cc8c:	e0bff717 	ldw	r2,-36(fp)
 203cc90:	10800517 	ldw	r2,20(r2)
 203cc94:	10801583 	ldbu	r2,86(r2)
 203cc98:	10c03fcc 	andi	r3,r2,255
 203cc9c:	e0bff717 	ldw	r2,-36(fp)
 203cca0:	10800517 	ldw	r2,20(r2)
 203cca4:	10801603 	ldbu	r2,88(r2)
 203cca8:	10803fcc 	andi	r2,r2,255
 203ccac:	e13ff717 	ldw	r4,-36(fp)
 203ccb0:	180b883a 	mov	r5,r3
 203ccb4:	100d883a 	mov	r6,r2
 203ccb8:	01c00044 	movi	r7,1
 203ccbc:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203ccc0:	e0bffd45 	stb	r2,-11(fp)
            
            /* Set MAC duplex register */
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
 203ccc4:	e0bff917 	ldw	r2,-28(fp)
 203ccc8:	10800017 	ldw	r2,0(r2)
 203cccc:	1007883a 	mov	r3,r2
 203ccd0:	e0bffd43 	ldbu	r2,-11(fp)
 203ccd4:	1809883a 	mov	r4,r3
 203ccd8:	100b883a 	mov	r5,r2
 203ccdc:	20396040 	call	2039604 <alt_tse_mac_set_duplex>
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
 203cce0:	e47ffa47 	ldb	r17,-23(fp)
 203cce4:	e43ffa07 	ldb	r16,-24(fp)
 203cce8:	e13ff717 	ldw	r4,-36(fp)
 203ccec:	01400044 	movi	r5,1
 203ccf0:	000d883a 	mov	r6,zero
 203ccf4:	01c00404 	movi	r7,16
 203ccf8:	203a2d00 	call	203a2d0 <alt_tse_phy_rd_mdio_reg>
 203ccfc:	01008174 	movhi	r4,517
 203cd00:	21042804 	addi	r4,r4,4256
 203cd04:	880b883a 	mov	r5,r17
 203cd08:	800d883a 	mov	r6,r16
 203cd0c:	100f883a 	mov	r7,r2
 203cd10:	2006a240 	call	2006a24 <printf>
 203cd14:	00000106 	br	203cd1c <alt_tse_phy_set_common_speed+0x410>

        pphy = pmac_info->pphy_info;
        
        /* if no PHY connected */
        if(!pphy) {
            continue;
 203cd18:	0001883a 	nop
		IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
        return TSE_PHY_SPEED_NO_COMMON;
    }
    
    /* loop through every PHY connected */
    for(i = 0; i < pmac_group->channel; i++) {
 203cd1c:	e0bff517 	ldw	r2,-44(fp)
 203cd20:	10800044 	addi	r2,r2,1
 203cd24:	e0bff515 	stw	r2,-44(fp)
 203cd28:	e0bffe17 	ldw	r2,-8(fp)
 203cd2c:	10800003 	ldbu	r2,0(r2)
 203cd30:	10803fcc 	andi	r2,r2,255
 203cd34:	e0fff517 	ldw	r3,-44(fp)
 203cd38:	18bf1f16 	blt	r3,r2,203c9b8 <alt_tse_phy_set_common_speed+0xac>
            alt_tse_mac_set_duplex((np_tse_mac *)psys->tse_mac_base, duplex);
            
        }
        tse_dprintf(5, "INFO    : PHY[%d.%d] - PHY STATUS = 0x%04x\n\n", mac_group_index, mac_info_index, (int) alt_tse_phy_rd_mdio_reg(pphy, TSE_PHY_MDIO_STATUS, 0, 16));        
    }
    tse_dprintf(5, "INFO    : MAC Group[%d] - All PHYs set to common speed : %d Mbps\n", mac_group_index, (common_speed == TSE_PHY_SPEED_1000) ? 1000 : ((common_speed == TSE_PHY_SPEED_100) ? 100 : 10));
 203cd3c:	e0fffa47 	ldb	r3,-23(fp)
 203cd40:	e0bfff17 	ldw	r2,-4(fp)
 203cd44:	108000a0 	cmpeqi	r2,r2,2
 203cd48:	1000071e 	bne	r2,zero,203cd68 <alt_tse_phy_set_common_speed+0x45c>
 203cd4c:	e0bfff17 	ldw	r2,-4(fp)
 203cd50:	10800058 	cmpnei	r2,r2,1
 203cd54:	1000021e 	bne	r2,zero,203cd60 <alt_tse_phy_set_common_speed+0x454>
 203cd58:	00801904 	movi	r2,100
 203cd5c:	00000106 	br	203cd64 <alt_tse_phy_set_common_speed+0x458>
 203cd60:	00800284 	movi	r2,10
 203cd64:	00000106 	br	203cd6c <alt_tse_phy_set_common_speed+0x460>
 203cd68:	0080fa04 	movi	r2,1000
 203cd6c:	01008174 	movhi	r4,517
 203cd70:	21043404 	addi	r4,r4,4304
 203cd74:	180b883a 	mov	r5,r3
 203cd78:	100d883a 	mov	r6,r2
 203cd7c:	2006a240 	call	2006a24 <printf>

    /* Set MAC speed register */
    alt_tse_mac_set_speed(pmac_group_base, common_speed);
 203cd80:	e0bfff17 	ldw	r2,-4(fp)
 203cd84:	10803fcc 	andi	r2,r2,255
 203cd88:	e13ffb17 	ldw	r4,-20(fp)
 203cd8c:	100b883a 	mov	r5,r2
 203cd90:	20395240 	call	2039524 <alt_tse_mac_set_speed>
    
    /* Restore previous MDIO address */
    IOWR(&pmac_group_base->MDIO_ADDR1, 0, mdioadd_prev);
 203cd94:	e0bffb17 	ldw	r2,-20(fp)
 203cd98:	10801004 	addi	r2,r2,64
 203cd9c:	e0fffc17 	ldw	r3,-16(fp)
 203cda0:	10c00035 	stwio	r3,0(r2)
        
    return common_speed;
 203cda4:	e0bfff17 	ldw	r2,-4(fp)
}
 203cda8:	e037883a 	mov	sp,fp
 203cdac:	dfc00317 	ldw	ra,12(sp)
 203cdb0:	df000217 	ldw	fp,8(sp)
 203cdb4:	dc400117 	ldw	r17,4(sp)
 203cdb8:	dc000017 	ldw	r16,0(sp)
 203cdbc:	dec00404 	addi	sp,sp,16
 203cdc0:	f800283a 	ret

0203cdc4 <marvell_phy_cfg>:

/* @Function Description: Additional configuration for Marvell PHY
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address of MAC group
 */
alt_32 marvell_phy_cfg(np_tse_mac *pmac) {
 203cdc4:	defffc04 	addi	sp,sp,-16
 203cdc8:	dfc00315 	stw	ra,12(sp)
 203cdcc:	df000215 	stw	fp,8(sp)
 203cdd0:	df000204 	addi	fp,sp,8
 203cdd4:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat;
    
    /* If there is no link yet, we enable auto crossover and reset the PHY */
    if((IORD(&pmac->mdio1.STATUS, 0) & PCS_ST_an_done) == 0) {
 203cdd8:	e0bfff17 	ldw	r2,-4(fp)
 203cddc:	1080a104 	addi	r2,r2,644
 203cde0:	10800037 	ldwio	r2,0(r2)
 203cde4:	1080080c 	andi	r2,r2,32
 203cde8:	1000161e 	bne	r2,zero,203ce44 <marvell_phy_cfg+0x80>
        tse_dprintf(5, "MARVELL : Enabling auto crossover\n");
 203cdec:	01008174 	movhi	r4,517
 203cdf0:	21044504 	addi	r4,r4,4372
 203cdf4:	2006cb40 	call	2006cb4 <puts>
        IOWR(&pmac->mdio1.CONTROL, 16, 0x0078);
 203cdf8:	e0bfff17 	ldw	r2,-4(fp)
 203cdfc:	1080a004 	addi	r2,r2,640
 203ce00:	10801004 	addi	r2,r2,64
 203ce04:	00c01e04 	movi	r3,120
 203ce08:	10c00035 	stwio	r3,0(r2)
        tse_dprintf(5, "MARVELL : PHY reset\n");
 203ce0c:	01008174 	movhi	r4,517
 203ce10:	21044e04 	addi	r4,r4,4408
 203ce14:	2006cb40 	call	2006cb4 <puts>
        dat = IORD(&pmac->mdio1.CONTROL, 0); 
 203ce18:	e0bfff17 	ldw	r2,-4(fp)
 203ce1c:	1080a004 	addi	r2,r2,640
 203ce20:	10800037 	ldwio	r2,0(r2)
 203ce24:	e0bffe0d 	sth	r2,-8(fp)
        IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);        
 203ce28:	e0bfff17 	ldw	r2,-4(fp)
 203ce2c:	1080a004 	addi	r2,r2,640
 203ce30:	e13ffe0b 	ldhu	r4,-8(fp)
 203ce34:	00e00004 	movi	r3,-32768
 203ce38:	20c6b03a 	or	r3,r4,r3
 203ce3c:	18ffffcc 	andi	r3,r3,65535
 203ce40:	10c00035 	stwio	r3,0(r2)
    }
    
    return 0;
 203ce44:	0005883a 	mov	r2,zero
}
 203ce48:	e037883a 	mov	sp,fp
 203ce4c:	dfc00117 	ldw	ra,4(sp)
 203ce50:	df000017 	ldw	fp,0(sp)
 203ce54:	dec00204 	addi	sp,sp,8
 203ce58:	f800283a 	ret

0203ce5c <marvell_cfg_gmii>:

/* @Function Description: Change operating mode of Marvell PHY to GMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_gmii(np_tse_mac *pmac) {
 203ce5c:	defffc04 	addi	sp,sp,-16
 203ce60:	dfc00315 	stw	ra,12(sp)
 203ce64:	df000215 	stw	fp,8(sp)
 203ce68:	df000204 	addi	fp,sp,8
 203ce6c:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 203ce70:	e0bfff17 	ldw	r2,-4(fp)
 203ce74:	1080bb04 	addi	r2,r2,748
 203ce78:	10800037 	ldwio	r2,0(r2)
 203ce7c:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 203ce80:	e0fffe0b 	ldhu	r3,-8(fp)
 203ce84:	00bffc04 	movi	r2,-16
 203ce88:	1884703a 	and	r2,r3,r2
 203ce8c:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to GMII to copper mode\n");
 203ce90:	01008174 	movhi	r4,517
 203ce94:	21045304 	addi	r4,r4,4428
 203ce98:	2006cb40 	call	2006cb4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xf);
 203ce9c:	e0bfff17 	ldw	r2,-4(fp)
 203cea0:	1080bb04 	addi	r2,r2,748
 203cea4:	e0fffe0b 	ldhu	r3,-8(fp)
 203cea8:	18c003d4 	ori	r3,r3,15
 203ceac:	18ffffcc 	andi	r3,r3,65535
 203ceb0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 203ceb4:	01008174 	movhi	r4,517
 203ceb8:	21045f04 	addi	r4,r4,4476
 203cebc:	2006cb40 	call	2006cb4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 203cec0:	e0bfff17 	ldw	r2,-4(fp)
 203cec4:	1080b404 	addi	r2,r2,720
 203cec8:	10800037 	ldwio	r2,0(r2)
 203cecc:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 203ced0:	e0fffe0b 	ldhu	r3,-8(fp)
 203ced4:	00bfdf44 	movi	r2,-131
 203ced8:	1884703a 	and	r2,r3,r2
 203cedc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 203cee0:	e0bfff17 	ldw	r2,-4(fp)
 203cee4:	1080b404 	addi	r2,r2,720
 203cee8:	e0fffe0b 	ldhu	r3,-8(fp)
 203ceec:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 203cef0:	01008174 	movhi	r4,517
 203cef4:	21044e04 	addi	r4,r4,4408
 203cef8:	2006cb40 	call	2006cb4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 203cefc:	e0bfff17 	ldw	r2,-4(fp)
 203cf00:	1080a004 	addi	r2,r2,640
 203cf04:	10800037 	ldwio	r2,0(r2)
 203cf08:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 203cf0c:	e0bfff17 	ldw	r2,-4(fp)
 203cf10:	1080a004 	addi	r2,r2,640
 203cf14:	e13ffe0b 	ldhu	r4,-8(fp)
 203cf18:	00e00004 	movi	r3,-32768
 203cf1c:	20c6b03a 	or	r3,r4,r3
 203cf20:	18ffffcc 	andi	r3,r3,65535
 203cf24:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 203cf28:	00800044 	movi	r2,1
}
 203cf2c:	e037883a 	mov	sp,fp
 203cf30:	dfc00117 	ldw	ra,4(sp)
 203cf34:	df000017 	ldw	fp,0(sp)
 203cf38:	dec00204 	addi	sp,sp,8
 203cf3c:	f800283a 	ret

0203cf40 <marvell_cfg_sgmii>:

/* @Function Description: Change operating mode of Marvell PHY to SGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_sgmii(np_tse_mac *pmac) {
 203cf40:	defffc04 	addi	sp,sp,-16
 203cf44:	dfc00315 	stw	ra,12(sp)
 203cf48:	df000215 	stw	fp,8(sp)
 203cf4c:	df000204 	addi	fp,sp,8
 203cf50:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 203cf54:	e0bfff17 	ldw	r2,-4(fp)
 203cf58:	1080bb04 	addi	r2,r2,748
 203cf5c:	10800037 	ldwio	r2,0(r2)
 203cf60:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 203cf64:	e0fffe0b 	ldhu	r3,-8(fp)
 203cf68:	00bffc04 	movi	r2,-16
 203cf6c:	1884703a 	and	r2,r3,r2
 203cf70:	e0bffe0d 	sth	r2,-8(fp)

    tse_dprintf(5, "MARVELL : Mode changed to SGMII without clock with SGMII Auto-Neg to copper mode\n");
 203cf74:	01008174 	movhi	r4,517
 203cf78:	21046904 	addi	r4,r4,4516
 203cf7c:	2006cb40 	call	2006cb4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0x4);
 203cf80:	e0bfff17 	ldw	r2,-4(fp)
 203cf84:	1080bb04 	addi	r2,r2,748
 203cf88:	e0fffe0b 	ldhu	r3,-8(fp)
 203cf8c:	18c00114 	ori	r3,r3,4
 203cf90:	18ffffcc 	andi	r3,r3,65535
 203cf94:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Disable RGMII Timing Control\n");
 203cf98:	01008174 	movhi	r4,517
 203cf9c:	21045f04 	addi	r4,r4,4476
 203cfa0:	2006cb40 	call	2006cb4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0); 
 203cfa4:	e0bfff17 	ldw	r2,-4(fp)
 203cfa8:	1080b404 	addi	r2,r2,720
 203cfac:	10800037 	ldwio	r2,0(r2)
 203cfb0:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 203cfb4:	e0fffe0b 	ldhu	r3,-8(fp)
 203cfb8:	00bfdf44 	movi	r2,-131
 203cfbc:	1884703a 	and	r2,r3,r2
 203cfc0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);
 203cfc4:	e0bfff17 	ldw	r2,-4(fp)
 203cfc8:	1080b404 	addi	r2,r2,720
 203cfcc:	e0fffe0b 	ldhu	r3,-8(fp)
 203cfd0:	10c00035 	stwio	r3,0(r2)

    tse_dprintf(5, "MARVELL : PHY reset\n");
 203cfd4:	01008174 	movhi	r4,517
 203cfd8:	21044e04 	addi	r4,r4,4408
 203cfdc:	2006cb40 	call	2006cb4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 203cfe0:	e0bfff17 	ldw	r2,-4(fp)
 203cfe4:	1080a004 	addi	r2,r2,640
 203cfe8:	10800037 	ldwio	r2,0(r2)
 203cfec:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 203cff0:	e0bfff17 	ldw	r2,-4(fp)
 203cff4:	1080a004 	addi	r2,r2,640
 203cff8:	e13ffe0b 	ldhu	r4,-8(fp)
 203cffc:	00e00004 	movi	r3,-32768
 203d000:	20c6b03a 	or	r3,r4,r3
 203d004:	18ffffcc 	andi	r3,r3,65535
 203d008:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 203d00c:	00800044 	movi	r2,1
}
 203d010:	e037883a 	mov	sp,fp
 203d014:	dfc00117 	ldw	ra,4(sp)
 203d018:	df000017 	ldw	fp,0(sp)
 203d01c:	dec00204 	addi	sp,sp,8
 203d020:	f800283a 	ret

0203d024 <marvell_cfg_rgmii>:

/* @Function Description: Change operating mode of Marvell PHY to RGMII
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_32 marvell_cfg_rgmii(np_tse_mac *pmac) {
 203d024:	defffc04 	addi	sp,sp,-16
 203d028:	dfc00315 	stw	ra,12(sp)
 203d02c:	df000215 	stw	fp,8(sp)
 203d030:	df000204 	addi	fp,sp,8
 203d034:	e13fff15 	stw	r4,-4(fp)
    
	alt_u16 dat = IORD(&pmac->mdio1.reg1b, 0);
 203d038:	e0bfff17 	ldw	r2,-4(fp)
 203d03c:	1080bb04 	addi	r2,r2,748
 203d040:	10800037 	ldwio	r2,0(r2)
 203d044:	e0bffe0d 	sth	r2,-8(fp)
    dat &= 0xfff0;
 203d048:	e0fffe0b 	ldhu	r3,-8(fp)
 203d04c:	00bffc04 	movi	r2,-16
 203d050:	1884703a 	and	r2,r3,r2
 203d054:	e0bffe0d 	sth	r2,-8(fp)
    
    tse_dprintf(5, "MARVELL : Mode changed to RGMII/Modified MII to Copper mode\n");
 203d058:	01008174 	movhi	r4,517
 203d05c:	21047e04 	addi	r4,r4,4600
 203d060:	2006cb40 	call	2006cb4 <puts>
    IOWR(&pmac->mdio1.reg1b, 0, dat | 0xb);
 203d064:	e0bfff17 	ldw	r2,-4(fp)
 203d068:	1080bb04 	addi	r2,r2,748
 203d06c:	e0fffe0b 	ldhu	r3,-8(fp)
 203d070:	18c002d4 	ori	r3,r3,11
 203d074:	18ffffcc 	andi	r3,r3,65535
 203d078:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : Enable RGMII Timing Control\n");
 203d07c:	01008174 	movhi	r4,517
 203d080:	21048d04 	addi	r4,r4,4660
 203d084:	2006cb40 	call	2006cb4 <puts>
    dat = IORD(&pmac->mdio1.reg14, 0);
 203d088:	e0bfff17 	ldw	r2,-4(fp)
 203d08c:	1080b404 	addi	r2,r2,720
 203d090:	10800037 	ldwio	r2,0(r2)
 203d094:	e0bffe0d 	sth	r2,-8(fp)
    dat &= ~0x82;
 203d098:	e0fffe0b 	ldhu	r3,-8(fp)
 203d09c:	00bfdf44 	movi	r2,-131
 203d0a0:	1884703a 	and	r2,r3,r2
 203d0a4:	e0bffe0d 	sth	r2,-8(fp)
    dat |= 0x82;
 203d0a8:	e0bffe0b 	ldhu	r2,-8(fp)
 203d0ac:	10802094 	ori	r2,r2,130
 203d0b0:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.reg14, 0, dat);    
 203d0b4:	e0bfff17 	ldw	r2,-4(fp)
 203d0b8:	1080b404 	addi	r2,r2,720
 203d0bc:	e0fffe0b 	ldhu	r3,-8(fp)
 203d0c0:	10c00035 	stwio	r3,0(r2)
    
    tse_dprintf(5, "MARVELL : PHY reset\n");
 203d0c4:	01008174 	movhi	r4,517
 203d0c8:	21044e04 	addi	r4,r4,4408
 203d0cc:	2006cb40 	call	2006cb4 <puts>
    dat = IORD(&pmac->mdio1.CONTROL, 0); 
 203d0d0:	e0bfff17 	ldw	r2,-4(fp)
 203d0d4:	1080a004 	addi	r2,r2,640
 203d0d8:	10800037 	ldwio	r2,0(r2)
 203d0dc:	e0bffe0d 	sth	r2,-8(fp)
    IOWR(&pmac->mdio1.CONTROL, 0, dat | PCS_CTL_sw_reset);
 203d0e0:	e0bfff17 	ldw	r2,-4(fp)
 203d0e4:	1080a004 	addi	r2,r2,640
 203d0e8:	e13ffe0b 	ldhu	r4,-8(fp)
 203d0ec:	00e00004 	movi	r3,-32768
 203d0f0:	20c6b03a 	or	r3,r4,r3
 203d0f4:	18ffffcc 	andi	r3,r3,65535
 203d0f8:	10c00035 	stwio	r3,0(r2)
    
    return 1;
 203d0fc:	00800044 	movi	r2,1
    
}
 203d100:	e037883a 	mov	sp,fp
 203d104:	dfc00117 	ldw	ra,4(sp)
 203d108:	df000017 	ldw	fp,0(sp)
 203d10c:	dec00204 	addi	sp,sp,8
 203d110:	f800283a 	ret

0203d114 <DP83848C_link_status_read>:

/* @Function Description: Read link status from PHY specific status register of DP83848C
 * @API Type:   Internal
 * @param pmac  Pointer to the first TSE MAC Control Interface Base address within MAC group
 */
alt_u32 DP83848C_link_status_read(np_tse_mac *pmac) {
 203d114:	defffc04 	addi	sp,sp,-16
 203d118:	df000315 	stw	fp,12(sp)
 203d11c:	df000304 	addi	fp,sp,12
 203d120:	e13fff15 	stw	r4,-4(fp)
	alt_u32 link_status = 0;
 203d124:	e03ffd15 	stw	zero,-12(fp)
	alt_u32 reg_status = IORD(&pmac->mdio1.reg10, 0);
 203d128:	e0bfff17 	ldw	r2,-4(fp)
 203d12c:	1080b004 	addi	r2,r2,704
 203d130:	10800037 	ldwio	r2,0(r2)
 203d134:	e0bffe15 	stw	r2,-8(fp)
	
	/* If speed == 10 Mbps */
	if(reg_status & 0x2) {
 203d138:	e0bffe17 	ldw	r2,-8(fp)
 203d13c:	1080008c 	andi	r2,r2,2
 203d140:	10000426 	beq	r2,zero,203d154 <DP83848C_link_status_read+0x40>
		link_status |= 0x8;
 203d144:	e0bffd17 	ldw	r2,-12(fp)
 203d148:	10800214 	ori	r2,r2,8
 203d14c:	e0bffd15 	stw	r2,-12(fp)
 203d150:	00000306 	br	203d160 <DP83848C_link_status_read+0x4c>
	}
	/* Else speed = 100 Mbps */
	else {
		link_status |= 0x4;
 203d154:	e0bffd17 	ldw	r2,-12(fp)
 203d158:	10800114 	ori	r2,r2,4
 203d15c:	e0bffd15 	stw	r2,-12(fp)
	}
	
	/* If duplex == Full */
	if(reg_status & 0x4) {
 203d160:	e0bffe17 	ldw	r2,-8(fp)
 203d164:	1080010c 	andi	r2,r2,4
 203d168:	10000326 	beq	r2,zero,203d178 <DP83848C_link_status_read+0x64>
		link_status |= 0x1;
 203d16c:	e0bffd17 	ldw	r2,-12(fp)
 203d170:	10800054 	ori	r2,r2,1
 203d174:	e0bffd15 	stw	r2,-12(fp)
	}
	
	return link_status;
 203d178:	e0bffd17 	ldw	r2,-12(fp)
}
 203d17c:	e037883a 	mov	sp,fp
 203d180:	df000017 	ldw	fp,0(sp)
 203d184:	dec00104 	addi	sp,sp,4
 203d188:	f800283a 	ret

0203d18c <netmain_init>:
 * RETURNS: 
 */

void 
netmain_init(void)
{
 203d18c:	defffb04 	addi	sp,sp,-20
 203d190:	dfc00415 	stw	ra,16(sp)
 203d194:	df000315 	stw	fp,12(sp)
 203d198:	dc000215 	stw	r16,8(sp)
 203d19c:	df000204 	addi	fp,sp,8
   int   e = 0;
 203d1a0:	e03ffe15 	stw	zero,-8(fp)
   char *   msg;
#ifdef IP_V6
   ip6_addr host;
#endif

   printf("%s\n", name);
 203d1a4:	d0a05017 	ldw	r2,-32448(gp)
 203d1a8:	1009883a 	mov	r4,r2
 203d1ac:	2006cb40 	call	2006cb4 <puts>
   printf("Copyright 1996-2008 by InterNiche Technologies. All rights reserved. \n");
 203d1b0:	01008174 	movhi	r4,517
 203d1b4:	2104aa04 	addi	r4,r4,4776
 203d1b8:	2006cb40 	call	2006cb4 <puts>
#ifdef IN_MENUS
   install_version("allports3.1");
#endif
#ifndef SUPERLOOP
   /* call this to do pre-task setup including intialization of port_prep */
   msg = pre_task_setup();
 203d1bc:	2028f400 	call	2028f40 <pre_task_setup>
 203d1c0:	e0bfff15 	stw	r2,-4(fp)
   if (msg)
 203d1c4:	e0bfff17 	ldw	r2,-4(fp)
 203d1c8:	10000226 	beq	r2,zero,203d1d4 <netmain_init+0x48>
      panic(msg);
 203d1cc:	e13fff17 	ldw	r4,-4(fp)
 203d1d0:	2026bf80 	call	2026bf8 <panic>
      printf("global_log_create() failed\n");
   }
   glog_with_type(LOG_TYPE_INFO, "INICHE LOG initialized", 1);
#endif

   msg = ip_startup();
 203d1d4:	20247d00 	call	20247d0 <ip_startup>
 203d1d8:	e0bfff15 	stw	r2,-4(fp)
   if (msg)
 203d1dc:	e0bfff17 	ldw	r2,-4(fp)
 203d1e0:	10000726 	beq	r2,zero,203d200 <netmain_init+0x74>
   {
      printf("inet startup error: %s\n", msg);
 203d1e4:	01008174 	movhi	r4,517
 203d1e8:	2104bc04 	addi	r4,r4,4848
 203d1ec:	e17fff17 	ldw	r5,-4(fp)
 203d1f0:	2006a240 	call	2006a24 <printf>
      panic("IP");
 203d1f4:	01008174 	movhi	r4,517
 203d1f8:	2104c204 	addi	r4,r4,4872
 203d1fc:	2026bf80 	call	2026bf8 <panic>
   }

#if defined(MEMDEV_SIZE) && defined(VFS_FILES)
   init_memdev(); /* init the mem and null test devices */
 203d200:	20475680 	call	2047568 <init_memdev>
#endif

#ifdef IP_MULTICAST
#ifdef INCLUDE_TCP
   /* call the IP multicast test program */
   u_mctest_init();
 203d204:	2046e300 	call	2046e30 <u_mctest_init>

   /* clear debugging flags. Port can optionally turn them
    * back on in post_task_setup();
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    
 203d208:	00808174 	movhi	r2,517
 203d20c:	1090b204 	addi	r2,r2,17096
 203d210:	10000015 	stw	zero,0(r2)

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 203d214:	00809934 	movhi	r2,612
 203d218:	10b7ce04 	addi	r2,r2,-8392
 203d21c:	10800017 	ldw	r2,0(r2)
 203d220:	14000104 	addi	r16,r2,4
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 203d224:	00809934 	movhi	r2,612
 203d228:	10b7ce04 	addi	r2,r2,-8392
 203d22c:	10800017 	ldw	r2,0(r2)
    * NDEBUG = UPCTRACE | IPTRACE | TPTRACE ;  
    */
   NDEBUG = 0;    

   /* print IP address of the first interface - for user's benefit */
   printf("IP address of %s : %s\n" , ((NET)(netlist.q_head))->name,
 203d230:	10800a17 	ldw	r2,40(r2)
 203d234:	1009883a 	mov	r4,r2
 203d238:	2026a400 	call	2026a40 <print_ipad>
 203d23c:	01008174 	movhi	r4,517
 203d240:	2104c304 	addi	r4,r4,4876
 203d244:	800b883a 	mov	r5,r16
 203d248:	100d883a 	mov	r6,r2
 203d24c:	2006a240 	call	2006a24 <printf>
      print_ipad(((NET)(netlist.q_head))->n_ipaddr));
 
#ifndef SUPERLOOP
   /* call this per-target routine after basic tasks & net are up */
   msg = post_task_setup();
 203d250:	2028fb40 	call	2028fb4 <post_task_setup>
 203d254:	e0bfff15 	stw	r2,-4(fp)
   if (msg)
 203d258:	e0bfff17 	ldw	r2,-4(fp)
 203d25c:	10000226 	beq	r2,zero,203d268 <netmain_init+0xdc>
      panic(msg);
 203d260:	e13fff17 	ldw	r4,-4(fp)
 203d264:	2026bf80 	call	2026bf8 <panic>
      panic("prep_modules");
   }
#endif
   USE_ARG(e);    /* Avoid compiler warnings */

} /* end of netmain_init() */
 203d268:	e037883a 	mov	sp,fp
 203d26c:	dfc00217 	ldw	ra,8(sp)
 203d270:	df000117 	ldw	fp,4(sp)
 203d274:	dc000017 	ldw	r16,0(sp)
 203d278:	dec00304 	addi	sp,sp,12
 203d27c:	f800283a 	ret

0203d280 <icmp_port_du>:
 * RETURNS: 
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
 203d280:	defffb04 	addi	sp,sp,-20
 203d284:	dfc00415 	stw	ra,16(sp)
 203d288:	df000315 	stw	fp,12(sp)
 203d28c:	dc000215 	stw	r16,8(sp)
 203d290:	df000204 	addi	fp,sp,8
 203d294:	e13ffe15 	stw	r4,-8(fp)
 203d298:	e17fff15 	stw	r5,-4(fp)
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 203d29c:	e0bfff17 	ldw	r2,-4(fp)
 203d2a0:	10800003 	ldbu	r2,0(r2)
 203d2a4:	10803fcc 	andi	r2,r2,255
 203d2a8:	1080201c 	xori	r2,r2,128
 203d2ac:	10bfe004 	addi	r2,r2,-128
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 203d2b0:	00c08174 	movhi	r3,517
 203d2b4:	18cfc604 	addi	r3,r3,16152
 203d2b8:	1085883a 	add	r2,r2,r2
 203d2bc:	1085883a 	add	r2,r2,r2
 203d2c0:	1885883a 	add	r2,r3,r2
 203d2c4:	14000017 	ldw	r16,0(r2)
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
 203d2c8:	e0bffe17 	ldw	r2,-8(fp)
 */

void
icmp_port_du(PACKET p, struct destun * pdp)
{
   dprintf("got ICMP %s UNREACHABLE from %s\n", 
 203d2cc:	10800717 	ldw	r2,28(r2)
 203d2d0:	1009883a 	mov	r4,r2
 203d2d4:	2026a400 	call	2026a40 <print_ipad>
 203d2d8:	01008174 	movhi	r4,517
 203d2dc:	2104d304 	addi	r4,r4,4940
 203d2e0:	800b883a 	mov	r5,r16
 203d2e4:	100d883a 	mov	r6,r2
 203d2e8:	2006a240 	call	2006a24 <printf>
      icmpdu_types[(int)(pdp->dtype)], print_ipad(p->fhost) );
   dprintf(prompt);
 203d2ec:	d0a05117 	ldw	r2,-32444(gp)
 203d2f0:	1009883a 	mov	r4,r2
 203d2f4:	2006a240 	call	2006a24 <printf>
}
 203d2f8:	e037883a 	mov	sp,fp
 203d2fc:	dfc00217 	ldw	ra,8(sp)
 203d300:	df000117 	ldw	fp,4(sp)
 203d304:	dc000017 	ldw	r16,0(sp)
 203d308:	dec00304 	addi	sp,sp,12
 203d30c:	f800283a 	ret

0203d310 <station_state>:
 * RETURNS: 
 */

int
station_state(void * pio)
{
 203d310:	defff904 	addi	sp,sp,-28
 203d314:	dfc00615 	stw	ra,24(sp)
 203d318:	df000515 	stw	fp,20(sp)
 203d31c:	dc000415 	stw	r16,16(sp)
 203d320:	df000404 	addi	fp,sp,16
 203d324:	e13fff15 	stw	r4,-4(fp)
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 203d328:	e03ffd15 	stw	zero,-12(fp)
 203d32c:	00809934 	movhi	r2,612
 203d330:	10b7ce04 	addi	r2,r2,-8392
 203d334:	10800017 	ldw	r2,0(r2)
 203d338:	e0bffe15 	stw	r2,-8(fp)
 203d33c:	00002506 	br	203d3d4 <station_state+0xc4>
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
 203d340:	e0bffe17 	ldw	r2,-8(fp)
 203d344:	14000104 	addi	r16,r2,4
 203d348:	e0bffe17 	ldw	r2,-8(fp)
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
   {
      ns_printf(pio, "iface %d-%s IP addr:%s  ", 
 203d34c:	10800a17 	ldw	r2,40(r2)
 203d350:	1009883a 	mov	r4,r2
 203d354:	2026a400 	call	2026a40 <print_ipad>
 203d358:	d8800015 	stw	r2,0(sp)
 203d35c:	e13fff17 	ldw	r4,-4(fp)
 203d360:	01408174 	movhi	r5,517
 203d364:	2944dc04 	addi	r5,r5,4976
 203d368:	e1bffd17 	ldw	r6,-12(fp)
 203d36c:	800f883a 	mov	r7,r16
 203d370:	2026e100 	call	2026e10 <ns_printf>
       i, ifp->name, print_ipad(ifp->n_ipaddr) );
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
 203d374:	e0bffe17 	ldw	r2,-8(fp)
 203d378:	10800c17 	ldw	r2,48(r2)
 203d37c:	1009883a 	mov	r4,r2
 203d380:	2026a400 	call	2026a40 <print_ipad>
 203d384:	e13fff17 	ldw	r4,-4(fp)
 203d388:	01408174 	movhi	r5,517
 203d38c:	2944e304 	addi	r5,r5,5004
 203d390:	100d883a 	mov	r6,r2
 203d394:	2026e100 	call	2026e10 <ns_printf>
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
 203d398:	e0bffe17 	ldw	r2,-8(fp)
 203d39c:	10800d17 	ldw	r2,52(r2)
 203d3a0:	1009883a 	mov	r4,r2
 203d3a4:	2026a400 	call	2026a40 <print_ipad>
 203d3a8:	e13fff17 	ldw	r4,-4(fp)
 203d3ac:	01408174 	movhi	r5,517
 203d3b0:	2944e604 	addi	r5,r5,5016
 203d3b4:	100d883a 	mov	r6,r2
 203d3b8:	2026e100 	call	2026e10 <ns_printf>
   int i;
   
#ifndef NO_INET_STACK
   NET ifp;

   for (i = 0, ifp = (NET)netlist.q_head; ifp; ifp = ifp->n_next, i++)
 203d3bc:	e0bffe17 	ldw	r2,-8(fp)
 203d3c0:	10800017 	ldw	r2,0(r2)
 203d3c4:	e0bffe15 	stw	r2,-8(fp)
 203d3c8:	e0bffd17 	ldw	r2,-12(fp)
 203d3cc:	10800044 	addi	r2,r2,1
 203d3d0:	e0bffd15 	stw	r2,-12(fp)
 203d3d4:	e0bffe17 	ldw	r2,-8(fp)
 203d3d8:	103fd91e 	bne	r2,zero,203d340 <station_state+0x30>
      ns_printf(pio, "subnet:%s  ", print_ipad(ifp->snmask) );
      ns_printf(pio, "gateway:%s\n", print_ipad(ifp->n_defgw) );
   }
#endif   /* NO_INET_STACK */

   ns_printf(pio, "current tick count %lu\n", cticks);
 203d3dc:	00808174 	movhi	r2,517
 203d3e0:	1090c904 	addi	r2,r2,17188
 203d3e4:	10800017 	ldw	r2,0(r2)
 203d3e8:	e13fff17 	ldw	r4,-4(fp)
 203d3ec:	01408174 	movhi	r5,517
 203d3f0:	2944e904 	addi	r5,r5,5028
 203d3f4:	100d883a 	mov	r6,r2
 203d3f8:	2026e100 	call	2026e10 <ns_printf>

   ns_printf(pio, "common delay parameter:  %lu ticks (%lu ms).\n", pingdelay, (pingdelay * TIMEFOR1TICK));
 203d3fc:	d4205217 	ldw	r16,-32440(gp)
 203d400:	d0a05217 	ldw	r2,-32440(gp)
 203d404:	1009883a 	mov	r4,r2
 203d408:	20145600 	call	2014560 <__floatunsidf>
 203d40c:	100b883a 	mov	r5,r2
 203d410:	180d883a 	mov	r6,r3
 203d414:	2809883a 	mov	r4,r5
 203d418:	300b883a 	mov	r5,r6
 203d41c:	000d883a 	mov	r6,zero
 203d420:	01d00934 	movhi	r7,16420
 203d424:	2013c880 	call	2013c88 <__muldf3>
 203d428:	1009883a 	mov	r4,r2
 203d42c:	180b883a 	mov	r5,r3
 203d430:	2005883a 	mov	r2,r4
 203d434:	2807883a 	mov	r3,r5
 203d438:	d8c00015 	stw	r3,0(sp)
 203d43c:	100f883a 	mov	r7,r2
 203d440:	e13fff17 	ldw	r4,-4(fp)
 203d444:	01408174 	movhi	r5,517
 203d448:	2944ef04 	addi	r5,r5,5052
 203d44c:	800d883a 	mov	r6,r16
 203d450:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio, "common host parameter: %s\n", print_ipad(activehost));
 203d454:	d0a0b017 	ldw	r2,-32064(gp)
 203d458:	1009883a 	mov	r4,r2
 203d45c:	2026a400 	call	2026a40 <print_ipad>
 203d460:	e13fff17 	ldw	r4,-4(fp)
 203d464:	01408174 	movhi	r5,517
 203d468:	2944fb04 	addi	r5,r5,5100
 203d46c:	100d883a 	mov	r6,r2
 203d470:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio, "common length parameter: %d\n", deflength);
 203d474:	d0a05317 	ldw	r2,-32436(gp)
 203d478:	e13fff17 	ldw	r4,-4(fp)
 203d47c:	01408174 	movhi	r5,517
 203d480:	29450204 	addi	r5,r5,5128
 203d484:	100d883a 	mov	r6,r2
 203d488:	2026e100 	call	2026e10 <ns_printf>
#ifdef USE_PPP
   ns_printf(pio, "current dial-in user name is %s\n", pppcfg.username);
   ns_printf(pio, "current dial-in password is %s\n", pppcfg.password);
#endif   /* USE_PPP */

   task_stats(pio);
 203d48c:	e13fff17 	ldw	r4,-4(fp)
 203d490:	203db7c0 	call	203db7c <task_stats>

   return 0;
 203d494:	0005883a 	mov	r2,zero
}
 203d498:	e037883a 	mov	sp,fp
 203d49c:	dfc00217 	ldw	ra,8(sp)
 203d4a0:	df000117 	ldw	fp,4(sp)
 203d4a4:	dc000017 	ldw	r16,0(sp)
 203d4a8:	dec00304 	addi	sp,sp,12
 203d4ac:	f800283a 	ret

0203d4b0 <sysuptime>:
 * RETURNS: 
 */

unsigned long
sysuptime()
{
 203d4b0:	defffe04 	addi	sp,sp,-8
 203d4b4:	dfc00115 	stw	ra,4(sp)
 203d4b8:	df000015 	stw	fp,0(sp)
 203d4bc:	d839883a 	mov	fp,sp
   return ((cticks/TPS)*100);    /* 100ths of a sec since boot time */
 203d4c0:	00808174 	movhi	r2,517
 203d4c4:	1090c904 	addi	r2,r2,17188
 203d4c8:	10800017 	ldw	r2,0(r2)
 203d4cc:	1009883a 	mov	r4,r2
 203d4d0:	20145600 	call	2014560 <__floatunsidf>
 203d4d4:	100b883a 	mov	r5,r2
 203d4d8:	180d883a 	mov	r6,r3
 203d4dc:	2809883a 	mov	r4,r5
 203d4e0:	300b883a 	mov	r5,r6
 203d4e4:	000d883a 	mov	r6,zero
 203d4e8:	01d01674 	movhi	r7,16473
 203d4ec:	2013f6c0 	call	2013f6c <__divdf3>
 203d4f0:	1009883a 	mov	r4,r2
 203d4f4:	180b883a 	mov	r5,r3
 203d4f8:	2005883a 	mov	r2,r4
 203d4fc:	2807883a 	mov	r3,r5
 203d500:	1009883a 	mov	r4,r2
 203d504:	180b883a 	mov	r5,r3
 203d508:	000d883a 	mov	r6,zero
 203d50c:	01d01674 	movhi	r7,16473
 203d510:	2013c880 	call	2013c88 <__muldf3>
 203d514:	1009883a 	mov	r4,r2
 203d518:	180b883a 	mov	r5,r3
 203d51c:	2005883a 	mov	r2,r4
 203d520:	2807883a 	mov	r3,r5
 203d524:	1009883a 	mov	r4,r2
 203d528:	180b883a 	mov	r5,r3
 203d52c:	2012ba40 	call	2012ba4 <__fixunsdfsi>
}
 203d530:	e037883a 	mov	sp,fp
 203d534:	dfc00117 	ldw	ra,4(sp)
 203d538:	df000017 	ldw	fp,0(sp)
 203d53c:	dec00204 	addi	sp,sp,8
 203d540:	f800283a 	ret

0203d544 <packet_check>:

static int inside_pktdemux = 0; 

void
packet_check(void)
{
 203d544:	defffe04 	addi	sp,sp,-8
 203d548:	dfc00115 	stw	ra,4(sp)
 203d54c:	df000015 	stw	fp,0(sp)
 203d550:	d839883a 	mov	fp,sp
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
 203d554:	d0a0b117 	ldw	r2,-32060(gp)
 203d558:	1000081e 	bne	r2,zero,203d57c <packet_check+0x38>
      return;           /* do not re-enter pktdemux(), packet will wait... */
   inside_pktdemux++;   /* set re-entrany flag */
 203d55c:	d0a0b117 	ldw	r2,-32060(gp)
 203d560:	10800044 	addi	r2,r2,1
 203d564:	d0a0b115 	stw	r2,-32060(gp)
   pktdemux();          /* process low level packet input */
 203d568:	20241dc0 	call	20241dc <pktdemux>
   inside_pktdemux--;   /* clear re-entrany flag */
 203d56c:	d0a0b117 	ldw	r2,-32060(gp)
 203d570:	10bfffc4 	addi	r2,r2,-1
 203d574:	d0a0b115 	stw	r2,-32060(gp)
 203d578:	00000106 	br	203d580 <packet_check+0x3c>

void
packet_check(void)
{
   if(inside_pktdemux != 0)   /* check re-entrancy flag */
      return;           /* do not re-enter pktdemux(), packet will wait... */
 203d57c:	0001883a 	nop
   inside_pktdemux++;   /* set re-entrany flag */
   pktdemux();          /* process low level packet input */
   inside_pktdemux--;   /* clear re-entrany flag */
}
 203d580:	e037883a 	mov	sp,fp
 203d584:	dfc00117 	ldw	ra,4(sp)
 203d588:	df000017 	ldw	fp,0(sp)
 203d58c:	dec00204 	addi	sp,sp,8
 203d590:	f800283a 	ret

0203d594 <mcastlist>:
 * RETURNS: 
 */

int
mcastlist(struct in_multi * multi_ptr)
{
 203d594:	defffe04 	addi	sp,sp,-8
 203d598:	df000115 	stw	fp,4(sp)
 203d59c:	df000104 	addi	fp,sp,4
 203d5a0:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(multi_ptr);

   return 0;
 203d5a4:	0005883a 	mov	r2,zero
}
 203d5a8:	e037883a 	mov	sp,fp
 203d5ac:	df000017 	ldw	fp,0(sp)
 203d5b0:	dec00104 	addi	sp,sp,4
 203d5b4:	f800283a 	ret

0203d5b8 <prep_modules>:
#ifdef USE_MODEM
extern   int   prep_modem(void);
#endif   /* USE_MODEM */

int prep_modules(void)
{
 203d5b8:	defffd04 	addi	sp,sp,-12
 203d5bc:	dfc00215 	stw	ra,8(sp)
 203d5c0:	df000115 	stw	fp,4(sp)
 203d5c4:	df000104 	addi	fp,sp,4
#ifdef IP_V6
   ip6_addr host;
   int i;
#endif

int e = 0;
 203d5c8:	e03fff15 	stw	zero,-4(fp)
      panic("prep_modules");
   }
#endif   /* SMTP_ALERTS */

#ifdef VFS_FILES
   e = prep_vfs();
 203d5cc:	204a68c0 	call	204a68c <prep_vfs>
 203d5d0:	e0bfff15 	stw	r2,-4(fp)
   if (e != 0)
 203d5d4:	e0bfff17 	ldw	r2,-4(fp)
 203d5d8:	10000626 	beq	r2,zero,203d5f4 <prep_modules+0x3c>
   {
      dprintf("VFS Module prep failed\n");
 203d5dc:	01008174 	movhi	r4,517
 203d5e0:	21050a04 	addi	r4,r4,5160
 203d5e4:	2006cb40 	call	2006cb4 <puts>
      panic("prep_modules");
 203d5e8:	01008174 	movhi	r4,517
 203d5ec:	21051004 	addi	r4,r4,5184
 203d5f0:	2026bf80 	call	2026bf8 <panic>
   {
      dprintf("sslapp_init() failed\n");
      panic("prep_modules");
   }
#endif
   return 0;
 203d5f4:	0005883a 	mov	r2,zero
}
 203d5f8:	e037883a 	mov	sp,fp
 203d5fc:	dfc00117 	ldw	ra,4(sp)
 203d600:	df000017 	ldw	fp,0(sp)
 203d604:	dec00204 	addi	sp,sp,8
 203d608:	f800283a 	ret

0203d60c <inet_timer>:
 * RETURNS: 
 */

void
inet_timer(void)
{
 203d60c:	defffc04 	addi	sp,sp,-16
 203d610:	dfc00315 	stw	ra,12(sp)
 203d614:	df000215 	stw	fp,8(sp)
 203d618:	dc400115 	stw	r17,4(sp)
 203d61c:	dc000015 	stw	r16,0(sp)
 203d620:	d839883a 	mov	fp,sp
#ifdef IP_FRAGMENTS
   /* run thru' the IP reassembly queue (once every second) */
   if (ire_cticks < cticks)
 203d624:	00808174 	movhi	r2,517
 203d628:	1090e904 	addi	r2,r2,17316
 203d62c:	10c00017 	ldw	r3,0(r2)
 203d630:	00808174 	movhi	r2,517
 203d634:	1090c904 	addi	r2,r2,17188
 203d638:	10800017 	ldw	r2,0(r2)
 203d63c:	1880012e 	bgeu	r3,r2,203d644 <inet_timer+0x38>
      ip_reasm_process_timer_tick ();
 203d640:	204290c0 	call	204290c <ip_reasm_process_timer_tick>
#endif

#ifdef INCLUDE_TCP
   tcp_tick();          /* run TCP timers */
 203d644:	202aa5c0 	call	202aa5c <tcp_tick>
#endif

#ifdef INICHE_TIMERS    /* interval timers? */
   check_interval_timers();
 203d648:	203d76c0 	call	203d76c <check_interval_timers>
#endif

#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   /* Call igmp timeout routine */
   if (igmp_cticks < cticks)  /* Call igmp timeout routine 5 times per sec */
 203d64c:	00808174 	movhi	r2,517
 203d650:	1090b604 	addi	r2,r2,17112
 203d654:	10c00017 	ldw	r3,0(r2)
 203d658:	00808174 	movhi	r2,517
 203d65c:	1090c904 	addi	r2,r2,17188
 203d660:	10800017 	ldw	r2,0(r2)
 203d664:	1880012e 	bgeu	r3,r2,203d66c <inet_timer+0x60>
      igmp_fasttimo();
 203d668:	2024e000 	call	2024e00 <igmp_fasttimo>
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 203d66c:	d0e0b217 	ldw	r3,-32056(gp)
 203d670:	00808174 	movhi	r2,517
 203d674:	1090c904 	addi	r2,r2,17188
 203d678:	10800017 	ldw	r2,0(r2)
 203d67c:	18801c36 	bltu	r3,r2,203d6f0 <inet_timer+0xe4>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
 203d680:	d0a0b217 	ldw	r2,-32056(gp)
 203d684:	1009883a 	mov	r4,r2
 203d688:	20145600 	call	2014560 <__floatunsidf>
 203d68c:	1021883a 	mov	r16,r2
 203d690:	1823883a 	mov	r17,r3
 203d694:	00808174 	movhi	r2,517
 203d698:	1090c904 	addi	r2,r2,17188
 203d69c:	10800017 	ldw	r2,0(r2)
 203d6a0:	1009883a 	mov	r4,r2
 203d6a4:	20145600 	call	2014560 <__floatunsidf>
 203d6a8:	100b883a 	mov	r5,r2
 203d6ac:	180d883a 	mov	r6,r3
 203d6b0:	2809883a 	mov	r4,r5
 203d6b4:	300b883a 	mov	r5,r6
 203d6b8:	000d883a 	mov	r6,zero
 203d6bc:	01d023f4 	movhi	r7,16527
 203d6c0:	39d00004 	addi	r7,r7,16384
 203d6c4:	2013bd40 	call	2013bd4 <__adddf3>
 203d6c8:	1009883a 	mov	r4,r2
 203d6cc:	180b883a 	mov	r5,r3
 203d6d0:	2005883a 	mov	r2,r4
 203d6d4:	2807883a 	mov	r3,r5
#endif



   /* Some timer routines only need calling once a second: */
   if ((nextppp < cticks) ||  /* next call to PPP is due */
 203d6d8:	8009883a 	mov	r4,r16
 203d6dc:	880b883a 	mov	r5,r17
 203d6e0:	100d883a 	mov	r6,r2
 203d6e4:	180f883a 	mov	r7,r3
 203d6e8:	20141d80 	call	20141d8 <__gtdf2>
 203d6ec:	0080180e 	bge	zero,r2,203d750 <inet_timer+0x144>
       (nextppp > (cticks+(10*TPS))) )  /* for when cticks wraps */
   {
      nextppp = cticks + TPS;
 203d6f0:	00808174 	movhi	r2,517
 203d6f4:	1090c904 	addi	r2,r2,17188
 203d6f8:	10800017 	ldw	r2,0(r2)
 203d6fc:	1009883a 	mov	r4,r2
 203d700:	20145600 	call	2014560 <__floatunsidf>
 203d704:	100b883a 	mov	r5,r2
 203d708:	180d883a 	mov	r6,r3
 203d70c:	2809883a 	mov	r4,r5
 203d710:	300b883a 	mov	r5,r6
 203d714:	000d883a 	mov	r6,zero
 203d718:	01d01674 	movhi	r7,16473
 203d71c:	2013bd40 	call	2013bd4 <__adddf3>
 203d720:	1009883a 	mov	r4,r2
 203d724:	180b883a 	mov	r5,r3
 203d728:	2005883a 	mov	r2,r4
 203d72c:	2807883a 	mov	r3,r5
 203d730:	1009883a 	mov	r4,r2
 203d734:	180b883a 	mov	r5,r3
 203d738:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 203d73c:	d0a0b215 	stw	r2,-32056(gp)

      if (port_1s_callout != NULL)
 203d740:	d0a0b317 	ldw	r2,-32052(gp)
 203d744:	10000226 	beq	r2,zero,203d750 <inet_timer+0x144>
         (*port_1s_callout)();
 203d748:	d0a0b317 	ldw	r2,-32052(gp)
 203d74c:	103ee83a 	callr	r2
#endif
#ifdef IPSEC
      IPSecTimer();
#endif
   }
}
 203d750:	e037883a 	mov	sp,fp
 203d754:	dfc00317 	ldw	ra,12(sp)
 203d758:	df000217 	ldw	fp,8(sp)
 203d75c:	dc400117 	ldw	r17,4(sp)
 203d760:	dc000017 	ldw	r16,0(sp)
 203d764:	dec00404 	addi	sp,sp,16
 203d768:	f800283a 	ret

0203d76c <check_interval_timers>:

static int numtimers = 0;     /* number of active timers */

static void
check_interval_timers(void)
{
 203d76c:	defffc04 	addi	sp,sp,-16
 203d770:	dfc00315 	stw	ra,12(sp)
 203d774:	df000215 	stw	fp,8(sp)
 203d778:	df000204 	addi	fp,sp,8
   int   i;
   int   found = 0;  /* number of valid timers found */
 203d77c:	e03fff15 	stw	zero,-4(fp)

   /* if no timers, just return */
   if (numtimers > 0)
 203d780:	d0a0b417 	ldw	r2,-32048(gp)
 203d784:	00805a0e 	bge	zero,r2,203d8f0 <check_interval_timers+0x184>
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 203d788:	e03ffe15 	stw	zero,-8(fp)
 203d78c:	00005306 	br	203d8dc <check_interval_timers+0x170>
      {
         if (intimers[i].callback)   /* is this timer active? */
 203d790:	00c09934 	movhi	r3,612
 203d794:	18f77504 	addi	r3,r3,-8748
 203d798:	e0bffe17 	ldw	r2,-8(fp)
 203d79c:	10800524 	muli	r2,r2,20
 203d7a0:	1885883a 	add	r2,r3,r2
 203d7a4:	10800017 	ldw	r2,0(r2)
 203d7a8:	10004926 	beq	r2,zero,203d8d0 <check_interval_timers+0x164>
	 {
            if ((intimers[i].tmo < cticks) && (!intimers[i].inuse))  /* timer ready fire? */
 203d7ac:	00c09934 	movhi	r3,612
 203d7b0:	18f77504 	addi	r3,r3,-8748
 203d7b4:	e0bffe17 	ldw	r2,-8(fp)
 203d7b8:	10800524 	muli	r2,r2,20
 203d7bc:	1885883a 	add	r2,r3,r2
 203d7c0:	10800304 	addi	r2,r2,12
 203d7c4:	10c00017 	ldw	r3,0(r2)
 203d7c8:	00808174 	movhi	r2,517
 203d7cc:	1090c904 	addi	r2,r2,17188
 203d7d0:	10800017 	ldw	r2,0(r2)
 203d7d4:	1880382e 	bgeu	r3,r2,203d8b8 <check_interval_timers+0x14c>
 203d7d8:	00c09934 	movhi	r3,612
 203d7dc:	18f77504 	addi	r3,r3,-8748
 203d7e0:	e0bffe17 	ldw	r2,-8(fp)
 203d7e4:	10800524 	muli	r2,r2,20
 203d7e8:	1885883a 	add	r2,r3,r2
 203d7ec:	10800404 	addi	r2,r2,16
 203d7f0:	10800017 	ldw	r2,0(r2)
 203d7f4:	1000301e 	bne	r2,zero,203d8b8 <check_interval_timers+0x14c>
            {
               intimers[i].tmo = intimers[i].interval + cticks;   /* set next tmo */
 203d7f8:	00c09934 	movhi	r3,612
 203d7fc:	18f77504 	addi	r3,r3,-8748
 203d800:	e0bffe17 	ldw	r2,-8(fp)
 203d804:	10800524 	muli	r2,r2,20
 203d808:	1885883a 	add	r2,r3,r2
 203d80c:	10800204 	addi	r2,r2,8
 203d810:	10c00017 	ldw	r3,0(r2)
 203d814:	00808174 	movhi	r2,517
 203d818:	1090c904 	addi	r2,r2,17188
 203d81c:	10800017 	ldw	r2,0(r2)
 203d820:	1887883a 	add	r3,r3,r2
 203d824:	01009934 	movhi	r4,612
 203d828:	21377504 	addi	r4,r4,-8748
 203d82c:	e0bffe17 	ldw	r2,-8(fp)
 203d830:	10800524 	muli	r2,r2,20
 203d834:	2085883a 	add	r2,r4,r2
 203d838:	10800304 	addi	r2,r2,12
 203d83c:	10c00015 	stw	r3,0(r2)
               intimers[i].inuse = TRUE;
 203d840:	00c09934 	movhi	r3,612
 203d844:	18f77504 	addi	r3,r3,-8748
 203d848:	e0bffe17 	ldw	r2,-8(fp)
 203d84c:	10800524 	muli	r2,r2,20
 203d850:	1885883a 	add	r2,r3,r2
 203d854:	10800404 	addi	r2,r2,16
 203d858:	00c00044 	movi	r3,1
 203d85c:	10c00015 	stw	r3,0(r2)
               intimers[i].callback(intimers[i].parm);      /* call user routine */
 203d860:	00c09934 	movhi	r3,612
 203d864:	18f77504 	addi	r3,r3,-8748
 203d868:	e0bffe17 	ldw	r2,-8(fp)
 203d86c:	10800524 	muli	r2,r2,20
 203d870:	1885883a 	add	r2,r3,r2
 203d874:	10c00017 	ldw	r3,0(r2)
 203d878:	01009934 	movhi	r4,612
 203d87c:	21377504 	addi	r4,r4,-8748
 203d880:	e0bffe17 	ldw	r2,-8(fp)
 203d884:	10800524 	muli	r2,r2,20
 203d888:	2085883a 	add	r2,r4,r2
 203d88c:	10800104 	addi	r2,r2,4
 203d890:	10800017 	ldw	r2,0(r2)
 203d894:	1009883a 	mov	r4,r2
 203d898:	183ee83a 	callr	r3
               intimers[i].inuse = FALSE;
 203d89c:	00c09934 	movhi	r3,612
 203d8a0:	18f77504 	addi	r3,r3,-8748
 203d8a4:	e0bffe17 	ldw	r2,-8(fp)
 203d8a8:	10800524 	muli	r2,r2,20
 203d8ac:	1885883a 	add	r2,r3,r2
 203d8b0:	10800404 	addi	r2,r2,16
 203d8b4:	10000015 	stw	zero,0(r2)
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
 203d8b8:	e0bfff17 	ldw	r2,-4(fp)
 203d8bc:	10800044 	addi	r2,r2,1
 203d8c0:	e0bfff15 	stw	r2,-4(fp)
 203d8c4:	d0a0b417 	ldw	r2,-32048(gp)
 203d8c8:	e0ffff17 	ldw	r3,-4(fp)
 203d8cc:	1880070e 	bge	r3,r2,203d8ec <check_interval_timers+0x180>

   /* if no timers, just return */
   if (numtimers > 0)
   {
      /* loop throught the timer list looking for active timers ready to fire */
      for (i = 0; i < NUM_INTIMERS; i++)
 203d8d0:	e0bffe17 	ldw	r2,-8(fp)
 203d8d4:	10800044 	addi	r2,r2,1
 203d8d8:	e0bffe15 	stw	r2,-8(fp)
 203d8dc:	e0bffe17 	ldw	r2,-8(fp)
 203d8e0:	10800150 	cmplti	r2,r2,5
 203d8e4:	103faa1e 	bne	r2,zero,203d790 <check_interval_timers+0x24>
 203d8e8:	00000106 	br	203d8f0 <check_interval_timers+0x184>
               intimers[i].callback(intimers[i].parm);      /* call user routine */
               intimers[i].inuse = FALSE;
            }
            /* If we've examined all the active timers, we're done */
            if (++found >= numtimers)
               break;
 203d8ec:	0001883a 	nop
         }
      }
   }
}
 203d8f0:	e037883a 	mov	sp,fp
 203d8f4:	dfc00117 	ldw	ra,4(sp)
 203d8f8:	df000017 	ldw	fp,0(sp)
 203d8fc:	dec00204 	addi	sp,sp,8
 203d900:	f800283a 	ret

0203d904 <in_timerset>:
 * RETURNS: timer ID if OK, else if table is full.
 */

long
in_timerset(void (*callback)(long), long msecs, long parm)
{
 203d904:	defffa04 	addi	sp,sp,-24
 203d908:	dfc00515 	stw	ra,20(sp)
 203d90c:	df000415 	stw	fp,16(sp)
 203d910:	df000404 	addi	fp,sp,16
 203d914:	e13ffd15 	stw	r4,-12(fp)
 203d918:	e17ffe15 	stw	r5,-8(fp)
 203d91c:	e1bfff15 	stw	r6,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 203d920:	e03ffc15 	stw	zero,-16(fp)
 203d924:	00005c06 	br	203da98 <in_timerset+0x194>
   {
      if(intimers[i].callback == NULL)
 203d928:	00c09934 	movhi	r3,612
 203d92c:	18f77504 	addi	r3,r3,-8748
 203d930:	e0bffc17 	ldw	r2,-16(fp)
 203d934:	10800524 	muli	r2,r2,20
 203d938:	1885883a 	add	r2,r3,r2
 203d93c:	10800017 	ldw	r2,0(r2)
 203d940:	1000521e 	bne	r2,zero,203da8c <in_timerset+0x188>
      {
         /* found empty table entry, set up new timer */
         intimers[i].callback = callback;
 203d944:	00c09934 	movhi	r3,612
 203d948:	18f77504 	addi	r3,r3,-8748
 203d94c:	e0bffc17 	ldw	r2,-16(fp)
 203d950:	10800524 	muli	r2,r2,20
 203d954:	1885883a 	add	r2,r3,r2
 203d958:	e0fffd17 	ldw	r3,-12(fp)
 203d95c:	10c00015 	stw	r3,0(r2)
         intimers[i].parm = parm;
 203d960:	00c09934 	movhi	r3,612
 203d964:	18f77504 	addi	r3,r3,-8748
 203d968:	e0bffc17 	ldw	r2,-16(fp)
 203d96c:	10800524 	muli	r2,r2,20
 203d970:	1885883a 	add	r2,r3,r2
 203d974:	10800104 	addi	r2,r2,4
 203d978:	e0ffff17 	ldw	r3,-4(fp)
 203d97c:	10c00015 	stw	r3,0(r2)
         /* set interval, in TPS (cticks) units */
         intimers[i].interval = (msecs * TPS)/1000;
 203d980:	e13ffe17 	ldw	r4,-8(fp)
 203d984:	20143580 	call	2014358 <__floatsidf>
 203d988:	100b883a 	mov	r5,r2
 203d98c:	180d883a 	mov	r6,r3
 203d990:	2809883a 	mov	r4,r5
 203d994:	300b883a 	mov	r5,r6
 203d998:	000d883a 	mov	r6,zero
 203d99c:	01d01674 	movhi	r7,16473
 203d9a0:	2013c880 	call	2013c88 <__muldf3>
 203d9a4:	1009883a 	mov	r4,r2
 203d9a8:	180b883a 	mov	r5,r3
 203d9ac:	2005883a 	mov	r2,r4
 203d9b0:	2807883a 	mov	r3,r5
 203d9b4:	1009883a 	mov	r4,r2
 203d9b8:	180b883a 	mov	r5,r3
 203d9bc:	000d883a 	mov	r6,zero
 203d9c0:	01d023f4 	movhi	r7,16527
 203d9c4:	39d00004 	addi	r7,r7,16384
 203d9c8:	2013f6c0 	call	2013f6c <__divdf3>
 203d9cc:	1009883a 	mov	r4,r2
 203d9d0:	180b883a 	mov	r5,r3
 203d9d4:	2005883a 	mov	r2,r4
 203d9d8:	2807883a 	mov	r3,r5
 203d9dc:	1009883a 	mov	r4,r2
 203d9e0:	180b883a 	mov	r5,r3
 203d9e4:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 203d9e8:	01009934 	movhi	r4,612
 203d9ec:	21377504 	addi	r4,r4,-8748
 203d9f0:	e0fffc17 	ldw	r3,-16(fp)
 203d9f4:	18c00524 	muli	r3,r3,20
 203d9f8:	20c7883a 	add	r3,r4,r3
 203d9fc:	18c00204 	addi	r3,r3,8
 203da00:	18800015 	stw	r2,0(r3)
         intimers[i].tmo = intimers[i].interval + cticks;   /* first tmo */
 203da04:	00c09934 	movhi	r3,612
 203da08:	18f77504 	addi	r3,r3,-8748
 203da0c:	e0bffc17 	ldw	r2,-16(fp)
 203da10:	10800524 	muli	r2,r2,20
 203da14:	1885883a 	add	r2,r3,r2
 203da18:	10800204 	addi	r2,r2,8
 203da1c:	10c00017 	ldw	r3,0(r2)
 203da20:	00808174 	movhi	r2,517
 203da24:	1090c904 	addi	r2,r2,17188
 203da28:	10800017 	ldw	r2,0(r2)
 203da2c:	1887883a 	add	r3,r3,r2
 203da30:	01009934 	movhi	r4,612
 203da34:	21377504 	addi	r4,r4,-8748
 203da38:	e0bffc17 	ldw	r2,-16(fp)
 203da3c:	10800524 	muli	r2,r2,20
 203da40:	2085883a 	add	r2,r4,r2
 203da44:	10800304 	addi	r2,r2,12
 203da48:	10c00015 	stw	r3,0(r2)
		 intimers[i].inuse = FALSE;
 203da4c:	00c09934 	movhi	r3,612
 203da50:	18f77504 	addi	r3,r3,-8748
 203da54:	e0bffc17 	ldw	r2,-16(fp)
 203da58:	10800524 	muli	r2,r2,20
 203da5c:	1885883a 	add	r2,r3,r2
 203da60:	10800404 	addi	r2,r2,16
 203da64:	10000015 	stw	zero,0(r2)
         numtimers++;
 203da68:	d0a0b417 	ldw	r2,-32048(gp)
 203da6c:	10800044 	addi	r2,r2,1
 203da70:	d0a0b415 	stw	r2,-32048(gp)
         return (long)&intimers[i];
 203da74:	e0bffc17 	ldw	r2,-16(fp)
 203da78:	10c00524 	muli	r3,r2,20
 203da7c:	00809934 	movhi	r2,612
 203da80:	10b77504 	addi	r2,r2,-8748
 203da84:	1885883a 	add	r2,r3,r2
 203da88:	00000706 	br	203daa8 <in_timerset+0x1a4>
long
in_timerset(void (*callback)(long), long msecs, long parm)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 203da8c:	e0bffc17 	ldw	r2,-16(fp)
 203da90:	10800044 	addi	r2,r2,1
 203da94:	e0bffc15 	stw	r2,-16(fp)
 203da98:	e0bffc17 	ldw	r2,-16(fp)
 203da9c:	10800150 	cmplti	r2,r2,5
 203daa0:	103fa11e 	bne	r2,zero,203d928 <in_timerset+0x24>
		 intimers[i].inuse = FALSE;
         numtimers++;
         return (long)&intimers[i];
      }
   }
   return 0;
 203daa4:	0005883a 	mov	r2,zero
}
 203daa8:	e037883a 	mov	sp,fp
 203daac:	dfc00117 	ldw	ra,4(sp)
 203dab0:	df000017 	ldw	fp,0(sp)
 203dab4:	dec00204 	addi	sp,sp,8
 203dab8:	f800283a 	ret

0203dabc <in_timerkill>:
 */


int
in_timerkill(long timer)
{
 203dabc:	defffc04 	addi	sp,sp,-16
 203dac0:	dfc00315 	stw	ra,12(sp)
 203dac4:	df000215 	stw	fp,8(sp)
 203dac8:	df000204 	addi	fp,sp,8
 203dacc:	e13fff15 	stw	r4,-4(fp)
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 203dad0:	e03ffe15 	stw	zero,-8(fp)
 203dad4:	00001606 	br	203db30 <in_timerkill+0x74>
   {
      if(timer == (long)&intimers[i])
 203dad8:	e0bffe17 	ldw	r2,-8(fp)
 203dadc:	10c00524 	muli	r3,r2,20
 203dae0:	00809934 	movhi	r2,612
 203dae4:	10b77504 	addi	r2,r2,-8748
 203dae8:	1885883a 	add	r2,r3,r2
 203daec:	1007883a 	mov	r3,r2
 203daf0:	e0bfff17 	ldw	r2,-4(fp)
 203daf4:	18800b1e 	bne	r3,r2,203db24 <in_timerkill+0x68>
      {
         intimers[i].callback = NULL;
 203daf8:	00c09934 	movhi	r3,612
 203dafc:	18f77504 	addi	r3,r3,-8748
 203db00:	e0bffe17 	ldw	r2,-8(fp)
 203db04:	10800524 	muli	r2,r2,20
 203db08:	1885883a 	add	r2,r3,r2
 203db0c:	10000015 	stw	zero,0(r2)
         numtimers--;
 203db10:	d0a0b417 	ldw	r2,-32048(gp)
 203db14:	10bfffc4 	addi	r2,r2,-1
 203db18:	d0a0b415 	stw	r2,-32048(gp)
         return 0;      /* OK return */
 203db1c:	0005883a 	mov	r2,zero
 203db20:	00000806 	br	203db44 <in_timerkill+0x88>
int
in_timerkill(long timer)
{
   int   i;

   for(i = 0; i < NUM_INTIMERS; i++)
 203db24:	e0bffe17 	ldw	r2,-8(fp)
 203db28:	10800044 	addi	r2,r2,1
 203db2c:	e0bffe15 	stw	r2,-8(fp)
 203db30:	e0bffe17 	ldw	r2,-8(fp)
 203db34:	10800150 	cmplti	r2,r2,5
 203db38:	103fe71e 	bne	r2,zero,203dad8 <in_timerkill+0x1c>
         intimers[i].callback = NULL;
         numtimers--;
         return 0;      /* OK return */
      }
   }
   dtrap();    /* timer to kill not found */
 203db3c:	20285c80 	call	20285c8 <dtrap>
   return ENP_PARAM;
 203db40:	00bffd84 	movi	r2,-10
}
 203db44:	e037883a 	mov	sp,fp
 203db48:	dfc00117 	ldw	ra,4(sp)
 203db4c:	df000017 	ldw	fp,0(sp)
 203db50:	dec00204 	addi	sp,sp,8
 203db54:	f800283a 	ret

0203db58 <create_apptasks>:
#endif
/* per-application thread definitions */

int
create_apptasks(void)
{
 203db58:	defffe04 	addi	sp,sp,-8
 203db5c:	df000115 	stw	fp,4(sp)
 203db60:	df000104 	addi	fp,sp,4
int e = 0;
 203db64:	e03fff15 	stw	zero,-4(fp)
#endif
/* 
 * Altera Niche Stack Nios port modification:
 * return error code, if any 
 */
   return e;
 203db68:	e0bfff17 	ldw	r2,-4(fp)
}
 203db6c:	e037883a 	mov	sp,fp
 203db70:	df000017 	ldw	fp,0(sp)
 203db74:	dec00104 	addi	sp,sp,4
 203db78:	f800283a 	ret

0203db7c <task_stats>:
 */


void
task_stats(void * pio)
{
 203db7c:	defffd04 	addi	sp,sp,-12
 203db80:	dfc00215 	stw	ra,8(sp)
 203db84:	df000115 	stw	fp,4(sp)
 203db88:	df000104 	addi	fp,sp,4
 203db8c:	e13fff15 	stw	r4,-4(fp)
   ns_printf(pio, "Task wakeups:");
 203db90:	e13fff17 	ldw	r4,-4(fp)
 203db94:	01408174 	movhi	r5,517
 203db98:	29451404 	addi	r5,r5,5200
 203db9c:	2026e100 	call	2026e10 <ns_printf>

#ifndef NO_INET_STACK
   ns_printf(pio, "netmain: %lu\n", netmain_wakes);
 203dba0:	00808174 	movhi	r2,517
 203dba4:	1090b904 	addi	r2,r2,17124
 203dba8:	10800017 	ldw	r2,0(r2)
 203dbac:	e13fff17 	ldw	r4,-4(fp)
 203dbb0:	01408174 	movhi	r5,517
 203dbb4:	29451804 	addi	r5,r5,5216
 203dbb8:	100d883a 	mov	r6,r2
 203dbbc:	2026e100 	call	2026e10 <ns_printf>
#endif
#ifndef NO_INET_TICK
   ns_printf(pio, "nettick: %lu\n", nettick_wakes);
 203dbc0:	00808174 	movhi	r2,517
 203dbc4:	1090ba04 	addi	r2,r2,17128
 203dbc8:	10800017 	ldw	r2,0(r2)
 203dbcc:	e13fff17 	ldw	r4,-4(fp)
 203dbd0:	01408174 	movhi	r5,517
 203dbd4:	29451c04 	addi	r5,r5,5232
 203dbd8:	100d883a 	mov	r6,r2
 203dbdc:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio, "browtask: %lu  ", browtask_wakes);
#endif
#ifdef INCLUDE_SSLAPP
   ns_printf(pio, "INCLUDE_SSLAPP: %lu  ", sslapp_wakes);
#endif
   ns_printf(pio, "\n");
 203dbe0:	e13fff17 	ldw	r4,-4(fp)
 203dbe4:	01408174 	movhi	r5,517
 203dbe8:	29452004 	addi	r5,r5,5248
 203dbec:	2026e100 	call	2026e10 <ns_printf>
}
 203dbf0:	e037883a 	mov	sp,fp
 203dbf4:	dfc00117 	ldw	ra,4(sp)
 203dbf8:	df000017 	ldw	fp,0(sp)
 203dbfc:	dec00204 	addi	sp,sp,8
 203dc00:	f800283a 	ret

0203dc04 <fcntl>:
 * (for files and device drivers) or calls the InterNiche bsd_ioctl for 
 * sockets.
 */
 
int fcntl (int file, int cmd, ...)
{
 203dc04:	defff804 	addi	sp,sp,-32
 203dc08:	dfc00515 	stw	ra,20(sp)
 203dc0c:	df000415 	stw	fp,16(sp)
 203dc10:	df000404 	addi	fp,sp,16
 203dc14:	e13ffe15 	stw	r4,-8(fp)
 203dc18:	e1800215 	stw	r6,8(fp)
 203dc1c:	e1c00315 	stw	r7,12(fp)
 203dc20:	e17fff15 	stw	r5,-4(fp)
  long     flags;
  va_list  argp;

  if (file < ALT_MAX_FD)
 203dc24:	e0bffe17 	ldw	r2,-8(fp)
 203dc28:	10800808 	cmpgei	r2,r2,32
 203dc2c:	10000c1e 	bne	r2,zero,203dc60 <fcntl+0x5c>
  {
    va_start(argp, cmd);
 203dc30:	e0800204 	addi	r2,fp,8
 203dc34:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 203dc38:	e0bffd17 	ldw	r2,-12(fp)
 203dc3c:	10c00104 	addi	r3,r2,4
 203dc40:	e0fffd15 	stw	r3,-12(fp)
 203dc44:	10800017 	ldw	r2,0(r2)
 203dc48:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return alt_fcntl(file, cmd, flags);
 203dc4c:	e13ffe17 	ldw	r4,-8(fp)
 203dc50:	e17fff17 	ldw	r5,-4(fp)
 203dc54:	e1bffc17 	ldw	r6,-16(fp)
 203dc58:	204a7000 	call	204a700 <alt_fcntl>
 203dc5c:	00000c06 	br	203dc90 <fcntl+0x8c>
  }
  else
  {
    va_start(argp, cmd);
 203dc60:	e0800204 	addi	r2,fp,8
 203dc64:	e0bffd15 	stw	r2,-12(fp)
    flags = va_arg(argp, long);
 203dc68:	e0bffd17 	ldw	r2,-12(fp)
 203dc6c:	10c00104 	addi	r3,r2,4
 203dc70:	e0fffd15 	stw	r3,-12(fp)
 203dc74:	10800017 	ldw	r2,0(r2)
 203dc78:	e0bffc15 	stw	r2,-16(fp)
    va_end(argp);
    return bsd_ioctl(file, cmd, flags);
 203dc7c:	e0bfff17 	ldw	r2,-4(fp)
 203dc80:	e13ffe17 	ldw	r4,-8(fp)
 203dc84:	100b883a 	mov	r5,r2
 203dc88:	e1bffc17 	ldw	r6,-16(fp)
 203dc8c:	20262600 	call	2026260 <bsd_ioctl>
  }
}
 203dc90:	e037883a 	mov	sp,fp
 203dc94:	dfc00117 	ldw	ra,4(sp)
 203dc98:	df000017 	ldw	fp,0(sp)
 203dc9c:	dec00404 	addi	sp,sp,16
 203dca0:	f800283a 	ret

0203dca4 <etainit>:
 * RETURNS: int               0 if OK, else nonzero
 */

int
etainit(void)
{
 203dca4:	defffe04 	addi	sp,sp,-8
 203dca8:	dfc00115 	stw	ra,4(sp)
 203dcac:	df000015 	stw	fp,0(sp)
 203dcb0:	d839883a 	mov	fp,sp
   /* register ARP type with the Net Driver */
   if (reg_type(ET_ARP) != 0)
 203dcb4:	01018204 	movi	r4,1544
 203dcb8:	203f2ac0 	call	203f2ac <reg_type>
 203dcbc:	10000526 	beq	r2,zero,203dcd4 <etainit+0x30>
   {
#ifdef NPDEBUG
      dprintf("ARP: unable to register type with MAC Driver\n");
 203dcc0:	01008174 	movhi	r4,517
 203dcc4:	21052104 	addi	r4,r4,5252
 203dcc8:	2006cb40 	call	2006cb4 <puts>
#endif
      return (1);
 203dccc:	00800044 	movi	r2,1
 203dcd0:	00000106 	br	203dcd8 <etainit+0x34>
   }
   return (0);
 203dcd4:	0005883a 	mov	r2,zero
}
 203dcd8:	e037883a 	mov	sp,fp
 203dcdc:	dfc00117 	ldw	ra,4(sp)
 203dce0:	df000017 	ldw	fp,0(sp)
 203dce4:	dec00204 	addi	sp,sp,8
 203dce8:	f800283a 	ret

0203dcec <et_send>:
 * and MIB info in the packet header. 
 */

int
et_send(PACKET pkt, struct arptabent *tp)
{
 203dcec:	defff904 	addi	sp,sp,-28
 203dcf0:	dfc00615 	stw	ra,24(sp)
 203dcf4:	df000515 	stw	fp,20(sp)
 203dcf8:	df000504 	addi	fp,sp,20
 203dcfc:	e13ffe15 	stw	r4,-8(fp)
 203dd00:	e17fff15 	stw	r5,-4(fp)
   char *ethhdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 203dd04:	e0bffe17 	ldw	r2,-8(fp)
 203dd08:	10800617 	ldw	r2,24(r2)
 203dd0c:	10802717 	ldw	r2,156(r2)
 203dd10:	e0bffc15 	stw	r2,-16(fp)
   int err;

   tp->lasttime = cticks;
 203dd14:	00808174 	movhi	r2,517
 203dd18:	1090c904 	addi	r2,r2,17188
 203dd1c:	10c00017 	ldw	r3,0(r2)
 203dd20:	e0bfff17 	ldw	r2,-4(fp)
 203dd24:	10c00615 	stw	r3,24(r2)
   pkt->nb_prot -= ETHHDR_SIZE;  /* prepare for prepending ethernet header */
 203dd28:	e0bffe17 	ldw	r2,-8(fp)
 203dd2c:	10800317 	ldw	r2,12(r2)
 203dd30:	10fffc04 	addi	r3,r2,-16
 203dd34:	e0bffe17 	ldw	r2,-8(fp)
 203dd38:	10c00315 	stw	r3,12(r2)
   pkt->nb_plen += ETHHDR_SIZE;
 203dd3c:	e0bffe17 	ldw	r2,-8(fp)
 203dd40:	10800417 	ldw	r2,16(r2)
 203dd44:	10c00404 	addi	r3,r2,16
 203dd48:	e0bffe17 	ldw	r2,-8(fp)
 203dd4c:	10c00415 	stw	r3,16(r2)
   ethhdr = pkt->nb_prot + ETHHDR_BIAS;
 203dd50:	e0bffe17 	ldw	r2,-8(fp)
 203dd54:	10800317 	ldw	r2,12(r2)
 203dd58:	10800084 	addi	r2,r2,2
 203dd5c:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(snap, snapdata, 6);
      snap->type = ARPIP;
   }
#endif   /* IEEE_802_3 */

   if (ethhdr < pkt->nb_buff)   /* sanity check pointer */
 203dd60:	e0bffe17 	ldw	r2,-8(fp)
 203dd64:	10800117 	ldw	r2,4(r2)
 203dd68:	e0fffd17 	ldw	r3,-12(fp)
 203dd6c:	1880032e 	bgeu	r3,r2,203dd7c <et_send+0x90>
      panic("et_send: prepend");
 203dd70:	01008174 	movhi	r4,517
 203dd74:	21052d04 	addi	r4,r4,5300
 203dd78:	2026bf80 	call	2026bf8 <panic>

   MEMMOVE(ethhdr + ET_DSTOFF, tp->t_phy_addr, 6);  /* set pkt's MAC dst addr */
 203dd7c:	e0bfff17 	ldw	r2,-4(fp)
 203dd80:	10800104 	addi	r2,r2,4
 203dd84:	e13ffd17 	ldw	r4,-12(fp)
 203dd88:	100b883a 	mov	r5,r2
 203dd8c:	01800184 	movi	r6,6
 203dd90:	20067040 	call	2006704 <memmove>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);  /* MAC src */
 203dd94:	e0bffd17 	ldw	r2,-12(fp)
 203dd98:	10c00184 	addi	r3,r2,6
 203dd9c:	e0bffc17 	ldw	r2,-16(fp)
 203dda0:	10800517 	ldw	r2,20(r2)
 203dda4:	1809883a 	mov	r4,r3
 203dda8:	100b883a 	mov	r5,r2
 203ddac:	01800184 	movi	r6,6
 203ddb0:	20067040 	call	2006704 <memmove>

   /* nice clean ethernet II header */
   if ((tp->flags & (ET_ETH2|ET_SNAP)) != ET_SNAP)
 203ddb4:	e0bfff17 	ldw	r2,-4(fp)
 203ddb8:	1080070b 	ldhu	r2,28(r2)
 203ddbc:	10bfffcc 	andi	r2,r2,65535
 203ddc0:	108000cc 	andi	r2,r2,3
 203ddc4:	108000a0 	cmpeqi	r2,r2,2
 203ddc8:	1000041e 	bne	r2,zero,203dddc <et_send+0xf0>
      ET_TYPE_SET(ethhdr, ntohs(ARPIP));
 203ddcc:	e0bffd17 	ldw	r2,-12(fp)
 203ddd0:	10800304 	addi	r2,r2,12
 203ddd4:	00c00204 	movi	r3,8
 203ddd8:	10c00005 	stb	r3,0(r2)
 203dddc:	e0bffd17 	ldw	r2,-12(fp)
 203dde0:	10800344 	addi	r2,r2,13
 203dde4:	10000005 	stb	zero,0(r2)
      ET_TYPE_SET(ethhdr, len8023);
   }
#endif   /* IEEE_802_3 */

   /* if a packet oriented send exists, use it: */
   if (pkt->net->pkt_send)
 203dde8:	e0bffe17 	ldw	r2,-8(fp)
 203ddec:	10800617 	ldw	r2,24(r2)
 203ddf0:	10800417 	ldw	r2,16(r2)
 203ddf4:	10000726 	beq	r2,zero,203de14 <et_send+0x128>
      err = pkt->net->pkt_send(pkt);   /* send packet to media */
 203ddf8:	e0bffe17 	ldw	r2,-8(fp)
 203ddfc:	10800617 	ldw	r2,24(r2)
 203de00:	10800417 	ldw	r2,16(r2)
 203de04:	e13ffe17 	ldw	r4,-8(fp)
 203de08:	103ee83a 	callr	r2
 203de0c:	e0bffb15 	stw	r2,-20(fp)
 203de10:	00001306 	br	203de60 <et_send+0x174>
   else  /* else use older raw_send routine */
   {
      /* sent to media */
      err = pkt->net->raw_send(pkt->net, pkt->nb_prot, pkt->nb_plen);
 203de14:	e0bffe17 	ldw	r2,-8(fp)
 203de18:	10800617 	ldw	r2,24(r2)
 203de1c:	11c00317 	ldw	r7,12(r2)
 203de20:	e0bffe17 	ldw	r2,-8(fp)
 203de24:	11000617 	ldw	r4,24(r2)
 203de28:	e0bffe17 	ldw	r2,-8(fp)
 203de2c:	10c00317 	ldw	r3,12(r2)
 203de30:	e0bffe17 	ldw	r2,-8(fp)
 203de34:	10800417 	ldw	r2,16(r2)
 203de38:	180b883a 	mov	r5,r3
 203de3c:	100d883a 	mov	r6,r2
 203de40:	383ee83a 	callr	r7
 203de44:	e0bffb15 	stw	r2,-20(fp)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203de48:	01000084 	movi	r4,2
 203de4c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 203de50:	e13ffe17 	ldw	r4,-8(fp)
 203de54:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203de58:	01000084 	movi	r4,2
 203de5c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   }

   return (err);
 203de60:	e0bffb17 	ldw	r2,-20(fp)
}
 203de64:	e037883a 	mov	sp,fp
 203de68:	dfc00117 	ldw	ra,4(sp)
 203de6c:	df000017 	ldw	fp,0(sp)
 203de70:	dec00204 	addi	sp,sp,8
 203de74:	f800283a 	ret

0203de78 <arp_free_pending>:
 * and mark the entry "unused".
 */

void
arp_free_pending(struct arptabent *entry)
{
 203de78:	defffb04 	addi	sp,sp,-20
 203de7c:	dfc00415 	stw	ra,16(sp)
 203de80:	df000315 	stw	fp,12(sp)
 203de84:	df000304 	addi	fp,sp,12
 203de88:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt;
   PACKET nextpkt;

   /* entry->pending has the linked list of all pending packets */
   tmppkt = entry->pending;
 203de8c:	e0bfff17 	ldw	r2,-4(fp)
 203de90:	10800417 	ldw	r2,16(r2)
 203de94:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;
 203de98:	e0bfff17 	ldw	r2,-4(fp)
 203de9c:	10000415 	stw	zero,16(r2)

   LOCK_NET_RESOURCE(FREEQ_RESID);
 203dea0:	01000084 	movi	r4,2
 203dea4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   /* free all pending packets */
   while (tmppkt)
 203dea8:	00000906 	br	203ded0 <arp_free_pending+0x58>
   {
      nextpkt = tmppkt->next;        /* save the next packet in list */
 203deac:	e0bffd17 	ldw	r2,-12(fp)
 203deb0:	10800017 	ldw	r2,0(r2)
 203deb4:	e0bffe15 	stw	r2,-8(fp)
      tmppkt->next = (PACKET)NULL;
 203deb8:	e0bffd17 	ldw	r2,-12(fp)
 203debc:	10000015 	stw	zero,0(r2)
      pk_free(tmppkt);               /* free current packet */
 203dec0:	e13ffd17 	ldw	r4,-12(fp)
 203dec4:	20280440 	call	2028044 <pk_free>
      tmppkt = nextpkt;              /* process the next packet */
 203dec8:	e0bffe17 	ldw	r2,-8(fp)
 203decc:	e0bffd15 	stw	r2,-12(fp)
   entry->pending = (PACKET)NULL;

   LOCK_NET_RESOURCE(FREEQ_RESID);

   /* free all pending packets */
   while (tmppkt)
 203ded0:	e0bffd17 	ldw	r2,-12(fp)
 203ded4:	103ff51e 	bne	r2,zero,203deac <arp_free_pending+0x34>
      tmppkt->next = (PACKET)NULL;
      pk_free(tmppkt);               /* free current packet */
      tmppkt = nextpkt;              /* process the next packet */
   }

   entry->t_pro_addr = 0;     /* mark the entry "unused" */
 203ded8:	e0bfff17 	ldw	r2,-4(fp)
 203dedc:	10000015 	stw	zero,0(r2)

   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203dee0:	01000084 	movi	r4,2
 203dee4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
}
 203dee8:	e037883a 	mov	sp,fp
 203deec:	dfc00117 	ldw	ra,4(sp)
 203def0:	df000017 	ldw	fp,0(sp)
 203def4:	dec00204 	addi	sp,sp,8
 203def8:	f800283a 	ret

0203defc <arp_send_pending>:
 * Clear the list (entry->pending) after sending the packets.
 */

void
arp_send_pending(struct arptabent *entry)
{
 203defc:	defffc04 	addi	sp,sp,-16
 203df00:	dfc00315 	stw	ra,12(sp)
 203df04:	df000215 	stw	fp,8(sp)
 203df08:	df000204 	addi	fp,sp,8
 203df0c:	e13fff15 	stw	r4,-4(fp)
   PACKET tmppkt = entry->pending;
 203df10:	e0bfff17 	ldw	r2,-4(fp)
 203df14:	10800417 	ldw	r2,16(r2)
 203df18:	e0bffe15 	stw	r2,-8(fp)

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 203df1c:	00000906 	br	203df44 <arp_send_pending+0x48>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
 203df20:	e0bffe17 	ldw	r2,-8(fp)
 203df24:	10c00017 	ldw	r3,0(r2)
 203df28:	e0bfff17 	ldw	r2,-4(fp)
 203df2c:	10c00415 	stw	r3,16(r2)
      tmppkt->next = (PACKET)NULL;
 203df30:	e0bffe17 	ldw	r2,-8(fp)
 203df34:	10000015 	stw	zero,0(r2)
      et_send(tmppkt, entry);          /* try send again */
 203df38:	e13ffe17 	ldw	r4,-8(fp)
 203df3c:	e17fff17 	ldw	r5,-4(fp)
 203df40:	203dcec0 	call	203dcec <et_send>
   PACKET tmppkt = entry->pending;

   /* entry->pending has the linked list of all pending packets */

   /* send all pending packets */
   while ((tmppkt = entry->pending) != (PACKET)NULL)
 203df44:	e0bfff17 	ldw	r2,-4(fp)
 203df48:	10800417 	ldw	r2,16(r2)
 203df4c:	e0bffe15 	stw	r2,-8(fp)
 203df50:	e0bffe17 	ldw	r2,-8(fp)
 203df54:	103ff21e 	bne	r2,zero,203df20 <arp_send_pending+0x24>
   {
      entry->pending = tmppkt->next;   /* unlink the next packet */
      tmppkt->next = (PACKET)NULL;
      et_send(tmppkt, entry);          /* try send again */
   }
}
 203df58:	e037883a 	mov	sp,fp
 203df5c:	dfc00117 	ldw	ra,4(sp)
 203df60:	df000017 	ldw	fp,0(sp)
 203df64:	dec00204 	addi	sp,sp,8
 203df68:	f800283a 	ret

0203df6c <send_arp>:
 * timeout will eventually free packet. 
 */

int
send_arp(PACKET pkt, ip_addr dest_ip)
{
 203df6c:	defff404 	addi	sp,sp,-48
 203df70:	dfc00b15 	stw	ra,44(sp)
 203df74:	df000a15 	stw	fp,40(sp)
 203df78:	df000a04 	addi	fp,sp,40
 203df7c:	e13ffe15 	stw	r4,-8(fp)
 203df80:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *   oldest;
   char * ethhdr;
   NET net = pkt->net;
 203df84:	e0bffe17 	ldw	r2,-8(fp)
 203df88:	10800617 	ldw	r2,24(r2)
 203df8c:	e0bff615 	stw	r2,-40(fp)
   struct arp_hdr *  arphdr;
   IFMIB etif = pkt->net->n_mib;    /* mib info for this ethernet interface */
 203df90:	e0bffe17 	ldw	r2,-8(fp)
 203df94:	10800617 	ldw	r2,24(r2)
 203df98:	10802717 	ldw	r2,156(r2)
 203df9c:	e0bff715 	stw	r2,-36(fp)
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 203dfa0:	e0bfff17 	ldw	r2,-4(fp)
 203dfa4:	10bfffe0 	cmpeqi	r2,r2,-1
 203dfa8:	1000191e 	bne	r2,zero,203e010 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
 203dfac:	e0bff617 	ldw	r2,-40(fp)
 203dfb0:	10800c17 	ldw	r2,48(r2)
 203dfb4:	0086303a 	nor	r3,zero,r2
 203dfb8:	e0bfff17 	ldw	r2,-4(fp)
 203dfbc:	1886703a 	and	r3,r3,r2
 203dfc0:	e0bff617 	ldw	r2,-40(fp)
 203dfc4:	10800c17 	ldw	r2,48(r2)
 203dfc8:	0084303a 	nor	r2,zero,r2
   } dest_ip_ptr;
#endif /* ETHMCAST */


   /* If we are broadcasting or multicasting ... */
   if ((dest_ip == 0xFFFFFFFF) ||  
 203dfcc:	18801026 	beq	r3,r2,203e010 <send_arp+0xa4>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask)))
       || (IN_MULTICAST(ntohl(dest_ip)) ))
 203dfd0:	e0bfff17 	ldw	r2,-4(fp)
 203dfd4:	1006d63a 	srli	r3,r2,24
 203dfd8:	e0bfff17 	ldw	r2,-4(fp)
 203dfdc:	1004d23a 	srli	r2,r2,8
 203dfe0:	10bfc00c 	andi	r2,r2,65280
 203dfe4:	1886b03a 	or	r3,r3,r2
 203dfe8:	e0bfff17 	ldw	r2,-4(fp)
 203dfec:	10bfc00c 	andi	r2,r2,65280
 203dff0:	1004923a 	slli	r2,r2,8
 203dff4:	1886b03a 	or	r3,r3,r2
 203dff8:	e0bfff17 	ldw	r2,-4(fp)
 203dffc:	1004963a 	slli	r2,r2,24
 203e000:	1884b03a 	or	r2,r3,r2
 203e004:	10fc002c 	andhi	r3,r2,61440
 203e008:	00b80034 	movhi	r2,57344
 203e00c:	1880391e 	bne	r3,r2,203e0f4 <send_arp+0x188>
      ((dest_ip & ~(net->snmask)) == (0xFFFFFFFF & ~(net->snmask))))

#endif /* IP_MULTICAST */
   {
      /* get unused or oldest entry in table */
      oldest = make_arp_entry(dest_ip, pkt->net);
 203e010:	e0bffe17 	ldw	r2,-8(fp)
 203e014:	10800617 	ldw	r2,24(r2)
 203e018:	e13fff17 	ldw	r4,-4(fp)
 203e01c:	100b883a 	mov	r5,r2
 203e020:	203e5780 	call	203e578 <make_arp_entry>
 203e024:	e0bff915 	stw	r2,-28(fp)

      /* set MAC destination to ethernet broadcast (all FFs) */
      MEMSET(oldest->t_phy_addr, 0xFF, 6);
 203e028:	e0bff917 	ldw	r2,-28(fp)
 203e02c:	10800104 	addi	r2,r2,4
 203e030:	1009883a 	mov	r4,r2
 203e034:	01403fc4 	movi	r5,255
 203e038:	01800184 	movi	r6,6
 203e03c:	200682c0 	call	200682c <memset>
#ifdef IP_MULTICAST
      /* If n_mcastlist routine is defined in the net structure,
         map IP mcast to Ether multicast  */

#ifdef ETHMCAST
      if ((pkt->net->n_mcastlist) && (IN_MULTICAST(ntohl(dest_ip))))
 203e040:	e0bffe17 	ldw	r2,-8(fp)
 203e044:	10800617 	ldw	r2,24(r2)
 203e048:	10802b17 	ldw	r2,172(r2)
 203e04c:	10002526 	beq	r2,zero,203e0e4 <send_arp+0x178>
 203e050:	e0bfff17 	ldw	r2,-4(fp)
 203e054:	1006d63a 	srli	r3,r2,24
 203e058:	e0bfff17 	ldw	r2,-4(fp)
 203e05c:	1004d23a 	srli	r2,r2,8
 203e060:	10bfc00c 	andi	r2,r2,65280
 203e064:	1886b03a 	or	r3,r3,r2
 203e068:	e0bfff17 	ldw	r2,-4(fp)
 203e06c:	10bfc00c 	andi	r2,r2,65280
 203e070:	1004923a 	slli	r2,r2,8
 203e074:	1886b03a 	or	r3,r3,r2
 203e078:	e0bfff17 	ldw	r2,-4(fp)
 203e07c:	1004963a 	slli	r2,r2,24
 203e080:	1884b03a 	or	r2,r3,r2
 203e084:	10fc002c 	andhi	r3,r2,61440
 203e088:	00b80034 	movhi	r2,57344
 203e08c:	1880151e 	bne	r3,r2,203e0e4 <send_arp+0x178>
      {
         /* If IP mcast to be mapped to Ethernet multicast */
         dest_ip_ptr.l = dest_ip;
 203e090:	e0bfff17 	ldw	r2,-4(fp)
 203e094:	e0bffd15 	stw	r2,-12(fp)
         oldest->t_phy_addr[0] = 0x01;
 203e098:	e0bff917 	ldw	r2,-28(fp)
 203e09c:	00c00044 	movi	r3,1
 203e0a0:	10c00105 	stb	r3,4(r2)
         oldest->t_phy_addr[1] = 0x00;
 203e0a4:	e0bff917 	ldw	r2,-28(fp)
 203e0a8:	10000145 	stb	zero,5(r2)
         oldest->t_phy_addr[2] = 0x5e;
 203e0ac:	e0bff917 	ldw	r2,-28(fp)
 203e0b0:	00c01784 	movi	r3,94
 203e0b4:	10c00185 	stb	r3,6(r2)
         oldest->t_phy_addr[3] = (u_char )(dest_ip_ptr.c[1] & 0x7f);
 203e0b8:	e0bffd43 	ldbu	r2,-11(fp)
 203e0bc:	10801fcc 	andi	r2,r2,127
 203e0c0:	1007883a 	mov	r3,r2
 203e0c4:	e0bff917 	ldw	r2,-28(fp)
 203e0c8:	10c001c5 	stb	r3,7(r2)
         oldest->t_phy_addr[4] = (u_char )dest_ip_ptr.c[2];
 203e0cc:	e0fffd83 	ldbu	r3,-10(fp)
 203e0d0:	e0bff917 	ldw	r2,-28(fp)
 203e0d4:	10c00205 	stb	r3,8(r2)
         oldest->t_phy_addr[5] = (u_char )dest_ip_ptr.c[3];
 203e0d8:	e0fffdc3 	ldbu	r3,-9(fp)
 203e0dc:	e0bff917 	ldw	r2,-28(fp)
 203e0e0:	10c00245 	stb	r3,9(r2)
      }
#endif /* ETHMCAST */
#endif /* IP_MULTICAST */
      return (et_send(pkt, oldest));
 203e0e4:	e13ffe17 	ldw	r4,-8(fp)
 203e0e8:	e17ff917 	ldw	r5,-28(fp)
 203e0ec:	203dcec0 	call	203dcec <et_send>
 203e0f0:	0000af06 	br	203e3b0 <send_arp+0x444>

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 203e0f4:	e0bffe17 	ldw	r2,-8(fp)
 203e0f8:	10c00717 	ldw	r3,28(r2)
 203e0fc:	e0bffe17 	ldw	r2,-8(fp)
 203e100:	10800617 	ldw	r2,24(r2)
 203e104:	10800a17 	ldw	r2,40(r2)
 203e108:	18800d1e 	bne	r3,r2,203e140 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
 203e10c:	e0bffe17 	ldw	r2,-8(fp)
 203e110:	10800717 	ldw	r2,28(r2)
 203e114:	10803fcc 	andi	r2,r2,255

   /* If packet is addressed to this Ethernet interface, and
    * it's not a loopback address, then don't send it on the wire. 
    * Instead, free the packet and return ENP_NO_ROUTE  
    */
   if ((pkt->fhost == pkt->net->n_ipaddr) &&
 203e118:	10801fe0 	cmpeqi	r2,r2,127
 203e11c:	1000081e 	bne	r2,zero,203e140 <send_arp+0x1d4>
      ((pkt->fhost & htonl(0xFF000000)) != htonl(0x7F000000)))
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203e120:	01000084 	movi	r4,2
 203e124:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 203e128:	e13ffe17 	ldw	r4,-8(fp)
 203e12c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203e130:	01000084 	movi	r4,2
 203e134:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_NO_ROUTE;
 203e138:	00bff7c4 	movi	r2,-33
 203e13c:	00009c06 	br	203e3b0 <send_arp+0x444>
   }

   /* not broadcasting, so get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 203e140:	01000084 	movi	r4,2
 203e144:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 203e148:	01000c04 	movi	r4,48
 203e14c:	2027cec0 	call	2027cec <pk_alloc>
 203e150:	e0bff815 	stw	r2,-32(fp)
   if (!arppkt)
 203e154:	e0bff817 	ldw	r2,-32(fp)
 203e158:	1000061e 	bne	r2,zero,203e174 <send_arp+0x208>
   {
      pk_free(pkt);
 203e15c:	e13ffe17 	ldw	r4,-8(fp)
 203e160:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203e164:	01000084 	movi	r4,2
 203e168:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 203e16c:	00bffa84 	movi	r2,-22
 203e170:	00008f06 	br	203e3b0 <send_arp+0x444>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203e174:	01000084 	movi	r4,2
 203e178:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 203e17c:	e0bff817 	ldw	r2,-32(fp)
 203e180:	10c00117 	ldw	r3,4(r2)
 203e184:	e0bff817 	ldw	r2,-32(fp)
 203e188:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 203e18c:	e0bff817 	ldw	r2,-32(fp)
 203e190:	00c00c04 	movi	r3,48
 203e194:	10c00415 	stw	r3,16(r2)
   arppkt->net = pkt->net;
 203e198:	e0bffe17 	ldw	r2,-8(fp)
 203e19c:	10c00617 	ldw	r3,24(r2)
 203e1a0:	e0bff817 	ldw	r2,-32(fp)
 203e1a4:	10c00615 	stw	r3,24(r2)

   /* get unused or oldest entry in table */
   oldest = make_arp_entry(dest_ip, pkt->net);
 203e1a8:	e0bffe17 	ldw	r2,-8(fp)
 203e1ac:	10800617 	ldw	r2,24(r2)
 203e1b0:	e13fff17 	ldw	r4,-4(fp)
 203e1b4:	100b883a 	mov	r5,r2
 203e1b8:	203e5780 	call	203e578 <make_arp_entry>
 203e1bc:	e0bff915 	stw	r2,-28(fp)

   oldest->pending = pkt;           /* packet is "pended", not pk_free()d */
 203e1c0:	e0bff917 	ldw	r2,-28(fp)
 203e1c4:	e0fffe17 	ldw	r3,-8(fp)
 203e1c8:	10c00415 	stw	r3,16(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 203e1cc:	e0bff817 	ldw	r2,-32(fp)
 203e1d0:	10800117 	ldw	r2,4(r2)
 203e1d4:	10800084 	addi	r2,r2,2
 203e1d8:	e0bffa15 	stw	r2,-24(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 203e1dc:	e0bff817 	ldw	r2,-32(fp)
 203e1e0:	10800117 	ldw	r2,4(r2)
 203e1e4:	10800404 	addi	r2,r2,16
 203e1e8:	e0bffb15 	stw	r2,-20(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 203e1ec:	e0bffb17 	ldw	r2,-20(fp)
 203e1f0:	00c04004 	movi	r3,256
 203e1f4:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 203e1f8:	e0bffb17 	ldw	r2,-20(fp)
 203e1fc:	00c00204 	movi	r3,8
 203e200:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 203e204:	e0bffb17 	ldw	r2,-20(fp)
 203e208:	00c00184 	movi	r3,6
 203e20c:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 203e210:	e0bffb17 	ldw	r2,-20(fp)
 203e214:	00c00104 	movi	r3,4
 203e218:	10c00145 	stb	r3,5(r2)
   arphdr->ar_op = ARREQ;
 203e21c:	e0bffb17 	ldw	r2,-20(fp)
 203e220:	00c04004 	movi	r3,256
 203e224:	10c0018d 	sth	r3,6(r2)
   arphdr->ar_tpa = dest_ip;        /* target's IP address */
 203e228:	e0bffb17 	ldw	r2,-20(fp)
 203e22c:	e0ffff17 	ldw	r3,-4(fp)
 203e230:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = pkt->net->n_ipaddr;   /* my IP address */
 203e234:	e0bffe17 	ldw	r2,-8(fp)
 203e238:	10800617 	ldw	r2,24(r2)
 203e23c:	10c00a17 	ldw	r3,40(r2)
 203e240:	e0bffb17 	ldw	r2,-20(fp)
 203e244:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 203e248:	e0bffb17 	ldw	r2,-20(fp)
 203e24c:	10c00204 	addi	r3,r2,8
 203e250:	e0bff717 	ldw	r2,-36(fp)
 203e254:	10800517 	ldw	r2,20(r2)
 203e258:	1809883a 	mov	r4,r3
 203e25c:	100b883a 	mov	r5,r2
 203e260:	01800184 	movi	r6,6
 203e264:	20067040 	call	2006704 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 203e268:	e13ffa17 	ldw	r4,-24(fp)
 203e26c:	01403fc4 	movi	r5,255
 203e270:	01800184 	movi	r6,6
 203e274:	200682c0 	call	200682c <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 203e278:	e0bffa17 	ldw	r2,-24(fp)
 203e27c:	10c00184 	addi	r3,r2,6
 203e280:	e0bff717 	ldw	r2,-36(fp)
 203e284:	10800517 	ldw	r2,20(r2)
 203e288:	1809883a 	mov	r4,r3
 203e28c:	100b883a 	mov	r5,r2
 203e290:	01800184 	movi	r6,6
 203e294:	20067040 	call	2006704 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 203e298:	e0bffa17 	ldw	r2,-24(fp)
 203e29c:	10800304 	addi	r2,r2,12
 203e2a0:	00c00204 	movi	r3,8
 203e2a4:	10c00005 	stb	r3,0(r2)
 203e2a8:	e0bffa17 	ldw	r2,-24(fp)
 203e2ac:	10800344 	addi	r2,r2,13
 203e2b0:	00c00184 	movi	r3,6
 203e2b4:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 203e2b8:	e0bffb17 	ldw	r2,-20(fp)
 203e2bc:	e0bffc15 	stw	r2,-16(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 203e2c0:	e0bffc17 	ldw	r2,-16(fp)
 203e2c4:	10c00204 	addi	r3,r2,8
 203e2c8:	e0bffb17 	ldw	r2,-20(fp)
 203e2cc:	10800204 	addi	r2,r2,8
 203e2d0:	1809883a 	mov	r4,r3
 203e2d4:	100b883a 	mov	r5,r2
 203e2d8:	01800184 	movi	r6,6
 203e2dc:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 203e2e0:	e0bffc17 	ldw	r2,-16(fp)
 203e2e4:	10c00384 	addi	r3,r2,14
 203e2e8:	e0bffb17 	ldw	r2,-20(fp)
 203e2ec:	10800404 	addi	r2,r2,16
 203e2f0:	1809883a 	mov	r4,r3
 203e2f4:	100b883a 	mov	r5,r2
 203e2f8:	01800104 	movi	r6,4
 203e2fc:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 203e300:	e0bffc17 	ldw	r2,-16(fp)
 203e304:	10c00484 	addi	r3,r2,18
 203e308:	e0bffb17 	ldw	r2,-20(fp)
 203e30c:	10800504 	addi	r2,r2,20
 203e310:	1809883a 	mov	r4,r3
 203e314:	100b883a 	mov	r5,r2
 203e318:	01800184 	movi	r6,6
 203e31c:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 203e320:	e0bffc17 	ldw	r2,-16(fp)
 203e324:	10c00604 	addi	r3,r2,24
 203e328:	e0bffb17 	ldw	r2,-20(fp)
 203e32c:	10800704 	addi	r2,r2,28
 203e330:	1809883a 	mov	r4,r3
 203e334:	100b883a 	mov	r5,r2
 203e338:	01800104 	movi	r6,4
 203e33c:	20067040 	call	2006704 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 203e340:	e0bff617 	ldw	r2,-40(fp)
 203e344:	10800417 	ldw	r2,16(r2)
 203e348:	10000526 	beq	r2,zero,203e360 <send_arp+0x3f4>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 203e34c:	e0bff617 	ldw	r2,-40(fp)
 203e350:	10800417 	ldw	r2,16(r2)
 203e354:	e13ff817 	ldw	r4,-32(fp)
 203e358:	103ee83a 	callr	r2
 203e35c:	00001006 	br	203e3a0 <send_arp+0x434>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 203e360:	e0bff617 	ldw	r2,-40(fp)
 203e364:	11c00317 	ldw	r7,12(r2)
 203e368:	e0bff817 	ldw	r2,-32(fp)
 203e36c:	10c00617 	ldw	r3,24(r2)
 203e370:	e0bff817 	ldw	r2,-32(fp)
 203e374:	10800117 	ldw	r2,4(r2)
 203e378:	1809883a 	mov	r4,r3
 203e37c:	100b883a 	mov	r5,r2
 203e380:	01800c04 	movi	r6,48
 203e384:	383ee83a 	callr	r7
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203e388:	01000084 	movi	r4,2
 203e38c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 203e390:	e13ff817 	ldw	r4,-32(fp)
 203e394:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203e398:	01000084 	movi	r4,2
 203e39c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 203e3a0:	d0a0b917 	ldw	r2,-32028(gp)
 203e3a4:	10800044 	addi	r2,r2,1
 203e3a8:	d0a0b915 	stw	r2,-32028(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 203e3ac:	00800044 	movi	r2,1
}
 203e3b0:	e037883a 	mov	sp,fp
 203e3b4:	dfc00117 	ldw	ra,4(sp)
 203e3b8:	df000017 	ldw	fp,0(sp)
 203e3bc:	dec00204 	addi	sp,sp,8
 203e3c0:	f800283a 	ret

0203e3c4 <find_oldest_arp>:
 * Old entries are removed from the table.
 */

struct arptabent * 
find_oldest_arp(ip_addr dest_ip)
{
 203e3c4:	defff804 	addi	sp,sp,-32
 203e3c8:	dfc00715 	stw	ra,28(sp)
 203e3cc:	df000615 	stw	fp,24(sp)
 203e3d0:	df000604 	addi	fp,sp,24
 203e3d4:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   struct arptabent *exact  = (struct arptabent *)NULL;
 203e3d8:	e03ffb15 	stw	zero,-20(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
 203e3dc:	e03ffc15 	stw	zero,-16(fp)
   struct arptabent *empty  = (struct arptabent *)NULL;
 203e3e0:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 203e3e4:	00808174 	movhi	r2,517
 203e3e8:	1090c904 	addi	r2,r2,17188
 203e3ec:	10800017 	ldw	r2,0(r2)
 203e3f0:	e0bffe15 	stw	r2,-8(fp)

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 203e3f4:	00809934 	movhi	r2,612
 203e3f8:	10b78e04 	addi	r2,r2,-8648
 203e3fc:	e0bffa15 	stw	r2,-24(fp)
 203e400:	00004b06 	br	203e530 <find_oldest_arp+0x16c>
   {
      /* age out old, pending entries */
      if (tp->pending)
 203e404:	e0bffa17 	ldw	r2,-24(fp)
 203e408:	10800417 	ldw	r2,16(r2)
 203e40c:	10001326 	beq	r2,zero,203e45c <find_oldest_arp+0x98>
      {
         /* purge if pending for more than one second */
         if ((lticks - tp->createtime) > TPS)
 203e410:	e0bffa17 	ldw	r2,-24(fp)
 203e414:	10800517 	ldw	r2,20(r2)
 203e418:	e0fffe17 	ldw	r3,-8(fp)
 203e41c:	1885c83a 	sub	r2,r3,r2
 203e420:	1009883a 	mov	r4,r2
 203e424:	20145600 	call	2014560 <__floatunsidf>
 203e428:	100b883a 	mov	r5,r2
 203e42c:	180d883a 	mov	r6,r3
 203e430:	2809883a 	mov	r4,r5
 203e434:	300b883a 	mov	r5,r6
 203e438:	000d883a 	mov	r6,zero
 203e43c:	01d01674 	movhi	r7,16473
 203e440:	20141d80 	call	20141d8 <__gtdf2>
 203e444:	00801f0e 	bge	zero,r2,203e4c4 <find_oldest_arp+0x100>
         {
            arp_free_pending(tp);   /* free pending packets */
 203e448:	e13ffa17 	ldw	r4,-24(fp)
 203e44c:	203de780 	call	203de78 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 203e450:	e0bffa17 	ldw	r2,-24(fp)
 203e454:	10000015 	stw	zero,0(r2)
 203e458:	00001a06 	br	203e4c4 <find_oldest_arp+0x100>
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 203e45c:	e0bffa17 	ldw	r2,-24(fp)
 203e460:	10800017 	ldw	r2,0(r2)
 203e464:	10001726 	beq	r2,zero,203e4c4 <find_oldest_arp+0x100>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 203e468:	e0bffa17 	ldw	r2,-24(fp)
 203e46c:	10800517 	ldw	r2,20(r2)
 203e470:	e0fffe17 	ldw	r3,-8(fp)
 203e474:	1885c83a 	sub	r2,r3,r2
 203e478:	1007883a 	mov	r3,r2
 203e47c:	d0a05417 	ldw	r2,-32432(gp)
         {
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
 203e480:	18801016 	blt	r3,r2,203e4c4 <find_oldest_arp+0x100>
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
               ((int)(lticks - tp->lasttime)   >= TPS))
 203e484:	e0bffa17 	ldw	r2,-24(fp)
 203e488:	10800617 	ldw	r2,24(r2)
 203e48c:	e0fffe17 	ldw	r3,-8(fp)
 203e490:	1885c83a 	sub	r2,r3,r2
 203e494:	1009883a 	mov	r4,r2
 203e498:	20143580 	call	2014358 <__floatsidf>
 203e49c:	100b883a 	mov	r5,r2
 203e4a0:	180d883a 	mov	r6,r3
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
      }
      else if ((tp->t_pro_addr != 0) &&
               ((int)(lticks - tp->createtime) >= arp_ageout) &&
 203e4a4:	2809883a 	mov	r4,r5
 203e4a8:	300b883a 	mov	r5,r6
 203e4ac:	000d883a 	mov	r6,zero
 203e4b0:	01d01674 	movhi	r7,16473
 203e4b4:	201423c0 	call	201423c <__gedf2>
 203e4b8:	10000216 	blt	r2,zero,203e4c4 <find_oldest_arp+0x100>
               ((int)(lticks - tp->lasttime)   >= TPS))
      {
         /* entry has "expired" and has not been reference in 1 sec. */
         tp->t_pro_addr = 0;     /* mark entry as "unused" */
 203e4bc:	e0bffa17 	ldw	r2,-24(fp)
 203e4c0:	10000015 	stw	zero,0(r2)
      }

      if (tp->t_pro_addr == dest_ip)   /* ip addr already has entry */
 203e4c4:	e0bffa17 	ldw	r2,-24(fp)
 203e4c8:	10c00017 	ldw	r3,0(r2)
 203e4cc:	e0bfff17 	ldw	r2,-4(fp)
 203e4d0:	1880031e 	bne	r3,r2,203e4e0 <find_oldest_arp+0x11c>
      {
         exact = tp;
 203e4d4:	e0bffa17 	ldw	r2,-24(fp)
 203e4d8:	e0bffb15 	stw	r2,-20(fp)
 203e4dc:	00001106 	br	203e524 <find_oldest_arp+0x160>
      }
      else if (tp->t_pro_addr != 0)
 203e4e0:	e0bffa17 	ldw	r2,-24(fp)
 203e4e4:	10800017 	ldw	r2,0(r2)
 203e4e8:	10000a26 	beq	r2,zero,203e514 <find_oldest_arp+0x150>
      {
         if (!oldest || (tp->lasttime < oldest->lasttime))
 203e4ec:	e0bffc17 	ldw	r2,-16(fp)
 203e4f0:	10000526 	beq	r2,zero,203e508 <find_oldest_arp+0x144>
 203e4f4:	e0bffa17 	ldw	r2,-24(fp)
 203e4f8:	10c00617 	ldw	r3,24(r2)
 203e4fc:	e0bffc17 	ldw	r2,-16(fp)
 203e500:	10800617 	ldw	r2,24(r2)
 203e504:	1880072e 	bgeu	r3,r2,203e524 <find_oldest_arp+0x160>
            oldest = tp;
 203e508:	e0bffa17 	ldw	r2,-24(fp)
 203e50c:	e0bffc15 	stw	r2,-16(fp)
 203e510:	00000406 	br	203e524 <find_oldest_arp+0x160>
      }
      else if (!empty)
 203e514:	e0bffd17 	ldw	r2,-12(fp)
 203e518:	1000021e 	bne	r2,zero,203e524 <find_oldest_arp+0x160>
         empty = tp;          /* grab first empty slot */
 203e51c:	e0bffa17 	ldw	r2,-24(fp)
 203e520:	e0bffd15 	stw	r2,-12(fp)
   struct arptabent *oldest = (struct arptabent *)NULL;
   struct arptabent *empty  = (struct arptabent *)NULL;
   unsigned long lticks = cticks;

   /* find lru (or free) entry */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 203e524:	e0bffa17 	ldw	r2,-24(fp)
 203e528:	10800804 	addi	r2,r2,32
 203e52c:	e0bffa15 	stw	r2,-24(fp)
 203e530:	e0fffa17 	ldw	r3,-24(fp)
 203e534:	00809934 	movhi	r2,612
 203e538:	10b7ce04 	addi	r2,r2,-8392
 203e53c:	18bfb136 	bltu	r3,r2,203e404 <find_oldest_arp+0x40>
      }
      else if (!empty)
         empty = tp;          /* grab first empty slot */
   }

   return ((exact) ? exact : ((empty) ? empty : oldest));
 203e540:	e0bffb17 	ldw	r2,-20(fp)
 203e544:	1000061e 	bne	r2,zero,203e560 <find_oldest_arp+0x19c>
 203e548:	e0bffd17 	ldw	r2,-12(fp)
 203e54c:	10000226 	beq	r2,zero,203e558 <find_oldest_arp+0x194>
 203e550:	e0bffd17 	ldw	r2,-12(fp)
 203e554:	00000106 	br	203e55c <find_oldest_arp+0x198>
 203e558:	e0bffc17 	ldw	r2,-16(fp)
 203e55c:	00000106 	br	203e564 <find_oldest_arp+0x1a0>
 203e560:	e0bffb17 	ldw	r2,-20(fp)
}
 203e564:	e037883a 	mov	sp,fp
 203e568:	dfc00117 	ldw	ra,4(sp)
 203e56c:	df000017 	ldw	fp,0(sp)
 203e570:	dec00204 	addi	sp,sp,8
 203e574:	f800283a 	ret

0203e578 <make_arp_entry>:
 * active.
 */

struct arptabent *   
make_arp_entry(ip_addr dest_ip, NET net)
{
 203e578:	defffa04 	addi	sp,sp,-24
 203e57c:	dfc00515 	stw	ra,20(sp)
 203e580:	df000415 	stw	fp,16(sp)
 203e584:	df000404 	addi	fp,sp,16
 203e588:	e13ffe15 	stw	r4,-8(fp)
 203e58c:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *oldest;
   unsigned long lticks = cticks;
 203e590:	00808174 	movhi	r2,517
 203e594:	1090c904 	addi	r2,r2,17188
 203e598:	10800017 	ldw	r2,0(r2)
 203e59c:	e0bffc15 	stw	r2,-16(fp)

   /* find usable (or existing) ARP table entry */
   oldest = find_oldest_arp(dest_ip);
 203e5a0:	e13ffe17 	ldw	r4,-8(fp)
 203e5a4:	203e3c40 	call	203e3c4 <find_oldest_arp>
 203e5a8:	e0bffd15 	stw	r2,-12(fp)

   /* If recycling entry, don't leak packets which may be stuck here */
   if (oldest->pending && (oldest->t_pro_addr != dest_ip))
 203e5ac:	e0bffd17 	ldw	r2,-12(fp)
 203e5b0:	10800417 	ldw	r2,16(r2)
 203e5b4:	10000626 	beq	r2,zero,203e5d0 <make_arp_entry+0x58>
 203e5b8:	e0bffd17 	ldw	r2,-12(fp)
 203e5bc:	10c00017 	ldw	r3,0(r2)
 203e5c0:	e0bffe17 	ldw	r2,-8(fp)
 203e5c4:	18800226 	beq	r3,r2,203e5d0 <make_arp_entry+0x58>
   {
      arp_free_pending(oldest);
 203e5c8:	e13ffd17 	ldw	r4,-12(fp)
 203e5cc:	203de780 	call	203de78 <arp_free_pending>
   }

   /* partially fill in arp entry */
   oldest->t_pro_addr = dest_ip;
 203e5d0:	e0bffd17 	ldw	r2,-12(fp)
 203e5d4:	e0fffe17 	ldw	r3,-8(fp)
 203e5d8:	10c00015 	stw	r3,0(r2)
   oldest->net = net;
 203e5dc:	e0bffd17 	ldw	r2,-12(fp)
 203e5e0:	e0ffff17 	ldw	r3,-4(fp)
 203e5e4:	10c00315 	stw	r3,12(r2)
   oldest->flags = 0;
 203e5e8:	e0bffd17 	ldw	r2,-12(fp)
 203e5ec:	1000070d 	sth	zero,28(r2)
   MEMSET(oldest->t_phy_addr, '\0', 6);   /* clear mac address */
 203e5f0:	e0bffd17 	ldw	r2,-12(fp)
 203e5f4:	10800104 	addi	r2,r2,4
 203e5f8:	1009883a 	mov	r4,r2
 203e5fc:	000b883a 	mov	r5,zero
 203e600:	01800184 	movi	r6,6
 203e604:	200682c0 	call	200682c <memset>
   oldest->createtime = oldest->lasttime = lticks;
 203e608:	e0bffd17 	ldw	r2,-12(fp)
 203e60c:	e0fffc17 	ldw	r3,-16(fp)
 203e610:	10c00615 	stw	r3,24(r2)
 203e614:	e0bffd17 	ldw	r2,-12(fp)
 203e618:	10c00617 	ldw	r3,24(r2)
 203e61c:	e0bffd17 	ldw	r2,-12(fp)
 203e620:	10c00515 	stw	r3,20(r2)

   /* start a ARP timer if there isn't one already */
   /* update the timeout value if there is a timer */
   /* time is specified in milliseconds */
   if (arp_timer == 0)
 203e624:	d0a0b517 	ldw	r2,-32044(gp)
 203e628:	1000071e 	bne	r2,zero,203e648 <make_arp_entry+0xd0>
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
 203e62c:	01008134 	movhi	r4,516
 203e630:	213b5404 	addi	r4,r4,-4784
 203e634:	0149c404 	movi	r5,10000
 203e638:	000d883a 	mov	r6,zero
 203e63c:	203d9040 	call	203d904 <in_timerset>
 203e640:	d0a0b515 	stw	r2,-32044(gp)
 203e644:	00000606 	br	203e660 <make_arp_entry+0xe8>
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 203e648:	d0a0b517 	ldw	r2,-32044(gp)
              ((struct intimer *)arp_timer)->interval + lticks;
 203e64c:	d0e0b517 	ldw	r3,-32044(gp)
 203e650:	19000217 	ldw	r4,8(r3)
 203e654:	e0fffc17 	ldw	r3,-16(fp)
 203e658:	20c7883a 	add	r3,r4,r3
   {
      arp_timer = in_timerset(&cb_arpent_tmo, ARPENT_TMO * 1000, 0);
   }
   else
   {
      ((struct intimer *)arp_timer)->tmo =
 203e65c:	10c00315 	stw	r3,12(r2)
              ((struct intimer *)arp_timer)->interval + lticks;
   }

   return oldest;
 203e660:	e0bffd17 	ldw	r2,-12(fp)
}
 203e664:	e037883a 	mov	sp,fp
 203e668:	dfc00117 	ldw	ra,4(sp)
 203e66c:	df000017 	ldw	fp,0(sp)
 203e670:	dec00204 	addi	sp,sp,8
 203e674:	f800283a 	ret

0203e678 <arpReply>:
 * must be freed (or reused) herein. 
 */

void
arpReply(PACKET pkt)
{
 203e678:	defff704 	addi	sp,sp,-36
 203e67c:	dfc00815 	stw	ra,32(sp)
 203e680:	df000715 	stw	fp,28(sp)
 203e684:	df000704 	addi	fp,sp,28
 203e688:	e13fff15 	stw	r4,-4(fp)
   struct arp_hdr *in;
   struct arp_hdr *out;
   char *ethout;
   char *ethin;

   LOCK_NET_RESOURCE(FREEQ_RESID);
 203e68c:	01000084 	movi	r4,2
 203e690:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   outpkt = pk_alloc(arpsize);
 203e694:	01000c04 	movi	r4,48
 203e698:	2027cec0 	call	2027cec <pk_alloc>
 203e69c:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203e6a0:	01000084 	movi	r4,2
 203e6a4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (!outpkt)
 203e6a8:	e0bff917 	ldw	r2,-28(fp)
 203e6ac:	1000021e 	bne	r2,zero,203e6b8 <arpReply+0x40>
   {
      dtrap();
 203e6b0:	20285c80 	call	20285c8 <dtrap>
      return;
 203e6b4:	00009c06 	br	203e928 <arpReply+0x2b0>
   }

   outpkt->net = pkt->net;    /* send back out the iface it came from */
 203e6b8:	e0bfff17 	ldw	r2,-4(fp)
 203e6bc:	10c00617 	ldw	r3,24(r2)
 203e6c0:	e0bff917 	ldw	r2,-28(fp)
 203e6c4:	10c00615 	stw	r3,24(r2)

   ethin = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 203e6c8:	e0bfff17 	ldw	r2,-4(fp)
 203e6cc:	10800317 	ldw	r2,12(r2)
 203e6d0:	10bffc84 	addi	r2,r2,-14
 203e6d4:	e0bffa15 	stw	r2,-24(fp)
   ethout = outpkt->nb_buff + ETHHDR_BIAS;
 203e6d8:	e0bff917 	ldw	r2,-28(fp)
 203e6dc:	10800117 	ldw	r2,4(r2)
 203e6e0:	10800084 	addi	r2,r2,2
 203e6e4:	e0bffb15 	stw	r2,-20(fp)
      snap->type = ET_ARP;
   }
   else
#endif   /* IEEE_802_3 */
   {
      ET_TYPE_SET(ethout, ntohs(ET_ARP));   /* 0x0806 - ARP type on ethernet */
 203e6e8:	e0bffb17 	ldw	r2,-20(fp)
 203e6ec:	10800304 	addi	r2,r2,12
 203e6f0:	00c00204 	movi	r3,8
 203e6f4:	10c00005 	stb	r3,0(r2)
 203e6f8:	e0bffb17 	ldw	r2,-20(fp)
 203e6fc:	10800344 	addi	r2,r2,13
 203e700:	00c00184 	movi	r3,6
 203e704:	10c00005 	stb	r3,0(r2)
      in = (struct arp_hdr *)(pkt->nb_prot);
 203e708:	e0bfff17 	ldw	r2,-4(fp)
 203e70c:	10800317 	ldw	r2,12(r2)
 203e710:	e0bffc15 	stw	r2,-16(fp)
      out = (struct arp_hdr *)(outpkt->nb_buff + ETHHDR_SIZE);
 203e714:	e0bff917 	ldw	r2,-28(fp)
 203e718:	10800117 	ldw	r2,4(r2)
 203e71c:	10800404 	addi	r2,r2,16
 203e720:	e0bffd15 	stw	r2,-12(fp)
      outpkt->nb_plen = arpsize;
 203e724:	e0bff917 	ldw	r2,-28(fp)
 203e728:	00c00c04 	movi	r3,48
 203e72c:	10c00415 	stw	r3,16(r2)

   /* prepare outgoing arp packet */
#ifdef IEEE_802_3
   out->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   out->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 203e730:	e0bffd17 	ldw	r2,-12(fp)
 203e734:	00c04004 	movi	r3,256
 203e738:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   out->ar_pro = ARPIP;
 203e73c:	e0bffd17 	ldw	r2,-12(fp)
 203e740:	00c00204 	movi	r3,8
 203e744:	10c0008d 	sth	r3,2(r2)
   out->ar_hln = 6;
 203e748:	e0bffd17 	ldw	r2,-12(fp)
 203e74c:	00c00184 	movi	r3,6
 203e750:	10c00105 	stb	r3,4(r2)
   out->ar_pln = 4;
 203e754:	e0bffd17 	ldw	r2,-12(fp)
 203e758:	00c00104 	movi	r3,4
 203e75c:	10c00145 	stb	r3,5(r2)
   out->ar_op = ARREP;
 203e760:	e0bffd17 	ldw	r2,-12(fp)
 203e764:	00c08004 	movi	r3,512
 203e768:	10c0018d 	sth	r3,6(r2)
   out->ar_tpa = in->ar_spa;     /* swap IP addresses */
 203e76c:	e0bffc17 	ldw	r2,-16(fp)
 203e770:	10c00417 	ldw	r3,16(r2)
 203e774:	e0bffd17 	ldw	r2,-12(fp)
 203e778:	10c00715 	stw	r3,28(r2)
   out->ar_spa = in->ar_tpa;
 203e77c:	e0bffc17 	ldw	r2,-16(fp)
 203e780:	10c00717 	ldw	r3,28(r2)
 203e784:	e0bffd17 	ldw	r2,-12(fp)
 203e788:	10c00415 	stw	r3,16(r2)
   MEMMOVE(out->ar_tha, in->ar_sha, 6);    /* move his MAC address */
 203e78c:	e0bffd17 	ldw	r2,-12(fp)
 203e790:	10c00504 	addi	r3,r2,20
 203e794:	e0bffc17 	ldw	r2,-16(fp)
 203e798:	10800204 	addi	r2,r2,8
 203e79c:	1809883a 	mov	r4,r3
 203e7a0:	100b883a 	mov	r5,r2
 203e7a4:	01800184 	movi	r6,6
 203e7a8:	20067040 	call	2006704 <memmove>
   MEMMOVE(out->ar_sha, outpkt->net->n_mib->ifPhysAddress, 6);  /* fill in our mac address */
 203e7ac:	e0bffd17 	ldw	r2,-12(fp)
 203e7b0:	10c00204 	addi	r3,r2,8
 203e7b4:	e0bff917 	ldw	r2,-28(fp)
 203e7b8:	10800617 	ldw	r2,24(r2)
 203e7bc:	10802717 	ldw	r2,156(r2)
 203e7c0:	10800517 	ldw	r2,20(r2)
 203e7c4:	1809883a 	mov	r4,r3
 203e7c8:	100b883a 	mov	r5,r2
 203e7cc:	01800184 	movi	r6,6
 203e7d0:	20067040 	call	2006704 <memmove>

   /* prepend ethernet unicast header to arp reply */
   MEMMOVE(ethout + ET_DSTOFF, ethin + ET_SRCOFF, 6);
 203e7d4:	e0bffa17 	ldw	r2,-24(fp)
 203e7d8:	10800184 	addi	r2,r2,6
 203e7dc:	e13ffb17 	ldw	r4,-20(fp)
 203e7e0:	100b883a 	mov	r5,r2
 203e7e4:	01800184 	movi	r6,6
 203e7e8:	20067040 	call	2006704 <memmove>
   MEMMOVE(ethout + ET_SRCOFF, outpkt->net->n_mib->ifPhysAddress, 6);
 203e7ec:	e0bffb17 	ldw	r2,-20(fp)
 203e7f0:	10c00184 	addi	r3,r2,6
 203e7f4:	e0bff917 	ldw	r2,-28(fp)
 203e7f8:	10800617 	ldw	r2,24(r2)
 203e7fc:	10802717 	ldw	r2,156(r2)
 203e800:	10800517 	ldw	r2,20(r2)
 203e804:	1809883a 	mov	r4,r3
 203e808:	100b883a 	mov	r5,r2
 203e80c:	01800184 	movi	r6,6
 203e810:	20067040 	call	2006704 <memmove>

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)out;
 203e814:	e0bffd17 	ldw	r2,-12(fp)
 203e818:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arwp->data[AR_SHA], out->ar_sha, 6);
 203e81c:	e0bffe17 	ldw	r2,-8(fp)
 203e820:	10c00204 	addi	r3,r2,8
 203e824:	e0bffd17 	ldw	r2,-12(fp)
 203e828:	10800204 	addi	r2,r2,8
 203e82c:	1809883a 	mov	r4,r3
 203e830:	100b883a 	mov	r5,r2
 203e834:	01800184 	movi	r6,6
 203e838:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &out->ar_spa, 4);
 203e83c:	e0bffe17 	ldw	r2,-8(fp)
 203e840:	10c00384 	addi	r3,r2,14
 203e844:	e0bffd17 	ldw	r2,-12(fp)
 203e848:	10800404 	addi	r2,r2,16
 203e84c:	1809883a 	mov	r4,r3
 203e850:	100b883a 	mov	r5,r2
 203e854:	01800104 	movi	r6,4
 203e858:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_THA], out->ar_tha, 6);
 203e85c:	e0bffe17 	ldw	r2,-8(fp)
 203e860:	10c00484 	addi	r3,r2,18
 203e864:	e0bffd17 	ldw	r2,-12(fp)
 203e868:	10800504 	addi	r2,r2,20
 203e86c:	1809883a 	mov	r4,r3
 203e870:	100b883a 	mov	r5,r2
 203e874:	01800184 	movi	r6,6
 203e878:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_TPA], &out->ar_tpa, 4);
 203e87c:	e0bffe17 	ldw	r2,-8(fp)
 203e880:	10c00604 	addi	r3,r2,24
 203e884:	e0bffd17 	ldw	r2,-12(fp)
 203e888:	10800704 	addi	r2,r2,28
 203e88c:	1809883a 	mov	r4,r3
 203e890:	100b883a 	mov	r5,r2
 203e894:	01800104 	movi	r6,4
 203e898:	20067040 	call	2006704 <memmove>
   }
#endif   /* NO_CC_PACKING */

   /* if a packet oriented send exists, use it: */
   if (outpkt->net->pkt_send)
 203e89c:	e0bff917 	ldw	r2,-28(fp)
 203e8a0:	10800617 	ldw	r2,24(r2)
 203e8a4:	10800417 	ldw	r2,16(r2)
 203e8a8:	10000a26 	beq	r2,zero,203e8d4 <arpReply+0x25c>
   {
      outpkt->nb_prot = outpkt->nb_buff;
 203e8ac:	e0bff917 	ldw	r2,-28(fp)
 203e8b0:	10c00117 	ldw	r3,4(r2)
 203e8b4:	e0bff917 	ldw	r2,-28(fp)
 203e8b8:	10c00315 	stw	r3,12(r2)
      outpkt->net->pkt_send(outpkt);
 203e8bc:	e0bff917 	ldw	r2,-28(fp)
 203e8c0:	10800617 	ldw	r2,24(r2)
 203e8c4:	10800417 	ldw	r2,16(r2)
 203e8c8:	e13ff917 	ldw	r4,-28(fp)
 203e8cc:	103ee83a 	callr	r2
 203e8d0:	00001206 	br	203e91c <arpReply+0x2a4>
   }
   else
   {
      outpkt->net->raw_send(pkt->net, outpkt->nb_buff, outpkt->nb_plen);
 203e8d4:	e0bff917 	ldw	r2,-28(fp)
 203e8d8:	10800617 	ldw	r2,24(r2)
 203e8dc:	11c00317 	ldw	r7,12(r2)
 203e8e0:	e0bfff17 	ldw	r2,-4(fp)
 203e8e4:	11000617 	ldw	r4,24(r2)
 203e8e8:	e0bff917 	ldw	r2,-28(fp)
 203e8ec:	10c00117 	ldw	r3,4(r2)
 203e8f0:	e0bff917 	ldw	r2,-28(fp)
 203e8f4:	10800417 	ldw	r2,16(r2)
 203e8f8:	180b883a 	mov	r5,r3
 203e8fc:	100d883a 	mov	r6,r2
 203e900:	383ee83a 	callr	r7
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203e904:	01000084 	movi	r4,2
 203e908:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(outpkt);
 203e90c:	e13ff917 	ldw	r4,-28(fp)
 203e910:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203e914:	01000084 	movi	r4,2
 203e918:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   }
   /* input 'pkt' will be freed by caller */
   arpRepsOut++;
 203e91c:	d0a0bb17 	ldw	r2,-32020(gp)
 203e920:	10800044 	addi	r2,r2,1
 203e924:	d0a0bb15 	stw	r2,-32020(gp)
}
 203e928:	e037883a 	mov	sp,fp
 203e92c:	dfc00117 	ldw	ra,4(sp)
 203e930:	df000017 	ldw	fp,0(sp)
 203e934:	dec00204 	addi	sp,sp,8
 203e938:	f800283a 	ret

0203e93c <arprcv>:
 *                            else a negative error code. 
 */

int
arprcv(PACKET pkt)
{
 203e93c:	defff904 	addi	sp,sp,-28
 203e940:	dfc00615 	stw	ra,24(sp)
 203e944:	df000515 	stw	fp,20(sp)
 203e948:	df000504 	addi	fp,sp,20
 203e94c:	e13fff15 	stw	r4,-4(fp)
   char *eth;
#ifdef IEEE_802_3
   int      ieee = FALSE;     /* TRUE if received packet is 802.3 */
#endif

   eth = pkt->nb_prot - (ETHHDR_SIZE - ETHHDR_BIAS);
 203e950:	e0bfff17 	ldw	r2,-4(fp)
 203e954:	10800317 	ldw	r2,12(r2)
 203e958:	10bffc84 	addi	r2,r2,-14
 203e95c:	e0bffc15 	stw	r2,-16(fp)
   arphdr = (struct arp_hdr *)(pkt->nb_prot);
 203e960:	e0bfff17 	ldw	r2,-4(fp)
 203e964:	10800317 	ldw	r2,12(r2)
 203e968:	e0bffd15 	stw	r2,-12(fp)
#endif   /* IEEE_802_3_ONLY */
#endif   /* IEEE_802_3 */

#ifdef NO_CC_PACKING    /* force ARP fields to local CPU valid boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 203e96c:	e0bffd17 	ldw	r2,-12(fp)
 203e970:	e0bffe15 	stw	r2,-8(fp)
      MEMMOVE(&arphdr->ar_tpa, &arwp->data[AR_TPA], 4);
 203e974:	e0bffd17 	ldw	r2,-12(fp)
 203e978:	10c00704 	addi	r3,r2,28
 203e97c:	e0bffe17 	ldw	r2,-8(fp)
 203e980:	10800604 	addi	r2,r2,24
 203e984:	1809883a 	mov	r4,r3
 203e988:	100b883a 	mov	r5,r2
 203e98c:	01800104 	movi	r6,4
 203e990:	20067040 	call	2006704 <memmove>
      MEMMOVE(arphdr->ar_tha, &arwp->data[AR_THA], 6);
 203e994:	e0bffd17 	ldw	r2,-12(fp)
 203e998:	10c00504 	addi	r3,r2,20
 203e99c:	e0bffe17 	ldw	r2,-8(fp)
 203e9a0:	10800484 	addi	r2,r2,18
 203e9a4:	1809883a 	mov	r4,r3
 203e9a8:	100b883a 	mov	r5,r2
 203e9ac:	01800184 	movi	r6,6
 203e9b0:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arphdr->ar_spa, &arwp->data[AR_SPA], 4);
 203e9b4:	e0bffd17 	ldw	r2,-12(fp)
 203e9b8:	10c00404 	addi	r3,r2,16
 203e9bc:	e0bffe17 	ldw	r2,-8(fp)
 203e9c0:	10800384 	addi	r2,r2,14
 203e9c4:	1809883a 	mov	r4,r3
 203e9c8:	100b883a 	mov	r5,r2
 203e9cc:	01800104 	movi	r6,4
 203e9d0:	20067040 	call	2006704 <memmove>
      MEMMOVE(arphdr->ar_sha, &arwp->data[AR_SHA], 6);
 203e9d4:	e0bffd17 	ldw	r2,-12(fp)
 203e9d8:	10c00204 	addi	r3,r2,8
 203e9dc:	e0bffe17 	ldw	r2,-8(fp)
 203e9e0:	10800204 	addi	r2,r2,8
 203e9e4:	1809883a 	mov	r4,r3
 203e9e8:	100b883a 	mov	r5,r2
 203e9ec:	01800184 	movi	r6,6
 203e9f0:	20067040 	call	2006704 <memmove>
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 203e9f4:	e0bffd17 	ldw	r2,-12(fp)
 203e9f8:	10c00717 	ldw	r3,28(r2)
 203e9fc:	e0bfff17 	ldw	r2,-4(fp)
 203ea00:	10800617 	ldw	r2,24(r2)
 203ea04:	10800a17 	ldw	r2,40(r2)
 203ea08:	18801c26 	beq	r3,r2,203ea7c <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
 203ea0c:	e0bffd17 	ldw	r2,-12(fp)
 203ea10:	10800717 	ldw	r2,28(r2)
 203ea14:	1006d63a 	srli	r3,r2,24
 203ea18:	e0bffd17 	ldw	r2,-12(fp)
 203ea1c:	10800717 	ldw	r2,28(r2)
 203ea20:	1004d23a 	srli	r2,r2,8
 203ea24:	10bfc00c 	andi	r2,r2,65280
 203ea28:	1886b03a 	or	r3,r3,r2
 203ea2c:	e0bffd17 	ldw	r2,-12(fp)
 203ea30:	10800717 	ldw	r2,28(r2)
 203ea34:	10bfc00c 	andi	r2,r2,65280
 203ea38:	1004923a 	slli	r2,r2,8
 203ea3c:	1886b03a 	or	r3,r3,r2
 203ea40:	e0bffd17 	ldw	r2,-12(fp)
 203ea44:	10800717 	ldw	r2,28(r2)
 203ea48:	1004963a 	slli	r2,r2,24
 203ea4c:	1884b03a 	or	r2,r3,r2
 203ea50:	10fc002c 	andhi	r3,r2,61440
   }
#endif

   /* check ARP's target IP against our net's: */
#ifdef IP_MULTICAST
   if ((arphdr->ar_tpa != pkt->net->n_ipaddr) &&   /* if it's not for me.... */
 203ea54:	00b80034 	movhi	r2,57344
 203ea58:	18800826 	beq	r3,r2,203ea7c <arprcv+0x140>
     (!IN_MULTICAST(ntohl(arphdr->ar_tpa))))
#else
   if (arphdr->ar_tpa != pkt->net->n_ipaddr)
#endif /* IP_MULTICAST */
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203ea5c:	01000084 	movi	r4,2
 203ea60:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);     /* not for us, dump & ret (proxy here later?) */
 203ea64:	e13fff17 	ldw	r4,-4(fp)
 203ea68:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203ea6c:	01000084 	movi	r4,2
 203ea70:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return (ENP_NOT_MINE);
 203ea74:	00800084 	movi	r2,2
 203ea78:	00004606 	br	203eb94 <arprcv+0x258>
   }

   if (arphdr->ar_op == ARREQ)   /* is it an arp request? */
 203ea7c:	e0bffd17 	ldw	r2,-12(fp)
 203ea80:	1080018b 	ldhu	r2,6(r2)
 203ea84:	10bfffcc 	andi	r2,r2,65535
 203ea88:	10804018 	cmpnei	r2,r2,256
 203ea8c:	10000d1e 	bne	r2,zero,203eac4 <arprcv+0x188>
   {
      arpReqsIn++;   /* count these */
 203ea90:	d0a0b817 	ldw	r2,-32032(gp)
 203ea94:	10800044 	addi	r2,r2,1
 203ea98:	d0a0b815 	stw	r2,-32032(gp)
      arpReply(pkt); /* send arp reply */
 203ea9c:	e13fff17 	ldw	r4,-4(fp)
 203eaa0:	203e6780 	call	203e678 <arpReply>
      /* make partial ARP table entry */
      make_arp_entry(arphdr->ar_spa, pkt->net);
 203eaa4:	e0bffd17 	ldw	r2,-12(fp)
 203eaa8:	10c00417 	ldw	r3,16(r2)
 203eaac:	e0bfff17 	ldw	r2,-4(fp)
 203eab0:	10800617 	ldw	r2,24(r2)
 203eab4:	1809883a 	mov	r4,r3
 203eab8:	100b883a 	mov	r5,r2
 203eabc:	203e5780 	call	203e578 <make_arp_entry>
 203eac0:	00000306 	br	203ead0 <arprcv+0x194>
      /* fall thru to arp reply logic to finish our table entry */
   }
   else     /* ARP reply, count and fall thru to logic to update table */
   {
      arpRepsIn++;
 203eac4:	d0a0ba17 	ldw	r2,-32024(gp)
 203eac8:	10800044 	addi	r2,r2,1
 203eacc:	d0a0ba15 	stw	r2,-32024(gp)
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 203ead0:	00809934 	movhi	r2,612
 203ead4:	10b78e04 	addi	r2,r2,-8648
 203ead8:	e0bffb15 	stw	r2,-20(fp)
 203eadc:	00002206 	br	203eb68 <arprcv+0x22c>
   {
      if (tp->t_pro_addr == arphdr->ar_spa)     /* we found IP address, update entry */
 203eae0:	e0bffb17 	ldw	r2,-20(fp)
 203eae4:	10c00017 	ldw	r3,0(r2)
 203eae8:	e0bffd17 	ldw	r2,-12(fp)
 203eaec:	10800417 	ldw	r2,16(r2)
 203eaf0:	18801a1e 	bne	r3,r2,203eb5c <arprcv+0x220>
            tp->flags |= ET_SNAP;
         else
            tp->flags |= ET_ETH2;      /* else it's ethernet II */
#endif   /* IEEE_802_3 */

         MEMMOVE(tp->t_phy_addr, arphdr->ar_sha, 6);   /* update MAC adddress */
 203eaf4:	e0bffb17 	ldw	r2,-20(fp)
 203eaf8:	10c00104 	addi	r3,r2,4
 203eafc:	e0bffd17 	ldw	r2,-12(fp)
 203eb00:	10800204 	addi	r2,r2,8
 203eb04:	1809883a 	mov	r4,r3
 203eb08:	100b883a 	mov	r5,r2
 203eb0c:	01800184 	movi	r6,6
 203eb10:	20067040 	call	2006704 <memmove>
         tp->lasttime = cticks;
 203eb14:	00808174 	movhi	r2,517
 203eb18:	1090c904 	addi	r2,r2,17188
 203eb1c:	10c00017 	ldw	r3,0(r2)
 203eb20:	e0bffb17 	ldw	r2,-20(fp)
 203eb24:	10c00615 	stw	r3,24(r2)
         if (tp->pending)     /* packet waiting for this IP entry? */
 203eb28:	e0bffb17 	ldw	r2,-20(fp)
 203eb2c:	10800417 	ldw	r2,16(r2)
 203eb30:	10000226 	beq	r2,zero,203eb3c <arprcv+0x200>
         {
            arp_send_pending(tp);
 203eb34:	e13ffb17 	ldw	r4,-20(fp)
 203eb38:	203defc0 	call	203defc <arp_send_pending>
         }
         LOCK_NET_RESOURCE(FREEQ_RESID);
 203eb3c:	01000084 	movi	r4,2
 203eb40:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(pkt);
 203eb44:	e13fff17 	ldw	r4,-4(fp)
 203eb48:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203eb4c:	01000084 	movi	r4,2
 203eb50:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

         return (0);
 203eb54:	0005883a 	mov	r2,zero
 203eb58:	00000e06 	br	203eb94 <arprcv+0x258>
      arpRepsIn++;
   }

   /* scan table for matching entry */
   /* check this for default gateway situations later, JB */
   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 203eb5c:	e0bffb17 	ldw	r2,-20(fp)
 203eb60:	10800804 	addi	r2,r2,32
 203eb64:	e0bffb15 	stw	r2,-20(fp)
 203eb68:	e0fffb17 	ldw	r3,-20(fp)
 203eb6c:	00809934 	movhi	r2,612
 203eb70:	10b7ce04 	addi	r2,r2,-8392
 203eb74:	18bfda36 	bltu	r3,r2,203eae0 <arprcv+0x1a4>

#ifdef IEEE_802_3_ONLY
drop:
#endif /* IEEE_802_3_ONLY */
   /* fall to here if packet is not in table */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 203eb78:	01000084 	movi	r4,2
 203eb7c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(pkt);
 203eb80:	e13fff17 	ldw	r4,-4(fp)
 203eb84:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203eb88:	01000084 	movi	r4,2
 203eb8c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   return ENP_NOT_MINE;
 203eb90:	00800084 	movi	r2,2
}
 203eb94:	e037883a 	mov	sp,fp
 203eb98:	dfc00117 	ldw	ra,4(sp)
 203eb9c:	df000017 	ldw	fp,0(sp)
 203eba0:	dec00204 	addi	sp,sp,8
 203eba4:	f800283a 	ret

0203eba8 <send_via_arp>:
 * change the PC's IP address. 
 */

int
send_via_arp(PACKET pkt, ip_addr dest_ip)
{
 203eba8:	defff804 	addi	sp,sp,-32
 203ebac:	dfc00715 	stw	ra,28(sp)
 203ebb0:	df000615 	stw	fp,24(sp)
 203ebb4:	df000604 	addi	fp,sp,24
 203ebb8:	e13ffe15 	stw	r4,-8(fp)
 203ebbc:	e17fff15 	stw	r5,-4(fp)
   struct arptabent *tp;
   unsigned long lticks = cticks;
 203ebc0:	00808174 	movhi	r2,517
 203ebc4:	1090c904 	addi	r2,r2,17188
 203ebc8:	10800017 	ldw	r2,0(r2)
 203ebcc:	e0bffd15 	stw	r2,-12(fp)
   int err;

   /* don't allow zero dest */
   if (dest_ip == 0)
 203ebd0:	e0bfff17 	ldw	r2,-4(fp)
 203ebd4:	1000081e 	bne	r2,zero,203ebf8 <send_via_arp+0x50>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203ebd8:	01000084 	movi	r4,2
 203ebdc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(pkt);
 203ebe0:	e13ffe17 	ldw	r4,-8(fp)
 203ebe4:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203ebe8:	01000084 	movi	r4,2
 203ebec:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return SEND_DROPPED; 
 203ebf0:	00bffa84 	movi	r2,-22
 203ebf4:	00005106 	br	203ed3c <send_via_arp+0x194>
   }

   /* Force refresh of cache once a second */
   if ((lticks - cachetime) > TPS)
 203ebf8:	d0a0b717 	ldw	r2,-32036(gp)
 203ebfc:	e0fffd17 	ldw	r3,-12(fp)
 203ec00:	1885c83a 	sub	r2,r3,r2
 203ec04:	1009883a 	mov	r4,r2
 203ec08:	20145600 	call	2014560 <__floatunsidf>
 203ec0c:	100b883a 	mov	r5,r2
 203ec10:	180d883a 	mov	r6,r3
 203ec14:	2809883a 	mov	r4,r5
 203ec18:	300b883a 	mov	r5,r6
 203ec1c:	000d883a 	mov	r6,zero
 203ec20:	01d01674 	movhi	r7,16473
 203ec24:	20141d80 	call	20141d8 <__gtdf2>
 203ec28:	0080010e 	bge	zero,r2,203ec30 <send_via_arp+0x88>
      arpcache = (struct arptabent *)NULL;
 203ec2c:	d020b615 	stw	zero,-32040(gp)

   /* look at the last ARP entry used. Good chance it's ours: */
   if (arpcache && (arpcache->t_pro_addr == dest_ip))
 203ec30:	d0a0b617 	ldw	r2,-32040(gp)
 203ec34:	10000726 	beq	r2,zero,203ec54 <send_via_arp+0xac>
 203ec38:	d0a0b617 	ldw	r2,-32040(gp)
 203ec3c:	10c00017 	ldw	r3,0(r2)
 203ec40:	e0bfff17 	ldw	r2,-4(fp)
 203ec44:	1880031e 	bne	r3,r2,203ec54 <send_via_arp+0xac>
      tp = arpcache;
 203ec48:	d0a0b617 	ldw	r2,-32040(gp)
 203ec4c:	e0bffa15 	stw	r2,-24(fp)
 203ec50:	00000306 	br	203ec60 <send_via_arp+0xb8>
   else
   {
      /* scan arp table for an existing entry */
      tp = find_oldest_arp(dest_ip);
 203ec54:	e13fff17 	ldw	r4,-4(fp)
 203ec58:	203e3c40 	call	203e3c4 <find_oldest_arp>
 203ec5c:	e0bffa15 	stw	r2,-24(fp)
   }

   if (tp->t_pro_addr == dest_ip)   /* we found our entry */
 203ec60:	e0bffa17 	ldw	r2,-24(fp)
 203ec64:	10c00017 	ldw	r3,0(r2)
 203ec68:	e0bfff17 	ldw	r2,-4(fp)
 203ec6c:	18802e1e 	bne	r3,r2,203ed28 <send_via_arp+0x180>
   {
      if (tp->pending)  /* arp already pending for this IP? */
 203ec70:	e0bffa17 	ldw	r2,-24(fp)
 203ec74:	10800417 	ldw	r2,16(r2)
 203ec78:	10002226 	beq	r2,zero,203ed04 <send_via_arp+0x15c>
      {
         if (lilfreeq.q_len < 2)
 203ec7c:	00809934 	movhi	r2,612
 203ec80:	10b5e704 	addi	r2,r2,-10340
 203ec84:	10800217 	ldw	r2,8(r2)
 203ec88:	10800088 	cmpgei	r2,r2,2
 203ec8c:	1000091e 	bne	r2,zero,203ecb4 <send_via_arp+0x10c>
         {
            /* system is depleted of resources - free the
             * pkt instead of queueing it - so that we are in a
             * position to receive an arp reply 
             */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 203ec90:	01000084 	movi	r4,2
 203ec94:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(pkt);  /* sorry, we have to dump this one.. */
 203ec98:	e13ffe17 	ldw	r4,-8(fp)
 203ec9c:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203eca0:	01000084 	movi	r4,2
 203eca4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            err = SEND_DROPPED;    /* pkts already waiting for this IP entry */
 203eca8:	00bffa84 	movi	r2,-22
 203ecac:	e0bffb15 	stw	r2,-20(fp)
 203ecb0:	00002106 	br	203ed38 <send_via_arp+0x190>
         }
         else
         {
            PACKET tmppkt=tp->pending;
 203ecb4:	e0bffa17 	ldw	r2,-24(fp)
 203ecb8:	10800417 	ldw	r2,16(r2)
 203ecbc:	e0bffc15 	stw	r2,-16(fp)

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 203ecc0:	00000306 	br	203ecd0 <send_via_arp+0x128>
               tmppkt = tmppkt->next;
 203ecc4:	e0bffc17 	ldw	r2,-16(fp)
 203ecc8:	10800017 	ldw	r2,0(r2)
 203eccc:	e0bffc15 	stw	r2,-16(fp)
         else
         {
            PACKET tmppkt=tp->pending;

            /* queue the packet in pending list */
            while (tmppkt->next)     /* traverse to the last packet */
 203ecd0:	e0bffc17 	ldw	r2,-16(fp)
 203ecd4:	10800017 	ldw	r2,0(r2)
 203ecd8:	103ffa1e 	bne	r2,zero,203ecc4 <send_via_arp+0x11c>
               tmppkt = tmppkt->next;
            tmppkt->next = pkt;      /* add new pkt to end of list */
 203ecdc:	e0bffc17 	ldw	r2,-16(fp)
 203ece0:	e0fffe17 	ldw	r3,-8(fp)
 203ece4:	10c00015 	stw	r3,0(r2)
            if (pkt->next)
 203ece8:	e0bffe17 	ldw	r2,-8(fp)
 203ecec:	10800017 	ldw	r2,0(r2)
 203ecf0:	10000126 	beq	r2,zero,203ecf8 <send_via_arp+0x150>
            {
               dtrap();              /* chain of pkts to be sent ??? */
 203ecf4:	20285c80 	call	20285c8 <dtrap>
            }
            err = ENP_SEND_PENDING; /* packet queued pending ARP reply */
 203ecf8:	00800044 	movi	r2,1
 203ecfc:	e0bffb15 	stw	r2,-20(fp)
 203ed00:	00000d06 	br	203ed38 <send_via_arp+0x190>
         }
      }
      else  /* just send it */
      {
         arpcache = tp;       /* cache this entry */
 203ed04:	e0bffa17 	ldw	r2,-24(fp)
 203ed08:	d0a0b615 	stw	r2,-32040(gp)
         cachetime = lticks;  /* mark time we cached */
 203ed0c:	e0bffd17 	ldw	r2,-12(fp)
 203ed10:	d0a0b715 	stw	r2,-32036(gp)
         err = et_send(pkt, tp);
 203ed14:	e13ffe17 	ldw	r4,-8(fp)
 203ed18:	e17ffa17 	ldw	r5,-24(fp)
 203ed1c:	203dcec0 	call	203dcec <et_send>
 203ed20:	e0bffb15 	stw	r2,-20(fp)
 203ed24:	00000406 	br	203ed38 <send_via_arp+0x190>
      }
   }
   else
      /* start the ARP process for this IP address */
      err = send_arp(pkt, dest_ip);
 203ed28:	e13ffe17 	ldw	r4,-8(fp)
 203ed2c:	e17fff17 	ldw	r5,-4(fp)
 203ed30:	203df6c0 	call	203df6c <send_arp>
 203ed34:	e0bffb15 	stw	r2,-20(fp)

   return (err);
 203ed38:	e0bffb17 	ldw	r2,-20(fp)
}
 203ed3c:	e037883a 	mov	sp,fp
 203ed40:	dfc00117 	ldw	ra,4(sp)
 203ed44:	df000017 	ldw	fp,0(sp)
 203ed48:	dec00204 	addi	sp,sp,8
 203ed4c:	f800283a 	ret

0203ed50 <cb_arpent_tmo>:
 *
 * If there are no more unresolved entries, cancel the timer.
 */
void
cb_arpent_tmo(long arg)
{
 203ed50:	defffa04 	addi	sp,sp,-24
 203ed54:	dfc00515 	stw	ra,20(sp)
 203ed58:	df000415 	stw	fp,16(sp)
 203ed5c:	df000404 	addi	fp,sp,16
 203ed60:	e13fff15 	stw	r4,-4(fp)
   struct arptabent *tp;
   int arp_count = 0;
 203ed64:	e03ffd15 	stw	zero,-12(fp)
   unsigned long lticks = cticks;
 203ed68:	00808174 	movhi	r2,517
 203ed6c:	1090c904 	addi	r2,r2,17188
 203ed70:	10800017 	ldw	r2,0(r2)
 203ed74:	e0bffe15 	stw	r2,-8(fp)

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 203ed78:	00809934 	movhi	r2,612
 203ed7c:	10b78e04 	addi	r2,r2,-8648
 203ed80:	e0bffc15 	stw	r2,-16(fp)
 203ed84:	00003706 	br	203ee64 <cb_arpent_tmo+0x114>
   {
      if (tp->t_pro_addr != 0)
 203ed88:	e0bffc17 	ldw	r2,-16(fp)
 203ed8c:	10800017 	ldw	r2,0(r2)
 203ed90:	10003126 	beq	r2,zero,203ee58 <cb_arpent_tmo+0x108>
      {
         /* age out old, pending entries */
         if (tp->pending && ((lticks - tp->createtime) > TPS))
 203ed94:	e0bffc17 	ldw	r2,-16(fp)
 203ed98:	10800417 	ldw	r2,16(r2)
 203ed9c:	10001326 	beq	r2,zero,203edec <cb_arpent_tmo+0x9c>
 203eda0:	e0bffc17 	ldw	r2,-16(fp)
 203eda4:	10800517 	ldw	r2,20(r2)
 203eda8:	e0fffe17 	ldw	r3,-8(fp)
 203edac:	1885c83a 	sub	r2,r3,r2
 203edb0:	1009883a 	mov	r4,r2
 203edb4:	20145600 	call	2014560 <__floatunsidf>
 203edb8:	100b883a 	mov	r5,r2
 203edbc:	180d883a 	mov	r6,r3
 203edc0:	2809883a 	mov	r4,r5
 203edc4:	300b883a 	mov	r5,r6
 203edc8:	000d883a 	mov	r6,zero
 203edcc:	01d01674 	movhi	r7,16473
 203edd0:	20141d80 	call	20141d8 <__gtdf2>
 203edd4:	0080050e 	bge	zero,r2,203edec <cb_arpent_tmo+0x9c>
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
 203edd8:	e13ffc17 	ldw	r4,-16(fp)
 203eddc:	203de780 	call	203de78 <arp_free_pending>
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 203ede0:	e0bffc17 	ldw	r2,-16(fp)
 203ede4:	10000015 	stw	zero,0(r2)
 203ede8:	00001b06 	br	203ee58 <cb_arpent_tmo+0x108>
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 203edec:	e0bffc17 	ldw	r2,-16(fp)
 203edf0:	10800517 	ldw	r2,20(r2)
 203edf4:	e0fffe17 	ldw	r3,-8(fp)
 203edf8:	1885c83a 	sub	r2,r3,r2
 203edfc:	1007883a 	mov	r3,r2
 203ee00:	d0a05417 	ldw	r2,-32432(gp)
 203ee04:	18801116 	blt	r3,r2,203ee4c <cb_arpent_tmo+0xfc>
                  ((int)(lticks - tp->lasttime)   >= TPS))
 203ee08:	e0bffc17 	ldw	r2,-16(fp)
 203ee0c:	10800617 	ldw	r2,24(r2)
 203ee10:	e0fffe17 	ldw	r3,-8(fp)
 203ee14:	1885c83a 	sub	r2,r3,r2
 203ee18:	1009883a 	mov	r4,r2
 203ee1c:	20143580 	call	2014358 <__floatsidf>
 203ee20:	100b883a 	mov	r5,r2
 203ee24:	180d883a 	mov	r6,r3
         {
            /* purge if pending for more than one second */
            arp_free_pending(tp);   /* free pending packets */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
         }
         else if (((int)(lticks - tp->createtime) >= arp_ageout) &&
 203ee28:	2809883a 	mov	r4,r5
 203ee2c:	300b883a 	mov	r5,r6
 203ee30:	000d883a 	mov	r6,zero
 203ee34:	01d01674 	movhi	r7,16473
 203ee38:	201423c0 	call	201423c <__gedf2>
 203ee3c:	10000316 	blt	r2,zero,203ee4c <cb_arpent_tmo+0xfc>
                  ((int)(lticks - tp->lasttime)   >= TPS))
         {
            /* entry has "expired" and has not been reference in 1 sec. */
            tp->t_pro_addr = 0;     /* mark entry as "unused" */
 203ee40:	e0bffc17 	ldw	r2,-16(fp)
 203ee44:	10000015 	stw	zero,0(r2)
 203ee48:	00000306 	br	203ee58 <cb_arpent_tmo+0x108>
         }
         else
            arp_count++;
 203ee4c:	e0bffd17 	ldw	r2,-12(fp)
 203ee50:	10800044 	addi	r2,r2,1
 203ee54:	e0bffd15 	stw	r2,-12(fp)
{
   struct arptabent *tp;
   int arp_count = 0;
   unsigned long lticks = cticks;

   for (tp = &arp_table[0]; tp < &arp_table[MAXARPS]; tp++)
 203ee58:	e0bffc17 	ldw	r2,-16(fp)
 203ee5c:	10800804 	addi	r2,r2,32
 203ee60:	e0bffc15 	stw	r2,-16(fp)
 203ee64:	e0fffc17 	ldw	r3,-16(fp)
 203ee68:	00809934 	movhi	r2,612
 203ee6c:	10b7ce04 	addi	r2,r2,-8392
 203ee70:	18bfc536 	bltu	r3,r2,203ed88 <cb_arpent_tmo+0x38>
            arp_count++;
      }
   }

   /* if there are no more "pending" entries, kill the timer */
   if (arp_count == 0)
 203ee74:	e0bffd17 	ldw	r2,-12(fp)
 203ee78:	1000041e 	bne	r2,zero,203ee8c <cb_arpent_tmo+0x13c>
   {
      in_timerkill(arp_timer);
 203ee7c:	d0a0b517 	ldw	r2,-32044(gp)
 203ee80:	1009883a 	mov	r4,r2
 203ee84:	203dabc0 	call	203dabc <in_timerkill>
      arp_timer = 0;
 203ee88:	d020b515 	stw	zero,-32044(gp)
   }
      
   USE_ARG(arg);
}
 203ee8c:	e037883a 	mov	sp,fp
 203ee90:	dfc00117 	ldw	ra,4(sp)
 203ee94:	df000017 	ldw	fp,0(sp)
 203ee98:	dec00204 	addi	sp,sp,8
 203ee9c:	f800283a 	ret

0203eea0 <grat_arp>:
 * RETURNS: Returns 0 if OK, or the usual ENP_ errors 
 */

int
grat_arp(NET net, int flag)
{
 203eea0:	defff704 	addi	sp,sp,-36
 203eea4:	dfc00815 	stw	ra,32(sp)
 203eea8:	df000715 	stw	fp,28(sp)
 203eeac:	df000704 	addi	fp,sp,28
 203eeb0:	e13ffe15 	stw	r4,-8(fp)
 203eeb4:	e17fff15 	stw	r5,-4(fp)
   char * ethhdr;
   struct arp_hdr *  arphdr;
   IFMIB etif = net->n_mib;    /* mib info for this ethernet interface */
 203eeb8:	e0bffe17 	ldw	r2,-8(fp)
 203eebc:	10802717 	ldw	r2,156(r2)
 203eec0:	e0bff915 	stw	r2,-28(fp)
   PACKET arppkt;

   /* get a packet for an ARP request */
   LOCK_NET_RESOURCE(FREEQ_RESID); 
 203eec4:	01000084 	movi	r4,2
 203eec8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   arppkt = pk_alloc(arpsize);
 203eecc:	01000c04 	movi	r4,48
 203eed0:	2027cec0 	call	2027cec <pk_alloc>
 203eed4:	e0bffa15 	stw	r2,-24(fp)
   if (!arppkt)
 203eed8:	e0bffa17 	ldw	r2,-24(fp)
 203eedc:	1000041e 	bne	r2,zero,203eef0 <grat_arp+0x50>
   {
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203eee0:	01000084 	movi	r4,2
 203eee4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_RESOURCE;
 203eee8:	00bffa84 	movi	r2,-22
 203eeec:	00009606 	br	203f148 <grat_arp+0x2a8>
   }
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203eef0:	01000084 	movi	r4,2
 203eef4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   arppkt->nb_prot = arppkt->nb_buff;
 203eef8:	e0bffa17 	ldw	r2,-24(fp)
 203eefc:	10c00117 	ldw	r3,4(r2)
 203ef00:	e0bffa17 	ldw	r2,-24(fp)
 203ef04:	10c00315 	stw	r3,12(r2)
   arppkt->nb_plen = arpsize;
 203ef08:	e0bffa17 	ldw	r2,-24(fp)
 203ef0c:	00c00c04 	movi	r3,48
 203ef10:	10c00415 	stw	r3,16(r2)
   arppkt->net = net;
 203ef14:	e0bffa17 	ldw	r2,-24(fp)
 203ef18:	e0fffe17 	ldw	r3,-8(fp)
 203ef1c:	10c00615 	stw	r3,24(r2)

   /* build arp request packet */
   ethhdr = arppkt->nb_buff + ETHHDR_BIAS;     /* ethernet header at start of buffer */
 203ef20:	e0bffa17 	ldw	r2,-24(fp)
 203ef24:	10800117 	ldw	r2,4(r2)
 203ef28:	10800084 	addi	r2,r2,2
 203ef2c:	e0bffb15 	stw	r2,-20(fp)
   arphdr = (struct arp_hdr *)(arppkt->nb_buff + ETHHDR_SIZE); /* arp header follows */
 203ef30:	e0bffa17 	ldw	r2,-24(fp)
 203ef34:	10800117 	ldw	r2,4(r2)
 203ef38:	10800404 	addi	r2,r2,16
 203ef3c:	e0bffc15 	stw	r2,-16(fp)

#ifdef IEEE_802_3
   arphdr->ar_hd = ARP8023HW; /* net endian 802.3 arp hardware type (ethernet) */
#else
   arphdr->ar_hd = ARPHW;     /* net endian Ethernet arp hardware type (ethernet) */
 203ef40:	e0bffc17 	ldw	r2,-16(fp)
 203ef44:	00c04004 	movi	r3,256
 203ef48:	10c0000d 	sth	r3,0(r2)
#endif /* IEEE_802_3 */

   arphdr->ar_pro = ARPIP;
 203ef4c:	e0bffc17 	ldw	r2,-16(fp)
 203ef50:	00c00204 	movi	r3,8
 203ef54:	10c0008d 	sth	r3,2(r2)
   arphdr->ar_hln = 6;
 203ef58:	e0bffc17 	ldw	r2,-16(fp)
 203ef5c:	00c00184 	movi	r3,6
 203ef60:	10c00105 	stb	r3,4(r2)
   arphdr->ar_pln = 4;
 203ef64:	e0bffc17 	ldw	r2,-16(fp)
 203ef68:	00c00104 	movi	r3,4
 203ef6c:	10c00145 	stb	r3,5(r2)
   
   /* ARP req? */
   if (flag == 0)
 203ef70:	e0bfff17 	ldw	r2,-4(fp)
 203ef74:	1000041e 	bne	r2,zero,203ef88 <grat_arp+0xe8>
      /* yup */
      arphdr->ar_op = ARREQ;
 203ef78:	e0bffc17 	ldw	r2,-16(fp)
 203ef7c:	00c04004 	movi	r3,256
 203ef80:	10c0018d 	sth	r3,6(r2)
 203ef84:	00000306 	br	203ef94 <grat_arp+0xf4>
   else
     /* nope */
      arphdr->ar_op = ARREP;
 203ef88:	e0bffc17 	ldw	r2,-16(fp)
 203ef8c:	00c08004 	movi	r3,512
 203ef90:	10c0018d 	sth	r3,6(r2)
      
   arphdr->ar_tpa = net->n_ipaddr;        /* target's IP address */
 203ef94:	e0bffe17 	ldw	r2,-8(fp)
 203ef98:	10c00a17 	ldw	r3,40(r2)
 203ef9c:	e0bffc17 	ldw	r2,-16(fp)
 203efa0:	10c00715 	stw	r3,28(r2)
   arphdr->ar_spa = net->n_ipaddr;   /* my IP address */
 203efa4:	e0bffe17 	ldw	r2,-8(fp)
 203efa8:	10c00a17 	ldw	r3,40(r2)
 203efac:	e0bffc17 	ldw	r2,-16(fp)
 203efb0:	10c00415 	stw	r3,16(r2)
   MEMMOVE(arphdr->ar_sha, etif->ifPhysAddress, 6);
 203efb4:	e0bffc17 	ldw	r2,-16(fp)
 203efb8:	10c00204 	addi	r3,r2,8
 203efbc:	e0bff917 	ldw	r2,-28(fp)
 203efc0:	10800517 	ldw	r2,20(r2)
 203efc4:	1809883a 	mov	r4,r3
 203efc8:	100b883a 	mov	r5,r2
 203efcc:	01800184 	movi	r6,6
 203efd0:	20067040 	call	2006704 <memmove>
   MEMSET(ethhdr + ET_DSTOFF, 0xFF, 6);     /* destination to broadcast (all FFs) */
 203efd4:	e13ffb17 	ldw	r4,-20(fp)
 203efd8:	01403fc4 	movi	r5,255
 203efdc:	01800184 	movi	r6,6
 203efe0:	200682c0 	call	200682c <memset>
   MEMMOVE(ethhdr + ET_SRCOFF, etif->ifPhysAddress, 6);
 203efe4:	e0bffb17 	ldw	r2,-20(fp)
 203efe8:	10c00184 	addi	r3,r2,6
 203efec:	e0bff917 	ldw	r2,-28(fp)
 203eff0:	10800517 	ldw	r2,20(r2)
 203eff4:	1809883a 	mov	r4,r3
 203eff8:	100b883a 	mov	r5,r2
 203effc:	01800184 	movi	r6,6
 203f000:	20067040 	call	2006704 <memmove>
   ET_TYPE_SET(ethhdr, ntohs(ET_ARP));
 203f004:	e0bffb17 	ldw	r2,-20(fp)
 203f008:	10800304 	addi	r2,r2,12
 203f00c:	00c00204 	movi	r3,8
 203f010:	10c00005 	stb	r3,0(r2)
 203f014:	e0bffb17 	ldw	r2,-20(fp)
 203f018:	10800344 	addi	r2,r2,13
 203f01c:	00c00184 	movi	r3,6
 203f020:	10c00005 	stb	r3,0(r2)

#ifdef NO_CC_PACKING    /* move ARP fields to proper network boundaries */
   {
      struct arp_wire * arwp  =  (struct  arp_wire *)arphdr;
 203f024:	e0bffc17 	ldw	r2,-16(fp)
 203f028:	e0bffd15 	stw	r2,-12(fp)
      MEMMOVE(&arwp->data[AR_SHA], arphdr->ar_sha, 6);
 203f02c:	e0bffd17 	ldw	r2,-12(fp)
 203f030:	10c00204 	addi	r3,r2,8
 203f034:	e0bffc17 	ldw	r2,-16(fp)
 203f038:	10800204 	addi	r2,r2,8
 203f03c:	1809883a 	mov	r4,r3
 203f040:	100b883a 	mov	r5,r2
 203f044:	01800184 	movi	r6,6
 203f048:	20067040 	call	2006704 <memmove>
      MEMMOVE(&arwp->data[AR_SPA], &arphdr->ar_spa, 4);
 203f04c:	e0bffd17 	ldw	r2,-12(fp)
 203f050:	10c00384 	addi	r3,r2,14
 203f054:	e0bffc17 	ldw	r2,-16(fp)
 203f058:	10800404 	addi	r2,r2,16
 203f05c:	1809883a 	mov	r4,r3
 203f060:	100b883a 	mov	r5,r2
 203f064:	01800104 	movi	r6,4
 203f068:	20067040 	call	2006704 <memmove>

   /* ARP req? */
   if (flag == 0)
 203f06c:	e0bfff17 	ldw	r2,-4(fp)
 203f070:	1000091e 	bne	r2,zero,203f098 <grat_arp+0x1f8>
      /* yup */      
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_tha, 6);
 203f074:	e0bffd17 	ldw	r2,-12(fp)
 203f078:	10c00484 	addi	r3,r2,18
 203f07c:	e0bffc17 	ldw	r2,-16(fp)
 203f080:	10800504 	addi	r2,r2,20
 203f084:	1809883a 	mov	r4,r3
 203f088:	100b883a 	mov	r5,r2
 203f08c:	01800184 	movi	r6,6
 203f090:	20067040 	call	2006704 <memmove>
 203f094:	00000806 	br	203f0b8 <grat_arp+0x218>
   else
      /* nope */
      MEMMOVE(&arwp->data[AR_THA], arphdr->ar_sha, 6);
 203f098:	e0bffd17 	ldw	r2,-12(fp)
 203f09c:	10c00484 	addi	r3,r2,18
 203f0a0:	e0bffc17 	ldw	r2,-16(fp)
 203f0a4:	10800204 	addi	r2,r2,8
 203f0a8:	1809883a 	mov	r4,r3
 203f0ac:	100b883a 	mov	r5,r2
 203f0b0:	01800184 	movi	r6,6
 203f0b4:	20067040 	call	2006704 <memmove>
      
      MEMMOVE(&arwp->data[AR_TPA], &arphdr->ar_tpa, 4);
 203f0b8:	e0bffd17 	ldw	r2,-12(fp)
 203f0bc:	10c00604 	addi	r3,r2,24
 203f0c0:	e0bffc17 	ldw	r2,-16(fp)
 203f0c4:	10800704 	addi	r2,r2,28
 203f0c8:	1809883a 	mov	r4,r3
 203f0cc:	100b883a 	mov	r5,r2
 203f0d0:	01800104 	movi	r6,4
 203f0d4:	20067040 	call	2006704 <memmove>
   }
#endif   /* IEEE_802_3 */

#ifndef IEEE_802_3_ONLY
   /* send arp request - if a packet oriented send exists, use it: */
   if (net->pkt_send)
 203f0d8:	e0bffe17 	ldw	r2,-8(fp)
 203f0dc:	10800417 	ldw	r2,16(r2)
 203f0e0:	10000526 	beq	r2,zero,203f0f8 <grat_arp+0x258>
      net->pkt_send(arppkt);  /* driver should free arppkt later */
 203f0e4:	e0bffe17 	ldw	r2,-8(fp)
 203f0e8:	10800417 	ldw	r2,16(r2)
 203f0ec:	e13ffa17 	ldw	r4,-24(fp)
 203f0f0:	103ee83a 	callr	r2
 203f0f4:	00001006 	br	203f138 <grat_arp+0x298>
   else  /* use old raw send */
   {
      net->raw_send(arppkt->net, arppkt->nb_buff, arpsize);
 203f0f8:	e0bffe17 	ldw	r2,-8(fp)
 203f0fc:	11c00317 	ldw	r7,12(r2)
 203f100:	e0bffa17 	ldw	r2,-24(fp)
 203f104:	10c00617 	ldw	r3,24(r2)
 203f108:	e0bffa17 	ldw	r2,-24(fp)
 203f10c:	10800117 	ldw	r2,4(r2)
 203f110:	1809883a 	mov	r4,r3
 203f114:	100b883a 	mov	r5,r2
 203f118:	01800c04 	movi	r6,48
 203f11c:	383ee83a 	callr	r7
      LOCK_NET_RESOURCE(FREEQ_RESID);
 203f120:	01000084 	movi	r4,2
 203f124:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(arppkt);
 203f128:	e13ffa17 	ldw	r4,-24(fp)
 203f12c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203f130:	01000084 	movi	r4,2
 203f134:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   }
   arpReqsOut++;
 203f138:	d0a0b917 	ldw	r2,-32028(gp)
 203f13c:	10800044 	addi	r2,r2,1
 203f140:	d0a0b915 	stw	r2,-32028(gp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(arppkt);
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif  /* IEEE_802_3_ONLY */
   
   return ENP_SEND_PENDING;
 203f144:	00800044 	movi	r2,1
}
 203f148:	e037883a 	mov	sp,fp
 203f14c:	dfc00117 	ldw	ra,4(sp)
 203f150:	df000017 	ldw	fp,0(sp)
 203f154:	dec00204 	addi	sp,sp,8
 203f158:	f800283a 	ret

0203f15c <if_getbynum>:
 * RETURNS: Returns NET pointer, or NULL if out of range
 */

NET
if_getbynum(int ifnum)
{
 203f15c:	defffc04 	addi	sp,sp,-16
 203f160:	dfc00315 	stw	ra,12(sp)
 203f164:	df000215 	stw	fp,8(sp)
 203f168:	df000204 	addi	fp,sp,8
 203f16c:	e13fff15 	stw	r4,-4(fp)
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 203f170:	00809934 	movhi	r2,612
 203f174:	10b7ce04 	addi	r2,r2,-8392
 203f178:	10800017 	ldw	r2,0(r2)
 203f17c:	e0bffe15 	stw	r2,-8(fp)
 203f180:	00000c06 	br	203f1b4 <if_getbynum+0x58>
   {
      if(ifnum-- == 0)
 203f184:	e0bfff17 	ldw	r2,-4(fp)
 203f188:	1005003a 	cmpeq	r2,r2,zero
 203f18c:	e0ffff17 	ldw	r3,-4(fp)
 203f190:	18ffffc4 	addi	r3,r3,-1
 203f194:	e0ffff15 	stw	r3,-4(fp)
 203f198:	10803fcc 	andi	r2,r2,255
 203f19c:	10000226 	beq	r2,zero,203f1a8 <if_getbynum+0x4c>
         return ifp;
 203f1a0:	e0bffe17 	ldw	r2,-8(fp)
 203f1a4:	00000706 	br	203f1c4 <if_getbynum+0x68>

NET
if_getbynum(int ifnum)
{
   NET ifp;
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 203f1a8:	e0bffe17 	ldw	r2,-8(fp)
 203f1ac:	10800017 	ldw	r2,0(r2)
 203f1b0:	e0bffe15 	stw	r2,-8(fp)
 203f1b4:	e0bffe17 	ldw	r2,-8(fp)
 203f1b8:	103ff21e 	bne	r2,zero,203f184 <if_getbynum+0x28>
   {
      if(ifnum-- == 0)
         return ifp;
   }
   dtrap();
 203f1bc:	20285c80 	call	20285c8 <dtrap>
   return NULL;   /* list is not long enough */
 203f1c0:	0005883a 	mov	r2,zero
}
 203f1c4:	e037883a 	mov	sp,fp
 203f1c8:	dfc00117 	ldw	ra,4(sp)
 203f1cc:	df000017 	ldw	fp,0(sp)
 203f1d0:	dec00204 	addi	sp,sp,8
 203f1d4:	f800283a 	ret

0203f1d8 <isbcast>:
 * RETURNS:  Returns TRUE if broadcast, else false. 
 */

int
isbcast(NET ifc, unsigned char * addr)
{
 203f1d8:	defffd04 	addi	sp,sp,-12
 203f1dc:	df000215 	stw	fp,8(sp)
 203f1e0:	df000204 	addi	fp,sp,8
 203f1e4:	e13ffe15 	stw	r4,-8(fp)
 203f1e8:	e17fff15 	stw	r5,-4(fp)
#if (ALIGN_TYPE > 2)
   /* On systems with 32bit alignment requirements we have to make
    * sure our tests are aligned. Specifically, this results in "data
    * abort" errors on the Samsung/ARM port. 
    */
   if((u_long)addr & (ALIGN_TYPE - 1))
 203f1ec:	e0bfff17 	ldw	r2,-4(fp)
 203f1f0:	108000cc 	andi	r2,r2,3
 203f1f4:	10000e26 	beq	r2,zero,203f230 <isbcast+0x58>
   {
      /* check first two bytes */
      if ((u_short)*(u_short*)(addr) != 0xFFFF)
 203f1f8:	e0bfff17 	ldw	r2,-4(fp)
 203f1fc:	1080000b 	ldhu	r2,0(r2)
 203f200:	10ffffcc 	andi	r3,r2,65535
 203f204:	00bfffd4 	movui	r2,65535
 203f208:	18800226 	beq	r3,r2,203f214 <isbcast+0x3c>
         return(FALSE);
 203f20c:	0005883a 	mov	r2,zero
 203f210:	00002206 	br	203f29c <isbcast+0xc4>
      if ((u_long)(*(u_long*)(addr + 2)) != 0xFFFFFFFF)
 203f214:	e0bfff17 	ldw	r2,-4(fp)
 203f218:	10800084 	addi	r2,r2,2
 203f21c:	10800017 	ldw	r2,0(r2)
 203f220:	10bfffe0 	cmpeqi	r2,r2,-1
 203f224:	1000101e 	bne	r2,zero,203f268 <isbcast+0x90>
         return FALSE;
 203f228:	0005883a 	mov	r2,zero
 203f22c:	00001b06 	br	203f29c <isbcast+0xc4>
#endif /* ALIGN_TYPE > 4 */
   {
      /* check first four bytes for all ones. Since this is the fastest
       * test, do it first
       */
      if ((u_long)(*(u_long*)addr) != 0xFFFFFFFF)
 203f230:	e0bfff17 	ldw	r2,-4(fp)
 203f234:	10800017 	ldw	r2,0(r2)
 203f238:	10bfffe0 	cmpeqi	r2,r2,-1
 203f23c:	1000021e 	bne	r2,zero,203f248 <isbcast+0x70>
         return FALSE;
 203f240:	0005883a 	mov	r2,zero
 203f244:	00001506 	br	203f29c <isbcast+0xc4>

      /* check last two bytes */
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
 203f248:	e0bfff17 	ldw	r2,-4(fp)
 203f24c:	10800104 	addi	r2,r2,4
 203f250:	1080000b 	ldhu	r2,0(r2)
 203f254:	10ffffcc 	andi	r3,r2,65535
 203f258:	00bfffd4 	movui	r2,65535
 203f25c:	18800226 	beq	r3,r2,203f268 <isbcast+0x90>
         return(FALSE);
 203f260:	0005883a 	mov	r2,zero
 203f264:	00000d06 	br	203f29c <isbcast+0xc4>
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 203f268:	e0bffe17 	ldw	r2,-8(fp)
 203f26c:	10802717 	ldw	r2,156(r2)
 203f270:	10800217 	ldw	r2,8(r2)
 203f274:	108005e0 	cmpeqi	r2,r2,23
 203f278:	1000051e 	bne	r2,zero,203f290 <isbcast+0xb8>
       (ifc->n_mib->ifType == SLIP))
 203f27c:	e0bffe17 	ldw	r2,-8(fp)
 203f280:	10802717 	ldw	r2,156(r2)
 203f284:	10800217 	ldw	r2,8(r2)
      if ((u_short)*(u_short*)(addr+4) != 0xFFFF)
         return(FALSE);
   }
   
   /* now reject any line type packets which don't support broadcast */
   if ((ifc->n_mib->ifType == PPP) ||
 203f288:	10800718 	cmpnei	r2,r2,28
 203f28c:	1000021e 	bne	r2,zero,203f298 <isbcast+0xc0>
       (ifc->n_mib->ifType == SLIP))
   {
      return FALSE;
 203f290:	0005883a 	mov	r2,zero
 203f294:	00000106 	br	203f29c <isbcast+0xc4>
   }

   /* passed all tests, must be broadcast */
   return(TRUE);
 203f298:	00800044 	movi	r2,1
}
 203f29c:	e037883a 	mov	sp,fp
 203f2a0:	df000017 	ldw	fp,0(sp)
 203f2a4:	dec00104 	addi	sp,sp,4
 203f2a8:	f800283a 	ret

0203f2ac <reg_type>:
 * RETURNS: Returns 0 if OK, else non-zero error code. 
 */

int
reg_type(unshort type)
{
 203f2ac:	defffb04 	addi	sp,sp,-20
 203f2b0:	dfc00415 	stw	ra,16(sp)
 203f2b4:	df000315 	stw	fp,12(sp)
 203f2b8:	df000304 	addi	fp,sp,12
 203f2bc:	2005883a 	mov	r2,r4
 203f2c0:	e0bfff0d 	sth	r2,-4(fp)
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 203f2c4:	00809934 	movhi	r2,612
 203f2c8:	10b7ce04 	addi	r2,r2,-8392
 203f2cc:	10800017 	ldw	r2,0(r2)
 203f2d0:	e0bffd15 	stw	r2,-12(fp)
 203f2d4:	00001106 	br	203f31c <reg_type+0x70>
   {
      if (ifp->n_reg_type)    /* make sure call exists */
 203f2d8:	e0bffd17 	ldw	r2,-12(fp)
 203f2dc:	10800617 	ldw	r2,24(r2)
 203f2e0:	10000b26 	beq	r2,zero,203f310 <reg_type+0x64>
      {
         e = (ifp->n_reg_type)(type, ifp);
 203f2e4:	e0bffd17 	ldw	r2,-12(fp)
 203f2e8:	10c00617 	ldw	r3,24(r2)
 203f2ec:	e0bfff0b 	ldhu	r2,-4(fp)
 203f2f0:	1009883a 	mov	r4,r2
 203f2f4:	e17ffd17 	ldw	r5,-12(fp)
 203f2f8:	183ee83a 	callr	r3
 203f2fc:	e0bffe15 	stw	r2,-8(fp)
         if (e)
 203f300:	e0bffe17 	ldw	r2,-8(fp)
 203f304:	10000226 	beq	r2,zero,203f310 <reg_type+0x64>
            return e;   /* bails out if error */
 203f308:	e0bffe17 	ldw	r2,-8(fp)
 203f30c:	00000606 	br	203f328 <reg_type+0x7c>
   if (i >= PLLISTLEN)
      return ENP_RESOURCE;
#endif   /* DYNAMIC_IFACES */

   /* loop thru list of nets, making them all look at new type */
   for (ifp = (NET)(netlist.q_head); ifp; ifp = ifp->n_next)
 203f310:	e0bffd17 	ldw	r2,-12(fp)
 203f314:	10800017 	ldw	r2,0(r2)
 203f318:	e0bffd15 	stw	r2,-12(fp)
 203f31c:	e0bffd17 	ldw	r2,-12(fp)
 203f320:	103fed1e 	bne	r2,zero,203f2d8 <reg_type+0x2c>
         e = (ifp->n_reg_type)(type, ifp);
         if (e)
            return e;   /* bails out if error */
      }
   }
   return 0;   /* OK code */
 203f324:	0005883a 	mov	r2,zero
}
 203f328:	e037883a 	mov	sp,fp
 203f32c:	dfc00117 	ldw	ra,4(sp)
 203f330:	df000017 	ldw	fp,0(sp)
 203f334:	dec00204 	addi	sp,sp,8
 203f338:	f800283a 	ret

0203f33c <if_killsocks>:
 */

      /* kill this NETs sockets */
void
if_killsocks(NET ifp)
{
 203f33c:	defffa04 	addi	sp,sp,-24
 203f340:	dfc00515 	stw	ra,20(sp)
 203f344:	df000415 	stw	fp,16(sp)
 203f348:	df000404 	addi	fp,sp,16
 203f34c:	e13fff15 	stw	r4,-4(fp)
   struct socket * so;
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
 203f350:	00809934 	movhi	r2,612
 203f354:	10b6c204 	addi	r2,r2,-9464
 203f358:	10800017 	ldw	r2,0(r2)
 203f35c:	e0bffc15 	stw	r2,-16(fp)
   while(so)
 203f360:	00001306 	br	203f3b0 <if_killsocks+0x74>
   {
      if(so->so_pcb)
 203f364:	e0bffc17 	ldw	r2,-16(fp)
 203f368:	10800117 	ldw	r2,4(r2)
 203f36c:	10000526 	beq	r2,zero,203f384 <if_killsocks+0x48>
         so_ifp = so->so_pcb->ifp;
 203f370:	e0bffc17 	ldw	r2,-16(fp)
 203f374:	10800117 	ldw	r2,4(r2)
 203f378:	10800a17 	ldw	r2,40(r2)
 203f37c:	e0bffd15 	stw	r2,-12(fp)
 203f380:	00000106 	br	203f388 <if_killsocks+0x4c>
      else
         so_ifp = NULL;
 203f384:	e03ffd15 	stw	zero,-12(fp)
      next = (struct socket *)so->next;
 203f388:	e0bffc17 	ldw	r2,-16(fp)
 203f38c:	10800017 	ldw	r2,0(r2)
 203f390:	e0bffe15 	stw	r2,-8(fp)
      if (so_ifp == ifp)
 203f394:	e0fffd17 	ldw	r3,-12(fp)
 203f398:	e0bfff17 	ldw	r2,-4(fp)
 203f39c:	1880021e 	bne	r3,r2,203f3a8 <if_killsocks+0x6c>
      {
         /* this is a direct heavy-handed close. A reset is sent
          * and all data is lost. The user should really have closed
          * all the sockets gracfully first.... 
          */
         soabort(so);
 203f3a0:	e13ffc17 	ldw	r4,-16(fp)
 203f3a4:	202d1d40 	call	202d1d4 <soabort>
      }
      so = next;
 203f3a8:	e0bffe17 	ldw	r2,-8(fp)
 203f3ac:	e0bffc15 	stw	r2,-16(fp)
   struct socket * next;
   NET      so_ifp;     /* interface of sockets in list */

   /* reset any sockets with this iface IP address */
   so = (struct socket *)(soq.q_head);
   while(so)
 203f3b0:	e0bffc17 	ldw	r2,-16(fp)
 203f3b4:	103feb1e 	bne	r2,zero,203f364 <if_killsocks+0x28>
          */
         soabort(so);
      }
      so = next;
   }
}
 203f3b8:	e037883a 	mov	sp,fp
 203f3bc:	dfc00117 	ldw	ra,4(sp)
 203f3c0:	df000017 	ldw	fp,0(sp)
 203f3c4:	dec00204 	addi	sp,sp,8
 203f3c8:	f800283a 	ret

0203f3cc <ip_init>:
 * OK, else returns a non-zero error code. 
 */

int
ip_init(void)
{
 203f3cc:	defffe04 	addi	sp,sp,-8
 203f3d0:	dfc00115 	stw	ra,4(sp)
 203f3d4:	df000015 	stw	fp,0(sp)
 203f3d8:	d839883a 	mov	fp,sp

   /* register IP type with link layer drivers */
   if (reg_type(IP_TYPE) != 0)
 203f3dc:	01000204 	movi	r4,8
 203f3e0:	203f2ac0 	call	203f2ac <reg_type>
 203f3e4:	10000526 	beq	r2,zero,203f3fc <ip_init+0x30>
   {   
#ifdef NPDEBUG
      dprintf("IP_INIT: unable to register type with MAC driver\n");
 203f3e8:	01008174 	movhi	r4,517
 203f3ec:	21053204 	addi	r4,r4,5320
 203f3f0:	2006cb40 	call	2006cb4 <puts>
#endif
      return(1);
 203f3f4:	00800044 	movi	r2,1
 203f3f8:	00002906 	br	203f4a0 <ip_init+0xd4>
   }

   /* initialize the IP mib */
   MEMSET(&ip_mib, 0, sizeof(ip_mib));
 203f3fc:	01009934 	movhi	r4,612
 203f400:	2137d304 	addi	r4,r4,-8372
 203f404:	000b883a 	mov	r5,zero
 203f408:	01801404 	movi	r6,80
 203f40c:	200682c0 	call	200682c <memset>
   ip_mib.ipForwarding = 2;   /* default to host, not gateway (router) */
 203f410:	00809934 	movhi	r2,612
 203f414:	10b7d304 	addi	r2,r2,-8372
 203f418:	00c00084 	movi	r3,2
 203f41c:	10c00015 	stw	r3,0(r2)
   ip_mib.ipDefaultTTL = IP_TTL;
 203f420:	00809934 	movhi	r2,612
 203f424:	10b7d304 	addi	r2,r2,-8372
 203f428:	00c01004 	movi	r3,64
 203f42c:	10c00115 	stw	r3,4(r2)

#ifdef IP_ROUTING
   /* alloc space for the route table */
   rt_mib = (struct RtMib*)RT_ALLOC(ipRoutes * sizeof(struct RtMib));
 203f430:	d0a05617 	ldw	r2,-32424(gp)
 203f434:	10800f24 	muli	r2,r2,60
 203f438:	1009883a 	mov	r4,r2
 203f43c:	20290400 	call	2029040 <npalloc>
 203f440:	d0a0bc15 	stw	r2,-32016(gp)
   if (!rt_mib)
 203f444:	d0a0bc17 	ldw	r2,-32016(gp)
 203f448:	1000051e 	bne	r2,zero,203f460 <ip_init+0x94>
   {
#ifdef NPDEBUG
      dprintf("IP_INIT ERROR: can't alloc route table\n");
 203f44c:	01008174 	movhi	r4,517
 203f450:	21053f04 	addi	r4,r4,5372
 203f454:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG */
      return(ENP_NOMEM);
 203f458:	00bffb04 	movi	r2,-20
 203f45c:	00001006 	br	203f4a0 <ip_init+0xd4>
   }

  MEMSET(rt_mib,0, ipRoutes * sizeof(struct RtMib)) ;
 203f460:	d0e0bc17 	ldw	r3,-32016(gp)
 203f464:	d0a05617 	ldw	r2,-32424(gp)
 203f468:	10800f24 	muli	r2,r2,60
 203f46c:	1809883a 	mov	r4,r3
 203f470:	000b883a 	mov	r5,zero
 203f474:	100d883a 	mov	r6,r2
 203f478:	200682c0 	call	200682c <memset>
  ip_mib.ipForwarding = 1;   /* override default, be gateway (router) */
 203f47c:	00809934 	movhi	r2,612
 203f480:	10b7d304 	addi	r2,r2,-8372
 203f484:	00c00044 	movi	r3,1
 203f488:	10c00015 	stw	r3,0(r2)
#endif   /* IP_ROUTING */

   /* set IP reassembly timeout */
   ip_mib.ipReasmTimeout = IRE_TMO;
 203f48c:	00809934 	movhi	r2,612
 203f490:	10b7d304 	addi	r2,r2,-8372
 203f494:	00c01e04 	movi	r3,120
 203f498:	10c00c15 	stw	r3,48(r2)
      return(1);
   }
#endif   /* IPSEC */

   /* everything opened OK return 0 */
   return(SUCCESS);
 203f49c:	0005883a 	mov	r2,zero
}
 203f4a0:	e037883a 	mov	sp,fp
 203f4a4:	dfc00117 	ldw	ra,4(sp)
 203f4a8:	df000017 	ldw	fp,0(sp)
 203f4ac:	dec00204 	addi	sp,sp,8
 203f4b0:	f800283a 	ret

0203f4b4 <ip_bldhead>:
 * RETURNS: void
 */

void
ip_bldhead(PACKET p, unsigned pid, u_char prot, unshort fragword)
{
 203f4b4:	defff804 	addi	sp,sp,-32
 203f4b8:	dfc00715 	stw	ra,28(sp)
 203f4bc:	df000615 	stw	fp,24(sp)
 203f4c0:	df000604 	addi	fp,sp,24
 203f4c4:	e13ffc15 	stw	r4,-16(fp)
 203f4c8:	e17ffd15 	stw	r5,-12(fp)
 203f4cc:	3007883a 	mov	r3,r6
 203f4d0:	3805883a 	mov	r2,r7
 203f4d4:	e0fffe05 	stb	r3,-8(fp)
 203f4d8:	e0bfff0d 	sth	r2,-4(fp)
   struct ip * pip;
   struct ip_socopts *sopts;

   /* prepend IP header to packet data */
   p->nb_prot -= sizeof(struct ip);       /* this assumes no send options! */
 203f4dc:	e0bffc17 	ldw	r2,-16(fp)
 203f4e0:	10800317 	ldw	r2,12(r2)
 203f4e4:	10fffb04 	addi	r3,r2,-20
 203f4e8:	e0bffc17 	ldw	r2,-16(fp)
 203f4ec:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 203f4f0:	e0bffc17 	ldw	r2,-16(fp)
 203f4f4:	10800417 	ldw	r2,16(r2)
 203f4f8:	10c00504 	addi	r3,r2,20
 203f4fc:	e0bffc17 	ldw	r2,-16(fp)
 203f500:	10c00415 	stw	r3,16(r2)

   pip = (struct ip*)p->nb_prot;
 203f504:	e0bffc17 	ldw	r2,-16(fp)
 203f508:	10800317 	ldw	r2,12(r2)
 203f50c:	e0bffa15 	stw	r2,-24(fp)

   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 203f510:	e0bffa17 	ldw	r2,-24(fp)
 203f514:	00c01144 	movi	r3,69
 203f518:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = fragword; /* fragment flags and offset */
 203f51c:	e0bffa17 	ldw	r2,-24(fp)
 203f520:	e0ffff0b 	ldhu	r3,-4(fp)
 203f524:	10c0018d 	sth	r3,6(r2)
   pip->ip_id = htons((unshort)pid);   /* IP datagram ID */
 203f528:	e0bffd17 	ldw	r2,-12(fp)
 203f52c:	10bfffcc 	andi	r2,r2,65535
 203f530:	1004d23a 	srli	r2,r2,8
 203f534:	1007883a 	mov	r3,r2
 203f538:	e0bffd17 	ldw	r2,-12(fp)
 203f53c:	10bfffcc 	andi	r2,r2,65535
 203f540:	1004923a 	slli	r2,r2,8
 203f544:	1884b03a 	or	r2,r3,r2
 203f548:	1007883a 	mov	r3,r2
 203f54c:	e0bffa17 	ldw	r2,-24(fp)
 203f550:	10c0010d 	sth	r3,4(r2)
   pip->ip_len = htons((unshort)p->nb_plen);
 203f554:	e0bffc17 	ldw	r2,-16(fp)
 203f558:	10800417 	ldw	r2,16(r2)
 203f55c:	10bfffcc 	andi	r2,r2,65535
 203f560:	1004d23a 	srli	r2,r2,8
 203f564:	1007883a 	mov	r3,r2
 203f568:	e0bffc17 	ldw	r2,-16(fp)
 203f56c:	10800417 	ldw	r2,16(r2)
 203f570:	10bfffcc 	andi	r2,r2,65535
 203f574:	1004923a 	slli	r2,r2,8
 203f578:	1884b03a 	or	r2,r3,r2
 203f57c:	1007883a 	mov	r3,r2
 203f580:	e0bffa17 	ldw	r2,-24(fp)
 203f584:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;          /* install protocol ID (TCP, UDP, etc) */
 203f588:	e0bffa17 	ldw	r2,-24(fp)
 203f58c:	e0fffe03 	ldbu	r3,-8(fp)
 203f590:	10c00245 	stb	r3,9(r2)

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 203f594:	e0bffc17 	ldw	r2,-16(fp)
 203f598:	10800c17 	ldw	r2,48(r2)
 203f59c:	e0bffb15 	stw	r2,-20(fp)
 203f5a0:	e0bffb17 	ldw	r2,-20(fp)
 203f5a4:	10001126 	beq	r2,zero,203f5ec <ip_bldhead+0x138>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 203f5a8:	e0bffb17 	ldw	r2,-20(fp)
 203f5ac:	10800043 	ldbu	r2,1(r2)
 203f5b0:	10803fcc 	andi	r2,r2,255
 203f5b4:	10000526 	beq	r2,zero,203f5cc <ip_bldhead+0x118>
         pip->ip_time = sopts->ip_ttl;
 203f5b8:	e0bffb17 	ldw	r2,-20(fp)
 203f5bc:	10c00043 	ldbu	r3,1(r2)
 203f5c0:	e0bffa17 	ldw	r2,-24(fp)
 203f5c4:	10c00205 	stb	r3,8(r2)
 203f5c8:	00000306 	br	203f5d8 <ip_bldhead+0x124>
	  else
         pip->ip_time = (u_char)IP_TTL;     /* default number of hops, really */
 203f5cc:	e0bffa17 	ldw	r2,-24(fp)
 203f5d0:	00c01004 	movi	r3,64
 203f5d4:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 203f5d8:	e0bffb17 	ldw	r2,-20(fp)
 203f5dc:	10c00003 	ldbu	r3,0(r2)
 203f5e0:	e0bffa17 	ldw	r2,-24(fp)
 203f5e4:	10c00045 	stb	r3,1(r2)
 203f5e8:	00000506 	br	203f600 <ip_bldhead+0x14c>
   }
   else
   {
	  /* nope */
      pip->ip_time = (u_char)IP_TTL;       /* default number of hops, really */
 203f5ec:	e0bffa17 	ldw	r2,-24(fp)
 203f5f0:	00c01004 	movi	r3,64
 203f5f4:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 203f5f8:	e0bffa17 	ldw	r2,-24(fp)
 203f5fc:	10000045 	stb	zero,1(r2)
   }
   
   pip->ip_chksum = IPXSUM;      /* clear checksum field for summing */
 203f600:	e0bffa17 	ldw	r2,-24(fp)
 203f604:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 203f608:	e13ffa17 	ldw	r4,-24(fp)
 203f60c:	01400284 	movi	r5,10
 203f610:	20268040 	call	2026804 <cksum>
 203f614:	0084303a 	nor	r2,zero,r2
 203f618:	1007883a 	mov	r3,r2
 203f61c:	e0bffa17 	ldw	r2,-24(fp)
 203f620:	10c0028d 	sth	r3,10(r2)
}
 203f624:	e037883a 	mov	sp,fp
 203f628:	dfc00117 	ldw	ra,4(sp)
 203f62c:	df000017 	ldw	fp,0(sp)
 203f630:	dec00204 	addi	sp,sp,8
 203f634:	f800283a 	ret

0203f638 <ip_write_internal>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_write_internal(PACKET p)
{
 203f638:	defff004 	addi	sp,sp,-64
 203f63c:	dfc00f15 	stw	ra,60(sp)
 203f640:	df000e15 	stw	fp,56(sp)
 203f644:	df000e04 	addi	fp,sp,56
 203f648:	e13fff15 	stw	r4,-4(fp)
   PACKET newpkt;
   unsigned maxbuflen;

#ifdef IP_MULTICAST
   /* If destination address is multicast, process multicast options */
   if (IN_MULTICAST(ntohl(p->fhost)))
 203f64c:	e0bfff17 	ldw	r2,-4(fp)
 203f650:	10800717 	ldw	r2,28(r2)
 203f654:	1006d63a 	srli	r3,r2,24
 203f658:	e0bfff17 	ldw	r2,-4(fp)
 203f65c:	10800717 	ldw	r2,28(r2)
 203f660:	1004d23a 	srli	r2,r2,8
 203f664:	10bfc00c 	andi	r2,r2,65280
 203f668:	1886b03a 	or	r3,r3,r2
 203f66c:	e0bfff17 	ldw	r2,-4(fp)
 203f670:	10800717 	ldw	r2,28(r2)
 203f674:	10bfc00c 	andi	r2,r2,65280
 203f678:	1004923a 	slli	r2,r2,8
 203f67c:	1886b03a 	or	r3,r3,r2
 203f680:	e0bfff17 	ldw	r2,-4(fp)
 203f684:	10800717 	ldw	r2,28(r2)
 203f688:	1004963a 	slli	r2,r2,24
 203f68c:	1884b03a 	or	r2,r3,r2
 203f690:	10fc002c 	andhi	r3,r2,61440
 203f694:	00b80034 	movhi	r2,57344
 203f698:	1880ad1e 	bne	r3,r2,203f950 <ip_write_internal+0x318>
   {
      if (p->imo != NULL)
 203f69c:	e0bfff17 	ldw	r2,-4(fp)
 203f6a0:	10800b17 	ldw	r2,44(r2)
 203f6a4:	10001326 	beq	r2,zero,203f6f4 <ip_write_internal+0xbc>
         if (p->imo->imo_multicast_netp)
 203f6a8:	e0bfff17 	ldw	r2,-4(fp)
 203f6ac:	10800b17 	ldw	r2,44(r2)
 203f6b0:	10800017 	ldw	r2,0(r2)
 203f6b4:	10000626 	beq	r2,zero,203f6d0 <ip_write_internal+0x98>
            p->net = p->imo->imo_multicast_netp;
 203f6b8:	e0bfff17 	ldw	r2,-4(fp)
 203f6bc:	10800b17 	ldw	r2,44(r2)
 203f6c0:	10c00017 	ldw	r3,0(r2)
 203f6c4:	e0bfff17 	ldw	r2,-4(fp)
 203f6c8:	10c00615 	stw	r3,24(r2)
 203f6cc:	00002606 	br	203f768 <ip_write_internal+0x130>
         else
            p->net = iproute(p->fhost, &firsthop);
 203f6d0:	e0bfff17 	ldw	r2,-4(fp)
 203f6d4:	10c00717 	ldw	r3,28(r2)
 203f6d8:	e0bffe04 	addi	r2,fp,-8
 203f6dc:	1809883a 	mov	r4,r3
 203f6e0:	100b883a 	mov	r5,r2
 203f6e4:	20410e40 	call	20410e4 <iproute>
 203f6e8:	e0ffff17 	ldw	r3,-4(fp)
 203f6ec:	18800615 	stw	r2,24(r3)
 203f6f0:	00001d06 	br	203f768 <ip_write_internal+0x130>
      else
      {
         for (i = 0; i < ifNumber; i++)
 203f6f4:	e03ff515 	stw	zero,-44(fp)
 203f6f8:	00001606 	br	203f754 <ip_write_internal+0x11c>
            if (nets[i]->n_mcastlist)
 203f6fc:	00c09934 	movhi	r3,612
 203f700:	18f5c104 	addi	r3,r3,-10492
 203f704:	e0bff517 	ldw	r2,-44(fp)
 203f708:	1085883a 	add	r2,r2,r2
 203f70c:	1085883a 	add	r2,r2,r2
 203f710:	1885883a 	add	r2,r3,r2
 203f714:	10800017 	ldw	r2,0(r2)
 203f718:	10802b17 	ldw	r2,172(r2)
 203f71c:	10000a26 	beq	r2,zero,203f748 <ip_write_internal+0x110>
            {
               p->net = nets[i];
 203f720:	00c09934 	movhi	r3,612
 203f724:	18f5c104 	addi	r3,r3,-10492
 203f728:	e0bff517 	ldw	r2,-44(fp)
 203f72c:	1085883a 	add	r2,r2,r2
 203f730:	1085883a 	add	r2,r2,r2
 203f734:	1885883a 	add	r2,r3,r2
 203f738:	10c00017 	ldw	r3,0(r2)
 203f73c:	e0bfff17 	ldw	r2,-4(fp)
 203f740:	10c00615 	stw	r3,24(r2)
               break;
 203f744:	00000806 	br	203f768 <ip_write_internal+0x130>
            p->net = p->imo->imo_multicast_netp;
         else
            p->net = iproute(p->fhost, &firsthop);
      else
      {
         for (i = 0; i < ifNumber; i++)
 203f748:	e0bff517 	ldw	r2,-44(fp)
 203f74c:	10800044 	addi	r2,r2,1
 203f750:	e0bff515 	stw	r2,-44(fp)
 203f754:	00808174 	movhi	r2,517
 203f758:	1090b304 	addi	r2,r2,17100
 203f75c:	10800017 	ldw	r2,0(r2)
 203f760:	e0fff517 	ldw	r3,-44(fp)
 203f764:	18bfe536 	bltu	r3,r2,203f6fc <ip_write_internal+0xc4>
               break;
            }
      }

      /* Confirm that the outgoing interface supports multicast. */
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
 203f768:	e0bfff17 	ldw	r2,-4(fp)
 203f76c:	10800617 	ldw	r2,24(r2)
 203f770:	10000426 	beq	r2,zero,203f784 <ip_write_internal+0x14c>
 203f774:	e0bfff17 	ldw	r2,-4(fp)
 203f778:	10800617 	ldw	r2,24(r2)
 203f77c:	10802b17 	ldw	r2,172(r2)
 203f780:	10002e1e 	bne	r2,zero,203f83c <ip_write_internal+0x204>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 203f784:	00808174 	movhi	r2,517
 203f788:	1090b204 	addi	r2,r2,17096
 203f78c:	10800017 	ldw	r2,0(r2)
 203f790:	1080840c 	andi	r2,r2,528
 203f794:	10001a26 	beq	r2,zero,203f800 <ip_write_internal+0x1c8>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f798:	e0bfff17 	ldw	r2,-4(fp)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f79c:	10c00417 	ldw	r3,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f7a0:	e0bfff17 	ldw	r2,-4(fp)
 203f7a4:	10800717 	ldw	r2,28(r2)
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f7a8:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f7ac:	e13fff17 	ldw	r4,-4(fp)
 203f7b0:	21000717 	ldw	r4,28(r4)
 203f7b4:	2008d23a 	srli	r4,r4,8
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f7b8:	21803fcc 	andi	r6,r4,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f7bc:	e13fff17 	ldw	r4,-4(fp)
 203f7c0:	21000717 	ldw	r4,28(r4)
 203f7c4:	2008d43a 	srli	r4,r4,16
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f7c8:	21403fcc 	andi	r5,r4,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f7cc:	e13fff17 	ldw	r4,-4(fp)
 203f7d0:	21000717 	ldw	r4,28(r4)
 203f7d4:	2008d63a 	srli	r4,r4,24
      if ((p->net == NULL) || (p->net->n_mcastlist) == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f7d8:	d9800015 	stw	r6,0(sp)
 203f7dc:	d9400115 	stw	r5,4(sp)
 203f7e0:	d9000215 	stw	r4,8(sp)
 203f7e4:	01008174 	movhi	r4,517
 203f7e8:	21054904 	addi	r4,r4,5412
 203f7ec:	e17fff17 	ldw	r5,-4(fp)
 203f7f0:	180d883a 	mov	r6,r3
 203f7f4:	100f883a 	mov	r7,r2
 203f7f8:	2006a240 	call	2006a24 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 203f7fc:	20285c80 	call	20285c8 <dtrap>
         }
#endif
         ip_mib.ipOutNoRoutes++;
 203f800:	00809934 	movhi	r2,612
 203f804:	10b7d304 	addi	r2,r2,-8372
 203f808:	10800b17 	ldw	r2,44(r2)
 203f80c:	10c00044 	addi	r3,r2,1
 203f810:	00809934 	movhi	r2,612
 203f814:	10b7d304 	addi	r2,r2,-8372
 203f818:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 203f81c:	01000084 	movi	r4,2
 203f820:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 203f824:	e13fff17 	ldw	r4,-4(fp)
 203f828:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203f82c:	01000084 	movi	r4,2
 203f830:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 203f834:	00bff7c4 	movi	r2,-33
 203f838:	00014a06 	br	203fd64 <ip_write_internal+0x72c>
       * If we belong to the destination multicast group
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
 203f83c:	e0bfff17 	ldw	r2,-4(fp)
 203f840:	10c00717 	ldw	r3,28(r2)
 203f844:	e0bfff17 	ldw	r2,-4(fp)
 203f848:	10800617 	ldw	r2,24(r2)
 203f84c:	1809883a 	mov	r4,r3
 203f850:	100b883a 	mov	r5,r2
 203f854:	20440e40 	call	20440e4 <lookup_mcast>
 203f858:	e0bff715 	stw	r2,-36(fp)
      if ((inm != NULL) &&
 203f85c:	e0bff717 	ldw	r2,-36(fp)
 203f860:	10001d26 	beq	r2,zero,203f8d8 <ip_write_internal+0x2a0>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 203f864:	e0bfff17 	ldw	r2,-4(fp)
 203f868:	10800b17 	ldw	r2,44(r2)
       * on the outgoing interface, and the caller did not
       * forbid loopback, put a copy of the packet on the
       * received queue.
       */
      inm = lookup_mcast(p->fhost, p->net);
      if ((inm != NULL) &&
 203f86c:	10000526 	beq	r2,zero,203f884 <ip_write_internal+0x24c>
          ((p->imo == NULL) || p->imo->imo_multicast_loop)) 
 203f870:	e0bfff17 	ldw	r2,-4(fp)
 203f874:	10800b17 	ldw	r2,44(r2)
 203f878:	10800143 	ldbu	r2,5(r2)
 203f87c:	10803fcc 	andi	r2,r2,255
 203f880:	10001526 	beq	r2,zero,203f8d8 <ip_write_internal+0x2a0>
      {
         p->type = IPTP;
 203f884:	e0bfff17 	ldw	r2,-4(fp)
 203f888:	00c00204 	movi	r3,8
 203f88c:	10c0080d 	sth	r3,32(r2)
         pkt2 = ip_copypkt(p);
 203f890:	e13fff17 	ldw	r4,-4(fp)
 203f894:	20413040 	call	2041304 <ip_copypkt>
 203f898:	e0bff815 	stw	r2,-32(fp)
         if (pkt2)
 203f89c:	e0bff817 	ldw	r2,-32(fp)
 203f8a0:	10000d26 	beq	r2,zero,203f8d8 <ip_write_internal+0x2a0>
         {
            LOCK_NET_RESOURCE(RXQ_RESID);
 203f8a4:	01000044 	movi	r4,1
 203f8a8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            putq(&rcvdq, (q_elt)pkt2);
 203f8ac:	01009934 	movhi	r4,612
 203f8b0:	2134fc04 	addi	r4,r4,-11280
 203f8b4:	e17ff817 	ldw	r5,-32(fp)
 203f8b8:	20282880 	call	2028288 <putq>
            UNLOCK_NET_RESOURCE(RXQ_RESID);
 203f8bc:	01000044 	movi	r4,1
 203f8c0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            SignalPktDemux();
 203f8c4:	00808174 	movhi	r2,517
 203f8c8:	1090cc04 	addi	r2,r2,17200
 203f8cc:	10800017 	ldw	r2,0(r2)
 203f8d0:	1009883a 	mov	r4,r2
 203f8d4:	201c3f80 	call	201c3f8 <OSSemPost>
       * Also, multicasts addressed to the loopback interface
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
 203f8d8:	e0bfff17 	ldw	r2,-4(fp)
 203f8dc:	10800317 	ldw	r2,12(r2)
 203f8e0:	e0bff915 	stw	r2,-28(fp)
      if ((pip->ip_time == 0) || 
 203f8e4:	e0bff917 	ldw	r2,-28(fp)
 203f8e8:	10800203 	ldbu	r2,8(r2)
 203f8ec:	10803fcc 	andi	r2,r2,255
 203f8f0:	10000b26 	beq	r2,zero,203f920 <ip_write_internal+0x2e8>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 203f8f4:	e0bfff17 	ldw	r2,-4(fp)
 203f8f8:	10800717 	ldw	r2,28(r2)
 203f8fc:	10803fcc 	andi	r2,r2,255
       * are not sent -- a copy will already have been looped
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
 203f900:	10801fe0 	cmpeqi	r2,r2,127
 203f904:	1000061e 	bne	r2,zero,203f920 <ip_write_internal+0x2e8>
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
          (p->fhost == p->net->n_ipaddr))
 203f908:	e0bfff17 	ldw	r2,-4(fp)
 203f90c:	10c00717 	ldw	r3,28(r2)
 203f910:	e0bfff17 	ldw	r2,-4(fp)
 203f914:	10800617 	ldw	r2,24(r2)
 203f918:	10800a17 	ldw	r2,40(r2)
       * back above if this host actually belongs to the
       * destination group on the loopback interface.
       */
      pip = (struct ip *)(p->nb_prot);
      if ((pip->ip_time == 0) || 
          ((p->fhost & htonl(0xFF000000)) == IPLBA) || 
 203f91c:	1880081e 	bne	r3,r2,203f940 <ip_write_internal+0x308>
          (p->fhost == p->net->n_ipaddr))
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 203f920:	01000084 	movi	r4,2
 203f924:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 203f928:	e13fff17 	ldw	r4,-4(fp)
 203f92c:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203f930:	01000084 	movi	r4,2
 203f934:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return(SUCCESS);
 203f938:	0005883a 	mov	r2,zero
 203f93c:	00010906 	br	203fd64 <ip_write_internal+0x72c>
      }

      firsthop = p->fhost;
 203f940:	e0bfff17 	ldw	r2,-4(fp)
 203f944:	10800717 	ldw	r2,28(r2)
 203f948:	e0bffe15 	stw	r2,-8(fp)

      goto sendit;
 203f94c:	00004106 	br	203fa54 <ip_write_internal+0x41c>
   }

#endif /* IP_MULTICAST */

   /* if this is a broadcast packet, use the caller-selected network */
   if (p->fhost == 0xFFFFFFFF)
 203f950:	e0bfff17 	ldw	r2,-4(fp)
 203f954:	10800717 	ldw	r2,28(r2)
 203f958:	10bfffd8 	cmpnei	r2,r2,-1
 203f95c:	1000041e 	bne	r2,zero,203f970 <ip_write_internal+0x338>
   {
      firsthop = p->fhost;
 203f960:	e0bfff17 	ldw	r2,-4(fp)
 203f964:	10800717 	ldw	r2,28(r2)
 203f968:	e0bffe15 	stw	r2,-8(fp)
 203f96c:	00003906 	br	203fa54 <ip_write_internal+0x41c>
   }
   else
   {
      p->net = iproute(p->fhost, &firsthop);
 203f970:	e0bfff17 	ldw	r2,-4(fp)
 203f974:	10c00717 	ldw	r3,28(r2)
 203f978:	e0bffe04 	addi	r2,fp,-8
 203f97c:	1809883a 	mov	r4,r3
 203f980:	100b883a 	mov	r5,r2
 203f984:	20410e40 	call	20410e4 <iproute>
 203f988:	e0ffff17 	ldw	r3,-4(fp)
 203f98c:	18800615 	stw	r2,24(r3)
      if (p->net == NULL)
 203f990:	e0bfff17 	ldw	r2,-4(fp)
 203f994:	10800617 	ldw	r2,24(r2)
 203f998:	10002e1e 	bne	r2,zero,203fa54 <ip_write_internal+0x41c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
 203f99c:	00808174 	movhi	r2,517
 203f9a0:	1090b204 	addi	r2,r2,17096
 203f9a4:	10800017 	ldw	r2,0(r2)
 203f9a8:	1080840c 	andi	r2,r2,528
 203f9ac:	10001a26 	beq	r2,zero,203fa18 <ip_write_internal+0x3e0>
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f9b0:	e0bfff17 	ldw	r2,-4(fp)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f9b4:	10c00417 	ldw	r3,16(r2)
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f9b8:	e0bfff17 	ldw	r2,-4(fp)
 203f9bc:	10800717 	ldw	r2,28(r2)
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f9c0:	10803fcc 	andi	r2,r2,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f9c4:	e13fff17 	ldw	r4,-4(fp)
 203f9c8:	21000717 	ldw	r4,28(r4)
 203f9cc:	2008d23a 	srli	r4,r4,8
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f9d0:	21803fcc 	andi	r6,r4,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f9d4:	e13fff17 	ldw	r4,-4(fp)
 203f9d8:	21000717 	ldw	r4,28(r4)
 203f9dc:	2008d43a 	srli	r4,r4,16
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f9e0:	21403fcc 	andi	r5,r4,255
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
 203f9e4:	e13fff17 	ldw	r4,-4(fp)
 203f9e8:	21000717 	ldw	r4,28(r4)
 203f9ec:	2008d63a 	srli	r4,r4,24
      if (p->net == NULL)
      {
#ifdef   NPDEBUG
         if (NDEBUG & (IPTRACE|PROTERR))
         {
            dprintf("ip_write_internal: pkt:%p len%u to %u.%u.%u.%u, can't route\n",
 203f9f0:	d9800015 	stw	r6,0(sp)
 203f9f4:	d9400115 	stw	r5,4(sp)
 203f9f8:	d9000215 	stw	r4,8(sp)
 203f9fc:	01008174 	movhi	r4,517
 203fa00:	21054904 	addi	r4,r4,5412
 203fa04:	e17fff17 	ldw	r5,-4(fp)
 203fa08:	180d883a 	mov	r6,r3
 203fa0c:	100f883a 	mov	r7,r2
 203fa10:	2006a240 	call	2006a24 <printf>
                    p, p->nb_plen, PUSH_IPADDR(p->fhost));
            dtrap();
 203fa14:	20285c80 	call	20285c8 <dtrap>
         }
#endif   /* NPDEBUG */
         ip_mib.ipOutNoRoutes++;
 203fa18:	00809934 	movhi	r2,612
 203fa1c:	10b7d304 	addi	r2,r2,-8372
 203fa20:	10800b17 	ldw	r2,44(r2)
 203fa24:	10c00044 	addi	r3,r2,1
 203fa28:	00809934 	movhi	r2,612
 203fa2c:	10b7d304 	addi	r2,r2,-8372
 203fa30:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 203fa34:	01000084 	movi	r4,2
 203fa38:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 203fa3c:	e13fff17 	ldw	r4,-4(fp)
 203fa40:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203fa44:	01000084 	movi	r4,2
 203fa48:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NO_ROUTE);
 203fa4c:	00bff7c4 	movi	r2,-33
 203fa50:	0000c406 	br	203fd64 <ip_write_internal+0x72c>
#ifdef   IP_MULTICAST
sendit:  /* label used for multicast packets to skip routing logic */
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
 203fa54:	00808174 	movhi	r2,517
 203fa58:	1090b204 	addi	r2,r2,17096
 203fa5c:	10800017 	ldw	r2,0(r2)
 203fa60:	1080800c 	andi	r2,r2,512
 203fa64:	10002726 	beq	r2,zero,203fb04 <ip_write_internal+0x4cc>
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
       p->nb_plen, PUSH_IPADDR(p->fhost));
 203fa68:	e0bfff17 	ldw	r2,-4(fp)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 203fa6c:	11400417 	ldw	r5,16(r2)
       p->nb_plen, PUSH_IPADDR(p->fhost));
 203fa70:	e0bfff17 	ldw	r2,-4(fp)
 203fa74:	10800717 	ldw	r2,28(r2)
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 203fa78:	10c03fcc 	andi	r3,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 203fa7c:	e0bfff17 	ldw	r2,-4(fp)
 203fa80:	10800717 	ldw	r2,28(r2)
 203fa84:	1004d23a 	srli	r2,r2,8
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 203fa88:	10803fcc 	andi	r2,r2,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 203fa8c:	e13fff17 	ldw	r4,-4(fp)
 203fa90:	21000717 	ldw	r4,28(r4)
 203fa94:	2008d43a 	srli	r4,r4,16
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 203fa98:	21803fcc 	andi	r6,r4,255
       p->nb_plen, PUSH_IPADDR(p->fhost));
 203fa9c:	e13fff17 	ldw	r4,-4(fp)
 203faa0:	21000717 	ldw	r4,28(r4)
 203faa4:	2008d63a 	srli	r4,r4,24
#endif   /* IP_MULTICAST */

#ifdef   NPDEBUG
   if (NDEBUG & IPTRACE)
   {
      dprintf("ip_write: pkt[%u] to %u.%u.%u.%u,", 
 203faa8:	d9800015 	stw	r6,0(sp)
 203faac:	d9000115 	stw	r4,4(sp)
 203fab0:	01008174 	movhi	r4,517
 203fab4:	21055904 	addi	r4,r4,5476
 203fab8:	180d883a 	mov	r6,r3
 203fabc:	100f883a 	mov	r7,r2
 203fac0:	2006a240 	call	2006a24 <printf>
       p->nb_plen, PUSH_IPADDR(p->fhost));
      dprintf(" route %u.%u.%u.%u\n", PUSH_IPADDR(firsthop));
 203fac4:	e0bffe17 	ldw	r2,-8(fp)
 203fac8:	11403fcc 	andi	r5,r2,255
 203facc:	e0bffe17 	ldw	r2,-8(fp)
 203fad0:	1004d23a 	srli	r2,r2,8
 203fad4:	10c03fcc 	andi	r3,r2,255
 203fad8:	e0bffe17 	ldw	r2,-8(fp)
 203fadc:	1004d43a 	srli	r2,r2,16
 203fae0:	10803fcc 	andi	r2,r2,255
 203fae4:	e13ffe17 	ldw	r4,-8(fp)
 203fae8:	2008d63a 	srli	r4,r4,24
 203faec:	d9000015 	stw	r4,0(sp)
 203faf0:	01008174 	movhi	r4,517
 203faf4:	21056204 	addi	r4,r4,5512
 203faf8:	180d883a 	mov	r6,r3
 203fafc:	100f883a 	mov	r7,r2
 203fb00:	2006a240 	call	2006a24 <printf>
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 203fb04:	e0bfff17 	ldw	r2,-4(fp)
 203fb08:	10800617 	ldw	r2,24(r2)
 203fb0c:	10c00a17 	ldw	r3,40(r2)
 203fb10:	e0bfff17 	ldw	r2,-4(fp)
 203fb14:	10800717 	ldw	r2,28(r2)
 203fb18:	1880291e 	bne	r3,r2,203fbc0 <ip_write_internal+0x588>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
 203fb1c:	e0bfff17 	ldw	r2,-4(fp)
 203fb20:	10800717 	ldw	r2,28(r2)
 203fb24:	10803fcc 	andi	r2,r2,255
#endif   /* IPSEC */

   /* If the packet is being sent to the same interface it will be sent
    * from, short-cut things and just put it on the received queue.
    */
   if ((p->net->n_ipaddr == p->fhost) &&
 203fb28:	10801fe0 	cmpeqi	r2,r2,127
 203fb2c:	1000241e 	bne	r2,zero,203fbc0 <ip_write_internal+0x588>
       ((p->fhost & htonl(0xff000000)) != htonl(0x7f000000)))
   {
      if (!(p->net->n_flags & NF_NBPROT))
 203fb30:	e0bfff17 	ldw	r2,-4(fp)
 203fb34:	10800617 	ldw	r2,24(r2)
 203fb38:	10802a17 	ldw	r2,168(r2)
 203fb3c:	1080020c 	andi	r2,r2,8
 203fb40:	1000091e 	bne	r2,zero,203fb68 <ip_write_internal+0x530>
          * IP or ARP protocol header) and nb_type to the protocol
          * type, and set the NF_NBPROT flag in its interfaces'
          * n_flags fields.
          */
#ifdef NPDEBUG
         dtrap();
 203fb44:	20285c80 	call	20285c8 <dtrap>
#endif
         LOCK_NET_RESOURCE(FREEQ_RESID);
 203fb48:	01000084 	movi	r4,2
 203fb4c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 203fb50:	e13fff17 	ldw	r4,-4(fp)
 203fb54:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203fb58:	01000084 	movi	r4,2
 203fb5c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_LOGIC;
 203fb60:	00bffd44 	movi	r2,-11
 203fb64:	00007f06 	br	203fd64 <ip_write_internal+0x72c>
      }
      p->type = IPTP;
 203fb68:	e0bfff17 	ldw	r2,-4(fp)
 203fb6c:	00c00204 	movi	r3,8
 203fb70:	10c0080d 	sth	r3,32(r2)
      UNLOCK_NET_RESOURCE(NET_RESID);
 203fb74:	0009883a 	mov	r4,zero
 203fb78:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(RXQ_RESID);
 203fb7c:	01000044 	movi	r4,1
 203fb80:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      putq(&rcvdq, (q_elt)p);
 203fb84:	01009934 	movhi	r4,612
 203fb88:	2134fc04 	addi	r4,r4,-11280
 203fb8c:	e17fff17 	ldw	r5,-4(fp)
 203fb90:	20282880 	call	2028288 <putq>
      UNLOCK_NET_RESOURCE(RXQ_RESID);
 203fb94:	01000044 	movi	r4,1
 203fb98:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      LOCK_NET_RESOURCE(NET_RESID);
 203fb9c:	0009883a 	mov	r4,zero
 203fba0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);

      SignalPktDemux();
 203fba4:	00808174 	movhi	r2,517
 203fba8:	1090cc04 	addi	r2,r2,17200
 203fbac:	10800017 	ldw	r2,0(r2)
 203fbb0:	1009883a 	mov	r4,r2
 203fbb4:	201c3f80 	call	201c3f8 <OSSemPost>

      return SUCCESS;
 203fbb8:	0005883a 	mov	r2,zero
 203fbbc:	00006906 	br	203fd64 <ip_write_internal+0x72c>
   }

   /* determine if the buffer that needs to be transmitted is interrupt-safe */
   intrsafe_buf = ((p->flags & PKF_INTRUNSAFE) ? 0 : 1);
 203fbc0:	e0bfff17 	ldw	r2,-4(fp)
 203fbc4:	10800a17 	ldw	r2,40(r2)
 203fbc8:	1080040c 	andi	r2,r2,16
 203fbcc:	1005003a 	cmpeq	r2,r2,zero
 203fbd0:	e0bffa05 	stb	r2,-24(fp)
   /* obtain the length of the largest interrupt-safe buffer that can be 
    * allocated via pk_alloc () */
   maxbuflen = pk_get_max_intrsafe_buf_len ();
 203fbd4:	20280f40 	call	20280f4 <pk_get_max_intrsafe_buf_len>
 203fbd8:	e0bffb15 	stw	r2,-20(fp)
    * the original buffer is interrupt-safe, we just need to consider the
    * MTU of the egress interface.  If the original buffer is interrupt-
    * unsafe, we compute the MIN of the largest interrupt-safe buffer that
    * we can use and the MTU of the egress interface (since we must satisfy
    * both constraints) */
   if (!intrsafe_buf)
 203fbdc:	e0bffa03 	ldbu	r2,-24(fp)
 203fbe0:	1000081e 	bne	r2,zero,203fc04 <ip_write_internal+0x5cc>
       limit = MIN(maxbuflen,p->net->n_mtu);
 203fbe4:	e0bfff17 	ldw	r2,-4(fp)
 203fbe8:	10800617 	ldw	r2,24(r2)
 203fbec:	10800917 	ldw	r2,36(r2)
 203fbf0:	e0fffb17 	ldw	r3,-20(fp)
 203fbf4:	1880012e 	bgeu	r3,r2,203fbfc <ip_write_internal+0x5c4>
 203fbf8:	1805883a 	mov	r2,r3
 203fbfc:	e0bff615 	stw	r2,-40(fp)
 203fc00:	00000406 	br	203fc14 <ip_write_internal+0x5dc>
   else
       limit = p->net->n_mtu;
 203fc04:	e0bfff17 	ldw	r2,-4(fp)
 203fc08:	10800617 	ldw	r2,24(r2)
 203fc0c:	10800917 	ldw	r2,36(r2)
 203fc10:	e0bff615 	stw	r2,-40(fp)

   if ((p->nb_plen + p->net->n_lnh) > limit)
 203fc14:	e0bfff17 	ldw	r2,-4(fp)
 203fc18:	10c00417 	ldw	r3,16(r2)
 203fc1c:	e0bfff17 	ldw	r2,-4(fp)
 203fc20:	10800617 	ldw	r2,24(r2)
 203fc24:	10800817 	ldw	r2,32(r2)
 203fc28:	1885883a 	add	r2,r3,r2
 203fc2c:	e0fff617 	ldw	r3,-40(fp)
 203fc30:	1880072e 	bgeu	r3,r2,203fc50 <ip_write_internal+0x618>
   {
#ifdef IP_FRAGMENTS
      int err;
      err = ip_fragment(p, firsthop);
 203fc34:	e0bffe17 	ldw	r2,-8(fp)
 203fc38:	e13fff17 	ldw	r4,-4(fp)
 203fc3c:	100b883a 	mov	r5,r2
 203fc40:	20407e40 	call	20407e4 <ip_fragment>
 203fc44:	e0bffc15 	stw	r2,-16(fp)
      IN_PROFILER(PF_IP, PF_EXIT);
      return(err);
 203fc48:	e0bffc17 	ldw	r2,-16(fp)
 203fc4c:	00004506 	br	203fd64 <ip_write_internal+0x72c>
   }
   else
   {
      /* fragmentation is not required; check to see if we need to copy out of
       * an interrupt-unsafe buffer */ 
      if (!intrsafe_buf)
 203fc50:	e0bffa03 	ldbu	r2,-24(fp)
 203fc54:	10003f1e 	bne	r2,zero,203fd54 <ip_write_internal+0x71c>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 203fc58:	01000084 	movi	r4,2
 203fc5c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         newpkt = pk_alloc(p->nb_plen + p->net->n_lnh);
 203fc60:	e0bfff17 	ldw	r2,-4(fp)
 203fc64:	10c00417 	ldw	r3,16(r2)
 203fc68:	e0bfff17 	ldw	r2,-4(fp)
 203fc6c:	10800617 	ldw	r2,24(r2)
 203fc70:	10800817 	ldw	r2,32(r2)
 203fc74:	1885883a 	add	r2,r3,r2
 203fc78:	1009883a 	mov	r4,r2
 203fc7c:	2027cec0 	call	2027cec <pk_alloc>
 203fc80:	e0bffd15 	stw	r2,-12(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203fc84:	01000084 	movi	r4,2
 203fc88:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         if (newpkt == 0)
 203fc8c:	e0bffd17 	ldw	r2,-12(fp)
 203fc90:	1000081e 	bne	r2,zero,203fcb4 <ip_write_internal+0x67c>
         {
            /* can't allocate interrupt-safe buffer, so free the packet that 
             * we are working with */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 203fc94:	01000084 	movi	r4,2
 203fc98:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(p);
 203fc9c:	e13fff17 	ldw	r4,-4(fp)
 203fca0:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203fca4:	01000084 	movi	r4,2
 203fca8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NOBUFFER;
 203fcac:	00bffac4 	movi	r2,-21
 203fcb0:	00002c06 	br	203fd64 <ip_write_internal+0x72c>
         }
         else
         {
            /* copy from interrupt-unsafe buffer into interrupt-safe buffer */
            newpkt->nb_prot = newpkt->nb_buff + p->net->n_lnh;
 203fcb4:	e0bffd17 	ldw	r2,-12(fp)
 203fcb8:	10c00117 	ldw	r3,4(r2)
 203fcbc:	e0bfff17 	ldw	r2,-4(fp)
 203fcc0:	10800617 	ldw	r2,24(r2)
 203fcc4:	10800817 	ldw	r2,32(r2)
 203fcc8:	1887883a 	add	r3,r3,r2
 203fccc:	e0bffd17 	ldw	r2,-12(fp)
 203fcd0:	10c00315 	stw	r3,12(r2)
            MEMCPY(newpkt->nb_prot, p->nb_prot, p->nb_plen);
 203fcd4:	e0bffd17 	ldw	r2,-12(fp)
 203fcd8:	11000317 	ldw	r4,12(r2)
 203fcdc:	e0bfff17 	ldw	r2,-4(fp)
 203fce0:	10c00317 	ldw	r3,12(r2)
 203fce4:	e0bfff17 	ldw	r2,-4(fp)
 203fce8:	10800417 	ldw	r2,16(r2)
 203fcec:	180b883a 	mov	r5,r3
 203fcf0:	100d883a 	mov	r6,r2
 203fcf4:	200660c0 	call	200660c <memcpy>
            /* setup various fields in the newly allocated PACKET structure */
            newpkt->nb_plen = p->nb_plen;
 203fcf8:	e0bfff17 	ldw	r2,-4(fp)
 203fcfc:	10c00417 	ldw	r3,16(r2)
 203fd00:	e0bffd17 	ldw	r2,-12(fp)
 203fd04:	10c00415 	stw	r3,16(r2)
            newpkt->net = p->net;
 203fd08:	e0bfff17 	ldw	r2,-4(fp)
 203fd0c:	10c00617 	ldw	r3,24(r2)
 203fd10:	e0bffd17 	ldw	r2,-12(fp)
 203fd14:	10c00615 	stw	r3,24(r2)
            newpkt->fhost = p->fhost;
 203fd18:	e0bfff17 	ldw	r2,-4(fp)
 203fd1c:	10c00717 	ldw	r3,28(r2)
 203fd20:	e0bffd17 	ldw	r2,-12(fp)
 203fd24:	10c00715 	stw	r3,28(r2)
            /* free the original packet since it is no longer needed */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 203fd28:	01000084 	movi	r4,2
 203fd2c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(p);
 203fd30:	e13fff17 	ldw	r4,-4(fp)
 203fd34:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 203fd38:	01000084 	movi	r4,2
 203fd3c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            /* send packet to MAC layer. This will try to resolve MAC layer addressing 
             * and send packet. ip2mac() can return SUCCESS, PENDING, or error codes. 
             */
            return(ip2mac(newpkt, firsthop));
 203fd40:	e0bffe17 	ldw	r2,-8(fp)
 203fd44:	e13ffd17 	ldw	r4,-12(fp)
 203fd48:	100b883a 	mov	r5,r2
 203fd4c:	20246400 	call	2024640 <ip2mac>
 203fd50:	00000406 	br	203fd64 <ip_write_internal+0x72c>
      else
      {
         /* since the packet is in an interrupt-safe buffer, it can be passed to 
          * ip2mac () without any additional work. */
         IN_PROFILER(PF_IP, PF_EXIT);
         return(ip2mac(p, firsthop));
 203fd54:	e0bffe17 	ldw	r2,-8(fp)
 203fd58:	e13fff17 	ldw	r4,-4(fp)
 203fd5c:	100b883a 	mov	r5,r2
 203fd60:	20246400 	call	2024640 <ip2mac>
      }
   }
}
 203fd64:	e037883a 	mov	sp,fp
 203fd68:	dfc00117 	ldw	ra,4(sp)
 203fd6c:	df000017 	ldw	fp,0(sp)
 203fd70:	dec00204 	addi	sp,sp,8
 203fd74:	f800283a 	ret

0203fd78 <ip_write>:

int
ip_write(
   u_char   prot,
   PACKET   p)
{
 203fd78:	defff904 	addi	sp,sp,-28
 203fd7c:	dfc00615 	stw	ra,24(sp)
 203fd80:	df000515 	stw	fp,20(sp)
 203fd84:	df000504 	addi	fp,sp,20
 203fd88:	2005883a 	mov	r2,r4
 203fd8c:	e17fff15 	stw	r5,-4(fp)
 203fd90:	e0bffe05 	stb	r2,-8(fp)
   u_char ttl;
   struct ip_socopts *sopts;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 203fd94:	00809934 	movhi	r2,612
 203fd98:	10b7d304 	addi	r2,r2,-8372
 203fd9c:	10800917 	ldw	r2,36(r2)
 203fda0:	10c00044 	addi	r3,r2,1
 203fda4:	00809934 	movhi	r2,612
 203fda8:	10b7d304 	addi	r2,r2,-8372
 203fdac:	10c00915 	stw	r3,36(r2)

   /* make room for IP header, and form a pointer to it (pip) */
   p->nb_prot -= sizeof(struct ip);
 203fdb0:	e0bfff17 	ldw	r2,-4(fp)
 203fdb4:	10800317 	ldw	r2,12(r2)
 203fdb8:	10fffb04 	addi	r3,r2,-20
 203fdbc:	e0bfff17 	ldw	r2,-4(fp)
 203fdc0:	10c00315 	stw	r3,12(r2)
   p->nb_plen += sizeof(struct ip);
 203fdc4:	e0bfff17 	ldw	r2,-4(fp)
 203fdc8:	10800417 	ldw	r2,16(r2)
 203fdcc:	10c00504 	addi	r3,r2,20
 203fdd0:	e0bfff17 	ldw	r2,-4(fp)
 203fdd4:	10c00415 	stw	r3,16(r2)
   pip = (struct ip*)(p->nb_prot);
 203fdd8:	e0bfff17 	ldw	r2,-4(fp)
 203fddc:	10800317 	ldw	r2,12(r2)
 203fde0:	e0bffc15 	stw	r2,-16(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = 0x45;       /* 2 nibbles; VER:4, IHL:5. */
 203fde4:	e0bffc17 	ldw	r2,-16(fp)
 203fde8:	00c01144 	movi	r3,69
 203fdec:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0;        /* clear fragmentation info field */
 203fdf0:	e0bffc17 	ldw	r2,-16(fp)
 203fdf4:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 203fdf8:	d0a05517 	ldw	r2,-32428(gp)
 203fdfc:	10bfffcc 	andi	r2,r2,65535
 203fe00:	1004d23a 	srli	r2,r2,8
 203fe04:	1007883a 	mov	r3,r2
 203fe08:	d0a05517 	ldw	r2,-32428(gp)
 203fe0c:	10bfffcc 	andi	r2,r2,65535
 203fe10:	1004923a 	slli	r2,r2,8
 203fe14:	1884b03a 	or	r2,r3,r2
 203fe18:	1007883a 	mov	r3,r2
 203fe1c:	e0bffc17 	ldw	r2,-16(fp)
 203fe20:	10c0010d 	sth	r3,4(r2)
   uid++;
 203fe24:	d0a05517 	ldw	r2,-32428(gp)
 203fe28:	10800044 	addi	r2,r2,1
 203fe2c:	d0a05515 	stw	r2,-32428(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 203fe30:	e0bfff17 	ldw	r2,-4(fp)
 203fe34:	10800417 	ldw	r2,16(r2)
 203fe38:	10bfffcc 	andi	r2,r2,65535
 203fe3c:	1004d23a 	srli	r2,r2,8
 203fe40:	1007883a 	mov	r3,r2
 203fe44:	e0bfff17 	ldw	r2,-4(fp)
 203fe48:	10800417 	ldw	r2,16(r2)
 203fe4c:	10bfffcc 	andi	r2,r2,65535
 203fe50:	1004923a 	slli	r2,r2,8
 203fe54:	1884b03a 	or	r2,r3,r2
 203fe58:	1007883a 	mov	r3,r2
 203fe5c:	e0bffc17 	ldw	r2,-16(fp)
 203fe60:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 203fe64:	e0bffc17 	ldw	r2,-16(fp)
 203fe68:	e0fffe03 	ldbu	r3,-8(fp)
 203fe6c:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 203fe70:	e0bffc17 	ldw	r2,-16(fp)
 203fe74:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 203fe78:	00801004 	movi	r2,64
 203fe7c:	e0bffb05 	stb	r2,-20(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 203fe80:	e0bfff17 	ldw	r2,-4(fp)
 203fe84:	10800717 	ldw	r2,28(r2)
 203fe88:	1006d63a 	srli	r3,r2,24
 203fe8c:	e0bfff17 	ldw	r2,-4(fp)
 203fe90:	10800717 	ldw	r2,28(r2)
 203fe94:	1004d23a 	srli	r2,r2,8
 203fe98:	10bfc00c 	andi	r2,r2,65280
 203fe9c:	1886b03a 	or	r3,r3,r2
 203fea0:	e0bfff17 	ldw	r2,-4(fp)
 203fea4:	10800717 	ldw	r2,28(r2)
 203fea8:	10bfc00c 	andi	r2,r2,65280
 203feac:	1004923a 	slli	r2,r2,8
 203feb0:	1886b03a 	or	r3,r3,r2
 203feb4:	e0bfff17 	ldw	r2,-4(fp)
 203feb8:	10800717 	ldw	r2,28(r2)
 203febc:	1004963a 	slli	r2,r2,24
 203fec0:	1884b03a 	or	r2,r3,r2
 203fec4:	10fc002c 	andhi	r3,r2,61440
 203fec8:	00b80034 	movhi	r2,57344
 203fecc:	1880071e 	bne	r3,r2,203feec <ip_write+0x174>
 203fed0:	e0bfff17 	ldw	r2,-4(fp)
 203fed4:	10800b17 	ldw	r2,44(r2)
 203fed8:	10000426 	beq	r2,zero,203feec <ip_write+0x174>
      ttl = p->imo->imo_multicast_ttl;
 203fedc:	e0bfff17 	ldw	r2,-4(fp)
 203fee0:	10800b17 	ldw	r2,44(r2)
 203fee4:	10800103 	ldbu	r2,4(r2)
 203fee8:	e0bffb05 	stb	r2,-20(fp)
#endif /* IP_MULTICAST */

   /* have IP_TOS or IP_TTL been set? */
   if ((sopts = p->soxopts))
 203feec:	e0bfff17 	ldw	r2,-4(fp)
 203fef0:	10800c17 	ldw	r2,48(r2)
 203fef4:	e0bffd15 	stw	r2,-12(fp)
 203fef8:	e0bffd17 	ldw	r2,-12(fp)
 203fefc:	10001126 	beq	r2,zero,203ff44 <ip_write+0x1cc>
   {
	  /* yup */
	  if (sopts->ip_ttl)
 203ff00:	e0bffd17 	ldw	r2,-12(fp)
 203ff04:	10800043 	ldbu	r2,1(r2)
 203ff08:	10803fcc 	andi	r2,r2,255
 203ff0c:	10000526 	beq	r2,zero,203ff24 <ip_write+0x1ac>
         pip->ip_time = sopts->ip_ttl;
 203ff10:	e0bffd17 	ldw	r2,-12(fp)
 203ff14:	10c00043 	ldbu	r3,1(r2)
 203ff18:	e0bffc17 	ldw	r2,-16(fp)
 203ff1c:	10c00205 	stb	r3,8(r2)
 203ff20:	00000306 	br	203ff30 <ip_write+0x1b8>
	  else
         pip->ip_time = ttl;
 203ff24:	e0bffc17 	ldw	r2,-16(fp)
 203ff28:	e0fffb03 	ldbu	r3,-20(fp)
 203ff2c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 203ff30:	e0bffd17 	ldw	r2,-12(fp)
 203ff34:	10c00003 	ldbu	r3,0(r2)
 203ff38:	e0bffc17 	ldw	r2,-16(fp)
 203ff3c:	10c00045 	stb	r3,1(r2)
 203ff40:	00000506 	br	203ff58 <ip_write+0x1e0>
   }
   else
   {
	  /* nope */
      pip->ip_time = ttl;
 203ff44:	e0bffc17 	ldw	r2,-16(fp)
 203ff48:	e0fffb03 	ldbu	r3,-20(fp)
 203ff4c:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 203ff50:	e0bffc17 	ldw	r2,-16(fp)
 203ff54:	10000045 	stb	zero,1(r2)
   }
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum(pip, 10);
 203ff58:	e13ffc17 	ldw	r4,-16(fp)
 203ff5c:	01400284 	movi	r5,10
 203ff60:	20268040 	call	2026804 <cksum>
 203ff64:	0084303a 	nor	r2,zero,r2
 203ff68:	1007883a 	mov	r3,r2
 203ff6c:	e0bffc17 	ldw	r2,-16(fp)
 203ff70:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 203ff74:	e13fff17 	ldw	r4,-4(fp)
 203ff78:	203f6380 	call	203f638 <ip_write_internal>
}
 203ff7c:	e037883a 	mov	sp,fp
 203ff80:	dfc00117 	ldw	ra,4(sp)
 203ff84:	df000017 	ldw	fp,0(sp)
 203ff88:	dec00204 	addi	sp,sp,8
 203ff8c:	f800283a 	ret

0203ff90 <ip_write2>:
 * OUTPUT: This function returns the return code from 
 *         ip_write_internal ().
 */

int ip_write2 (u_char prot, PACKET p, u_char * optp)
{
 203ff90:	defff604 	addi	sp,sp,-40
 203ff94:	dfc00915 	stw	ra,36(sp)
 203ff98:	df000815 	stw	fp,32(sp)
 203ff9c:	df000804 	addi	fp,sp,32
 203ffa0:	2005883a 	mov	r2,r4
 203ffa4:	e17ffe15 	stw	r5,-8(fp)
 203ffa8:	e1bfff15 	stw	r6,-4(fp)
 203ffac:	e0bffd05 	stb	r2,-12(fp)
   struct ip * pip;
   u_char ttl;
   struct ip_socopts * sopts;
   u_char iphlen = sizeof (struct ip);
 203ffb0:	00800504 	movi	r2,20
 203ffb4:	e0bff845 	stb	r2,-31(fp)
   u_char iphlen_pad;
   u_char i;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 203ffb8:	00809934 	movhi	r2,612
 203ffbc:	10b7d304 	addi	r2,r2,-8372
 203ffc0:	10800917 	ldw	r2,36(r2)
 203ffc4:	10c00044 	addi	r3,r2,1
 203ffc8:	00809934 	movhi	r2,612
 203ffcc:	10b7d304 	addi	r2,r2,-8372
 203ffd0:	10c00915 	stw	r3,36(r2)

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 203ffd4:	e0bfff17 	ldw	r2,-4(fp)
 203ffd8:	e0bff915 	stw	r2,-28(fp)
 203ffdc:	00000d06 	br	2040014 <ip_write2+0x84>
   {
      /* account for options, if any (caller has already created
       * adequate space for the requested option) */
      switch (*tmpp)
 203ffe0:	e0bff917 	ldw	r2,-28(fp)
 203ffe4:	10800003 	ldbu	r2,0(r2)
 203ffe8:	10803fcc 	andi	r2,r2,255
 203ffec:	10800520 	cmpeqi	r2,r2,20
 203fff0:	10000426 	beq	r2,zero,2040004 <ip_write2+0x74>
      {
         case IP_RTR_ALERT_OPT:
            iphlen += IP_RTR_ALERT_OPT_SIZE;
 203fff4:	e0bff843 	ldbu	r2,-31(fp)
 203fff8:	10800104 	addi	r2,r2,4
 203fffc:	e0bff845 	stb	r2,-31(fp)
            break;
 2040000:	00000106 	br	2040008 <ip_write2+0x78>
         default:
            break;
 2040004:	0001883a 	nop
   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;

   /* compute the total length of the options requested */
   for (tmpp = optp; (*tmpp) != EOL_OPT; ++tmpp)
 2040008:	e0bff917 	ldw	r2,-28(fp)
 204000c:	10800044 	addi	r2,r2,1
 2040010:	e0bff915 	stw	r2,-28(fp)
 2040014:	e0bff917 	ldw	r2,-28(fp)
 2040018:	10800003 	ldbu	r2,0(r2)
 204001c:	10803fcc 	andi	r2,r2,255
 2040020:	103fef1e 	bne	r2,zero,203ffe0 <ip_write2+0x50>
   }

   /* compute the amount of padding required, if any (to ensure
    * that the IP header (including options) ends on a dword
    * (four byte) boundary */
   if (iphlen & 0x3)
 2040024:	e0bff843 	ldbu	r2,-31(fp)
 2040028:	108000cc 	andi	r2,r2,3
 204002c:	10000626 	beq	r2,zero,2040048 <ip_write2+0xb8>
      iphlen_pad = 4 - (iphlen & 0x3);
 2040030:	e0bff843 	ldbu	r2,-31(fp)
 2040034:	108000cc 	andi	r2,r2,3
 2040038:	00c00104 	movi	r3,4
 204003c:	1885c83a 	sub	r2,r3,r2
 2040040:	e0bffa05 	stb	r2,-24(fp)
 2040044:	00000106 	br	204004c <ip_write2+0xbc>
   else iphlen_pad = 0; /* no header padding required */
 2040048:	e03ffa05 	stb	zero,-24(fp)
   /* the packet passed to ip_write2 () has its nb_prot set to
    * point to start of the protocol's (e.g., IGMP) data, and 
    * nb_plen set to the length of that data.  locate start of 
    * the IP header (account for IP options), and form a pointer 
    * to it (pip) */
   p->nb_prot -= (iphlen + iphlen_pad);
 204004c:	e0bffe17 	ldw	r2,-8(fp)
 2040050:	10c00317 	ldw	r3,12(r2)
 2040054:	e13ff843 	ldbu	r4,-31(fp)
 2040058:	e0bffa03 	ldbu	r2,-24(fp)
 204005c:	2085883a 	add	r2,r4,r2
 2040060:	0085c83a 	sub	r2,zero,r2
 2040064:	1887883a 	add	r3,r3,r2
 2040068:	e0bffe17 	ldw	r2,-8(fp)
 204006c:	10c00315 	stw	r3,12(r2)
   /* add padding length to the total length of the IP datagram */
   p->nb_plen += (iphlen + iphlen_pad);
 2040070:	e0bffe17 	ldw	r2,-8(fp)
 2040074:	10c00417 	ldw	r3,16(r2)
 2040078:	e13ff843 	ldbu	r4,-31(fp)
 204007c:	e0bffa03 	ldbu	r2,-24(fp)
 2040080:	2085883a 	add	r2,r4,r2
 2040084:	1887883a 	add	r3,r3,r2
 2040088:	e0bffe17 	ldw	r2,-8(fp)
 204008c:	10c00415 	stw	r3,16(r2)
   pip = (struct ip *) (p->nb_prot);
 2040090:	e0bffe17 	ldw	r2,-8(fp)
 2040094:	10800317 	ldw	r2,12(r2)
 2040098:	e0bffb15 	stw	r2,-20(fp)

   /* build the initial IP header:
    * IP source address (ip_src) and IP destination address (ip_dest)
    * should already have been filled in by upper-layer protocol
    */
   pip->ip_ver_ihl = ((IP_VER << 4) | ((iphlen + iphlen_pad) >> 2));
 204009c:	e0fff843 	ldbu	r3,-31(fp)
 20400a0:	e0bffa03 	ldbu	r2,-24(fp)
 20400a4:	1885883a 	add	r2,r3,r2
 20400a8:	1005d0ba 	srai	r2,r2,2
 20400ac:	10801014 	ori	r2,r2,64
 20400b0:	1007883a 	mov	r3,r2
 20400b4:	e0bffb17 	ldw	r2,-20(fp)
 20400b8:	10c00005 	stb	r3,0(r2)
   pip->ip_flgs_foff = 0; /* clear fragmentation info field */
 20400bc:	e0bffb17 	ldw	r2,-20(fp)
 20400c0:	1000018d 	sth	zero,6(r2)
   pip->ip_id = htons((unshort)uid);
 20400c4:	d0a05517 	ldw	r2,-32428(gp)
 20400c8:	10bfffcc 	andi	r2,r2,65535
 20400cc:	1004d23a 	srli	r2,r2,8
 20400d0:	1007883a 	mov	r3,r2
 20400d4:	d0a05517 	ldw	r2,-32428(gp)
 20400d8:	10bfffcc 	andi	r2,r2,65535
 20400dc:	1004923a 	slli	r2,r2,8
 20400e0:	1884b03a 	or	r2,r3,r2
 20400e4:	1007883a 	mov	r3,r2
 20400e8:	e0bffb17 	ldw	r2,-20(fp)
 20400ec:	10c0010d 	sth	r3,4(r2)
   uid++;
 20400f0:	d0a05517 	ldw	r2,-32428(gp)
 20400f4:	10800044 	addi	r2,r2,1
 20400f8:	d0a05515 	stw	r2,-32428(gp)
   pip->ip_len = htons((unshort)(p->nb_plen));
 20400fc:	e0bffe17 	ldw	r2,-8(fp)
 2040100:	10800417 	ldw	r2,16(r2)
 2040104:	10bfffcc 	andi	r2,r2,65535
 2040108:	1004d23a 	srli	r2,r2,8
 204010c:	1007883a 	mov	r3,r2
 2040110:	e0bffe17 	ldw	r2,-8(fp)
 2040114:	10800417 	ldw	r2,16(r2)
 2040118:	10bfffcc 	andi	r2,r2,65535
 204011c:	1004923a 	slli	r2,r2,8
 2040120:	1884b03a 	or	r2,r3,r2
 2040124:	1007883a 	mov	r3,r2
 2040128:	e0bffb17 	ldw	r2,-20(fp)
 204012c:	10c0008d 	sth	r3,2(r2)
   pip->ip_prot = prot;
 2040130:	e0bffb17 	ldw	r2,-20(fp)
 2040134:	e0fffd03 	ldbu	r3,-12(fp)
 2040138:	10c00245 	stb	r3,9(r2)
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 204013c:	e0bffb17 	ldw	r2,-20(fp)
 2040140:	1000028d 	sth	zero,10(r2)
   ttl = IP_TTL;
 2040144:	00801004 	movi	r2,64
 2040148:	e0bff805 	stb	r2,-32(fp)
#ifdef IP_MULTICAST
   if ((IN_MULTICAST(ntohl(p->fhost))) && (p->imo != NULL))
 204014c:	e0bffe17 	ldw	r2,-8(fp)
 2040150:	10800717 	ldw	r2,28(r2)
 2040154:	1006d63a 	srli	r3,r2,24
 2040158:	e0bffe17 	ldw	r2,-8(fp)
 204015c:	10800717 	ldw	r2,28(r2)
 2040160:	1004d23a 	srli	r2,r2,8
 2040164:	10bfc00c 	andi	r2,r2,65280
 2040168:	1886b03a 	or	r3,r3,r2
 204016c:	e0bffe17 	ldw	r2,-8(fp)
 2040170:	10800717 	ldw	r2,28(r2)
 2040174:	10bfc00c 	andi	r2,r2,65280
 2040178:	1004923a 	slli	r2,r2,8
 204017c:	1886b03a 	or	r3,r3,r2
 2040180:	e0bffe17 	ldw	r2,-8(fp)
 2040184:	10800717 	ldw	r2,28(r2)
 2040188:	1004963a 	slli	r2,r2,24
 204018c:	1884b03a 	or	r2,r3,r2
 2040190:	10fc002c 	andhi	r3,r2,61440
 2040194:	00b80034 	movhi	r2,57344
 2040198:	1880071e 	bne	r3,r2,20401b8 <ip_write2+0x228>
 204019c:	e0bffe17 	ldw	r2,-8(fp)
 20401a0:	10800b17 	ldw	r2,44(r2)
 20401a4:	10000426 	beq	r2,zero,20401b8 <ip_write2+0x228>
      ttl = p->imo->imo_multicast_ttl;
 20401a8:	e0bffe17 	ldw	r2,-8(fp)
 20401ac:	10800b17 	ldw	r2,44(r2)
 20401b0:	10800103 	ldbu	r2,4(r2)
 20401b4:	e0bff805 	stb	r2,-32(fp)
#endif /* IP_MULTICAST */

   /* have TOS or TTL been set (via socket options)? */
   if ((sopts = p->soxopts))
 20401b8:	e0bffe17 	ldw	r2,-8(fp)
 20401bc:	10800c17 	ldw	r2,48(r2)
 20401c0:	e0bffc15 	stw	r2,-16(fp)
 20401c4:	e0bffc17 	ldw	r2,-16(fp)
 20401c8:	10001126 	beq	r2,zero,2040210 <ip_write2+0x280>
   {
      if (sopts->ip_ttl)
 20401cc:	e0bffc17 	ldw	r2,-16(fp)
 20401d0:	10800043 	ldbu	r2,1(r2)
 20401d4:	10803fcc 	andi	r2,r2,255
 20401d8:	10000526 	beq	r2,zero,20401f0 <ip_write2+0x260>
         pip->ip_time = sopts->ip_ttl;
 20401dc:	e0bffc17 	ldw	r2,-16(fp)
 20401e0:	10c00043 	ldbu	r3,1(r2)
 20401e4:	e0bffb17 	ldw	r2,-20(fp)
 20401e8:	10c00205 	stb	r3,8(r2)
 20401ec:	00000306 	br	20401fc <ip_write2+0x26c>
      else
         pip->ip_time = ttl;
 20401f0:	e0bffb17 	ldw	r2,-20(fp)
 20401f4:	e0fff803 	ldbu	r3,-32(fp)
 20401f8:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = sopts->ip_tos;
 20401fc:	e0bffc17 	ldw	r2,-16(fp)
 2040200:	10c00003 	ldbu	r3,0(r2)
 2040204:	e0bffb17 	ldw	r2,-20(fp)
 2040208:	10c00045 	stb	r3,1(r2)
 204020c:	00000506 	br	2040224 <ip_write2+0x294>
   }
   else
   {
      pip->ip_time = ttl;
 2040210:	e0bffb17 	ldw	r2,-20(fp)
 2040214:	e0fff803 	ldbu	r3,-32(fp)
 2040218:	10c00205 	stb	r3,8(r2)
      pip->ip_tos = IP_TOS_DEFVAL;
 204021c:	e0bffb17 	ldw	r2,-20(fp)
 2040220:	10000045 	stb	zero,1(r2)
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 2040224:	e0bffe17 	ldw	r2,-8(fp)
 2040228:	10800317 	ldw	r2,12(r2)
 204022c:	10800504 	addi	r2,r2,20
 2040230:	e0bff915 	stw	r2,-28(fp)
 2040234:	00001006 	br	2040278 <ip_write2+0x2e8>
   {
      /* caller has already provided adequate space for the requested options */
      switch (*optp)
 2040238:	e0bfff17 	ldw	r2,-4(fp)
 204023c:	10800003 	ldbu	r2,0(r2)
 2040240:	10803fcc 	andi	r2,r2,255
 2040244:	10800520 	cmpeqi	r2,r2,20
 2040248:	10000726 	beq	r2,zero,2040268 <ip_write2+0x2d8>
      {
         case IP_RTR_ALERT_OPT:
            *((u_long *) tmpp) = htonl (IP_RTR_ALERT_OPT_DATA);
 204024c:	e0bff917 	ldw	r2,-28(fp)
 2040250:	00c12504 	movi	r3,1172
 2040254:	10c00015 	stw	r3,0(r2)
            /* this option is 4 bytes long */
            tmpp += IP_RTR_ALERT_OPT_SIZE;
 2040258:	e0bff917 	ldw	r2,-28(fp)
 204025c:	10800104 	addi	r2,r2,4
 2040260:	e0bff915 	stw	r2,-28(fp)
            break;
 2040264:	00000106 	br	204026c <ip_write2+0x2dc>
         default:
            break;
 2040268:	0001883a 	nop
      pip->ip_time = ttl;
      pip->ip_tos = IP_TOS_DEFVAL;
   }

   /* point to the start of the IP options, and insert the options */
   for (tmpp = (u_char *)(p->nb_prot + sizeof(struct ip)); *optp != EOL_OPT; ++optp)
 204026c:	e0bfff17 	ldw	r2,-4(fp)
 2040270:	10800044 	addi	r2,r2,1
 2040274:	e0bfff15 	stw	r2,-4(fp)
 2040278:	e0bfff17 	ldw	r2,-4(fp)
 204027c:	10800003 	ldbu	r2,0(r2)
 2040280:	10803fcc 	andi	r2,r2,255
 2040284:	103fec1e 	bne	r2,zero,2040238 <ip_write2+0x2a8>
            break;
      }
   }

   /* add one (or more) one-byte long End of Option options (if required) */
   for (i = 0; i < iphlen_pad; ++i) *(tmpp + i) = 0;
 2040288:	e03ffa45 	stb	zero,-23(fp)
 204028c:	00000706 	br	20402ac <ip_write2+0x31c>
 2040290:	e0bffa43 	ldbu	r2,-23(fp)
 2040294:	e0fff917 	ldw	r3,-28(fp)
 2040298:	1885883a 	add	r2,r3,r2
 204029c:	10000005 	stb	zero,0(r2)
 20402a0:	e0bffa43 	ldbu	r2,-23(fp)
 20402a4:	10800044 	addi	r2,r2,1
 20402a8:	e0bffa45 	stb	r2,-23(fp)
 20402ac:	e0fffa43 	ldbu	r3,-23(fp)
 20402b0:	e0bffa03 	ldbu	r2,-24(fp)
 20402b4:	18bff636 	bltu	r3,r2,2040290 <ip_write2+0x300>
   
   /* checksum the IP header */
   pip->ip_chksum = ~cksum (pip, ((iphlen + iphlen_pad)/2));
 20402b8:	e0fff843 	ldbu	r3,-31(fp)
 20402bc:	e0bffa03 	ldbu	r2,-24(fp)
 20402c0:	1885883a 	add	r2,r3,r2
 20402c4:	1006d7fa 	srli	r3,r2,31
 20402c8:	1885883a 	add	r2,r3,r2
 20402cc:	1005d07a 	srai	r2,r2,1
 20402d0:	e13ffb17 	ldw	r4,-20(fp)
 20402d4:	100b883a 	mov	r5,r2
 20402d8:	20268040 	call	2026804 <cksum>
 20402dc:	0084303a 	nor	r2,zero,r2
 20402e0:	1007883a 	mov	r3,r2
 20402e4:	e0bffb17 	ldw	r2,-20(fp)
 20402e8:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal (p));
 20402ec:	e13ffe17 	ldw	r4,-8(fp)
 20402f0:	203f6380 	call	203f638 <ip_write_internal>
}
 20402f4:	e037883a 	mov	sp,fp
 20402f8:	dfc00117 	ldw	ra,4(sp)
 20402fc:	df000017 	ldw	fp,0(sp)
 2040300:	dec00204 	addi	sp,sp,8
 2040304:	f800283a 	ret

02040308 <ip_raw_write>:
 * RETURNS: Returns 0 if sent OK, ENP_SEND_PENDING (1) if 
 * waiting for ARP, else negative error code if error detected. 
 */
int
ip_raw_write(PACKET p)
{
 2040308:	defffc04 	addi	sp,sp,-16
 204030c:	dfc00315 	stw	ra,12(sp)
 2040310:	df000215 	stw	fp,8(sp)
 2040314:	df000204 	addi	fp,sp,8
 2040318:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;

   IN_PROFILER(PF_IP, PF_ENTRY);       /* measure time in IP */

   ip_mib.ipOutRequests++;
 204031c:	00809934 	movhi	r2,612
 2040320:	10b7d304 	addi	r2,r2,-8372
 2040324:	10800917 	ldw	r2,36(r2)
 2040328:	10c00044 	addi	r3,r2,1
 204032c:	00809934 	movhi	r2,612
 2040330:	10b7d304 	addi	r2,r2,-8372
 2040334:	10c00915 	stw	r3,36(r2)

   /* form a pointer to IP header (pip) */
   pip = (struct ip*)(p->nb_prot);
 2040338:	e0bfff17 	ldw	r2,-4(fp)
 204033c:	10800317 	ldw	r2,12(r2)
 2040340:	e0bffe15 	stw	r2,-8(fp)
   
   /* if there's no IP id, give it one */
   if (pip->ip_id == 0)
 2040344:	e0bffe17 	ldw	r2,-8(fp)
 2040348:	1080010b 	ldhu	r2,4(r2)
 204034c:	10bfffcc 	andi	r2,r2,65535
 2040350:	10000e1e 	bne	r2,zero,204038c <ip_raw_write+0x84>
   {
      pip->ip_id = htons((unshort)uid);
 2040354:	d0a05517 	ldw	r2,-32428(gp)
 2040358:	10bfffcc 	andi	r2,r2,65535
 204035c:	1004d23a 	srli	r2,r2,8
 2040360:	1007883a 	mov	r3,r2
 2040364:	d0a05517 	ldw	r2,-32428(gp)
 2040368:	10bfffcc 	andi	r2,r2,65535
 204036c:	1004923a 	slli	r2,r2,8
 2040370:	1884b03a 	or	r2,r3,r2
 2040374:	1007883a 	mov	r3,r2
 2040378:	e0bffe17 	ldw	r2,-8(fp)
 204037c:	10c0010d 	sth	r3,4(r2)
      uid++;
 2040380:	d0a05517 	ldw	r2,-32428(gp)
 2040384:	10800044 	addi	r2,r2,1
 2040388:	d0a05515 	stw	r2,-32428(gp)
   }

   /* checksum the IP header */
   pip->ip_chksum = IPXSUM;      /* clear checksum field */
 204038c:	e0bffe17 	ldw	r2,-8(fp)
 2040390:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum(pip, 10);
 2040394:	e13ffe17 	ldw	r4,-8(fp)
 2040398:	01400284 	movi	r5,10
 204039c:	20268040 	call	2026804 <cksum>
 20403a0:	0084303a 	nor	r2,zero,r2
 20403a4:	1007883a 	mov	r3,r2
 20403a8:	e0bffe17 	ldw	r2,-8(fp)
 20403ac:	10c0028d 	sth	r3,10(r2)

   /* do the actual write */
   return (ip_write_internal(p));
 20403b0:	e13fff17 	ldw	r4,-4(fp)
 20403b4:	203f6380 	call	203f638 <ip_write_internal>
}
 20403b8:	e037883a 	mov	sp,fp
 20403bc:	dfc00117 	ldw	ra,4(sp)
 20403c0:	df000017 	ldw	fp,0(sp)
 20403c4:	dec00204 	addi	sp,sp,8
 20403c8:	f800283a 	ret

020403cc <ip_fragment_lc>:
 *              invocation of ip2mac () for the last generated fragment
 */

int
ip_fragment_lc(PACKET p, ip_addr firsthop)
{
 20403cc:	defff104 	addi	sp,sp,-60
 20403d0:	dfc00e15 	stw	ra,56(sp)
 20403d4:	df000d15 	stw	fp,52(sp)
 20403d8:	df000d04 	addi	fp,sp,52
 20403dc:	e13ffe15 	stw	r4,-8(fp)
 20403e0:	e17fff15 	stw	r5,-4(fp)
   int      e;
   struct ip * pip;
   int      iphlen;     /* IP header length */
   unshort  tmp_fraginfo   ;

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 20403e4:	00809934 	movhi	r2,612
 20403e8:	10b7d304 	addi	r2,r2,-8372
 20403ec:	10801017 	ldw	r2,64(r2)
 20403f0:	10c00044 	addi	r3,r2,1
 20403f4:	00809934 	movhi	r2,612
 20403f8:	10b7d304 	addi	r2,r2,-8372
 20403fc:	10c01015 	stw	r3,64(r2)
   pip = (struct ip *)(p->nb_prot);          /* get ptr to IP header */
 2040400:	e0bffe17 	ldw	r2,-8(fp)
 2040404:	10800317 	ldw	r2,12(r2)
 2040408:	e0bff815 	stw	r2,-32(fp)
   iphlen = (pip->ip_ver_ihl & 0xf) << 2;    /* and its length */
 204040c:	e0bff817 	ldw	r2,-32(fp)
 2040410:	10800003 	ldbu	r2,0(r2)
 2040414:	10803fcc 	andi	r2,r2,255
 2040418:	108003cc 	andi	r2,r2,15
 204041c:	1085883a 	add	r2,r2,r2
 2040420:	1085883a 	add	r2,r2,r2
 2040424:	e0bff915 	stw	r2,-28(fp)
   left = (int)p->nb_plen - iphlen; /* bytes left to send in datagram */
 2040428:	e0bffe17 	ldw	r2,-8(fp)
 204042c:	10800417 	ldw	r2,16(r2)
 2040430:	1007883a 	mov	r3,r2
 2040434:	e0bff917 	ldw	r2,-28(fp)
 2040438:	1885c83a 	sub	r2,r3,r2
 204043c:	e0bff515 	stw	r2,-44(fp)
    * of fragments to get a fragment length that will result
    * in similarly-sized segments (remembering to round this
    * length up to a multiple of 8 because that's how the IP 
    * Fragment Offset field is scaled).
    */
   maxipsize = p->net->n_mtu - (iphlen + p->net->n_lnh + 8);   /* 8 == for rounding up */
 2040440:	e0bffe17 	ldw	r2,-8(fp)
 2040444:	10800617 	ldw	r2,24(r2)
 2040448:	10c00917 	ldw	r3,36(r2)
 204044c:	e0bffe17 	ldw	r2,-8(fp)
 2040450:	10800617 	ldw	r2,24(r2)
 2040454:	11000817 	ldw	r4,32(r2)
 2040458:	e0bff917 	ldw	r2,-28(fp)
 204045c:	2085883a 	add	r2,r4,r2
 2040460:	013ffe04 	movi	r4,-8
 2040464:	2085c83a 	sub	r2,r4,r2
 2040468:	1885883a 	add	r2,r3,r2
 204046c:	e0bffa15 	stw	r2,-24(fp)
   if (maxipsize < 64)  /* to small to use */
 2040470:	e0bffa17 	ldw	r2,-24(fp)
 2040474:	10801028 	cmpgeui	r2,r2,64
 2040478:	1000031e 	bne	r2,zero,2040488 <ip_fragment_lc+0xbc>
   {
      dtrap();    /* probably bad programming */
 204047c:	20285c80 	call	20285c8 <dtrap>
      return ENP_LOGIC;
 2040480:	00bffd44 	movi	r2,-11
 2040484:	0000d206 	br	20407d0 <ip_fragment_lc+0x404>
   }
   numfrags = (p->nb_plen/maxipsize) + 1;    /* number of fragments */
 2040488:	e0bffe17 	ldw	r2,-8(fp)
 204048c:	10c00417 	ldw	r3,16(r2)
 2040490:	e0bffa17 	ldw	r2,-24(fp)
 2040494:	1885203a 	divu	r2,r3,r2
 2040498:	10800044 	addi	r2,r2,1
 204049c:	e0bffb15 	stw	r2,-20(fp)
   fragsize = (((p->nb_plen + (numfrags - 1)) / numfrags) + 7) & ~7; 
 20404a0:	e0bffe17 	ldw	r2,-8(fp)
 20404a4:	10c00417 	ldw	r3,16(r2)
 20404a8:	e0bffb17 	ldw	r2,-20(fp)
 20404ac:	1885883a 	add	r2,r3,r2
 20404b0:	10ffffc4 	addi	r3,r2,-1
 20404b4:	e0bffb17 	ldw	r2,-20(fp)
 20404b8:	1885203a 	divu	r2,r3,r2
 20404bc:	10c001c4 	addi	r3,r2,7
 20404c0:	00bffe04 	movi	r2,-8
 20404c4:	1884703a 	and	r2,r3,r2
 20404c8:	e0bffc15 	stw	r2,-16(fp)
   foffset = 0;
 20404cc:	e03ff315 	stw	zero,-52(fp)

   /* Now update from any previous info */
   tmp_fraginfo = ntohs(pip->ip_flgs_foff);     /* get current frag info*/
 20404d0:	e0bff817 	ldw	r2,-32(fp)
 20404d4:	1080018b 	ldhu	r2,6(r2)
 20404d8:	10bfffcc 	andi	r2,r2,65535
 20404dc:	1004d23a 	srli	r2,r2,8
 20404e0:	1007883a 	mov	r3,r2
 20404e4:	e0bff817 	ldw	r2,-32(fp)
 20404e8:	1080018b 	ldhu	r2,6(r2)
 20404ec:	10bfffcc 	andi	r2,r2,65535
 20404f0:	1004923a 	slli	r2,r2,8
 20404f4:	1884b03a 	or	r2,r3,r2
 20404f8:	e0bffd0d 	sth	r2,-12(fp)
   if ( tmp_fraginfo & (~IP_FLG_MASK) )
 20404fc:	e0fffd0b 	ldhu	r3,-12(fp)
 2040500:	00bffff4 	movhi	r2,65535
 2040504:	1087ffc4 	addi	r2,r2,8191
 2040508:	1884703a 	and	r2,r3,r2
 204050c:	10000826 	beq	r2,zero,2040530 <ip_fragment_lc+0x164>
   {
      /* When fragmenting an already fragmented packet, we need to
         add the initial offset */
      foffset = (tmp_fraginfo & (~IP_FLG_MASK))  ;
 2040510:	e0fffd0b 	ldhu	r3,-12(fp)
 2040514:	00bffff4 	movhi	r2,65535
 2040518:	1087ffc4 	addi	r2,r2,8191
 204051c:	1884703a 	and	r2,r3,r2
 2040520:	e0bff315 	stw	r2,-52(fp)
      foffset <<= 3;    /* Multiply by 8 to get "offset in num of bytes" */
 2040524:	e0bff317 	ldw	r2,-52(fp)
 2040528:	100490fa 	slli	r2,r2,3
 204052c:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
 2040530:	e0bffe17 	ldw	r2,-8(fp)
 2040534:	e0bff615 	stw	r2,-40(fp)
   e = 0;
 2040538:	e03ff715 	stw	zero,-36(fp)
   while (left > 1)  /* more data left to send? */
 204053c:	0000a006 	br	20407c0 <ip_fragment_lc+0x3f4>
   {
      p = pkt2;  /* move next fragment up */
 2040540:	e0bff617 	ldw	r2,-40(fp)
 2040544:	e0bffe15 	stw	r2,-8(fp)
      pip = (struct ip *)(p->nb_prot);
 2040548:	e0bffe17 	ldw	r2,-8(fp)
 204054c:	10800317 	ldw	r2,12(r2)
 2040550:	e0bff815 	stw	r2,-32(fp)
      p->nb_plen = min((int)fragsize, left) + iphlen; /* set size of fragment */
 2040554:	e0bffc17 	ldw	r2,-16(fp)
 2040558:	e0fff517 	ldw	r3,-44(fp)
 204055c:	1880010e 	bge	r3,r2,2040564 <ip_fragment_lc+0x198>
 2040560:	1805883a 	mov	r2,r3
 2040564:	e0fff917 	ldw	r3,-28(fp)
 2040568:	10c5883a 	add	r2,r2,r3
 204056c:	1007883a 	mov	r3,r2
 2040570:	e0bffe17 	ldw	r2,-8(fp)
 2040574:	10c00415 	stw	r3,16(r2)
      left -= fragsize; /* decrement count of bytes left to send */
 2040578:	e0fff517 	ldw	r3,-44(fp)
 204057c:	e0bffc17 	ldw	r2,-16(fp)
 2040580:	1885c83a 	sub	r2,r3,r2
 2040584:	e0bff515 	stw	r2,-44(fp)

      /* set the IP datagram length */
      pip->ip_len = htons((unshort)p->nb_plen);
 2040588:	e0bffe17 	ldw	r2,-8(fp)
 204058c:	10800417 	ldw	r2,16(r2)
 2040590:	10bfffcc 	andi	r2,r2,65535
 2040594:	1004d23a 	srli	r2,r2,8
 2040598:	1007883a 	mov	r3,r2
 204059c:	e0bffe17 	ldw	r2,-8(fp)
 20405a0:	10800417 	ldw	r2,16(r2)
 20405a4:	10bfffcc 	andi	r2,r2,65535
 20405a8:	1004923a 	slli	r2,r2,8
 20405ac:	1884b03a 	or	r2,r3,r2
 20405b0:	1007883a 	mov	r3,r2
 20405b4:	e0bff817 	ldw	r2,-32(fp)
 20405b8:	10c0008d 	sth	r3,2(r2)

      /* build 16bit IP header field value for fragment flags & offset */
      fraginfo = (unshort)(foffset >> 3);    /* offset, in 8 byte chunks */
 20405bc:	e0bff317 	ldw	r2,-52(fp)
 20405c0:	1004d0fa 	srli	r2,r2,3
 20405c4:	e0bff40d 	sth	r2,-48(fp)
      fraginfo |= ((left>1)?IP_FLG_MF:0);    /* OR in MoreFrags flag */
 20405c8:	e0bff517 	ldw	r2,-44(fp)
 20405cc:	10800090 	cmplti	r2,r2,2
 20405d0:	1000021e 	bne	r2,zero,20405dc <ip_fragment_lc+0x210>
 20405d4:	00880004 	movi	r2,8192
 20405d8:	00000106 	br	20405e0 <ip_fragment_lc+0x214>
 20405dc:	0005883a 	mov	r2,zero
 20405e0:	e0fff40b 	ldhu	r3,-48(fp)
 20405e4:	10c4b03a 	or	r2,r2,r3
 20405e8:	e0bff40d 	sth	r2,-48(fp)

      if ( tmp_fraginfo & IP_FLG_MF )             
 20405ec:	e0bffd0b 	ldhu	r2,-12(fp)
 20405f0:	1088000c 	andi	r2,r2,8192
 20405f4:	10000326 	beq	r2,zero,2040604 <ip_fragment_lc+0x238>
      {
         /* As flag is set in main packet, it should be set in all
          * fragmented packets also 
          */
         fraginfo |= IP_FLG_MF;
 20405f8:	e0bff40b 	ldhu	r2,-48(fp)
 20405fc:	10880014 	ori	r2,r2,8192
 2040600:	e0bff40d 	sth	r2,-48(fp)
      }

      pip->ip_flgs_foff = htons(fraginfo);   /* do htons macro on separate line */
 2040604:	e0bff40b 	ldhu	r2,-48(fp)
 2040608:	1004d23a 	srli	r2,r2,8
 204060c:	1007883a 	mov	r3,r2
 2040610:	e0bff40b 	ldhu	r2,-48(fp)
 2040614:	1004923a 	slli	r2,r2,8
 2040618:	1884b03a 	or	r2,r3,r2
 204061c:	1007883a 	mov	r3,r2
 2040620:	e0bff817 	ldw	r2,-32(fp)
 2040624:	10c0018d 	sth	r3,6(r2)
      /* set up & save next fragment (pkt2) since ip2mac() will delete p */
      if (left > 1)
 2040628:	e0bff517 	ldw	r2,-44(fp)
 204062c:	10800090 	cmplti	r2,r2,2
 2040630:	10003e1e 	bne	r2,zero,204072c <ip_fragment_lc+0x360>
      {
         LOCK_NET_RESOURCE(FREEQ_RESID);
 2040634:	01000084 	movi	r4,2
 2040638:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pkt2 = pk_alloc(left + iphlen + MaxLnh);
 204063c:	e0fff517 	ldw	r3,-44(fp)
 2040640:	e0bff917 	ldw	r2,-28(fp)
 2040644:	1887883a 	add	r3,r3,r2
 2040648:	00808174 	movhi	r2,517
 204064c:	1090b004 	addi	r2,r2,17088
 2040650:	10800017 	ldw	r2,0(r2)
 2040654:	1885883a 	add	r2,r3,r2
 2040658:	1009883a 	mov	r4,r2
 204065c:	2027cec0 	call	2027cec <pk_alloc>
 2040660:	e0bff615 	stw	r2,-40(fp)
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040664:	01000084 	movi	r4,2
 2040668:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         if (!pkt2)
 204066c:	e0bff617 	ldw	r2,-40(fp)
 2040670:	1000101e 	bne	r2,zero,20406b4 <ip_fragment_lc+0x2e8>
         {
            dtrap();
 2040674:	20285c80 	call	20285c8 <dtrap>
            LOCK_NET_RESOURCE(FREEQ_RESID);
 2040678:	01000084 	movi	r4,2
 204067c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(p);
 2040680:	e13ffe17 	ldw	r4,-8(fp)
 2040684:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040688:	01000084 	movi	r4,2
 204068c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 2040690:	00809934 	movhi	r2,612
 2040694:	10b7d304 	addi	r2,r2,-8372
 2040698:	10801117 	ldw	r2,68(r2)
 204069c:	10c00044 	addi	r3,r2,1
 20406a0:	00809934 	movhi	r2,612
 20406a4:	10b7d304 	addi	r2,r2,-8372
 20406a8:	10c01115 	stw	r3,68(r2)
            return ENP_RESOURCE;
 20406ac:	00bffa84 	movi	r2,-22
 20406b0:	00004706 	br	20407d0 <ip_fragment_lc+0x404>
         }

         pkt2->net = p->net;       /* copy critical parms to new packet */
 20406b4:	e0bffe17 	ldw	r2,-8(fp)
 20406b8:	10c00617 	ldw	r3,24(r2)
 20406bc:	e0bff617 	ldw	r2,-40(fp)
 20406c0:	10c00615 	stw	r3,24(r2)
         pkt2->fhost = p->fhost;
 20406c4:	e0bffe17 	ldw	r2,-8(fp)
 20406c8:	10c00717 	ldw	r3,28(r2)
 20406cc:	e0bff617 	ldw	r2,-40(fp)
 20406d0:	10c00715 	stw	r3,28(r2)
         /* Duplicate the IPHeader */
         MEMCPY(pkt2->nb_prot, p->nb_prot, iphlen);
 20406d4:	e0bff617 	ldw	r2,-40(fp)
 20406d8:	11000317 	ldw	r4,12(r2)
 20406dc:	e0bffe17 	ldw	r2,-8(fp)
 20406e0:	10c00317 	ldw	r3,12(r2)
 20406e4:	e0bff917 	ldw	r2,-28(fp)
 20406e8:	180b883a 	mov	r5,r3
 20406ec:	100d883a 	mov	r6,r2
 20406f0:	200660c0 	call	200660c <memcpy>
         /* copy data for NEXT fragment from p to pkt2 */
         MEMCPY(pkt2->nb_prot + iphlen, p->nb_prot + iphlen + fragsize, left);
 20406f4:	e0bff617 	ldw	r2,-40(fp)
 20406f8:	10c00317 	ldw	r3,12(r2)
 20406fc:	e0bff917 	ldw	r2,-28(fp)
 2040700:	1889883a 	add	r4,r3,r2
 2040704:	e0bffe17 	ldw	r2,-8(fp)
 2040708:	10c00317 	ldw	r3,12(r2)
 204070c:	e17ff917 	ldw	r5,-28(fp)
 2040710:	e0bffc17 	ldw	r2,-16(fp)
 2040714:	2885883a 	add	r2,r5,r2
 2040718:	1887883a 	add	r3,r3,r2
 204071c:	e0bff517 	ldw	r2,-44(fp)
 2040720:	180b883a 	mov	r5,r3
 2040724:	100d883a 	mov	r6,r2
 2040728:	200660c0 	call	200660c <memcpy>
      }

      /* we've changed the IP header, so recalculate the checksum */
      pip->ip_chksum = IPXSUM;
 204072c:	e0bff817 	ldw	r2,-32(fp)
 2040730:	1000028d 	sth	zero,10(r2)
      pip->ip_chksum = ~cksum(pip, 10);
 2040734:	e13ff817 	ldw	r4,-32(fp)
 2040738:	01400284 	movi	r5,10
 204073c:	20268040 	call	2026804 <cksum>
 2040740:	0084303a 	nor	r2,zero,r2
 2040744:	1007883a 	mov	r3,r2
 2040748:	e0bff817 	ldw	r2,-32(fp)
 204074c:	10c0028d 	sth	r3,10(r2)

      /* ip_dump(p); */

      e = ip2mac(p, firsthop);   /* send fragment in p */
 2040750:	e13ffe17 	ldw	r4,-8(fp)
 2040754:	e17fff17 	ldw	r5,-4(fp)
 2040758:	20246400 	call	2024640 <ip2mac>
 204075c:	e0bff715 	stw	r2,-36(fp)
      ip_mib.ipFragCreates++;
 2040760:	00809934 	movhi	r2,612
 2040764:	10b7d304 	addi	r2,r2,-8372
 2040768:	10801217 	ldw	r2,72(r2)
 204076c:	10c00044 	addi	r3,r2,1
 2040770:	00809934 	movhi	r2,612
 2040774:	10b7d304 	addi	r2,r2,-8372
 2040778:	10c01215 	stw	r3,72(r2)
      if (e < 0)
 204077c:	e0bff717 	ldw	r2,-36(fp)
 2040780:	10000b0e 	bge	r2,zero,20407b0 <ip_fragment_lc+0x3e4>
      {
         if (left > 1) 
 2040784:	e0bff517 	ldw	r2,-44(fp)
 2040788:	10800090 	cmplti	r2,r2,2
 204078c:	1000061e 	bne	r2,zero,20407a8 <ip_fragment_lc+0x3dc>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 2040790:	01000084 	movi	r4,2
 2040794:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(pkt2);
 2040798:	e13ff617 	ldw	r4,-40(fp)
 204079c:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20407a0:	01000084 	movi	r4,2
 20407a4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         }
         return e;
 20407a8:	e0bff717 	ldw	r2,-36(fp)
 20407ac:	00000806 	br	20407d0 <ip_fragment_lc+0x404>
      }
      foffset += fragsize;    /* offset for next fragment */
 20407b0:	e0fff317 	ldw	r3,-52(fp)
 20407b4:	e0bffc17 	ldw	r2,-16(fp)
 20407b8:	1885883a 	add	r2,r3,r2
 20407bc:	e0bff315 	stw	r2,-52(fp)
   }

   /* Loop through IP data area, sending it as fragments */
   pkt2 = p;  /* init these to avoid compiler warnings */
   e = 0;
   while (left > 1)  /* more data left to send? */
 20407c0:	e0bff517 	ldw	r2,-44(fp)
 20407c4:	10800088 	cmpgei	r2,r2,2
 20407c8:	103f5d1e 	bne	r2,zero,2040540 <ip_fragment_lc+0x174>
         }
         return e;
      }
      foffset += fragsize;    /* offset for next fragment */
   }
   return e;
 20407cc:	e0bff717 	ldw	r2,-36(fp)
}
 20407d0:	e037883a 	mov	sp,fp
 20407d4:	dfc00117 	ldw	ra,4(sp)
 20407d8:	df000017 	ldw	fp,0(sp)
 20407dc:	dec00204 	addi	sp,sp,8
 20407e0:	f800283a 	ret

020407e4 <ip_fragment>:
 *              generated fragment, if less than zero
 *          (5) 0, if everything went okay
 */

int ip_fragment(PACKET p, ip_addr firsthop)
{
 20407e4:	defff004 	addi	sp,sp,-64
 20407e8:	dfc00f15 	stw	ra,60(sp)
 20407ec:	df000e15 	stw	fp,56(sp)
 20407f0:	df000e04 	addi	fp,sp,56
 20407f4:	e13ffe15 	stw	r4,-8(fp)
 20407f8:	e17fff15 	stw	r5,-4(fp)
   u_short parent_mf;
   PACKET newpkt;
   struct ip * newpip;
   int e;

   pip = ip_head(p);
 20407fc:	e0bffe17 	ldw	r2,-8(fp)
 2040800:	10800317 	ldw	r2,12(r2)
 2040804:	e0bff515 	stw	r2,-44(fp)
   if ((ntohs(pip->ip_flgs_foff)) & IP_FLG_DF)
 2040808:	e0bff517 	ldw	r2,-44(fp)
 204080c:	1080018b 	ldhu	r2,6(r2)
 2040810:	10bfffcc 	andi	r2,r2,65535
 2040814:	1004d23a 	srli	r2,r2,8
 2040818:	10bfffcc 	andi	r2,r2,65535
 204081c:	10c03fcc 	andi	r3,r2,255
 2040820:	e0bff517 	ldw	r2,-44(fp)
 2040824:	1080018b 	ldhu	r2,6(r2)
 2040828:	10bfffcc 	andi	r2,r2,65535
 204082c:	1004923a 	slli	r2,r2,8
 2040830:	10bfffcc 	andi	r2,r2,65535
 2040834:	1884b03a 	or	r2,r3,r2
 2040838:	1090000c 	andi	r2,r2,16384
 204083c:	10001c26 	beq	r2,zero,20408b0 <ip_fragment+0xcc>
   {
      /* can't fragment a packet with the DF bit set */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2040840:	01000084 	movi	r4,2
 2040844:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 2040848:	e13ffe17 	ldw	r4,-8(fp)
 204084c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040850:	01000084 	movi	r4,2
 2040854:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ip_mib.ipFragFails++;
 2040858:	00809934 	movhi	r2,612
 204085c:	10b7d304 	addi	r2,r2,-8372
 2040860:	10801117 	ldw	r2,68(r2)
 2040864:	10c00044 	addi	r3,r2,1
 2040868:	00809934 	movhi	r2,612
 204086c:	10b7d304 	addi	r2,r2,-8372
 2040870:	10c01115 	stw	r3,68(r2)
#ifdef FULL_ICMP
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 2040874:	e0bff517 	ldw	r2,-44(fp)
 2040878:	10c00317 	ldw	r3,12(r2)
 204087c:	e0bffe17 	ldw	r2,-8(fp)
 2040880:	10800617 	ldw	r2,24(r2)
 2040884:	10800a17 	ldw	r2,40(r2)
 2040888:	e13ffe17 	ldw	r4,-8(fp)
 204088c:	21000617 	ldw	r4,24(r4)
 2040890:	d9000015 	stw	r4,0(sp)
 2040894:	1809883a 	mov	r4,r3
 2040898:	100b883a 	mov	r5,r2
 204089c:	e1bff517 	ldw	r6,-44(fp)
 20408a0:	01c00104 	movi	r7,4
 20408a4:	204b5140 	call	204b514 <icmp_destun>
#endif   /* FULL_ICMP */
      return 0;
 20408a8:	0005883a 	mov	r2,zero
 20408ac:	00013406 	br	2040d80 <ip_fragment+0x59c>
   }

   maxbuflen = pk_get_max_intrsafe_buf_len ();
 20408b0:	20280f40 	call	20280f4 <pk_get_max_intrsafe_buf_len>
 20408b4:	e0bff615 	stw	r2,-40(fp)

   /* the maximum amount of data that will be sent to ip2mac ().  Please note that
    * our definition of MTU is different from the traditional definition of that
    * parameter (which excludes the data link layer header). */
   maxl3_len = (unsigned short int) (MIN(maxbuflen, ((unsigned) p->net->n_mtu)));
 20408b8:	e0bffe17 	ldw	r2,-8(fp)
 20408bc:	10800617 	ldw	r2,24(r2)
 20408c0:	10800917 	ldw	r2,36(r2)
 20408c4:	e0fff617 	ldw	r3,-40(fp)
 20408c8:	1880022e 	bgeu	r3,r2,20408d4 <ip_fragment+0xf0>
 20408cc:	e0bff617 	ldw	r2,-40(fp)
 20408d0:	00000306 	br	20408e0 <ip_fragment+0xfc>
 20408d4:	e0bffe17 	ldw	r2,-8(fp)
 20408d8:	10800617 	ldw	r2,24(r2)
 20408dc:	10800917 	ldw	r2,36(r2)
 20408e0:	e0bff70d 	sth	r2,-36(fp)

   /* get the length of the IP header of the original, unfragmented datagram */
   iphlen = ip_hlen(pip);
 20408e4:	e0bff517 	ldw	r2,-44(fp)
 20408e8:	10800003 	ldbu	r2,0(r2)
 20408ec:	108003cc 	andi	r2,r2,15
 20408f0:	1085883a 	add	r2,r2,r2
 20408f4:	1085883a 	add	r2,r2,r2
 20408f8:	e0bff785 	stb	r2,-34(fp)

   /* obtain the useable payload length in an IP datagram (after accounting for the 
    * length of the IP and data link layer headers) */
   l2hdr_len = (u_char) p->net->n_lnh;
 20408fc:	e0bffe17 	ldw	r2,-8(fp)
 2040900:	10800617 	ldw	r2,24(r2)
 2040904:	10800817 	ldw	r2,32(r2)
 2040908:	e0bff7c5 	stb	r2,-33(fp)
   useable_payload_len = maxl3_len - iphlen - l2hdr_len;
 204090c:	e0bff783 	ldbu	r2,-34(fp)
 2040910:	e0fff70b 	ldhu	r3,-36(fp)
 2040914:	1885c83a 	sub	r2,r3,r2
 2040918:	1007883a 	mov	r3,r2
 204091c:	e0bff7c3 	ldbu	r2,-33(fp)
 2040920:	1885c83a 	sub	r2,r3,r2
 2040924:	e0bff80d 	sth	r2,-32(fp)

   /* IP fragments must always have a length that is a multiple of 8 bytes, so we
    * need to round 'payload_len' down to the nearest multiple of 8 bytes. */
   useable_payload_len &= (~((unsigned short int) 0x07));
 2040928:	e0fff80b 	ldhu	r3,-32(fp)
 204092c:	00bffe04 	movi	r2,-8
 2040930:	1884703a 	and	r2,r3,r2
 2040934:	e0bff80d 	sth	r2,-32(fp)

   /* compute the number of packets that we need to send.  First compute the total
    * payload length of the "original" datagram (which could itself be a fragment). 
    */
   total_payload_len = (ntohs(pip->ip_len)) - iphlen;
 2040938:	e0bff517 	ldw	r2,-44(fp)
 204093c:	1080008b 	ldhu	r2,2(r2)
 2040940:	10bfffcc 	andi	r2,r2,65535
 2040944:	1004d23a 	srli	r2,r2,8
 2040948:	1007883a 	mov	r3,r2
 204094c:	e0bff517 	ldw	r2,-44(fp)
 2040950:	1080008b 	ldhu	r2,2(r2)
 2040954:	10bfffcc 	andi	r2,r2,65535
 2040958:	1004923a 	slli	r2,r2,8
 204095c:	1884b03a 	or	r2,r3,r2
 2040960:	1007883a 	mov	r3,r2
 2040964:	e0bff783 	ldbu	r2,-34(fp)
 2040968:	1885c83a 	sub	r2,r3,r2
 204096c:	e0bff88d 	sth	r2,-30(fp)
   num_frags = (total_payload_len / useable_payload_len);
 2040970:	e0fff88b 	ldhu	r3,-30(fp)
 2040974:	e0bff80b 	ldhu	r2,-32(fp)
 2040978:	1885203a 	divu	r2,r3,r2
 204097c:	e0bff30d 	sth	r2,-52(fp)
   if ((last_payload_len = (total_payload_len % useable_payload_len)) != 0)
 2040980:	e0bff88b 	ldhu	r2,-30(fp)
 2040984:	e0fff80b 	ldhu	r3,-32(fp)
 2040988:	10c9203a 	divu	r4,r2,r3
 204098c:	20c7383a 	mul	r3,r4,r3
 2040990:	10c5c83a 	sub	r2,r2,r3
 2040994:	e0bff90d 	sth	r2,-28(fp)
 2040998:	e0bff90b 	ldhu	r2,-28(fp)
 204099c:	10000326 	beq	r2,zero,20409ac <ip_fragment+0x1c8>
   {
      /* we will have one additional (also last) fragment that is smaller than the 
       * other fragments */
      ++num_frags;
 20409a0:	e0bff30b 	ldhu	r2,-52(fp)
 20409a4:	10800044 	addi	r2,r2,1
 20409a8:	e0bff30d 	sth	r2,-52(fp)
    * the one passed to this function) is interrupt-safe, then we use 
    * ip_fragment_lc () for creating the child fragments.  This decreases the 
    * amount of copying that needs to be done in those cases (as compared to this 
    * function); however, for larger packets, ip_fragment () becomes more efficient 
    * (than ip_fragment_lc ()). */
   if ((num_frags <= FRAG_SCHEME_SWITCH_THRESHOLD) && (!(p->flags & PKF_INTRUNSAFE)))
 20409ac:	e0bff30b 	ldhu	r2,-52(fp)
 20409b0:	10800128 	cmpgeui	r2,r2,4
 20409b4:	1000081e 	bne	r2,zero,20409d8 <ip_fragment+0x1f4>
 20409b8:	e0bffe17 	ldw	r2,-8(fp)
 20409bc:	10800a17 	ldw	r2,40(r2)
 20409c0:	1080040c 	andi	r2,r2,16
 20409c4:	1000041e 	bne	r2,zero,20409d8 <ip_fragment+0x1f4>
   {
      return (ip_fragment_lc (p, firsthop));
 20409c8:	e13ffe17 	ldw	r4,-8(fp)
 20409cc:	e17fff17 	ldw	r5,-4(fp)
 20409d0:	20403cc0 	call	20403cc <ip_fragment_lc>
 20409d4:	0000ea06 	br	2040d80 <ip_fragment+0x59c>
   }

   parent_frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 20409d8:	e0bff517 	ldw	r2,-44(fp)
 20409dc:	1080018b 	ldhu	r2,6(r2)
 20409e0:	10bfffcc 	andi	r2,r2,65535
 20409e4:	1004d23a 	srli	r2,r2,8
 20409e8:	10bfffcc 	andi	r2,r2,65535
 20409ec:	10c03fcc 	andi	r3,r2,255
 20409f0:	e0bff517 	ldw	r2,-44(fp)
 20409f4:	1080018b 	ldhu	r2,6(r2)
 20409f8:	10bfffcc 	andi	r2,r2,65535
 20409fc:	1004923a 	slli	r2,r2,8
 2040a00:	10bfffcc 	andi	r2,r2,65535
 2040a04:	1884b03a 	or	r2,r3,r2
 2040a08:	100490fa 	slli	r2,r2,3
 2040a0c:	e0bff98d 	sth	r2,-26(fp)
   parent_mf = ((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF);
 2040a10:	e0bff517 	ldw	r2,-44(fp)
 2040a14:	1080018b 	ldhu	r2,6(r2)
 2040a18:	10bfffcc 	andi	r2,r2,65535
 2040a1c:	1004d23a 	srli	r2,r2,8
 2040a20:	1007883a 	mov	r3,r2
 2040a24:	e0bff517 	ldw	r2,-44(fp)
 2040a28:	1080018b 	ldhu	r2,6(r2)
 2040a2c:	10bfffcc 	andi	r2,r2,65535
 2040a30:	1004923a 	slli	r2,r2,8
 2040a34:	1884b03a 	or	r2,r3,r2
 2040a38:	1088000c 	andi	r2,r2,8192
 2040a3c:	e0bffa0d 	sth	r2,-24(fp)
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 2040a40:	e03ff38d 	sth	zero,-50(fp)
 2040a44:	0000bd06 	br	2040d3c <ip_fragment+0x558>
   {
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2040a48:	01000084 	movi	r4,2
 2040a4c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      newpkt = pk_alloc (useable_payload_len + iphlen + l2hdr_len); 
 2040a50:	e0fff80b 	ldhu	r3,-32(fp)
 2040a54:	e0bff783 	ldbu	r2,-34(fp)
 2040a58:	1887883a 	add	r3,r3,r2
 2040a5c:	e0bff7c3 	ldbu	r2,-33(fp)
 2040a60:	1885883a 	add	r2,r3,r2
 2040a64:	1009883a 	mov	r4,r2
 2040a68:	2027cec0 	call	2027cec <pk_alloc>
 2040a6c:	e0bffb15 	stw	r2,-20(fp)
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040a70:	01000084 	movi	r4,2
 2040a74:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

      if (newpkt == 0)
 2040a78:	e0bffb17 	ldw	r2,-20(fp)
 2040a7c:	10000f1e 	bne	r2,zero,2040abc <ip_fragment+0x2d8>
      {
         /* free the packet that we are working with */
         LOCK_NET_RESOURCE(FREEQ_RESID);
 2040a80:	01000084 	movi	r4,2
 2040a84:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 2040a88:	e13ffe17 	ldw	r4,-8(fp)
 2040a8c:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040a90:	01000084 	movi	r4,2
 2040a94:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         ip_mib.ipFragFails++;
 2040a98:	00809934 	movhi	r2,612
 2040a9c:	10b7d304 	addi	r2,r2,-8372
 2040aa0:	10801117 	ldw	r2,68(r2)
 2040aa4:	10c00044 	addi	r3,r2,1
 2040aa8:	00809934 	movhi	r2,612
 2040aac:	10b7d304 	addi	r2,r2,-8372
 2040ab0:	10c01115 	stw	r3,68(r2)
         return ENP_NOBUFFER;
 2040ab4:	00bffac4 	movi	r2,-21
 2040ab8:	0000b106 	br	2040d80 <ip_fragment+0x59c>
      }
      else
      {
         /* copy the IP header from the original datagram into the fragment */
         MEMCPY((newpkt->nb_buff + l2hdr_len), p->nb_prot, iphlen);
 2040abc:	e0bffb17 	ldw	r2,-20(fp)
 2040ac0:	10c00117 	ldw	r3,4(r2)
 2040ac4:	e0bff7c3 	ldbu	r2,-33(fp)
 2040ac8:	1889883a 	add	r4,r3,r2
 2040acc:	e0bffe17 	ldw	r2,-8(fp)
 2040ad0:	10c00317 	ldw	r3,12(r2)
 2040ad4:	e0bff783 	ldbu	r2,-34(fp)
 2040ad8:	180b883a 	mov	r5,r3
 2040adc:	100d883a 	mov	r6,r2
 2040ae0:	200660c0 	call	200660c <memcpy>

         /* compute the amount of payload that needs to be copied into each 
          * child fragment */
         if (i < (num_frags - 1))
 2040ae4:	e0fff38b 	ldhu	r3,-50(fp)
 2040ae8:	e0bff30b 	ldhu	r2,-52(fp)
 2040aec:	10bfffc4 	addi	r2,r2,-1
 2040af0:	1880030e 	bge	r3,r2,2040b00 <ip_fragment+0x31c>
         {
            amt_to_copy = useable_payload_len;
 2040af4:	e0bff80b 	ldhu	r2,-32(fp)
 2040af8:	e0bff40d 	sth	r2,-48(fp)
 2040afc:	00000606 	br	2040b18 <ip_fragment+0x334>
         }
         else
         {
            amt_to_copy = ((last_payload_len == 0) ? useable_payload_len : last_payload_len);
 2040b00:	e0bff90b 	ldhu	r2,-28(fp)
 2040b04:	1000021e 	bne	r2,zero,2040b10 <ip_fragment+0x32c>
 2040b08:	e0bff80b 	ldhu	r2,-32(fp)
 2040b0c:	00000106 	br	2040b14 <ip_fragment+0x330>
 2040b10:	e0bff90b 	ldhu	r2,-28(fp)
 2040b14:	e0bff40d 	sth	r2,-48(fp)
         }
         MEMCPY((newpkt->nb_buff + l2hdr_len + iphlen), p->nb_prot + iphlen + (useable_payload_len * i), amt_to_copy);
 2040b18:	e0bffb17 	ldw	r2,-20(fp)
 2040b1c:	10c00117 	ldw	r3,4(r2)
 2040b20:	e13ff7c3 	ldbu	r4,-33(fp)
 2040b24:	e0bff783 	ldbu	r2,-34(fp)
 2040b28:	2085883a 	add	r2,r4,r2
 2040b2c:	1889883a 	add	r4,r3,r2
 2040b30:	e0bffe17 	ldw	r2,-8(fp)
 2040b34:	10c00317 	ldw	r3,12(r2)
 2040b38:	e17ff783 	ldbu	r5,-34(fp)
 2040b3c:	e1bff80b 	ldhu	r6,-32(fp)
 2040b40:	e0bff38b 	ldhu	r2,-50(fp)
 2040b44:	3085383a 	mul	r2,r6,r2
 2040b48:	2885883a 	add	r2,r5,r2
 2040b4c:	1887883a 	add	r3,r3,r2
 2040b50:	e0bff40b 	ldhu	r2,-48(fp)
 2040b54:	180b883a 	mov	r5,r3
 2040b58:	100d883a 	mov	r6,r2
 2040b5c:	200660c0 	call	200660c <memcpy>

         /* set up the various netbuf fields for the fragment */
         newpkt->nb_prot = newpkt->nb_buff + l2hdr_len;
 2040b60:	e0bffb17 	ldw	r2,-20(fp)
 2040b64:	10c00117 	ldw	r3,4(r2)
 2040b68:	e0bff7c3 	ldbu	r2,-33(fp)
 2040b6c:	1887883a 	add	r3,r3,r2
 2040b70:	e0bffb17 	ldw	r2,-20(fp)
 2040b74:	10c00315 	stw	r3,12(r2)
         newpkt->nb_plen = iphlen + amt_to_copy;
 2040b78:	e0fff783 	ldbu	r3,-34(fp)
 2040b7c:	e0bff40b 	ldhu	r2,-48(fp)
 2040b80:	1885883a 	add	r2,r3,r2
 2040b84:	1007883a 	mov	r3,r2
 2040b88:	e0bffb17 	ldw	r2,-20(fp)
 2040b8c:	10c00415 	stw	r3,16(r2)
         newpkt->net = p->net;
 2040b90:	e0bffe17 	ldw	r2,-8(fp)
 2040b94:	10c00617 	ldw	r3,24(r2)
 2040b98:	e0bffb17 	ldw	r2,-20(fp)
 2040b9c:	10c00615 	stw	r3,24(r2)
         newpkt->fhost = p->fhost;
 2040ba0:	e0bffe17 	ldw	r2,-8(fp)
 2040ba4:	10c00717 	ldw	r3,28(r2)
 2040ba8:	e0bffb17 	ldw	r2,-20(fp)
 2040bac:	10c00715 	stw	r3,28(r2)
         /* type and nb_tstamp fields are not used in the egress direction, but we set 'type' anyway */
         newpkt->type = htons(IPTP);
 2040bb0:	e0bffb17 	ldw	r2,-20(fp)
 2040bb4:	00c20004 	movi	r3,2048
 2040bb8:	10c0080d 	sth	r3,32(r2)

         /* now set the Total Length, Fragment Offset, and More Fragments fields */
         newpip = ip_head(newpkt);
 2040bbc:	e0bffb17 	ldw	r2,-20(fp)
 2040bc0:	10800317 	ldw	r2,12(r2)
 2040bc4:	e0bffc15 	stw	r2,-16(fp)
         newpip->ip_len = htons(newpkt->nb_plen);
 2040bc8:	e0bffb17 	ldw	r2,-20(fp)
 2040bcc:	10800417 	ldw	r2,16(r2)
 2040bd0:	1004d23a 	srli	r2,r2,8
 2040bd4:	10803fcc 	andi	r2,r2,255
 2040bd8:	1007883a 	mov	r3,r2
 2040bdc:	e0bffb17 	ldw	r2,-20(fp)
 2040be0:	10800417 	ldw	r2,16(r2)
 2040be4:	1004923a 	slli	r2,r2,8
 2040be8:	1884b03a 	or	r2,r3,r2
 2040bec:	1007883a 	mov	r3,r2
 2040bf0:	e0bffc17 	ldw	r2,-16(fp)
 2040bf4:	10c0008d 	sth	r3,2(r2)
         /* the following statement will reset DF and MF bits */
         newpip->ip_flgs_foff = htons((parent_frag_offset + (useable_payload_len * i)) >> 3);
 2040bf8:	e0fff98b 	ldhu	r3,-26(fp)
 2040bfc:	e13ff80b 	ldhu	r4,-32(fp)
 2040c00:	e0bff38b 	ldhu	r2,-50(fp)
 2040c04:	2085383a 	mul	r2,r4,r2
 2040c08:	1885883a 	add	r2,r3,r2
 2040c0c:	1005d2fa 	srai	r2,r2,11
 2040c10:	10803fcc 	andi	r2,r2,255
 2040c14:	1007883a 	mov	r3,r2
 2040c18:	e13ff98b 	ldhu	r4,-26(fp)
 2040c1c:	e17ff80b 	ldhu	r5,-32(fp)
 2040c20:	e0bff38b 	ldhu	r2,-50(fp)
 2040c24:	2885383a 	mul	r2,r5,r2
 2040c28:	2085883a 	add	r2,r4,r2
 2040c2c:	1005d0fa 	srai	r2,r2,3
 2040c30:	1004923a 	slli	r2,r2,8
 2040c34:	1884b03a 	or	r2,r3,r2
 2040c38:	1007883a 	mov	r3,r2
 2040c3c:	e0bffc17 	ldw	r2,-16(fp)
 2040c40:	10c0018d 	sth	r3,6(r2)
          *     child fragments but the last will have the MF bit set)
          * (2) Parent fragment offset = x, MF = 1: first or middle fragment (FF or MF)
          *     (all child fragments will have the MF bit set)
          * (3) Parent fragment offset > 0, MF = 0: last fragment (LF) (all child fragments
          *     except the last will have the MF bit set) */
         if (i < (num_frags - 1))
 2040c44:	e0fff38b 	ldhu	r3,-50(fp)
 2040c48:	e0bff30b 	ldhu	r2,-52(fp)
 2040c4c:	10bfffc4 	addi	r2,r2,-1
 2040c50:	1880070e 	bge	r3,r2,2040c70 <ip_fragment+0x48c>
         {
            newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 2040c54:	e0bffc17 	ldw	r2,-16(fp)
 2040c58:	1080018b 	ldhu	r2,6(r2)
 2040c5c:	10800814 	ori	r2,r2,32
 2040c60:	1007883a 	mov	r3,r2
 2040c64:	e0bffc17 	ldw	r2,-16(fp)
 2040c68:	10c0018d 	sth	r3,6(r2)
 2040c6c:	00000806 	br	2040c90 <ip_fragment+0x4ac>
         }
         else
         {
            if (parent_mf)
 2040c70:	e0bffa0b 	ldhu	r2,-24(fp)
 2040c74:	10000626 	beq	r2,zero,2040c90 <ip_fragment+0x4ac>
            {
               newpip->ip_flgs_foff |= htons(IP_FLG_MF);
 2040c78:	e0bffc17 	ldw	r2,-16(fp)
 2040c7c:	1080018b 	ldhu	r2,6(r2)
 2040c80:	10800814 	ori	r2,r2,32
 2040c84:	1007883a 	mov	r3,r2
 2040c88:	e0bffc17 	ldw	r2,-16(fp)
 2040c8c:	10c0018d 	sth	r3,6(r2)
            }
         }

         /* finally, update the checksum */
         newpip->ip_chksum = IPXSUM;
 2040c90:	e0bffc17 	ldw	r2,-16(fp)
 2040c94:	1000028d 	sth	zero,10(r2)
         newpip->ip_chksum = ~cksum(newpip, (iphlen/2));
 2040c98:	e0bff783 	ldbu	r2,-34(fp)
 2040c9c:	1004d07a 	srli	r2,r2,1
 2040ca0:	10803fcc 	andi	r2,r2,255
 2040ca4:	e13ffc17 	ldw	r4,-16(fp)
 2040ca8:	100b883a 	mov	r5,r2
 2040cac:	20268040 	call	2026804 <cksum>
 2040cb0:	0084303a 	nor	r2,zero,r2
 2040cb4:	1007883a 	mov	r3,r2
 2040cb8:	e0bffc17 	ldw	r2,-16(fp)
 2040cbc:	10c0028d 	sth	r3,10(r2)

         ip_mib.ipFragCreates++;
 2040cc0:	00809934 	movhi	r2,612
 2040cc4:	10b7d304 	addi	r2,r2,-8372
 2040cc8:	10801217 	ldw	r2,72(r2)
 2040ccc:	10c00044 	addi	r3,r2,1
 2040cd0:	00809934 	movhi	r2,612
 2040cd4:	10b7d304 	addi	r2,r2,-8372
 2040cd8:	10c01215 	stw	r3,72(r2)

         /* we're done; hand the packet off to ip2mac () */
         e = ip2mac (newpkt, firsthop);
 2040cdc:	e13ffb17 	ldw	r4,-20(fp)
 2040ce0:	e17fff17 	ldw	r5,-4(fp)
 2040ce4:	20246400 	call	2024640 <ip2mac>
 2040ce8:	e0bffd15 	stw	r2,-12(fp)
         if (e < 0)
 2040cec:	e0bffd17 	ldw	r2,-12(fp)
 2040cf0:	10000f0e 	bge	r2,zero,2040d30 <ip_fragment+0x54c>
         {
            LOCK_NET_RESOURCE(FREEQ_RESID);
 2040cf4:	01000084 	movi	r4,2
 2040cf8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(p);
 2040cfc:	e13ffe17 	ldw	r4,-8(fp)
 2040d00:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040d04:	01000084 	movi	r4,2
 2040d08:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            ip_mib.ipFragFails++;
 2040d0c:	00809934 	movhi	r2,612
 2040d10:	10b7d304 	addi	r2,r2,-8372
 2040d14:	10801117 	ldw	r2,68(r2)
 2040d18:	10c00044 	addi	r3,r2,1
 2040d1c:	00809934 	movhi	r2,612
 2040d20:	10b7d304 	addi	r2,r2,-8372
 2040d24:	10c01115 	stw	r3,68(r2)
            return e;
 2040d28:	e0bffd17 	ldw	r2,-12(fp)
 2040d2c:	00001406 	br	2040d80 <ip_fragment+0x59c>
   /* irrespective of whether the parent buffer is interrupt-safe or not, we attempt 
    * to allocate new buffers for all of the fragments.  Iterate thru' the original 
    * datagram, copying fragments into the newly allocated data buffers.  If we want
    * to send the fragments in reverse order, we just need to "reverse" the FOR loop.
    */
   for (i = 0; i < num_frags; ++i)
 2040d30:	e0bff38b 	ldhu	r2,-50(fp)
 2040d34:	10800044 	addi	r2,r2,1
 2040d38:	e0bff38d 	sth	r2,-50(fp)
 2040d3c:	e0fff38b 	ldhu	r3,-50(fp)
 2040d40:	e0bff30b 	ldhu	r2,-52(fp)
 2040d44:	18bf4036 	bltu	r3,r2,2040a48 <ip_fragment+0x264>

   } /* end FOR (all child fragments) */

   /* free the parent buffer since all of the data from it have been copied 
    * out into the child fragments */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2040d48:	01000084 	movi	r4,2
 2040d4c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 2040d50:	e13ffe17 	ldw	r4,-8(fp)
 2040d54:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2040d58:	01000084 	movi	r4,2
 2040d5c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   ip_mib.ipFragOKs++;     /* count packets we fragmented */
 2040d60:	00809934 	movhi	r2,612
 2040d64:	10b7d304 	addi	r2,r2,-8372
 2040d68:	10801017 	ldw	r2,64(r2)
 2040d6c:	10c00044 	addi	r3,r2,1
 2040d70:	00809934 	movhi	r2,612
 2040d74:	10b7d304 	addi	r2,r2,-8372
 2040d78:	10c01015 	stw	r3,64(r2)

   return 0;
 2040d7c:	0005883a 	mov	r2,zero
}
 2040d80:	e037883a 	mov	sp,fp
 2040d84:	dfc00117 	ldw	ra,4(sp)
 2040d88:	df000017 	ldw	fp,0(sp)
 2040d8c:	dec00204 	addi	sp,sp,8
 2040d90:	f800283a 	ret

02040d94 <ip_mymach>:
 * certain foreign host. 
 */

ip_addr
ip_mymach(ip_addr host)
{
 2040d94:	defffa04 	addi	sp,sp,-24
 2040d98:	dfc00515 	stw	ra,20(sp)
 2040d9c:	df000415 	stw	fp,16(sp)
 2040da0:	df000404 	addi	fp,sp,16
 2040da4:	e13fff15 	stw	r4,-4(fp)

#ifndef MULTI_HOMED /* single static interface */
   USE_ARG(host);
   return(nets[0]->n_ipaddr);   /* always use address from only net */
#else   /* MULTI_HOMED */
   tnet = iproute(host, &temp);
 2040da8:	e0bffe04 	addi	r2,fp,-8
 2040dac:	e13fff17 	ldw	r4,-4(fp)
 2040db0:	100b883a 	mov	r5,r2
 2040db4:	20410e40 	call	20410e4 <iproute>
 2040db8:	e0bffd15 	stw	r2,-12(fp)
   if (tnet == 0)
 2040dbc:	e0bffd17 	ldw	r2,-12(fp)
 2040dc0:	1000171e 	bne	r2,zero,2040e20 <ip_mymach+0x8c>
   {
#ifdef   NPDEBUG
      if (NDEBUG & (PROTERR|INFOMSG))
 2040dc4:	00808174 	movhi	r2,517
 2040dc8:	1090b204 	addi	r2,r2,17096
 2040dcc:	10800017 	ldw	r2,0(r2)
 2040dd0:	1080050c 	andi	r2,r2,20
 2040dd4:	10001026 	beq	r2,zero,2040e18 <ip_mymach+0x84>
         dprintf("IP: Couldn't route to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 2040dd8:	e0bfff17 	ldw	r2,-4(fp)
 2040ddc:	11403fcc 	andi	r5,r2,255
 2040de0:	e0bfff17 	ldw	r2,-4(fp)
 2040de4:	1004d23a 	srli	r2,r2,8
 2040de8:	10c03fcc 	andi	r3,r2,255
 2040dec:	e0bfff17 	ldw	r2,-4(fp)
 2040df0:	1004d43a 	srli	r2,r2,16
 2040df4:	10803fcc 	andi	r2,r2,255
 2040df8:	e13fff17 	ldw	r4,-4(fp)
 2040dfc:	2008d63a 	srli	r4,r4,24
 2040e00:	d9000015 	stw	r4,0(sp)
 2040e04:	01008174 	movhi	r4,517
 2040e08:	21056704 	addi	r4,r4,5532
 2040e0c:	180d883a 	mov	r6,r3
 2040e10:	100f883a 	mov	r7,r2
 2040e14:	2006a240 	call	2006a24 <printf>
#endif   /* NPDEBUG */
      return 0L;
 2040e18:	0005883a 	mov	r2,zero
 2040e1c:	00000206 	br	2040e28 <ip_mymach+0x94>
   }
   return tnet->n_ipaddr;
 2040e20:	e0bffd17 	ldw	r2,-12(fp)
 2040e24:	10800a17 	ldw	r2,40(r2)
#endif /* MULTI_HOMED */
}
 2040e28:	e037883a 	mov	sp,fp
 2040e2c:	dfc00117 	ldw	ra,4(sp)
 2040e30:	df000017 	ldw	fp,0(sp)
 2040e34:	dec00204 	addi	sp,sp,8
 2040e38:	f800283a 	ret

02040e3c <ip_dump>:
 * RETURNS: void
 */

void
ip_dump(PACKET p)
{
 2040e3c:	defff704 	addi	sp,sp,-36
 2040e40:	dfc00815 	stw	ra,32(sp)
 2040e44:	df000715 	stw	fp,28(sp)
 2040e48:	df000704 	addi	fp,sp,28
 2040e4c:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   unsigned char * cp;
   unsigned short xsum, osum;

   pip = ip_head(p);
 2040e50:	e0bfff17 	ldw	r2,-4(fp)
 2040e54:	10800317 	ldw	r2,12(r2)
 2040e58:	e0bffc15 	stw	r2,-16(fp)
   osum = pip->ip_chksum;
 2040e5c:	e0bffc17 	ldw	r2,-16(fp)
 2040e60:	1080028b 	ldhu	r2,10(r2)
 2040e64:	e0bffd0d 	sth	r2,-12(fp)
   pip->ip_chksum = 0;
 2040e68:	e0bffc17 	ldw	r2,-16(fp)
 2040e6c:	1000028d 	sth	zero,10(r2)
   xsum = ~cksum(pip, ip_hlen(pip) >> 1);
 2040e70:	e0bffc17 	ldw	r2,-16(fp)
 2040e74:	10800003 	ldbu	r2,0(r2)
 2040e78:	10803fcc 	andi	r2,r2,255
 2040e7c:	108003cc 	andi	r2,r2,15
 2040e80:	1085883a 	add	r2,r2,r2
 2040e84:	1085883a 	add	r2,r2,r2
 2040e88:	1005d07a 	srai	r2,r2,1
 2040e8c:	e13ffc17 	ldw	r4,-16(fp)
 2040e90:	100b883a 	mov	r5,r2
 2040e94:	20268040 	call	2026804 <cksum>
 2040e98:	0084303a 	nor	r2,zero,r2
 2040e9c:	e0bffd8d 	sth	r2,-10(fp)

   if (osum != xsum)          /* trap here if checksum is wrong */
 2040ea0:	e0fffd0b 	ldhu	r3,-12(fp)
 2040ea4:	e0bffd8b 	ldhu	r2,-10(fp)
 2040ea8:	18800126 	beq	r3,r2,2040eb0 <ip_dump+0x74>
   {
      dtrap();
 2040eac:	20285c80 	call	20285c8 <dtrap>
   /* dtrap() is fatal in the default Windows implementation, so
    * we comment it out */
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
 2040eb0:	0009883a 	mov	r4,zero
 2040eb4:	01408174 	movhi	r5,517
 2040eb8:	29457004 	addi	r5,r5,5568
 2040ebc:	2026e100 	call	2026e10 <ns_printf>
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
 2040ec0:	e0bffc17 	ldw	r2,-16(fp)
 2040ec4:	e0bffe15 	stw	r2,-8(fp)
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 2040ec8:	e0bffe17 	ldw	r2,-8(fp)
 2040ecc:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 2040ed0:	10c03fcc 	andi	r3,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 2040ed4:	e0bffe17 	ldw	r2,-8(fp)
 2040ed8:	10800044 	addi	r2,r2,1
 2040edc:	10800003 	ldbu	r2,0(r2)
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 2040ee0:	10803fcc 	andi	r2,r2,255
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 2040ee4:	e13ffc17 	ldw	r4,-16(fp)
 2040ee8:	2100008b 	ldhu	r4,2(r4)
 2040eec:	213fffcc 	andi	r4,r4,65535
 2040ef0:	2008d23a 	srli	r4,r4,8
 2040ef4:	213fffcc 	andi	r4,r4,65535
 2040ef8:	21403fcc 	andi	r5,r4,255
 2040efc:	e13ffc17 	ldw	r4,-16(fp)
 2040f00:	2100008b 	ldhu	r4,2(r4)
 2040f04:	213fffcc 	andi	r4,r4,65535
 2040f08:	2008923a 	slli	r4,r4,8
 2040f0c:	213fffcc 	andi	r4,r4,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 2040f10:	290ab03a 	or	r5,r5,r4
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
 2040f14:	e13ffc17 	ldw	r4,-16(fp)
 2040f18:	2100010b 	ldhu	r4,4(r4)
 2040f1c:	213fffcc 	andi	r4,r4,65535
 2040f20:	2008d23a 	srli	r4,r4,8
 2040f24:	213fffcc 	andi	r4,r4,65535
 2040f28:	21803fcc 	andi	r6,r4,255
 2040f2c:	e13ffc17 	ldw	r4,-16(fp)
 2040f30:	2100010b 	ldhu	r4,4(r4)
 2040f34:	213fffcc 	andi	r4,r4,65535
 2040f38:	2008923a 	slli	r4,r4,8
 2040f3c:	213fffcc 	andi	r4,r4,65535
   dtrap();       /* use debugger to view variables & packet */
#endif

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
 2040f40:	3108b03a 	or	r4,r6,r4
 2040f44:	d9400015 	stw	r5,0(sp)
 2040f48:	d9000115 	stw	r4,4(sp)
 2040f4c:	0009883a 	mov	r4,zero
 2040f50:	01408174 	movhi	r5,517
 2040f54:	29457504 	addi	r5,r5,5588
 2040f58:	180d883a 	mov	r6,r3
 2040f5c:	100f883a 	mov	r7,r2
 2040f60:	2026e100 	call	2026e10 <ns_printf>
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 2040f64:	e0bffe17 	ldw	r2,-8(fp)
 2040f68:	10800184 	addi	r2,r2,6
 2040f6c:	1080000b 	ldhu	r2,0(r2)
 2040f70:	10bfffcc 	andi	r2,r2,65535
 2040f74:	1004d23a 	srli	r2,r2,8
 2040f78:	10bfffcc 	andi	r2,r2,65535
 2040f7c:	10c03fcc 	andi	r3,r2,255
 2040f80:	e0bffe17 	ldw	r2,-8(fp)
 2040f84:	10800184 	addi	r2,r2,6
 2040f88:	1080000b 	ldhu	r2,0(r2)
 2040f8c:	10bfffcc 	andi	r2,r2,65535
 2040f90:	1004923a 	slli	r2,r2,8
 2040f94:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 2040f98:	188cb03a 	or	r6,r3,r2
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 2040f9c:	e0bffc17 	ldw	r2,-16(fp)
 2040fa0:	10800203 	ldbu	r2,8(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 2040fa4:	10c03fcc 	andi	r3,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
 2040fa8:	e0bffc17 	ldw	r2,-16(fp)
 2040fac:	10800243 	ldbu	r2,9(r2)

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 2040fb0:	11403fcc 	andi	r5,r2,255
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
 2040fb4:	e0bffd0b 	ldhu	r2,-12(fp)
 2040fb8:	1004d23a 	srli	r2,r2,8
 2040fbc:	10bfffcc 	andi	r2,r2,65535
 2040fc0:	11003fcc 	andi	r4,r2,255
 2040fc4:	e0bffd0b 	ldhu	r2,-12(fp)
 2040fc8:	1004923a 	slli	r2,r2,8
 2040fcc:	10bfffcc 	andi	r2,r2,65535

   ns_printf(NULL ,"IP packet header:\n");
   cp = (unsigned char *)pip;    /* make char pointer for bitmasks */
   ns_printf(NULL ,"ver/hlen: %02x, TOS: %02x, len: %04x, id: %04x\n",
    *cp, *(cp+1), htons(pip->ip_len), htons(pip->ip_id));
   ns_printf(NULL ,"flags/offs: %04x, TTL %02x, protocol: %02x, cksum: %04x (%s)\n",
 2040fd0:	2088b03a 	or	r4,r4,r2
 2040fd4:	e1fffd0b 	ldhu	r7,-12(fp)
 2040fd8:	e0bffd8b 	ldhu	r2,-10(fp)
 2040fdc:	3880031e 	bne	r7,r2,2040fec <ip_dump+0x1b0>
 2040fe0:	00808174 	movhi	r2,517
 2040fe4:	10858104 	addi	r2,r2,5636
 2040fe8:	00000206 	br	2040ff4 <ip_dump+0x1b8>
 2040fec:	00808174 	movhi	r2,517
 2040ff0:	10858204 	addi	r2,r2,5640
 2040ff4:	d9400015 	stw	r5,0(sp)
 2040ff8:	d9000115 	stw	r4,4(sp)
 2040ffc:	d8800215 	stw	r2,8(sp)
 2041000:	0009883a 	mov	r4,zero
 2041004:	01408174 	movhi	r5,517
 2041008:	29458304 	addi	r5,r5,5644
 204100c:	180f883a 	mov	r7,r3
 2041010:	2026e100 	call	2026e10 <ns_printf>
    htons(*(unshort*)(cp+6)), pip->ip_time, pip->ip_prot, 
    htons(osum), (osum==xsum)?"ok":"bad");
   ns_printf(NULL ,"src: %u.%u.%u.%u  ", PUSH_IPADDR(pip->ip_src));
 2041014:	e0bffc17 	ldw	r2,-16(fp)
 2041018:	10800317 	ldw	r2,12(r2)
 204101c:	10c03fcc 	andi	r3,r2,255
 2041020:	e0bffc17 	ldw	r2,-16(fp)
 2041024:	10800317 	ldw	r2,12(r2)
 2041028:	1004d23a 	srli	r2,r2,8
 204102c:	10803fcc 	andi	r2,r2,255
 2041030:	e13ffc17 	ldw	r4,-16(fp)
 2041034:	21000317 	ldw	r4,12(r4)
 2041038:	2008d43a 	srli	r4,r4,16
 204103c:	21403fcc 	andi	r5,r4,255
 2041040:	e13ffc17 	ldw	r4,-16(fp)
 2041044:	21000317 	ldw	r4,12(r4)
 2041048:	2008d63a 	srli	r4,r4,24
 204104c:	d9400015 	stw	r5,0(sp)
 2041050:	d9000115 	stw	r4,4(sp)
 2041054:	0009883a 	mov	r4,zero
 2041058:	01408174 	movhi	r5,517
 204105c:	29459304 	addi	r5,r5,5708
 2041060:	180d883a 	mov	r6,r3
 2041064:	100f883a 	mov	r7,r2
 2041068:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(NULL ,"dest: %u.%u.%u.%u\n", PUSH_IPADDR(pip->ip_dest));
 204106c:	e0bffc17 	ldw	r2,-16(fp)
 2041070:	10800417 	ldw	r2,16(r2)
 2041074:	10c03fcc 	andi	r3,r2,255
 2041078:	e0bffc17 	ldw	r2,-16(fp)
 204107c:	10800417 	ldw	r2,16(r2)
 2041080:	1004d23a 	srli	r2,r2,8
 2041084:	10803fcc 	andi	r2,r2,255
 2041088:	e13ffc17 	ldw	r4,-16(fp)
 204108c:	21000417 	ldw	r4,16(r4)
 2041090:	2008d43a 	srli	r4,r4,16
 2041094:	21403fcc 	andi	r5,r4,255
 2041098:	e13ffc17 	ldw	r4,-16(fp)
 204109c:	21000417 	ldw	r4,16(r4)
 20410a0:	2008d63a 	srli	r4,r4,24
 20410a4:	d9400015 	stw	r5,0(sp)
 20410a8:	d9000115 	stw	r4,4(sp)
 20410ac:	0009883a 	mov	r4,zero
 20410b0:	01408174 	movhi	r5,517
 20410b4:	29459804 	addi	r5,r5,5728
 20410b8:	180d883a 	mov	r6,r3
 20410bc:	100f883a 	mov	r7,r2
 20410c0:	2026e100 	call	2026e10 <ns_printf>

   pip->ip_chksum = osum;     /* fix what we clobbered */
 20410c4:	e0bffc17 	ldw	r2,-16(fp)
 20410c8:	e0fffd0b 	ldhu	r3,-12(fp)
 20410cc:	10c0028d 	sth	r3,10(r2)
}
 20410d0:	e037883a 	mov	sp,fp
 20410d4:	dfc00117 	ldw	ra,4(sp)
 20410d8:	df000017 	ldw	fp,0(sp)
 20410dc:	dec00204 	addi	sp,sp,8
 20410e0:	f800283a 	ret

020410e4 <iproute>:
 * RETURNS: Returns NULL when unable to route, else returns a NET pointer.
 */

NET
iproute(ip_addr host, ip_addr * hop1)
{
 20410e4:	defff804 	addi	sp,sp,-32
 20410e8:	dfc00715 	stw	ra,28(sp)
 20410ec:	df000615 	stw	fp,24(sp)
 20410f0:	df000604 	addi	fp,sp,24
 20410f4:	e13ffe15 	stw	r4,-8(fp)
 20410f8:	e17fff15 	stw	r5,-4(fp)
   NET      ifp;
#ifdef IP_ROUTING
   RTMIB    rtp;
#endif   /* IP_ROUTING */

   if (host == 0L)      /* Sanity check parameter. */
 20410fc:	e0bffe17 	ldw	r2,-8(fp)
 2041100:	1000021e 	bne	r2,zero,204110c <iproute+0x28>
      return NULL;
 2041104:	0005883a 	mov	r2,zero
 2041108:	00007906 	br	20412f0 <iproute+0x20c>
    * stack has been initialized (tk_yield() gets called out of the 
    * dialer code as part of PPP initialization), one symptom of 
    * which is the routing table not being present yet. if this 
    * happens, quit. 
    */
   if (rt_mib == NULL)
 204110c:	d0a0bc17 	ldw	r2,-32016(gp)
 2041110:	1000021e 	bne	r2,zero,204111c <iproute+0x38>
      return NULL;
 2041114:	0005883a 	mov	r2,zero
 2041118:	00007506 	br	20412f0 <iproute+0x20c>
#endif   /* BTREE_ROUTING */

   /* see if the host matches the cached route */
   if (cachedRoute)     /* don't test this if route is null  */
 204111c:	00808174 	movhi	r2,517
 2041120:	1090f004 	addi	r2,r2,17344
 2041124:	10800017 	ldw	r2,0(r2)
 2041128:	10001826 	beq	r2,zero,204118c <iproute+0xa8>
   {
      if (cachedRoute->ipRouteDest == host)    /* exact match */
 204112c:	00808174 	movhi	r2,517
 2041130:	1090f004 	addi	r2,r2,17344
 2041134:	10800017 	ldw	r2,0(r2)
 2041138:	10c00017 	ldw	r3,0(r2)
 204113c:	e0bffe17 	ldw	r2,-8(fp)
 2041140:	1880121e 	bne	r3,r2,204118c <iproute+0xa8>
      {
         *hop1 = cachedRoute->ipRouteNextHop;   /* fill in nexthop IP addr */
 2041144:	00808174 	movhi	r2,517
 2041148:	1090f004 	addi	r2,r2,17344
 204114c:	10800017 	ldw	r2,0(r2)
 2041150:	10c00617 	ldw	r3,24(r2)
 2041154:	e0bfff17 	ldw	r2,-4(fp)
 2041158:	10c00015 	stw	r3,0(r2)
         cachedRoute->ipRouteAge = cticks;      /* timestamp route entry */
 204115c:	00808174 	movhi	r2,517
 2041160:	1090f004 	addi	r2,r2,17344
 2041164:	10800017 	ldw	r2,0(r2)
 2041168:	00c08174 	movhi	r3,517
 204116c:	18d0c904 	addi	r3,r3,17188
 2041170:	18c00017 	ldw	r3,0(r3)
 2041174:	10c00915 	stw	r3,36(r2)
         return(cachedRoute->ifp); /* net to send on */
 2041178:	00808174 	movhi	r2,517
 204117c:	1090f004 	addi	r2,r2,17344
 2041180:	10800017 	ldw	r2,0(r2)
 2041184:	10800e17 	ldw	r2,56(r2)
 2041188:	00005906 	br	20412f0 <iproute+0x20c>
      }
   }

   rtp = rt_lookup(host);
 204118c:	e13ffe17 	ldw	r4,-8(fp)
 2041190:	20447380 	call	2044738 <rt_lookup>
 2041194:	e0bffd15 	stw	r2,-12(fp)
   if(rtp)
 2041198:	e0bffd17 	ldw	r2,-12(fp)
 204119c:	10000b26 	beq	r2,zero,20411cc <iproute+0xe8>
   {
      cachedRoute = rtp;
 20411a0:	00808174 	movhi	r2,517
 20411a4:	1090f004 	addi	r2,r2,17344
 20411a8:	e0fffd17 	ldw	r3,-12(fp)
 20411ac:	10c00015 	stw	r3,0(r2)
      *hop1 = rtp->ipRouteNextHop;  /* fill in IP dest (next hop) */
 20411b0:	e0bffd17 	ldw	r2,-12(fp)
 20411b4:	10c00617 	ldw	r3,24(r2)
 20411b8:	e0bfff17 	ldw	r2,-4(fp)
 20411bc:	10c00015 	stw	r3,0(r2)
      return(rtp->ifp);             /* return pointer to net */
 20411c0:	e0bffd17 	ldw	r2,-12(fp)
 20411c4:	10800e17 	ldw	r2,56(r2)
 20411c8:	00004906 	br	20412f0 <iproute+0x20c>
    * the initial state for the for loop that iterates through the
    * list), but only build the iterator for multi-homed systems
    * because single-homed systems are often memory-limited systems as
    * well.  
    */
   ifp = (NET)(netlist.q_head);
 20411cc:	00809934 	movhi	r2,612
 20411d0:	10b7ce04 	addi	r2,r2,-8392
 20411d4:	10800017 	ldw	r2,0(r2)
 20411d8:	e0bffc15 	stw	r2,-16(fp)
   i = 0;
 20411dc:	e03ffb15 	stw	zero,-20(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 20411e0:	00002806 	br	2041284 <iproute+0x1a0>
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 20411e4:	e0bffc17 	ldw	r2,-16(fp)
 20411e8:	10800c17 	ldw	r2,48(r2)
 20411ec:	10001f26 	beq	r2,zero,204126c <iproute+0x188>
         (ifp->n_ipaddr != 0) && 
 20411f0:	e0bffc17 	ldw	r2,-16(fp)
 20411f4:	10800a17 	ldw	r2,40(r2)
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
 20411f8:	10001c26 	beq	r2,zero,204126c <iproute+0x188>
         (ifp->n_ipaddr != 0) && 
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
 20411fc:	e0bffc17 	ldw	r2,-16(fp)
 2041200:	10c00a17 	ldw	r3,40(r2)
 2041204:	e0bffe17 	ldw	r2,-8(fp)
 2041208:	1886f03a 	xor	r3,r3,r2
 204120c:	e0bffc17 	ldw	r2,-16(fp)
 2041210:	10800c17 	ldw	r2,48(r2)
 2041214:	1884703a 	and	r2,r3,r2
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
#endif /* MULTI_HOMED */
   {
      if((ifp->snmask != 0) &&      /* skip ifaces with no IP or subnet mask set */
         (ifp->n_ipaddr != 0) && 
 2041218:	1000141e 	bne	r2,zero,204126c <iproute+0x188>
         ((ifp->n_ipaddr & ifp->snmask) == (host & ifp->snmask)))
      {
#ifdef IP_ROUTING
         /* make a cached Route entry for next time */
         cachedRoute = add_route(host, 0xFFFFFFFF, host, i, IPRP_OTHER);
 204121c:	00800044 	movi	r2,1
 2041220:	d8800015 	stw	r2,0(sp)
 2041224:	e13ffe17 	ldw	r4,-8(fp)
 2041228:	017fffc4 	movi	r5,-1
 204122c:	e1bffe17 	ldw	r6,-8(fp)
 2041230:	e1fffb17 	ldw	r7,-20(fp)
 2041234:	20448ac0 	call	20448ac <add_route>
 2041238:	00c08174 	movhi	r3,517
 204123c:	18d0f004 	addi	r3,r3,17344
 2041240:	18800015 	stw	r2,0(r3)
#ifdef NPDEBUG
         if (cachedRoute == NULL)
 2041244:	00808174 	movhi	r2,517
 2041248:	1090f004 	addi	r2,r2,17344
 204124c:	10800017 	ldw	r2,0(r2)
 2041250:	1000011e 	bne	r2,zero,2041258 <iproute+0x174>
            dtrap();
 2041254:	20285c80 	call	20285c8 <dtrap>
#endif   /* NPDEBUG */
#endif   /* IP_ROUTING */
         *hop1 = host;
 2041258:	e0bfff17 	ldw	r2,-4(fp)
 204125c:	e0fffe17 	ldw	r3,-8(fp)
 2041260:	10c00015 	stw	r3,0(r2)
         return ifp;
 2041264:	e0bffc17 	ldw	r2,-16(fp)
 2041268:	00002106 	br	20412f0 <iproute+0x20c>
    * well.  
    */
   ifp = (NET)(netlist.q_head);
   i = 0;
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next, i++)
 204126c:	e0bffc17 	ldw	r2,-16(fp)
 2041270:	10800017 	ldw	r2,0(r2)
 2041274:	e0bffc15 	stw	r2,-16(fp)
 2041278:	e0bffb17 	ldw	r2,-20(fp)
 204127c:	10800044 	addi	r2,r2,1
 2041280:	e0bffb15 	stw	r2,-20(fp)
 2041284:	e0bffc17 	ldw	r2,-16(fp)
 2041288:	103fd61e 	bne	r2,zero,20411e4 <iproute+0x100>
#endif   /* IP_LOOPBACK */

   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
 204128c:	00809934 	movhi	r2,612
 2041290:	10b7ce04 	addi	r2,r2,-8392
 2041294:	10800017 	ldw	r2,0(r2)
 2041298:	e0bffc15 	stw	r2,-16(fp)
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 204129c:	00000c06 	br	20412d0 <iproute+0x1ec>
#endif   /* MULTI_HOMED */
   {
      /* Check if this net has a gateway */
      if(ifp->n_defgw)
 20412a0:	e0bffc17 	ldw	r2,-16(fp)
 20412a4:	10800d17 	ldw	r2,52(r2)
 20412a8:	10000626 	beq	r2,zero,20412c4 <iproute+0x1e0>
      {
         *hop1 = ifp->n_defgw;
 20412ac:	e0bffc17 	ldw	r2,-16(fp)
 20412b0:	10c00d17 	ldw	r3,52(r2)
 20412b4:	e0bfff17 	ldw	r2,-4(fp)
 20412b8:	10c00015 	stw	r3,0(r2)
         return ifp;
 20412bc:	e0bffc17 	ldw	r2,-16(fp)
 20412c0:	00000b06 	br	20412f0 <iproute+0x20c>
   /* The host isn't on a net I'm on, so send it to the default 
    * gateway on the first net which has one. 
    */
   ifp = (NET)(netlist.q_head);
#ifdef MULTI_HOMED
   for(; ifp; ifp = ifp->n_next)
 20412c4:	e0bffc17 	ldw	r2,-16(fp)
 20412c8:	10800017 	ldw	r2,0(r2)
 20412cc:	e0bffc15 	stw	r2,-16(fp)
 20412d0:	e0bffc17 	ldw	r2,-16(fp)
 20412d4:	103ff21e 	bne	r2,zero,20412a0 <iproute+0x1bc>
   /* if no gateway is set, then change the first hop address to the 
    * host we're trying to route to. this is just a kluge to make 
    * this work with arp routing. otherwise, we would try to return 
    * some sort of error indication. 
    */
   *hop1 = host;
 20412d8:	e0bfff17 	ldw	r2,-4(fp)
 20412dc:	e0fffe17 	ldw	r3,-8(fp)
 20412e0:	10c00015 	stw	r3,0(r2)
   return((NET)(netlist.q_head));
 20412e4:	00809934 	movhi	r2,612
 20412e8:	10b7ce04 	addi	r2,r2,-8392
 20412ec:	10800017 	ldw	r2,0(r2)
#endif   /* STRICT_SUBNETTING */
}
 20412f0:	e037883a 	mov	sp,fp
 20412f4:	dfc00117 	ldw	ra,4(sp)
 20412f8:	df000017 	ldw	fp,0(sp)
 20412fc:	dec00204 	addi	sp,sp,8
 2041300:	f800283a 	ret

02041304 <ip_copypkt>:
 * RETURNS: a pointer to the new copy of the packet,
 *          or NULL if no packet buffer could be allocated
 */
PACKET
ip_copypkt(PACKET p)
{
 2041304:	defffb04 	addi	sp,sp,-20
 2041308:	dfc00415 	stw	ra,16(sp)
 204130c:	df000315 	stw	fp,12(sp)
 2041310:	df000304 	addi	fp,sp,12
 2041314:	e13fff15 	stw	r4,-4(fp)
   int len;

   /* figure out how much we need to copy from the packet, 
    * and allocate a new buffer to hold it 
    */
   len = p->nb_plen + (p->nb_prot - p->nb_buff);
 2041318:	e0bfff17 	ldw	r2,-4(fp)
 204131c:	10c00417 	ldw	r3,16(r2)
 2041320:	e0bfff17 	ldw	r2,-4(fp)
 2041324:	10800317 	ldw	r2,12(r2)
 2041328:	1009883a 	mov	r4,r2
 204132c:	e0bfff17 	ldw	r2,-4(fp)
 2041330:	10800117 	ldw	r2,4(r2)
 2041334:	2085c83a 	sub	r2,r4,r2
 2041338:	1885883a 	add	r2,r3,r2
 204133c:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2041340:	01000084 	movi	r4,2
 2041344:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   np = pk_alloc(len);
 2041348:	e0bffd17 	ldw	r2,-12(fp)
 204134c:	1009883a 	mov	r4,r2
 2041350:	2027cec0 	call	2027cec <pk_alloc>
 2041354:	e0bffe15 	stw	r2,-8(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2041358:	01000084 	movi	r4,2
 204135c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (np == NULL)
 2041360:	e0bffe17 	ldw	r2,-8(fp)
 2041364:	1000061e 	bne	r2,zero,2041380 <ip_copypkt+0x7c>
   {
#ifdef NPDEBUG
      dprintf("ip_copypkt(): unable to obtain packet (len %d)\n", len);
 2041368:	01008174 	movhi	r4,517
 204136c:	21059d04 	addi	r4,r4,5748
 2041370:	e17ffd17 	ldw	r5,-12(fp)
 2041374:	2006a240 	call	2006a24 <printf>
#endif
      return NULL;
 2041378:	0005883a 	mov	r2,zero
 204137c:	00002806 	br	2041420 <ip_copypkt+0x11c>
   }

   /* copy packet data into new buffer */
   MEMCPY(np->nb_buff, p->nb_buff, len);
 2041380:	e0bffe17 	ldw	r2,-8(fp)
 2041384:	11000117 	ldw	r4,4(r2)
 2041388:	e0bfff17 	ldw	r2,-4(fp)
 204138c:	10c00117 	ldw	r3,4(r2)
 2041390:	e0bffd17 	ldw	r2,-12(fp)
 2041394:	180b883a 	mov	r5,r3
 2041398:	100d883a 	mov	r6,r2
 204139c:	200660c0 	call	200660c <memcpy>

   /* copy relevant packet fields */
   np->nb_prot = np->nb_buff + (p->nb_prot - p->nb_buff);
 20413a0:	e0bffe17 	ldw	r2,-8(fp)
 20413a4:	10c00117 	ldw	r3,4(r2)
 20413a8:	e0bfff17 	ldw	r2,-4(fp)
 20413ac:	10800317 	ldw	r2,12(r2)
 20413b0:	1009883a 	mov	r4,r2
 20413b4:	e0bfff17 	ldw	r2,-4(fp)
 20413b8:	10800117 	ldw	r2,4(r2)
 20413bc:	2085c83a 	sub	r2,r4,r2
 20413c0:	1887883a 	add	r3,r3,r2
 20413c4:	e0bffe17 	ldw	r2,-8(fp)
 20413c8:	10c00315 	stw	r3,12(r2)
   np->nb_plen = p->nb_plen;
 20413cc:	e0bfff17 	ldw	r2,-4(fp)
 20413d0:	10c00417 	ldw	r3,16(r2)
 20413d4:	e0bffe17 	ldw	r2,-8(fp)
 20413d8:	10c00415 	stw	r3,16(r2)
   np->net = p->net;
 20413dc:	e0bfff17 	ldw	r2,-4(fp)
 20413e0:	10c00617 	ldw	r3,24(r2)
 20413e4:	e0bffe17 	ldw	r2,-8(fp)
 20413e8:	10c00615 	stw	r3,24(r2)
   np->fhost = p->fhost;
 20413ec:	e0bfff17 	ldw	r2,-4(fp)
 20413f0:	10c00717 	ldw	r3,28(r2)
 20413f4:	e0bffe17 	ldw	r2,-8(fp)
 20413f8:	10c00715 	stw	r3,28(r2)
   np->type = p->type;
 20413fc:	e0bfff17 	ldw	r2,-4(fp)
 2041400:	10c0080b 	ldhu	r3,32(r2)
 2041404:	e0bffe17 	ldw	r2,-8(fp)
 2041408:	10c0080d 	sth	r3,32(r2)
   np->nb_tstamp = p->nb_tstamp;
 204140c:	e0bfff17 	ldw	r2,-4(fp)
 2041410:	10c00517 	ldw	r3,20(r2)
 2041414:	e0bffe17 	ldw	r2,-8(fp)
 2041418:	10c00515 	stw	r3,20(r2)

   /* return pointer to the copy */
   return np;
 204141c:	e0bffe17 	ldw	r2,-8(fp)
}
 2041420:	e037883a 	mov	sp,fp
 2041424:	dfc00117 	ldw	ra,4(sp)
 2041428:	df000017 	ldw	fp,0(sp)
 204142c:	dec00204 	addi	sp,sp,8
 2041430:	f800283a 	ret

02041434 <ip_reasm_match_frag_with_ire>:
packet being processed.  If no such entry is found, this function returns 
NULL.
*/

IREP ip_reasm_match_frag_with_ire (struct ip * pip)
{
 2041434:	defffa04 	addi	sp,sp,-24
 2041438:	df000515 	stw	fp,20(sp)
 204143c:	df000504 	addi	fp,sp,20
 2041440:	e13fff15 	stw	r4,-4(fp)
   ip_addr dest;
   u_char prot;
   u_short id;
   IREP tmpp;
 
   src = pip->ip_src;
 2041444:	e0bfff17 	ldw	r2,-4(fp)
 2041448:	10800317 	ldw	r2,12(r2)
 204144c:	e0bffc15 	stw	r2,-16(fp)
   dest = pip->ip_dest;
 2041450:	e0bfff17 	ldw	r2,-4(fp)
 2041454:	10800417 	ldw	r2,16(r2)
 2041458:	e0bffd15 	stw	r2,-12(fp)
   prot = pip->ip_prot;
 204145c:	e0bfff17 	ldw	r2,-4(fp)
 2041460:	10800243 	ldbu	r2,9(r2)
 2041464:	e0bffe05 	stb	r2,-8(fp)
   id = pip->ip_id;
 2041468:	e0bfff17 	ldw	r2,-4(fp)
 204146c:	1080010b 	ldhu	r2,4(r2)
 2041470:	e0bffe8d 	sth	r2,-6(fp)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 2041474:	d0a0be17 	ldw	r2,-32008(gp)
 2041478:	e0bffb15 	stw	r2,-20(fp)
 204147c:	00001706 	br	20414dc <ip_reasm_match_frag_with_ire+0xa8>
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 2041480:	e0bffb17 	ldw	r2,-20(fp)
 2041484:	10c00117 	ldw	r3,4(r2)
 2041488:	e0bffc17 	ldw	r2,-16(fp)
 204148c:	1880101e 	bne	r3,r2,20414d0 <ip_reasm_match_frag_with_ire+0x9c>
 2041490:	e0bffb17 	ldw	r2,-20(fp)
 2041494:	10c00217 	ldw	r3,8(r2)
 2041498:	e0bffd17 	ldw	r2,-12(fp)
 204149c:	18800c1e 	bne	r3,r2,20414d0 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 20414a0:	e0bffb17 	ldw	r2,-20(fp)
 20414a4:	10800383 	ldbu	r2,14(r2)

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      if ((tmpp->src == src) && (tmpp->dest == dest) && 
 20414a8:	10c03fcc 	andi	r3,r2,255
 20414ac:	e0bffe03 	ldbu	r2,-8(fp)
 20414b0:	1880071e 	bne	r3,r2,20414d0 <ip_reasm_match_frag_with_ire+0x9c>
          (tmpp->prot == prot) && (tmpp->id == id))
 20414b4:	e0bffb17 	ldw	r2,-20(fp)
 20414b8:	1080030b 	ldhu	r2,12(r2)
 20414bc:	10ffffcc 	andi	r3,r2,65535
 20414c0:	e0bffe8b 	ldhu	r2,-6(fp)
 20414c4:	1880021e 	bne	r3,r2,20414d0 <ip_reasm_match_frag_with_ire+0x9c>
         {
         return tmpp; /* we've found a match */
 20414c8:	e0bffb17 	ldw	r2,-20(fp)
 20414cc:	00000606 	br	20414e8 <ip_reasm_match_frag_with_ire+0xb4>
   prot = pip->ip_prot;
   id = pip->ip_id;

   /* note that multi-byte fields such as the source address, destination address,
    * and id fields are stored in the IRE structure in network byte order */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 20414d0:	e0bffb17 	ldw	r2,-20(fp)
 20414d4:	10800017 	ldw	r2,0(r2)
 20414d8:	e0bffb15 	stw	r2,-20(fp)
 20414dc:	e0bffb17 	ldw	r2,-20(fp)
 20414e0:	103fe71e 	bne	r2,zero,2041480 <ip_reasm_match_frag_with_ire+0x4c>
         return tmpp; /* we've found a match */
         }
      }

   /* no match found */
   return NULL;
 20414e4:	0005883a 	mov	r2,zero
}
 20414e8:	e037883a 	mov	sp,fp
 20414ec:	df000017 	ldw	fp,0(sp)
 20414f0:	dec00104 	addi	sp,sp,4
 20414f4:	f800283a 	ret

020414f8 <ip_reasm_determine_type_of_frag>:
OUTPUT: One of the various IP_FRAGTYPE values (IP_CP, IP_FF, IP_MF, 
or IP_LF)
*/

IP_FRAGTYPE ip_reasm_determine_type_of_frag (struct ip * pip)
{
 20414f8:	defffc04 	addi	sp,sp,-16
 20414fc:	df000315 	stw	fp,12(sp)
 2041500:	df000304 	addi	fp,sp,12
 2041504:	e13fff15 	stw	r4,-4(fp)
  u_short mf;
  u_short foff;
  IP_FRAGTYPE rc;

  mf = (((ntohs(pip->ip_flgs_foff)) & IP_FLG_MF) >> 13);
 2041508:	e0bfff17 	ldw	r2,-4(fp)
 204150c:	1080018b 	ldhu	r2,6(r2)
 2041510:	10bfffcc 	andi	r2,r2,65535
 2041514:	1004d23a 	srli	r2,r2,8
 2041518:	10bfffcc 	andi	r2,r2,65535
 204151c:	10c03fcc 	andi	r3,r2,255
 2041520:	e0bfff17 	ldw	r2,-4(fp)
 2041524:	1080018b 	ldhu	r2,6(r2)
 2041528:	10bfffcc 	andi	r2,r2,65535
 204152c:	1004923a 	slli	r2,r2,8
 2041530:	10bfffcc 	andi	r2,r2,65535
 2041534:	1884b03a 	or	r2,r3,r2
 2041538:	1088000c 	andi	r2,r2,8192
 204153c:	1005d37a 	srai	r2,r2,13
 2041540:	e0bffe0d 	sth	r2,-8(fp)
  foff = ((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF);
 2041544:	e0bfff17 	ldw	r2,-4(fp)
 2041548:	1080018b 	ldhu	r2,6(r2)
 204154c:	10bfffcc 	andi	r2,r2,65535
 2041550:	1004d23a 	srli	r2,r2,8
 2041554:	1007883a 	mov	r3,r2
 2041558:	e0bfff17 	ldw	r2,-4(fp)
 204155c:	1080018b 	ldhu	r2,6(r2)
 2041560:	10bfffcc 	andi	r2,r2,65535
 2041564:	1004923a 	slli	r2,r2,8
 2041568:	1884b03a 	or	r2,r3,r2
 204156c:	1087ffcc 	andi	r2,r2,8191
 2041570:	e0bffe8d 	sth	r2,-6(fp)

  if (mf == 0)
 2041574:	e0bffe0b 	ldhu	r2,-8(fp)
 2041578:	1000071e 	bne	r2,zero,2041598 <ip_reasm_determine_type_of_frag+0xa0>
     {
     if (foff == 0) {rc = IP_CP;}
 204157c:	e0bffe8b 	ldhu	r2,-6(fp)
 2041580:	1000021e 	bne	r2,zero,204158c <ip_reasm_determine_type_of_frag+0x94>
 2041584:	e03ffd15 	stw	zero,-12(fp)
 2041588:	00000a06 	br	20415b4 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_LF;}
 204158c:	00800144 	movi	r2,5
 2041590:	e0bffd15 	stw	r2,-12(fp)
 2041594:	00000706 	br	20415b4 <ip_reasm_determine_type_of_frag+0xbc>
     }
  else
     {
     if (foff == 0) {rc = IP_FF;}
 2041598:	e0bffe8b 	ldhu	r2,-6(fp)
 204159c:	1000031e 	bne	r2,zero,20415ac <ip_reasm_determine_type_of_frag+0xb4>
 20415a0:	00800044 	movi	r2,1
 20415a4:	e0bffd15 	stw	r2,-12(fp)
 20415a8:	00000206 	br	20415b4 <ip_reasm_determine_type_of_frag+0xbc>
     else {rc = IP_MF;}
 20415ac:	008000c4 	movi	r2,3
 20415b0:	e0bffd15 	stw	r2,-12(fp)
     }

  return rc;
 20415b4:	e0bffd17 	ldw	r2,-12(fp)
}
 20415b8:	e037883a 	mov	sp,fp
 20415bc:	df000017 	ldw	fp,0(sp)
 20415c0:	dec00104 	addi	sp,sp,4
 20415c4:	f800283a 	ret

020415c8 <ip_reasm_check_mem_useage>:
OUTPUT: ENP_RESOURCE, if the increment request can't be allowed; 
otherwise it returns IPREASM_OK.
*/

int ip_reasm_check_mem_useage (u_short increment)
{
 20415c8:	defffe04 	addi	sp,sp,-8
 20415cc:	df000115 	stw	fp,4(sp)
 20415d0:	df000104 	addi	fp,sp,4
 20415d4:	2005883a 	mov	r2,r4
 20415d8:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity check */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 20415dc:	d0a0bd17 	ldw	r2,-32012(gp)
 20415e0:	00c001b4 	movhi	r3,6
 20415e4:	1880072e 	bgeu	r3,r2,2041604 <ip_reasm_check_mem_useage+0x3c>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 20415e8:	00809934 	movhi	r2,612
 20415ec:	10b7e704 	addi	r2,r2,-8292
 20415f0:	10800217 	ldw	r2,8(r2)
 20415f4:	10c00044 	addi	r3,r2,1
 20415f8:	00809934 	movhi	r2,612
 20415fc:	10b7e704 	addi	r2,r2,-8292
 2041600:	10c00215 	stw	r3,8(r2)
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 2041604:	d0e0bd17 	ldw	r3,-32012(gp)
 2041608:	008001b4 	movhi	r2,6
 204160c:	18800526 	beq	r3,r2,2041624 <ip_reasm_check_mem_useage+0x5c>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
 2041610:	e0ffff0b 	ldhu	r3,-4(fp)
 2041614:	d0a0bd17 	ldw	r2,-32012(gp)
 2041618:	1885883a 	add	r2,r3,r2
      ++ire_stats.bad_max_mem;
   }

   /* check to see if we are already at limit OR if we may become over limit 
    * after accepting this new fragment */
   if ((ipr_curr_mem == IP_REASM_MAX_MEM) ||
 204161c:	00c001b4 	movhi	r3,6
 2041620:	1880092e 	bgeu	r3,r2,2041648 <ip_reasm_check_mem_useage+0x80>
       (ipr_curr_mem + increment > IP_REASM_MAX_MEM))
   {
      /* return an error indication */
      ++ire_stats.mem_check_fail;
 2041624:	00809934 	movhi	r2,612
 2041628:	10b7e704 	addi	r2,r2,-8292
 204162c:	10800317 	ldw	r2,12(r2)
 2041630:	10c00044 	addi	r3,r2,1
 2041634:	00809934 	movhi	r2,612
 2041638:	10b7e704 	addi	r2,r2,-8292
 204163c:	10c00315 	stw	r3,12(r2)
      return ENP_RESOURCE;
 2041640:	00bffa84 	movi	r2,-22
 2041644:	00000106 	br	204164c <ip_reasm_check_mem_useage+0x84>
   }

   /* memory limits will not be exceeded with this increment */
   return IPREASM_OK;
 2041648:	0005883a 	mov	r2,zero
}
 204164c:	e037883a 	mov	sp,fp
 2041650:	df000017 	ldw	fp,0(sp)
 2041654:	dec00104 	addi	sp,sp,4
 2041658:	f800283a 	ret

0204165c <ip_reasm_incr_mem_useage>:
system exceeding the maximum limit or if the system has already exceeded 
the prespecified limit for memory useage; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_incr_mem_useage (u_short increment)
{
 204165c:	defffe04 	addi	sp,sp,-8
 2041660:	df000115 	stw	fp,4(sp)
 2041664:	df000104 	addi	fp,sp,4
 2041668:	2005883a 	mov	r2,r4
 204166c:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 2041670:	d0a0bd17 	ldw	r2,-32012(gp)
 2041674:	00c001b4 	movhi	r3,6
 2041678:	1880092e 	bgeu	r3,r2,20416a0 <ip_reasm_incr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 204167c:	00809934 	movhi	r2,612
 2041680:	10b7e704 	addi	r2,r2,-8292
 2041684:	10800217 	ldw	r2,8(r2)
 2041688:	10c00044 	addi	r3,r2,1
 204168c:	00809934 	movhi	r2,612
 2041690:	10b7e704 	addi	r2,r2,-8292
 2041694:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 2041698:	00bffa84 	movi	r2,-22
 204169c:	00001306 	br	20416ec <ip_reasm_incr_mem_useage+0x90>
   }
   if (ipr_curr_mem + increment > IP_REASM_MAX_MEM)
 20416a0:	e0ffff0b 	ldhu	r3,-4(fp)
 20416a4:	d0a0bd17 	ldw	r2,-32012(gp)
 20416a8:	1885883a 	add	r2,r3,r2
 20416ac:	00c001b4 	movhi	r3,6
 20416b0:	1880092e 	bgeu	r3,r2,20416d8 <ip_reasm_incr_mem_useage+0x7c>
   {
      /* this should never happen since caller should have 
       * checked prior to asking for the increment */
      ++ire_stats.mem_incr_fail;
 20416b4:	00809934 	movhi	r2,612
 20416b8:	10b7e704 	addi	r2,r2,-8292
 20416bc:	10800417 	ldw	r2,16(r2)
 20416c0:	10c00044 	addi	r3,r2,1
 20416c4:	00809934 	movhi	r2,612
 20416c8:	10b7e704 	addi	r2,r2,-8292
 20416cc:	10c00415 	stw	r3,16(r2)
      return ENP_RESOURCE;
 20416d0:	00bffa84 	movi	r2,-22
 20416d4:	00000506 	br	20416ec <ip_reasm_incr_mem_useage+0x90>
   }

   ipr_curr_mem += increment;
 20416d8:	e0ffff0b 	ldhu	r3,-4(fp)
 20416dc:	d0a0bd17 	ldw	r2,-32012(gp)
 20416e0:	1885883a 	add	r2,r3,r2
 20416e4:	d0a0bd15 	stw	r2,-32012(gp)

   /* successfully incremented memory useage counter */
   return IPREASM_OK;
 20416e8:	0005883a 	mov	r2,zero
}
 20416ec:	e037883a 	mov	sp,fp
 20416f0:	df000017 	ldw	fp,0(sp)
 20416f4:	dec00104 	addi	sp,sp,4
 20416f8:	f800283a 	ret

020416fc <ip_reasm_decr_mem_useage>:
exceeded the prespecified limit for memory useage; otherwise, it returns 
IPREASM_OK.
*/

int ip_reasm_decr_mem_useage (u_short decrement)
{
 20416fc:	defffe04 	addi	sp,sp,-8
 2041700:	df000115 	stw	fp,4(sp)
 2041704:	df000104 	addi	fp,sp,4
 2041708:	2005883a 	mov	r2,r4
 204170c:	e0bfff0d 	sth	r2,-4(fp)
   /* sanity checks */
   if (ipr_curr_mem > IP_REASM_MAX_MEM)
 2041710:	d0a0bd17 	ldw	r2,-32012(gp)
 2041714:	00c001b4 	movhi	r3,6
 2041718:	1880092e 	bgeu	r3,r2,2041740 <ip_reasm_decr_mem_useage+0x44>
   {
      /* this should never happen */
      ++ire_stats.bad_max_mem;
 204171c:	00809934 	movhi	r2,612
 2041720:	10b7e704 	addi	r2,r2,-8292
 2041724:	10800217 	ldw	r2,8(r2)
 2041728:	10c00044 	addi	r3,r2,1
 204172c:	00809934 	movhi	r2,612
 2041730:	10b7e704 	addi	r2,r2,-8292
 2041734:	10c00215 	stw	r3,8(r2)
      return ENP_RESOURCE;
 2041738:	00bffa84 	movi	r2,-22
 204173c:	00001106 	br	2041784 <ip_reasm_decr_mem_useage+0x88>
   }
   if (ipr_curr_mem < decrement)
 2041740:	e0bfff0b 	ldhu	r2,-4(fp)
 2041744:	d0e0bd17 	ldw	r3,-32012(gp)
 2041748:	1880092e 	bgeu	r3,r2,2041770 <ip_reasm_decr_mem_useage+0x74>
   {
      /* this should never happen since the current memory useage
       * counter must always be greater than or at least equal to
       * the allocation that is being "returned" */
      ++ire_stats.mem_decr_fail;
 204174c:	00809934 	movhi	r2,612
 2041750:	10b7e704 	addi	r2,r2,-8292
 2041754:	10800517 	ldw	r2,20(r2)
 2041758:	10c00044 	addi	r3,r2,1
 204175c:	00809934 	movhi	r2,612
 2041760:	10b7e704 	addi	r2,r2,-8292
 2041764:	10c00515 	stw	r3,20(r2)
      return ENP_RESOURCE;
 2041768:	00bffa84 	movi	r2,-22
 204176c:	00000506 	br	2041784 <ip_reasm_decr_mem_useage+0x88>
   }

   ipr_curr_mem -= decrement;
 2041770:	d0e0bd17 	ldw	r3,-32012(gp)
 2041774:	e0bfff0b 	ldhu	r2,-4(fp)
 2041778:	1885c83a 	sub	r2,r3,r2
 204177c:	d0a0bd15 	stw	r2,-32012(gp)

   /* successfully decremented memory useage counter */
   return IPREASM_OK;
 2041780:	0005883a 	mov	r2,zero
}
 2041784:	e037883a 	mov	sp,fp
 2041788:	df000017 	ldw	fp,0(sp)
 204178c:	dec00104 	addi	sp,sp,4
 2041790:	f800283a 	ret

02041794 <ip_reasm_process_first_fragment>:
OUTPUT: ENP_RESOURCE if the memory check (in ip_reasm_check_mem_useage ()) 
or the allocation for an IRE fails; otherwise, it returns IPREASM_OK.
*/

int ip_reasm_process_first_fragment (PACKET p)
{
 2041794:	defff704 	addi	sp,sp,-36
 2041798:	dfc00815 	stw	ra,32(sp)
 204179c:	df000715 	stw	fp,28(sp)
 20417a0:	df000704 	addi	fp,sp,28
 20417a4:	e13fff15 	stw	r4,-4(fp)
   u_short total_len;
   int rc;

   /* this is a fragment from a hitherto unknown fragment stream; 
    * check for resource limits before accepting it */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (IRE)))) != IPREASM_OK)
 20417a8:	e0bfff17 	ldw	r2,-4(fp)
 20417ac:	10800217 	ldw	r2,8(r2)
 20417b0:	10802204 	addi	r2,r2,136
 20417b4:	10bfffcc 	andi	r2,r2,65535
 20417b8:	1009883a 	mov	r4,r2
 20417bc:	20415c80 	call	20415c8 <ip_reasm_check_mem_useage>
 20417c0:	e0bff915 	stw	r2,-28(fp)
 20417c4:	e0bff917 	ldw	r2,-28(fp)
 20417c8:	10000f26 	beq	r2,zero,2041808 <ip_reasm_process_first_fragment+0x74>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 20417cc:	01000084 	movi	r4,2
 20417d0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free (p);
 20417d4:	e13fff17 	ldw	r4,-4(fp)
 20417d8:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 20417dc:	01000084 	movi	r4,2
 20417e0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 20417e4:	00809934 	movhi	r2,612
 20417e8:	10b7d304 	addi	r2,r2,-8372
 20417ec:	10800f17 	ldw	r2,60(r2)
 20417f0:	10c00044 	addi	r3,r2,1
 20417f4:	00809934 	movhi	r2,612
 20417f8:	10b7d304 	addi	r2,r2,-8372
 20417fc:	10c00f15 	stw	r3,60(r2)
      return rc;
 2041800:	e0bff917 	ldw	r2,-28(fp)
 2041804:	00008c06 	br	2041a38 <ip_reasm_process_first_fragment+0x2a4>
   }

   /* we are ok wrt memory limits; since this is the first fragment, we need 
    * to create an IRE entry */
   irep = (IREP) IPR_ALLOC(sizeof(IRE));
 2041808:	01002204 	movi	r4,136
 204180c:	20290400 	call	2029040 <npalloc>
 2041810:	e0bffa15 	stw	r2,-24(fp)
   if (irep == 0) 
 2041814:	e0bffa17 	ldw	r2,-24(fp)
 2041818:	10000f1e 	bne	r2,zero,2041858 <ip_reasm_process_first_fragment+0xc4>
   {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 204181c:	01000084 	movi	r4,2
 2041820:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free (p);
 2041824:	e13fff17 	ldw	r4,-4(fp)
 2041828:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 204182c:	01000084 	movi	r4,2
 2041830:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 2041834:	00809934 	movhi	r2,612
 2041838:	10b7d304 	addi	r2,r2,-8372
 204183c:	10800f17 	ldw	r2,60(r2)
 2041840:	10c00044 	addi	r3,r2,1
 2041844:	00809934 	movhi	r2,612
 2041848:	10b7d304 	addi	r2,r2,-8372
 204184c:	10c00f15 	stw	r3,60(r2)
      return ENP_RESOURCE;
 2041850:	00bffa84 	movi	r2,-22
 2041854:	00007806 	br	2041a38 <ip_reasm_process_first_fragment+0x2a4>
   }

   pip = ip_head(p);
 2041858:	e0bfff17 	ldw	r2,-4(fp)
 204185c:	10800317 	ldw	r2,12(r2)
 2041860:	e0bffb15 	stw	r2,-20(fp)
   iphlen = ip_hlen(pip);
 2041864:	e0bffb17 	ldw	r2,-20(fp)
 2041868:	10800003 	ldbu	r2,0(r2)
 204186c:	108003cc 	andi	r2,r2,15
 2041870:	1085883a 	add	r2,r2,r2
 2041874:	1085883a 	add	r2,r2,r2
 2041878:	e0bffc05 	stb	r2,-16(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 204187c:	e13ffb17 	ldw	r4,-20(fp)
 2041880:	20414f80 	call	20414f8 <ip_reasm_determine_type_of_frag>
 2041884:	e0bffd15 	stw	r2,-12(fp)
   frag_offset = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 2041888:	e0bffb17 	ldw	r2,-20(fp)
 204188c:	1080018b 	ldhu	r2,6(r2)
 2041890:	10bfffcc 	andi	r2,r2,65535
 2041894:	1004d23a 	srli	r2,r2,8
 2041898:	10bfffcc 	andi	r2,r2,65535
 204189c:	10c03fcc 	andi	r3,r2,255
 20418a0:	e0bffb17 	ldw	r2,-20(fp)
 20418a4:	1080018b 	ldhu	r2,6(r2)
 20418a8:	10bfffcc 	andi	r2,r2,65535
 20418ac:	1004923a 	slli	r2,r2,8
 20418b0:	10bfffcc 	andi	r2,r2,65535
 20418b4:	1884b03a 	or	r2,r3,r2
 20418b8:	100490fa 	slli	r2,r2,3
 20418bc:	e0bffe0d 	sth	r2,-8(fp)
   total_len = ntohs(pip->ip_len);
 20418c0:	e0bffb17 	ldw	r2,-20(fp)
 20418c4:	1080008b 	ldhu	r2,2(r2)
 20418c8:	10bfffcc 	andi	r2,r2,65535
 20418cc:	1004d23a 	srli	r2,r2,8
 20418d0:	1007883a 	mov	r3,r2
 20418d4:	e0bffb17 	ldw	r2,-20(fp)
 20418d8:	1080008b 	ldhu	r2,2(r2)
 20418dc:	10bfffcc 	andi	r2,r2,65535
 20418e0:	1004923a 	slli	r2,r2,8
 20418e4:	1884b03a 	or	r2,r3,r2
 20418e8:	e0bffe8d 	sth	r2,-6(fp)

   /* now setup various fields in the IRE entry (multi-byte fields stored in network 
    * byte order) */
   irep->src = pip->ip_src;
 20418ec:	e0bffb17 	ldw	r2,-20(fp)
 20418f0:	10c00317 	ldw	r3,12(r2)
 20418f4:	e0bffa17 	ldw	r2,-24(fp)
 20418f8:	10c00115 	stw	r3,4(r2)
   irep->dest = pip->ip_dest;
 20418fc:	e0bffb17 	ldw	r2,-20(fp)
 2041900:	10c00417 	ldw	r3,16(r2)
 2041904:	e0bffa17 	ldw	r2,-24(fp)
 2041908:	10c00215 	stw	r3,8(r2)
   irep->prot = pip->ip_prot;
 204190c:	e0bffb17 	ldw	r2,-20(fp)
 2041910:	10c00243 	ldbu	r3,9(r2)
 2041914:	e0bffa17 	ldw	r2,-24(fp)
 2041918:	10c00385 	stb	r3,14(r2)
   irep->id = pip->ip_id;
 204191c:	e0bffb17 	ldw	r2,-20(fp)
 2041920:	10c0010b 	ldhu	r3,4(r2)
 2041924:	e0bffa17 	ldw	r2,-24(fp)
 2041928:	10c0030d 	sth	r3,12(r2)
   if (ftype == IP_LF)
 204192c:	e0bffd17 	ldw	r2,-12(fp)
 2041930:	10800158 	cmpnei	r2,r2,5
 2041934:	10000a1e 	bne	r2,zero,2041960 <ip_reasm_process_first_fragment+0x1cc>
      {
      irep->length = frag_offset + (total_len - iphlen);
 2041938:	e0bffc03 	ldbu	r2,-16(fp)
 204193c:	e0fffe8b 	ldhu	r3,-6(fp)
 2041940:	1885c83a 	sub	r2,r3,r2
 2041944:	1007883a 	mov	r3,r2
 2041948:	e0bffe0b 	ldhu	r2,-8(fp)
 204194c:	1885883a 	add	r2,r3,r2
 2041950:	1007883a 	mov	r3,r2
 2041954:	e0bffa17 	ldw	r2,-24(fp)
 2041958:	10c0040d 	sth	r3,16(r2)
 204195c:	00000a06 	br	2041988 <ip_reasm_process_first_fragment+0x1f4>
      }
   else if (ftype == IP_FF)
 2041960:	e0bffd17 	ldw	r2,-12(fp)
 2041964:	10800058 	cmpnei	r2,r2,1
 2041968:	1000071e 	bne	r2,zero,2041988 <ip_reasm_process_first_fragment+0x1f4>
       * out, and results in the transmission of an ICMP Time Exceeded message (with the
       * code set to "fragment reassembly time exceeded").  Please note that the 'l2_hdr' 
       * as set below may not be the start address for the L2 header (but it is adequate 
       * for our use).  If the FF is never received, these fields stay at their initial
       * value of 0. */
      irep->l2_hdr = p->nb_buff;
 204196c:	e0bfff17 	ldw	r2,-4(fp)
 2041970:	10c00117 	ldw	r3,4(r2)
 2041974:	e0bffa17 	ldw	r2,-24(fp)
 2041978:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 204197c:	e0bffa17 	ldw	r2,-24(fp)
 2041980:	e0fffb17 	ldw	r3,-20(fp)
 2041984:	10c02015 	stw	r3,128(r2)
      }

   /* note that the 'rcvd' and 'length' counters only keep track of the data part of 
    * the IP datagram */
   irep->rcvd = total_len - iphlen;
 2041988:	e0bffc03 	ldbu	r2,-16(fp)
 204198c:	e0fffe8b 	ldhu	r3,-6(fp)
 2041990:	1885c83a 	sub	r2,r3,r2
 2041994:	1007883a 	mov	r3,r2
 2041998:	e0bffa17 	ldw	r2,-24(fp)
 204199c:	10c0048d 	sth	r3,18(r2)
   irep->age = 0;
 20419a0:	e0bffa17 	ldw	r2,-24(fp)
 20419a4:	10000515 	stw	zero,20(r2)

   /* all RFQs are compact when created */
   irep->flags |= IPR_RFQ_COMPACT;
 20419a8:	e0bffa17 	ldw	r2,-24(fp)
 20419ac:	10802103 	ldbu	r2,132(r2)
 20419b0:	10800054 	ori	r2,r2,1
 20419b4:	1007883a 	mov	r3,r2
 20419b8:	e0bffa17 	ldw	r2,-24(fp)
 20419bc:	10c02105 	stb	r3,132(r2)

   /* store PACKET pointer in the first location of the first RFQ */
   irep->rfq.bufp[0] = p;
 20419c0:	e0bffa17 	ldw	r2,-24(fp)
 20419c4:	e0ffff17 	ldw	r3,-4(fp)
 20419c8:	10c00715 	stw	r3,28(r2)
   irep->rfq.frag_offset[0] = frag_offset;
 20419cc:	e0bffa17 	ldw	r2,-24(fp)
 20419d0:	e0fffe0b 	ldhu	r3,-8(fp)
 20419d4:	10c0170d 	sth	r3,92(r2)
   /* the next pointer in the RFQ is already 0 */

   p->nb_prot += iphlen;
 20419d8:	e0bfff17 	ldw	r2,-4(fp)
 20419dc:	10c00317 	ldw	r3,12(r2)
 20419e0:	e0bffc03 	ldbu	r2,-16(fp)
 20419e4:	1887883a 	add	r3,r3,r2
 20419e8:	e0bfff17 	ldw	r2,-4(fp)
 20419ec:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 20419f0:	e0bfff17 	ldw	r2,-4(fp)
 20419f4:	10c00417 	ldw	r3,16(r2)
 20419f8:	e0bffc03 	ldbu	r2,-16(fp)
 20419fc:	1887c83a 	sub	r3,r3,r2
 2041a00:	e0bfff17 	ldw	r2,-4(fp)
 2041a04:	10c00415 	stw	r3,16(r2)

   /* insert at start of global IRE list */
   irep->next = h_ireq;
 2041a08:	d0e0be17 	ldw	r3,-32008(gp)
 2041a0c:	e0bffa17 	ldw	r2,-24(fp)
 2041a10:	10c00015 	stw	r3,0(r2)
   h_ireq = irep;
 2041a14:	e0bffa17 	ldw	r2,-24(fp)
 2041a18:	d0a0be15 	stw	r2,-32008(gp)

   /* increment the memory useage */
   ip_reasm_incr_mem_useage (p->nb_blen + (sizeof (IRE)));
 2041a1c:	e0bfff17 	ldw	r2,-4(fp)
 2041a20:	10800217 	ldw	r2,8(r2)
 2041a24:	10802204 	addi	r2,r2,136
 2041a28:	10bfffcc 	andi	r2,r2,65535
 2041a2c:	1009883a 	mov	r4,r2
 2041a30:	204165c0 	call	204165c <ip_reasm_incr_mem_useage>

   return IPREASM_OK;
 2041a34:	0005883a 	mov	r2,zero
}
 2041a38:	e037883a 	mov	sp,fp
 2041a3c:	dfc00117 	ldw	ra,4(sp)
 2041a40:	df000017 	ldw	fp,0(sp)
 2041a44:	dec00204 	addi	sp,sp,8
 2041a48:	f800283a 	ret

02041a4c <ip_reassm>:
merely passes their return code back to its caller.  Otherwise, it returns
IPREASM_OK indicating that the fragment was successfully processed.
*/

int ip_reassm (PACKET p)
{
 2041a4c:	defff904 	addi	sp,sp,-28
 2041a50:	dfc00615 	stw	ra,24(sp)
 2041a54:	df000515 	stw	fp,20(sp)
 2041a58:	df000504 	addi	fp,sp,20
 2041a5c:	e13fff15 	stw	r4,-4(fp)
   IREP irep;
   struct ip * pip;
   int rc1, rc2;

   pip = ip_head(p);
 2041a60:	e0bfff17 	ldw	r2,-4(fp)
 2041a64:	10800317 	ldw	r2,12(r2)
 2041a68:	e0bffb15 	stw	r2,-20(fp)

   /* we have just received a fragment, so let's start processing it.  First
    * check for a matching IRE entry. */
   irep = ip_reasm_match_frag_with_ire (pip);
 2041a6c:	e13ffb17 	ldw	r4,-20(fp)
 2041a70:	20414340 	call	2041434 <ip_reasm_match_frag_with_ire>
 2041a74:	e0bffc15 	stw	r2,-16(fp)

   if (!irep)
 2041a78:	e0bffc17 	ldw	r2,-16(fp)
 2041a7c:	1000071e 	bne	r2,zero,2041a9c <ip_reassm+0x50>
   {
      /* this is the first packet for a "new" fragment stream */
      if ((rc1 = ip_reasm_process_first_fragment (p)) != IPREASM_OK)
 2041a80:	e13fff17 	ldw	r4,-4(fp)
 2041a84:	20417940 	call	2041794 <ip_reasm_process_first_fragment>
 2041a88:	e0bffd15 	stw	r2,-12(fp)
 2041a8c:	e0bffd17 	ldw	r2,-12(fp)
 2041a90:	10000a26 	beq	r2,zero,2041abc <ip_reassm+0x70>
      {
         /* ip_reasm_process_first_fragment () will free the packet */
         return rc1;
 2041a94:	e0bffd17 	ldw	r2,-12(fp)
 2041a98:	00000906 	br	2041ac0 <ip_reassm+0x74>
      }
   }
   else
   {
      /* a matching IRE already exists for this fragment */
      if ((rc2 = ip_reasm_process_subsequent_fragments (p, irep)) != IPREASM_OK)
 2041a9c:	e13fff17 	ldw	r4,-4(fp)
 2041aa0:	e17ffc17 	ldw	r5,-16(fp)
 2041aa4:	20420380 	call	2042038 <ip_reasm_process_subsequent_fragments>
 2041aa8:	e0bffe15 	stw	r2,-8(fp)
 2041aac:	e0bffe17 	ldw	r2,-8(fp)
 2041ab0:	10000226 	beq	r2,zero,2041abc <ip_reassm+0x70>
      {
         /* ip_reasm_process_subsequent_fragments () has already deleted the IRE entry */
         return rc2;
 2041ab4:	e0bffe17 	ldw	r2,-8(fp)
 2041ab8:	00000106 	br	2041ac0 <ip_reassm+0x74>
      }
   }

   return IPREASM_OK;
 2041abc:	0005883a 	mov	r2,zero
}
 2041ac0:	e037883a 	mov	sp,fp
 2041ac4:	dfc00117 	ldw	ra,4(sp)
 2041ac8:	df000017 	ldw	fp,0(sp)
 2041acc:	dec00204 	addi	sp,sp,8
 2041ad0:	f800283a 	ret

02041ad4 <ip_reasm_compute_overlap>:
            (i.e., contains "unique" data).
*/

IPREASM_RC ip_reasm_compute_overlap (PACKET p, IREP irep, u_short * indexp, 
 RFQP * last_rfqpp, u_short * frag_offsetp, u_char * hole_createdp)
{
 2041ad4:	defff204 	addi	sp,sp,-56
 2041ad8:	dfc00d15 	stw	ra,52(sp)
 2041adc:	df000c15 	stw	fp,48(sp)
 2041ae0:	df000c04 	addi	fp,sp,48
 2041ae4:	e13ffc15 	stw	r4,-16(fp)
 2041ae8:	e17ffd15 	stw	r5,-12(fp)
 2041aec:	e1bffe15 	stw	r6,-8(fp)
 2041af0:	e1ffff15 	stw	r7,-4(fp)
   u_short currend;
   u_short drop_len;
   u_char iphlen;
   u_short i;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 2041af4:	e13ffd17 	ldw	r4,-12(fp)
 2041af8:	20425680 	call	2042568 <ip_reasm_find_ire>
 2041afc:	10803fcc 	andi	r2,r2,255
 2041b00:	10800060 	cmpeqi	r2,r2,1
 2041b04:	10000f1e 	bne	r2,zero,2041b44 <ip_reasm_compute_overlap+0x70>
      {
      ++ire_stats.bad_irep;
 2041b08:	00809934 	movhi	r2,612
 2041b0c:	10b7e704 	addi	r2,r2,-8292
 2041b10:	10800017 	ldw	r2,0(r2)
 2041b14:	10c00044 	addi	r3,r2,1
 2041b18:	00809934 	movhi	r2,612
 2041b1c:	10b7e704 	addi	r2,r2,-8292
 2041b20:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 2041b24:	01000084 	movi	r4,2
 2041b28:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free (p);
 2041b2c:	e13ffc17 	ldw	r4,-16(fp)
 2041b30:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2041b34:	01000084 	movi	r4,2
 2041b38:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return IPREASM_DROP_FRAG_BAD_PARAM;
 2041b3c:	00800044 	movi	r2,1
 2041b40:	00013806 	br	2042024 <ip_reasm_compute_overlap+0x550>
      }

   jrip = ip_head(p);
 2041b44:	e0bffc17 	ldw	r2,-16(fp)
 2041b48:	10800317 	ldw	r2,12(r2)
 2041b4c:	e0bff715 	stw	r2,-36(fp)
   iphlen = ip_hlen (jrip);
 2041b50:	e0bff717 	ldw	r2,-36(fp)
 2041b54:	10800003 	ldbu	r2,0(r2)
 2041b58:	108003cc 	andi	r2,r2,15
 2041b5c:	1085883a 	add	r2,r2,r2
 2041b60:	1085883a 	add	r2,r2,r2
 2041b64:	e0bff805 	stb	r2,-32(fp)
   jrstart = (((ntohs(jrip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3);
 2041b68:	e0bff717 	ldw	r2,-36(fp)
 2041b6c:	1080018b 	ldhu	r2,6(r2)
 2041b70:	10bfffcc 	andi	r2,r2,65535
 2041b74:	1004d23a 	srli	r2,r2,8
 2041b78:	10bfffcc 	andi	r2,r2,65535
 2041b7c:	10c03fcc 	andi	r3,r2,255
 2041b80:	e0bff717 	ldw	r2,-36(fp)
 2041b84:	1080018b 	ldhu	r2,6(r2)
 2041b88:	10bfffcc 	andi	r2,r2,65535
 2041b8c:	1004923a 	slli	r2,r2,8
 2041b90:	10bfffcc 	andi	r2,r2,65535
 2041b94:	1884b03a 	or	r2,r3,r2
 2041b98:	100490fa 	slli	r2,r2,3
 2041b9c:	e0bff50d 	sth	r2,-44(fp)
   jrend =   jrstart + ((ntohs(jrip->ip_len)) - iphlen) - 1;
 2041ba0:	e0bff717 	ldw	r2,-36(fp)
 2041ba4:	1080008b 	ldhu	r2,2(r2)
 2041ba8:	10bfffcc 	andi	r2,r2,65535
 2041bac:	1004d23a 	srli	r2,r2,8
 2041bb0:	1007883a 	mov	r3,r2
 2041bb4:	e0bff717 	ldw	r2,-36(fp)
 2041bb8:	1080008b 	ldhu	r2,2(r2)
 2041bbc:	10bfffcc 	andi	r2,r2,65535
 2041bc0:	1004923a 	slli	r2,r2,8
 2041bc4:	1884b03a 	or	r2,r3,r2
 2041bc8:	1007883a 	mov	r3,r2
 2041bcc:	e0bff803 	ldbu	r2,-32(fp)
 2041bd0:	1885c83a 	sub	r2,r3,r2
 2041bd4:	1007883a 	mov	r3,r2
 2041bd8:	e0bff50b 	ldhu	r2,-44(fp)
 2041bdc:	1885883a 	add	r2,r3,r2
 2041be0:	10bfffc4 	addi	r2,r2,-1
 2041be4:	e0bff58d 	sth	r2,-42(fp)
   /* skip past the IP header of the just received fragment as we get ready 
    * to compare for overlap between the just received fragment and the 
    * fragments that are currently queued in the IRE entry for this fragment 
    * chain */
   p->nb_prot += iphlen;
 2041be8:	e0bffc17 	ldw	r2,-16(fp)
 2041bec:	10c00317 	ldw	r3,12(r2)
 2041bf0:	e0bff803 	ldbu	r2,-32(fp)
 2041bf4:	1887883a 	add	r3,r3,r2
 2041bf8:	e0bffc17 	ldw	r2,-16(fp)
 2041bfc:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= iphlen;
 2041c00:	e0bffc17 	ldw	r2,-16(fp)
 2041c04:	10c00417 	ldw	r3,16(r2)
 2041c08:	e0bff803 	ldbu	r2,-32(fp)
 2041c0c:	1887c83a 	sub	r3,r3,r2
 2041c10:	e0bffc17 	ldw	r2,-16(fp)
 2041c14:	10c00415 	stw	r3,16(r2)

   *frag_offsetp = jrstart;
 2041c18:	e0800217 	ldw	r2,8(fp)
 2041c1c:	e0fff50b 	ldhu	r3,-44(fp)
 2041c20:	10c0000d 	sth	r3,0(r2)
   *indexp = INVALID_FRAG_INDEX;
 2041c24:	e0bffe17 	ldw	r2,-8(fp)
 2041c28:	00c00404 	movi	r3,16
 2041c2c:	10c0000d 	sth	r3,0(r2)
   *last_rfqpp = 0;
 2041c30:	e0bfff17 	ldw	r2,-4(fp)
 2041c34:	10000015 	stw	zero,0(r2)
   *hole_createdp = IPREASM_FALSE;
 2041c38:	e0800317 	ldw	r2,12(fp)
 2041c3c:	10000005 	stb	zero,0(r2)

   rfqp = &(irep->rfq);
 2041c40:	e0bffd17 	ldw	r2,-12(fp)
 2041c44:	10800604 	addi	r2,r2,24
 2041c48:	e0bff415 	stw	r2,-48(fp)

   while (rfqp)
 2041c4c:	0000ef06 	br	204200c <ip_reasm_compute_overlap+0x538>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2041c50:	e03ff60d 	sth	zero,-40(fp)
 2041c54:	0000dd06 	br	2041fcc <ip_reasm_compute_overlap+0x4f8>
         {
         if ((currpkt = rfqp->bufp[i]) != 0)
 2041c58:	e0bff60b 	ldhu	r2,-40(fp)
 2041c5c:	e0fff417 	ldw	r3,-48(fp)
 2041c60:	10800044 	addi	r2,r2,1
 2041c64:	1085883a 	add	r2,r2,r2
 2041c68:	1085883a 	add	r2,r2,r2
 2041c6c:	1885883a 	add	r2,r3,r2
 2041c70:	10800017 	ldw	r2,0(r2)
 2041c74:	e0bff915 	stw	r2,-28(fp)
 2041c78:	e0bff917 	ldw	r2,-28(fp)
 2041c7c:	1000c026 	beq	r2,zero,2041f80 <ip_reasm_compute_overlap+0x4ac>
            {
            currstart = rfqp->frag_offset[i];
 2041c80:	e0bff60b 	ldhu	r2,-40(fp)
 2041c84:	e0fff417 	ldw	r3,-48(fp)
 2041c88:	10800884 	addi	r2,r2,34
 2041c8c:	1085883a 	add	r2,r2,r2
 2041c90:	1885883a 	add	r2,r3,r2
 2041c94:	1080000b 	ldhu	r2,0(r2)
 2041c98:	e0bffa0d 	sth	r2,-24(fp)
            currend = currstart + currpkt->nb_plen - 1;
 2041c9c:	e0bff917 	ldw	r2,-28(fp)
 2041ca0:	10800417 	ldw	r2,16(r2)
 2041ca4:	1007883a 	mov	r3,r2
 2041ca8:	e0bffa0b 	ldhu	r2,-24(fp)
 2041cac:	1885883a 	add	r2,r3,r2
 2041cb0:	10bfffc4 	addi	r2,r2,-1
 2041cb4:	e0bffa8d 	sth	r2,-22(fp)

            if (currstart < jrstart)
 2041cb8:	e0fffa0b 	ldhu	r3,-24(fp)
 2041cbc:	e0bff50b 	ldhu	r2,-44(fp)
 2041cc0:	18802b2e 	bgeu	r3,r2,2041d70 <ip_reasm_compute_overlap+0x29c>
               {
               if (currend < jrend) /* cases A1 and A2 */
 2041cc4:	e0fffa8b 	ldhu	r3,-22(fp)
 2041cc8:	e0bff58b 	ldhu	r2,-42(fp)
 2041ccc:	1880202e 	bgeu	r3,r2,2041d50 <ip_reasm_compute_overlap+0x27c>
                  {
                  if (currend < jrstart) /* A1 */
 2041cd0:	e0fffa8b 	ldhu	r3,-22(fp)
 2041cd4:	e0bff50b 	ldhu	r2,-44(fp)
 2041cd8:	1880b936 	bltu	r3,r2,2041fc0 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* the just received fragment partially overlaps current 
                      * fragment on the latter's right; increment start 
                      * pointer and decrement length of just received fragment.
                      * Move on to the next fragment in the RFQ. */
                     drop_len = (currend - jrstart) + 1;
 2041cdc:	e0fffa8b 	ldhu	r3,-22(fp)
 2041ce0:	e0bff50b 	ldhu	r2,-44(fp)
 2041ce4:	1885c83a 	sub	r2,r3,r2
 2041ce8:	10800044 	addi	r2,r2,1
 2041cec:	e0bffb0d 	sth	r2,-20(fp)
                     p->nb_prot += drop_len;
 2041cf0:	e0bffc17 	ldw	r2,-16(fp)
 2041cf4:	10c00317 	ldw	r3,12(r2)
 2041cf8:	e0bffb0b 	ldhu	r2,-20(fp)
 2041cfc:	1887883a 	add	r3,r3,r2
 2041d00:	e0bffc17 	ldw	r2,-16(fp)
 2041d04:	10c00315 	stw	r3,12(r2)
                     p->nb_plen -= drop_len;
 2041d08:	e0bffc17 	ldw	r2,-16(fp)
 2041d0c:	10c00417 	ldw	r3,16(r2)
 2041d10:	e0bffb0b 	ldhu	r2,-20(fp)
 2041d14:	1887c83a 	sub	r3,r3,r2
 2041d18:	e0bffc17 	ldw	r2,-16(fp)
 2041d1c:	10c00415 	stw	r3,16(r2)
                     jrstart += drop_len;
 2041d20:	e0fff50b 	ldhu	r3,-44(fp)
 2041d24:	e0bffb0b 	ldhu	r2,-20(fp)
 2041d28:	1885883a 	add	r2,r3,r2
 2041d2c:	e0bff50d 	sth	r2,-44(fp)
                     jrend = jrstart + p->nb_plen - 1;
 2041d30:	e0bffc17 	ldw	r2,-16(fp)
 2041d34:	10800417 	ldw	r2,16(r2)
 2041d38:	1007883a 	mov	r3,r2
 2041d3c:	e0bff50b 	ldhu	r2,-44(fp)
 2041d40:	1885883a 	add	r2,r3,r2
 2041d44:	10bfffc4 	addi	r2,r2,-1
 2041d48:	e0bff58d 	sth	r2,-42(fp)
 2041d4c:	00009c06 	br	2041fc0 <ip_reasm_compute_overlap+0x4ec>
               else
                  {
                  /* currend is greater than or equal to jrend (cases E1 and E2).
                   * The current fragment is a superset of the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 2041d50:	01000084 	movi	r4,2
 2041d54:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
                  pk_free (p);
 2041d58:	e13ffc17 	ldw	r4,-16(fp)
 2041d5c:	20280440 	call	2028044 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2041d60:	01000084 	movi	r4,2
 2041d64:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 2041d68:	0005883a 	mov	r2,zero
 2041d6c:	0000ad06 	br	2042024 <ip_reasm_compute_overlap+0x550>
                  }
               }
            else if (currstart > jrstart)
 2041d70:	e0bffa0b 	ldhu	r2,-24(fp)
 2041d74:	e0fff50b 	ldhu	r3,-44(fp)
 2041d78:	18804e2e 	bgeu	r3,r2,2041eb4 <ip_reasm_compute_overlap+0x3e0>
               {
               if (currend > jrend) /* cases B1 and B2 */
 2041d7c:	e0bffa8b 	ldhu	r2,-22(fp)
 2041d80:	e0fff58b 	ldhu	r3,-42(fp)
 2041d84:	1880112e 	bgeu	r3,r2,2041dcc <ip_reasm_compute_overlap+0x2f8>
                  {
                  if (currstart > jrend) /* B1 */
 2041d88:	e0bffa0b 	ldhu	r2,-24(fp)
 2041d8c:	e0fff58b 	ldhu	r3,-42(fp)
 2041d90:	18808b36 	bltu	r3,r2,2041fc0 <ip_reasm_compute_overlap+0x4ec>
                     {
                     /* just received fragment partially overlaps current 
                      * fragment on the latter's left; decrement length of 
                      * just received fragment.  Move on to the next fragment 
                      * in the RFQ. */
                     p->nb_plen = currstart - jrstart;
 2041d94:	e0fffa0b 	ldhu	r3,-24(fp)
 2041d98:	e0bff50b 	ldhu	r2,-44(fp)
 2041d9c:	1885c83a 	sub	r2,r3,r2
 2041da0:	1007883a 	mov	r3,r2
 2041da4:	e0bffc17 	ldw	r2,-16(fp)
 2041da8:	10c00415 	stw	r3,16(r2)
                     /* start offset remains unchanged, but jrend must be updated */
                     jrend = jrstart + p->nb_plen - 1;
 2041dac:	e0bffc17 	ldw	r2,-16(fp)
 2041db0:	10800417 	ldw	r2,16(r2)
 2041db4:	1007883a 	mov	r3,r2
 2041db8:	e0bff50b 	ldhu	r2,-44(fp)
 2041dbc:	1885883a 	add	r2,r3,r2
 2041dc0:	10bfffc4 	addi	r2,r2,-1
 2041dc4:	e0bff58d 	sth	r2,-42(fp)
 2041dc8:	00007d06 	br	2041fc0 <ip_reasm_compute_overlap+0x4ec>
                     }
                  }
               else if (currend == jrend) /* F1 */
 2041dcc:	e0fffa8b 	ldhu	r3,-22(fp)
 2041dd0:	e0bff58b 	ldhu	r2,-42(fp)
 2041dd4:	18800e1e 	bne	r3,r2,2041e10 <ip_reasm_compute_overlap+0x33c>
                  {
                  /* current fragment is a subset of the just received fragment.  
                   * Decrement the length of the just received fragment.  Move
                   * on to the next fragment in the RFQ. */
                  p->nb_plen = currstart - jrstart;
 2041dd8:	e0fffa0b 	ldhu	r3,-24(fp)
 2041ddc:	e0bff50b 	ldhu	r2,-44(fp)
 2041de0:	1885c83a 	sub	r2,r3,r2
 2041de4:	1007883a 	mov	r3,r2
 2041de8:	e0bffc17 	ldw	r2,-16(fp)
 2041dec:	10c00415 	stw	r3,16(r2)
                  jrend = jrstart + p->nb_plen - 1;
 2041df0:	e0bffc17 	ldw	r2,-16(fp)
 2041df4:	10800417 	ldw	r2,16(r2)
 2041df8:	1007883a 	mov	r3,r2
 2041dfc:	e0bff50b 	ldhu	r2,-44(fp)
 2041e00:	1885883a 	add	r2,r3,r2
 2041e04:	10bfffc4 	addi	r2,r2,-1
 2041e08:	e0bff58d 	sth	r2,-42(fp)
 2041e0c:	00006c06 	br	2041fc0 <ip_reasm_compute_overlap+0x4ec>
                  {
                  /* currend is less than jrend (case F2).  current fragment is 
                   * a subset of the just received fragment.  Drop current
                   * fragment.  Move on to the next fragment in the RFQ.  Decrement
                   * the amount of memory currently in use. */
                  ip_reasm_decr_mem_useage (currpkt->nb_blen);
 2041e10:	e0bff917 	ldw	r2,-28(fp)
 2041e14:	10800217 	ldw	r2,8(r2)
 2041e18:	10bfffcc 	andi	r2,r2,65535
 2041e1c:	1009883a 	mov	r4,r2
 2041e20:	20416fc0 	call	20416fc <ip_reasm_decr_mem_useage>
                  irep->rcvd -= currpkt->nb_plen;
 2041e24:	e0bffd17 	ldw	r2,-12(fp)
 2041e28:	10c0048b 	ldhu	r3,18(r2)
 2041e2c:	e0bff917 	ldw	r2,-28(fp)
 2041e30:	10800417 	ldw	r2,16(r2)
 2041e34:	1885c83a 	sub	r2,r3,r2
 2041e38:	1007883a 	mov	r3,r2
 2041e3c:	e0bffd17 	ldw	r2,-12(fp)
 2041e40:	10c0048d 	sth	r3,18(r2)
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 2041e44:	01000084 	movi	r4,2
 2041e48:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
                  pk_free (currpkt);
 2041e4c:	e13ff917 	ldw	r4,-28(fp)
 2041e50:	20280440 	call	2028044 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2041e54:	01000084 	movi	r4,2
 2041e58:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
                  rfqp->bufp[i] = 0; /* mark slot as unused */
 2041e5c:	e0bff60b 	ldhu	r2,-40(fp)
 2041e60:	e0fff417 	ldw	r3,-48(fp)
 2041e64:	10800044 	addi	r2,r2,1
 2041e68:	1085883a 	add	r2,r2,r2
 2041e6c:	1085883a 	add	r2,r2,r2
 2041e70:	1885883a 	add	r2,r3,r2
 2041e74:	10000015 	stw	zero,0(r2)
                  /* save the location of the empty slot */
                  if ((*indexp) == INVALID_FRAG_INDEX) 
 2041e78:	e0bffe17 	ldw	r2,-8(fp)
 2041e7c:	1080000b 	ldhu	r2,0(r2)
 2041e80:	10bfffcc 	andi	r2,r2,65535
 2041e84:	10800418 	cmpnei	r2,r2,16
 2041e88:	1000061e 	bne	r2,zero,2041ea4 <ip_reasm_compute_overlap+0x3d0>
                     {
                     *indexp = i;
 2041e8c:	e0bffe17 	ldw	r2,-8(fp)
 2041e90:	e0fff60b 	ldhu	r3,-40(fp)
 2041e94:	10c0000d 	sth	r3,0(r2)
                     *last_rfqpp = rfqp;
 2041e98:	e0bfff17 	ldw	r2,-4(fp)
 2041e9c:	e0fff417 	ldw	r3,-48(fp)
 2041ea0:	10c00015 	stw	r3,0(r2)
                     }
                  /* we've just created a hole; the array may no longer be "compact" */
                  *hole_createdp = IPREASM_TRUE;
 2041ea4:	e0800317 	ldw	r2,12(fp)
 2041ea8:	00c00044 	movi	r3,1
 2041eac:	10c00005 	stb	r3,0(r2)
 2041eb0:	00004306 	br	2041fc0 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            else
               {
               /* currstart and jrstart are equal */
               if (currend == jrend) /* case C */
 2041eb4:	e0fffa8b 	ldhu	r3,-22(fp)
 2041eb8:	e0bff58b 	ldhu	r2,-42(fp)
 2041ebc:	1880081e 	bne	r3,r2,2041ee0 <ip_reasm_compute_overlap+0x40c>
                  {
                  /* the current fragment is identical to the just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 2041ec0:	01000084 	movi	r4,2
 2041ec4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
                  pk_free (p);
 2041ec8:	e13ffc17 	ldw	r4,-16(fp)
 2041ecc:	20280440 	call	2028044 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2041ed0:	01000084 	movi	r4,2
 2041ed4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 2041ed8:	0005883a 	mov	r2,zero
 2041edc:	00005106 	br	2042024 <ip_reasm_compute_overlap+0x550>
                  }
               else if (currend > jrend) /* case D1 */
 2041ee0:	e0bffa8b 	ldhu	r2,-22(fp)
 2041ee4:	e0fff58b 	ldhu	r3,-42(fp)
 2041ee8:	1880082e 	bgeu	r3,r2,2041f0c <ip_reasm_compute_overlap+0x438>
                  {
                  /* current fragment is a superset of just received 
                   * fragment.  Drop the just received fragment (and we're done). */
                  LOCK_NET_RESOURCE (FREEQ_RESID);
 2041eec:	01000084 	movi	r4,2
 2041ef0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
                  pk_free (p);
 2041ef4:	e13ffc17 	ldw	r4,-16(fp)
 2041ef8:	20280440 	call	2028044 <pk_free>
                  UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2041efc:	01000084 	movi	r4,2
 2041f00:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
                  return IPREASM_DROP_FRAG_DUPLICATE;
 2041f04:	0005883a 	mov	r2,zero
 2041f08:	00004606 	br	2042024 <ip_reasm_compute_overlap+0x550>
                  /* currend is less than jrend (case D2).  current fragment 
                   * is a subset of the just received fragment.  Increment 
                   * the start pointer and decrement the length of the just
                   * received fragment.  Move on to the next fragment in 
                   * the RFQ. */
                  drop_len = (currend - jrstart) + 1;
 2041f0c:	e0fffa8b 	ldhu	r3,-22(fp)
 2041f10:	e0bff50b 	ldhu	r2,-44(fp)
 2041f14:	1885c83a 	sub	r2,r3,r2
 2041f18:	10800044 	addi	r2,r2,1
 2041f1c:	e0bffb0d 	sth	r2,-20(fp)
                  p->nb_prot += drop_len;
 2041f20:	e0bffc17 	ldw	r2,-16(fp)
 2041f24:	10c00317 	ldw	r3,12(r2)
 2041f28:	e0bffb0b 	ldhu	r2,-20(fp)
 2041f2c:	1887883a 	add	r3,r3,r2
 2041f30:	e0bffc17 	ldw	r2,-16(fp)
 2041f34:	10c00315 	stw	r3,12(r2)
                  p->nb_plen -= drop_len;
 2041f38:	e0bffc17 	ldw	r2,-16(fp)
 2041f3c:	10c00417 	ldw	r3,16(r2)
 2041f40:	e0bffb0b 	ldhu	r2,-20(fp)
 2041f44:	1887c83a 	sub	r3,r3,r2
 2041f48:	e0bffc17 	ldw	r2,-16(fp)
 2041f4c:	10c00415 	stw	r3,16(r2)
                  jrstart += drop_len;
 2041f50:	e0fff50b 	ldhu	r3,-44(fp)
 2041f54:	e0bffb0b 	ldhu	r2,-20(fp)
 2041f58:	1885883a 	add	r2,r3,r2
 2041f5c:	e0bff50d 	sth	r2,-44(fp)
                  jrend = jrstart + p->nb_plen - 1;
 2041f60:	e0bffc17 	ldw	r2,-16(fp)
 2041f64:	10800417 	ldw	r2,16(r2)
 2041f68:	1007883a 	mov	r3,r2
 2041f6c:	e0bff50b 	ldhu	r2,-44(fp)
 2041f70:	1885883a 	add	r2,r3,r2
 2041f74:	10bfffc4 	addi	r2,r2,-1
 2041f78:	e0bff58d 	sth	r2,-42(fp)
 2041f7c:	00001006 	br	2041fc0 <ip_reasm_compute_overlap+0x4ec>
                  }
               }
            } /* end if (PACKET buffer exists at this slot) */
         else
            {
            if ((*indexp) == INVALID_FRAG_INDEX)
 2041f80:	e0bffe17 	ldw	r2,-8(fp)
 2041f84:	1080000b 	ldhu	r2,0(r2)
 2041f88:	10bfffcc 	andi	r2,r2,65535
 2041f8c:	10800418 	cmpnei	r2,r2,16
 2041f90:	1000061e 	bne	r2,zero,2041fac <ip_reasm_compute_overlap+0x4d8>
               {
               *indexp = i;
 2041f94:	e0bffe17 	ldw	r2,-8(fp)
 2041f98:	e0fff60b 	ldhu	r3,-40(fp)
 2041f9c:	10c0000d 	sth	r3,0(r2)
               *last_rfqpp = rfqp;               
 2041fa0:	e0bfff17 	ldw	r2,-4(fp)
 2041fa4:	e0fff417 	ldw	r3,-48(fp)
 2041fa8:	10c00015 	stw	r3,0(r2)
               }
            if (irep->flags & IPR_RFQ_COMPACT)
 2041fac:	e0bffd17 	ldw	r2,-12(fp)
 2041fb0:	10802103 	ldbu	r2,132(r2)
 2041fb4:	10803fcc 	andi	r2,r2,255
 2041fb8:	1080004c 	andi	r2,r2,1
 2041fbc:	1000071e 	bne	r2,zero,2041fdc <ip_reasm_compute_overlap+0x508>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2041fc0:	e0bff60b 	ldhu	r2,-40(fp)
 2041fc4:	10800044 	addi	r2,r2,1
 2041fc8:	e0bff60d 	sth	r2,-40(fp)
 2041fcc:	e0bff60b 	ldhu	r2,-40(fp)
 2041fd0:	10800430 	cmpltui	r2,r2,16
 2041fd4:	103f201e 	bne	r2,zero,2041c58 <ip_reasm_compute_overlap+0x184>
 2041fd8:	00000106 	br	2041fe0 <ip_reasm_compute_overlap+0x50c>
               *indexp = i;
               *last_rfqpp = rfqp;               
               }
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 2041fdc:	0001883a 	nop
               }
            }
         } /* end FOR (0...(IPR_MAX_FRAGS - 1)) */

      /* skip saving RFQ pointer if we've already found an empty slot */
      if ((*indexp) == INVALID_FRAG_INDEX) 
 2041fe0:	e0bffe17 	ldw	r2,-8(fp)
 2041fe4:	1080000b 	ldhu	r2,0(r2)
 2041fe8:	10bfffcc 	andi	r2,r2,65535
 2041fec:	10800418 	cmpnei	r2,r2,16
 2041ff0:	1000031e 	bne	r2,zero,2042000 <ip_reasm_compute_overlap+0x52c>
         {
         *last_rfqpp = rfqp;
 2041ff4:	e0bfff17 	ldw	r2,-4(fp)
 2041ff8:	e0fff417 	ldw	r3,-48(fp)
 2041ffc:	10c00015 	stw	r3,0(r2)
         }
      rfqp = rfqp->next;
 2042000:	e0bff417 	ldw	r2,-48(fp)
 2042004:	10800017 	ldw	r2,0(r2)
 2042008:	e0bff415 	stw	r2,-48(fp)
   *last_rfqpp = 0;
   *hole_createdp = IPREASM_FALSE;

   rfqp = &(irep->rfq);

   while (rfqp)
 204200c:	e0bff417 	ldw	r2,-48(fp)
 2042010:	103f0f1e 	bne	r2,zero,2041c50 <ip_reasm_compute_overlap+0x17c>
      } /* end while (rfqp) */

   /* if no empty slots were found, (*last_rfqpp) will contain a pointer 
    * to the last RFQ that we were working with */

   *frag_offsetp = jrstart; /* stored in host byte order */
 2042014:	e0800217 	ldw	r2,8(fp)
 2042018:	e0fff50b 	ldhu	r3,-44(fp)
 204201c:	10c0000d 	sth	r3,0(r2)

   return IPREASM_ACCEPT_FRAG;
 2042020:	00800084 	movi	r2,2
}
 2042024:	e037883a 	mov	sp,fp
 2042028:	dfc00117 	ldw	ra,4(sp)
 204202c:	df000017 	ldw	fp,0(sp)
 2042030:	dec00204 	addi	sp,sp,8
 2042034:	f800283a 	ret

02042038 <ip_reasm_process_subsequent_fragments>:
            queued fragments (and hence has been dropped), or if the fragment
            has been processed successfully.
*/

int ip_reasm_process_subsequent_fragments (PACKET p, IREP irep)
{
 2042038:	defff104 	addi	sp,sp,-60
 204203c:	dfc00e15 	stw	ra,56(sp)
 2042040:	df000d15 	stw	fp,52(sp)
 2042044:	df000d04 	addi	fp,sp,52
 2042048:	e13ffe15 	stw	r4,-8(fp)
 204204c:	e17fff15 	stw	r5,-4(fp)
   PACKET reassy_pkt;
   struct ip * pip;
   RFQP new_rfqp = 0;
 2042050:	e03ff515 	stw	zero,-44(fp)
   u_short index;
   RFQP rfqp;
   u_short frag_offset;
   u_char hole_created;

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 2042054:	e13fff17 	ldw	r4,-4(fp)
 2042058:	20425680 	call	2042568 <ip_reasm_find_ire>
 204205c:	10803fcc 	andi	r2,r2,255
 2042060:	10800060 	cmpeqi	r2,r2,1
 2042064:	1000161e 	bne	r2,zero,20420c0 <ip_reasm_process_subsequent_fragments+0x88>
      {
      ++ire_stats.bad_irep;
 2042068:	00809934 	movhi	r2,612
 204206c:	10b7e704 	addi	r2,r2,-8292
 2042070:	10800017 	ldw	r2,0(r2)
 2042074:	10c00044 	addi	r3,r2,1
 2042078:	00809934 	movhi	r2,612
 204207c:	10b7e704 	addi	r2,r2,-8292
 2042080:	10c00015 	stw	r3,0(r2)
      LOCK_NET_RESOURCE (FREEQ_RESID);
 2042084:	01000084 	movi	r4,2
 2042088:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free (p);
 204208c:	e13ffe17 	ldw	r4,-8(fp)
 2042090:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2042094:	01000084 	movi	r4,2
 2042098:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ++ip_mib.ipReasmFails;
 204209c:	00809934 	movhi	r2,612
 20420a0:	10b7d304 	addi	r2,r2,-8372
 20420a4:	10800f17 	ldw	r2,60(r2)
 20420a8:	10c00044 	addi	r3,r2,1
 20420ac:	00809934 	movhi	r2,612
 20420b0:	10b7d304 	addi	r2,r2,-8372
 20420b4:	10c00f15 	stw	r3,60(r2)
      return ENP_PARAM;
 20420b8:	00bffd84 	movi	r2,-10
 20420bc:	00012506 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>
      }

   pip = ip_head(p);
 20420c0:	e0bffe17 	ldw	r2,-8(fp)
 20420c4:	10800317 	ldw	r2,12(r2)
 20420c8:	e0bff615 	stw	r2,-40(fp)
   ftype = ip_reasm_determine_type_of_frag (pip);
 20420cc:	e13ff617 	ldw	r4,-40(fp)
 20420d0:	20414f80 	call	20414f8 <ip_reasm_determine_type_of_frag>
 20420d4:	e0bff715 	stw	r2,-36(fp)
   /* this fragment is a destined for an already queued fragment stream.
    * we update the 'length' field for LFs here because ip_reasm_compute_overlap ()
    * modifies the received fragment's nb_prot pointer (thereby making its IP header 
    * inaccessible) */
   if (ftype == IP_LF)
 20420d8:	e0bff717 	ldw	r2,-36(fp)
 20420dc:	10800158 	cmpnei	r2,r2,5
 20420e0:	1000251e 	bne	r2,zero,2042178 <ip_reasm_process_subsequent_fragments+0x140>
      {
      irep->length = (((ntohs(pip->ip_flgs_foff)) & IP_EXTRACT_FOFF) << 3) + ((ntohs(pip->ip_len)) - ip_hlen(pip));
 20420e4:	e0bff617 	ldw	r2,-40(fp)
 20420e8:	1080018b 	ldhu	r2,6(r2)
 20420ec:	10bfffcc 	andi	r2,r2,65535
 20420f0:	1004d23a 	srli	r2,r2,8
 20420f4:	10bfffcc 	andi	r2,r2,65535
 20420f8:	10c03fcc 	andi	r3,r2,255
 20420fc:	e0bff617 	ldw	r2,-40(fp)
 2042100:	1080018b 	ldhu	r2,6(r2)
 2042104:	10bfffcc 	andi	r2,r2,65535
 2042108:	1004923a 	slli	r2,r2,8
 204210c:	10bfffcc 	andi	r2,r2,65535
 2042110:	1884b03a 	or	r2,r3,r2
 2042114:	100490fa 	slli	r2,r2,3
 2042118:	1007883a 	mov	r3,r2
 204211c:	e0bff617 	ldw	r2,-40(fp)
 2042120:	1080008b 	ldhu	r2,2(r2)
 2042124:	10bfffcc 	andi	r2,r2,65535
 2042128:	1004d23a 	srli	r2,r2,8
 204212c:	1009883a 	mov	r4,r2
 2042130:	e0bff617 	ldw	r2,-40(fp)
 2042134:	1080008b 	ldhu	r2,2(r2)
 2042138:	10bfffcc 	andi	r2,r2,65535
 204213c:	1004923a 	slli	r2,r2,8
 2042140:	2084b03a 	or	r2,r4,r2
 2042144:	1009883a 	mov	r4,r2
 2042148:	e0bff617 	ldw	r2,-40(fp)
 204214c:	10800003 	ldbu	r2,0(r2)
 2042150:	10803fcc 	andi	r2,r2,255
 2042154:	108003cc 	andi	r2,r2,15
 2042158:	1085883a 	add	r2,r2,r2
 204215c:	1085883a 	add	r2,r2,r2
 2042160:	2085c83a 	sub	r2,r4,r2
 2042164:	1885883a 	add	r2,r3,r2
 2042168:	1007883a 	mov	r3,r2
 204216c:	e0bfff17 	ldw	r2,-4(fp)
 2042170:	10c0040d 	sth	r3,16(r2)
 2042174:	00000a06 	br	20421a0 <ip_reasm_process_subsequent_fragments+0x168>
      }
   else if (ftype == IP_FF)
 2042178:	e0bff717 	ldw	r2,-36(fp)
 204217c:	10800058 	cmpnei	r2,r2,1
 2042180:	1000071e 	bne	r2,zero,20421a0 <ip_reasm_process_subsequent_fragments+0x168>
      {
      irep->l2_hdr = p->nb_buff;
 2042184:	e0bffe17 	ldw	r2,-8(fp)
 2042188:	10c00117 	ldw	r3,4(r2)
 204218c:	e0bfff17 	ldw	r2,-4(fp)
 2042190:	10c01f15 	stw	r3,124(r2)
      irep->l3_hdr = (char *) pip;
 2042194:	e0bfff17 	ldw	r2,-4(fp)
 2042198:	e0fff617 	ldw	r3,-40(fp)
 204219c:	10c02015 	stw	r3,128(r2)
      }

   /* Check for overlap, and determine the increase in memory resource 
    * requirements from the newly arrived fragment */
   if ((rc2 = ip_reasm_compute_overlap (p, irep, &index, &rfqp, &frag_offset, &hole_created)) != IPREASM_ACCEPT_FRAG)
 20421a0:	e0fffb04 	addi	r3,fp,-20
 20421a4:	e0bffc04 	addi	r2,fp,-16
 20421a8:	e13ffd04 	addi	r4,fp,-12
 20421ac:	d9000015 	stw	r4,0(sp)
 20421b0:	e13ffd84 	addi	r4,fp,-10
 20421b4:	d9000115 	stw	r4,4(sp)
 20421b8:	e13ffe17 	ldw	r4,-8(fp)
 20421bc:	e17fff17 	ldw	r5,-4(fp)
 20421c0:	180d883a 	mov	r6,r3
 20421c4:	100f883a 	mov	r7,r2
 20421c8:	2041ad40 	call	2041ad4 <ip_reasm_compute_overlap>
 20421cc:	e0bff815 	stw	r2,-32(fp)
 20421d0:	e0bff817 	ldw	r2,-32(fp)
 20421d4:	108000a0 	cmpeqi	r2,r2,2
 20421d8:	1000091e 	bne	r2,zero,2042200 <ip_reasm_process_subsequent_fragments+0x1c8>
      {
      switch (rc2)
 20421dc:	e0bff817 	ldw	r2,-32(fp)
 20421e0:	10c00060 	cmpeqi	r3,r2,1
 20421e4:	1800031e 	bne	r3,zero,20421f4 <ip_reasm_process_subsequent_fragments+0x1bc>
 20421e8:	00800436 	bltu	zero,r2,20421fc <ip_reasm_process_subsequent_fragments+0x1c4>
         {
         case IPREASM_DROP_FRAG_DUPLICATE:
            /* this isn't really an error, since it indicates that the received 
             * fragment's information is a duplicate of what is present in the 
             * already queued fragments */
            return IPREASM_OK;
 20421ec:	0005883a 	mov	r2,zero
 20421f0:	0000d806 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>
         case IPREASM_DROP_FRAG_BAD_PARAM:
            /* this is a real error */
            return ENP_PARAM;
 20421f4:	00bffd84 	movi	r2,-10
 20421f8:	0000d606 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>
          * Altera Niche Stack Nios port modification:
          * Handle IPREASM_ACCEPT_FRAG case (will never
          * get here per if() above) to remove build warning.
          */
         case IPREASM_ACCEPT_FRAG:
            while(0);
 20421fc:	0001883a 	nop
      }

   /* this is a fragment from an existing fragment stream; 
    * check for resource limits before accepting it.  For now
    * assume that an extra RFQ is not required. */
   if ((rc = ip_reasm_check_mem_useage (p->nb_blen)) != IPREASM_OK)
 2042200:	e0bffe17 	ldw	r2,-8(fp)
 2042204:	10800217 	ldw	r2,8(r2)
 2042208:	10bfffcc 	andi	r2,r2,65535
 204220c:	1009883a 	mov	r4,r2
 2042210:	20415c80 	call	20415c8 <ip_reasm_check_mem_useage>
 2042214:	e0bff915 	stw	r2,-28(fp)
 2042218:	e0bff917 	ldw	r2,-28(fp)
 204221c:	10001126 	beq	r2,zero,2042264 <ip_reasm_process_subsequent_fragments+0x22c>
      {
      LOCK_NET_RESOURCE (FREEQ_RESID);
 2042220:	01000084 	movi	r4,2
 2042224:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free (p);
 2042228:	e13ffe17 	ldw	r4,-8(fp)
 204222c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2042230:	01000084 	movi	r4,2
 2042234:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      ip_reasm_delete_ire (irep);
 2042238:	e13fff17 	ldw	r4,-4(fp)
 204223c:	2042a280 	call	2042a28 <ip_reasm_delete_ire>
      ++ip_mib.ipReasmFails;
 2042240:	00809934 	movhi	r2,612
 2042244:	10b7d304 	addi	r2,r2,-8372
 2042248:	10800f17 	ldw	r2,60(r2)
 204224c:	10c00044 	addi	r3,r2,1
 2042250:	00809934 	movhi	r2,612
 2042254:	10b7d304 	addi	r2,r2,-8372
 2042258:	10c00f15 	stw	r3,60(r2)
      return rc;
 204225c:	e0bff917 	ldw	r2,-28(fp)
 2042260:	0000bc06 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>

   /* the two combinations of index and rfqp are as follows:
    * (1) index = INVALID_FRAG_INDEX, rfqp = non-zero: no empty slot found in RFQ(s),
    *     and rfqp points to the last RFQ that was processed
    * (2) index != INVALID_FRAG_INDEX, rfqp = non-zero: empty slot found in RFQ(s) */
   if (index != INVALID_FRAG_INDEX)
 2042264:	e0bffb0b 	ldhu	r2,-20(fp)
 2042268:	10bfffcc 	andi	r2,r2,65535
 204226c:	10800420 	cmpeqi	r2,r2,16
 2042270:	1000121e 	bne	r2,zero,20422bc <ip_reasm_process_subsequent_fragments+0x284>
      {
      /* we have an empty slot in the PACKET array into which we can place 
       * the just received fragment */
      rfqp->bufp[index] = p;
 2042274:	e0fffc17 	ldw	r3,-16(fp)
 2042278:	e0bffb0b 	ldhu	r2,-20(fp)
 204227c:	10bfffcc 	andi	r2,r2,65535
 2042280:	10800044 	addi	r2,r2,1
 2042284:	1085883a 	add	r2,r2,r2
 2042288:	1085883a 	add	r2,r2,r2
 204228c:	1885883a 	add	r2,r3,r2
 2042290:	e0fffe17 	ldw	r3,-8(fp)
 2042294:	10c00015 	stw	r3,0(r2)
      rfqp->frag_offset[index] = frag_offset;
 2042298:	e13ffc17 	ldw	r4,-16(fp)
 204229c:	e0bffb0b 	ldhu	r2,-20(fp)
 20422a0:	10bfffcc 	andi	r2,r2,65535
 20422a4:	e0fffd0b 	ldhu	r3,-12(fp)
 20422a8:	10800884 	addi	r2,r2,34
 20422ac:	1085883a 	add	r2,r2,r2
 20422b0:	2085883a 	add	r2,r4,r2
 20422b4:	10c0000d 	sth	r3,0(r2)
 20422b8:	00003906 	br	20423a0 <ip_reasm_process_subsequent_fragments+0x368>
      }
   else
      {
      /* since we need to allocate an extra RFQ, check for memory useage again... */
      if ((rc = ip_reasm_check_mem_useage (p->nb_blen + (sizeof (RFQ)))) != IPREASM_OK)
 20422bc:	e0bffe17 	ldw	r2,-8(fp)
 20422c0:	10800217 	ldw	r2,8(r2)
 20422c4:	10801904 	addi	r2,r2,100
 20422c8:	10bfffcc 	andi	r2,r2,65535
 20422cc:	1009883a 	mov	r4,r2
 20422d0:	20415c80 	call	20415c8 <ip_reasm_check_mem_useage>
 20422d4:	e0bff915 	stw	r2,-28(fp)
 20422d8:	e0bff917 	ldw	r2,-28(fp)
 20422dc:	10001126 	beq	r2,zero,2042324 <ip_reasm_process_subsequent_fragments+0x2ec>
         {
         LOCK_NET_RESOURCE (FREEQ_RESID);
 20422e0:	01000084 	movi	r4,2
 20422e4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free (p);
 20422e8:	e13ffe17 	ldw	r4,-8(fp)
 20422ec:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 20422f0:	01000084 	movi	r4,2
 20422f4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 20422f8:	e13fff17 	ldw	r4,-4(fp)
 20422fc:	2042a280 	call	2042a28 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 2042300:	00809934 	movhi	r2,612
 2042304:	10b7d304 	addi	r2,r2,-8372
 2042308:	10800f17 	ldw	r2,60(r2)
 204230c:	10c00044 	addi	r3,r2,1
 2042310:	00809934 	movhi	r2,612
 2042314:	10b7d304 	addi	r2,r2,-8372
 2042318:	10c00f15 	stw	r3,60(r2)
         return rc;
 204231c:	e0bff917 	ldw	r2,-28(fp)
 2042320:	00008c06 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>
         }

      /* no slots are available in the one (or more) existing RFQs; we 
       * need to create a new RFQ to store the just received fragment */
      new_rfqp = (RFQP) IPR_ALLOC (sizeof(RFQ));
 2042324:	01001904 	movi	r4,100
 2042328:	20290400 	call	2029040 <npalloc>
 204232c:	e0bff515 	stw	r2,-44(fp)
      if (new_rfqp == 0)
 2042330:	e0bff517 	ldw	r2,-44(fp)
 2042334:	1000111e 	bne	r2,zero,204237c <ip_reasm_process_subsequent_fragments+0x344>
         {
         /* can't store the existing fragment, so we'll drop it */
         LOCK_NET_RESOURCE (FREEQ_RESID);
 2042338:	01000084 	movi	r4,2
 204233c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free (p);
 2042340:	e13ffe17 	ldw	r4,-8(fp)
 2042344:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2042348:	01000084 	movi	r4,2
 204234c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         ip_reasm_delete_ire (irep);
 2042350:	e13fff17 	ldw	r4,-4(fp)
 2042354:	2042a280 	call	2042a28 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 2042358:	00809934 	movhi	r2,612
 204235c:	10b7d304 	addi	r2,r2,-8372
 2042360:	10800f17 	ldw	r2,60(r2)
 2042364:	10c00044 	addi	r3,r2,1
 2042368:	00809934 	movhi	r2,612
 204236c:	10b7d304 	addi	r2,r2,-8372
 2042370:	10c00f15 	stw	r3,60(r2)
         return ENP_RESOURCE;
 2042374:	00bffa84 	movi	r2,-22
 2042378:	00007606 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>
         }
      else
         {
         new_rfqp->bufp[0] = p;
 204237c:	e0bff517 	ldw	r2,-44(fp)
 2042380:	e0fffe17 	ldw	r3,-8(fp)
 2042384:	10c00115 	stw	r3,4(r2)
         new_rfqp->frag_offset[0] = frag_offset;
 2042388:	e0fffd0b 	ldhu	r3,-12(fp)
 204238c:	e0bff517 	ldw	r2,-44(fp)
 2042390:	10c0110d 	sth	r3,68(r2)
         rfqp->next = new_rfqp;
 2042394:	e0bffc17 	ldw	r2,-16(fp)
 2042398:	e0fff517 	ldw	r3,-44(fp)
 204239c:	10c00015 	stw	r3,0(r2)
         }
      }
      
      /* check to see if the RFQ is still compact, but only if hole(s) were created 
       * in ip_reasm_compute_overlap () */
      if (hole_created)
 20423a0:	e0bffd83 	ldbu	r2,-10(fp)
 20423a4:	10803fcc 	andi	r2,r2,255
 20423a8:	10001426 	beq	r2,zero,20423fc <ip_reasm_process_subsequent_fragments+0x3c4>
         {
         if ((rc = ip_reasm_mark_compact_rfq (irep)) != IPREASM_OK)
 20423ac:	e13fff17 	ldw	r4,-4(fp)
 20423b0:	2042bdc0 	call	2042bdc <ip_reasm_mark_compact_rfq>
 20423b4:	e0bff915 	stw	r2,-28(fp)
 20423b8:	e0bff917 	ldw	r2,-28(fp)
 20423bc:	10000f26 	beq	r2,zero,20423fc <ip_reasm_process_subsequent_fragments+0x3c4>
            {
            /* an error return is due to a bad IRE pointer, which ip_reasm_mark_compact_rfq () logs */
            LOCK_NET_RESOURCE (FREEQ_RESID);
 20423c0:	01000084 	movi	r4,2
 20423c4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free (p);
 20423c8:	e13ffe17 	ldw	r4,-8(fp)
 20423cc:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);
 20423d0:	01000084 	movi	r4,2
 20423d4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            ++ip_mib.ipReasmFails;
 20423d8:	00809934 	movhi	r2,612
 20423dc:	10b7d304 	addi	r2,r2,-8372
 20423e0:	10800f17 	ldw	r2,60(r2)
 20423e4:	10c00044 	addi	r3,r2,1
 20423e8:	00809934 	movhi	r2,612
 20423ec:	10b7d304 	addi	r2,r2,-8372
 20423f0:	10c00f15 	stw	r3,60(r2)
            return rc;
 20423f4:	e0bff917 	ldw	r2,-28(fp)
 20423f8:	00005606 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>

   /* compute the total number of bytes queued in this IRE.  Note 
    * that the RHS has been updated to reflect the amount of "unique"
    * data in the just received fragment (the IP header has been dropped,
    * and perhaps additional duplicate data too (if present)) */
   irep->rcvd += (u_short) (p->nb_plen);
 20423fc:	e0bfff17 	ldw	r2,-4(fp)
 2042400:	10c0048b 	ldhu	r3,18(r2)
 2042404:	e0bffe17 	ldw	r2,-8(fp)
 2042408:	10800417 	ldw	r2,16(r2)
 204240c:	1885883a 	add	r2,r3,r2
 2042410:	1007883a 	mov	r3,r2
 2042414:	e0bfff17 	ldw	r2,-4(fp)
 2042418:	10c0048d 	sth	r3,18(r2)
   ip_reasm_incr_mem_useage (p->nb_blen + ((new_rfqp == 0) ? 0 : (sizeof(RFQ))));
 204241c:	e0bffe17 	ldw	r2,-8(fp)
 2042420:	10800217 	ldw	r2,8(r2)
 2042424:	1007883a 	mov	r3,r2
 2042428:	e0bff517 	ldw	r2,-44(fp)
 204242c:	1000021e 	bne	r2,zero,2042438 <ip_reasm_process_subsequent_fragments+0x400>
 2042430:	0005883a 	mov	r2,zero
 2042434:	00000106 	br	204243c <ip_reasm_process_subsequent_fragments+0x404>
 2042438:	00801904 	movi	r2,100
 204243c:	1885883a 	add	r2,r3,r2
 2042440:	10bfffcc 	andi	r2,r2,65535
 2042444:	1009883a 	mov	r4,r2
 2042448:	204165c0 	call	204165c <ip_reasm_incr_mem_useage>

   if (irep->length != 0)
 204244c:	e0bfff17 	ldw	r2,-4(fp)
 2042450:	1080040b 	ldhu	r2,16(r2)
 2042454:	10bfffcc 	andi	r2,r2,65535
 2042458:	10003d26 	beq	r2,zero,2042550 <ip_reasm_process_subsequent_fragments+0x518>
      {
      /* we know the total length of the original unfragmented datagram; 
       * let's check to see if we have all of the bytes... */
      if (irep->rcvd == irep->length)
 204245c:	e0bfff17 	ldw	r2,-4(fp)
 2042460:	10c0048b 	ldhu	r3,18(r2)
 2042464:	e0bfff17 	ldw	r2,-4(fp)
 2042468:	1080040b 	ldhu	r2,16(r2)
 204246c:	18ffffcc 	andi	r3,r3,65535
 2042470:	10bfffcc 	andi	r2,r2,65535
 2042474:	1880361e 	bne	r3,r2,2042550 <ip_reasm_process_subsequent_fragments+0x518>
          * Ensure that we allocate space for the data link header, IP header, 
          * and the payload of the original, unfragmented datagram.  We pick 
          * the data link layer and IP headers from the First Fragment (FF), 
          * but we need to adjust some of the fields in the IP header after 
          * reassembly is complete. */
         pip = (struct ip *) irep->l3_hdr;
 2042478:	e0bfff17 	ldw	r2,-4(fp)
 204247c:	10802017 	ldw	r2,128(r2)
 2042480:	e0bff615 	stw	r2,-40(fp)
         LOCK_NET_RESOURCE (FREEQ_RESID);
 2042484:	01000084 	movi	r4,2
 2042488:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         reassy_pkt = pk_alloc (irep->length + (irep->l3_hdr - irep->l2_hdr) + ip_hlen (pip));
 204248c:	e0bfff17 	ldw	r2,-4(fp)
 2042490:	1080040b 	ldhu	r2,16(r2)
 2042494:	10ffffcc 	andi	r3,r2,65535
 2042498:	e0bfff17 	ldw	r2,-4(fp)
 204249c:	10802017 	ldw	r2,128(r2)
 20424a0:	1009883a 	mov	r4,r2
 20424a4:	e0bfff17 	ldw	r2,-4(fp)
 20424a8:	10801f17 	ldw	r2,124(r2)
 20424ac:	2085c83a 	sub	r2,r4,r2
 20424b0:	1887883a 	add	r3,r3,r2
 20424b4:	e0bff617 	ldw	r2,-40(fp)
 20424b8:	10800003 	ldbu	r2,0(r2)
 20424bc:	10803fcc 	andi	r2,r2,255
 20424c0:	108003cc 	andi	r2,r2,15
 20424c4:	1085883a 	add	r2,r2,r2
 20424c8:	1085883a 	add	r2,r2,r2
 20424cc:	1885883a 	add	r2,r3,r2
 20424d0:	1009883a 	mov	r4,r2
 20424d4:	2027cec0 	call	2027cec <pk_alloc>
 20424d8:	e0bffa15 	stw	r2,-24(fp)
         UNLOCK_NET_RESOURCE (FREEQ_RESID);
 20424dc:	01000084 	movi	r4,2
 20424e0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         if (reassy_pkt == 0)
 20424e4:	e0bffa17 	ldw	r2,-24(fp)
 20424e8:	10000b1e 	bne	r2,zero,2042518 <ip_reasm_process_subsequent_fragments+0x4e0>
            {
            /* the following call will delete all queued fragments, including
             * the currently received one */
            ip_reasm_delete_ire (irep);
 20424ec:	e13fff17 	ldw	r4,-4(fp)
 20424f0:	2042a280 	call	2042a28 <ip_reasm_delete_ire>
            ++ip_mib.ipReasmFails;
 20424f4:	00809934 	movhi	r2,612
 20424f8:	10b7d304 	addi	r2,r2,-8372
 20424fc:	10800f17 	ldw	r2,60(r2)
 2042500:	10c00044 	addi	r3,r2,1
 2042504:	00809934 	movhi	r2,612
 2042508:	10b7d304 	addi	r2,r2,-8372
 204250c:	10c00f15 	stw	r3,60(r2)
            return ENP_NOBUFFER;
 2042510:	00bffac4 	movi	r2,-21
 2042514:	00000f06 	br	2042554 <ip_reasm_process_subsequent_fragments+0x51c>
            }
         else
            {
            ip_reasm_copy_queued_fragments_into_reassy_buffer (reassy_pkt, irep);
 2042518:	e13ffa17 	ldw	r4,-24(fp)
 204251c:	e17fff17 	ldw	r5,-4(fp)
 2042520:	20425c00 	call	20425c0 <ip_reasm_copy_queued_fragments_into_reassy_buffer>
            /* free the IRE structure (and its constituent elements) */
            ip_reasm_delete_ire (irep);
 2042524:	e13fff17 	ldw	r4,-4(fp)
 2042528:	2042a280 	call	2042a28 <ip_reasm_delete_ire>
            /* at this point, 'irep' is no longer a valid pointer, and so should 
             * not be referenced.  We're done, and we now pass the packet for 
             * demux'ing to the appropriate entity (e.g., UDP, TCP, etc.).  Note
             * that ip_demux () expects 'nb_prot' to point to the beginning of 
             * the IP header. */
            ++ip_mib.ipReasmOKs;
 204252c:	00809934 	movhi	r2,612
 2042530:	10b7d304 	addi	r2,r2,-8372
 2042534:	10800e17 	ldw	r2,56(r2)
 2042538:	10c00044 	addi	r3,r2,1
 204253c:	00809934 	movhi	r2,612
 2042540:	10b7d304 	addi	r2,r2,-8372
 2042544:	10c00e15 	stw	r3,56(r2)
            ip_demux (reassy_pkt);
 2042548:	e13ffa17 	ldw	r4,-24(fp)
 204254c:	2043a900 	call	2043a90 <ip_demux>
      {
      /* we haven't received the LF (so we don't know the total amount of data in 
       * the original, unfragmented datagram), and therefore reassembly can't complete yet */
      }

   return IPREASM_OK;
 2042550:	0005883a 	mov	r2,zero
}
 2042554:	e037883a 	mov	sp,fp
 2042558:	dfc00117 	ldw	ra,4(sp)
 204255c:	df000017 	ldw	fp,0(sp)
 2042560:	dec00204 	addi	sp,sp,8
 2042564:	f800283a 	ret

02042568 <ip_reasm_find_ire>:
OUTPUT: This function returns a IPREASM_TRUE if the IRE exists in the master 
IRE list; otherwise, it returns a IPREASM_FALSE.
*/

u_char ip_reasm_find_ire (IREP irep)
{
 2042568:	defffd04 	addi	sp,sp,-12
 204256c:	df000215 	stw	fp,8(sp)
 2042570:	df000204 	addi	fp,sp,8
 2042574:	e13fff15 	stw	r4,-4(fp)
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 2042578:	d0a0be17 	ldw	r2,-32008(gp)
 204257c:	e0bffe15 	stw	r2,-8(fp)
 2042580:	00000806 	br	20425a4 <ip_reasm_find_ire+0x3c>
      {
      if (tmpp == irep) 
 2042584:	e0fffe17 	ldw	r3,-8(fp)
 2042588:	e0bfff17 	ldw	r2,-4(fp)
 204258c:	1880021e 	bne	r3,r2,2042598 <ip_reasm_find_ire+0x30>
         {
         return IPREASM_TRUE;
 2042590:	00800044 	movi	r2,1
 2042594:	00000606 	br	20425b0 <ip_reasm_find_ire+0x48>
u_char ip_reasm_find_ire (IREP irep)
{
   IREP tmpp;

   /* check to see if the IRE exists in the IREQ linked list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 2042598:	e0bffe17 	ldw	r2,-8(fp)
 204259c:	10800017 	ldw	r2,0(r2)
 20425a0:	e0bffe15 	stw	r2,-8(fp)
 20425a4:	e0bffe17 	ldw	r2,-8(fp)
 20425a8:	103ff61e 	bne	r2,zero,2042584 <ip_reasm_find_ire+0x1c>
         {
         return IPREASM_TRUE;
         }
      }

   return IPREASM_FALSE;
 20425ac:	0005883a 	mov	r2,zero
}
 20425b0:	e037883a 	mov	sp,fp
 20425b4:	df000017 	ldw	fp,0(sp)
 20425b8:	dec00104 	addi	sp,sp,4
 20425bc:	f800283a 	ret

020425c0 <ip_reasm_copy_queued_fragments_into_reassy_buffer>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_copy_queued_fragments_into_reassy_buffer (PACKET reassy_pkt, IREP irep)
{
 20425c0:	defff504 	addi	sp,sp,-44
 20425c4:	dfc00a15 	stw	ra,40(sp)
 20425c8:	df000915 	stw	fp,36(sp)
 20425cc:	df000904 	addi	fp,sp,36
 20425d0:	e13ffe15 	stw	r4,-8(fp)
 20425d4:	e17fff15 	stw	r5,-4(fp)
   RFQP rfqp;
   u_short i;
   PACKET p;
   u_char iphlen;
   char * writep;
   PACKET sav_pkt = 0;
 20425d8:	e03ff915 	stw	zero,-28(fp)

   pip = (struct ip *) irep->l3_hdr;
 20425dc:	e0bfff17 	ldw	r2,-4(fp)
 20425e0:	10802017 	ldw	r2,128(r2)
 20425e4:	e0bffa15 	stw	r2,-24(fp)
   iphlen = ip_hlen (pip);
 20425e8:	e0bffa17 	ldw	r2,-24(fp)
 20425ec:	10800003 	ldbu	r2,0(r2)
 20425f0:	108003cc 	andi	r2,r2,15
 20425f4:	1085883a 	add	r2,r2,r2
 20425f8:	1085883a 	add	r2,r2,r2
 20425fc:	e0bffb05 	stb	r2,-20(fp)

   /* copy the data link and IP layer headers into place.  These headers are 
    * from the First Fragment (FF). */
   offset = (u_char) ((irep->l3_hdr - irep->l2_hdr) + iphlen);
 2042600:	e0bfff17 	ldw	r2,-4(fp)
 2042604:	10802017 	ldw	r2,128(r2)
 2042608:	1007883a 	mov	r3,r2
 204260c:	e0bfff17 	ldw	r2,-4(fp)
 2042610:	10801f17 	ldw	r2,124(r2)
 2042614:	1885c83a 	sub	r2,r3,r2
 2042618:	1007883a 	mov	r3,r2
 204261c:	e0bffb03 	ldbu	r2,-20(fp)
 2042620:	1885883a 	add	r2,r3,r2
 2042624:	e0bffb45 	stb	r2,-19(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);
 2042628:	e0bffe17 	ldw	r2,-8(fp)
 204262c:	11000117 	ldw	r4,4(r2)
 2042630:	e0bfff17 	ldw	r2,-4(fp)
 2042634:	10c01f17 	ldw	r3,124(r2)
 2042638:	e0bffb43 	ldbu	r2,-19(fp)
 204263c:	180b883a 	mov	r5,r3
 2042640:	100d883a 	mov	r6,r2
 2042644:	200660c0 	call	200660c <memcpy>

   rfqp = &(irep->rfq);
 2042648:	e0bfff17 	ldw	r2,-4(fp)
 204264c:	10800604 	addi	r2,r2,24
 2042650:	e0bff715 	stw	r2,-36(fp)
   writep = reassy_pkt->nb_buff + offset;
 2042654:	e0bffe17 	ldw	r2,-8(fp)
 2042658:	10c00117 	ldw	r3,4(r2)
 204265c:	e0bffb43 	ldbu	r2,-19(fp)
 2042660:	1885883a 	add	r2,r3,r2
 2042664:	e0bffc15 	stw	r2,-16(fp)

   while (rfqp)
 2042668:	00004406 	br	204277c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1bc>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 204266c:	e03ff80d 	sth	zero,-32(fp)
 2042670:	00003a06 	br	204275c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x19c>
         {
         if ((p = rfqp->bufp [i]) != 0)
 2042674:	e0bff80b 	ldhu	r2,-32(fp)
 2042678:	e0fff717 	ldw	r3,-36(fp)
 204267c:	10800044 	addi	r2,r2,1
 2042680:	1085883a 	add	r2,r2,r2
 2042684:	1085883a 	add	r2,r2,r2
 2042688:	1885883a 	add	r2,r3,r2
 204268c:	10800017 	ldw	r2,0(r2)
 2042690:	e0bffd15 	stw	r2,-12(fp)
 2042694:	e0bffd17 	ldw	r2,-12(fp)
 2042698:	10002826 	beq	r2,zero,204273c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x17c>
            {
            /* note that rfqp->frag_offset[i] is the true value of the offset field, 
             * and does not require any scaling (like the Fragment Offset field in 
             * the IP header) */
            MEMCPY((writep + rfqp->frag_offset[i]), p->nb_prot, p->nb_plen);
 204269c:	e0bff80b 	ldhu	r2,-32(fp)
 20426a0:	e0fff717 	ldw	r3,-36(fp)
 20426a4:	10800884 	addi	r2,r2,34
 20426a8:	1085883a 	add	r2,r2,r2
 20426ac:	1885883a 	add	r2,r3,r2
 20426b0:	1080000b 	ldhu	r2,0(r2)
 20426b4:	10bfffcc 	andi	r2,r2,65535
 20426b8:	e0fffc17 	ldw	r3,-16(fp)
 20426bc:	1889883a 	add	r4,r3,r2
 20426c0:	e0bffd17 	ldw	r2,-12(fp)
 20426c4:	10c00317 	ldw	r3,12(r2)
 20426c8:	e0bffd17 	ldw	r2,-12(fp)
 20426cc:	10800417 	ldw	r2,16(r2)
 20426d0:	180b883a 	mov	r5,r3
 20426d4:	100d883a 	mov	r6,r2
 20426d8:	200660c0 	call	200660c <memcpy>
            /* free fragment after we've copied data out from it (unless we need to
             * save it so that we can copy some fields from it later (after exiting 
             * from the loop)) */
            if (!sav_pkt) sav_pkt = p;
 20426dc:	e0bff917 	ldw	r2,-28(fp)
 20426e0:	1000031e 	bne	r2,zero,20426f0 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x130>
 20426e4:	e0bffd17 	ldw	r2,-12(fp)
 20426e8:	e0bff915 	stw	r2,-28(fp)
 20426ec:	00000b06 	br	204271c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x15c>
            else
               {
               ip_reasm_decr_mem_useage (p->nb_blen);
 20426f0:	e0bffd17 	ldw	r2,-12(fp)
 20426f4:	10800217 	ldw	r2,8(r2)
 20426f8:	10bfffcc 	andi	r2,r2,65535
 20426fc:	1009883a 	mov	r4,r2
 2042700:	20416fc0 	call	20416fc <ip_reasm_decr_mem_useage>
               LOCK_NET_RESOURCE (FREEQ_RESID);
 2042704:	01000084 	movi	r4,2
 2042708:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
               pk_free (p);
 204270c:	e13ffd17 	ldw	r4,-12(fp)
 2042710:	20280440 	call	2028044 <pk_free>
               UNLOCK_NET_RESOURCE (FREEQ_RESID);
 2042714:	01000084 	movi	r4,2
 2042718:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
               }
            /* since we're done with the packet, mark slot as unused */
            rfqp->bufp [i] = 0;
 204271c:	e0bff80b 	ldhu	r2,-32(fp)
 2042720:	e0fff717 	ldw	r3,-36(fp)
 2042724:	10800044 	addi	r2,r2,1
 2042728:	1085883a 	add	r2,r2,r2
 204272c:	1085883a 	add	r2,r2,r2
 2042730:	1885883a 	add	r2,r3,r2
 2042734:	10000015 	stw	zero,0(r2)
 2042738:	00000506 	br	2042750 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x190>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 204273c:	e0bfff17 	ldw	r2,-4(fp)
 2042740:	10802103 	ldbu	r2,132(r2)
 2042744:	10803fcc 	andi	r2,r2,255
 2042748:	1080004c 	andi	r2,r2,1
 204274c:	1000071e 	bne	r2,zero,204276c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1ac>
   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042750:	e0bff80b 	ldhu	r2,-32(fp)
 2042754:	10800044 	addi	r2,r2,1
 2042758:	e0bff80d 	sth	r2,-32(fp)
 204275c:	e0bff80b 	ldhu	r2,-32(fp)
 2042760:	10800430 	cmpltui	r2,r2,16
 2042764:	103fc31e 	bne	r2,zero,2042674 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xb4>
 2042768:	00000106 	br	2042770 <ip_reasm_copy_queued_fragments_into_reassy_buffer+0x1b0>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 204276c:	0001883a 	nop
               }
            }
          }

      rfqp = rfqp->next;
 2042770:	e0bff717 	ldw	r2,-36(fp)
 2042774:	10800017 	ldw	r2,0(r2)
 2042778:	e0bff715 	stw	r2,-36(fp)
   MEMCPY(reassy_pkt->nb_buff, irep->l2_hdr, offset);

   rfqp = &(irep->rfq);
   writep = reassy_pkt->nb_buff + offset;

   while (rfqp)
 204277c:	e0bff717 	ldw	r2,-36(fp)
 2042780:	103fba1e 	bne	r2,zero,204266c <ip_reasm_copy_queued_fragments_into_reassy_buffer+0xac>
      }

   /* update various fields in the reassembled packet.  Some fields will be 
    * picked from one of the constituent fragments (sav_pkt) which hasn't
    * been deleted yet. */
   reassy_pkt->nb_prot = reassy_pkt->nb_buff + (irep->l3_hdr - irep->l2_hdr);
 2042784:	e0bffe17 	ldw	r2,-8(fp)
 2042788:	10c00117 	ldw	r3,4(r2)
 204278c:	e0bfff17 	ldw	r2,-4(fp)
 2042790:	10802017 	ldw	r2,128(r2)
 2042794:	1009883a 	mov	r4,r2
 2042798:	e0bfff17 	ldw	r2,-4(fp)
 204279c:	10801f17 	ldw	r2,124(r2)
 20427a0:	2085c83a 	sub	r2,r4,r2
 20427a4:	1887883a 	add	r3,r3,r2
 20427a8:	e0bffe17 	ldw	r2,-8(fp)
 20427ac:	10c00315 	stw	r3,12(r2)
   reassy_pkt->nb_plen = irep->length + iphlen;
 20427b0:	e0bfff17 	ldw	r2,-4(fp)
 20427b4:	1080040b 	ldhu	r2,16(r2)
 20427b8:	10ffffcc 	andi	r3,r2,65535
 20427bc:	e0bffb03 	ldbu	r2,-20(fp)
 20427c0:	1885883a 	add	r2,r3,r2
 20427c4:	1007883a 	mov	r3,r2
 20427c8:	e0bffe17 	ldw	r2,-8(fp)
 20427cc:	10c00415 	stw	r3,16(r2)
   reassy_pkt->nb_tstamp = cticks;
 20427d0:	00808174 	movhi	r2,517
 20427d4:	1090c904 	addi	r2,r2,17188
 20427d8:	10800017 	ldw	r2,0(r2)
 20427dc:	1007883a 	mov	r3,r2
 20427e0:	e0bffe17 	ldw	r2,-8(fp)
 20427e4:	10c00515 	stw	r3,20(r2)
   reassy_pkt->flags |= ((sav_pkt->flags) & (PKF_BCAST | PKF_MCAST));
 20427e8:	e0bffe17 	ldw	r2,-8(fp)
 20427ec:	10c00a17 	ldw	r3,40(r2)
 20427f0:	e0bff917 	ldw	r2,-28(fp)
 20427f4:	10800a17 	ldw	r2,40(r2)
 20427f8:	108000cc 	andi	r2,r2,3
 20427fc:	1886b03a 	or	r3,r3,r2
 2042800:	e0bffe17 	ldw	r2,-8(fp)
 2042804:	10c00a15 	stw	r3,40(r2)
   reassy_pkt->net = sav_pkt->net;
 2042808:	e0bff917 	ldw	r2,-28(fp)
 204280c:	10c00617 	ldw	r3,24(r2)
 2042810:	e0bffe17 	ldw	r2,-8(fp)
 2042814:	10c00615 	stw	r3,24(r2)
   reassy_pkt->type = sav_pkt->type;
 2042818:	e0bff917 	ldw	r2,-28(fp)
 204281c:	10c0080b 	ldhu	r3,32(r2)
 2042820:	e0bffe17 	ldw	r2,-8(fp)
 2042824:	10c0080d 	sth	r3,32(r2)
   /* fhost is set by ip_demux () before handing off to the packet to its 
    * intended destination (protocol) */

   /* free the saved packet too, since we don't need it anymore */
   ip_reasm_decr_mem_useage (sav_pkt->nb_blen);
 2042828:	e0bff917 	ldw	r2,-28(fp)
 204282c:	10800217 	ldw	r2,8(r2)
 2042830:	10bfffcc 	andi	r2,r2,65535
 2042834:	1009883a 	mov	r4,r2
 2042838:	20416fc0 	call	20416fc <ip_reasm_decr_mem_useage>
   LOCK_NET_RESOURCE (FREEQ_RESID);
 204283c:	01000084 	movi	r4,2
 2042840:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free (sav_pkt);
 2042844:	e13ff917 	ldw	r4,-28(fp)
 2042848:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE (FREEQ_RESID);
 204284c:	01000084 	movi	r4,2
 2042850:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   /* after the reassembly is complete, we update the following fields in
    * the IP header: Total Length, Flags/Fragment Offset, header checksum */
   pip = ip_head(reassy_pkt);
 2042854:	e0bffe17 	ldw	r2,-8(fp)
 2042858:	10800317 	ldw	r2,12(r2)
 204285c:	e0bffa15 	stw	r2,-24(fp)
   pip->ip_len = htons(reassy_pkt->nb_plen);
 2042860:	e0bffe17 	ldw	r2,-8(fp)
 2042864:	10800417 	ldw	r2,16(r2)
 2042868:	1004d23a 	srli	r2,r2,8
 204286c:	10803fcc 	andi	r2,r2,255
 2042870:	1007883a 	mov	r3,r2
 2042874:	e0bffe17 	ldw	r2,-8(fp)
 2042878:	10800417 	ldw	r2,16(r2)
 204287c:	1004923a 	slli	r2,r2,8
 2042880:	1884b03a 	or	r2,r3,r2
 2042884:	1007883a 	mov	r3,r2
 2042888:	e0bffa17 	ldw	r2,-24(fp)
 204288c:	10c0008d 	sth	r3,2(r2)
   /* turn off More Fragments (MF) bit; the DF bit stays unchanged */
   pip->ip_flgs_foff &= htons(~((u_short) IP_FLG_MF));
 2042890:	e0bffa17 	ldw	r2,-24(fp)
 2042894:	10c0018b 	ldhu	r3,6(r2)
 2042898:	00bff7c4 	movi	r2,-33
 204289c:	1884703a 	and	r2,r3,r2
 20428a0:	1007883a 	mov	r3,r2
 20428a4:	e0bffa17 	ldw	r2,-24(fp)
 20428a8:	10c0018d 	sth	r3,6(r2)
   /* clear the Fragment Offset bits */
   pip->ip_flgs_foff &= htons(~((u_short) IP_EXTRACT_FOFF)); 
 20428ac:	e0bffa17 	ldw	r2,-24(fp)
 20428b0:	1080018b 	ldhu	r2,6(r2)
 20428b4:	1080380c 	andi	r2,r2,224
 20428b8:	1007883a 	mov	r3,r2
 20428bc:	e0bffa17 	ldw	r2,-24(fp)
 20428c0:	10c0018d 	sth	r3,6(r2)
   /* the following isn't really required, and can be removed */
   pip->ip_chksum = IPXSUM;
 20428c4:	e0bffa17 	ldw	r2,-24(fp)
 20428c8:	1000028d 	sth	zero,10(r2)
   pip->ip_chksum = ~cksum (pip, (iphlen/2));
 20428cc:	e0bffb03 	ldbu	r2,-20(fp)
 20428d0:	1004d07a 	srli	r2,r2,1
 20428d4:	10803fcc 	andi	r2,r2,255
 20428d8:	e13ffa17 	ldw	r4,-24(fp)
 20428dc:	100b883a 	mov	r5,r2
 20428e0:	20268040 	call	2026804 <cksum>
 20428e4:	0084303a 	nor	r2,zero,r2
 20428e8:	1007883a 	mov	r3,r2
 20428ec:	e0bffa17 	ldw	r2,-24(fp)
 20428f0:	10c0028d 	sth	r3,10(r2)

   return IPREASM_OK;
 20428f4:	0005883a 	mov	r2,zero
}
 20428f8:	e037883a 	mov	sp,fp
 20428fc:	dfc00117 	ldw	ra,4(sp)
 2042900:	df000017 	ldw	fp,0(sp)
 2042904:	dec00204 	addi	sp,sp,8
 2042908:	f800283a 	ret

0204290c <ip_reasm_process_timer_tick>:

OUTPUT: This function always returns IPREASM_OK.
*/

u_char ip_reasm_process_timer_tick (void)
{
 204290c:	defffc04 	addi	sp,sp,-16
 2042910:	dfc00315 	stw	ra,12(sp)
 2042914:	df000215 	stw	fp,8(sp)
 2042918:	df000204 	addi	fp,sp,8
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 204291c:	0009883a 	mov	r4,zero
 2042920:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 2042924:	d0a0be17 	ldw	r2,-32008(gp)
 2042928:	e0bffe15 	stw	r2,-8(fp)
 204292c:	00002006 	br	20429b0 <ip_reasm_process_timer_tick+0xa4>
      {
      /* save the next pointer for the IRE that may be deleted */
      nxt_tmpp = tmpp->next;
 2042930:	e0bffe17 	ldw	r2,-8(fp)
 2042934:	10800017 	ldw	r2,0(r2)
 2042938:	e0bfff15 	stw	r2,-4(fp)
      ++tmpp->age;
 204293c:	e0bffe17 	ldw	r2,-8(fp)
 2042940:	10800517 	ldw	r2,20(r2)
 2042944:	10c00044 	addi	r3,r2,1
 2042948:	e0bffe17 	ldw	r2,-8(fp)
 204294c:	10c00515 	stw	r3,20(r2)
      /* check to see if this entry has reached its max age (expired)? */
      if (tmpp->age == IRE_TMO)
 2042950:	e0bffe17 	ldw	r2,-8(fp)
 2042954:	10800517 	ldw	r2,20(r2)
 2042958:	10801e18 	cmpnei	r2,r2,120
 204295c:	1000121e 	bne	r2,zero,20429a8 <ip_reasm_process_timer_tick+0x9c>
         {
         /* it has...and therefore must be deleted. */
         ++ire_stats.ire_timed_out;
 2042960:	00809934 	movhi	r2,612
 2042964:	10b7e704 	addi	r2,r2,-8292
 2042968:	10800117 	ldw	r2,4(r2)
 204296c:	10c00044 	addi	r3,r2,1
 2042970:	00809934 	movhi	r2,612
 2042974:	10b7e704 	addi	r2,r2,-8292
 2042978:	10c00115 	stw	r3,4(r2)
#ifdef FULL_ICMP
         /* send ICMP Time Exceeded message with code 1 ("fragment reassembly time exceeded") */
         ip_reasm_send_icmp_timex (tmpp);
 204297c:	e13ffe17 	ldw	r4,-8(fp)
 2042980:	20430840 	call	2043084 <ip_reasm_send_icmp_timex>
#endif
         ip_reasm_delete_ire (tmpp);
 2042984:	e13ffe17 	ldw	r4,-8(fp)
 2042988:	2042a280 	call	2042a28 <ip_reasm_delete_ire>
         ++ip_mib.ipReasmFails;
 204298c:	00809934 	movhi	r2,612
 2042990:	10b7d304 	addi	r2,r2,-8372
 2042994:	10800f17 	ldw	r2,60(r2)
 2042998:	10c00044 	addi	r3,r2,1
 204299c:	00809934 	movhi	r2,612
 20429a0:	10b7d304 	addi	r2,r2,-8372
 20429a4:	10c00f15 	stw	r3,60(r2)
   IREP tmpp;
   IREP nxt_tmpp;

   LOCK_NET_RESOURCE (NET_RESID);
 
   for (tmpp = h_ireq; tmpp; tmpp = nxt_tmpp)
 20429a8:	e0bfff17 	ldw	r2,-4(fp)
 20429ac:	e0bffe15 	stw	r2,-8(fp)
 20429b0:	e0bffe17 	ldw	r2,-8(fp)
 20429b4:	103fde1e 	bne	r2,zero,2042930 <ip_reasm_process_timer_tick+0x24>
         ++ip_mib.ipReasmFails;
         }
      }

   /* set the time for the next invocation of this routine (one second later) */
   ire_cticks = cticks + TPS;
 20429b8:	00808174 	movhi	r2,517
 20429bc:	1090c904 	addi	r2,r2,17188
 20429c0:	10800017 	ldw	r2,0(r2)
 20429c4:	1009883a 	mov	r4,r2
 20429c8:	20145600 	call	2014560 <__floatunsidf>
 20429cc:	100b883a 	mov	r5,r2
 20429d0:	180d883a 	mov	r6,r3
 20429d4:	2809883a 	mov	r4,r5
 20429d8:	300b883a 	mov	r5,r6
 20429dc:	000d883a 	mov	r6,zero
 20429e0:	01d01674 	movhi	r7,16473
 20429e4:	2013bd40 	call	2013bd4 <__adddf3>
 20429e8:	1009883a 	mov	r4,r2
 20429ec:	180b883a 	mov	r5,r3
 20429f0:	2005883a 	mov	r2,r4
 20429f4:	2807883a 	mov	r3,r5
 20429f8:	1009883a 	mov	r4,r2
 20429fc:	180b883a 	mov	r5,r3
 2042a00:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 2042a04:	d0a0bf15 	stw	r2,-32004(gp)

   UNLOCK_NET_RESOURCE (NET_RESID);
 2042a08:	0009883a 	mov	r4,zero
 2042a0c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   return IPREASM_OK;
 2042a10:	0005883a 	mov	r2,zero
}
 2042a14:	e037883a 	mov	sp,fp
 2042a18:	dfc00117 	ldw	ra,4(sp)
 2042a1c:	df000017 	ldw	fp,0(sp)
 2042a20:	dec00204 	addi	sp,sp,8
 2042a24:	f800283a 	ret

02042a28 <ip_reasm_delete_ire>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in the 
master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_delete_ire (IREP irep)
{
 2042a28:	defff604 	addi	sp,sp,-40
 2042a2c:	dfc00915 	stw	ra,36(sp)
 2042a30:	df000815 	stw	fp,32(sp)
 2042a34:	df000804 	addi	fp,sp,32
 2042a38:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp, first_rfqp, prev_rfqp;
   u_short i;
   PACKET p;
   IREP tmpp;
   IREP prev_tmpp = 0;
 2042a3c:	e03ffb15 	stw	zero,-20(fp)

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 2042a40:	d0a0be17 	ldw	r2,-32008(gp)
 2042a44:	e0bffa15 	stw	r2,-24(fp)
 2042a48:	00001406 	br	2042a9c <ip_reasm_delete_ire+0x74>
      {
      if (tmpp == irep) 
 2042a4c:	e0fffa17 	ldw	r3,-24(fp)
 2042a50:	e0bfff17 	ldw	r2,-4(fp)
 2042a54:	18800c1e 	bne	r3,r2,2042a88 <ip_reasm_delete_ire+0x60>
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
 2042a58:	d0a0be17 	ldw	r2,-32008(gp)
 2042a5c:	e0fffa17 	ldw	r3,-24(fp)
 2042a60:	1880041e 	bne	r3,r2,2042a74 <ip_reasm_delete_ire+0x4c>
 2042a64:	e0bfff17 	ldw	r2,-4(fp)
 2042a68:	10800017 	ldw	r2,0(r2)
 2042a6c:	d0a0be15 	stw	r2,-32008(gp)
         else prev_tmpp->next = irep->next;
         break;
 2042a70:	00000c06 	br	2042aa4 <ip_reasm_delete_ire+0x7c>
      {
      if (tmpp == irep) 
         {
         /* update the head pointer to the list */
         if (tmpp == h_ireq) h_ireq = irep->next;
         else prev_tmpp->next = irep->next;
 2042a74:	e0bfff17 	ldw	r2,-4(fp)
 2042a78:	10c00017 	ldw	r3,0(r2)
 2042a7c:	e0bffb17 	ldw	r2,-20(fp)
 2042a80:	10c00015 	stw	r3,0(r2)
         break;
 2042a84:	00000706 	br	2042aa4 <ip_reasm_delete_ire+0x7c>
         }
      prev_tmpp = tmpp;
 2042a88:	e0bffa17 	ldw	r2,-24(fp)
 2042a8c:	e0bffb15 	stw	r2,-20(fp)
   IREP tmpp;
   IREP prev_tmpp = 0;

   /* check to see if the IRE exists in the master table; if it does,
    * remove it and also update the pointers in that list */
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 2042a90:	e0bffa17 	ldw	r2,-24(fp)
 2042a94:	10800017 	ldw	r2,0(r2)
 2042a98:	e0bffa15 	stw	r2,-24(fp)
 2042a9c:	e0bffa17 	ldw	r2,-24(fp)
 2042aa0:	103fea1e 	bne	r2,zero,2042a4c <ip_reasm_delete_ire+0x24>
      prev_tmpp = tmpp;
      }

   /* if the IRE entry does not exist in the master table, return an error 
    * to the caller */
   if (!tmpp)
 2042aa4:	e0bffa17 	ldw	r2,-24(fp)
 2042aa8:	1000091e 	bne	r2,zero,2042ad0 <ip_reasm_delete_ire+0xa8>
      {
      ++ire_stats.bad_irep;
 2042aac:	00809934 	movhi	r2,612
 2042ab0:	10b7e704 	addi	r2,r2,-8292
 2042ab4:	10800017 	ldw	r2,0(r2)
 2042ab8:	10c00044 	addi	r3,r2,1
 2042abc:	00809934 	movhi	r2,612
 2042ac0:	10b7e704 	addi	r2,r2,-8292
 2042ac4:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 2042ac8:	00bffd84 	movi	r2,-10
 2042acc:	00003e06 	br	2042bc8 <ip_reasm_delete_ire+0x1a0>
      }

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);
 2042ad0:	e0bfff17 	ldw	r2,-4(fp)
 2042ad4:	10800604 	addi	r2,r2,24
 2042ad8:	e0bffc15 	stw	r2,-16(fp)
 2042adc:	e0bffc17 	ldw	r2,-16(fp)
 2042ae0:	e0bff815 	stw	r2,-32(fp)

   while (rfqp)
 2042ae4:	00003106 	br	2042bac <ip_reasm_delete_ire+0x184>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042ae8:	e03ff90d 	sth	zero,-28(fp)
 2042aec:	00001e06 	br	2042b68 <ip_reasm_delete_ire+0x140>
         {
         if ((p = rfqp->bufp [i]) != 0)
 2042af0:	e0bff90b 	ldhu	r2,-28(fp)
 2042af4:	e0fff817 	ldw	r3,-32(fp)
 2042af8:	10800044 	addi	r2,r2,1
 2042afc:	1085883a 	add	r2,r2,r2
 2042b00:	1085883a 	add	r2,r2,r2
 2042b04:	1885883a 	add	r2,r3,r2
 2042b08:	10800017 	ldw	r2,0(r2)
 2042b0c:	e0bffd15 	stw	r2,-12(fp)
 2042b10:	e0bffd17 	ldw	r2,-12(fp)
 2042b14:	10000c26 	beq	r2,zero,2042b48 <ip_reasm_delete_ire+0x120>
            {
            ip_reasm_decr_mem_useage (p->nb_blen);
 2042b18:	e0bffd17 	ldw	r2,-12(fp)
 2042b1c:	10800217 	ldw	r2,8(r2)
 2042b20:	10bfffcc 	andi	r2,r2,65535
 2042b24:	1009883a 	mov	r4,r2
 2042b28:	20416fc0 	call	20416fc <ip_reasm_decr_mem_useage>
            LOCK_NET_RESOURCE (FREEQ_RESID);
 2042b2c:	01000084 	movi	r4,2
 2042b30:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free (p);
 2042b34:	e13ffd17 	ldw	r4,-12(fp)
 2042b38:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE (FREEQ_RESID);               
 2042b3c:	01000084 	movi	r4,2
 2042b40:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
 2042b44:	00000506 	br	2042b5c <ip_reasm_delete_ire+0x134>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
 2042b48:	e0bfff17 	ldw	r2,-4(fp)
 2042b4c:	10802103 	ldbu	r2,132(r2)
 2042b50:	10803fcc 	andi	r2,r2,255
 2042b54:	1080004c 	andi	r2,r2,1
 2042b58:	1000071e 	bne	r2,zero,2042b78 <ip_reasm_delete_ire+0x150>
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042b5c:	e0bff90b 	ldhu	r2,-28(fp)
 2042b60:	10800044 	addi	r2,r2,1
 2042b64:	e0bff90d 	sth	r2,-28(fp)
 2042b68:	e0bff90b 	ldhu	r2,-28(fp)
 2042b6c:	10800430 	cmpltui	r2,r2,16
 2042b70:	103fdf1e 	bne	r2,zero,2042af0 <ip_reasm_delete_ire+0xc8>
 2042b74:	00000106 	br	2042b7c <ip_reasm_delete_ire+0x154>
            }
         else
            {
            if (irep->flags & IPR_RFQ_COMPACT)
               {
               break;
 2042b78:	0001883a 	nop
               }
            }
          }

       prev_rfqp = rfqp;
 2042b7c:	e0bff817 	ldw	r2,-32(fp)
 2042b80:	e0bffe15 	stw	r2,-8(fp)
       rfqp = rfqp->next;
 2042b84:	e0bff817 	ldw	r2,-32(fp)
 2042b88:	10800017 	ldw	r2,0(r2)
 2042b8c:	e0bff815 	stw	r2,-32(fp)
       /* the first RFQ is statically allocated, and cannot be freed */
       if (prev_rfqp != first_rfqp)
 2042b90:	e0fffe17 	ldw	r3,-8(fp)
 2042b94:	e0bffc17 	ldw	r2,-16(fp)
 2042b98:	18800426 	beq	r3,r2,2042bac <ip_reasm_delete_ire+0x184>
          {
          ip_reasm_decr_mem_useage (sizeof(RFQ));
 2042b9c:	01001904 	movi	r4,100
 2042ba0:	20416fc0 	call	20416fc <ip_reasm_decr_mem_useage>
          IPR_FREE (prev_rfqp);
 2042ba4:	e13ffe17 	ldw	r4,-8(fp)
 2042ba8:	202912c0 	call	202912c <npfree>

   /* free any queued packets (there may be none if the IRE is being deleted
    * because the packet has been successfully reassembled) */
   rfqp = first_rfqp = &(irep->rfq);

   while (rfqp)
 2042bac:	e0bff817 	ldw	r2,-32(fp)
 2042bb0:	103fcd1e 	bne	r2,zero,2042ae8 <ip_reasm_delete_ire+0xc0>
          IPR_FREE (prev_rfqp);
          }
      }

   /* now free the parent entity */
   ip_reasm_decr_mem_useage (sizeof(IRE));
 2042bb4:	01002204 	movi	r4,136
 2042bb8:	20416fc0 	call	20416fc <ip_reasm_decr_mem_useage>
   IPR_FREE (irep);
 2042bbc:	e13fff17 	ldw	r4,-4(fp)
 2042bc0:	202912c0 	call	202912c <npfree>

   return IPREASM_OK;
 2042bc4:	0005883a 	mov	r2,zero
}
 2042bc8:	e037883a 	mov	sp,fp
 2042bcc:	dfc00117 	ldw	ra,4(sp)
 2042bd0:	df000017 	ldw	fp,0(sp)
 2042bd4:	dec00204 	addi	sp,sp,8
 2042bd8:	f800283a 	ret

02042bdc <ip_reasm_mark_compact_rfq>:
OUTPUT: This function returns a ENP_PARAM if the IRE does not exist in 
the master IRE list; otherwise, it returns a IPREASM_OK.
*/

int ip_reasm_mark_compact_rfq (IREP irep)
{
 2042bdc:	defffb04 	addi	sp,sp,-20
 2042be0:	dfc00415 	stw	ra,16(sp)
 2042be4:	df000315 	stw	fp,12(sp)
 2042be8:	df000304 	addi	fp,sp,12
 2042bec:	e13fff15 	stw	r4,-4(fp)
   RFQP rfqp;
   u_short i;
   u_char empty_slot_discovered = IPREASM_FALSE;
 2042bf0:	e03ffe85 	stb	zero,-6(fp)
   u_char compact = IPREASM_TRUE;
 2042bf4:	00800044 	movi	r2,1
 2042bf8:	e0bffec5 	stb	r2,-5(fp)

   if (ip_reasm_find_ire (irep) != IPREASM_TRUE)
 2042bfc:	e13fff17 	ldw	r4,-4(fp)
 2042c00:	20425680 	call	2042568 <ip_reasm_find_ire>
 2042c04:	10803fcc 	andi	r2,r2,255
 2042c08:	10800060 	cmpeqi	r2,r2,1
 2042c0c:	1000091e 	bne	r2,zero,2042c34 <ip_reasm_mark_compact_rfq+0x58>
   {
      ++ire_stats.bad_irep;
 2042c10:	00809934 	movhi	r2,612
 2042c14:	10b7e704 	addi	r2,r2,-8292
 2042c18:	10800017 	ldw	r2,0(r2)
 2042c1c:	10c00044 	addi	r3,r2,1
 2042c20:	00809934 	movhi	r2,612
 2042c24:	10b7e704 	addi	r2,r2,-8292
 2042c28:	10c00015 	stw	r3,0(r2)
      return ENP_PARAM;
 2042c2c:	00bffd84 	movi	r2,-10
 2042c30:	00003106 	br	2042cf8 <ip_reasm_mark_compact_rfq+0x11c>
   }

   rfqp = &(irep->rfq);
 2042c34:	e0bfff17 	ldw	r2,-4(fp)
 2042c38:	10800604 	addi	r2,r2,24
 2042c3c:	e0bffd15 	stw	r2,-12(fp)

   while (rfqp)
 2042c40:	00001a06 	br	2042cac <ip_reasm_mark_compact_rfq+0xd0>
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042c44:	e03ffe0d 	sth	zero,-8(fp)
 2042c48:	00001206 	br	2042c94 <ip_reasm_mark_compact_rfq+0xb8>
         {
         if (rfqp->bufp [i] == 0)
 2042c4c:	e0bffe0b 	ldhu	r2,-8(fp)
 2042c50:	e0fffd17 	ldw	r3,-12(fp)
 2042c54:	10800044 	addi	r2,r2,1
 2042c58:	1085883a 	add	r2,r2,r2
 2042c5c:	1085883a 	add	r2,r2,r2
 2042c60:	1885883a 	add	r2,r3,r2
 2042c64:	10800017 	ldw	r2,0(r2)
 2042c68:	1000031e 	bne	r2,zero,2042c78 <ip_reasm_mark_compact_rfq+0x9c>
            {            
            empty_slot_discovered = IPREASM_TRUE;
 2042c6c:	00800044 	movi	r2,1
 2042c70:	e0bffe85 	stb	r2,-6(fp)
 2042c74:	00000406 	br	2042c88 <ip_reasm_mark_compact_rfq+0xac>
            }
         else
            {
            if (empty_slot_discovered) 
 2042c78:	e0bffe83 	ldbu	r2,-6(fp)
 2042c7c:	10000226 	beq	r2,zero,2042c88 <ip_reasm_mark_compact_rfq+0xac>
               {
               compact = IPREASM_FALSE;
 2042c80:	e03ffec5 	stb	zero,-5(fp)
               break;
 2042c84:	00000606 	br	2042ca0 <ip_reasm_mark_compact_rfq+0xc4>

   rfqp = &(irep->rfq);

   while (rfqp)
      {
      for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042c88:	e0bffe0b 	ldhu	r2,-8(fp)
 2042c8c:	10800044 	addi	r2,r2,1
 2042c90:	e0bffe0d 	sth	r2,-8(fp)
 2042c94:	e0bffe0b 	ldhu	r2,-8(fp)
 2042c98:	10800430 	cmpltui	r2,r2,16
 2042c9c:	103feb1e 	bne	r2,zero,2042c4c <ip_reasm_mark_compact_rfq+0x70>
               compact = IPREASM_FALSE;
               break;
               }
            }
          }
       rfqp = rfqp->next;
 2042ca0:	e0bffd17 	ldw	r2,-12(fp)
 2042ca4:	10800017 	ldw	r2,0(r2)
 2042ca8:	e0bffd15 	stw	r2,-12(fp)
      return ENP_PARAM;
   }

   rfqp = &(irep->rfq);

   while (rfqp)
 2042cac:	e0bffd17 	ldw	r2,-12(fp)
 2042cb0:	103fe41e 	bne	r2,zero,2042c44 <ip_reasm_mark_compact_rfq+0x68>
            }
          }
       rfqp = rfqp->next;
      }

   if (compact) 
 2042cb4:	e0bffec3 	ldbu	r2,-5(fp)
 2042cb8:	10000726 	beq	r2,zero,2042cd8 <ip_reasm_mark_compact_rfq+0xfc>
      {
      irep->flags |= IPR_RFQ_COMPACT;
 2042cbc:	e0bfff17 	ldw	r2,-4(fp)
 2042cc0:	10802103 	ldbu	r2,132(r2)
 2042cc4:	10800054 	ori	r2,r2,1
 2042cc8:	1007883a 	mov	r3,r2
 2042ccc:	e0bfff17 	ldw	r2,-4(fp)
 2042cd0:	10c02105 	stb	r3,132(r2)
 2042cd4:	00000706 	br	2042cf4 <ip_reasm_mark_compact_rfq+0x118>
      }
   else 
      {
      irep->flags &= ~IPR_RFQ_COMPACT;
 2042cd8:	e0bfff17 	ldw	r2,-4(fp)
 2042cdc:	10c02103 	ldbu	r3,132(r2)
 2042ce0:	00bfff84 	movi	r2,-2
 2042ce4:	1884703a 	and	r2,r3,r2
 2042ce8:	1007883a 	mov	r3,r2
 2042cec:	e0bfff17 	ldw	r2,-4(fp)
 2042cf0:	10c02105 	stb	r3,132(r2)
      }

   return IPREASM_OK;
 2042cf4:	0005883a 	mov	r2,zero
}
 2042cf8:	e037883a 	mov	sp,fp
 2042cfc:	dfc00117 	ldw	ra,4(sp)
 2042d00:	df000017 	ldw	fp,0(sp)
 2042d04:	dec00204 	addi	sp,sp,8
 2042d08:	f800283a 	ret

02042d0c <ipr_stats>:

OUTPUT: This function always returns IPREASM_OK.
*/

int ipr_stats(void * pio)
{
 2042d0c:	deffec04 	addi	sp,sp,-80
 2042d10:	dfc01315 	stw	ra,76(sp)
 2042d14:	df001215 	stw	fp,72(sp)
 2042d18:	dc001115 	stw	r16,68(sp)
 2042d1c:	df001104 	addi	fp,sp,68
 2042d20:	e13fff15 	stw	r4,-4(fp)
   unsigned long ticks_elapsed = cticks;
 2042d24:	00808174 	movhi	r2,517
 2042d28:	1090c904 	addi	r2,r2,17188
 2042d2c:	10800017 	ldw	r2,0(r2)
 2042d30:	e0bffd15 	stw	r2,-12(fp)
   u_short size_ire = sizeof(IRE);
 2042d34:	00802204 	movi	r2,136
 2042d38:	e0bffe0d 	sth	r2,-8(fp)
   u_short size_rfq = sizeof(RFQ);
 2042d3c:	00801904 	movi	r2,100
 2042d40:	e0bffe8d 	sth	r2,-6(fp)
   IREP tmpp;
   u_short count = 0;
 2042d44:	e03ffa0d 	sth	zero,-24(fp)
   RFQP rfqp;
   u_short frag_count = 0;
 2042d48:	e03ffc0d 	sth	zero,-16(fp)
   u_short i;

   ns_printf(pio,"IP reassembly statistics:\n");
 2042d4c:	e13fff17 	ldw	r4,-4(fp)
 2042d50:	01408174 	movhi	r5,517
 2042d54:	2945a904 	addi	r5,r5,5796
 2042d58:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
 2042d5c:	d420bd17 	ldw	r16,-32012(gp)
 2042d60:	e13ffd17 	ldw	r4,-12(fp)
 2042d64:	20145600 	call	2014560 <__floatunsidf>
 2042d68:	100b883a 	mov	r5,r2
 2042d6c:	180d883a 	mov	r6,r3
 2042d70:	2809883a 	mov	r4,r5
 2042d74:	300b883a 	mov	r5,r6
 2042d78:	000d883a 	mov	r6,zero
 2042d7c:	01d01674 	movhi	r7,16473
 2042d80:	2013f6c0 	call	2013f6c <__divdf3>
 2042d84:	1009883a 	mov	r4,r2
 2042d88:	180b883a 	mov	r5,r3
 2042d8c:	2005883a 	mov	r2,r4
 2042d90:	2807883a 	mov	r3,r5
 2042d94:	e17ffe0b 	ldhu	r5,-8(fp)
 2042d98:	e13ffe8b 	ldhu	r4,-6(fp)
 2042d9c:	d8800015 	stw	r2,0(sp)
 2042da0:	d8c00115 	stw	r3,4(sp)
 2042da4:	d9400215 	stw	r5,8(sp)
 2042da8:	d9000315 	stw	r4,12(sp)
 2042dac:	e13fff17 	ldw	r4,-4(fp)
 2042db0:	01408174 	movhi	r5,517
 2042db4:	2945b004 	addi	r5,r5,5824
 2042db8:	800d883a 	mov	r6,r16
 2042dbc:	e1fffd17 	ldw	r7,-12(fp)
 2042dc0:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
 2042dc4:	00809934 	movhi	r2,612
 2042dc8:	10b7e704 	addi	r2,r2,-8292
 2042dcc:	10c00117 	ldw	r3,4(r2)
 2042dd0:	00809934 	movhi	r2,612
 2042dd4:	10b7e704 	addi	r2,r2,-8292
 2042dd8:	10800017 	ldw	r2,0(r2)
 2042ddc:	01009934 	movhi	r4,612
 2042de0:	2137e704 	addi	r4,r4,-8292
 2042de4:	21c00217 	ldw	r7,8(r4)
 2042de8:	01009934 	movhi	r4,612
 2042dec:	2137e704 	addi	r4,r4,-8292
 2042df0:	21800317 	ldw	r6,12(r4)
 2042df4:	01009934 	movhi	r4,612
 2042df8:	2137e704 	addi	r4,r4,-8292
 2042dfc:	21400417 	ldw	r5,16(r4)
 2042e00:	01009934 	movhi	r4,612
 2042e04:	2137e704 	addi	r4,r4,-8292
 2042e08:	21000517 	ldw	r4,20(r4)
 2042e0c:	d9c00015 	stw	r7,0(sp)
 2042e10:	d9800115 	stw	r6,4(sp)
 2042e14:	d9400215 	stw	r5,8(sp)
 2042e18:	d9000315 	stw	r4,12(sp)
 2042e1c:	e13fff17 	ldw	r4,-4(fp)
 2042e20:	01408174 	movhi	r5,517
 2042e24:	2945c004 	addi	r5,r5,5888
 2042e28:	180d883a 	mov	r6,r3
 2042e2c:	100f883a 	mov	r7,r2
 2042e30:	2026e100 	call	2026e10 <ns_printf>
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
 2042e34:	d0a0be17 	ldw	r2,-32008(gp)
 2042e38:	e13fff17 	ldw	r4,-4(fp)
 2042e3c:	01408174 	movhi	r5,517
 2042e40:	2945d504 	addi	r5,r5,5972
 2042e44:	100d883a 	mov	r6,r2
 2042e48:	2026e100 	call	2026e10 <ns_printf>
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 2042e4c:	d0a0be17 	ldw	r2,-32008(gp)
 2042e50:	e0bff915 	stw	r2,-28(fp)
 2042e54:	00007c06 	br	2043048 <ipr_stats+0x33c>
      {
      ++count;
 2042e58:	e0bffa0b 	ldhu	r2,-24(fp)
 2042e5c:	10800044 	addi	r2,r2,1
 2042e60:	e0bffa0d 	sth	r2,-24(fp)
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
 2042e64:	e0bff917 	ldw	r2,-28(fp)
 2042e68:	10800604 	addi	r2,r2,24
 2042e6c:	e0bffb15 	stw	r2,-20(fp)
      while (rfqp)
 2042e70:	00001e06 	br	2042eec <ipr_stats+0x1e0>
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042e74:	e03ffc8d 	sth	zero,-14(fp)
 2042e78:	00001406 	br	2042ecc <ipr_stats+0x1c0>
            {
            if (rfqp->bufp [i] != 0)
 2042e7c:	e0bffc8b 	ldhu	r2,-14(fp)
 2042e80:	e0fffb17 	ldw	r3,-20(fp)
 2042e84:	10800044 	addi	r2,r2,1
 2042e88:	1085883a 	add	r2,r2,r2
 2042e8c:	1085883a 	add	r2,r2,r2
 2042e90:	1885883a 	add	r2,r3,r2
 2042e94:	10800017 	ldw	r2,0(r2)
 2042e98:	10000426 	beq	r2,zero,2042eac <ipr_stats+0x1a0>
               {
               ++frag_count;            
 2042e9c:	e0bffc0b 	ldhu	r2,-16(fp)
 2042ea0:	10800044 	addi	r2,r2,1
 2042ea4:	e0bffc0d 	sth	r2,-16(fp)
 2042ea8:	00000506 	br	2042ec0 <ipr_stats+0x1b4>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
 2042eac:	e0bff917 	ldw	r2,-28(fp)
 2042eb0:	10802103 	ldbu	r2,132(r2)
 2042eb4:	10803fcc 	andi	r2,r2,255
 2042eb8:	1080004c 	andi	r2,r2,1
 2042ebc:	1000071e 	bne	r2,zero,2042edc <ipr_stats+0x1d0>
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
         {
         for (i = 0; i < IPR_MAX_FRAGS; ++i)
 2042ec0:	e0bffc8b 	ldhu	r2,-14(fp)
 2042ec4:	10800044 	addi	r2,r2,1
 2042ec8:	e0bffc8d 	sth	r2,-14(fp)
 2042ecc:	e0bffc8b 	ldhu	r2,-14(fp)
 2042ed0:	10800430 	cmpltui	r2,r2,16
 2042ed4:	103fe91e 	bne	r2,zero,2042e7c <ipr_stats+0x170>
 2042ed8:	00000106 	br	2042ee0 <ipr_stats+0x1d4>
               }
            else
               {
               if (tmpp->flags & IPR_RFQ_COMPACT)
                  {
                  break;
 2042edc:	0001883a 	nop
                  }
               }
            }
         rfqp = rfqp->next;
 2042ee0:	e0bffb17 	ldw	r2,-20(fp)
 2042ee4:	10800017 	ldw	r2,0(r2)
 2042ee8:	e0bffb15 	stw	r2,-20(fp)
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
      {
      ++count;
      /* compute the total number of fragments queued awaiting reassembly for this IRE */
      rfqp = &(tmpp->rfq);
      while (rfqp)
 2042eec:	e0bffb17 	ldw	r2,-20(fp)
 2042ef0:	103fe01e 	bne	r2,zero,2042e74 <ipr_stats+0x168>
                  }
               }
            }
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
 2042ef4:	e0bffc0b 	ldhu	r2,-16(fp)
 2042ef8:	e0fff917 	ldw	r3,-28(fp)
 2042efc:	18c00117 	ldw	r3,4(r3)
 2042f00:	1808d63a 	srli	r4,r3,24
 2042f04:	e0fff917 	ldw	r3,-28(fp)
 2042f08:	18c00117 	ldw	r3,4(r3)
 2042f0c:	1806d23a 	srli	r3,r3,8
 2042f10:	18ffc00c 	andi	r3,r3,65280
 2042f14:	20c8b03a 	or	r4,r4,r3
 2042f18:	e0fff917 	ldw	r3,-28(fp)
 2042f1c:	18c00117 	ldw	r3,4(r3)
 2042f20:	18ffc00c 	andi	r3,r3,65280
 2042f24:	1806923a 	slli	r3,r3,8
 2042f28:	20c8b03a 	or	r4,r4,r3
 2042f2c:	e0fff917 	ldw	r3,-28(fp)
 2042f30:	18c00117 	ldw	r3,4(r3)
 2042f34:	1806963a 	slli	r3,r3,24
 2042f38:	20d8b03a 	or	r12,r4,r3
 2042f3c:	e0fff917 	ldw	r3,-28(fp)
 2042f40:	18c00217 	ldw	r3,8(r3)
 2042f44:	1808d63a 	srli	r4,r3,24
 2042f48:	e0fff917 	ldw	r3,-28(fp)
 2042f4c:	18c00217 	ldw	r3,8(r3)
 2042f50:	1806d23a 	srli	r3,r3,8
 2042f54:	18ffc00c 	andi	r3,r3,65280
 2042f58:	20c8b03a 	or	r4,r4,r3
 2042f5c:	e0fff917 	ldw	r3,-28(fp)
 2042f60:	18c00217 	ldw	r3,8(r3)
 2042f64:	18ffc00c 	andi	r3,r3,65280
 2042f68:	1806923a 	slli	r3,r3,8
 2042f6c:	20c8b03a 	or	r4,r4,r3
 2042f70:	e0fff917 	ldw	r3,-28(fp)
 2042f74:	18c00217 	ldw	r3,8(r3)
 2042f78:	1806963a 	slli	r3,r3,24
 2042f7c:	20d6b03a 	or	r11,r4,r3
 2042f80:	e0fff917 	ldw	r3,-28(fp)
 2042f84:	18c00383 	ldbu	r3,14(r3)
 2042f88:	1a803fcc 	andi	r10,r3,255
 2042f8c:	e0fff917 	ldw	r3,-28(fp)
 2042f90:	18c0030b 	ldhu	r3,12(r3)
 2042f94:	18ffffcc 	andi	r3,r3,65535
 2042f98:	1806d23a 	srli	r3,r3,8
 2042f9c:	18ffffcc 	andi	r3,r3,65535
 2042fa0:	19003fcc 	andi	r4,r3,255
 2042fa4:	e0fff917 	ldw	r3,-28(fp)
 2042fa8:	18c0030b 	ldhu	r3,12(r3)
 2042fac:	18ffffcc 	andi	r3,r3,65535
 2042fb0:	1806923a 	slli	r3,r3,8
 2042fb4:	18ffffcc 	andi	r3,r3,65535
 2042fb8:	20d2b03a 	or	r9,r4,r3
 2042fbc:	e0fff917 	ldw	r3,-28(fp)
 2042fc0:	18c0040b 	ldhu	r3,16(r3)
 2042fc4:	1a3fffcc 	andi	r8,r3,65535
 2042fc8:	e0fff917 	ldw	r3,-28(fp)
 2042fcc:	18c0048b 	ldhu	r3,18(r3)
 2042fd0:	19ffffcc 	andi	r7,r3,65535
 2042fd4:	e0fff917 	ldw	r3,-28(fp)
 2042fd8:	19800517 	ldw	r6,20(r3)
 2042fdc:	e0fff917 	ldw	r3,-28(fp)
 2042fe0:	19401f17 	ldw	r5,124(r3)
 2042fe4:	e0fff917 	ldw	r3,-28(fp)
 2042fe8:	19002017 	ldw	r4,128(r3)
 2042fec:	e0fff917 	ldw	r3,-28(fp)
 2042ff0:	18c02103 	ldbu	r3,132(r3)
 2042ff4:	18c03fcc 	andi	r3,r3,255
 2042ff8:	18c0004c 	andi	r3,r3,1
 2042ffc:	db000015 	stw	r12,0(sp)
 2043000:	dac00115 	stw	r11,4(sp)
 2043004:	da800215 	stw	r10,8(sp)
 2043008:	da400315 	stw	r9,12(sp)
 204300c:	da000415 	stw	r8,16(sp)
 2043010:	d9c00515 	stw	r7,20(sp)
 2043014:	d9800615 	stw	r6,24(sp)
 2043018:	d9400715 	stw	r5,28(sp)
 204301c:	d9000815 	stw	r4,32(sp)
 2043020:	d8c00915 	stw	r3,36(sp)
 2043024:	e13fff17 	ldw	r4,-4(fp)
 2043028:	01408174 	movhi	r5,517
 204302c:	2945db04 	addi	r5,r5,5996
 2043030:	e1bff917 	ldw	r6,-28(fp)
 2043034:	100f883a 	mov	r7,r2
 2043038:	2026e100 	call	2026e10 <ns_printf>
   ns_printf(pio,"Current memory useage %lu, ticks %lu, secs %lu, IRE %u, RFQ %u\n",ipr_curr_mem,ticks_elapsed,(ticks_elapsed/TPS),size_ire,size_rfq);
   ns_printf(pio,"[ERR] IRE T/O %lu, IRE ptr %lu, max mem %lu, mem chk %lu, mem inc %lu, mem dec %lu\n",\
    ire_stats.ire_timed_out,ire_stats.bad_irep,ire_stats.bad_max_mem,ire_stats.mem_check_fail,ire_stats.mem_incr_fail,ire_stats.mem_decr_fail);

   ns_printf(pio,"Head of IRE queue %p\n",h_ireq); 
   for (tmpp = h_ireq; tmpp; tmpp = tmpp->next)
 204303c:	e0bff917 	ldw	r2,-28(fp)
 2043040:	10800017 	ldw	r2,0(r2)
 2043044:	e0bff915 	stw	r2,-28(fp)
 2043048:	e0bff917 	ldw	r2,-28(fp)
 204304c:	103f821e 	bne	r2,zero,2042e58 <ipr_stats+0x14c>
         rfqp = rfqp->next;
         } /* end WHILE (fragments queued) */
      ns_printf(pio,"IRE %p [Frags queued %u] SA 0x%lx DA 0x%lx Prot %u Id %u Len %u Rcvd %u Age %lu L2H %p L3H %p Compact %u]\n",tmpp,frag_count,(ntohl(tmpp->src)),(ntohl(tmpp->dest)),tmpp->prot,(ntohs(tmpp->id)),tmpp->length,tmpp->rcvd,tmpp->age,tmpp->l2_hdr,tmpp->l3_hdr,((tmpp->flags) & IPR_RFQ_COMPACT));
      } /* end FOR (IRE linked list) */

   ns_printf(pio,"Found a total of %u IRE entries\n",count);
 2043050:	e0bffa0b 	ldhu	r2,-24(fp)
 2043054:	e13fff17 	ldw	r4,-4(fp)
 2043058:	01408174 	movhi	r5,517
 204305c:	2945f604 	addi	r5,r5,6104
 2043060:	100d883a 	mov	r6,r2
 2043064:	2026e100 	call	2026e10 <ns_printf>

   return IPREASM_OK;
 2043068:	0005883a 	mov	r2,zero
}
 204306c:	e037883a 	mov	sp,fp
 2043070:	dfc00217 	ldw	ra,8(sp)
 2043074:	df000117 	ldw	fp,4(sp)
 2043078:	dc000017 	ldw	r16,0(sp)
 204307c:	dec00304 	addi	sp,sp,12
 2043080:	f800283a 	ret

02043084 <ip_reasm_send_icmp_timex>:
OUTPUT: This function always returns IPREASM_OK.
*/

#ifdef FULL_ICMP
u_long ip_reasm_send_icmp_timex (IREP irep)
{
 2043084:	defffc04 	addi	sp,sp,-16
 2043088:	dfc00315 	stw	ra,12(sp)
 204308c:	df000215 	stw	fp,8(sp)
 2043090:	df000204 	addi	fp,sp,8
 2043094:	e13fff15 	stw	r4,-4(fp)

   /* we can only send an ICMP Time Exceeded message with code 1 ("fragment reassembly 
    * time exceeded") if we have received the First Fragment (FF) of the original, 
    * unfragmented datagram.  This is indicated by a non-zero value for the l2_hdr and
    * l3_hdr fields in the IRE data structure. */
   if (irep->l2_hdr)
 2043098:	e0bfff17 	ldw	r2,-4(fp)
 204309c:	10801f17 	ldw	r2,124(r2)
 20430a0:	10000626 	beq	r2,zero,20430bc <ip_reasm_send_icmp_timex+0x38>
      {
      pip = (struct ip *) irep->l3_hdr;
 20430a4:	e0bfff17 	ldw	r2,-4(fp)
 20430a8:	10802017 	ldw	r2,128(r2)
 20430ac:	e0bffe15 	stw	r2,-8(fp)
      icmp_timex (pip, TIMEX_REASSY_FAILED);
 20430b0:	e13ffe17 	ldw	r4,-8(fp)
 20430b4:	01400044 	movi	r5,1
 20430b8:	204b8280 	call	204b828 <icmp_timex>
      }

   return IPREASM_OK;
 20430bc:	0005883a 	mov	r2,zero
}
 20430c0:	e037883a 	mov	sp,fp
 20430c4:	dfc00117 	ldw	ra,4(sp)
 20430c8:	df000017 	ldw	fp,0(sp)
 20430cc:	dec00204 	addi	sp,sp,8
 20430d0:	f800283a 	ret

020430d4 <ip_rcv>:
 * RETURNS: 
 */

int
ip_rcv(PACKET p)
{
 20430d4:	defff304 	addi	sp,sp,-52
 20430d8:	dfc00c15 	stw	ra,48(sp)
 20430dc:	df000b15 	stw	fp,44(sp)
 20430e0:	dc000a15 	stw	r16,40(sp)
 20430e4:	df000a04 	addi	fp,sp,40
 20430e8:	e13fff15 	stw	r4,-4(fp)
   unsigned hdrlen;  /* length of IP header including options */
   unsigned len;     /* total length including IP header */
   unsigned short int num_pkts;
   PACKET * pktp;
   unsigned char i;
   int rcvrc = -1;
 20430ec:	00bfffc4 	movi	r2,-1
 20430f0:	e0bff715 	stw	r2,-36(fp)
   unsigned char rc_ret;
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 20430f4:	00808174 	movhi	r2,517
 20430f8:	1090b204 	addi	r2,r2,17096
 20430fc:	10800017 	ldw	r2,0(r2)
 2043100:	1081000c 	andi	r2,r2,1024
 2043104:	10001026 	beq	r2,zero,2043148 <ip_rcv+0x74>
 2043108:	00808174 	movhi	r2,517
 204310c:	1090b204 	addi	r2,r2,17096
 2043110:	10800017 	ldw	r2,0(r2)
 2043114:	1080800c 	andi	r2,r2,512
 2043118:	10000b26 	beq	r2,zero,2043148 <ip_rcv+0x74>
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
         p->nb_plen, net_num(p->net));
 204311c:	e0bfff17 	ldw	r2,-4(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 2043120:	14000417 	ldw	r16,16(r2)
         p->nb_plen, net_num(p->net));
 2043124:	e0bfff17 	ldw	r2,-4(fp)
#endif


#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      dprintf("ip_rcv: got packet, len:%d, if:%d\n",
 2043128:	10800617 	ldw	r2,24(r2)
 204312c:	1009883a 	mov	r4,r2
 2043130:	2024bac0 	call	2024bac <if_netnumber>
 2043134:	01008174 	movhi	r4,517
 2043138:	2105ff04 	addi	r4,r4,6140
 204313c:	800b883a 	mov	r5,r16
 2043140:	100d883a 	mov	r6,r2
 2043144:	2006a240 	call	2006a24 <printf>
         p->nb_plen, net_num(p->net));
#endif

   IN_PROFILER(PF_IP, PF_ENTRY);

   nt = p->net;      /* which interface it came in on */
 2043148:	e0bfff17 	ldw	r2,-4(fp)
 204314c:	10800617 	ldw	r2,24(r2)
 2043150:	e0bff815 	stw	r2,-32(fp)
   ip_mib.ipInReceives++;
 2043154:	00809934 	movhi	r2,612
 2043158:	10b7d304 	addi	r2,r2,-8372
 204315c:	10800217 	ldw	r2,8(r2)
 2043160:	10c00044 	addi	r3,r2,1
 2043164:	00809934 	movhi	r2,612
 2043168:	10b7d304 	addi	r2,r2,-8372
 204316c:	10c00215 	stw	r3,8(r2)
   pip = ip_head(p);
 2043170:	e0bfff17 	ldw	r2,-4(fp)
 2043174:	10800317 	ldw	r2,12(r2)
 2043178:	e0bff915 	stw	r2,-28(fp)

   /* test received MAC len against IP header len */
   if (p->nb_plen < (unsigned)htons(pip->ip_len))
 204317c:	e0bfff17 	ldw	r2,-4(fp)
 2043180:	10c00417 	ldw	r3,16(r2)
 2043184:	e0bff917 	ldw	r2,-28(fp)
 2043188:	1080008b 	ldhu	r2,2(r2)
 204318c:	10bfffcc 	andi	r2,r2,65535
 2043190:	1004d23a 	srli	r2,r2,8
 2043194:	10bfffcc 	andi	r2,r2,65535
 2043198:	11003fcc 	andi	r4,r2,255
 204319c:	e0bff917 	ldw	r2,-28(fp)
 20431a0:	1080008b 	ldhu	r2,2(r2)
 20431a4:	10bfffcc 	andi	r2,r2,65535
 20431a8:	1004923a 	slli	r2,r2,8
 20431ac:	10bfffcc 	andi	r2,r2,65535
 20431b0:	2084b03a 	or	r2,r4,r2
 20431b4:	1880252e 	bgeu	r3,r2,204324c <ip_rcv+0x178>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 20431b8:	00808174 	movhi	r2,517
 20431bc:	1090b204 	addi	r2,r2,17096
 20431c0:	10800017 	ldw	r2,0(r2)
 20431c4:	1081000c 	andi	r2,r2,1024
 20431c8:	10001026 	beq	r2,zero,204320c <ip_rcv+0x138>
 20431cc:	00808174 	movhi	r2,517
 20431d0:	1090b204 	addi	r2,r2,17096
 20431d4:	10800017 	ldw	r2,0(r2)
 20431d8:	1080800c 	andi	r2,r2,512
 20431dc:	10000b26 	beq	r2,zero,204320c <ip_rcv+0x138>
      {
         dprintf("ip_rcv: bad pkt len\n");
 20431e0:	01008174 	movhi	r4,517
 20431e4:	21060804 	addi	r4,r4,6176
 20431e8:	2006cb40 	call	2006cb4 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 20431ec:	00808174 	movhi	r2,517
 20431f0:	1090b204 	addi	r2,r2,17096
 20431f4:	10800017 	ldw	r2,0(r2)
 20431f8:	1080008c 	andi	r2,r2,2
 20431fc:	10000326 	beq	r2,zero,204320c <ip_rcv+0x138>
 2043200:	e0bfff17 	ldw	r2,-4(fp)
 2043204:	1009883a 	mov	r4,r2
 2043208:	2040e3c0 	call	2040e3c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 204320c:	00809934 	movhi	r2,612
 2043210:	10b7d304 	addi	r2,r2,-8372
 2043214:	10800317 	ldw	r2,12(r2)
 2043218:	10c00044 	addi	r3,r2,1
 204321c:	00809934 	movhi	r2,612
 2043220:	10b7d304 	addi	r2,r2,-8372
 2043224:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2043228:	01000084 	movi	r4,2
 204322c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 2043230:	e0bfff17 	ldw	r2,-4(fp)
 2043234:	1009883a 	mov	r4,r2
 2043238:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204323c:	01000084 	movi	r4,2
 2043240:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 2043244:	00bff804 	movi	r2,-32
 2043248:	00009406 	br	204349c <ip_rcv+0x3c8>
   }

   /* use length from IP header; MAC value may be padded */
   len = htons(pip->ip_len);
 204324c:	e0bff917 	ldw	r2,-28(fp)
 2043250:	1080008b 	ldhu	r2,2(r2)
 2043254:	10bfffcc 	andi	r2,r2,65535
 2043258:	1004d23a 	srli	r2,r2,8
 204325c:	10bfffcc 	andi	r2,r2,65535
 2043260:	10c03fcc 	andi	r3,r2,255
 2043264:	e0bff917 	ldw	r2,-28(fp)
 2043268:	1080008b 	ldhu	r2,2(r2)
 204326c:	10bfffcc 	andi	r2,r2,65535
 2043270:	1004923a 	slli	r2,r2,8
 2043274:	10bfffcc 	andi	r2,r2,65535
 2043278:	1884b03a 	or	r2,r3,r2
 204327c:	e0bffa15 	stw	r2,-24(fp)
   p->nb_plen = len;       /* fix pkt len */
 2043280:	e0bfff17 	ldw	r2,-4(fp)
 2043284:	e0fffa17 	ldw	r3,-24(fp)
 2043288:	10c00415 	stw	r3,16(r2)

   if ( ((pip->ip_ver_ihl & 0xf0) >> 4) != IP_VER)
 204328c:	e0bff917 	ldw	r2,-28(fp)
 2043290:	10800003 	ldbu	r2,0(r2)
 2043294:	10803fcc 	andi	r2,r2,255
 2043298:	1004d13a 	srli	r2,r2,4
 204329c:	10803fcc 	andi	r2,r2,255
 20432a0:	10800120 	cmpeqi	r2,r2,4
 20432a4:	1000251e 	bne	r2,zero,204333c <ip_rcv+0x268>
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 20432a8:	00808174 	movhi	r2,517
 20432ac:	1090b204 	addi	r2,r2,17096
 20432b0:	10800017 	ldw	r2,0(r2)
 20432b4:	1081000c 	andi	r2,r2,1024
 20432b8:	10001026 	beq	r2,zero,20432fc <ip_rcv+0x228>
 20432bc:	00808174 	movhi	r2,517
 20432c0:	1090b204 	addi	r2,r2,17096
 20432c4:	10800017 	ldw	r2,0(r2)
 20432c8:	1080800c 	andi	r2,r2,512
 20432cc:	10000b26 	beq	r2,zero,20432fc <ip_rcv+0x228>
      {
         dprintf("ip_rcv: bad version number\n");
 20432d0:	01008174 	movhi	r4,517
 20432d4:	21060d04 	addi	r4,r4,6196
 20432d8:	2006cb40 	call	2006cb4 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 20432dc:	00808174 	movhi	r2,517
 20432e0:	1090b204 	addi	r2,r2,17096
 20432e4:	10800017 	ldw	r2,0(r2)
 20432e8:	1080008c 	andi	r2,r2,2
 20432ec:	10000326 	beq	r2,zero,20432fc <ip_rcv+0x228>
 20432f0:	e0bfff17 	ldw	r2,-4(fp)
 20432f4:	1009883a 	mov	r4,r2
 20432f8:	2040e3c0 	call	2040e3c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 20432fc:	00809934 	movhi	r2,612
 2043300:	10b7d304 	addi	r2,r2,-8372
 2043304:	10800317 	ldw	r2,12(r2)
 2043308:	10c00044 	addi	r3,r2,1
 204330c:	00809934 	movhi	r2,612
 2043310:	10b7d304 	addi	r2,r2,-8372
 2043314:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2043318:	01000084 	movi	r4,2
 204331c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 2043320:	e0bfff17 	ldw	r2,-4(fp)
 2043324:	1009883a 	mov	r4,r2
 2043328:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204332c:	01000084 	movi	r4,2
 2043330:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 2043334:	00bff804 	movi	r2,-32
 2043338:	00005806 	br	204349c <ip_rcv+0x3c8>
   }

   csum = pip->ip_chksum;
 204333c:	e0bff917 	ldw	r2,-28(fp)
 2043340:	1080028b 	ldhu	r2,10(r2)
 2043344:	e0bffb0d 	sth	r2,-20(fp)
   pip->ip_chksum = 0;
 2043348:	e0bff917 	ldw	r2,-28(fp)
 204334c:	1000028d 	sth	zero,10(r2)
   hdrlen = ip_hlen(pip);
 2043350:	e0bff917 	ldw	r2,-28(fp)
 2043354:	10800003 	ldbu	r2,0(r2)
 2043358:	10803fcc 	andi	r2,r2,255
 204335c:	108003cc 	andi	r2,r2,15
 2043360:	1085883a 	add	r2,r2,r2
 2043364:	1085883a 	add	r2,r2,r2
 2043368:	e0bffc15 	stw	r2,-16(fp)
   tempsum = ~cksum(pip, hdrlen >> 1);
 204336c:	e0bffc17 	ldw	r2,-16(fp)
 2043370:	1004d07a 	srli	r2,r2,1
 2043374:	e13ff917 	ldw	r4,-28(fp)
 2043378:	100b883a 	mov	r5,r2
 204337c:	20268040 	call	2026804 <cksum>
 2043380:	0084303a 	nor	r2,zero,r2
 2043384:	e0bffd0d 	sth	r2,-12(fp)

   if (csum != tempsum)
 2043388:	e0fffb0b 	ldhu	r3,-20(fp)
 204338c:	e0bffd0b 	ldhu	r2,-12(fp)
 2043390:	18802826 	beq	r3,r2,2043434 <ip_rcv+0x360>
   {
      pip->ip_chksum = csum;
 2043394:	e0bff917 	ldw	r2,-28(fp)
 2043398:	e0fffb0b 	ldhu	r3,-20(fp)
 204339c:	10c0028d 	sth	r3,10(r2)
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 20433a0:	00808174 	movhi	r2,517
 20433a4:	1090b204 	addi	r2,r2,17096
 20433a8:	10800017 	ldw	r2,0(r2)
 20433ac:	1081000c 	andi	r2,r2,1024
 20433b0:	10001026 	beq	r2,zero,20433f4 <ip_rcv+0x320>
 20433b4:	00808174 	movhi	r2,517
 20433b8:	1090b204 	addi	r2,r2,17096
 20433bc:	10800017 	ldw	r2,0(r2)
 20433c0:	1080800c 	andi	r2,r2,512
 20433c4:	10000b26 	beq	r2,zero,20433f4 <ip_rcv+0x320>
      {
         dprintf("ip_rcv: bad xsum\n");
 20433c8:	01008174 	movhi	r4,517
 20433cc:	21061404 	addi	r4,r4,6224
 20433d0:	2006cb40 	call	2006cb4 <puts>
         if (NDEBUG & DUMP) ip_dump(p);
 20433d4:	00808174 	movhi	r2,517
 20433d8:	1090b204 	addi	r2,r2,17096
 20433dc:	10800017 	ldw	r2,0(r2)
 20433e0:	1080008c 	andi	r2,r2,2
 20433e4:	10000326 	beq	r2,zero,20433f4 <ip_rcv+0x320>
 20433e8:	e0bfff17 	ldw	r2,-4(fp)
 20433ec:	1009883a 	mov	r4,r2
 20433f0:	2040e3c0 	call	2040e3c <ip_dump>
            }
#endif
      ip_mib.ipInHdrErrors++;
 20433f4:	00809934 	movhi	r2,612
 20433f8:	10b7d304 	addi	r2,r2,-8372
 20433fc:	10800317 	ldw	r2,12(r2)
 2043400:	10c00044 	addi	r3,r2,1
 2043404:	00809934 	movhi	r2,612
 2043408:	10b7d304 	addi	r2,r2,-8372
 204340c:	10c00315 	stw	r3,12(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 2043410:	01000084 	movi	r4,2
 2043414:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 2043418:	e0bfff17 	ldw	r2,-4(fp)
 204341c:	1009883a 	mov	r4,r2
 2043420:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2043424:	01000084 	movi	r4,2
 2043428:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      IN_PROFILER(PF_IP, PF_EXIT);
      return(ENP_BAD_HEADER);
 204342c:	00bff804 	movi	r2,-32
 2043430:	00001a06 	br	204349c <ip_rcv+0x3c8>
   }

   pip->ip_chksum = csum;
 2043434:	e0bff917 	ldw	r2,-28(fp)
 2043438:	e0fffb0b 	ldhu	r3,-20(fp)
 204343c:	10c0028d 	sth	r3,10(r2)
#endif

    /* start off by assuming that we will only process the "current" packet;
     * these values may get overwritten by the NAT module if it returns
     * more than one packet back to this function (ip_rcv ()) */
    num_pkts = 1;
 2043440:	00800044 	movi	r2,1
 2043444:	e0bffd8d 	sth	r2,-10(fp)
    pktp = &p;
 2043448:	e0bfff04 	addi	r2,fp,-4
 204344c:	e0bffe15 	stw	r2,-8(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 2043450:	e03ff605 	stb	zero,-40(fp)
 2043454:	00000c06 	br	2043488 <ip_rcv+0x3b4>
   {
      rcvrc = ip_rcv_phase2 (*(pktp + i));
 2043458:	e0bff603 	ldbu	r2,-40(fp)
 204345c:	1085883a 	add	r2,r2,r2
 2043460:	1085883a 	add	r2,r2,r2
 2043464:	e0fffe17 	ldw	r3,-8(fp)
 2043468:	1885883a 	add	r2,r3,r2
 204346c:	10800017 	ldw	r2,0(r2)
 2043470:	1009883a 	mov	r4,r2
 2043474:	20434b40 	call	20434b4 <ip_rcv_phase2>
 2043478:	e0bff715 	stw	r2,-36(fp)
    * by other modules */
#endif   /* NATRT */

   /* we need to process 'num_pkts' packets.  Pointers to these packets are stored
    * in storage @ 'pktp' */
   for (i = 0; i < num_pkts; ++i)
 204347c:	e0bff603 	ldbu	r2,-40(fp)
 2043480:	10800044 	addi	r2,r2,1
 2043484:	e0bff605 	stb	r2,-40(fp)
 2043488:	e0bff603 	ldbu	r2,-40(fp)
 204348c:	10ffffcc 	andi	r3,r2,65535
 2043490:	e0bffd8b 	ldhu	r2,-10(fp)
 2043494:	18bff036 	bltu	r3,r2,2043458 <ip_rcv+0x384>
   if (pktp != &p) nat_free (pktp);
#endif /* NATRT */

   /* when multiple packets are processed in the loop above, the return code
    * contains the return code for the last packet */
   return rcvrc;
 2043498:	e0bff717 	ldw	r2,-36(fp)
}
 204349c:	e037883a 	mov	sp,fp
 20434a0:	dfc00217 	ldw	ra,8(sp)
 20434a4:	df000117 	ldw	fp,4(sp)
 20434a8:	dc000017 	ldw	r16,0(sp)
 20434ac:	dec00304 	addi	sp,sp,12
 20434b0:	f800283a 	ret

020434b4 <ip_rcv_phase2>:


int ip_rcv_phase2 (PACKET p)
{
 20434b4:	defff504 	addi	sp,sp,-44
 20434b8:	dfc00a15 	stw	ra,40(sp)
 20434bc:	df000915 	stw	fp,36(sp)
 20434c0:	df000904 	addi	fp,sp,36
 20434c4:	e13fff15 	stw	r4,-4(fp)

   struct ip * pip;     /* the internet header */
   NET nt;
   unsigned short tempsum;

   pip = ip_head(p);
 20434c8:	e0bfff17 	ldw	r2,-4(fp)
 20434cc:	10800317 	ldw	r2,12(r2)
 20434d0:	e0bff815 	stw	r2,-32(fp)
   nt = p->net;      /* which interface it came in on */
 20434d4:	e0bfff17 	ldw	r2,-4(fp)
 20434d8:	10800617 	ldw	r2,24(r2)
 20434dc:	e0bff915 	stw	r2,-28(fp)

#ifdef IP_MULTICAST

   if (IN_MULTICAST(ntohl(pip->ip_dest))) 
 20434e0:	e0bff817 	ldw	r2,-32(fp)
 20434e4:	10800417 	ldw	r2,16(r2)
 20434e8:	1006d63a 	srli	r3,r2,24
 20434ec:	e0bff817 	ldw	r2,-32(fp)
 20434f0:	10800417 	ldw	r2,16(r2)
 20434f4:	1004d23a 	srli	r2,r2,8
 20434f8:	10bfc00c 	andi	r2,r2,65280
 20434fc:	1886b03a 	or	r3,r3,r2
 2043500:	e0bff817 	ldw	r2,-32(fp)
 2043504:	10800417 	ldw	r2,16(r2)
 2043508:	10bfc00c 	andi	r2,r2,65280
 204350c:	1004923a 	slli	r2,r2,8
 2043510:	1886b03a 	or	r3,r3,r2
 2043514:	e0bff817 	ldw	r2,-32(fp)
 2043518:	10800417 	ldw	r2,16(r2)
 204351c:	1004963a 	slli	r2,r2,24
 2043520:	1884b03a 	or	r2,r3,r2
 2043524:	10fc002c 	andhi	r3,r2,61440
 2043528:	00b80034 	movhi	r2,57344
 204352c:	1880171e 	bne	r3,r2,204358c <ip_rcv_phase2+0xd8>
      struct in_multi * inm;
      /*
       * See if we belong to the destination multicast group on the
       * arrival interface.
       */
      inm = lookup_mcast(pip->ip_dest, nt);
 2043530:	e0bff817 	ldw	r2,-32(fp)
 2043534:	10800417 	ldw	r2,16(r2)
 2043538:	1009883a 	mov	r4,r2
 204353c:	e17ff917 	ldw	r5,-28(fp)
 2043540:	20440e40 	call	20440e4 <lookup_mcast>
 2043544:	e0bffa15 	stw	r2,-24(fp)
      if (inm == NULL) 
 2043548:	e0bffa17 	ldw	r2,-24(fp)
 204354c:	10010b1e 	bne	r2,zero,204397c <ip_rcv_phase2+0x4c8>
      {
         ip_mib.ipOutNoRoutes++;
 2043550:	00809934 	movhi	r2,612
 2043554:	10b7d304 	addi	r2,r2,-8372
 2043558:	10800b17 	ldw	r2,44(r2)
 204355c:	10c00044 	addi	r3,r2,1
 2043560:	00809934 	movhi	r2,612
 2043564:	10b7d304 	addi	r2,r2,-8372
 2043568:	10c00b15 	stw	r3,44(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 204356c:	01000084 	movi	r4,2
 2043570:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 2043574:	e13fff17 	ldw	r4,-4(fp)
 2043578:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204357c:	01000084 	movi	r4,2
 2043580:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
 2043584:	00800084 	movi	r2,2
 2043588:	00013c06 	br	2043a7c <ip_rcv_phase2+0x5c8>
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 204358c:	e0bff817 	ldw	r2,-32(fp)
 2043590:	10c00417 	ldw	r3,16(r2)
 2043594:	e0bff917 	ldw	r2,-28(fp)
 2043598:	10800a17 	ldw	r2,40(r2)
 204359c:	1880f826 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 20435a0:	e0bff817 	ldw	r2,-32(fp)
 20435a4:	10800417 	ldw	r2,16(r2)
      else
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
 20435a8:	10bfffe0 	cmpeqi	r2,r2,-1
 20435ac:	1000f41e 	bne	r2,zero,2043980 <ip_rcv_phase2+0x4cc>
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 20435b0:	e0bff817 	ldw	r2,-32(fp)
 20435b4:	10c00417 	ldw	r3,16(r2)
 20435b8:	e0bff917 	ldw	r2,-28(fp)
 20435bc:	10800e17 	ldw	r2,56(r2)
         goto ours;
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 20435c0:	1880ef26 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 20435c4:	e0bff817 	ldw	r2,-32(fp)
 20435c8:	10c00417 	ldw	r3,16(r2)
 20435cc:	e0bff917 	ldw	r2,-28(fp)
 20435d0:	10800f17 	ldw	r2,60(r2)
   }
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
 20435d4:	1880ea26 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 20435d8:	e0bff817 	ldw	r2,-32(fp)
 20435dc:	10c00417 	ldw	r3,16(r2)
 20435e0:	e0bff917 	ldw	r2,-28(fp)
 20435e4:	10801017 	ldw	r2,64(r2)
#endif   /* IP_MULTICAST */

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
 20435e8:	1880e526 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
 20435ec:	e0bff917 	ldw	r2,-28(fp)
 20435f0:	10c00a17 	ldw	r3,40(r2)
 20435f4:	e0bff917 	ldw	r2,-28(fp)
 20435f8:	10800c17 	ldw	r2,48(r2)
 20435fc:	0084303a 	nor	r2,zero,r2
 2043600:	1884703a 	and	r2,r3,r2

   if ((pip->ip_dest != nt->n_ipaddr) &&  /* Quick check on our own addr */
       (pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
       (pip->ip_dest != nt->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != nt->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
 2043604:	1000de26 	beq	r2,zero,2043980 <ip_rcv_phase2+0x4cc>
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 2043608:	00808174 	movhi	r2,517
 204360c:	1090b204 	addi	r2,r2,17096
 2043610:	10800017 	ldw	r2,0(r2)
 2043614:	1081000c 	andi	r2,r2,1024
 2043618:	10001926 	beq	r2,zero,2043680 <ip_rcv_phase2+0x1cc>
 204361c:	00808174 	movhi	r2,517
 2043620:	1090b204 	addi	r2,r2,17096
 2043624:	10800017 	ldw	r2,0(r2)
 2043628:	1080800c 	andi	r2,r2,512
 204362c:	10001426 	beq	r2,zero,2043680 <ip_rcv_phase2+0x1cc>
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
       PUSH_IPADDR(pip->ip_dest));
 2043630:	e0bff817 	ldw	r2,-32(fp)
 2043634:	10800417 	ldw	r2,16(r2)
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 2043638:	11403fcc 	andi	r5,r2,255
       PUSH_IPADDR(pip->ip_dest));
 204363c:	e0bff817 	ldw	r2,-32(fp)
 2043640:	10800417 	ldw	r2,16(r2)
 2043644:	1004d23a 	srli	r2,r2,8
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 2043648:	10c03fcc 	andi	r3,r2,255
       PUSH_IPADDR(pip->ip_dest));
 204364c:	e0bff817 	ldw	r2,-32(fp)
 2043650:	10800417 	ldw	r2,16(r2)
 2043654:	1004d43a 	srli	r2,r2,16
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 2043658:	10803fcc 	andi	r2,r2,255
       PUSH_IPADDR(pip->ip_dest));
 204365c:	e13ff817 	ldw	r4,-32(fp)
 2043660:	21000417 	ldw	r4,16(r4)
 2043664:	2008d63a 	srli	r4,r4,24
       (pip->ip_dest != nt->n_subnetbr) &&/* Our subnet broadcast */
       (nt->n_ipaddr & ~nt->snmask))      /* Know our own host address? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
         dprintf("ip_rcv: got pkt not for me; for %u.%u.%u.%u\n",
 2043668:	d9000015 	stw	r4,0(sp)
 204366c:	01008174 	movhi	r4,517
 2043670:	21061904 	addi	r4,r4,6244
 2043674:	180d883a 	mov	r6,r3
 2043678:	100f883a 	mov	r7,r2
 204367c:	2006a240 	call	2006a24 <printf>

#ifdef IP_ROUTING    /* if multi-homed router, try to route */
      /* Do routing only if ipForwarding is enabled in the IP MIB. This
       * is the switch for routing whether SNMP is used or not.
       */
      if (ip_mib.ipForwarding == 2)
 2043680:	00809934 	movhi	r2,612
 2043684:	10b7d304 	addi	r2,r2,-8372
 2043688:	10800017 	ldw	r2,0(r2)
 204368c:	10800098 	cmpnei	r2,r2,2
 2043690:	10000f1e 	bne	r2,zero,20436d0 <ip_rcv_phase2+0x21c>
      {
         ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 2043694:	00809934 	movhi	r2,612
 2043698:	10b7d304 	addi	r2,r2,-8372
 204369c:	10800a17 	ldw	r2,40(r2)
 20436a0:	10c00044 	addi	r3,r2,1
 20436a4:	00809934 	movhi	r2,612
 20436a8:	10b7d304 	addi	r2,r2,-8372
 20436ac:	10c00a15 	stw	r3,40(r2)
         LOCK_NET_RESOURCE(FREEQ_RESID);
 20436b0:	01000084 	movi	r4,2
 20436b4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
         pk_free(p);
 20436b8:	e13fff17 	ldw	r4,-4(fp)
 20436bc:	20280440 	call	2028044 <pk_free>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20436c0:	01000084 	movi	r4,2
 20436c4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         IN_PROFILER(PF_IP, PF_EXIT);
         return ENP_NO_ROUTE;
 20436c8:	00bff7c4 	movi	r2,-33
 20436cc:	0000eb06 	br	2043a7c <ip_rcv_phase2+0x5c8>
         NET outnet;
#ifdef IP_FRAGMENTS
         int err;
#endif

         ip_mib.ipForwDatagrams++;  /* Count MIB-2 route attempts here */
 20436d0:	00809934 	movhi	r2,612
 20436d4:	10b7d304 	addi	r2,r2,-8372
 20436d8:	10800517 	ldw	r2,20(r2)
 20436dc:	10c00044 	addi	r3,r2,1
 20436e0:	00809934 	movhi	r2,612
 20436e4:	10b7d304 	addi	r2,r2,-8372
 20436e8:	10c00515 	stw	r3,20(r2)
         if (pip->ip_time <= 1)     /* Time to Live (hopcount) expired? */
 20436ec:	e0bff817 	ldw	r2,-32(fp)
 20436f0:	10800203 	ldbu	r2,8(r2)
 20436f4:	10803fcc 	andi	r2,r2,255
 20436f8:	108000a8 	cmpgeui	r2,r2,2
 20436fc:	10001c1e 	bne	r2,zero,2043770 <ip_rcv_phase2+0x2bc>
         {
            ip_mib.ipOutDiscards++; /* Is this the right counter for these? */
 2043700:	00809934 	movhi	r2,612
 2043704:	10b7d304 	addi	r2,r2,-8372
 2043708:	10800a17 	ldw	r2,40(r2)
 204370c:	10c00044 	addi	r3,r2,1
 2043710:	00809934 	movhi	r2,612
 2043714:	10b7d304 	addi	r2,r2,-8372
 2043718:	10c00a15 	stw	r3,40(r2)
#ifdef FULL_ICMP
            icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, (TIMEX <<8), p->net);
 204371c:	e0bff817 	ldw	r2,-32(fp)
 2043720:	10c00317 	ldw	r3,12(r2)
 2043724:	e0bfff17 	ldw	r2,-4(fp)
 2043728:	10800617 	ldw	r2,24(r2)
 204372c:	10800a17 	ldw	r2,40(r2)
 2043730:	e13fff17 	ldw	r4,-4(fp)
 2043734:	21000617 	ldw	r4,24(r4)
 2043738:	d9000015 	stw	r4,0(sp)
 204373c:	1809883a 	mov	r4,r3
 2043740:	100b883a 	mov	r5,r2
 2043744:	e1bff817 	ldw	r6,-32(fp)
 2043748:	01c2c004 	movi	r7,2816
 204374c:	204b5140 	call	204b514 <icmp_destun>
#endif   /* FULL_ICMP */
            LOCK_NET_RESOURCE(FREEQ_RESID);
 2043750:	01000084 	movi	r4,2
 2043754:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(p);
 2043758:	e13fff17 	ldw	r4,-4(fp)
 204375c:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2043760:	01000084 	movi	r4,2
 2043764:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 2043768:	00bff7c4 	movi	r2,-33
 204376c:	0000c306 	br	2043a7c <ip_rcv_phase2+0x5c8>
         }

         p->fhost = pip->ip_dest;   /* set packet's target IP in net endian */
 2043770:	e0bff817 	ldw	r2,-32(fp)
 2043774:	10c00417 	ldw	r3,16(r2)
 2043778:	e0bfff17 	ldw	r2,-4(fp)
 204377c:	10c00715 	stw	r3,28(r2)
         if ((outnet = iproute(p->fhost, &firsthop)) == NULL)  /* find route */
 2043780:	e0bfff17 	ldw	r2,-4(fp)
 2043784:	10c00717 	ldw	r3,28(r2)
 2043788:	e0bffe04 	addi	r2,fp,-8
 204378c:	1809883a 	mov	r4,r3
 2043790:	100b883a 	mov	r5,r2
 2043794:	20410e40 	call	20410e4 <iproute>
 2043798:	e0bffb15 	stw	r2,-20(fp)
 204379c:	e0bffb17 	ldw	r2,-20(fp)
 20437a0:	10000f1e 	bne	r2,zero,20437e0 <ip_rcv_phase2+0x32c>
         {
            ip_mib.ipOutNoRoutes++; /* count unroutable pkts */
 20437a4:	00809934 	movhi	r2,612
 20437a8:	10b7d304 	addi	r2,r2,-8372
 20437ac:	10800b17 	ldw	r2,44(r2)
 20437b0:	10c00044 	addi	r3,r2,1
 20437b4:	00809934 	movhi	r2,612
 20437b8:	10b7d304 	addi	r2,r2,-8372
 20437bc:	10c00b15 	stw	r3,44(r2)
            LOCK_NET_RESOURCE(FREEQ_RESID);
 20437c0:	01000084 	movi	r4,2
 20437c4:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
            pk_free(p);
 20437c8:	e13fff17 	ldw	r4,-4(fp)
 20437cc:	20280440 	call	2028044 <pk_free>
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20437d0:	01000084 	movi	r4,2
 20437d4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
            IN_PROFILER(PF_IP, PF_EXIT);
            return ENP_NO_ROUTE;
 20437d8:	00bff7c4 	movi	r2,-33
 20437dc:	0000a706 	br	2043a7c <ip_rcv_phase2+0x5c8>
         /* Check to see if the packet was is addressed to one of our IP
          * addresses other than the interface it was received on. If so,
          * routing should have returned that interface and we can trap this
          * situation by checking the interfaces IP address.
          */
         if(pip->ip_dest == outnet->n_ipaddr)
 20437e0:	e0bff817 	ldw	r2,-32(fp)
 20437e4:	10c00417 	ldw	r3,16(r2)
 20437e8:	e0bffb17 	ldw	r2,-20(fp)
 20437ec:	10800a17 	ldw	r2,40(r2)
 20437f0:	18806326 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 20437f4:	e0bff817 	ldw	r2,-32(fp)
 20437f8:	10c00417 	ldw	r3,16(r2)
 20437fc:	e0bffb17 	ldw	r2,-20(fp)
 2043800:	10800e17 	ldw	r2,56(r2)
 2043804:	18805e26 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
            (pip->ip_dest == p->net->n_netbr))
 2043808:	e0bff817 	ldw	r2,-32(fp)
 204380c:	10c00417 	ldw	r3,16(r2)
 2043810:	e0bfff17 	ldw	r2,-4(fp)
 2043814:	10800617 	ldw	r2,24(r2)
 2043818:	10800e17 	ldw	r2,56(r2)
            goto ours;

         /* Make sure the packet is not a subnet broadcast for either the
          * source or destination network.
          */
         if((pip->ip_dest == outnet->n_netbr) ||
 204381c:	18805826 	beq	r3,r2,2043980 <ip_rcv_phase2+0x4cc>
         {
            goto ours;            
         }

         /* Routed OK, prepare to send */
         p->net = outnet;           /* set iface to send on */
 2043820:	e0bfff17 	ldw	r2,-4(fp)
 2043824:	e0fffb17 	ldw	r3,-20(fp)
 2043828:	10c00615 	stw	r3,24(r2)
            }
         }
#endif   /* IPSEC */

         /* see if packet is too big for media of dest net */
         if ((p->nb_plen + p->net->n_lnh) > (unsigned)outnet->n_mtu)
 204382c:	e0bfff17 	ldw	r2,-4(fp)
 2043830:	10c00417 	ldw	r3,16(r2)
 2043834:	e0bfff17 	ldw	r2,-4(fp)
 2043838:	10800617 	ldw	r2,24(r2)
 204383c:	10800817 	ldw	r2,32(r2)
 2043840:	1885883a 	add	r2,r3,r2
 2043844:	e0fffb17 	ldw	r3,-20(fp)
 2043848:	18c00917 	ldw	r3,36(r3)
 204384c:	1880372e 	bgeu	r3,r2,204392c <ip_rcv_phase2+0x478>
         {
#ifdef IP_FRAGMENTS
            /* see if we're not supposed to fragment it */
            if (ntohs(pip->ip_flgs_foff) & IP_FLG_DF)
 2043850:	e0bff817 	ldw	r2,-32(fp)
 2043854:	1080018b 	ldhu	r2,6(r2)
 2043858:	10bfffcc 	andi	r2,r2,65535
 204385c:	1004d23a 	srli	r2,r2,8
 2043860:	10bfffcc 	andi	r2,r2,65535
 2043864:	10c03fcc 	andi	r3,r2,255
 2043868:	e0bff817 	ldw	r2,-32(fp)
 204386c:	1080018b 	ldhu	r2,6(r2)
 2043870:	10bfffcc 	andi	r2,r2,65535
 2043874:	1004923a 	slli	r2,r2,8
 2043878:	10bfffcc 	andi	r2,r2,65535
 204387c:	1884b03a 	or	r2,r3,r2
 2043880:	1090000c 	andi	r2,r2,16384
 2043884:	10001c26 	beq	r2,zero,20438f8 <ip_rcv_phase2+0x444>
            {
#ifdef FULL_ICMP
               icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTFRAG, p->net);
 2043888:	e0bff817 	ldw	r2,-32(fp)
 204388c:	10c00317 	ldw	r3,12(r2)
 2043890:	e0bfff17 	ldw	r2,-4(fp)
 2043894:	10800617 	ldw	r2,24(r2)
 2043898:	10800a17 	ldw	r2,40(r2)
 204389c:	e13fff17 	ldw	r4,-4(fp)
 20438a0:	21000617 	ldw	r4,24(r4)
 20438a4:	d9000015 	stw	r4,0(sp)
 20438a8:	1809883a 	mov	r4,r3
 20438ac:	100b883a 	mov	r5,r2
 20438b0:	e1bff817 	ldw	r6,-32(fp)
 20438b4:	01c00104 	movi	r7,4
 20438b8:	204b5140 	call	204b514 <icmp_destun>
#endif   /* FULL_ICMP */
               ip_mib.ipFragFails++;
 20438bc:	00809934 	movhi	r2,612
 20438c0:	10b7d304 	addi	r2,r2,-8372
 20438c4:	10801117 	ldw	r2,68(r2)
 20438c8:	10c00044 	addi	r3,r2,1
 20438cc:	00809934 	movhi	r2,612
 20438d0:	10b7d304 	addi	r2,r2,-8372
 20438d4:	10c01115 	stw	r3,68(r2)
               LOCK_NET_RESOURCE(FREEQ_RESID);
 20438d8:	01000084 	movi	r4,2
 20438dc:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
               pk_free(p);
 20438e0:	e13fff17 	ldw	r4,-4(fp)
 20438e4:	20280440 	call	2028044 <pk_free>
               UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20438e8:	01000084 	movi	r4,2
 20438ec:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
               IN_PROFILER(PF_IP, PF_EXIT);
               return ENP_LOGIC;
 20438f0:	00bffd44 	movi	r2,-11
 20438f4:	00006106 	br	2043a7c <ip_rcv_phase2+0x5c8>
            }

            /* fall to here if we're going to fragment it. */
            pip->ip_time--;            /* datagram's hop count */
 20438f8:	e0bff817 	ldw	r2,-32(fp)
 20438fc:	10800203 	ldbu	r2,8(r2)
 2043900:	10bfffc4 	addi	r2,r2,-1
 2043904:	1007883a 	mov	r3,r2
 2043908:	e0bff817 	ldw	r2,-32(fp)
 204390c:	10c00205 	stb	r3,8(r2)
            err = ip_fragment(p, firsthop);
 2043910:	e0bffe17 	ldw	r2,-8(fp)
 2043914:	e13fff17 	ldw	r4,-4(fp)
 2043918:	100b883a 	mov	r5,r2
 204391c:	20407e40 	call	20407e4 <ip_fragment>
 2043920:	e0bffc15 	stw	r2,-16(fp)
            IN_PROFILER(PF_IP, PF_EXIT);
            return(err);
 2043924:	e0bffc17 	ldw	r2,-16(fp)
 2043928:	00005406 	br	2043a7c <ip_rcv_phase2+0x5c8>
            pk_free(p);
            UNLOCK_NET_RESOURCE(FREEQ_RESID);
            return ENP_LOGIC;
#endif   /* IP_FRAGMENTS */
         }
         pip->ip_time--;            /* datagram's hop count */
 204392c:	e0bff817 	ldw	r2,-32(fp)
 2043930:	10800203 	ldbu	r2,8(r2)
 2043934:	10bfffc4 	addi	r2,r2,-1
 2043938:	1007883a 	mov	r3,r2
 204393c:	e0bff817 	ldw	r2,-32(fp)
 2043940:	10c00205 	stb	r3,8(r2)
         pip->ip_chksum = IPXSUM;   /* clear checksum field for summing */
 2043944:	e0bff817 	ldw	r2,-32(fp)
 2043948:	1000028d 	sth	zero,10(r2)
         pip->ip_chksum = ~cksum(pip, 10);   /* new xsum */
 204394c:	e13ff817 	ldw	r4,-32(fp)
 2043950:	01400284 	movi	r5,10
 2043954:	20268040 	call	2026804 <cksum>
 2043958:	0084303a 	nor	r2,zero,r2
 204395c:	1007883a 	mov	r3,r2
 2043960:	e0bff817 	ldw	r2,-32(fp)
 2043964:	10c0028d 	sth	r3,10(r2)
         IN_PROFILER(PF_IP, PF_EXIT);
#ifdef RF_SIMULATION
         if(rfsim_routing)
            return(rfsim_send(p, firsthop));
#endif   /* RF_SIMULATION */
         return(ip2mac(p, firsthop));
 2043968:	e0bffe17 	ldw	r2,-8(fp)
 204396c:	e13fff17 	ldw	r4,-4(fp)
 2043970:	100b883a 	mov	r5,r2
 2043974:	20246400 	call	2024640 <ip2mac>
 2043978:	00004006 	br	2043a7c <ip_rcv_phase2+0x5c8>
         UNLOCK_NET_RESOURCE(FREEQ_RESID);
         IN_PROFILER(PF_IP, PF_EXIT);
         return (ENP_NOT_MINE);
      }
      else
         goto ours;
 204397c:	0001883a 	nop
#if defined (IP_MULTICAST) || defined (IP_ROUTING)
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
 2043980:	e0bff817 	ldw	r2,-32(fp)
 2043984:	1080018b 	ldhu	r2,6(r2)
 2043988:	10bfffcc 	andi	r2,r2,65535
 204398c:	1004d23a 	srli	r2,r2,8
 2043990:	1007883a 	mov	r3,r2
 2043994:	e0bff817 	ldw	r2,-32(fp)
 2043998:	1080018b 	ldhu	r2,6(r2)
 204399c:	10bfffcc 	andi	r2,r2,65535
 20439a0:	1004923a 	slli	r2,r2,8
 20439a4:	1884b03a 	or	r2,r3,r2
 20439a8:	e0bffd0d 	sth	r2,-12(fp)
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 20439ac:	e0bffd0b 	ldhu	r2,-12(fp)
 20439b0:	1088000c 	andi	r2,r2,8192
 20439b4:	1000051e 	bne	r2,zero,20439cc <ip_rcv_phase2+0x518>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
 20439b8:	e0fffd0b 	ldhu	r3,-12(fp)
 20439bc:	00bffff4 	movhi	r2,65535
 20439c0:	1087ffc4 	addi	r2,r2,8191
 20439c4:	1884703a 	and	r2,r3,r2
ours:
#endif

   /* Test for fragment: */
   tempsum = htons(pip->ip_flgs_foff); /* borrow cksum variable */
   if ((tempsum & IP_FLG_MF) ||  /* IP flag for "More Fragments" set? */
 20439c8:	10002a26 	beq	r2,zero,2043a74 <ip_rcv_phase2+0x5c0>
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 20439cc:	00808174 	movhi	r2,517
 20439d0:	1090b204 	addi	r2,r2,17096
 20439d4:	10800017 	ldw	r2,0(r2)
 20439d8:	1081000c 	andi	r2,r2,1024
 20439dc:	10001b26 	beq	r2,zero,2043a4c <ip_rcv_phase2+0x598>
 20439e0:	00808174 	movhi	r2,517
 20439e4:	1090b204 	addi	r2,r2,17096
 20439e8:	10800017 	ldw	r2,0(r2)
 20439ec:	1080800c 	andi	r2,r2,512
 20439f0:	10001626 	beq	r2,zero,2043a4c <ip_rcv_phase2+0x598>
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
          PUSH_IPADDR(pip->ip_src));
 20439f4:	e0bff817 	ldw	r2,-32(fp)
 20439f8:	10800317 	ldw	r2,12(r2)
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 20439fc:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(pip->ip_src));
 2043a00:	e0bff817 	ldw	r2,-32(fp)
 2043a04:	10800317 	ldw	r2,12(r2)
 2043a08:	1004d23a 	srli	r2,r2,8
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 2043a0c:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pip->ip_src));
 2043a10:	e0bff817 	ldw	r2,-32(fp)
 2043a14:	10800317 	ldw	r2,12(r2)
 2043a18:	1004d43a 	srli	r2,r2,16
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 2043a1c:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pip->ip_src));
 2043a20:	e13ff817 	ldw	r4,-32(fp)
 2043a24:	21000317 	ldw	r4,12(r4)
 2043a28:	2008d63a 	srli	r4,r4,24
       (tempsum & ~IP_FLG_MASK))  /* or offset to last frag? */
   {
#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
      {
         dprintf("ip_rcv: fragment from %u.%u.%u.%u\n", 
 2043a2c:	d9000015 	stw	r4,0(sp)
 2043a30:	01008174 	movhi	r4,517
 2043a34:	21062504 	addi	r4,r4,6292
 2043a38:	180d883a 	mov	r6,r3
 2043a3c:	100f883a 	mov	r7,r2
 2043a40:	2006a240 	call	2006a24 <printf>
          PUSH_IPADDR(pip->ip_src));
         ip_dump(p);
 2043a44:	e13fff17 	ldw	r4,-4(fp)
 2043a48:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif
      ip_mib.ipReasmReqds++;     /* got a reassemble request; ie a frag */
 2043a4c:	00809934 	movhi	r2,612
 2043a50:	10b7d304 	addi	r2,r2,-8372
 2043a54:	10800d17 	ldw	r2,52(r2)
 2043a58:	10c00044 	addi	r3,r2,1
 2043a5c:	00809934 	movhi	r2,612
 2043a60:	10b7d304 	addi	r2,r2,-8372
 2043a64:	10c00d15 	stw	r3,52(r2)
#ifdef IP_FRAGMENTS
      return(ip_reassm(p));
 2043a68:	e13fff17 	ldw	r4,-4(fp)
 2043a6c:	2041a4c0 	call	2041a4c <ip_reassm>
 2043a70:	00000206 	br	2043a7c <ip_rcv_phase2+0x5c8>
   {
      return ENP_LOGIC;
   }
#endif /* IPSEC */

   return(ip_demux(p));    /* demux to correct to upper layer */
 2043a74:	e13fff17 	ldw	r4,-4(fp)
 2043a78:	2043a900 	call	2043a90 <ip_demux>
}
 2043a7c:	e037883a 	mov	sp,fp
 2043a80:	dfc00117 	ldw	ra,4(sp)
 2043a84:	df000017 	ldw	fp,0(sp)
 2043a88:	dec00204 	addi	sp,sp,8
 2043a8c:	f800283a 	ret

02043a90 <ip_demux>:
 * RETURNS: Same return values as ip_rcv(). 
 */

int
ip_demux(PACKET p)
{
 2043a90:	defff904 	addi	sp,sp,-28
 2043a94:	dfc00615 	stw	ra,24(sp)
 2043a98:	df000515 	stw	fp,20(sp)
 2043a9c:	df000504 	addi	fp,sp,20
 2043aa0:	e13fff15 	stw	r4,-4(fp)
   int   err;

   /* The packet is verified; the header is correct. Now we have
    * to demultiplex it among our internet connections.
    */
   pip = (struct ip *)(p->nb_prot);
 2043aa4:	e0bfff17 	ldw	r2,-4(fp)
 2043aa8:	10800317 	ldw	r2,12(r2)
 2043aac:	e0bffe15 	stw	r2,-8(fp)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
 2043ab0:	e0bffe17 	ldw	r2,-8(fp)
 2043ab4:	10800003 	ldbu	r2,0(r2)
 2043ab8:	10803fcc 	andi	r2,r2,255
 2043abc:	10801160 	cmpeqi	r2,r2,69
 2043ac0:	1000131e 	bne	r2,zero,2043b10 <ip_demux+0x80>
   {
      if((pip->ip_ver_ihl < 0x45) ||
 2043ac4:	e0bffe17 	ldw	r2,-8(fp)
 2043ac8:	10800003 	ldbu	r2,0(r2)
 2043acc:	10803fcc 	andi	r2,r2,255
 2043ad0:	10801170 	cmpltui	r2,r2,69
 2043ad4:	1000051e 	bne	r2,zero,2043aec <ip_demux+0x5c>
         (pip->ip_ver_ihl > 0x47))
 2043ad8:	e0bffe17 	ldw	r2,-8(fp)
 2043adc:	10800003 	ldbu	r2,0(r2)

#ifdef NPDEBUG
   /* make sure the caller set p->nb_prot */
   if(pip->ip_ver_ihl != 0x45)
   {
      if((pip->ip_ver_ihl < 0x45) ||
 2043ae0:	10803fcc 	andi	r2,r2,255
 2043ae4:	10801230 	cmpltui	r2,r2,72
 2043ae8:	1000091e 	bne	r2,zero,2043b10 <ip_demux+0x80>
         (pip->ip_ver_ihl > 0x47))
      {
         dprintf("ip_demux: bad IP type 0x%x\n", pip->ip_ver_ihl);
 2043aec:	e0bffe17 	ldw	r2,-8(fp)
 2043af0:	10800003 	ldbu	r2,0(r2)
 2043af4:	10803fcc 	andi	r2,r2,255
 2043af8:	01008174 	movhi	r4,517
 2043afc:	21062e04 	addi	r4,r4,6328
 2043b00:	100b883a 	mov	r5,r2
 2043b04:	2006a240 	call	2006a24 <printf>
         return ENP_LOGIC;
 2043b08:	00bffd44 	movi	r2,-11
 2043b0c:	0000db06 	br	2043e7c <ip_demux+0x3ec>

   /* for profiling purposes count the upper layers (UDP, ICMP) in the IP
    * profile bucket. TCP will insert it's own nested profile calls 
    */
   IN_PROFILER(PF_IP, PF_ENTRY);
   p->fhost = pip->ip_src;
 2043b10:	e0bffe17 	ldw	r2,-8(fp)
 2043b14:	10c00317 	ldw	r3,12(r2)
 2043b18:	e0bfff17 	ldw	r2,-4(fp)
 2043b1c:	10c00715 	stw	r3,28(r2)

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 2043b20:	00808174 	movhi	r2,517
 2043b24:	1090b204 	addi	r2,r2,17096
 2043b28:	10800017 	ldw	r2,0(r2)
 2043b2c:	1081000c 	andi	r2,r2,1024
 2043b30:	10002426 	beq	r2,zero,2043bc4 <ip_demux+0x134>
 2043b34:	00808174 	movhi	r2,517
 2043b38:	1090b204 	addi	r2,r2,17096
 2043b3c:	10800017 	ldw	r2,0(r2)
 2043b40:	1080800c 	andi	r2,r2,512
 2043b44:	10001f26 	beq	r2,zero,2043bc4 <ip_demux+0x134>
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 2043b48:	e0bffe17 	ldw	r2,-8(fp)
 2043b4c:	10800243 	ldbu	r2,9(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 2043b50:	11403fcc 	andi	r5,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 2043b54:	e0bffe17 	ldw	r2,-8(fp)
 2043b58:	10800317 	ldw	r2,12(r2)
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 2043b5c:	10c03fcc 	andi	r3,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 2043b60:	e0bffe17 	ldw	r2,-8(fp)
 2043b64:	10800317 	ldw	r2,12(r2)
 2043b68:	1004d23a 	srli	r2,r2,8
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 2043b6c:	10803fcc 	andi	r2,r2,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 2043b70:	e13ffe17 	ldw	r4,-8(fp)
 2043b74:	21000317 	ldw	r4,12(r4)
 2043b78:	2008d43a 	srli	r4,r4,16
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 2043b7c:	21803fcc 	andi	r6,r4,255
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
 2043b80:	e13ffe17 	ldw	r4,-8(fp)
 2043b84:	21000317 	ldw	r4,12(r4)
 2043b88:	2008d63a 	srli	r4,r4,24
   p->fhost = pip->ip_src;

#ifdef NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
   {
      dprintf("ip_demux: pkt prot %u from %u.%u.%u.%u\n",
 2043b8c:	d9800015 	stw	r6,0(sp)
 2043b90:	d9000115 	stw	r4,4(sp)
 2043b94:	01008174 	movhi	r4,517
 2043b98:	21063504 	addi	r4,r4,6356
 2043b9c:	180d883a 	mov	r6,r3
 2043ba0:	100f883a 	mov	r7,r2
 2043ba4:	2006a240 	call	2006a24 <printf>
       pip->ip_prot, PUSH_IPADDR(pip->ip_src));
      if (NDEBUG & DUMP) ip_dump(p);
 2043ba8:	00808174 	movhi	r2,517
 2043bac:	1090b204 	addi	r2,r2,17096
 2043bb0:	10800017 	ldw	r2,0(r2)
 2043bb4:	1080008c 	andi	r2,r2,2
 2043bb8:	10000226 	beq	r2,zero,2043bc4 <ip_demux+0x134>
 2043bbc:	e13fff17 	ldw	r4,-4(fp)
 2043bc0:	2040e3c0 	call	2040e3c <ip_dump>
   }
#endif

   switch (pip->ip_prot)
 2043bc4:	e0bffe17 	ldw	r2,-8(fp)
 2043bc8:	10800243 	ldbu	r2,9(r2)
 2043bcc:	10803fcc 	andi	r2,r2,255
 2043bd0:	10c000a0 	cmpeqi	r3,r2,2
 2043bd4:	18001f1e 	bne	r3,zero,2043c54 <ip_demux+0x1c4>
 2043bd8:	10c000c8 	cmpgei	r3,r2,3
 2043bdc:	1800031e 	bne	r3,zero,2043bec <ip_demux+0x15c>
 2043be0:	10800060 	cmpeqi	r2,r2,1
 2043be4:	1000101e 	bne	r2,zero,2043c28 <ip_demux+0x198>
 2043be8:	00003006 	br	2043cac <ip_demux+0x21c>
 2043bec:	10c001a0 	cmpeqi	r3,r2,6
 2043bf0:	1800231e 	bne	r3,zero,2043c80 <ip_demux+0x1f0>
 2043bf4:	10800460 	cmpeqi	r2,r2,17
 2043bf8:	10002c26 	beq	r2,zero,2043cac <ip_demux+0x21c>
   {
   case UDP_PROT:
      ip_mib.ipInDelivers++;
 2043bfc:	00809934 	movhi	r2,612
 2043c00:	10b7d304 	addi	r2,r2,-8372
 2043c04:	10800817 	ldw	r2,32(r2)
 2043c08:	10c00044 	addi	r3,r2,1
 2043c0c:	00809934 	movhi	r2,612
 2043c10:	10b7d304 	addi	r2,r2,-8372
 2043c14:	10c00815 	stw	r3,32(r2)
      err = udpdemux(p);
 2043c18:	e13fff17 	ldw	r4,-4(fp)
 2043c1c:	2044dcc0 	call	2044dcc <udpdemux>
 2043c20:	e0bffd15 	stw	r2,-12(fp)
      break;
 2043c24:	00002c06 	br	2043cd8 <ip_demux+0x248>
   case ICMP_PROT:
      ip_mib.ipInDelivers++;
 2043c28:	00809934 	movhi	r2,612
 2043c2c:	10b7d304 	addi	r2,r2,-8372
 2043c30:	10800817 	ldw	r2,32(r2)
 2043c34:	10c00044 	addi	r3,r2,1
 2043c38:	00809934 	movhi	r2,612
 2043c3c:	10b7d304 	addi	r2,r2,-8372
 2043c40:	10c00815 	stw	r3,32(r2)
      err = icmprcv(p);
 2043c44:	e13fff17 	ldw	r4,-4(fp)
 2043c48:	204a92c0 	call	204a92c <icmprcv>
 2043c4c:	e0bffd15 	stw	r2,-12(fp)
      break;
 2043c50:	00002106 	br	2043cd8 <ip_demux+0x248>
#if defined (IP_MULTICAST) && (defined (IGMP_V1) || defined (IGMP_V2))
   case IGMP_PROT:
      ip_mib.ipInDelivers++;
 2043c54:	00809934 	movhi	r2,612
 2043c58:	10b7d304 	addi	r2,r2,-8372
 2043c5c:	10800817 	ldw	r2,32(r2)
 2043c60:	10c00044 	addi	r3,r2,1
 2043c64:	00809934 	movhi	r2,612
 2043c68:	10b7d304 	addi	r2,r2,-8372
 2043c6c:	10c00815 	stw	r3,32(r2)
      err = igmp_input(p);
 2043c70:	e13fff17 	ldw	r4,-4(fp)
 2043c74:	2024d200 	call	2024d20 <igmp_input>
 2043c78:	e0bffd15 	stw	r2,-12(fp)
      break;
 2043c7c:	00001606 	br	2043cd8 <ip_demux+0x248>
#endif   /* IP_MULTICAST and (IGMPv1 or IGMPv2) */
#ifdef INCLUDE_TCP
   case TCP_PROT:
      ip_mib.ipInDelivers++;
 2043c80:	00809934 	movhi	r2,612
 2043c84:	10b7d304 	addi	r2,r2,-8372
 2043c88:	10800817 	ldw	r2,32(r2)
 2043c8c:	10c00044 	addi	r3,r2,1
 2043c90:	00809934 	movhi	r2,612
 2043c94:	10b7d304 	addi	r2,r2,-8372
 2043c98:	10c00815 	stw	r3,32(r2)
      err = tcp_rcv(p);
 2043c9c:	e13fff17 	ldw	r4,-4(fp)
 2043ca0:	2029e580 	call	2029e58 <tcp_rcv>
 2043ca4:	e0bffd15 	stw	r2,-12(fp)
      break;
 2043ca8:	00000b06 	br	2043cd8 <ip_demux+0x248>
      err = v6t_rcv(p);
      break;
#endif /* IPV6_TUNNEL */
   default: /* unknown upper protocol */
#ifdef IP_RAW
      ip_mib.ipInDelivers++;
 2043cac:	00809934 	movhi	r2,612
 2043cb0:	10b7d304 	addi	r2,r2,-8372
 2043cb4:	10800817 	ldw	r2,32(r2)
 2043cb8:	10c00044 	addi	r3,r2,1
 2043cbc:	00809934 	movhi	r2,612
 2043cc0:	10b7d304 	addi	r2,r2,-8372
 2043cc4:	10c00815 	stw	r3,32(r2)
      err = ip_raw_input(p);
 2043cc8:	e13fff17 	ldw	r4,-4(fp)
 2043ccc:	20443bc0 	call	20443bc <ip_raw_input>
 2043cd0:	e0bffd15 	stw	r2,-12(fp)
      break;
 2043cd4:	0001883a 	nop
#endif /* IP_RAW */
   }

   IN_PROFILER(PF_IP, PF_EXIT);

   if(err != ENP_PARAM)
 2043cd8:	e0bffd17 	ldw	r2,-12(fp)
 2043cdc:	10bffda0 	cmpeqi	r2,r2,-10
 2043ce0:	1000021e 	bne	r2,zero,2043cec <ip_demux+0x25c>
   {
      return err;
 2043ce4:	e0bffd17 	ldw	r2,-12(fp)
 2043ce8:	00006406 	br	2043e7c <ip_demux+0x3ec>

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 2043cec:	e0bffe17 	ldw	r2,-8(fp)
 2043cf0:	10800417 	ldw	r2,16(r2)
 2043cf4:	10bfffe0 	cmpeqi	r2,r2,-1
 2043cf8:	1000521e 	bne	r2,zero,2043e44 <ip_demux+0x3b4>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 2043cfc:	e0bffe17 	ldw	r2,-8(fp)
 2043d00:	10800417 	ldw	r2,16(r2)
 2043d04:	1006d63a 	srli	r3,r2,24
 2043d08:	e0bffe17 	ldw	r2,-8(fp)
 2043d0c:	10800417 	ldw	r2,16(r2)
 2043d10:	1004d23a 	srli	r2,r2,8
 2043d14:	10bfc00c 	andi	r2,r2,65280
 2043d18:	1886b03a 	or	r3,r3,r2
 2043d1c:	e0bffe17 	ldw	r2,-8(fp)
 2043d20:	10800417 	ldw	r2,16(r2)
 2043d24:	10bfc00c 	andi	r2,r2,65280
 2043d28:	1004923a 	slli	r2,r2,8
 2043d2c:	1886b03a 	or	r3,r3,r2
 2043d30:	e0bffe17 	ldw	r2,-8(fp)
 2043d34:	10800417 	ldw	r2,16(r2)
 2043d38:	1004963a 	slli	r2,r2,24
 2043d3c:	1884b03a 	or	r2,r3,r2
 2043d40:	10fc002c 	andhi	r3,r2,61440

#ifdef FULL_ICMP
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
 2043d44:	00b80034 	movhi	r2,57344
 2043d48:	18803e26 	beq	r3,r2,2043e44 <ip_demux+0x3b4>
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 2043d4c:	e0bffe17 	ldw	r2,-8(fp)
 2043d50:	10c00417 	ldw	r3,16(r2)
 2043d54:	e0bfff17 	ldw	r2,-4(fp)
 2043d58:	10800617 	ldw	r2,24(r2)
 2043d5c:	10800e17 	ldw	r2,56(r2)
   /* nobody's listening for this packet. Unless it was broadcast or 
    * multicast, send a destination unreachable. 
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
 2043d60:	18803826 	beq	r3,r2,2043e44 <ip_demux+0x3b4>
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 2043d64:	e0bffe17 	ldw	r2,-8(fp)
 2043d68:	10c00417 	ldw	r3,16(r2)
 2043d6c:	e0bfff17 	ldw	r2,-4(fp)
 2043d70:	10800617 	ldw	r2,24(r2)
 2043d74:	10800f17 	ldw	r2,60(r2)
    */
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
 2043d78:	18803226 	beq	r3,r2,2043e44 <ip_demux+0x3b4>
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 2043d7c:	e0bffe17 	ldw	r2,-8(fp)
 2043d80:	10c00417 	ldw	r3,16(r2)
 2043d84:	e0bfff17 	ldw	r2,-4(fp)
 2043d88:	10800617 	ldw	r2,24(r2)
 2043d8c:	10801017 	ldw	r2,64(r2)
   if ((pip->ip_dest != 0xffffffffL) &&   /* Physical cable broadcast addr*/
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
 2043d90:	18802c26 	beq	r3,r2,2043e44 <ip_demux+0x3b4>
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
 2043d94:	e0bfff17 	ldw	r2,-4(fp)
 2043d98:	10800617 	ldw	r2,24(r2)
 2043d9c:	10c00a17 	ldw	r3,40(r2)
 2043da0:	e0bfff17 	ldw	r2,-4(fp)
 2043da4:	10800617 	ldw	r2,24(r2)
 2043da8:	10801017 	ldw	r2,64(r2)
#ifdef IP_MULTICAST
       (!(IN_MULTICAST(ntohl(pip->ip_dest)))) && /* multicast address */
#endif /* IP_MULTICAST */
       (pip->ip_dest != p->net->n_netbr) &&   /* All subnet broadcast */
       (pip->ip_dest != p->net->n_netbr42) && /* All subnet bcast (4.2bsd) */
       (pip->ip_dest != p->net->n_subnetbr) &&   /* Our subnet broadcast */
 2043dac:	18802526 	beq	r3,r2,2043e44 <ip_demux+0x3b4>
       (p->net->n_ipaddr ^ p->net->n_subnetbr))  /* Know our own host address? */
   {

#ifdef NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 2043db0:	00808174 	movhi	r2,517
 2043db4:	1090b204 	addi	r2,r2,17096
 2043db8:	10800017 	ldw	r2,0(r2)
 2043dbc:	1081000c 	andi	r2,r2,1024
 2043dc0:	10001326 	beq	r2,zero,2043e10 <ip_demux+0x380>
 2043dc4:	00808174 	movhi	r2,517
 2043dc8:	1090b204 	addi	r2,r2,17096
 2043dcc:	10800017 	ldw	r2,0(r2)
 2043dd0:	1080800c 	andi	r2,r2,512
 2043dd4:	10000e26 	beq	r2,zero,2043e10 <ip_demux+0x380>
      {
         dprintf("ip_demux: unhandled prot %u\n", pip->ip_prot);
 2043dd8:	e0bffe17 	ldw	r2,-8(fp)
 2043ddc:	10800243 	ldbu	r2,9(r2)
 2043de0:	10803fcc 	andi	r2,r2,255
 2043de4:	01008174 	movhi	r4,517
 2043de8:	21063f04 	addi	r4,r4,6396
 2043dec:	100b883a 	mov	r5,r2
 2043df0:	2006a240 	call	2006a24 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 2043df4:	00808174 	movhi	r2,517
 2043df8:	1090b204 	addi	r2,r2,17096
 2043dfc:	10800017 	ldw	r2,0(r2)
 2043e00:	1080008c 	andi	r2,r2,2
 2043e04:	10000226 	beq	r2,zero,2043e10 <ip_demux+0x380>
 2043e08:	e13fff17 	ldw	r4,-4(fp)
 2043e0c:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif   /* NPDEBUG */
      icmp_destun(pip->ip_src, p->net->n_ipaddr, pip, DSTPROT, p->net);
 2043e10:	e0bffe17 	ldw	r2,-8(fp)
 2043e14:	10c00317 	ldw	r3,12(r2)
 2043e18:	e0bfff17 	ldw	r2,-4(fp)
 2043e1c:	10800617 	ldw	r2,24(r2)
 2043e20:	10800a17 	ldw	r2,40(r2)
 2043e24:	e13fff17 	ldw	r4,-4(fp)
 2043e28:	21000617 	ldw	r4,24(r4)
 2043e2c:	d9000015 	stw	r4,0(sp)
 2043e30:	1809883a 	mov	r4,r3
 2043e34:	100b883a 	mov	r5,r2
 2043e38:	e1bffe17 	ldw	r6,-8(fp)
 2043e3c:	01c00084 	movi	r7,2
 2043e40:	204b5140 	call	204b514 <icmp_destun>
   }
#endif   /* FULL_ICMP */

   ip_mib.ipUnknownProtos++;
 2043e44:	00809934 	movhi	r2,612
 2043e48:	10b7d304 	addi	r2,r2,-8372
 2043e4c:	10800617 	ldw	r2,24(r2)
 2043e50:	10c00044 	addi	r3,r2,1
 2043e54:	00809934 	movhi	r2,612
 2043e58:	10b7d304 	addi	r2,r2,-8372
 2043e5c:	10c00615 	stw	r3,24(r2)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2043e60:	01000084 	movi	r4,2
 2043e64:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 2043e68:	e13fff17 	ldw	r4,-4(fp)
 2043e6c:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2043e70:	01000084 	movi	r4,2
 2043e74:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return ENP_NOT_MINE;
 2043e78:	00800084 	movi	r2,2
}
 2043e7c:	e037883a 	mov	sp,fp
 2043e80:	dfc00117 	ldw	ra,4(sp)
 2043e84:	df000017 	ldw	fp,0(sp)
 2043e88:	dec00204 	addi	sp,sp,8
 2043e8c:	f800283a 	ret

02043e90 <in_addmulti>:
 * RETURNS: 
 */

struct in_multi * 
in_addmulti(ip_addr *ap, struct net *netp, int addrtype)
{
 2043e90:	defff904 	addi	sp,sp,-28
 2043e94:	dfc00615 	stw	ra,24(sp)
 2043e98:	df000515 	stw	fp,20(sp)
 2043e9c:	df000504 	addi	fp,sp,20
 2043ea0:	e13ffd15 	stw	r4,-12(fp)
 2043ea4:	e17ffe15 	stw	r5,-8(fp)
 2043ea8:	e1bfff15 	stw	r6,-4(fp)
   struct in_multi *inm = (struct in_multi *)NULL;
 2043eac:	e03ffb15 	stw	zero,-20(fp)
   int error;

   /* check for good addr. */
   if ((ap == (ip_addr *)NULL) || (*ap == 0))
 2043eb0:	e0bffd17 	ldw	r2,-12(fp)
 2043eb4:	10000326 	beq	r2,zero,2043ec4 <in_addmulti+0x34>
 2043eb8:	e0bffd17 	ldw	r2,-12(fp)
 2043ebc:	10800017 	ldw	r2,0(r2)
 2043ec0:	1000021e 	bne	r2,zero,2043ecc <in_addmulti+0x3c>
      return ((struct in_multi *)NULL);  
 2043ec4:	0005883a 	mov	r2,zero
 2043ec8:	00003f06 	br	2043fc8 <in_addmulti+0x138>

   ENTER_CRIT_SECTION(netp);
 2043ecc:	20287fc0 	call	20287fc <irq_Mask>
#ifdef IP_V6
   if(addrtype == 6)
      inm = v6_lookup_mcast((ip6_addr*)ap, netp);
#endif
#ifdef IP_V4
   if(addrtype != 6)
 2043ed0:	e0bfff17 	ldw	r2,-4(fp)
 2043ed4:	108001a0 	cmpeqi	r2,r2,6
 2043ed8:	1000061e 	bne	r2,zero,2043ef4 <in_addmulti+0x64>
      inm = lookup_mcast(*ap, netp);
 2043edc:	e0bffd17 	ldw	r2,-12(fp)
 2043ee0:	10800017 	ldw	r2,0(r2)
 2043ee4:	1009883a 	mov	r4,r2
 2043ee8:	e17ffe17 	ldw	r5,-8(fp)
 2043eec:	20440e40 	call	20440e4 <lookup_mcast>
 2043ef0:	e0bffb15 	stw	r2,-20(fp)
#endif

   if (inm != (struct in_multi *)NULL) 
 2043ef4:	e0bffb17 	ldw	r2,-20(fp)
 2043ef8:	10000626 	beq	r2,zero,2043f14 <in_addmulti+0x84>
   {
      /* Found it; just increment the reference count. */
      ++inm->inm_refcount;
 2043efc:	e0bffb17 	ldw	r2,-20(fp)
 2043f00:	10800217 	ldw	r2,8(r2)
 2043f04:	10c00044 	addi	r3,r2,1
 2043f08:	e0bffb17 	ldw	r2,-20(fp)
 2043f0c:	10c00215 	stw	r3,8(r2)
 2043f10:	00002b06 	br	2043fc0 <in_addmulti+0x130>
   {
      /*
       * New address; allocate a new multicast record
       * and link it into the interface's multicast list.
       */
      inm = (struct in_multi *)INM_ALLOC(sizeof(*inm));
 2043f14:	01000604 	movi	r4,24
 2043f18:	20290400 	call	2029040 <npalloc>
 2043f1c:	e0bffb15 	stw	r2,-20(fp)

      if (inm == (struct in_multi *)NULL) 
 2043f20:	e0bffb17 	ldw	r2,-20(fp)
 2043f24:	1000031e 	bne	r2,zero,2043f34 <in_addmulti+0xa4>
      {
         EXIT_CRIT_SECTION(netp);
 2043f28:	20288580 	call	2028858 <irq_Unmask>
         return ((struct in_multi *)NULL);
 2043f2c:	0005883a 	mov	r2,zero
 2043f30:	00002506 	br	2043fc8 <in_addmulti+0x138>
#ifdef IP_V6
      if(addrtype == 6)
         IP6CPY(&inm->ip6addr, (struct in6_addr *)ap);
#endif
#ifdef IP_V4
      if(addrtype != 6)
 2043f34:	e0bfff17 	ldw	r2,-4(fp)
 2043f38:	108001a0 	cmpeqi	r2,r2,6
 2043f3c:	1000041e 	bne	r2,zero,2043f50 <in_addmulti+0xc0>
         inm->inm_addr = *ap;
 2043f40:	e0bffd17 	ldw	r2,-12(fp)
 2043f44:	10c00017 	ldw	r3,0(r2)
 2043f48:	e0bffb17 	ldw	r2,-20(fp)
 2043f4c:	10c00015 	stw	r3,0(r2)
#endif
      inm->inm_netp = netp;
 2043f50:	e0bffb17 	ldw	r2,-20(fp)
 2043f54:	e0fffe17 	ldw	r3,-8(fp)
 2043f58:	10c00115 	stw	r3,4(r2)
      inm->inm_refcount = 1;
 2043f5c:	e0bffb17 	ldw	r2,-20(fp)
 2043f60:	00c00044 	movi	r3,1
 2043f64:	10c00215 	stw	r3,8(r2)
      inm->inm_next = netp->mc_list;
 2043f68:	e0bffe17 	ldw	r2,-8(fp)
 2043f6c:	10c02c17 	ldw	r3,176(r2)
 2043f70:	e0bffb17 	ldw	r2,-20(fp)
 2043f74:	10c00515 	stw	r3,20(r2)
      netp->mc_list = inm;
 2043f78:	e0bffe17 	ldw	r2,-8(fp)
 2043f7c:	e0fffb17 	ldw	r3,-20(fp)
 2043f80:	10c02c15 	stw	r3,176(r2)
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the new address.
       */
      if(netp->n_mcastlist)
 2043f84:	e0bffe17 	ldw	r2,-8(fp)
 2043f88:	10802b17 	ldw	r2,172(r2)
 2043f8c:	10000626 	beq	r2,zero,2043fa8 <in_addmulti+0x118>
         error = netp->n_mcastlist(inm);
 2043f90:	e0bffe17 	ldw	r2,-8(fp)
 2043f94:	10802b17 	ldw	r2,172(r2)
 2043f98:	e13ffb17 	ldw	r4,-20(fp)
 2043f9c:	103ee83a 	callr	r2
 2043fa0:	e0bffc15 	stw	r2,-16(fp)
 2043fa4:	00000106 	br	2043fac <in_addmulti+0x11c>
      else
         error = 0;
 2043fa8:	e03ffc15 	stw	zero,-16(fp)
#if defined (IGMP_V1) || defined (IGMP_V2)
      /*
       * Let IGMP know that we have joined a new IP multicast group.
       */
      if (inm->inm_addr) igmp_joingroup(inm);
 2043fac:	e0bffb17 	ldw	r2,-20(fp)
 2043fb0:	10800017 	ldw	r2,0(r2)
 2043fb4:	10000226 	beq	r2,zero,2043fc0 <in_addmulti+0x130>
 2043fb8:	e13ffb17 	ldw	r4,-20(fp)
 2043fbc:	20252cc0 	call	20252cc <igmp_joingroup>
#endif      
   }

   EXIT_CRIT_SECTION(netp);
 2043fc0:	20288580 	call	2028858 <irq_Unmask>
   USE_ARG(error);

   return (inm);
 2043fc4:	e0bffb17 	ldw	r2,-20(fp)
}
 2043fc8:	e037883a 	mov	sp,fp
 2043fcc:	dfc00117 	ldw	ra,4(sp)
 2043fd0:	df000017 	ldw	fp,0(sp)
 2043fd4:	dec00204 	addi	sp,sp,8
 2043fd8:	f800283a 	ret

02043fdc <in_delmulti>:
 * RETURNS: 
 */

void
in_delmulti(struct in_multi * inm)
{
 2043fdc:	defffa04 	addi	sp,sp,-24
 2043fe0:	dfc00515 	stw	ra,20(sp)
 2043fe4:	df000415 	stw	fp,16(sp)
 2043fe8:	df000404 	addi	fp,sp,16
 2043fec:	e13fff15 	stw	r4,-4(fp)
   struct in_multi * p;
   NET         netp = inm->inm_netp;
 2043ff0:	e0bfff17 	ldw	r2,-4(fp)
 2043ff4:	10800117 	ldw	r2,4(r2)
 2043ff8:	e0bffd15 	stw	r2,-12(fp)
   int error;

   ENTER_CRIT_SECTION(inm);
 2043ffc:	20287fc0 	call	20287fc <irq_Mask>
   if (--inm->inm_refcount == 0) 
 2044000:	e0bfff17 	ldw	r2,-4(fp)
 2044004:	10800217 	ldw	r2,8(r2)
 2044008:	10ffffc4 	addi	r3,r2,-1
 204400c:	e0bfff17 	ldw	r2,-4(fp)
 2044010:	10c00215 	stw	r3,8(r2)
 2044014:	e0bfff17 	ldw	r2,-4(fp)
 2044018:	10800217 	ldw	r2,8(r2)
 204401c:	10002b1e 	bne	r2,zero,20440cc <in_delmulti+0xf0>
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 2044020:	e0bffd17 	ldw	r2,-12(fp)
 2044024:	10802c17 	ldw	r2,176(r2)
 2044028:	e0bffc15 	stw	r2,-16(fp)
 204402c:	00001406 	br	2044080 <in_delmulti+0xa4>
      {
         if(p == inm)   /* inm is first in mc_list */
 2044030:	e0fffc17 	ldw	r3,-16(fp)
 2044034:	e0bfff17 	ldw	r2,-4(fp)
 2044038:	1880051e 	bne	r3,r2,2044050 <in_delmulti+0x74>
         {
            netp->mc_list = p->inm_next;  /* unlink */
 204403c:	e0bffc17 	ldw	r2,-16(fp)
 2044040:	10c00517 	ldw	r3,20(r2)
 2044044:	e0bffd17 	ldw	r2,-12(fp)
 2044048:	10c02c15 	stw	r3,176(r2)
            break;
 204404c:	00000e06 	br	2044088 <in_delmulti+0xac>
         }
         else if(p->inm_next == inm)   /* inm is next */
 2044050:	e0bffc17 	ldw	r2,-16(fp)
 2044054:	10c00517 	ldw	r3,20(r2)
 2044058:	e0bfff17 	ldw	r2,-4(fp)
 204405c:	1880051e 	bne	r3,r2,2044074 <in_delmulti+0x98>
         {
            p->inm_next = inm->inm_next;  /* unlink */
 2044060:	e0bfff17 	ldw	r2,-4(fp)
 2044064:	10c00517 	ldw	r3,20(r2)
 2044068:	e0bffc17 	ldw	r2,-16(fp)
 204406c:	10c00515 	stw	r3,20(r2)
            break;
 2044070:	00000506 	br	2044088 <in_delmulti+0xac>

   ENTER_CRIT_SECTION(inm);
   if (--inm->inm_refcount == 0) 
   {
      /* Unlink from list.  */
      for (p = netp->mc_list; p; p = p->inm_next)
 2044074:	e0bffc17 	ldw	r2,-16(fp)
 2044078:	10800517 	ldw	r2,20(r2)
 204407c:	e0bffc15 	stw	r2,-16(fp)
 2044080:	e0bffc17 	ldw	r2,-16(fp)
 2044084:	103fea1e 	bne	r2,zero,2044030 <in_delmulti+0x54>
      /*
       * If net has a multicast address registration routine then ask
       * the network driver to update its multicast reception
       * filter appropriately for the deleted address.
       */
      if(netp->n_mcastlist)
 2044088:	e0bffd17 	ldw	r2,-12(fp)
 204408c:	10802b17 	ldw	r2,172(r2)
 2044090:	10000626 	beq	r2,zero,20440ac <in_delmulti+0xd0>
         error = netp->n_mcastlist(inm);
 2044094:	e0bffd17 	ldw	r2,-12(fp)
 2044098:	10802b17 	ldw	r2,172(r2)
 204409c:	e13fff17 	ldw	r4,-4(fp)
 20440a0:	103ee83a 	callr	r2
 20440a4:	e0bffe15 	stw	r2,-8(fp)
 20440a8:	00000106 	br	20440b0 <in_delmulti+0xd4>
      else
         error = 0;
 20440ac:	e03ffe15 	stw	zero,-8(fp)
#if defined (IGMP_V2)
      /*
       * No remaining claims to this record; let IGMP know that
       * we are leaving the multicast group.
       */
      if (inm->inm_addr) igmp_leavegroup(inm);
 20440b0:	e0bfff17 	ldw	r2,-4(fp)
 20440b4:	10800017 	ldw	r2,0(r2)
 20440b8:	10000226 	beq	r2,zero,20440c4 <in_delmulti+0xe8>
 20440bc:	e13fff17 	ldw	r4,-4(fp)
 20440c0:	20255280 	call	2025528 <igmp_leavegroup>
#endif      

      IM_FREE(inm);
 20440c4:	e13fff17 	ldw	r4,-4(fp)
 20440c8:	202912c0 	call	202912c <npfree>
   }
   EXIT_CRIT_SECTION(inm);
 20440cc:	20288580 	call	2028858 <irq_Unmask>
}
 20440d0:	e037883a 	mov	sp,fp
 20440d4:	dfc00117 	ldw	ra,4(sp)
 20440d8:	df000017 	ldw	fp,0(sp)
 20440dc:	dec00204 	addi	sp,sp,8
 20440e0:	f800283a 	ret

020440e4 <lookup_mcast>:
 * RETURNS: pointer to mcast addr structure, or NULL if not found.
 */

struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
 20440e4:	defffc04 	addi	sp,sp,-16
 20440e8:	df000315 	stw	fp,12(sp)
 20440ec:	df000304 	addi	fp,sp,12
 20440f0:	e13ffe15 	stw	r4,-8(fp)
 20440f4:	e17fff15 	stw	r5,-4(fp)
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 20440f8:	e0bfff17 	ldw	r2,-4(fp)
 20440fc:	10802c17 	ldw	r2,176(r2)
 2044100:	e0bffd15 	stw	r2,-12(fp)
 2044104:	00000906 	br	204412c <lookup_mcast+0x48>
   {
      if(imp->inm_addr == addr)
 2044108:	e0bffd17 	ldw	r2,-12(fp)
 204410c:	10c00017 	ldw	r3,0(r2)
 2044110:	e0bffe17 	ldw	r2,-8(fp)
 2044114:	1880021e 	bne	r3,r2,2044120 <lookup_mcast+0x3c>
         return imp;
 2044118:	e0bffd17 	ldw	r2,-12(fp)
 204411c:	00000606 	br	2044138 <lookup_mcast+0x54>
struct in_multi *
lookup_mcast(ip_addr addr, NET netp)
{
   struct in_multi * imp;

   for (imp = netp->mc_list; imp; imp = imp->inm_next)
 2044120:	e0bffd17 	ldw	r2,-12(fp)
 2044124:	10800517 	ldw	r2,20(r2)
 2044128:	e0bffd15 	stw	r2,-12(fp)
 204412c:	e0bffd17 	ldw	r2,-12(fp)
 2044130:	103ff51e 	bne	r2,zero,2044108 <lookup_mcast+0x24>
   {
      if(imp->inm_addr == addr)
         return imp;
   }
   return NULL;   /* addr not found in mcast list */
 2044134:	0005883a 	mov	r2,zero
}
 2044138:	e037883a 	mov	sp,fp
 204413c:	df000017 	ldw	fp,0(sp)
 2044140:	dec00104 	addi	sp,sp,4
 2044144:	f800283a 	ret

02044148 <prep_ifaces>:
 * passed value. 
 */

int
prep_ifaces(int ifaces_found)
{
 2044148:	defffd04 	addi	sp,sp,-12
 204414c:	dfc00215 	stw	ra,8(sp)
 2044150:	df000115 	stw	fp,4(sp)
 2044154:	df000104 	addi	fp,sp,4
 2044158:	e13fff15 	stw	r4,-4(fp)
   if (port_prep)
 204415c:	d0a0c017 	ldw	r2,-32000(gp)
 2044160:	10000426 	beq	r2,zero,2044174 <prep_ifaces+0x2c>
      ifaces_found = port_prep(ifaces_found);
 2044164:	d0a0c017 	ldw	r2,-32000(gp)
 2044168:	e13fff17 	ldw	r4,-4(fp)
 204416c:	103ee83a 	callr	r2
 2044170:	e0bfff15 	stw	r2,-4(fp)

#ifdef MAC_LOOPBACK
   ifaces_found = prep_lb(ifaces_found);
#endif   /* MAC_LOOPBACK */

   ifNumber = ifaces_found;   /* set global interface counter */
 2044174:	e0ffff17 	ldw	r3,-4(fp)
 2044178:	00808174 	movhi	r2,517
 204417c:	1090b304 	addi	r2,r2,17100
 2044180:	10c00015 	stw	r3,0(r2)

   initmsg("prepped %u interface%s, initializing...\n", 
 2044184:	e0bfff17 	ldw	r2,-4(fp)
 2044188:	10800058 	cmpnei	r2,r2,1
 204418c:	1000031e 	bne	r2,zero,204419c <prep_ifaces+0x54>
 2044190:	00808174 	movhi	r2,517
 2044194:	10864704 	addi	r2,r2,6428
 2044198:	00000206 	br	20441a4 <prep_ifaces+0x5c>
 204419c:	00808174 	movhi	r2,517
 20441a0:	10864804 	addi	r2,r2,6432
 20441a4:	01008174 	movhi	r4,517
 20441a8:	21064904 	addi	r4,r4,6436
 20441ac:	e17fff17 	ldw	r5,-4(fp)
 20441b0:	100d883a 	mov	r6,r2
 20441b4:	2006a240 	call	2006a24 <printf>
      ifaces_found, ifaces_found==1?"":"s");

   return ifaces_found;
 20441b8:	e0bfff17 	ldw	r2,-4(fp)
}
 20441bc:	e037883a 	mov	sp,fp
 20441c0:	dfc00117 	ldw	ra,4(sp)
 20441c4:	df000017 	ldw	fp,0(sp)
 20441c8:	dec00204 	addi	sp,sp,8
 20441cc:	f800283a 	ret

020441d0 <netexit>:
 * RETURNS: SHould not return
 */

void
netexit(int err)      /* exit error level */
{
 20441d0:	defffd04 	addi	sp,sp,-12
 20441d4:	dfc00215 	stw	ra,8(sp)
 20441d8:	df000115 	stw	fp,4(sp)
 20441dc:	df000104 	addi	fp,sp,4
 20441e0:	e13fff15 	stw	r4,-4(fp)
   net_system_exit = TRUE; /* set flag for shutting down */
 20441e4:	00800044 	movi	r2,1
 20441e8:	d0a0c115 	stw	r2,-31996(gp)
   ip_exit();  /* do the exit_hook()ed stuff */
 20441ec:	2024ae00 	call	2024ae0 <ip_exit>

   PORT_EXIT_FUNC(err);    /* should not return! */
 20441f0:	e13fff17 	ldw	r4,-4(fp)
 20441f4:	204bd0c0 	call	204bd0c <exit>

020441f8 <evtmap_setup>:
 * INPUT: None.
 * OUTPUT: None
 */
 
void evtmap_setup (void)
{
 20441f8:	deffff04 	addi	sp,sp,-4
 20441fc:	df000015 	stw	fp,0(sp)
 2044200:	d839883a 	mov	fp,sp
#ifdef SOCK_MAP_EVENTS
   so_evtmap = TRUE;
   so_evtmap_create = evtmap_create;
   so_evtmap_delete = evtmap_delete;
#else
   so_evtmap = FALSE;
 2044204:	d020c405 	stb	zero,-31984(gp)
   so_evtmap_create = 0;
 2044208:	d020c215 	stw	zero,-31992(gp)
   so_evtmap_delete = 0;
 204420c:	d020c315 	stw	zero,-31988(gp)
#endif   /* SOCK_MAP_EVENTS */ 

}
 2044210:	e037883a 	mov	sp,fp
 2044214:	df000017 	ldw	fp,0(sp)
 2044218:	dec00104 	addi	sp,sp,4
 204421c:	f800283a 	ret

02044220 <ip_raw_open>:
ip_raw_open(u_char prot,
            ip_addr laddr,
            ip_addr faddr,
            int (*handler)(PACKET, void *),
            void * data)
{
 2044220:	defff904 	addi	sp,sp,-28
 2044224:	dfc00615 	stw	ra,24(sp)
 2044228:	df000515 	stw	fp,20(sp)
 204422c:	df000504 	addi	fp,sp,20
 2044230:	2005883a 	mov	r2,r4
 2044234:	e17ffd15 	stw	r5,-12(fp)
 2044238:	e1bffe15 	stw	r6,-8(fp)
 204423c:	e1ffff15 	stw	r7,-4(fp)
 2044240:	e0bffc05 	stb	r2,-16(fp)
   struct ipraw_ep * ep;

   LOCK_NET_RESOURCE(NET_RESID);
 2044244:	0009883a 	mov	r4,zero
 2044248:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   /* allocate a structure for the endpoint */
   ep = (struct ipraw_ep *)IEP_ALLOC(sizeof(struct ipraw_ep));
 204424c:	01000604 	movi	r4,24
 2044250:	20290400 	call	2029040 <npalloc>
 2044254:	e0bffb15 	stw	r2,-20(fp)
   if (ep == NULL)
 2044258:	e0bffb17 	ldw	r2,-20(fp)
 204425c:	10000c1e 	bne	r2,zero,2044290 <ip_raw_open+0x70>
   {
#ifdef NPDEBUG
      if (NDEBUG & INFOMSG)
 2044260:	00808174 	movhi	r2,517
 2044264:	1090b204 	addi	r2,r2,17096
 2044268:	10800017 	ldw	r2,0(r2)
 204426c:	1080010c 	andi	r2,r2,4
 2044270:	10000326 	beq	r2,zero,2044280 <ip_raw_open+0x60>
         dprintf("IP: Couldn't allocate ep storage.\n");
 2044274:	01008174 	movhi	r4,517
 2044278:	21065404 	addi	r4,r4,6480
 204427c:	2006cb40 	call	2006cb4 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 2044280:	0009883a 	mov	r4,zero
 2044284:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ep;
 2044288:	e0bffb17 	ldw	r2,-20(fp)
 204428c:	00001706 	br	20442ec <ip_raw_open+0xcc>
   }

   /* fill it in with the caller's requested binding */
   ep->ipr_laddr = laddr;
 2044290:	e0bffb17 	ldw	r2,-20(fp)
 2044294:	e0fffd17 	ldw	r3,-12(fp)
 2044298:	10c00115 	stw	r3,4(r2)
   ep->ipr_faddr = faddr;
 204429c:	e0bffb17 	ldw	r2,-20(fp)
 20442a0:	e0fffe17 	ldw	r3,-8(fp)
 20442a4:	10c00215 	stw	r3,8(r2)
   ep->ipr_prot = prot;
 20442a8:	e0bffb17 	ldw	r2,-20(fp)
 20442ac:	e0fffc03 	ldbu	r3,-16(fp)
 20442b0:	10c00505 	stb	r3,20(r2)
   ep->ipr_rcv = handler;
 20442b4:	e0bffb17 	ldw	r2,-20(fp)
 20442b8:	e0ffff17 	ldw	r3,-4(fp)
 20442bc:	10c00315 	stw	r3,12(r2)
   ep->ipr_data = data;
 20442c0:	e0bffb17 	ldw	r2,-20(fp)
 20442c4:	e0c00217 	ldw	r3,8(fp)
 20442c8:	10c00415 	stw	r3,16(r2)

   /* link it into the list 
    * (at the head, because that's simple and fast) 
    */
   ep->ipr_next = ipraw_eps;
 20442cc:	d0e0c517 	ldw	r3,-31980(gp)
 20442d0:	e0bffb17 	ldw	r2,-20(fp)
 20442d4:	10c00015 	stw	r3,0(r2)
   ipraw_eps = ep;
 20442d8:	e0bffb17 	ldw	r2,-20(fp)
 20442dc:	d0a0c515 	stw	r2,-31980(gp)

   /* and return the pointer to the endpoint */
   UNLOCK_NET_RESOURCE(NET_RESID);
 20442e0:	0009883a 	mov	r4,zero
 20442e4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return ep;
 20442e8:	e0bffb17 	ldw	r2,-20(fp)
}
 20442ec:	e037883a 	mov	sp,fp
 20442f0:	dfc00117 	ldw	ra,4(sp)
 20442f4:	df000017 	ldw	fp,0(sp)
 20442f8:	dec00204 	addi	sp,sp,8
 20442fc:	f800283a 	ret

02044300 <ip_raw_close>:
 *                               that is to be closed
 * RETURNS: void
 */
void
ip_raw_close(struct ipraw_ep * ep)
{
 2044300:	defffb04 	addi	sp,sp,-20
 2044304:	dfc00415 	stw	ra,16(sp)
 2044308:	df000315 	stw	fp,12(sp)
 204430c:	df000304 	addi	fp,sp,12
 2044310:	e13fff15 	stw	r4,-4(fp)
   struct ipraw_ep * prev_ep;
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);
 2044314:	0009883a 	mov	r4,zero
 2044318:	20288980 	call	2028898 <LOCK_NET_RESOURCE>

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 204431c:	e03ffd15 	stw	zero,-12(fp)
 2044320:	d0a0c517 	ldw	r2,-31980(gp)
 2044324:	e0bffe15 	stw	r2,-8(fp)
 2044328:	00000806 	br	204434c <ip_raw_close+0x4c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
 204432c:	e0fffe17 	ldw	r3,-8(fp)
 2044330:	e0bfff17 	ldw	r2,-4(fp)
 2044334:	18800826 	beq	r3,r2,2044358 <ip_raw_close+0x58>
         break;
      prev_ep = curr_ep;
 2044338:	e0bffe17 	ldw	r2,-8(fp)
 204433c:	e0bffd15 	stw	r2,-12(fp)
   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
 2044340:	e0bffe17 	ldw	r2,-8(fp)
 2044344:	10800017 	ldw	r2,0(r2)
 2044348:	e0bffe15 	stw	r2,-8(fp)
   struct ipraw_ep * curr_ep;

   LOCK_NET_RESOURCE(NET_RESID);

   /* search the list of endpoints for the one we're supposed to close */
   for (prev_ep = NULL, curr_ep = ipraw_eps;
 204434c:	e0bffe17 	ldw	r2,-8(fp)
 2044350:	103ff61e 	bne	r2,zero,204432c <ip_raw_close+0x2c>
 2044354:	00000106 	br	204435c <ip_raw_close+0x5c>
        curr_ep != NULL;
        curr_ep = curr_ep->ipr_next)
   {
      if (curr_ep == ep)
         break;
 2044358:	0001883a 	nop
      prev_ep = curr_ep;
   }

   /* if we didn't find it, we can't close it, so just return */
   if (curr_ep == NULL)
 204435c:	e0bffe17 	ldw	r2,-8(fp)
 2044360:	1000041e 	bne	r2,zero,2044374 <ip_raw_close+0x74>
   {
#ifdef NPDEBUG
      /* caller passed pointer to endpoint not in list 
       * -- not fatal, but may be programming error
       */
      dtrap();
 2044364:	20285c80 	call	20285c8 <dtrap>
#endif /* NPDEBUG */
      UNLOCK_NET_RESOURCE(NET_RESID);
 2044368:	0009883a 	mov	r4,zero
 204436c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return;
 2044370:	00000d06 	br	20443a8 <ip_raw_close+0xa8>
   }

   /* unlink it from the list */
   if (prev_ep)
 2044374:	e0bffd17 	ldw	r2,-12(fp)
 2044378:	10000426 	beq	r2,zero,204438c <ip_raw_close+0x8c>
      prev_ep = curr_ep->ipr_next;
 204437c:	e0bffe17 	ldw	r2,-8(fp)
 2044380:	10800017 	ldw	r2,0(r2)
 2044384:	e0bffd15 	stw	r2,-12(fp)
 2044388:	00000306 	br	2044398 <ip_raw_close+0x98>
   else
      ipraw_eps = curr_ep->ipr_next;
 204438c:	e0bffe17 	ldw	r2,-8(fp)
 2044390:	10800017 	ldw	r2,0(r2)
 2044394:	d0a0c515 	stw	r2,-31980(gp)

   /* free its storage */
   IEP_FREE(curr_ep);
 2044398:	e13ffe17 	ldw	r4,-8(fp)
 204439c:	202912c0 	call	202912c <npfree>

   /* and return */
   UNLOCK_NET_RESOURCE(NET_RESID);
 20443a0:	0009883a 	mov	r4,zero
 20443a4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
}
 20443a8:	e037883a 	mov	sp,fp
 20443ac:	dfc00117 	ldw	ra,4(sp)
 20443b0:	df000017 	ldw	fp,0(sp)
 20443b4:	dec00204 	addi	sp,sp,8
 20443b8:	f800283a 	ret

020443bc <ip_raw_input>:
 *          freed); else an error code indicating that the
 *          received packet was not accepted/processed
 */
int
ip_raw_input(PACKET p)
{
 20443bc:	defff604 	addi	sp,sp,-40
 20443c0:	dfc00915 	stw	ra,36(sp)
 20443c4:	df000815 	stw	fp,32(sp)
 20443c8:	df000804 	addi	fp,sp,32
 20443cc:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;              /* the internet header */
   struct ipraw_ep * ep;
   struct ipraw_ep * next_ep;
   struct ipraw_ep * matched_ep = NULL;
 20443d0:	e03ff915 	stw	zero,-28(fp)
   int err;
   int delivered;

   /* start out expecting to not deliver the packet */
   delivered = 0;
 20443d4:	e03ffb15 	stw	zero,-20(fp)

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);
 20443d8:	e0bfff17 	ldw	r2,-4(fp)
 20443dc:	10800317 	ldw	r2,12(r2)
 20443e0:	e0bffc15 	stw	r2,-16(fp)

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 20443e4:	d0a0c517 	ldw	r2,-31980(gp)
 20443e8:	e0bff815 	stw	r2,-32(fp)
 20443ec:	00004c06 	br	2044520 <ip_raw_input+0x164>
   {
      /* keep track of next endpoint -- defense against upcall
       * function closing its own endpoint
       */
      next_ep = ep->ipr_next;
 20443f0:	e0bff817 	ldw	r2,-32(fp)
 20443f4:	10800017 	ldw	r2,0(r2)
 20443f8:	e0bffd15 	stw	r2,-12(fp)

      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
 20443fc:	e0bff817 	ldw	r2,-32(fp)
 2044400:	10800503 	ldbu	r2,20(r2)
 2044404:	10803fcc 	andi	r2,r2,255
 2044408:	10000726 	beq	r2,zero,2044428 <ip_raw_input+0x6c>
 204440c:	e0bff817 	ldw	r2,-32(fp)
 2044410:	10c00503 	ldbu	r3,20(r2)
 2044414:	e0bffc17 	ldw	r2,-16(fp)
 2044418:	10800243 	ldbu	r2,9(r2)
 204441c:	18c03fcc 	andi	r3,r3,255
 2044420:	10803fcc 	andi	r2,r2,255
 2044424:	1880371e 	bne	r3,r2,2044504 <ip_raw_input+0x148>
         continue;
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
 2044428:	e0bff817 	ldw	r2,-32(fp)
 204442c:	10800117 	ldw	r2,4(r2)
 2044430:	10000526 	beq	r2,zero,2044448 <ip_raw_input+0x8c>
 2044434:	e0bff817 	ldw	r2,-32(fp)
 2044438:	10c00117 	ldw	r3,4(r2)
 204443c:	e0bffc17 	ldw	r2,-16(fp)
 2044440:	10800417 	ldw	r2,16(r2)
 2044444:	1880311e 	bne	r3,r2,204450c <ip_raw_input+0x150>
         continue;
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
 2044448:	e0bff817 	ldw	r2,-32(fp)
 204444c:	10800217 	ldw	r2,8(r2)
 2044450:	10000526 	beq	r2,zero,2044468 <ip_raw_input+0xac>
 2044454:	e0bff817 	ldw	r2,-32(fp)
 2044458:	10c00217 	ldw	r3,8(r2)
 204445c:	e0bffc17 	ldw	r2,-16(fp)
 2044460:	10800317 	ldw	r2,12(r2)
 2044464:	18802b1e 	bne	r3,r2,2044514 <ip_raw_input+0x158>
         continue;

      /* if the endpoint has a receive upcall function, 
       * keep track of the endpoint
       */
      if (ep->ipr_rcv != NULL)
 2044468:	e0bff817 	ldw	r2,-32(fp)
 204446c:	10800317 	ldw	r2,12(r2)
 2044470:	10002926 	beq	r2,zero,2044518 <ip_raw_input+0x15c>
          * copy the packet into a new buffer,
          * and pass the new copy to the previously matched 
          * endpoint's upcall function 
          * before we forget the previous endpoint
          */
         if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 2044474:	e0bff917 	ldw	r2,-28(fp)
 2044478:	10001f26 	beq	r2,zero,20444f8 <ip_raw_input+0x13c>
 204447c:	e0bff917 	ldw	r2,-28(fp)
 2044480:	10800317 	ldw	r2,12(r2)
 2044484:	10001c26 	beq	r2,zero,20444f8 <ip_raw_input+0x13c>
         {
            PACKET p2;

            p2 = ip_copypkt(p);
 2044488:	e13fff17 	ldw	r4,-4(fp)
 204448c:	20413040 	call	2041304 <ip_copypkt>
 2044490:	e0bffe15 	stw	r2,-8(fp)
            if (p2)
 2044494:	e0bffe17 	ldw	r2,-8(fp)
 2044498:	10001726 	beq	r2,zero,20444f8 <ip_raw_input+0x13c>
            {
               UNLOCK_NET_RESOURCE(NET_RESID);
 204449c:	0009883a 	mov	r4,zero
 20444a0:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
               err = ((*matched_ep->ipr_rcv)(p2, matched_ep->ipr_data));
 20444a4:	e0bff917 	ldw	r2,-28(fp)
 20444a8:	10c00317 	ldw	r3,12(r2)
 20444ac:	e0bff917 	ldw	r2,-28(fp)
 20444b0:	10800417 	ldw	r2,16(r2)
 20444b4:	e13ffe17 	ldw	r4,-8(fp)
 20444b8:	100b883a 	mov	r5,r2
 20444bc:	183ee83a 	callr	r3
 20444c0:	e0bffa15 	stw	r2,-24(fp)
               LOCK_NET_RESOURCE(NET_RESID);
 20444c4:	0009883a 	mov	r4,zero
 20444c8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
               if (err)
 20444cc:	e0bffa17 	ldw	r2,-24(fp)
 20444d0:	10000726 	beq	r2,zero,20444f0 <ip_raw_input+0x134>
               {
                  LOCK_NET_RESOURCE(FREEQ_RESID);
 20444d4:	01000084 	movi	r4,2
 20444d8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
                  pk_free(p2);
 20444dc:	e13ffe17 	ldw	r4,-8(fp)
 20444e0:	20280440 	call	2028044 <pk_free>
                  UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20444e4:	01000084 	movi	r4,2
 20444e8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
 20444ec:	00000206 	br	20444f8 <ip_raw_input+0x13c>
               }
               else
                  delivered = 1;
 20444f0:	00800044 	movi	r2,1
 20444f4:	e0bffb15 	stw	r2,-20(fp)
            }
         }
         matched_ep = ep;
 20444f8:	e0bff817 	ldw	r2,-32(fp)
 20444fc:	e0bff915 	stw	r2,-28(fp)
 2044500:	00000506 	br	2044518 <ip_raw_input+0x15c>
      /* if this packet doesn't match the endpoint's filters (IP
       * protocol ID, locally-bound address, connected-peer address)
       * then skip ahead to next endpoint
       */
      if (ep->ipr_prot && ep->ipr_prot != pip->ip_prot)
         continue;
 2044504:	0001883a 	nop
 2044508:	00000306 	br	2044518 <ip_raw_input+0x15c>
      if (ep->ipr_laddr && ep->ipr_laddr != pip->ip_dest)
         continue;
 204450c:	0001883a 	nop
 2044510:	00000106 	br	2044518 <ip_raw_input+0x15c>
      if (ep->ipr_faddr && ep->ipr_faddr != pip->ip_src)
         continue;
 2044514:	0001883a 	nop

   /* get a pointer to the received packet's IP header */
   pip = (struct ip *)(p->nb_prot);

   /* search the list of raw-IP endpoints for matches */
   for (ep = ipraw_eps; ep != NULL; ep = next_ep)
 2044518:	e0bffd17 	ldw	r2,-12(fp)
 204451c:	e0bff815 	stw	r2,-32(fp)
 2044520:	e0bff817 	ldw	r2,-32(fp)
 2044524:	103fb21e 	bne	r2,zero,20443f0 <ip_raw_input+0x34>
   /* if we matched an endpoint, 
    * pass the packet to its upcall function
    * otherwise, return ENP_PARAM to indicate that the
    * packet was not processed and freed
    */
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
 2044528:	e0bff917 	ldw	r2,-28(fp)
 204452c:	10001426 	beq	r2,zero,2044580 <ip_raw_input+0x1c4>
 2044530:	e0bff917 	ldw	r2,-28(fp)
 2044534:	10800317 	ldw	r2,12(r2)
 2044538:	10001126 	beq	r2,zero,2044580 <ip_raw_input+0x1c4>
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
 204453c:	0009883a 	mov	r4,zero
 2044540:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
 2044544:	e0bff917 	ldw	r2,-28(fp)
 2044548:	10c00317 	ldw	r3,12(r2)
 204454c:	e0bff917 	ldw	r2,-28(fp)
 2044550:	10800417 	ldw	r2,16(r2)
 2044554:	e13fff17 	ldw	r4,-4(fp)
 2044558:	100b883a 	mov	r5,r2
 204455c:	183ee83a 	callr	r3
 2044560:	e0bffa15 	stw	r2,-24(fp)
      LOCK_NET_RESOURCE(NET_RESID);
 2044564:	0009883a 	mov	r4,zero
 2044568:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      if (err == 0)
 204456c:	e0bffa17 	ldw	r2,-24(fp)
 2044570:	10000c1e 	bne	r2,zero,20445a4 <ip_raw_input+0x1e8>
         delivered = 1;
 2044574:	00800044 	movi	r2,1
 2044578:	e0bffb15 	stw	r2,-20(fp)
   if ((matched_ep != NULL) && (matched_ep->ipr_rcv != NULL))
   {
      UNLOCK_NET_RESOURCE(NET_RESID);
      err = ((*matched_ep->ipr_rcv)(p, matched_ep->ipr_data));
      LOCK_NET_RESOURCE(NET_RESID);
      if (err == 0)
 204457c:	00000906 	br	20445a4 <ip_raw_input+0x1e8>
         delivered = 1;
   }
   else
   {
      err = ENP_PARAM;
 2044580:	00bffd84 	movi	r2,-10
 2044584:	e0bffa15 	stw	r2,-24(fp)
      ip_mib.ipUnknownProtos++;
 2044588:	00809934 	movhi	r2,612
 204458c:	10b7d304 	addi	r2,r2,-8372
 2044590:	10800617 	ldw	r2,24(r2)
 2044594:	10c00044 	addi	r3,r2,1
 2044598:	00809934 	movhi	r2,612
 204459c:	10b7d304 	addi	r2,r2,-8372
 20445a0:	10c00615 	stw	r3,24(r2)
   }

   if (!delivered)
 20445a4:	e0bffb17 	ldw	r2,-20(fp)
 20445a8:	1000071e 	bne	r2,zero,20445c8 <ip_raw_input+0x20c>
      ip_mib.ipInDelivers--;
 20445ac:	00809934 	movhi	r2,612
 20445b0:	10b7d304 	addi	r2,r2,-8372
 20445b4:	10800817 	ldw	r2,32(r2)
 20445b8:	10ffffc4 	addi	r3,r2,-1
 20445bc:	00809934 	movhi	r2,612
 20445c0:	10b7d304 	addi	r2,r2,-8372
 20445c4:	10c00815 	stw	r3,32(r2)

   return err;
 20445c8:	e0bffa17 	ldw	r2,-24(fp)
}
 20445cc:	e037883a 	mov	sp,fp
 20445d0:	dfc00117 	ldw	ra,4(sp)
 20445d4:	df000017 	ldw	fp,0(sp)
 20445d8:	dec00204 	addi	sp,sp,8
 20445dc:	f800283a 	ret

020445e0 <ip_raw_alloc>:
 *          inclhdr is zero.
 */

PACKET
ip_raw_alloc(int reqlen, int hdrincl)
{
 20445e0:	defffa04 	addi	sp,sp,-24
 20445e4:	dfc00515 	stw	ra,20(sp)
 20445e8:	df000415 	stw	fp,16(sp)
 20445ec:	df000404 	addi	fp,sp,16
 20445f0:	e13ffe15 	stw	r4,-8(fp)
 20445f4:	e17fff15 	stw	r5,-4(fp)
   int len;
   PACKET p;

   len = (reqlen + 1) & ~1;
 20445f8:	e0bffe17 	ldw	r2,-8(fp)
 20445fc:	10c00044 	addi	r3,r2,1
 2044600:	00bfff84 	movi	r2,-2
 2044604:	1884703a 	and	r2,r3,r2
 2044608:	e0bffc15 	stw	r2,-16(fp)
   if (!hdrincl)
 204460c:	e0bfff17 	ldw	r2,-4(fp)
 2044610:	1000031e 	bne	r2,zero,2044620 <ip_raw_alloc+0x40>
      len += IPHSIZ;
 2044614:	e0bffc17 	ldw	r2,-16(fp)
 2044618:	10800504 	addi	r2,r2,20
 204461c:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2044620:	01000084 	movi	r4,2
 2044624:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + MaxLnh);
 2044628:	00808174 	movhi	r2,517
 204462c:	1090b004 	addi	r2,r2,17088
 2044630:	10c00017 	ldw	r3,0(r2)
 2044634:	e0bffc17 	ldw	r2,-16(fp)
 2044638:	1885883a 	add	r2,r3,r2
 204463c:	1009883a 	mov	r4,r2
 2044640:	2027cec0 	call	2027cec <pk_alloc>
 2044644:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2044648:	01000084 	movi	r4,2
 204464c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   if (p)
 2044650:	e0bffd17 	ldw	r2,-12(fp)
 2044654:	10000c26 	beq	r2,zero,2044688 <ip_raw_alloc+0xa8>
   {
      if (!hdrincl)
 2044658:	e0bfff17 	ldw	r2,-4(fp)
 204465c:	10000a1e 	bne	r2,zero,2044688 <ip_raw_alloc+0xa8>
      {
         p->nb_prot += IPHSIZ;
 2044660:	e0bffd17 	ldw	r2,-12(fp)
 2044664:	10800317 	ldw	r2,12(r2)
 2044668:	10c00504 	addi	r3,r2,20
 204466c:	e0bffd17 	ldw	r2,-12(fp)
 2044670:	10c00315 	stw	r3,12(r2)
         p->nb_plen -= IPHSIZ;
 2044674:	e0bffd17 	ldw	r2,-12(fp)
 2044678:	10800417 	ldw	r2,16(r2)
 204467c:	10fffb04 	addi	r3,r2,-20
 2044680:	e0bffd17 	ldw	r2,-12(fp)
 2044684:	10c00415 	stw	r3,16(r2)
      }
   }
   return p;
 2044688:	e0bffd17 	ldw	r2,-12(fp)
}
 204468c:	e037883a 	mov	sp,fp
 2044690:	dfc00117 	ldw	ra,4(sp)
 2044694:	df000017 	ldw	fp,0(sp)
 2044698:	dec00204 	addi	sp,sp,8
 204469c:	f800283a 	ret

020446a0 <ip_raw_free>:
 * RETURNS: void
 */

void
ip_raw_free(PACKET p)
{
 20446a0:	defffd04 	addi	sp,sp,-12
 20446a4:	dfc00215 	stw	ra,8(sp)
 20446a8:	df000115 	stw	fp,4(sp)
 20446ac:	df000104 	addi	fp,sp,4
 20446b0:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 20446b4:	01000084 	movi	r4,2
 20446b8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 20446bc:	e13fff17 	ldw	r4,-4(fp)
 20446c0:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 20446c4:	01000084 	movi	r4,2
 20446c8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
}
 20446cc:	e037883a 	mov	sp,fp
 20446d0:	dfc00117 	ldw	ra,4(sp)
 20446d4:	df000017 	ldw	fp,0(sp)
 20446d8:	dec00204 	addi	sp,sp,8
 20446dc:	f800283a 	ret

020446e0 <ip_raw_maxalloc>:
 *          for 
 */

int
ip_raw_maxalloc(int hdrincl)
{
 20446e0:	defffd04 	addi	sp,sp,-12
 20446e4:	df000215 	stw	fp,8(sp)
 20446e8:	df000204 	addi	fp,sp,8
 20446ec:	e13fff15 	stw	r4,-4(fp)
   int len;

   len = bigbufsiz - MaxLnh;
 20446f0:	00808174 	movhi	r2,517
 20446f4:	10906904 	addi	r2,r2,16804
 20446f8:	10c00017 	ldw	r3,0(r2)
 20446fc:	00808174 	movhi	r2,517
 2044700:	1090b004 	addi	r2,r2,17088
 2044704:	10800017 	ldw	r2,0(r2)
 2044708:	1885c83a 	sub	r2,r3,r2
 204470c:	e0bffe15 	stw	r2,-8(fp)
   if (!hdrincl)
 2044710:	e0bfff17 	ldw	r2,-4(fp)
 2044714:	1000031e 	bne	r2,zero,2044724 <ip_raw_maxalloc+0x44>
      len -= IPHSIZ;
 2044718:	e0bffe17 	ldw	r2,-8(fp)
 204471c:	10bffb04 	addi	r2,r2,-20
 2044720:	e0bffe15 	stw	r2,-8(fp)
   return len;
 2044724:	e0bffe17 	ldw	r2,-8(fp)
}
 2044728:	e037883a 	mov	sp,fp
 204472c:	df000017 	ldw	fp,0(sp)
 2044730:	dec00104 	addi	sp,sp,4
 2044734:	f800283a 	ret

02044738 <rt_lookup>:
 * entry was found.
 */

RTMIB
rt_lookup(ip_addr host)
{
 2044738:	defff804 	addi	sp,sp,-32
 204473c:	df000715 	stw	fp,28(sp)
 2044740:	df000704 	addi	fp,sp,28
 2044744:	e13fff15 	stw	r4,-4(fp)
   RTMIB    rtp;
   RTMIB    netmatch;
   unsigned char max_bits_matched = 0;
 2044748:	e03ffb05 	stb	zero,-20(fp)
   unsigned char curr_bits_matched;
   ip_addr  entry_mask;
   unsigned long int bitcount_mask;
   unsigned long int extracted_bit;

   netmatch = NULL;
 204474c:	e03ffa15 	stw	zero,-24(fp)

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 2044750:	00808174 	movhi	r2,517
 2044754:	1090e604 	addi	r2,r2,17304
 2044758:	10800017 	ldw	r2,0(r2)
 204475c:	e0bff915 	stw	r2,-28(fp)
 2044760:	00003a06 	br	204484c <rt_lookup+0x114>
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
 2044764:	e0bff917 	ldw	r2,-28(fp)
 2044768:	10800617 	ldw	r2,24(r2)
 204476c:	10003326 	beq	r2,zero,204483c <rt_lookup+0x104>
#ifdef RIP_SUPPORT
      /* skip RIP private entries */
      if (rtp->ipRouteFlags & RIP_PRIVATE)
         continue;
#endif
      entry_mask = rtp->ipRouteMask;
 2044770:	e0bff917 	ldw	r2,-28(fp)
 2044774:	10800a17 	ldw	r2,40(r2)
 2044778:	e0bffd15 	stw	r2,-12(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
 204477c:	e0bff917 	ldw	r2,-28(fp)
 2044780:	10c00017 	ldw	r3,0(r2)
 2044784:	e0bfff17 	ldw	r2,-4(fp)
 2044788:	1886f03a 	xor	r3,r3,r2
 204478c:	e0bffd17 	ldw	r2,-12(fp)
 2044790:	1884703a 	and	r2,r3,r2
 2044794:	10002a1e 	bne	r2,zero,2044840 <rt_lookup+0x108>
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 2044798:	e03ffb45 	stb	zero,-19(fp)
 204479c:	00a00034 	movhi	r2,32768
 20447a0:	e0bffc15 	stw	r2,-16(fp)
 20447a4:	00001806 	br	2044808 <rt_lookup+0xd0>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
 20447a8:	e0bffd17 	ldw	r2,-12(fp)
 20447ac:	1006d63a 	srli	r3,r2,24
 20447b0:	e0bffd17 	ldw	r2,-12(fp)
 20447b4:	1004d23a 	srli	r2,r2,8
 20447b8:	10bfc00c 	andi	r2,r2,65280
 20447bc:	1886b03a 	or	r3,r3,r2
 20447c0:	e0bffd17 	ldw	r2,-12(fp)
 20447c4:	10bfc00c 	andi	r2,r2,65280
 20447c8:	1004923a 	slli	r2,r2,8
 20447cc:	1886b03a 	or	r3,r3,r2
 20447d0:	e0bffd17 	ldw	r2,-12(fp)
 20447d4:	1004963a 	slli	r2,r2,24
 20447d8:	1886b03a 	or	r3,r3,r2
 20447dc:	e0bffc17 	ldw	r2,-16(fp)
 20447e0:	1884703a 	and	r2,r3,r2
 20447e4:	e0bffe15 	stw	r2,-8(fp)
            if (extracted_bit) ++curr_bits_matched;
 20447e8:	e0bffe17 	ldw	r2,-8(fp)
 20447ec:	10000326 	beq	r2,zero,20447fc <rt_lookup+0xc4>
 20447f0:	e0bffb43 	ldbu	r2,-19(fp)
 20447f4:	10800044 	addi	r2,r2,1
 20447f8:	e0bffb45 	stb	r2,-19(fp)
      /* check to see if we have a match in the route table */
      if ((rtp->ipRouteDest & entry_mask) == (host & entry_mask))
      {
         /* check to see if current match is better than the previous best
          * by computing the number of bits that matched */
         for (curr_bits_matched = 0, bitcount_mask = 0x80000000; bitcount_mask > 0; bitcount_mask >>= 1)
 20447fc:	e0bffc17 	ldw	r2,-16(fp)
 2044800:	1004d07a 	srli	r2,r2,1
 2044804:	e0bffc15 	stw	r2,-16(fp)
 2044808:	e0bffc17 	ldw	r2,-16(fp)
 204480c:	103fe61e 	bne	r2,zero,20447a8 <rt_lookup+0x70>
         {
            extracted_bit = (ntohl(entry_mask)) & bitcount_mask;
            if (extracted_bit) ++curr_bits_matched;
         }
         if (curr_bits_matched > max_bits_matched)
 2044810:	e0bffb43 	ldbu	r2,-19(fp)
 2044814:	e0fffb03 	ldbu	r3,-20(fp)
 2044818:	1880092e 	bgeu	r3,r2,2044840 <rt_lookup+0x108>
         {
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
 204481c:	e0bffb43 	ldbu	r2,-19(fp)
 2044820:	e0bffb05 	stb	r2,-20(fp)
            netmatch = rtp;
 2044824:	e0bff917 	ldw	r2,-28(fp)
 2044828:	e0bffa15 	stw	r2,-24(fp)
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
 204482c:	e0bffb03 	ldbu	r2,-20(fp)
 2044830:	10800818 	cmpnei	r2,r2,32
 2044834:	10001026 	beq	r2,zero,2044878 <rt_lookup+0x140>
 2044838:	00000106 	br	2044840 <rt_lookup+0x108>

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (rtp->ipRouteNextHop == 0L)   /* skip over empty entries */
         continue;
 204483c:	0001883a 	nop
   unsigned long int extracted_bit;

   netmatch = NULL;

   /* see if it's in the route table. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 2044840:	e0bff917 	ldw	r2,-28(fp)
 2044844:	10800f04 	addi	r2,r2,60
 2044848:	e0bff915 	stw	r2,-28(fp)
 204484c:	00808174 	movhi	r2,517
 2044850:	1090e604 	addi	r2,r2,17304
 2044854:	10c00017 	ldw	r3,0(r2)
 2044858:	00808174 	movhi	r2,517
 204485c:	10908004 	addi	r2,r2,16896
 2044860:	10800017 	ldw	r2,0(r2)
 2044864:	10800f24 	muli	r2,r2,60
 2044868:	1885883a 	add	r2,r3,r2
 204486c:	e0fff917 	ldw	r3,-28(fp)
 2044870:	18bfbc36 	bltu	r3,r2,2044764 <rt_lookup+0x2c>
 2044874:	00000106 	br	204487c <rt_lookup+0x144>
            /* save a pointer to the best match */
            max_bits_matched = curr_bits_matched;
            netmatch = rtp;
            /* if all 32 bits match, stop searching the route table */
            if (max_bits_matched == 32)
               break;
 2044878:	0001883a 	nop
         }
      }
   }

   if (netmatch)
 204487c:	e0bffa17 	ldw	r2,-24(fp)
 2044880:	10000526 	beq	r2,zero,2044898 <rt_lookup+0x160>
      netmatch->ipRouteAge = cticks;   /* timestamp entry we used */
 2044884:	00808174 	movhi	r2,517
 2044888:	1090c904 	addi	r2,r2,17188
 204488c:	10c00017 	ldw	r3,0(r2)
 2044890:	e0bffa17 	ldw	r2,-24(fp)
 2044894:	10c00915 	stw	r3,36(r2)

   return netmatch;
 2044898:	e0bffa17 	ldw	r2,-24(fp)
}
 204489c:	e037883a 	mov	sp,fp
 20448a0:	df000017 	ldw	fp,0(sp)
 20448a4:	dec00104 	addi	sp,sp,4
 20448a8:	f800283a 	ret

020448ac <add_route>:
   ip_addr  dest,       /* ultimate destination */
   ip_addr  mask,       /* net mask, 0xFFFFFFFF if dest is host address */
   ip_addr  nexthop,    /* where to forward to */
   int      iface,      /* interface (net) for nexthop */
   int      prot)       /* how we know it: icmp, table, etc */
{
 20448ac:	defff704 	addi	sp,sp,-36
 20448b0:	dfc00815 	stw	ra,32(sp)
 20448b4:	df000715 	stw	fp,28(sp)
 20448b8:	df000704 	addi	fp,sp,28
 20448bc:	e13ffc15 	stw	r4,-16(fp)
 20448c0:	e17ffd15 	stw	r5,-12(fp)
 20448c4:	e1bffe15 	stw	r6,-8(fp)
 20448c8:	e1ffff15 	stw	r7,-4(fp)
   RTMIB rtp;           /* scratch route table entrry pointer */
   RTMIB newrt;         /* best entry for new route */
   struct net * ifp;    /* interface (net) for nexthop */

   newrt = NULL;     /* may be replaced with empty or more expendable entry */
 20448cc:	e03ffa15 	stw	zero,-24(fp)
					 
   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   ifp = if_getbynum(iface);
 20448d0:	e13fff17 	ldw	r4,-4(fp)
 20448d4:	203f15c0 	call	203f15c <if_getbynum>
 20448d8:	e0bffb15 	stw	r2,-20(fp)
   if(!ifp)
 20448dc:	e0bffb17 	ldw	r2,-20(fp)
 20448e0:	1000021e 	bne	r2,zero,20448ec <add_route+0x40>
      return NULL;
 20448e4:	0005883a 	mov	r2,zero
 20448e8:	0000e606 	br	2044c84 <add_route+0x3d8>

   if (rt_mib == NULL)
 20448ec:	00808174 	movhi	r2,517
 20448f0:	1090e604 	addi	r2,r2,17304
 20448f4:	10800017 	ldw	r2,0(r2)
 20448f8:	1000021e 	bne	r2,zero,2044904 <add_route+0x58>
      return NULL;
 20448fc:	0005883a 	mov	r2,zero
 2044900:	0000e006 	br	2044c84 <add_route+0x3d8>

   /* Don't add null masks or IP addresses - they give false positives on
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
 2044904:	e0bffc17 	ldw	r2,-16(fp)
 2044908:	10000226 	beq	r2,zero,2044914 <add_route+0x68>
 204490c:	e0bffd17 	ldw	r2,-12(fp)
 2044910:	1000221e 	bne	r2,zero,204499c <add_route+0xf0>
   {
      dtrap();    /* bad configuration? */
 2044914:	20285c80 	call	20285c8 <dtrap>
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
	      htonl(dest), htonl(mask) );
 2044918:	e0bffc17 	ldw	r2,-16(fp)
 204491c:	1006d63a 	srli	r3,r2,24
 2044920:	e0bffc17 	ldw	r2,-16(fp)
 2044924:	1004d23a 	srli	r2,r2,8
 2044928:	10bfc00c 	andi	r2,r2,65280
 204492c:	1886b03a 	or	r3,r3,r2
 2044930:	e0bffc17 	ldw	r2,-16(fp)
 2044934:	10bfc00c 	andi	r2,r2,65280
 2044938:	1004923a 	slli	r2,r2,8
 204493c:	1886b03a 	or	r3,r3,r2
 2044940:	e0bffc17 	ldw	r2,-16(fp)
 2044944:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 2044948:	1886b03a 	or	r3,r3,r2
	      htonl(dest), htonl(mask) );
 204494c:	e0bffd17 	ldw	r2,-12(fp)
 2044950:	1008d63a 	srli	r4,r2,24
 2044954:	e0bffd17 	ldw	r2,-12(fp)
 2044958:	1004d23a 	srli	r2,r2,8
 204495c:	10bfc00c 	andi	r2,r2,65280
 2044960:	2088b03a 	or	r4,r4,r2
 2044964:	e0bffd17 	ldw	r2,-12(fp)
 2044968:	10bfc00c 	andi	r2,r2,65280
 204496c:	1004923a 	slli	r2,r2,8
 2044970:	2088b03a 	or	r4,r4,r2
 2044974:	e0bffd17 	ldw	r2,-12(fp)
 2044978:	1004963a 	slli	r2,r2,24
    * net matches and don't belong here anyway.
    */
   if((dest == 0) || (mask == 0))
   {
      dtrap();    /* bad configuration? */
      dprintf("add_route: rejected null parm; dest: %lx, mask: %lx\n",
 204497c:	2084b03a 	or	r2,r4,r2
 2044980:	01008174 	movhi	r4,517
 2044984:	21065d04 	addi	r4,r4,6516
 2044988:	180b883a 	mov	r5,r3
 204498c:	100d883a 	mov	r6,r2
 2044990:	2006a240 	call	2006a24 <printf>
	      htonl(dest), htonl(mask) );
      return NULL;
 2044994:	0005883a 	mov	r2,zero
 2044998:	0000ba06 	br	2044c84 <add_route+0x3d8>
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 204499c:	00808174 	movhi	r2,517
 20449a0:	1090e604 	addi	r2,r2,17304
 20449a4:	10800017 	ldw	r2,0(r2)
 20449a8:	e0bff915 	stw	r2,-28(fp)
 20449ac:	00006b06 	br	2044b5c <add_route+0x2b0>
   {
      if (rtp->ipRouteDest == dest) /* found existing entry for target */
 20449b0:	e0bff917 	ldw	r2,-28(fp)
 20449b4:	10c00017 	ldw	r3,0(r2)
 20449b8:	e0bffc17 	ldw	r2,-16(fp)
 20449bc:	1880171e 	bne	r3,r2,2044a1c <add_route+0x170>
      {
         rtp->ipRouteNextHop = nexthop;      /* fix entry */
 20449c0:	e0bff917 	ldw	r2,-28(fp)
 20449c4:	e0fffe17 	ldw	r3,-8(fp)
 20449c8:	10c00615 	stw	r3,24(r2)
         rtp->ipRouteAge = cticks;           /* timestamp it */
 20449cc:	00808174 	movhi	r2,517
 20449d0:	1090c904 	addi	r2,r2,17188
 20449d4:	10c00017 	ldw	r3,0(r2)
 20449d8:	e0bff917 	ldw	r2,-28(fp)
 20449dc:	10c00915 	stw	r3,36(r2)
         /* set the rfc1213 1-based SNMP-ish interface index */
         rtp->ipRouteIfIndex = (long)(iface) + 1;
 20449e0:	e0bfff17 	ldw	r2,-4(fp)
 20449e4:	10c00044 	addi	r3,r2,1
 20449e8:	e0bff917 	ldw	r2,-28(fp)
 20449ec:	10c00115 	stw	r3,4(r2)
         rtp->ipRouteProto = prot;           /* icmp, or whatever */
 20449f0:	e0bff917 	ldw	r2,-28(fp)
 20449f4:	e0c00217 	ldw	r3,8(fp)
 20449f8:	10c00815 	stw	r3,32(r2)
         rtp->ipRouteMask = mask;
 20449fc:	e0bff917 	ldw	r2,-28(fp)
 2044a00:	e0fffd17 	ldw	r3,-12(fp)
 2044a04:	10c00a15 	stw	r3,40(r2)
         rtp->ifp = ifp;
 2044a08:	e0bff917 	ldw	r2,-28(fp)
 2044a0c:	e0fffb17 	ldw	r3,-20(fp)
 2044a10:	10c00e15 	stw	r3,56(r2)
         return(rtp);   /* just update and exit */
 2044a14:	e0bff917 	ldw	r2,-28(fp)
 2044a18:	00009a06 	br	2044c84 <add_route+0x3d8>
      }
      /* if we didn't find empty slot yet, look for good slot to recycle */
      if (!newrt || (newrt->ipRouteProto != 0))
 2044a1c:	e0bffa17 	ldw	r2,-24(fp)
 2044a20:	10000326 	beq	r2,zero,2044a30 <add_route+0x184>
 2044a24:	e0bffa17 	ldw	r2,-24(fp)
 2044a28:	10800817 	ldw	r2,32(r2)
 2044a2c:	10004826 	beq	r2,zero,2044b50 <add_route+0x2a4>
      {
         if (!rtp->ipRouteNextHop)  /* found empty slot for use */
 2044a30:	e0bff917 	ldw	r2,-28(fp)
 2044a34:	10800617 	ldw	r2,24(r2)
 2044a38:	1000051e 	bne	r2,zero,2044a50 <add_route+0x1a4>
         {
            newrt = rtp;   /* record empty route for use */
 2044a3c:	e0bff917 	ldw	r2,-28(fp)
 2044a40:	e0bffa15 	stw	r2,-24(fp)
            newrt->ipRouteProto = 0;
 2044a44:	e0bffa17 	ldw	r2,-24(fp)
 2044a48:	10000815 	stw	zero,32(r2)
            continue;
 2044a4c:	00004006 	br	2044b50 <add_route+0x2a4>
         }
         /* else see if the new route has higher priority than this slot: */
         if (rtp_priority[prot] >= rtp_priority[rtp->ipRouteProto])
 2044a50:	00c08174 	movhi	r3,517
 2044a54:	18cfcc04 	addi	r3,r3,16176
 2044a58:	e0800217 	ldw	r2,8(fp)
 2044a5c:	1885883a 	add	r2,r3,r2
 2044a60:	10c00003 	ldbu	r3,0(r2)
 2044a64:	e0bff917 	ldw	r2,-28(fp)
 2044a68:	10800817 	ldw	r2,32(r2)
 2044a6c:	01008174 	movhi	r4,517
 2044a70:	210fcc04 	addi	r4,r4,16176
 2044a74:	2085883a 	add	r2,r4,r2
 2044a78:	10800003 	ldbu	r2,0(r2)
 2044a7c:	18c03fcc 	andi	r3,r3,255
 2044a80:	10803fcc 	andi	r2,r2,255
 2044a84:	18803236 	bltu	r3,r2,2044b50 <add_route+0x2a4>
         {
            if (!newrt)
 2044a88:	e0bffa17 	ldw	r2,-24(fp)
 2044a8c:	1000031e 	bne	r2,zero,2044a9c <add_route+0x1f0>
            {
               newrt = rtp;
 2044a90:	e0bff917 	ldw	r2,-28(fp)
 2044a94:	e0bffa15 	stw	r2,-24(fp)
               continue;
 2044a98:	00002d06 	br	2044b50 <add_route+0x2a4>
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 2044a9c:	e0bff917 	ldw	r2,-28(fp)
 2044aa0:	10800817 	ldw	r2,32(r2)
 2044aa4:	00c08174 	movhi	r3,517
 2044aa8:	18cfcc04 	addi	r3,r3,16176
 2044aac:	1885883a 	add	r2,r3,r2
 2044ab0:	10c00003 	ldbu	r3,0(r2)
                rtp_priority[newrt->ipRouteProto])
 2044ab4:	e0bffa17 	ldw	r2,-24(fp)
 2044ab8:	10800817 	ldw	r2,32(r2)
 2044abc:	01008174 	movhi	r4,517
 2044ac0:	210fcc04 	addi	r4,r4,16176
 2044ac4:	2085883a 	add	r2,r4,r2
 2044ac8:	10800003 	ldbu	r2,0(r2)
               newrt = rtp;
               continue;
            }

            /* see if rtp is less important then newrtp */
            if (rtp_priority[rtp->ipRouteProto] < 
 2044acc:	18c03fcc 	andi	r3,r3,255
 2044ad0:	10803fcc 	andi	r2,r2,255
 2044ad4:	1880032e 	bgeu	r3,r2,2044ae4 <add_route+0x238>
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
 2044ad8:	e0bff917 	ldw	r2,-28(fp)
 2044adc:	e0bffa15 	stw	r2,-24(fp)
 2044ae0:	00001b06 	br	2044b50 <add_route+0x2a4>
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 2044ae4:	e0bff917 	ldw	r2,-28(fp)
 2044ae8:	10800817 	ldw	r2,32(r2)
 2044aec:	00c08174 	movhi	r3,517
 2044af0:	18cfcc04 	addi	r3,r3,16176
 2044af4:	1885883a 	add	r2,r3,r2
 2044af8:	10c00003 	ldbu	r3,0(r2)
                rtp_priority[newrt->ipRouteProto])
 2044afc:	e0bffa17 	ldw	r2,-24(fp)
 2044b00:	10800817 	ldw	r2,32(r2)
 2044b04:	01008174 	movhi	r4,517
 2044b08:	210fcc04 	addi	r4,r4,16176
 2044b0c:	2085883a 	add	r2,r4,r2
 2044b10:	10800003 	ldbu	r2,0(r2)
            if (rtp_priority[rtp->ipRouteProto] < 
                rtp_priority[newrt->ipRouteProto])
            {
               newrt = rtp;   /* save lower priority entry for recycle */
            }
            else if(rtp_priority[rtp->ipRouteProto] == 
 2044b14:	18c03fcc 	andi	r3,r3,255
 2044b18:	10803fcc 	andi	r2,r2,255
 2044b1c:	18800c1e 	bne	r3,r2,2044b50 <add_route+0x2a4>
                rtp_priority[newrt->ipRouteProto])
            {
               /* if equal priority, keep the older entry for deletion */
               if (c_older(rtp->ipRouteAge, newrt->ipRouteAge) == rtp->ipRouteAge)
 2044b20:	e0bff917 	ldw	r2,-28(fp)
 2044b24:	10c00917 	ldw	r3,36(r2)
 2044b28:	e0bffa17 	ldw	r2,-24(fp)
 2044b2c:	10800917 	ldw	r2,36(r2)
 2044b30:	1809883a 	mov	r4,r3
 2044b34:	100b883a 	mov	r5,r2
 2044b38:	20245880 	call	2024588 <c_older>
 2044b3c:	e0fff917 	ldw	r3,-28(fp)
 2044b40:	18c00917 	ldw	r3,36(r3)
 2044b44:	10c0021e 	bne	r2,r3,2044b50 <add_route+0x2a4>
                  newrt = rtp;   /* got an older one */
 2044b48:	e0bff917 	ldw	r2,-28(fp)
 2044b4c:	e0bffa15 	stw	r2,-24(fp)
   }



   /* if it's already in the route table, just update it. */
   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 2044b50:	e0bff917 	ldw	r2,-28(fp)
 2044b54:	10800f04 	addi	r2,r2,60
 2044b58:	e0bff915 	stw	r2,-28(fp)
 2044b5c:	00808174 	movhi	r2,517
 2044b60:	1090e604 	addi	r2,r2,17304
 2044b64:	10c00017 	ldw	r3,0(r2)
 2044b68:	00808174 	movhi	r2,517
 2044b6c:	10908004 	addi	r2,r2,16896
 2044b70:	10800017 	ldw	r2,0(r2)
 2044b74:	10800f24 	muli	r2,r2,60
 2044b78:	1885883a 	add	r2,r3,r2
 2044b7c:	e0fff917 	ldw	r3,-28(fp)
 2044b80:	18bf8b36 	bltu	r3,r2,20449b0 <add_route+0x104>
         }
      }
   }

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
 2044b84:	e0bffa17 	ldw	r2,-24(fp)
 2044b88:	10002926 	beq	r2,zero,2044c30 <add_route+0x384>
      rtp = newrt;   /* create new entry in lowest priority slot */
 2044b8c:	e0bffa17 	ldw	r2,-24(fp)
 2044b90:	e0bff915 	stw	r2,-28(fp)
   else  /* all slots have higher priority, new entry looses */
      return NULL;

   /* set default value in new route entry, caller can modiy further. */
   rtp->ifp = ifp;
 2044b94:	e0bff917 	ldw	r2,-28(fp)
 2044b98:	e0fffb17 	ldw	r3,-20(fp)
 2044b9c:	10c00e15 	stw	r3,56(r2)
   rtp->ipRouteDest = dest;
 2044ba0:	e0bff917 	ldw	r2,-28(fp)
 2044ba4:	e0fffc17 	ldw	r3,-16(fp)
 2044ba8:	10c00015 	stw	r3,0(r2)
   rtp->ipRouteIfIndex = (long)(if_netnumber(ifp)) + 1; /* set interface number */
 2044bac:	e13ffb17 	ldw	r4,-20(fp)
 2044bb0:	2024bac0 	call	2024bac <if_netnumber>
 2044bb4:	10c00044 	addi	r3,r2,1
 2044bb8:	e0bff917 	ldw	r2,-28(fp)
 2044bbc:	10c00115 	stw	r3,4(r2)
   rtp->ipRouteMetric1 = ip_mib.ipDefaultTTL;
 2044bc0:	00809934 	movhi	r2,612
 2044bc4:	10b7d304 	addi	r2,r2,-8372
 2044bc8:	10800117 	ldw	r2,4(r2)
 2044bcc:	1007883a 	mov	r3,r2
 2044bd0:	e0bff917 	ldw	r2,-28(fp)
 2044bd4:	10c00215 	stw	r3,8(r2)
   rtp->ipRouteMetric2 = -1;
 2044bd8:	e0bff917 	ldw	r2,-28(fp)
 2044bdc:	00ffffc4 	movi	r3,-1
 2044be0:	10c00315 	stw	r3,12(r2)
   rtp->ipRouteMetric3 = -1;
 2044be4:	e0bff917 	ldw	r2,-28(fp)
 2044be8:	00ffffc4 	movi	r3,-1
 2044bec:	10c00415 	stw	r3,16(r2)
   rtp->ipRouteMetric4 = -1;
 2044bf0:	e0bff917 	ldw	r2,-28(fp)
 2044bf4:	00ffffc4 	movi	r3,-1
 2044bf8:	10c00515 	stw	r3,20(r2)
   rtp->ipRouteNextHop = nexthop;
 2044bfc:	e0bff917 	ldw	r2,-28(fp)
 2044c00:	e0fffe17 	ldw	r3,-8(fp)
 2044c04:	10c00615 	stw	r3,24(r2)
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */
 2044c08:	e0bff917 	ldw	r2,-28(fp)
 2044c0c:	e0c00217 	ldw	r3,8(fp)
 2044c10:	10c00815 	stw	r3,32(r2)

   if ((dest & mask) == (nexthop & mask))
 2044c14:	e0fffc17 	ldw	r3,-16(fp)
 2044c18:	e0bffe17 	ldw	r2,-8(fp)
 2044c1c:	1886f03a 	xor	r3,r3,r2
 2044c20:	e0bffd17 	ldw	r2,-12(fp)
 2044c24:	1884703a 	and	r2,r3,r2
 2044c28:	10000326 	beq	r2,zero,2044c38 <add_route+0x38c>
 2044c2c:	00000606 	br	2044c48 <add_route+0x39c>

   /* fall to here if not in table: create a new route */
   if (newrt)  /* did we find an empty or lower priority route entry? */
      rtp = newrt;   /* create new entry in lowest priority slot */
   else  /* all slots have higher priority, new entry looses */
      return NULL;
 2044c30:	0005883a 	mov	r2,zero
 2044c34:	00001306 	br	2044c84 <add_route+0x3d8>
   rtp->ipRouteMetric4 = -1;
   rtp->ipRouteNextHop = nexthop;
   rtp->ipRouteProto = prot;                 /* icmp, or whatever */

   if ((dest & mask) == (nexthop & mask))
      rtp->ipRouteType = IPRT_DIRECT;
 2044c38:	e0bff917 	ldw	r2,-28(fp)
 2044c3c:	00c000c4 	movi	r3,3
 2044c40:	10c00715 	stw	r3,28(r2)
 2044c44:	00000306 	br	2044c54 <add_route+0x3a8>
   else
      rtp->ipRouteType = IPRT_INDIRECT;
 2044c48:	e0bff917 	ldw	r2,-28(fp)
 2044c4c:	00c00104 	movi	r3,4
 2044c50:	10c00715 	stw	r3,28(r2)

   rtp->ipRouteAge = cticks;        /* timestamp it */
 2044c54:	00808174 	movhi	r2,517
 2044c58:	1090c904 	addi	r2,r2,17188
 2044c5c:	10c00017 	ldw	r3,0(r2)
 2044c60:	e0bff917 	ldw	r2,-28(fp)
 2044c64:	10c00915 	stw	r3,36(r2)
   rtp->ipRouteMask = mask;
 2044c68:	e0bff917 	ldw	r2,-28(fp)
 2044c6c:	e0fffd17 	ldw	r3,-12(fp)
 2044c70:	10c00a15 	stw	r3,40(r2)
   rtp->ipRouteMetric5 = -1;
 2044c74:	e0bff917 	ldw	r2,-28(fp)
 2044c78:	00ffffc4 	movi	r3,-1
 2044c7c:	10c00b15 	stw	r3,44(r2)
   return(rtp);
 2044c80:	e0bff917 	ldw	r2,-28(fp)
}
 2044c84:	e037883a 	mov	sp,fp
 2044c88:	dfc00117 	ldw	ra,4(sp)
 2044c8c:	df000017 	ldw	fp,0(sp)
 2044c90:	dec00204 	addi	sp,sp,8
 2044c94:	f800283a 	ret

02044c98 <del_route>:
 * RETURNS: Returns number of route table entries deleted. 
 */

int
del_route(ip_addr dest, ip_addr mask, int iface)
{
 2044c98:	defff804 	addi	sp,sp,-32
 2044c9c:	dfc00715 	stw	ra,28(sp)
 2044ca0:	df000615 	stw	fp,24(sp)
 2044ca4:	df000604 	addi	fp,sp,24
 2044ca8:	e13ffd15 	stw	r4,-12(fp)
 2044cac:	e17ffe15 	stw	r5,-8(fp)
 2044cb0:	e1bfff15 	stw	r6,-4(fp)
   RTMIB rtp;
   int   retval   =  0;
 2044cb4:	e03ffb15 	stw	zero,-20(fp)

   /* set the route interface pointer according to the index passed. This allows 
    * the passed index to be used to access dynamic interfaces, which do not appear 
    * in the nets[] array.
    */
   if(iface == -1)
 2044cb8:	e0bfff17 	ldw	r2,-4(fp)
 2044cbc:	10bfffd8 	cmpnei	r2,r2,-1
 2044cc0:	1000021e 	bne	r2,zero,2044ccc <del_route+0x34>
      ifp = NULL;    /* wildcard */
 2044cc4:	e03ffc15 	stw	zero,-16(fp)
 2044cc8:	00000306 	br	2044cd8 <del_route+0x40>
   else
      ifp = if_getbynum(iface);
 2044ccc:	e13fff17 	ldw	r4,-4(fp)
 2044cd0:	203f15c0 	call	203f15c <if_getbynum>
 2044cd4:	e0bffc15 	stw	r2,-16(fp)

   if (rt_mib == NULL)     /* Make sure we're up */
 2044cd8:	00808174 	movhi	r2,517
 2044cdc:	1090e604 	addi	r2,r2,17304
 2044ce0:	10800017 	ldw	r2,0(r2)
 2044ce4:	1000021e 	bne	r2,zero,2044cf0 <del_route+0x58>
      return 0;
 2044ce8:	0005883a 	mov	r2,zero
 2044cec:	00003206 	br	2044db8 <del_route+0x120>

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 2044cf0:	00808174 	movhi	r2,517
 2044cf4:	1090e604 	addi	r2,r2,17304
 2044cf8:	10800017 	ldw	r2,0(r2)
 2044cfc:	e0bffa15 	stw	r2,-24(fp)
 2044d00:	00002206 	br	2044d8c <del_route+0xf4>
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
 2044d04:	e0bffa17 	ldw	r2,-24(fp)
 2044d08:	10800617 	ldw	r2,24(r2)
 2044d0c:	10001926 	beq	r2,zero,2044d74 <del_route+0xdc>
         continue;
      if(ifp != NULL && ifp != rtp->ifp)
 2044d10:	e0bffc17 	ldw	r2,-16(fp)
 2044d14:	10000426 	beq	r2,zero,2044d28 <del_route+0x90>
 2044d18:	e0bffa17 	ldw	r2,-24(fp)
 2044d1c:	10c00e17 	ldw	r3,56(r2)
 2044d20:	e0bffc17 	ldw	r2,-16(fp)
 2044d24:	1880151e 	bne	r3,r2,2044d7c <del_route+0xe4>
         continue;   /* interface didn't match */
      if ((rtp->ipRouteDest & mask) == (dest & mask))
 2044d28:	e0bffa17 	ldw	r2,-24(fp)
 2044d2c:	10c00017 	ldw	r3,0(r2)
 2044d30:	e0bffd17 	ldw	r2,-12(fp)
 2044d34:	1886f03a 	xor	r3,r3,r2
 2044d38:	e0bffe17 	ldw	r2,-8(fp)
 2044d3c:	1884703a 	and	r2,r3,r2
 2044d40:	1000071e 	bne	r2,zero,2044d60 <del_route+0xc8>
      {
         MEMSET(rtp, 0, sizeof(*rtp)); /* clear entry */
 2044d44:	e13ffa17 	ldw	r4,-24(fp)
 2044d48:	000b883a 	mov	r5,zero
 2044d4c:	01800f04 	movi	r6,60
 2044d50:	200682c0 	call	200682c <memset>
         retval++;
 2044d54:	e0bffb17 	ldw	r2,-20(fp)
 2044d58:	10800044 	addi	r2,r2,1
 2044d5c:	e0bffb15 	stw	r2,-20(fp)
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
 2044d60:	d0e0c617 	ldw	r3,-31976(gp)
 2044d64:	e0bffa17 	ldw	r2,-24(fp)
 2044d68:	1880051e 	bne	r3,r2,2044d80 <del_route+0xe8>
         cachedRoute = NULL;
 2044d6c:	d020c615 	stw	zero,-31976(gp)
 2044d70:	00000306 	br	2044d80 <del_route+0xe8>
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
   {
      if (!rtp->ipRouteNextHop)  /* empty slot */
         continue;
 2044d74:	0001883a 	nop
 2044d78:	00000106 	br	2044d80 <del_route+0xe8>
      if(ifp != NULL && ifp != rtp->ifp)
         continue;   /* interface didn't match */
 2044d7c:	0001883a 	nop
      ifp = if_getbynum(iface);

   if (rt_mib == NULL)     /* Make sure we're up */
      return 0;

   for (rtp = rt_mib; rtp < rt_mib + ipRoutes; rtp++)
 2044d80:	e0bffa17 	ldw	r2,-24(fp)
 2044d84:	10800f04 	addi	r2,r2,60
 2044d88:	e0bffa15 	stw	r2,-24(fp)
 2044d8c:	00808174 	movhi	r2,517
 2044d90:	1090e604 	addi	r2,r2,17304
 2044d94:	10c00017 	ldw	r3,0(r2)
 2044d98:	00808174 	movhi	r2,517
 2044d9c:	10908004 	addi	r2,r2,16896
 2044da0:	10800017 	ldw	r2,0(r2)
 2044da4:	10800f24 	muli	r2,r2,60
 2044da8:	1885883a 	add	r2,r3,r2
 2044dac:	e0fffa17 	ldw	r3,-24(fp)
 2044db0:	18bfd436 	bltu	r3,r2,2044d04 <del_route+0x6c>
         retval++;
      }
      if (cachedRoute == rtp) /* clear cache if it's being deleted */
         cachedRoute = NULL;
   }
   return retval;
 2044db4:	e0bffb17 	ldw	r2,-20(fp)
}
 2044db8:	e037883a 	mov	sp,fp
 2044dbc:	dfc00117 	ldw	ra,4(sp)
 2044dc0:	df000017 	ldw	fp,0(sp)
 2044dc4:	dec00204 	addi	sp,sp,8
 2044dc8:	f800283a 	ret

02044dcc <udpdemux>:
 * RETURNS: 0 if OK or ENP error code
 */

int
udpdemux(PACKET p)
{
 2044dcc:	deffec04 	addi	sp,sp,-80
 2044dd0:	dfc01315 	stw	ra,76(sp)
 2044dd4:	df001215 	stw	fp,72(sp)
 2044dd8:	df001204 	addi	fp,sp,72
 2044ddc:	e13fff15 	stw	r4,-4(fp)
   unsigned short osum, xsum; /* scratch checksum holders */
   unsigned plen; /* packet length */
   int   e;    /* general error holder */

   /* First let's verify that it's a valid UDP packet. */
   pip = ip_head(p);       /* we'll need IP header info */
 2044de0:	e0bfff17 	ldw	r2,-4(fp)
 2044de4:	10800317 	ldw	r2,12(r2)
 2044de8:	e0bff615 	stw	r2,-40(fp)
   pup = (struct udp*)ip_data(pip);   /*  also need UDP header */
 2044dec:	e0bff617 	ldw	r2,-40(fp)
 2044df0:	10800003 	ldbu	r2,0(r2)
 2044df4:	10803fcc 	andi	r2,r2,255
 2044df8:	108003cc 	andi	r2,r2,15
 2044dfc:	1085883a 	add	r2,r2,r2
 2044e00:	1085883a 	add	r2,r2,r2
 2044e04:	e0fff617 	ldw	r3,-40(fp)
 2044e08:	1885883a 	add	r2,r3,r2
 2044e0c:	e0bff715 	stw	r2,-36(fp)
   plen = htons(pup->ud_len);
 2044e10:	e0bff717 	ldw	r2,-36(fp)
 2044e14:	1080010b 	ldhu	r2,4(r2)
 2044e18:	10bfffcc 	andi	r2,r2,65535
 2044e1c:	1004d23a 	srli	r2,r2,8
 2044e20:	10bfffcc 	andi	r2,r2,65535
 2044e24:	10c03fcc 	andi	r3,r2,255
 2044e28:	e0bff717 	ldw	r2,-36(fp)
 2044e2c:	1080010b 	ldhu	r2,4(r2)
 2044e30:	10bfffcc 	andi	r2,r2,65535
 2044e34:	1004923a 	slli	r2,r2,8
 2044e38:	10bfffcc 	andi	r2,r2,65535
 2044e3c:	1884b03a 	or	r2,r3,r2
 2044e40:	e0bff815 	stw	r2,-32(fp)

   if (plen > p->nb_plen)
 2044e44:	e0bfff17 	ldw	r2,-4(fp)
 2044e48:	10c00417 	ldw	r3,16(r2)
 2044e4c:	e0bff817 	ldw	r2,-32(fp)
 2044e50:	1880292e 	bgeu	r3,r2,2044ef8 <udpdemux+0x12c>
#ifdef   NPDEBUG
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 2044e54:	00808174 	movhi	r2,517
 2044e58:	1090b204 	addi	r2,r2,17096
 2044e5c:	10800017 	ldw	r2,0(r2)
 2044e60:	1081000c 	andi	r2,r2,1024
 2044e64:	10001926 	beq	r2,zero,2044ecc <udpdemux+0x100>
 2044e68:	00808174 	movhi	r2,517
 2044e6c:	1090b204 	addi	r2,r2,17096
 2044e70:	10800017 	ldw	r2,0(r2)
 2044e74:	1080400c 	andi	r2,r2,256
 2044e78:	10001426 	beq	r2,zero,2044ecc <udpdemux+0x100>
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 2044e7c:	e0bfff17 	ldw	r2,-4(fp)
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 2044e80:	10c00417 	ldw	r3,16(r2)
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
 2044e84:	e0bff717 	ldw	r2,-36(fp)
 2044e88:	1080010b 	ldhu	r2,4(r2)
 2044e8c:	10bfffcc 	andi	r2,r2,65535
 2044e90:	1004d23a 	srli	r2,r2,8
 2044e94:	10bfffcc 	andi	r2,r2,65535
 2044e98:	11003fcc 	andi	r4,r2,255
 2044e9c:	e0bff717 	ldw	r2,-36(fp)
 2044ea0:	1080010b 	ldhu	r2,4(r2)
 2044ea4:	10bfffcc 	andi	r2,r2,65535
 2044ea8:	1004923a 	slli	r2,r2,8
 2044eac:	10bfffcc 	andi	r2,r2,65535
 2044eb0:	2084b03a 	or	r2,r4,r2
/* 
 * Altera Niche Stack Nios port modification:
 * cast arg to unsigned long to remove build warning
 */
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         dprintf("UDP: bad len pkt: rcvd: %u, hdr: %u.\n",
 2044eb4:	10800204 	addi	r2,r2,8
 2044eb8:	01008174 	movhi	r4,517
 2044ebc:	21066b04 	addi	r4,r4,6572
 2044ec0:	180b883a 	mov	r5,r3
 2044ec4:	100d883a 	mov	r6,r2
 2044ec8:	2006a240 	call	2006a24 <printf>
                 p->nb_plen, (unsigned int)(htons(pup->ud_len) + UDPLEN));
#endif
      udp_mib.udpInErrors++;
 2044ecc:	00809934 	movhi	r2,612
 2044ed0:	10b7ed04 	addi	r2,r2,-8268
 2044ed4:	10800217 	ldw	r2,8(r2)
 2044ed8:	10c00044 	addi	r3,r2,1
 2044edc:	00809934 	movhi	r2,612
 2044ee0:	10b7ed04 	addi	r2,r2,-8268
 2044ee4:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 2044ee8:	e13fff17 	ldw	r4,-4(fp)
 2044eec:	2045b2c0 	call	2045b2c <udp_free>
      return ENP_BAD_HEADER;
 2044ef0:	00bff804 	movi	r2,-32
 2044ef4:	0001b606 	br	20455d0 <udpdemux+0x804>
   }

   osum = pup->ud_cksum;
 2044ef8:	e0bff717 	ldw	r2,-36(fp)
 2044efc:	1080018b 	ldhu	r2,6(r2)
 2044f00:	e0bff90d 	sth	r2,-28(fp)
   /* did other guy use checksumming? */
   if (osum)
 2044f04:	e0bff90b 	ldhu	r2,-28(fp)
 2044f08:	10005f26 	beq	r2,zero,2045088 <udpdemux+0x2bc>
   {
      if (plen & 1) ((char *)pup)[plen] = 0;
 2044f0c:	e0bff817 	ldw	r2,-32(fp)
 2044f10:	1080004c 	andi	r2,r2,1
 2044f14:	10000426 	beq	r2,zero,2044f28 <udpdemux+0x15c>
 2044f18:	e0fff717 	ldw	r3,-36(fp)
 2044f1c:	e0bff817 	ldw	r2,-32(fp)
 2044f20:	1885883a 	add	r2,r3,r2
 2044f24:	10000005 	stb	zero,0(r2)
         php.ph_src = p->fhost;
 2044f28:	e0bfff17 	ldw	r2,-4(fp)
 2044f2c:	10800717 	ldw	r2,28(r2)
 2044f30:	e0bffc15 	stw	r2,-16(fp)
      php.ph_dest = pip->ip_dest;
 2044f34:	e0bff617 	ldw	r2,-40(fp)
 2044f38:	10800417 	ldw	r2,16(r2)
 2044f3c:	e0bffd15 	stw	r2,-12(fp)
      php.ph_zero = 0;
 2044f40:	e03ffe05 	stb	zero,-8(fp)
      php.ph_prot = UDP_PROT;
 2044f44:	00800444 	movi	r2,17
 2044f48:	e0bffe45 	stb	r2,-7(fp)
      php.ph_len  = pup->ud_len;
 2044f4c:	e0bff717 	ldw	r2,-36(fp)
 2044f50:	1080010b 	ldhu	r2,4(r2)
 2044f54:	e0bffe8d 	sth	r2,-6(fp)

      pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 2044f58:	e0bffc04 	addi	r2,fp,-16
 2044f5c:	1009883a 	mov	r4,r2
 2044f60:	01400184 	movi	r5,6
 2044f64:	20268040 	call	2026804 <cksum>
 2044f68:	e0fff717 	ldw	r3,-36(fp)
 2044f6c:	1880018d 	sth	r2,6(r3)
      xsum = ~cksum(pup, (plen+1)>>1);
 2044f70:	e0bff817 	ldw	r2,-32(fp)
 2044f74:	10800044 	addi	r2,r2,1
 2044f78:	1004d07a 	srli	r2,r2,1
 2044f7c:	e13ff717 	ldw	r4,-36(fp)
 2044f80:	100b883a 	mov	r5,r2
 2044f84:	20268040 	call	2026804 <cksum>
 2044f88:	0084303a 	nor	r2,zero,r2
 2044f8c:	e0bff30d 	sth	r2,-52(fp)
      if (!xsum)
 2044f90:	e0bff30b 	ldhu	r2,-52(fp)
 2044f94:	1000021e 	bne	r2,zero,2044fa0 <udpdemux+0x1d4>
         xsum = 0xffff;
 2044f98:	00bfffc4 	movi	r2,-1
 2044f9c:	e0bff30d 	sth	r2,-52(fp)
      pup->ud_cksum = osum;
 2044fa0:	e0bff717 	ldw	r2,-36(fp)
 2044fa4:	e0fff90b 	ldhu	r3,-28(fp)
 2044fa8:	10c0018d 	sth	r3,6(r2)
      if (xsum != osum)
 2044fac:	e0fff30b 	ldhu	r3,-52(fp)
 2044fb0:	e0bff90b 	ldhu	r2,-28(fp)
 2044fb4:	18803426 	beq	r3,r2,2045088 <udpdemux+0x2bc>
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 2044fb8:	00808174 	movhi	r2,517
 2044fbc:	1090b204 	addi	r2,r2,17096
 2044fc0:	10800017 	ldw	r2,0(r2)
 2044fc4:	1081000c 	andi	r2,r2,1024
 2044fc8:	10002426 	beq	r2,zero,204505c <udpdemux+0x290>
 2044fcc:	00808174 	movhi	r2,517
 2044fd0:	1090b204 	addi	r2,r2,17096
 2044fd4:	10800017 	ldw	r2,0(r2)
 2044fd8:	1080400c 	andi	r2,r2,256
 2044fdc:	10001f26 	beq	r2,zero,204505c <udpdemux+0x290>
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 2044fe0:	e17ff90b 	ldhu	r5,-28(fp)
 2044fe4:	e0fff30b 	ldhu	r3,-52(fp)
                    osum, xsum, PUSH_IPADDR(p->fhost));
 2044fe8:	e0bfff17 	ldw	r2,-4(fp)
 2044fec:	10800717 	ldw	r2,28(r2)
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 2044ff0:	10803fcc 	andi	r2,r2,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 2044ff4:	e13fff17 	ldw	r4,-4(fp)
 2044ff8:	21000717 	ldw	r4,28(r4)
 2044ffc:	2008d23a 	srli	r4,r4,8
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 2045000:	21c03fcc 	andi	r7,r4,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 2045004:	e13fff17 	ldw	r4,-4(fp)
 2045008:	21000717 	ldw	r4,28(r4)
 204500c:	2008d43a 	srli	r4,r4,16
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 2045010:	21803fcc 	andi	r6,r4,255
                    osum, xsum, PUSH_IPADDR(p->fhost));
 2045014:	e13fff17 	ldw	r4,-4(fp)
 2045018:	21000717 	ldw	r4,28(r4)
 204501c:	2008d63a 	srli	r4,r4,24
      if (xsum != osum)
      {
#ifdef   NPDEBUG
         if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
         {
            dprintf("UDPDEMUX: bad xsum %04x right %04x from %u.%u.%u.%u\n",
 2045020:	d9c00015 	stw	r7,0(sp)
 2045024:	d9800115 	stw	r6,4(sp)
 2045028:	d9000215 	stw	r4,8(sp)
 204502c:	01008174 	movhi	r4,517
 2045030:	21067504 	addi	r4,r4,6612
 2045034:	180d883a 	mov	r6,r3
 2045038:	100f883a 	mov	r7,r2
 204503c:	2006a240 	call	2006a24 <printf>
                    osum, xsum, PUSH_IPADDR(p->fhost));
            if (NDEBUG & DUMP)
 2045040:	00808174 	movhi	r2,517
 2045044:	1090b204 	addi	r2,r2,17096
 2045048:	10800017 	ldw	r2,0(r2)
 204504c:	1080008c 	andi	r2,r2,2
 2045050:	10000226 	beq	r2,zero,204505c <udpdemux+0x290>
               ip_dump(p);
 2045054:	e13fff17 	ldw	r4,-4(fp)
 2045058:	2040e3c0 	call	2040e3c <ip_dump>
         }
#endif
         udp_mib.udpInErrors++;
 204505c:	00809934 	movhi	r2,612
 2045060:	10b7ed04 	addi	r2,r2,-8268
 2045064:	10800217 	ldw	r2,8(r2)
 2045068:	10c00044 	addi	r3,r2,1
 204506c:	00809934 	movhi	r2,612
 2045070:	10b7ed04 	addi	r2,r2,-8268
 2045074:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 2045078:	e13fff17 	ldw	r4,-4(fp)
 204507c:	2045b2c0 	call	2045b2c <udp_free>
         return ENP_BAD_HEADER;
 2045080:	00bff804 	movi	r2,-32
 2045084:	00015206 	br	20455d0 <udpdemux+0x804>
      }
   }

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 2045088:	e13ff717 	ldw	r4,-36(fp)
 204508c:	20458840 	call	2045884 <udpswap>
#endif

   /* Prior to upcall, adjust nb_prot for size of IP and UDP headers */
   e = (sizeof(struct udp) + ip_hlen(pip));
 2045090:	e0bff617 	ldw	r2,-40(fp)
 2045094:	10800003 	ldbu	r2,0(r2)
 2045098:	10803fcc 	andi	r2,r2,255
 204509c:	108003cc 	andi	r2,r2,15
 20450a0:	1085883a 	add	r2,r2,r2
 20450a4:	1085883a 	add	r2,r2,r2
 20450a8:	10800204 	addi	r2,r2,8
 20450ac:	e0bff415 	stw	r2,-48(fp)
   p->nb_plen -= e;
 20450b0:	e0bfff17 	ldw	r2,-4(fp)
 20450b4:	10c00417 	ldw	r3,16(r2)
 20450b8:	e0bff417 	ldw	r2,-48(fp)
 20450bc:	1887c83a 	sub	r3,r3,r2
 20450c0:	e0bfff17 	ldw	r2,-4(fp)
 20450c4:	10c00415 	stw	r3,16(r2)
   p->nb_prot += e;
 20450c8:	e0bfff17 	ldw	r2,-4(fp)
 20450cc:	10c00317 	ldw	r3,12(r2)
 20450d0:	e0bff417 	ldw	r2,-48(fp)
 20450d4:	1887883a 	add	r3,r3,r2
 20450d8:	e0bfff17 	ldw	r2,-4(fp)
 20450dc:	10c00315 	stw	r3,12(r2)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 20450e0:	00808174 	movhi	r2,517
 20450e4:	1090b204 	addi	r2,r2,17096
 20450e8:	10800017 	ldw	r2,0(r2)
 20450ec:	1081000c 	andi	r2,r2,1024
 20450f0:	10002326 	beq	r2,zero,2045180 <udpdemux+0x3b4>
 20450f4:	00808174 	movhi	r2,517
 20450f8:	1090b204 	addi	r2,r2,17096
 20450fc:	10800017 	ldw	r2,0(r2)
 2045100:	1080400c 	andi	r2,r2,256
 2045104:	10001e26 	beq	r2,zero,2045180 <udpdemux+0x3b4>
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 2045108:	e0bfff17 	ldw	r2,-4(fp)
 204510c:	10800717 	ldw	r2,28(r2)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 2045110:	10c03fcc 	andi	r3,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 2045114:	e0bfff17 	ldw	r2,-4(fp)
 2045118:	10800717 	ldw	r2,28(r2)
 204511c:	1004d23a 	srli	r2,r2,8
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 2045120:	10803fcc 	andi	r2,r2,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 2045124:	e13fff17 	ldw	r4,-4(fp)
 2045128:	21000717 	ldw	r4,28(r4)
 204512c:	2008d43a 	srli	r4,r4,16
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 2045130:	21c03fcc 	andi	r7,r4,255
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 2045134:	e13fff17 	ldw	r4,-4(fp)
 2045138:	21000717 	ldw	r4,28(r4)
 204513c:	200cd63a 	srli	r6,r4,24
 2045140:	e13ff717 	ldw	r4,-36(fp)
 2045144:	2100000b 	ldhu	r4,0(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 2045148:	217fffcc 	andi	r5,r4,65535
       plen, PUSH_IPADDR(p->fhost), pup->ud_srcp, pup->ud_dstp);
 204514c:	e13ff717 	ldw	r4,-36(fp)
 2045150:	2100008b 	ldhu	r4,2(r4)
   p->nb_prot += e;

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
   {
      dprintf("UDP: pkt[%u] from %u.%u.%u.%u:%d to %d\n",
 2045154:	213fffcc 	andi	r4,r4,65535
 2045158:	d9c00015 	stw	r7,0(sp)
 204515c:	d9800115 	stw	r6,4(sp)
 2045160:	d9400215 	stw	r5,8(sp)
 2045164:	d9000315 	stw	r4,12(sp)
 2045168:	01008174 	movhi	r4,517
 204516c:	21068304 	addi	r4,r4,6668
 2045170:	e17ff817 	ldw	r5,-32(fp)
 2045174:	180d883a 	mov	r6,r3
 2045178:	100f883a 	mov	r7,r2
 204517c:	2006a240 	call	2006a24 <printf>
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 2045180:	00808174 	movhi	r2,517
 2045184:	1090f204 	addi	r2,r2,17352
 2045188:	10800017 	ldw	r2,0(r2)
 204518c:	e0bff215 	stw	r2,-56(fp)
 2045190:	0000ae06 	br	204544c <udpdemux+0x680>
         continue;
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
 2045194:	e0bff217 	ldw	r2,-56(fp)
 2045198:	1080018b 	ldhu	r2,6(r2)
 204519c:	10bfffcc 	andi	r2,r2,65535
 20451a0:	10000726 	beq	r2,zero,20451c0 <udpdemux+0x3f4>
 20451a4:	e0bff217 	ldw	r2,-56(fp)
 20451a8:	10c0018b 	ldhu	r3,6(r2)
 20451ac:	e0bff717 	ldw	r2,-36(fp)
 20451b0:	1080008b 	ldhu	r2,2(r2)
 20451b4:	18ffffcc 	andi	r3,r3,65535
 20451b8:	10bfffcc 	andi	r2,r2,65535
 20451bc:	1880991e 	bne	r3,r2,2045424 <udpdemux+0x658>
         continue;
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
 20451c0:	e0bff217 	ldw	r2,-56(fp)
 20451c4:	1080020b 	ldhu	r2,8(r2)
 20451c8:	10bfffcc 	andi	r2,r2,65535
 20451cc:	10000726 	beq	r2,zero,20451ec <udpdemux+0x420>
 20451d0:	e0bff217 	ldw	r2,-56(fp)
 20451d4:	10c0020b 	ldhu	r3,8(r2)
 20451d8:	e0bff717 	ldw	r2,-36(fp)
 20451dc:	1080000b 	ldhu	r2,0(r2)
 20451e0:	18ffffcc 	andi	r3,r3,65535
 20451e4:	10bfffcc 	andi	r2,r2,65535
 20451e8:	1880901e 	bne	r3,r2,204542c <udpdemux+0x660>
         continue;
      if (con->u_fhost && (con->u_fhost != p->fhost))
 20451ec:	e0bff217 	ldw	r2,-56(fp)
 20451f0:	10800417 	ldw	r2,16(r2)
 20451f4:	10000526 	beq	r2,zero,204520c <udpdemux+0x440>
 20451f8:	e0bff217 	ldw	r2,-56(fp)
 20451fc:	10c00417 	ldw	r3,16(r2)
 2045200:	e0bfff17 	ldw	r2,-4(fp)
 2045204:	10800717 	ldw	r2,28(r2)
 2045208:	18808a1e 	bne	r3,r2,2045434 <udpdemux+0x668>
#ifdef IP_MULTICAST
      /* In the case of multicast, check if there is multicast membership
       * attached to this socket and if so, is the incoming packet
       * addressed to the multicast address
       */
      if (IN_MULTICAST(ntohl(pip->ip_dest)))
 204520c:	e0bff617 	ldw	r2,-40(fp)
 2045210:	10800417 	ldw	r2,16(r2)
 2045214:	1006d63a 	srli	r3,r2,24
 2045218:	e0bff617 	ldw	r2,-40(fp)
 204521c:	10800417 	ldw	r2,16(r2)
 2045220:	1004d23a 	srli	r2,r2,8
 2045224:	10bfc00c 	andi	r2,r2,65280
 2045228:	1886b03a 	or	r3,r3,r2
 204522c:	e0bff617 	ldw	r2,-40(fp)
 2045230:	10800417 	ldw	r2,16(r2)
 2045234:	10bfc00c 	andi	r2,r2,65280
 2045238:	1004923a 	slli	r2,r2,8
 204523c:	1886b03a 	or	r3,r3,r2
 2045240:	e0bff617 	ldw	r2,-40(fp)
 2045244:	10800417 	ldw	r2,16(r2)
 2045248:	1004963a 	slli	r2,r2,24
 204524c:	1884b03a 	or	r2,r3,r2
 2045250:	10fc002c 	andhi	r3,r2,61440
 2045254:	00b80034 	movhi	r2,57344
 2045258:	1880301e 	bne	r3,r2,204531c <udpdemux+0x550>
      {
         struct socket *soptr = (struct socket *)con->u_data;
 204525c:	e0bff217 	ldw	r2,-56(fp)
 2045260:	10800617 	ldw	r2,24(r2)
 2045264:	e0bffa15 	stw	r2,-24(fp)

         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
 2045268:	e0bff217 	ldw	r2,-56(fp)
 204526c:	10c00517 	ldw	r3,20(r2)
 2045270:	008080f4 	movhi	r2,515
 2045274:	10983b04 	addi	r2,r2,24812
 2045278:	1880281e 	bne	r3,r2,204531c <udpdemux+0x550>
 204527c:	e0bffa17 	ldw	r2,-24(fp)
 2045280:	10800317 	ldw	r2,12(r2)
 2045284:	10002526 	beq	r2,zero,204531c <udpdemux+0x550>
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;
 2045288:	e0bffa17 	ldw	r2,-24(fp)
 204528c:	10800317 	ldw	r2,12(r2)
 2045290:	e0bffb15 	stw	r2,-20(fp)

            for (i = 0; i < imo->imo_num_memberships; ++i)
 2045294:	e03ff50d 	sth	zero,-44(fp)
 2045298:	00001906 	br	2045300 <udpdemux+0x534>
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 204529c:	e0bff50b 	ldhu	r2,-44(fp)
 20452a0:	e0fffb17 	ldw	r3,-20(fp)
 20452a4:	10800084 	addi	r2,r2,2
 20452a8:	1085883a 	add	r2,r2,r2
 20452ac:	1085883a 	add	r2,r2,r2
 20452b0:	1885883a 	add	r2,r3,r2
 20452b4:	10800017 	ldw	r2,0(r2)
 20452b8:	10c00117 	ldw	r3,4(r2)
 20452bc:	e0bfff17 	ldw	r2,-4(fp)
 20452c0:	10800617 	ldw	r2,24(r2)
 20452c4:	18800b1e 	bne	r3,r2,20452f4 <udpdemux+0x528>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
 20452c8:	e0bff50b 	ldhu	r2,-44(fp)
 20452cc:	e0fffb17 	ldw	r3,-20(fp)
 20452d0:	10800084 	addi	r2,r2,2
 20452d4:	1085883a 	add	r2,r2,r2
 20452d8:	1085883a 	add	r2,r2,r2
 20452dc:	1885883a 	add	r2,r3,r2
 20452e0:	10800017 	ldw	r2,0(r2)
 20452e4:	10c00017 	ldw	r3,0(r2)
 20452e8:	e0bff617 	ldw	r2,-40(fp)
 20452ec:	10800417 	ldw	r2,16(r2)
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
 20452f0:	18800926 	beq	r3,r2,2045318 <udpdemux+0x54c>
         if ((con->u_rcv == udp_soinput) && (soptr->inp_moptions != NULL))
         {
            u_short  i;
            struct ip_moptions *imo = soptr->inp_moptions;

            for (i = 0; i < imo->imo_num_memberships; ++i)
 20452f4:	e0bff50b 	ldhu	r2,-44(fp)
 20452f8:	10800044 	addi	r2,r2,1
 20452fc:	e0bff50d 	sth	r2,-44(fp)
 2045300:	e0bffb17 	ldw	r2,-20(fp)
 2045304:	1080018b 	ldhu	r2,6(r2)
 2045308:	10bfffcc 	andi	r2,r2,65535
 204530c:	e0fff50b 	ldhu	r3,-44(fp)
 2045310:	18bfe236 	bltu	r3,r2,204529c <udpdemux+0x4d0>
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
               }
            }
            continue;
 2045314:	00004a06 	br	2045440 <udpdemux+0x674>
            for (i = 0; i < imo->imo_num_memberships; ++i)
            {
               if ((imo->imo_membership[i]->inm_netp == p->net) &&
                   (imo->imo_membership[i]->inm_addr == pip->ip_dest))
               {
                  goto found;
 2045318:	0001883a 	nop
#endif /* INCLUDE_TCP */

      /* if this endpoint has been bound to a local interface address,
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
 204531c:	e0bff617 	ldw	r2,-40(fp)
 2045320:	10800417 	ldw	r2,16(r2)
 2045324:	1006d63a 	srli	r3,r2,24
 2045328:	e0bff617 	ldw	r2,-40(fp)
 204532c:	10800417 	ldw	r2,16(r2)
 2045330:	1004d23a 	srli	r2,r2,8
 2045334:	10bfc00c 	andi	r2,r2,65280
 2045338:	1886b03a 	or	r3,r3,r2
 204533c:	e0bff617 	ldw	r2,-40(fp)
 2045340:	10800417 	ldw	r2,16(r2)
 2045344:	10bfc00c 	andi	r2,r2,65280
 2045348:	1004923a 	slli	r2,r2,8
 204534c:	1886b03a 	or	r3,r3,r2
 2045350:	e0bff617 	ldw	r2,-40(fp)
 2045354:	10800417 	ldw	r2,16(r2)
 2045358:	1004963a 	slli	r2,r2,24
 204535c:	1884b03a 	or	r2,r3,r2
 2045360:	10fc002c 	andhi	r3,r2,61440
 2045364:	00b80034 	movhi	r2,57344
 2045368:	18800826 	beq	r3,r2,204538c <udpdemux+0x5c0>
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
 204536c:	e0bff217 	ldw	r2,-56(fp)
 2045370:	10800317 	ldw	r2,12(r2)
 2045374:	10000526 	beq	r2,zero,204538c <udpdemux+0x5c0>
 2045378:	e0bff217 	ldw	r2,-56(fp)
 204537c:	10c00317 	ldw	r3,12(r2)
 2045380:	e0bff617 	ldw	r2,-40(fp)
 2045384:	10800417 	ldw	r2,16(r2)
 2045388:	18802c1e 	bne	r3,r2,204543c <udpdemux+0x670>
            continue;
      }

      /* fall to here if we found it */
      udp_mib.udpInDatagrams++;
 204538c:	00809934 	movhi	r2,612
 2045390:	10b7ed04 	addi	r2,r2,-8268
 2045394:	10800017 	ldw	r2,0(r2)
 2045398:	10c00044 	addi	r3,r2,1
 204539c:	00809934 	movhi	r2,612
 20453a0:	10b7ed04 	addi	r2,r2,-8268
 20453a4:	10c00015 	stw	r3,0(r2)
      if (con->u_rcv)         /* if upcall address is set... */
 20453a8:	e0bff217 	ldw	r2,-56(fp)
 20453ac:	10800517 	ldw	r2,20(r2)
 20453b0:	10000d26 	beq	r2,zero,20453e8 <udpdemux+0x61c>
      {
         UNLOCK_NET_RESOURCE(NET_RESID);
 20453b4:	0009883a 	mov	r4,zero
 20453b8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         e = ((*con->u_rcv)(p, con->u_data));   /* upcall it */
 20453bc:	e0bff217 	ldw	r2,-56(fp)
 20453c0:	10c00517 	ldw	r3,20(r2)
 20453c4:	e0bff217 	ldw	r2,-56(fp)
 20453c8:	10800617 	ldw	r2,24(r2)
 20453cc:	e13fff17 	ldw	r4,-4(fp)
 20453d0:	100b883a 	mov	r5,r2
 20453d4:	183ee83a 	callr	r3
 20453d8:	e0bff415 	stw	r2,-48(fp)
         LOCK_NET_RESOURCE(NET_RESID);
 20453dc:	0009883a 	mov	r4,zero
 20453e0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
 20453e4:	00000206 	br	20453f0 <udpdemux+0x624>
      }
      else
         e = ENP_LOGIC;
 20453e8:	00bffd44 	movi	r2,-11
 20453ec:	e0bff415 	stw	r2,-48(fp)

      /* if error occurred in upcall or there was no upcall hander
         its up to this routine to free the packet buffer */
      if (e)
 20453f0:	e0bff417 	ldw	r2,-48(fp)
 20453f4:	10000926 	beq	r2,zero,204541c <udpdemux+0x650>
      {
         udp_mib.udpInErrors++;
 20453f8:	00809934 	movhi	r2,612
 20453fc:	10b7ed04 	addi	r2,r2,-8268
 2045400:	10800217 	ldw	r2,8(r2)
 2045404:	10c00044 	addi	r3,r2,1
 2045408:	00809934 	movhi	r2,612
 204540c:	10b7ed04 	addi	r2,r2,-8268
 2045410:	10c00215 	stw	r3,8(r2)
         udp_free(p);
 2045414:	e13fff17 	ldw	r4,-4(fp)
 2045418:	2045b2c0 	call	2045b2c <udp_free>
      }

      return(e);
 204541c:	e0bff417 	ldw	r2,-48(fp)
 2045420:	00006b06 	br	20455d0 <udpdemux+0x804>
#endif

      /* enforce all three aspects of tuple matching. Old code
      assumed lport was unique, which is not always so. */
      if (con->u_lport && (con->u_lport != pup->ud_dstp))
         continue;
 2045424:	0001883a 	nop
 2045428:	00000506 	br	2045440 <udpdemux+0x674>
      if (con->u_fport && (con->u_fport != pup->ud_srcp))
         continue;
 204542c:	0001883a 	nop
 2045430:	00000306 	br	2045440 <udpdemux+0x674>
      if (con->u_fhost && (con->u_fhost != p->fhost))
         continue;
 2045434:	0001883a 	nop
 2045438:	00000106 	br	2045440 <udpdemux+0x674>
       * make sure the packet was received on that interface address
       */
      if (!IN_MULTICAST(ntohl(pip->ip_dest)))
      {
         if ((con->u_lhost != 0) && (con->u_lhost != pip->ip_dest)) 
            continue;
 204543c:	0001883a 	nop
#endif   /* INCLUDE_SNMPV3 */
#endif   /* PREBIND_AGENT */

   /* run through the demux table and try to upcall it */

   for (con = firstudp; con; con = con->u_next)
 2045440:	e0bff217 	ldw	r2,-56(fp)
 2045444:	10800017 	ldw	r2,0(r2)
 2045448:	e0bff215 	stw	r2,-56(fp)
 204544c:	e0bff217 	ldw	r2,-56(fp)
 2045450:	103f501e 	bne	r2,zero,2045194 <udpdemux+0x3c8>

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 2045454:	e0bff617 	ldw	r2,-40(fp)
 2045458:	10800417 	ldw	r2,16(r2)
 204545c:	10bfffe0 	cmpeqi	r2,r2,-1
 2045460:	1000121e 	bne	r2,zero,20454ac <udpdemux+0x6e0>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 2045464:	e0bff617 	ldw	r2,-40(fp)
 2045468:	10c00417 	ldw	r3,16(r2)
 204546c:	e0bfff17 	ldw	r2,-4(fp)
 2045470:	10800617 	ldw	r2,24(r2)
 2045474:	10800e17 	ldw	r2,56(r2)

   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
 2045478:	18800c26 	beq	r3,r2,20454ac <udpdemux+0x6e0>
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 204547c:	e0bff617 	ldw	r2,-40(fp)
 2045480:	10c00417 	ldw	r3,16(r2)
 2045484:	e0bfff17 	ldw	r2,-4(fp)
 2045488:	10800617 	ldw	r2,24(r2)
 204548c:	10800f17 	ldw	r2,60(r2)
   /* Fall to here if packet is not for us. Check if the packet was 
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
 2045490:	18800626 	beq	r3,r2,20454ac <udpdemux+0x6e0>
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
 2045494:	e0bff617 	ldw	r2,-40(fp)
 2045498:	10c00417 	ldw	r3,16(r2)
 204549c:	e0bfff17 	ldw	r2,-4(fp)
 20454a0:	10800617 	ldw	r2,24(r2)
 20454a4:	10801017 	ldw	r2,64(r2)
    * sent to an ip broadcast address. If it was, don't send a 
    * destination unreachable. 
    */
   if ((pip->ip_dest == 0xffffffffL) ||   /* Physical cable broadcast addr*/
       (pip->ip_dest == p->net->n_netbr) ||   /* All subnet broadcast */
       (pip->ip_dest == p->net->n_netbr42) || /* All subnet bcast (4.2bsd) */
 20454a8:	1880181e 	bne	r3,r2,204550c <udpdemux+0x740>
       (pip->ip_dest == p->net->n_subnetbr))  /* Our subnet broadcast */
   {
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 20454ac:	00808174 	movhi	r2,517
 20454b0:	1090b204 	addi	r2,r2,17096
 20454b4:	10800017 	ldw	r2,0(r2)
 20454b8:	1081000c 	andi	r2,r2,1024
 20454bc:	10000826 	beq	r2,zero,20454e0 <udpdemux+0x714>
 20454c0:	00808174 	movhi	r2,517
 20454c4:	1090b204 	addi	r2,r2,17096
 20454c8:	10800017 	ldw	r2,0(r2)
 20454cc:	1080400c 	andi	r2,r2,256
 20454d0:	10000326 	beq	r2,zero,20454e0 <udpdemux+0x714>
         dprintf("UDP: ignoring ip broadcast\n");
 20454d4:	01008174 	movhi	r4,517
 20454d8:	21068d04 	addi	r4,r4,6708
 20454dc:	2006cb40 	call	2006cb4 <puts>
#endif
      udp_mib.udpInErrors++;
 20454e0:	00809934 	movhi	r2,612
 20454e4:	10b7ed04 	addi	r2,r2,-8268
 20454e8:	10800217 	ldw	r2,8(r2)
 20454ec:	10c00044 	addi	r3,r2,1
 20454f0:	00809934 	movhi	r2,612
 20454f4:	10b7ed04 	addi	r2,r2,-8268
 20454f8:	10c00215 	stw	r3,8(r2)
      udp_free(p);
 20454fc:	e13fff17 	ldw	r4,-4(fp)
 2045500:	2045b2c0 	call	2045b2c <udp_free>
      return ENP_NOT_MINE;
 2045504:	00800084 	movi	r2,2
 2045508:	00003106 	br	20455d0 <udpdemux+0x804>
   }

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & TPTRACE))
 204550c:	00808174 	movhi	r2,517
 2045510:	1090b204 	addi	r2,r2,17096
 2045514:	10800017 	ldw	r2,0(r2)
 2045518:	1081000c 	andi	r2,r2,1024
 204551c:	10001326 	beq	r2,zero,204556c <udpdemux+0x7a0>
 2045520:	00808174 	movhi	r2,517
 2045524:	1090b204 	addi	r2,r2,17096
 2045528:	10800017 	ldw	r2,0(r2)
 204552c:	1080400c 	andi	r2,r2,256
 2045530:	10000e26 	beq	r2,zero,204556c <udpdemux+0x7a0>
   {
      dprintf("UDP: unexpected port %04x\n", pup->ud_dstp);
 2045534:	e0bff717 	ldw	r2,-36(fp)
 2045538:	1080008b 	ldhu	r2,2(r2)
 204553c:	10bfffcc 	andi	r2,r2,65535
 2045540:	01008174 	movhi	r4,517
 2045544:	21069404 	addi	r4,r4,6736
 2045548:	100b883a 	mov	r5,r2
 204554c:	2006a240 	call	2006a24 <printf>
      if (NDEBUG & DUMP) 
 2045550:	00808174 	movhi	r2,517
 2045554:	1090b204 	addi	r2,r2,17096
 2045558:	10800017 	ldw	r2,0(r2)
 204555c:	1080008c 	andi	r2,r2,2
 2045560:	10000226 	beq	r2,zero,204556c <udpdemux+0x7a0>
         ip_dump(p);
 2045564:	e13fff17 	ldw	r4,-4(fp)
 2045568:	2040e3c0 	call	2040e3c <ip_dump>
#ifdef FULL_ICMP
   /* send destination unreachable.  Swap back all the swapped information */
   /* so that the destun packet format is correct */

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 204556c:	e13ff717 	ldw	r4,-36(fp)
 2045570:	20458840 	call	2045884 <udpswap>
#endif   /* BYTE_ORDER */
   
   icmp_destun(p->fhost, p->net->n_ipaddr, pip, DSTPORT, p->net);
 2045574:	e0bfff17 	ldw	r2,-4(fp)
 2045578:	10c00717 	ldw	r3,28(r2)
 204557c:	e0bfff17 	ldw	r2,-4(fp)
 2045580:	10800617 	ldw	r2,24(r2)
 2045584:	10800a17 	ldw	r2,40(r2)
 2045588:	e13fff17 	ldw	r4,-4(fp)
 204558c:	21000617 	ldw	r4,24(r4)
 2045590:	d9000015 	stw	r4,0(sp)
 2045594:	1809883a 	mov	r4,r3
 2045598:	100b883a 	mov	r5,r2
 204559c:	e1bff617 	ldw	r6,-40(fp)
 20455a0:	01c000c4 	movi	r7,3
 20455a4:	204b5140 	call	204b514 <icmp_destun>
#endif   /* FULL_ICMP */

   udp_mib.udpNoPorts++;
 20455a8:	00809934 	movhi	r2,612
 20455ac:	10b7ed04 	addi	r2,r2,-8268
 20455b0:	10800117 	ldw	r2,4(r2)
 20455b4:	10c00044 	addi	r3,r2,1
 20455b8:	00809934 	movhi	r2,612
 20455bc:	10b7ed04 	addi	r2,r2,-8268
 20455c0:	10c00115 	stw	r3,4(r2)
   udp_free(p);
 20455c4:	e13fff17 	ldw	r4,-4(fp)
 20455c8:	2045b2c0 	call	2045b2c <udp_free>
   return ENP_NOT_MINE;
 20455cc:	00800084 	movi	r2,2
}
 20455d0:	e037883a 	mov	sp,fp
 20455d4:	dfc00117 	ldw	ra,4(sp)
 20455d8:	df000017 	ldw	fp,0(sp)
 20455dc:	dec00204 	addi	sp,sp,8
 20455e0:	f800283a 	ret

020455e4 <udp_send>:
 * detected. 
 */

int
udp_send(unshort fport, unshort lport, PACKET p)
{
 20455e4:	deffef04 	addi	sp,sp,-68
 20455e8:	dfc01015 	stw	ra,64(sp)
 20455ec:	df000f15 	stw	fp,60(sp)
 20455f0:	df000f04 	addi	fp,sp,60
 20455f4:	2007883a 	mov	r3,r4
 20455f8:	2805883a 	mov	r2,r5
 20455fc:	e1bfff15 	stw	r6,-4(fp)
 2045600:	e0fffd0d 	sth	r3,-12(fp)
 2045604:	e0bffe0d 	sth	r2,-8(fp)
   int         udplen;
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
 2045608:	00808174 	movhi	r2,517
 204560c:	1090b204 	addi	r2,r2,17096
 2045610:	10800017 	ldw	r2,0(r2)
 2045614:	1080410c 	andi	r2,r2,260
 2045618:	10001b26 	beq	r2,zero,2045688 <udp_send+0xa4>
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 204561c:	e0bfff17 	ldw	r2,-4(fp)
 2045620:	11400417 	ldw	r5,16(r2)
 2045624:	e0fffe0b 	ldhu	r3,-8(fp)
    PUSH_IPADDR(p->fhost), fport);
 2045628:	e0bfff17 	ldw	r2,-4(fp)
 204562c:	10800717 	ldw	r2,28(r2)
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 2045630:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(p->fhost), fport);
 2045634:	e13fff17 	ldw	r4,-4(fp)
 2045638:	21000717 	ldw	r4,28(r4)
 204563c:	2008d23a 	srli	r4,r4,8
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 2045640:	22003fcc 	andi	r8,r4,255
    PUSH_IPADDR(p->fhost), fport);
 2045644:	e13fff17 	ldw	r4,-4(fp)
 2045648:	21000717 	ldw	r4,28(r4)
 204564c:	2008d43a 	srli	r4,r4,16
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 2045650:	21c03fcc 	andi	r7,r4,255
    PUSH_IPADDR(p->fhost), fport);
 2045654:	e13fff17 	ldw	r4,-4(fp)
 2045658:	21000717 	ldw	r4,28(r4)
 204565c:	200cd63a 	srli	r6,r4,24
   int         e;
   ip_addr     src_ip;    /* source IP, for checksumming purposes */

#ifdef   NPDEBUG
   if (NDEBUG & (INFOMSG|TPTRACE))
      dprintf("UDP: pkt [%u] %04x -> %u.%u.%u.%u:%04x\n", p->nb_plen, lport,
 2045660:	e13ffd0b 	ldhu	r4,-12(fp)
 2045664:	da000015 	stw	r8,0(sp)
 2045668:	d9c00115 	stw	r7,4(sp)
 204566c:	d9800215 	stw	r6,8(sp)
 2045670:	d9000315 	stw	r4,12(sp)
 2045674:	01008174 	movhi	r4,517
 2045678:	21069b04 	addi	r4,r4,6764
 204567c:	180d883a 	mov	r6,r3
 2045680:	100f883a 	mov	r7,r2
 2045684:	2006a240 	call	2006a24 <printf>
    PUSH_IPADDR(p->fhost), fport);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 2045688:	0009883a 	mov	r4,zero
 204568c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   /* prepend UDP header to upper layer's data */
   p->nb_prot -= sizeof(struct udp);
 2045690:	e0bfff17 	ldw	r2,-4(fp)
 2045694:	10800317 	ldw	r2,12(r2)
 2045698:	10fffe04 	addi	r3,r2,-8
 204569c:	e0bfff17 	ldw	r2,-4(fp)
 20456a0:	10c00315 	stw	r3,12(r2)
   pup = (struct udp*)p->nb_prot;
 20456a4:	e0bfff17 	ldw	r2,-4(fp)
 20456a8:	10800317 	ldw	r2,12(r2)
 20456ac:	e0bff615 	stw	r2,-40(fp)
   udplen = p->nb_plen + sizeof(struct udp);
 20456b0:	e0bfff17 	ldw	r2,-4(fp)
 20456b4:	10800417 	ldw	r2,16(r2)
 20456b8:	10800204 	addi	r2,r2,8
 20456bc:	e0bff715 	stw	r2,-36(fp)
   p->nb_plen = udplen;
 20456c0:	e0fff717 	ldw	r3,-36(fp)
 20456c4:	e0bfff17 	ldw	r2,-4(fp)
 20456c8:	10c00415 	stw	r3,16(r2)
   if (udplen & 1) ((char *)pup)[udplen] = 0;
 20456cc:	e0bff717 	ldw	r2,-36(fp)
 20456d0:	1080004c 	andi	r2,r2,1
 20456d4:	10000426 	beq	r2,zero,20456e8 <udp_send+0x104>
 20456d8:	e0bff717 	ldw	r2,-36(fp)
 20456dc:	e0fff617 	ldw	r3,-40(fp)
 20456e0:	1885883a 	add	r2,r3,r2
 20456e4:	10000005 	stb	zero,0(r2)

      pup->ud_len = (unshort)udplen;   /* fill in the UDP header */
 20456e8:	e0bff717 	ldw	r2,-36(fp)
 20456ec:	1007883a 	mov	r3,r2
 20456f0:	e0bff617 	ldw	r2,-40(fp)
 20456f4:	10c0010d 	sth	r3,4(r2)
   pup->ud_srcp = lport;
 20456f8:	e0bff617 	ldw	r2,-40(fp)
 20456fc:	e0fffe0b 	ldhu	r3,-8(fp)
 2045700:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = fport;
 2045704:	e0bff617 	ldw	r2,-40(fp)
 2045708:	e0fffd0b 	ldhu	r3,-12(fp)
 204570c:	10c0008d 	sth	r3,2(r2)

#if (BYTE_ORDER == LITTLE_ENDIAN)
   udpswap(pup);
 2045710:	e13ff617 	ldw	r4,-40(fp)
 2045714:	20458840 	call	2045884 <udpswap>
#endif   /* BYTE_ORDER */
   
#ifdef MULTI_HOMED
   /* getting the source IP address for a broadcast is a bit tricky: */
   if (p->fhost == 0xffffffff)
 2045718:	e0bfff17 	ldw	r2,-4(fp)
 204571c:	10800717 	ldw	r2,28(r2)
 2045720:	10bfffd8 	cmpnei	r2,r2,-1
 2045724:	10000f1e 	bne	r2,zero,2045764 <udp_send+0x180>
   {
      if (!p->net)
 2045728:	e0bfff17 	ldw	r2,-4(fp)
 204572c:	10800617 	ldw	r2,24(r2)
 2045730:	1000071e 	bne	r2,zero,2045750 <udp_send+0x16c>
      {
         dtrap();    /* programmer forgot to select iface */
 2045734:	20285c80 	call	20285c8 <dtrap>
         /* it would appear that the callers of udp_send() expect it
            to do cleanup on failure, so free the packet buffer here */
         udp_free(p);
 2045738:	e13fff17 	ldw	r4,-4(fp)
 204573c:	2045b2c0 	call	2045b2c <udp_free>
         UNLOCK_NET_RESOURCE(NET_RESID);
 2045740:	0009883a 	mov	r4,zero
 2045744:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return ENP_NO_IFACE;
 2045748:	00bff784 	movi	r2,-34
 204574c:	00004806 	br	2045870 <udp_send+0x28c>
      }
      src_ip = p->net->n_ipaddr;
 2045750:	e0bfff17 	ldw	r2,-4(fp)
 2045754:	10800617 	ldw	r2,24(r2)
 2045758:	10800a17 	ldw	r2,40(r2)
 204575c:	e0bff515 	stw	r2,-44(fp)
 2045760:	00000506 	br	2045778 <udp_send+0x194>
   /* set the IP addresses in the IP header. The pseudo header used for
    * checksumming overlays the addresses on the IP header area in the
    * buffer, so setting them there (which we need to do for cksum
    * anyway) sets up for IP too.
    */
   src_ip = ip_mymach(p->fhost);
 2045764:	e0bfff17 	ldw	r2,-4(fp)
 2045768:	10800717 	ldw	r2,28(r2)
 204576c:	1009883a 	mov	r4,r2
 2045770:	2040d940 	call	2040d94 <ip_mymach>
 2045774:	e0bff515 	stw	r2,-44(fp)
   php.ph_src = src_ip;
 2045778:	e0bff517 	ldw	r2,-44(fp)
 204577c:	e0bffa15 	stw	r2,-24(fp)
   php.ph_dest = p->fhost;
 2045780:	e0bfff17 	ldw	r2,-4(fp)
 2045784:	10800717 	ldw	r2,28(r2)
 2045788:	e0bffb15 	stw	r2,-20(fp)
#ifdef NO_UDP_CKSUM
   /* If no UDP checksum support, just zero the checksum field */
   pup->ud_cksum = 0;
#else
   /* finish filling in the pseudo header required for checksumming */
   php.ph_zero = 0;
 204578c:	e03ffc05 	stb	zero,-16(fp)
   php.ph_prot = UDP_PROT;
 2045790:	00800444 	movi	r2,17
 2045794:	e0bffc45 	stb	r2,-15(fp)
   php.ph_len = pup->ud_len;
 2045798:	e0bff617 	ldw	r2,-40(fp)
 204579c:	1080010b 	ldhu	r2,4(r2)
 20457a0:	e0bffc8d 	sth	r2,-14(fp)
   pup->ud_cksum = cksum(&php, sizeof(struct ph)>>1);
 20457a4:	e0bffa04 	addi	r2,fp,-24
 20457a8:	1009883a 	mov	r4,r2
 20457ac:	01400184 	movi	r5,6
 20457b0:	20268040 	call	2026804 <cksum>
 20457b4:	e0fff617 	ldw	r3,-40(fp)
 20457b8:	1880018d 	sth	r2,6(r3)
   pup->ud_cksum = ~cksum(pup, (udplen+1)>>1);
 20457bc:	e0bff717 	ldw	r2,-36(fp)
 20457c0:	10800044 	addi	r2,r2,1
 20457c4:	1005d07a 	srai	r2,r2,1
 20457c8:	e13ff617 	ldw	r4,-40(fp)
 20457cc:	100b883a 	mov	r5,r2
 20457d0:	20268040 	call	2026804 <cksum>
 20457d4:	0084303a 	nor	r2,zero,r2
 20457d8:	1007883a 	mov	r3,r2
 20457dc:	e0bff617 	ldw	r2,-40(fp)
 20457e0:	10c0018d 	sth	r3,6(r2)
   if (pup->ud_cksum == 0)
 20457e4:	e0bff617 	ldw	r2,-40(fp)
 20457e8:	1080018b 	ldhu	r2,6(r2)
 20457ec:	10bfffcc 	andi	r2,r2,65535
 20457f0:	1000031e 	bne	r2,zero,2045800 <udp_send+0x21c>
      pup->ud_cksum = 0xffff;
 20457f4:	e0bff617 	ldw	r2,-40(fp)
 20457f8:	00ffffc4 	movi	r3,-1
 20457fc:	10c0018d 	sth	r3,6(r2)
#endif

   /* need to fill in IP addresses at this layer too */
   pip = (struct ip *)(p->nb_prot - sizeof(struct ip));
 2045800:	e0bfff17 	ldw	r2,-4(fp)
 2045804:	10800317 	ldw	r2,12(r2)
 2045808:	10bffb04 	addi	r2,r2,-20
 204580c:	e0bff815 	stw	r2,-32(fp)
   pip->ip_src = src_ip;
 2045810:	e0bff817 	ldw	r2,-32(fp)
 2045814:	e0fff517 	ldw	r3,-44(fp)
 2045818:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = p->fhost;
 204581c:	e0bfff17 	ldw	r2,-4(fp)
 2045820:	10c00717 	ldw	r3,28(r2)
 2045824:	e0bff817 	ldw	r2,-32(fp)
 2045828:	10c00415 	stw	r3,16(r2)

   udp_mib.udpOutDatagrams++;
 204582c:	00809934 	movhi	r2,612
 2045830:	10b7ed04 	addi	r2,r2,-8268
 2045834:	10800317 	ldw	r2,12(r2)
 2045838:	10c00044 	addi	r3,r2,1
 204583c:	00809934 	movhi	r2,612
 2045840:	10b7ed04 	addi	r2,r2,-8268
 2045844:	10c00315 	stw	r3,12(r2)

   p->nb_plen = udplen;       /* nb_prot was adjusted above */
 2045848:	e0fff717 	ldw	r3,-36(fp)
 204584c:	e0bfff17 	ldw	r2,-4(fp)
 2045850:	10c00415 	stw	r3,16(r2)
   e = ip_write(UDP_PROT, p);
 2045854:	01000444 	movi	r4,17
 2045858:	e17fff17 	ldw	r5,-4(fp)
 204585c:	203fd780 	call	203fd78 <ip_write>
 2045860:	e0bff915 	stw	r2,-28(fp)
   UNLOCK_NET_RESOURCE(NET_RESID);
 2045864:	0009883a 	mov	r4,zero
 2045868:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return e;
 204586c:	e0bff917 	ldw	r2,-28(fp)
}
 2045870:	e037883a 	mov	sp,fp
 2045874:	dfc00117 	ldw	ra,4(sp)
 2045878:	df000017 	ldw	fp,0(sp)
 204587c:	dec00204 	addi	sp,sp,8
 2045880:	f800283a 	ret

02045884 <udpswap>:
 */

#if (BYTE_ORDER == LITTLE_ENDIAN)
void
udpswap(struct udp *pup)
{
 2045884:	defffe04 	addi	sp,sp,-8
 2045888:	df000115 	stw	fp,4(sp)
 204588c:	df000104 	addi	fp,sp,4
 2045890:	e13fff15 	stw	r4,-4(fp)

   pup->ud_srcp = htons(pup->ud_srcp);
 2045894:	e0bfff17 	ldw	r2,-4(fp)
 2045898:	1080000b 	ldhu	r2,0(r2)
 204589c:	10bfffcc 	andi	r2,r2,65535
 20458a0:	1004d23a 	srli	r2,r2,8
 20458a4:	1007883a 	mov	r3,r2
 20458a8:	e0bfff17 	ldw	r2,-4(fp)
 20458ac:	1080000b 	ldhu	r2,0(r2)
 20458b0:	10bfffcc 	andi	r2,r2,65535
 20458b4:	1004923a 	slli	r2,r2,8
 20458b8:	1884b03a 	or	r2,r3,r2
 20458bc:	1007883a 	mov	r3,r2
 20458c0:	e0bfff17 	ldw	r2,-4(fp)
 20458c4:	10c0000d 	sth	r3,0(r2)
   pup->ud_dstp = htons(pup->ud_dstp);
 20458c8:	e0bfff17 	ldw	r2,-4(fp)
 20458cc:	1080008b 	ldhu	r2,2(r2)
 20458d0:	10bfffcc 	andi	r2,r2,65535
 20458d4:	1004d23a 	srli	r2,r2,8
 20458d8:	1007883a 	mov	r3,r2
 20458dc:	e0bfff17 	ldw	r2,-4(fp)
 20458e0:	1080008b 	ldhu	r2,2(r2)
 20458e4:	10bfffcc 	andi	r2,r2,65535
 20458e8:	1004923a 	slli	r2,r2,8
 20458ec:	1884b03a 	or	r2,r3,r2
 20458f0:	1007883a 	mov	r3,r2
 20458f4:	e0bfff17 	ldw	r2,-4(fp)
 20458f8:	10c0008d 	sth	r3,2(r2)
   pup->ud_len = htons(pup->ud_len);
 20458fc:	e0bfff17 	ldw	r2,-4(fp)
 2045900:	1080010b 	ldhu	r2,4(r2)
 2045904:	10bfffcc 	andi	r2,r2,65535
 2045908:	1004d23a 	srli	r2,r2,8
 204590c:	1007883a 	mov	r3,r2
 2045910:	e0bfff17 	ldw	r2,-4(fp)
 2045914:	1080010b 	ldhu	r2,4(r2)
 2045918:	10bfffcc 	andi	r2,r2,65535
 204591c:	1004923a 	slli	r2,r2,8
 2045920:	1884b03a 	or	r2,r3,r2
 2045924:	1007883a 	mov	r3,r2
 2045928:	e0bfff17 	ldw	r2,-4(fp)
 204592c:	10c0010d 	sth	r3,4(r2)
   pup->ud_cksum = htons(pup->ud_cksum);
 2045930:	e0bfff17 	ldw	r2,-4(fp)
 2045934:	1080018b 	ldhu	r2,6(r2)
 2045938:	10bfffcc 	andi	r2,r2,65535
 204593c:	1004d23a 	srli	r2,r2,8
 2045940:	1007883a 	mov	r3,r2
 2045944:	e0bfff17 	ldw	r2,-4(fp)
 2045948:	1080018b 	ldhu	r2,6(r2)
 204594c:	10bfffcc 	andi	r2,r2,65535
 2045950:	1004923a 	slli	r2,r2,8
 2045954:	1884b03a 	or	r2,r3,r2
 2045958:	1007883a 	mov	r3,r2
 204595c:	e0bfff17 	ldw	r2,-4(fp)
 2045960:	10c0018d 	sth	r3,6(r2)
}
 2045964:	e037883a 	mov	sp,fp
 2045968:	df000017 	ldw	fp,0(sp)
 204596c:	dec00104 	addi	sp,sp,4
 2045970:	f800283a 	ret

02045974 <udp_socket>:
#define  MINSOCKET   1200
static unshort usocket = 0;   /* next socket to grab */

unshort
udp_socket(void)
{
 2045974:	defffe04 	addi	sp,sp,-8
 2045978:	df000115 	stw	fp,4(sp)
 204597c:	df000104 	addi	fp,sp,4
   UDPCONN tmp;

   if (usocket < MINSOCKET)
 2045980:	d0a0c70b 	ldhu	r2,-31972(gp)
 2045984:	10bfffcc 	andi	r2,r2,65535
 2045988:	10812c28 	cmpgeui	r2,r2,1200
 204598c:	10000c1e 	bne	r2,zero,20459c0 <udp_socket+0x4c>
   {
      /* logic for for init and after wraps */
      usocket = (unshort)(cticks & 0x7fff);
 2045990:	00808174 	movhi	r2,517
 2045994:	1090c904 	addi	r2,r2,17188
 2045998:	10800017 	ldw	r2,0(r2)
 204599c:	109fffcc 	andi	r2,r2,32767
 20459a0:	d0a0c70d 	sth	r2,-31972(gp)
      if (usocket < MINSOCKET)
 20459a4:	d0a0c70b 	ldhu	r2,-31972(gp)
 20459a8:	10bfffcc 	andi	r2,r2,65535
 20459ac:	10812c28 	cmpgeui	r2,r2,1200
 20459b0:	1000031e 	bne	r2,zero,20459c0 <udp_socket+0x4c>
         usocket += MINSOCKET;
 20459b4:	d0a0c70b 	ldhu	r2,-31972(gp)
 20459b8:	10812c04 	addi	r2,r2,1200
 20459bc:	d0a0c70d 	sth	r2,-31972(gp)
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 20459c0:	00808174 	movhi	r2,517
 20459c4:	1090f204 	addi	r2,r2,17352
 20459c8:	10800017 	ldw	r2,0(r2)
 20459cc:	e0bfff15 	stw	r2,-4(fp)
 20459d0:	00001106 	br	2045a18 <udp_socket+0xa4>
   {
      if (tmp->u_lport == usocket)
 20459d4:	e0bfff17 	ldw	r2,-4(fp)
 20459d8:	10c0018b 	ldhu	r3,6(r2)
 20459dc:	d0a0c70b 	ldhu	r2,-31972(gp)
 20459e0:	18ffffcc 	andi	r3,r3,65535
 20459e4:	10bfffcc 	andi	r2,r2,65535
 20459e8:	1880081e 	bne	r3,r2,2045a0c <udp_socket+0x98>
      {
         usocket++;     /* bump socket number */
 20459ec:	d0a0c70b 	ldhu	r2,-31972(gp)
 20459f0:	10800044 	addi	r2,r2,1
 20459f4:	d0a0c70d 	sth	r2,-31972(gp)
         tmp = firstudp;   /* restart scan */
 20459f8:	00808174 	movhi	r2,517
 20459fc:	1090f204 	addi	r2,r2,17352
 2045a00:	10800017 	ldw	r2,0(r2)
 2045a04:	e0bfff15 	stw	r2,-4(fp)
         continue;
 2045a08:	0001883a 	nop
      usocket = (unshort)(cticks & 0x7fff);
      if (usocket < MINSOCKET)
         usocket += MINSOCKET;
   }
   /* scan existing connections, making sure socket isn't in use */
   for (tmp = firstudp; tmp; tmp = tmp->u_next)
 2045a0c:	e0bfff17 	ldw	r2,-4(fp)
 2045a10:	10800017 	ldw	r2,0(r2)
 2045a14:	e0bfff15 	stw	r2,-4(fp)
 2045a18:	e0bfff17 	ldw	r2,-4(fp)
 2045a1c:	103fed1e 	bne	r2,zero,20459d4 <udp_socket+0x60>
         usocket++;     /* bump socket number */
         tmp = firstudp;   /* restart scan */
         continue;
      }
   }
   return usocket++;
 2045a20:	d0a0c70b 	ldhu	r2,-31972(gp)
 2045a24:	1007883a 	mov	r3,r2
 2045a28:	10800044 	addi	r2,r2,1
 2045a2c:	d0a0c70d 	sth	r2,-31972(gp)
 2045a30:	1805883a 	mov	r2,r3
}
 2045a34:	e037883a 	mov	sp,fp
 2045a38:	df000017 	ldw	fp,0(sp)
 2045a3c:	dec00104 	addi	sp,sp,4
 2045a40:	f800283a 	ret

02045a44 <udp_alloc>:
 * RETURNS:  Returns buffer, or NULL in no buffer was available. 
 */

PACKET
udp_alloc(int datalen, int optlen)
{
 2045a44:	defffa04 	addi	sp,sp,-24
 2045a48:	dfc00515 	stw	ra,20(sp)
 2045a4c:	df000415 	stw	fp,16(sp)
 2045a50:	df000404 	addi	fp,sp,16
 2045a54:	e13ffe15 	stw	r4,-8(fp)
 2045a58:	e17fff15 	stw	r5,-4(fp)
   int   len;
   PACKET p;

   len = (datalen + sizeof(struct udp) + 1) & ~1;
 2045a5c:	e0bffe17 	ldw	r2,-8(fp)
 2045a60:	10800244 	addi	r2,r2,9
 2045a64:	1007883a 	mov	r3,r2
 2045a68:	00bfff84 	movi	r2,-2
 2045a6c:	1884703a 	and	r2,r3,r2
 2045a70:	e0bffc15 	stw	r2,-16(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2045a74:	01000084 	movi	r4,2
 2045a78:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   p = pk_alloc(len + UDPHDRSLEN + optlen);
 2045a7c:	e0bffc17 	ldw	r2,-16(fp)
 2045a80:	10c00904 	addi	r3,r2,36
 2045a84:	e0bfff17 	ldw	r2,-4(fp)
 2045a88:	1885883a 	add	r2,r3,r2
 2045a8c:	1009883a 	mov	r4,r2
 2045a90:	2027cec0 	call	2027cec <pk_alloc>
 2045a94:	e0bffd15 	stw	r2,-12(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2045a98:	01000084 	movi	r4,2
 2045a9c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (p != (PACKET)NULL)
 2045aa0:	e0bffd17 	ldw	r2,-12(fp)
 2045aa4:	10001026 	beq	r2,zero,2045ae8 <udp_alloc+0xa4>
   {
      /* set prot pointers past end of UDP header  */
      len = sizeof(struct ip) + (optlen >> 2) + sizeof(struct udp);
 2045aa8:	e0bfff17 	ldw	r2,-4(fp)
 2045aac:	1005d0ba 	srai	r2,r2,2
 2045ab0:	10800704 	addi	r2,r2,28
 2045ab4:	e0bffc15 	stw	r2,-16(fp)
      p->nb_prot += len;
 2045ab8:	e0bffd17 	ldw	r2,-12(fp)
 2045abc:	10c00317 	ldw	r3,12(r2)
 2045ac0:	e0bffc17 	ldw	r2,-16(fp)
 2045ac4:	1887883a 	add	r3,r3,r2
 2045ac8:	e0bffd17 	ldw	r2,-12(fp)
 2045acc:	10c00315 	stw	r3,12(r2)
      p->nb_plen -= len;
 2045ad0:	e0bffd17 	ldw	r2,-12(fp)
 2045ad4:	10c00417 	ldw	r3,16(r2)
 2045ad8:	e0bffc17 	ldw	r2,-16(fp)
 2045adc:	1887c83a 	sub	r3,r3,r2
 2045ae0:	e0bffd17 	ldw	r2,-12(fp)
 2045ae4:	10c00415 	stw	r3,16(r2)
   }

   return (p);
 2045ae8:	e0bffd17 	ldw	r2,-12(fp)
}
 2045aec:	e037883a 	mov	sp,fp
 2045af0:	dfc00117 	ldw	ra,4(sp)
 2045af4:	df000017 	ldw	fp,0(sp)
 2045af8:	dec00204 	addi	sp,sp,8
 2045afc:	f800283a 	ret

02045b00 <udp_maxalloc>:
 *          returned value, the allocation will fail
 */

int
udp_maxalloc(void)
{
 2045b00:	deffff04 	addi	sp,sp,-4
 2045b04:	df000015 	stw	fp,0(sp)
 2045b08:	d839883a 	mov	fp,sp
    * created is ((2^16 - 1) - (size of IP and UDP headers)) */
   return (0xFFFF - (sizeof (struct ip) + sizeof (struct udp)));
#else
   /* if heap buffers are not available, the largest size of a UDP datagram
    * is constrained by what will fit inside a big buffer */
   return (bigbufsiz - UDPHDRSLEN);
 2045b0c:	00808174 	movhi	r2,517
 2045b10:	10906904 	addi	r2,r2,16804
 2045b14:	10800017 	ldw	r2,0(r2)
 2045b18:	10bff704 	addi	r2,r2,-36
#endif
}
 2045b1c:	e037883a 	mov	sp,fp
 2045b20:	df000017 	ldw	fp,0(sp)
 2045b24:	dec00104 	addi	sp,sp,4
 2045b28:	f800283a 	ret

02045b2c <udp_free>:
 * RETURNS: void
 */

void
udp_free(PACKET p)
{
 2045b2c:	defffd04 	addi	sp,sp,-12
 2045b30:	dfc00215 	stw	ra,8(sp)
 2045b34:	df000115 	stw	fp,4(sp)
 2045b38:	df000104 	addi	fp,sp,4
 2045b3c:	e13fff15 	stw	r4,-4(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2045b40:	01000084 	movi	r4,2
 2045b44:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 2045b48:	e13fff17 	ldw	r4,-4(fp)
 2045b4c:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2045b50:	01000084 	movi	r4,2
 2045b54:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
}
 2045b58:	e037883a 	mov	sp,fp
 2045b5c:	dfc00117 	ldw	ra,4(sp)
 2045b60:	df000017 	ldw	fp,0(sp)
 2045b64:	dec00204 	addi	sp,sp,8
 2045b68:	f800283a 	ret

02045b6c <igmpv1_input>:
 * OUTPUT: This function returns IGMP_ERR if it is passed an "unknown"
 * packet type.  Otherwise, it returns IGMP_OK.
 */

int igmpv1_input(PACKET p)
{
 2045b6c:	defff804 	addi	sp,sp,-32
 2045b70:	dfc00715 	stw	ra,28(sp)
 2045b74:	df000615 	stw	fp,24(sp)
 2045b78:	df000604 	addi	fp,sp,24
 2045b7c:	e13fff15 	stw	r4,-4(fp)
   struct igmp *  igmp;
   struct ip *    pip;
   struct in_multi * inm;
   NET netp  = p->net;
 2045b80:	e0bfff17 	ldw	r2,-4(fp)
 2045b84:	10800617 	ldw	r2,24(r2)
 2045b88:	e0bffc15 	stw	r2,-16(fp)
   int rc;
         
   pip = ip_head (p);
 2045b8c:	e0bfff17 	ldw	r2,-4(fp)
 2045b90:	10800317 	ldw	r2,12(r2)
 2045b94:	e0bffd15 	stw	r2,-12(fp)
   igmp = (struct igmp *) (ip_data (pip));
 2045b98:	e0bffd17 	ldw	r2,-12(fp)
 2045b9c:	10800003 	ldbu	r2,0(r2)
 2045ba0:	10803fcc 	andi	r2,r2,255
 2045ba4:	108003cc 	andi	r2,r2,15
 2045ba8:	1085883a 	add	r2,r2,r2
 2045bac:	1085883a 	add	r2,r2,r2
 2045bb0:	e0fffd17 	ldw	r3,-12(fp)
 2045bb4:	1885883a 	add	r2,r3,r2
 2045bb8:	e0bffe15 	stw	r2,-8(fp)

   switch (igmp->igmp_type) 
 2045bbc:	e0bffe17 	ldw	r2,-8(fp)
 2045bc0:	10800003 	ldbu	r2,0(r2)
 2045bc4:	10803fcc 	andi	r2,r2,255
 2045bc8:	10c00460 	cmpeqi	r3,r2,17
 2045bcc:	1800031e 	bne	r3,zero,2045bdc <igmpv1_input+0x70>
 2045bd0:	108004a0 	cmpeqi	r2,r2,18
 2045bd4:	10005e1e 	bne	r2,zero,2045d50 <igmpv1_input+0x1e4>
 2045bd8:	00008106 	br	2045de0 <igmpv1_input+0x274>
   {
   case IGMP_HOST_MEMBERSHIP_QUERY:
      ++igmpstats.igmpv1mode_v1_queries_rcvd;
 2045bdc:	00809934 	movhi	r2,612
 2045be0:	10b5c504 	addi	r2,r2,-10476
 2045be4:	10800117 	ldw	r2,4(r2)
 2045be8:	10c00044 	addi	r3,r2,1
 2045bec:	00809934 	movhi	r2,612
 2045bf0:	10b5c504 	addi	r2,r2,-10476
 2045bf4:	10c00115 	stw	r3,4(r2)
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 2045bf8:	e0bffc17 	ldw	r2,-16(fp)
 2045bfc:	10802c17 	ldw	r2,176(r2)
 2045c00:	e0bffa15 	stw	r2,-24(fp)
 2045c04:	00004e06 	br	2045d40 <igmpv1_input+0x1d4>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
 2045c08:	e0bffa17 	ldw	r2,-24(fp)
 2045c0c:	10800017 	ldw	r2,0(r2)
 2045c10:	10004726 	beq	r2,zero,2045d30 <igmpv1_input+0x1c4>
            continue;
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 2045c14:	e0bffa17 	ldw	r2,-24(fp)
 2045c18:	10c00017 	ldw	r3,0(r2)
 2045c1c:	00808174 	movhi	r2,517
 2045c20:	1090b704 	addi	r2,r2,17116
 2045c24:	10800017 	ldw	r2,0(r2)
 2045c28:	18804226 	beq	r3,r2,2045d34 <igmpv1_input+0x1c8>
         {
            if (inm->inm_timer == 0)
 2045c2c:	e0bffa17 	ldw	r2,-24(fp)
 2045c30:	10800317 	ldw	r2,12(r2)
 2045c34:	10003f1e 	bne	r2,zero,2045d34 <igmpv1_input+0x1c8>
            {
               inm->inm_timer = (unsigned) IGMP_RANDOM_DELAY(inm->inm_addr);
 2045c38:	00809934 	movhi	r2,612
 2045c3c:	10b7d304 	addi	r2,r2,-8372
 2045c40:	10c00217 	ldw	r3,8(r2)
 2045c44:	00809934 	movhi	r2,612
 2045c48:	10b5c104 	addi	r2,r2,-10492
 2045c4c:	10800017 	ldw	r2,0(r2)
 2045c50:	10800a17 	ldw	r2,40(r2)
 2045c54:	1008d63a 	srli	r4,r2,24
 2045c58:	00809934 	movhi	r2,612
 2045c5c:	10b5c104 	addi	r2,r2,-10492
 2045c60:	10800017 	ldw	r2,0(r2)
 2045c64:	10800a17 	ldw	r2,40(r2)
 2045c68:	1004d23a 	srli	r2,r2,8
 2045c6c:	10bfc00c 	andi	r2,r2,65280
 2045c70:	2088b03a 	or	r4,r4,r2
 2045c74:	00809934 	movhi	r2,612
 2045c78:	10b5c104 	addi	r2,r2,-10492
 2045c7c:	10800017 	ldw	r2,0(r2)
 2045c80:	10800a17 	ldw	r2,40(r2)
 2045c84:	10bfc00c 	andi	r2,r2,65280
 2045c88:	1004923a 	slli	r2,r2,8
 2045c8c:	2088b03a 	or	r4,r4,r2
 2045c90:	00809934 	movhi	r2,612
 2045c94:	10b5c104 	addi	r2,r2,-10492
 2045c98:	10800017 	ldw	r2,0(r2)
 2045c9c:	10800a17 	ldw	r2,40(r2)
 2045ca0:	1004963a 	slli	r2,r2,24
 2045ca4:	2084b03a 	or	r2,r4,r2
 2045ca8:	1887883a 	add	r3,r3,r2
 2045cac:	e0bffa17 	ldw	r2,-24(fp)
 2045cb0:	10800017 	ldw	r2,0(r2)
 2045cb4:	1008d63a 	srli	r4,r2,24
 2045cb8:	e0bffa17 	ldw	r2,-24(fp)
 2045cbc:	10800017 	ldw	r2,0(r2)
 2045cc0:	1004d23a 	srli	r2,r2,8
 2045cc4:	10bfc00c 	andi	r2,r2,65280
 2045cc8:	2088b03a 	or	r4,r4,r2
 2045ccc:	e0bffa17 	ldw	r2,-24(fp)
 2045cd0:	10800017 	ldw	r2,0(r2)
 2045cd4:	10bfc00c 	andi	r2,r2,65280
 2045cd8:	1004923a 	slli	r2,r2,8
 2045cdc:	2088b03a 	or	r4,r4,r2
 2045ce0:	e0bffa17 	ldw	r2,-24(fp)
 2045ce4:	10800017 	ldw	r2,0(r2)
 2045ce8:	1004963a 	slli	r2,r2,24
 2045cec:	2084b03a 	or	r2,r4,r2
 2045cf0:	1885883a 	add	r2,r3,r2
 2045cf4:	00c00c84 	movi	r3,50
 2045cf8:	10c7203a 	divu	r3,r2,r3
 2045cfc:	18c00ca4 	muli	r3,r3,50
 2045d00:	10c5c83a 	sub	r2,r2,r3
 2045d04:	10c00044 	addi	r3,r2,1
 2045d08:	e0bffa17 	ldw	r2,-24(fp)
 2045d0c:	10c00315 	stw	r3,12(r2)
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
 2045d10:	00808174 	movhi	r2,517
 2045d14:	1090b504 	addi	r2,r2,17108
 2045d18:	10800017 	ldw	r2,0(r2)
 2045d1c:	10c00044 	addi	r3,r2,1
 2045d20:	00808174 	movhi	r2,517
 2045d24:	1090b504 	addi	r2,r2,17108
 2045d28:	10c00015 	stw	r3,0(r2)
 2045d2c:	00000106 	br	2045d34 <igmpv1_input+0x1c8>
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (inm->inm_addr == 0)
            continue;
 2045d30:	0001883a 	nop
       * Start the timers in all of our membership records for
       * the interface on which the query arrived, except those
       * that are already running and those that belong to the
       * "all-hosts" group.
       */
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 2045d34:	e0bffa17 	ldw	r2,-24(fp)
 2045d38:	10800517 	ldw	r2,20(r2)
 2045d3c:	e0bffa15 	stw	r2,-24(fp)
 2045d40:	e0bffa17 	ldw	r2,-24(fp)
 2045d44:	103fb01e 	bne	r2,zero,2045c08 <igmpv1_input+0x9c>
               /* increment the count of running timers */
               ++igmp_timers_are_running;            
            }   
         }
      }
      rc = IGMP_OK;
 2045d48:	e03ffb15 	stw	zero,-20(fp)
      break;
 2045d4c:	00002e06 	br	2045e08 <igmpv1_input+0x29c>

   case IGMP_HOST_MEMBERSHIP_REPORT:
      ++igmpstats.igmpv1mode_v1_reports_rcvd;
 2045d50:	00809934 	movhi	r2,612
 2045d54:	10b5c504 	addi	r2,r2,-10476
 2045d58:	10800217 	ldw	r2,8(r2)
 2045d5c:	10c00044 	addi	r3,r2,1
 2045d60:	00809934 	movhi	r2,612
 2045d64:	10b5c504 	addi	r2,r2,-10476
 2045d68:	10c00215 	stw	r3,8(r2)
      /*
       * If we belong to the group being reported and have a 
       * running timer for that group, stop our timer for that 
       * group.
       */
      inm = lookup_mcast(igmp->igmp_group, netp);
 2045d6c:	e0bffe17 	ldw	r2,-8(fp)
 2045d70:	10800117 	ldw	r2,4(r2)
 2045d74:	1009883a 	mov	r4,r2
 2045d78:	e17ffc17 	ldw	r5,-16(fp)
 2045d7c:	20440e40 	call	20440e4 <lookup_mcast>
 2045d80:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL) 
 2045d84:	e0bffa17 	ldw	r2,-24(fp)
 2045d88:	10001326 	beq	r2,zero,2045dd8 <igmpv1_input+0x26c>
      {
         if (inm->inm_timer > 0)
 2045d8c:	e0bffa17 	ldw	r2,-24(fp)
 2045d90:	10800317 	ldw	r2,12(r2)
 2045d94:	10001026 	beq	r2,zero,2045dd8 <igmpv1_input+0x26c>
         {
            inm->inm_timer = 0;
 2045d98:	e0bffa17 	ldw	r2,-24(fp)
 2045d9c:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 2045da0:	00808174 	movhi	r2,517
 2045da4:	1090b504 	addi	r2,r2,17108
 2045da8:	10800017 	ldw	r2,0(r2)
 2045dac:	10ffffc4 	addi	r3,r2,-1
 2045db0:	00808174 	movhi	r2,517
 2045db4:	1090b504 	addi	r2,r2,17108
 2045db8:	10c00015 	stw	r3,0(r2)
            ++igmpstats.igmpv1mode_v1_reports_rcvd_canceled_timer;
 2045dbc:	00809934 	movhi	r2,612
 2045dc0:	10b5c504 	addi	r2,r2,-10476
 2045dc4:	10800317 	ldw	r2,12(r2)
 2045dc8:	10c00044 	addi	r3,r2,1
 2045dcc:	00809934 	movhi	r2,612
 2045dd0:	10b5c504 	addi	r2,r2,-10476
 2045dd4:	10c00315 	stw	r3,12(r2)
         }
      }
      rc = IGMP_OK;
 2045dd8:	e03ffb15 	stw	zero,-20(fp)
      break;
 2045ddc:	00000a06 	br	2045e08 <igmpv1_input+0x29c>
      
   default:
      ++igmpstats.igmpv1mode_unknown_pkttype;
 2045de0:	00809934 	movhi	r2,612
 2045de4:	10b5c504 	addi	r2,r2,-10476
 2045de8:	10801017 	ldw	r2,64(r2)
 2045dec:	10c00044 	addi	r3,r2,1
 2045df0:	00809934 	movhi	r2,612
 2045df4:	10b5c504 	addi	r2,r2,-10476
 2045df8:	10c01015 	stw	r3,64(r2)
      rc = IGMP_ERR;
 2045dfc:	00bfffc4 	movi	r2,-1
 2045e00:	e0bffb15 	stw	r2,-20(fp)
      break;   
 2045e04:	0001883a 	nop
   }

   /* we're done with the received packet; return packet buffer back 
    * to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2045e08:	01000084 	movi	r4,2
 2045e0c:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 2045e10:	e13fff17 	ldw	r4,-4(fp)
 2045e14:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2045e18:	01000084 	movi	r4,2
 2045e1c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      
   return rc;
 2045e20:	e0bffb17 	ldw	r2,-20(fp)
}
 2045e24:	e037883a 	mov	sp,fp
 2045e28:	dfc00117 	ldw	ra,4(sp)
 2045e2c:	df000017 	ldw	fp,0(sp)
 2045e30:	dec00204 	addi	sp,sp,8
 2045e34:	f800283a 	ret

02045e38 <igmpv2_input>:
 * from igmpv2_process_report (), IGMP_OK (for a received Leave Group
 * message only), or IGMP_ERR (for a message of an "unknown" type).
 */

int igmpv2_input (PACKET p)
{
 2045e38:	defff804 	addi	sp,sp,-32
 2045e3c:	dfc00715 	stw	ra,28(sp)
 2045e40:	df000615 	stw	fp,24(sp)
 2045e44:	df000604 	addi	fp,sp,24
 2045e48:	e13fff15 	stw	r4,-4(fp)
   struct ip * pip;
   int igmplen;
   u_char type;
   int rc;

   pip = ip_head (p);    
 2045e4c:	e0bfff17 	ldw	r2,-4(fp)
 2045e50:	10800317 	ldw	r2,12(r2)
 2045e54:	e0bffb15 	stw	r2,-20(fp)
   /* compute length of IGMP packet (after accounting for IP header, 
    * including the IP Router Alert option (if present)) */   
   igmplen = p->nb_plen - ip_hlen (pip);
 2045e58:	e0bfff17 	ldw	r2,-4(fp)
 2045e5c:	10c00417 	ldw	r3,16(r2)
 2045e60:	e0bffb17 	ldw	r2,-20(fp)
 2045e64:	10800003 	ldbu	r2,0(r2)
 2045e68:	10803fcc 	andi	r2,r2,255
 2045e6c:	108003cc 	andi	r2,r2,15
 2045e70:	1085883a 	add	r2,r2,r2
 2045e74:	1085883a 	add	r2,r2,r2
 2045e78:	1885c83a 	sub	r2,r3,r2
 2045e7c:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 2045e80:	e0bffb17 	ldw	r2,-20(fp)
 2045e84:	10800003 	ldbu	r2,0(r2)
 2045e88:	10803fcc 	andi	r2,r2,255
 2045e8c:	108003cc 	andi	r2,r2,15
 2045e90:	1085883a 	add	r2,r2,r2
 2045e94:	1085883a 	add	r2,r2,r2
 2045e98:	e0fffb17 	ldw	r3,-20(fp)
 2045e9c:	1885883a 	add	r2,r3,r2
 2045ea0:	e0bffd15 	stw	r2,-12(fp)
   /* extract the IGMP packet type from received packet */
   type = igmp->igmp_type;
 2045ea4:	e0bffd17 	ldw	r2,-12(fp)
 2045ea8:	10800003 	ldbu	r2,0(r2)
 2045eac:	e0bffe05 	stb	r2,-8(fp)

   switch (type) 
 2045eb0:	e0bffe03 	ldbu	r2,-8(fp)
 2045eb4:	10c004a0 	cmpeqi	r3,r2,18
 2045eb8:	18000e1e 	bne	r3,zero,2045ef4 <igmpv2_input+0xbc>
 2045ebc:	10c004c8 	cmpgei	r3,r2,19
 2045ec0:	1800031e 	bne	r3,zero,2045ed0 <igmpv2_input+0x98>
 2045ec4:	10800460 	cmpeqi	r2,r2,17
 2045ec8:	1000061e 	bne	r2,zero,2045ee4 <igmpv2_input+0xac>
 2045ecc:	00001606 	br	2045f28 <igmpv2_input+0xf0>
 2045ed0:	10c005a0 	cmpeqi	r3,r2,22
 2045ed4:	1800071e 	bne	r3,zero,2045ef4 <igmpv2_input+0xbc>
 2045ed8:	108005e0 	cmpeqi	r2,r2,23
 2045edc:	1000091e 	bne	r2,zero,2045f04 <igmpv2_input+0xcc>
 2045ee0:	00001106 	br	2045f28 <igmpv2_input+0xf0>
   {
      case IGMP_HOST_MEMBERSHIP_QUERY:
         rc = igmpv2_process_query (p);
 2045ee4:	e13fff17 	ldw	r4,-4(fp)
 2045ee8:	20460c00 	call	20460c0 <igmpv2_process_query>
 2045eec:	e0bffa15 	stw	r2,-24(fp)
         break;
 2045ef0:	00001706 	br	2045f50 <igmpv2_input+0x118>

      case IGMP_HOST_MEMBERSHIP_REPORT:
      case IGMPv2_MEMBERSHIP_REPORT:
         rc = igmpv2_process_report (p);
 2045ef4:	e13fff17 	ldw	r4,-4(fp)
 2045ef8:	2045f800 	call	2045f80 <igmpv2_process_report>
 2045efc:	e0bffa15 	stw	r2,-24(fp)
         break;
 2045f00:	00001306 	br	2045f50 <igmpv2_input+0x118>
          * expect to receive such messages.  However, according to
          * RFC 2236, some implementations of an older version of the 
          * IGMPv2 specification send leave messages to the group 
          * being left.  If we do receive such a message, we will 
          * drop it. */       
         ++igmpstats.igmpv2mode_v2_leave_msgs_rcvd;
 2045f04:	00809934 	movhi	r2,612
 2045f08:	10b5c504 	addi	r2,r2,-10476
 2045f0c:	10800917 	ldw	r2,36(r2)
 2045f10:	10c00044 	addi	r3,r2,1
 2045f14:	00809934 	movhi	r2,612
 2045f18:	10b5c504 	addi	r2,r2,-10476
 2045f1c:	10c00915 	stw	r3,36(r2)
         rc = IGMP_OK;
 2045f20:	e03ffa15 	stw	zero,-24(fp)
         break;               
 2045f24:	00000a06 	br	2045f50 <igmpv2_input+0x118>

      default:     
         ++igmpstats.igmpv2mode_unknown_pkttype;
 2045f28:	00809934 	movhi	r2,612
 2045f2c:	10b5c504 	addi	r2,r2,-10476
 2045f30:	10801517 	ldw	r2,84(r2)
 2045f34:	10c00044 	addi	r3,r2,1
 2045f38:	00809934 	movhi	r2,612
 2045f3c:	10b5c504 	addi	r2,r2,-10476
 2045f40:	10c01515 	stw	r3,84(r2)
         rc = IGMP_ERR;         
 2045f44:	00bfffc4 	movi	r2,-1
 2045f48:	e0bffa15 	stw	r2,-24(fp)
         break;
 2045f4c:	0001883a 	nop
   } /* end SWITCH */

   /* we're done processing the received packet; return packet buffer 
    * back to free pool */
   LOCK_NET_RESOURCE(FREEQ_RESID);
 2045f50:	01000084 	movi	r4,2
 2045f54:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   pk_free(p);
 2045f58:	e13fff17 	ldw	r4,-4(fp)
 2045f5c:	20280440 	call	2028044 <pk_free>
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 2045f60:	01000084 	movi	r4,2
 2045f64:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   
   return rc;
 2045f68:	e0bffa17 	ldw	r2,-24(fp)
}
 2045f6c:	e037883a 	mov	sp,fp
 2045f70:	dfc00117 	ldw	ra,4(sp)
 2045f74:	df000017 	ldw	fp,0(sp)
 2045f78:	dec00204 	addi	sp,sp,8
 2045f7c:	f800283a 	ret

02045f80 <igmpv2_process_report>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_report (PACKET p)
{
 2045f80:	defff904 	addi	sp,sp,-28
 2045f84:	dfc00615 	stw	ra,24(sp)
 2045f88:	df000515 	stw	fp,20(sp)
 2045f8c:	df000504 	addi	fp,sp,20
 2045f90:	e13fff15 	stw	r4,-4(fp)
   struct igmp * igmp;
   struct ip * pip;
   NET netp;
   struct in_multi * inm;

   netp = p->net;
 2045f94:	e0bfff17 	ldw	r2,-4(fp)
 2045f98:	10800617 	ldw	r2,24(r2)
 2045f9c:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 2045fa0:	e0bfff17 	ldw	r2,-4(fp)
 2045fa4:	10800317 	ldw	r2,12(r2)
 2045fa8:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));   
 2045fac:	e0bffc17 	ldw	r2,-16(fp)
 2045fb0:	10800003 	ldbu	r2,0(r2)
 2045fb4:	10803fcc 	andi	r2,r2,255
 2045fb8:	108003cc 	andi	r2,r2,15
 2045fbc:	1085883a 	add	r2,r2,r2
 2045fc0:	1085883a 	add	r2,r2,r2
 2045fc4:	e0fffc17 	ldw	r3,-16(fp)
 2045fc8:	1885883a 	add	r2,r3,r2
 2045fcc:	e0bffd15 	stw	r2,-12(fp)
    * processing IGMPv2 packets (it has "downgraded" itself because
    * there are IGMPv1 routers on that network); however, we do not
    * know that, and hence we don't cancel our timer (for the 
    * subsequent transmission of a IGMPv1 report).
    */
   inm = lookup_mcast(igmp->igmp_group, netp);
 2045fd0:	e0bffd17 	ldw	r2,-12(fp)
 2045fd4:	10800117 	ldw	r2,4(r2)
 2045fd8:	1009883a 	mov	r4,r2
 2045fdc:	e17ffb17 	ldw	r5,-20(fp)
 2045fe0:	20440e40 	call	20440e4 <lookup_mcast>
 2045fe4:	e0bffe15 	stw	r2,-8(fp)
   if (inm != NULL) 
 2045fe8:	e0bffe17 	ldw	r2,-8(fp)
 2045fec:	10002726 	beq	r2,zero,204608c <igmpv2_process_report+0x10c>
   {
      if (inm->inm_timer != 0)
 2045ff0:	e0bffe17 	ldw	r2,-8(fp)
 2045ff4:	10800317 	ldw	r2,12(r2)
 2045ff8:	10001c26 	beq	r2,zero,204606c <igmpv2_process_report+0xec>
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 2045ffc:	e0bffb17 	ldw	r2,-20(fp)
 2046000:	10802d03 	ldbu	r2,180(r2)
 2046004:	10803fcc 	andi	r2,r2,255
 2046008:	10000526 	beq	r2,zero,2046020 <igmpv2_process_report+0xa0>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
 204600c:	e0bffd17 	ldw	r2,-12(fp)
 2046010:	10800003 	ldbu	r2,0(r2)
   if (inm != NULL) 
   {
      if (inm->inm_timer != 0)
      {
         /* we have a timer running */
         if (!(netp->igmpv1_rtr_present && 
 2046014:	10803fcc 	andi	r2,r2,255
 2046018:	108005a0 	cmpeqi	r2,r2,22
 204601c:	1000221e 	bne	r2,zero,20460a8 <igmpv2_process_report+0x128>
             igmp->igmp_type == IGMPv2_MEMBERSHIP_REPORT))
         {
            /* cancel timer */
            inm->inm_timer = 0;
 2046020:	e0bffe17 	ldw	r2,-8(fp)
 2046024:	10000315 	stw	zero,12(r2)
            /* decrement the count of running timers */
            --igmp_timers_are_running;
 2046028:	00808174 	movhi	r2,517
 204602c:	1090b504 	addi	r2,r2,17108
 2046030:	10800017 	ldw	r2,0(r2)
 2046034:	10ffffc4 	addi	r3,r2,-1
 2046038:	00808174 	movhi	r2,517
 204603c:	1090b504 	addi	r2,r2,17108
 2046040:	10c00015 	stw	r3,0(r2)
            /* indicate that we are not the last host to send a 
             * report for this group */
            inm->last2send_report = IGMP_FALSE;
 2046044:	e0bffe17 	ldw	r2,-8(fp)
 2046048:	10000405 	stb	zero,16(r2)
            ++igmpstats.igmpv2mode_v12_reports_rcvd_canceled_timer;
 204604c:	00809934 	movhi	r2,612
 2046050:	10b5c504 	addi	r2,r2,-10476
 2046054:	10800717 	ldw	r2,28(r2)
 2046058:	10c00044 	addi	r3,r2,1
 204605c:	00809934 	movhi	r2,612
 2046060:	10b5c504 	addi	r2,r2,-10476
 2046064:	10c00715 	stw	r3,28(r2)
 2046068:	00000f06 	br	20460a8 <igmpv2_process_report+0x128>
      else
      {
         /* we don't have a timer running; perhaps the source
          * host has just joined the group, and has sent an
          * unsolicited report */
         ++igmpstats.igmpv2mode_v12_reports_rcvd_no_timer;   
 204606c:	00809934 	movhi	r2,612
 2046070:	10b5c504 	addi	r2,r2,-10476
 2046074:	10800817 	ldw	r2,32(r2)
 2046078:	10c00044 	addi	r3,r2,1
 204607c:	00809934 	movhi	r2,612
 2046080:	10b5c504 	addi	r2,r2,-10476
 2046084:	10c00815 	stw	r3,32(r2)
 2046088:	00000706 	br	20460a8 <igmpv2_process_report+0x128>
       * on that interface.  Even if imperfect filtering at the 
       * device level causes reports for unregistered groups to 
       * be passed up to the IP module, ip_rcv_phase2 () is 
       * responsible for dropping them, and so we should never
       * receive such packets. */
      ++igmpstats.igmpv2mode_v12_unknown_grp_reports_rcvd;
 204608c:	00809934 	movhi	r2,612
 2046090:	10b5c504 	addi	r2,r2,-10476
 2046094:	10801317 	ldw	r2,76(r2)
 2046098:	10c00044 	addi	r3,r2,1
 204609c:	00809934 	movhi	r2,612
 20460a0:	10b5c504 	addi	r2,r2,-10476
 20460a4:	10c01315 	stw	r3,76(r2)
   }
   
   return IGMP_OK;   
 20460a8:	0005883a 	mov	r2,zero
}
 20460ac:	e037883a 	mov	sp,fp
 20460b0:	dfc00117 	ldw	ra,4(sp)
 20460b4:	df000017 	ldw	fp,0(sp)
 20460b8:	dec00204 	addi	sp,sp,8
 20460bc:	f800283a 	ret

020460c0 <igmpv2_process_query>:
 *
 * OUTPUT: This function always returns IGMP_OK.
 */

int igmpv2_process_query (PACKET p)
{
 20460c0:	defff704 	addi	sp,sp,-36
 20460c4:	dfc00815 	stw	ra,32(sp)
 20460c8:	df000715 	stw	fp,28(sp)
 20460cc:	df000704 	addi	fp,sp,28
 20460d0:	e13fff15 	stw	r4,-4(fp)
   u_short max_resp_time;
   u_char process_all;
   struct in_multi * inm;
   ip_addr mcgrp_addr;

   netp = p->net;
 20460d4:	e0bfff17 	ldw	r2,-4(fp)
 20460d8:	10800617 	ldw	r2,24(r2)
 20460dc:	e0bffb15 	stw	r2,-20(fp)
   pip = ip_head (p);
 20460e0:	e0bfff17 	ldw	r2,-4(fp)
 20460e4:	10800317 	ldw	r2,12(r2)
 20460e8:	e0bffc15 	stw	r2,-16(fp)
   igmp = (struct igmp *) (ip_data (pip));
 20460ec:	e0bffc17 	ldw	r2,-16(fp)
 20460f0:	10800003 	ldbu	r2,0(r2)
 20460f4:	10803fcc 	andi	r2,r2,255
 20460f8:	108003cc 	andi	r2,r2,15
 20460fc:	1085883a 	add	r2,r2,r2
 2046100:	1085883a 	add	r2,r2,r2
 2046104:	e0fffc17 	ldw	r3,-16(fp)
 2046108:	1885883a 	add	r2,r3,r2
 204610c:	e0bffd15 	stw	r2,-12(fp)
   mcgrp_addr = ntohl(igmp->igmp_group);
 2046110:	e0bffd17 	ldw	r2,-12(fp)
 2046114:	10800117 	ldw	r2,4(r2)
 2046118:	1006d63a 	srli	r3,r2,24
 204611c:	e0bffd17 	ldw	r2,-12(fp)
 2046120:	10800117 	ldw	r2,4(r2)
 2046124:	1004d23a 	srli	r2,r2,8
 2046128:	10bfc00c 	andi	r2,r2,65280
 204612c:	1886b03a 	or	r3,r3,r2
 2046130:	e0bffd17 	ldw	r2,-12(fp)
 2046134:	10800117 	ldw	r2,4(r2)
 2046138:	10bfc00c 	andi	r2,r2,65280
 204613c:	1004923a 	slli	r2,r2,8
 2046140:	1886b03a 	or	r3,r3,r2
 2046144:	e0bffd17 	ldw	r2,-12(fp)
 2046148:	10800117 	ldw	r2,4(r2)
 204614c:	1004963a 	slli	r2,r2,24
 2046150:	1884b03a 	or	r2,r3,r2
 2046154:	e0bffe15 	stw	r2,-8(fp)

   if (igmp->igmp_code == 0)
 2046158:	e0bffd17 	ldw	r2,-12(fp)
 204615c:	10800043 	ldbu	r2,1(r2)
 2046160:	10803fcc 	andi	r2,r2,255
 2046164:	1000141e 	bne	r2,zero,20461b8 <igmpv2_process_query+0xf8>
   {
      /* this is a IGMPv1 Host Membership Query */
      netp->igmpv1_rtr_present = IGMP_TRUE;
 2046168:	e0bffb17 	ldw	r2,-20(fp)
 204616c:	00c00044 	movi	r3,1
 2046170:	10c02d05 	stb	r3,180(r2)
      netp->igmpv1_query_rcvd_time = cticks;      
 2046174:	00808174 	movhi	r2,517
 2046178:	1090c904 	addi	r2,r2,17188
 204617c:	10c00017 	ldw	r3,0(r2)
 2046180:	e0bffb17 	ldw	r2,-20(fp)
 2046184:	10c02e15 	stw	r3,184(r2)
      ++igmpstats.igmpv2mode_v1_queries_rcvd;
 2046188:	00809934 	movhi	r2,612
 204618c:	10b5c504 	addi	r2,r2,-10476
 2046190:	10800417 	ldw	r2,16(r2)
 2046194:	10c00044 	addi	r3,r2,1
 2046198:	00809934 	movhi	r2,612
 204619c:	10b5c504 	addi	r2,r2,-10476
 20461a0:	10c00415 	stw	r3,16(r2)
      /* set maximum time to respond to the equivalent of 10 
       * seconds worth of "ticks" (the timeout routine is
       * intended to be invoked PR_FASTHZ (5) times a second,
       * so each tick is equal to 200 ms) */
      max_resp_time = IGMP_MAX_HOST_REPORT_DELAY * PR_FASTHZ;
 20461a4:	00800c84 	movi	r2,50
 20461a8:	e0bff90d 	sth	r2,-28(fp)
      process_all = IGMP_TRUE;
 20461ac:	00800044 	movi	r2,1
 20461b0:	e0bff985 	stb	r2,-26(fp)
 20461b4:	00001c06 	br	2046228 <igmpv2_process_query+0x168>
   }
   else
   {
      /* this is either a IGMPv2 General Query or 
       * a IGMPv2 Group-Specific Query */
      if (igmp->igmp_group == 0)
 20461b8:	e0bffd17 	ldw	r2,-12(fp)
 20461bc:	10800117 	ldw	r2,4(r2)
 20461c0:	10000a1e 	bne	r2,zero,20461ec <igmpv2_process_query+0x12c>
      {
         /* this is a IGMPv2 General Query */
         ++igmpstats.igmpv2mode_v2_general_queries_rcvd;
 20461c4:	00809934 	movhi	r2,612
 20461c8:	10b5c504 	addi	r2,r2,-10476
 20461cc:	10800517 	ldw	r2,20(r2)
 20461d0:	10c00044 	addi	r3,r2,1
 20461d4:	00809934 	movhi	r2,612
 20461d8:	10b5c504 	addi	r2,r2,-10476
 20461dc:	10c00515 	stw	r3,20(r2)
         process_all = IGMP_TRUE;
 20461e0:	00800044 	movi	r2,1
 20461e4:	e0bff985 	stb	r2,-26(fp)
 20461e8:	00000806 	br	204620c <igmpv2_process_query+0x14c>
      }
      else
      {
         /* this is a IGMPv2 Group-Specific Query */       
         ++igmpstats.igmpv2mode_v2_grp_specific_queries_rcvd;
 20461ec:	00809934 	movhi	r2,612
 20461f0:	10b5c504 	addi	r2,r2,-10476
 20461f4:	10800617 	ldw	r2,24(r2)
 20461f8:	10c00044 	addi	r3,r2,1
 20461fc:	00809934 	movhi	r2,612
 2046200:	10b5c504 	addi	r2,r2,-10476
 2046204:	10c00615 	stw	r3,24(r2)
         process_all = IGMP_FALSE;
 2046208:	e03ff985 	stb	zero,-26(fp)
       * IGMPv2 General Query or a IGMPv2 Group-Specific Query,
       * set maximum time to respond to value extracted 
       * from received message. The value in the message
       * is in tenths of a second.  max_resp_time is in
       * units of ticks (where one tick is 200 ms) */
      max_resp_time = (igmp->igmp_code * PR_FASTHZ) / 10;
 204620c:	e0bffd17 	ldw	r2,-12(fp)
 2046210:	10800043 	ldbu	r2,1(r2)
 2046214:	10803fcc 	andi	r2,r2,255
 2046218:	10c00164 	muli	r3,r2,5
 204621c:	00800284 	movi	r2,10
 2046220:	1885283a 	div	r2,r3,r2
 2046224:	e0bff90d 	sth	r2,-28(fp)
   
   /* process all entries in a link's multicast address linked
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
 2046228:	e0bff983 	ldbu	r2,-26(fp)
 204622c:	10001926 	beq	r2,zero,2046294 <igmpv2_process_query+0x1d4>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 2046230:	e0bffb17 	ldw	r2,-20(fp)
 2046234:	10802c17 	ldw	r2,176(r2)
 2046238:	e0bffa15 	stw	r2,-24(fp)
 204623c:	00001206 	br	2046288 <igmpv2_process_query+0x1c8>
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 2046240:	e0bffa17 	ldw	r2,-24(fp)
 2046244:	10800017 	ldw	r2,0(r2)
 2046248:	10000b26 	beq	r2,zero,2046278 <igmpv2_process_query+0x1b8>
         /* skip IPv4 multicast address of 224.0.0.1 (note that
          * the IPv4 address stored in inm_addr is in network 
          * byte order */
         if (inm->inm_addr != igmp_all_hosts_group)
 204624c:	e0bffa17 	ldw	r2,-24(fp)
 2046250:	10c00017 	ldw	r3,0(r2)
 2046254:	00808174 	movhi	r2,517
 2046258:	1090b704 	addi	r2,r2,17116
 204625c:	10800017 	ldw	r2,0(r2)
 2046260:	18800626 	beq	r3,r2,204627c <igmpv2_process_query+0x1bc>
            igmpv2_chk_set_timer (inm, max_resp_time);
 2046264:	e0bff90b 	ldhu	r2,-28(fp)
 2046268:	e13ffa17 	ldw	r4,-24(fp)
 204626c:	100b883a 	mov	r5,r2
 2046270:	20462fc0 	call	20462fc <igmpv2_chk_set_timer>
 2046274:	00000106 	br	204627c <igmpv2_process_query+0x1bc>
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
      {
         /* skip all IPv6 entries - they are indicated by 
          * an IPv4 address field of 0 */
         if (!(inm->inm_addr)) continue;
 2046278:	0001883a 	nop
    * list (pointed to by mc_list) as part of the response to
    * the received IGMPv1 Host Membership Query or IGMPv2 General
    * Query message */
   if (process_all)
   {
      for (inm = netp->mc_list; inm; inm = inm->inm_next)
 204627c:	e0bffa17 	ldw	r2,-24(fp)
 2046280:	10800517 	ldw	r2,20(r2)
 2046284:	e0bffa15 	stw	r2,-24(fp)
 2046288:	e0bffa17 	ldw	r2,-24(fp)
 204628c:	103fec1e 	bne	r2,zero,2046240 <igmpv2_process_query+0x180>
 2046290:	00001406 	br	20462e4 <igmpv2_process_query+0x224>
   {
      /* process one (for IGMPv2 Group-Specific Query) entry (the 
       * one that corresponds to the address listed in the received 
       * query) - it should be present in the link's multicast
       * address list */
      inm = lookup_mcast(igmp->igmp_group, netp);
 2046294:	e0bffd17 	ldw	r2,-12(fp)
 2046298:	10800117 	ldw	r2,4(r2)
 204629c:	1009883a 	mov	r4,r2
 20462a0:	e17ffb17 	ldw	r5,-20(fp)
 20462a4:	20440e40 	call	20440e4 <lookup_mcast>
 20462a8:	e0bffa15 	stw	r2,-24(fp)
      if (inm != NULL)
 20462ac:	e0bffa17 	ldw	r2,-24(fp)
 20462b0:	10000526 	beq	r2,zero,20462c8 <igmpv2_process_query+0x208>
         igmpv2_chk_set_timer (inm, max_resp_time);
 20462b4:	e0bff90b 	ldhu	r2,-28(fp)
 20462b8:	e13ffa17 	ldw	r4,-24(fp)
 20462bc:	100b883a 	mov	r5,r2
 20462c0:	20462fc0 	call	20462fc <igmpv2_chk_set_timer>
 20462c4:	00000706 	br	20462e4 <igmpv2_process_query+0x224>
      else ++igmpstats.igmpv2mode_v2_unknown_grp_specific_queries_rcvd;
 20462c8:	00809934 	movhi	r2,612
 20462cc:	10b5c504 	addi	r2,r2,-10476
 20462d0:	10801217 	ldw	r2,72(r2)
 20462d4:	10c00044 	addi	r3,r2,1
 20462d8:	00809934 	movhi	r2,612
 20462dc:	10b5c504 	addi	r2,r2,-10476
 20462e0:	10c01215 	stw	r3,72(r2)
   } /* end ELSE (process ALL) */
   
   /* return success; caller will the received packet back to the 
    * free pool */
   return IGMP_OK;
 20462e4:	0005883a 	mov	r2,zero
}
 20462e8:	e037883a 	mov	sp,fp
 20462ec:	dfc00117 	ldw	ra,4(sp)
 20462f0:	df000017 	ldw	fp,0(sp)
 20462f4:	dec00204 	addi	sp,sp,8
 20462f8:	f800283a 	ret

020462fc <igmpv2_chk_set_timer>:
 *
 * OUTPUT: None.
 */

void igmpv2_chk_set_timer (struct in_multi * inm, u_short max_resp_time)
{  
 20462fc:	defffd04 	addi	sp,sp,-12
 2046300:	df000215 	stw	fp,8(sp)
 2046304:	df000204 	addi	fp,sp,8
 2046308:	e13ffe15 	stw	r4,-8(fp)
 204630c:	2805883a 	mov	r2,r5
 2046310:	e0bfff0d 	sth	r2,-4(fp)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 2046314:	e0bffe17 	ldw	r2,-8(fp)
 2046318:	10800317 	ldw	r2,12(r2)
 204631c:	e0ffff0b 	ldhu	r3,-4(fp)
 2046320:	18800336 	bltu	r3,r2,2046330 <igmpv2_chk_set_timer+0x34>
       (inm->inm_timer == 0))
 2046324:	e0bffe17 	ldw	r2,-8(fp)
 2046328:	10800317 	ldw	r2,12(r2)

    * Otherwise, the current timer for this group is scheduled 
    * to expire within the duration indicated in the Query 
    * message, so we let it continue. 
    */
   if ((inm->inm_timer > max_resp_time) ||
 204632c:	1000401e 	bne	r2,zero,2046430 <igmpv2_chk_set_timer+0x134>
       (inm->inm_timer == 0))
   {
      if (inm->inm_timer == 0) ++igmp_timers_are_running;
 2046330:	e0bffe17 	ldw	r2,-8(fp)
 2046334:	10800317 	ldw	r2,12(r2)
 2046338:	1000071e 	bne	r2,zero,2046358 <igmpv2_chk_set_timer+0x5c>
 204633c:	00808174 	movhi	r2,517
 2046340:	1090b504 	addi	r2,r2,17108
 2046344:	10800017 	ldw	r2,0(r2)
 2046348:	10c00044 	addi	r3,r2,1
 204634c:	00808174 	movhi	r2,517
 2046350:	1090b504 	addi	r2,r2,17108
 2046354:	10c00015 	stw	r3,0(r2)
      inm->inm_timer = (unsigned) IGMPv2_RANDOM_DELAY (max_resp_time, inm->inm_addr);                     
 2046358:	00809934 	movhi	r2,612
 204635c:	10b7d304 	addi	r2,r2,-8372
 2046360:	10c00217 	ldw	r3,8(r2)
 2046364:	00809934 	movhi	r2,612
 2046368:	10b5c104 	addi	r2,r2,-10492
 204636c:	10800017 	ldw	r2,0(r2)
 2046370:	10800a17 	ldw	r2,40(r2)
 2046374:	1008d63a 	srli	r4,r2,24
 2046378:	00809934 	movhi	r2,612
 204637c:	10b5c104 	addi	r2,r2,-10492
 2046380:	10800017 	ldw	r2,0(r2)
 2046384:	10800a17 	ldw	r2,40(r2)
 2046388:	1004d23a 	srli	r2,r2,8
 204638c:	10bfc00c 	andi	r2,r2,65280
 2046390:	2088b03a 	or	r4,r4,r2
 2046394:	00809934 	movhi	r2,612
 2046398:	10b5c104 	addi	r2,r2,-10492
 204639c:	10800017 	ldw	r2,0(r2)
 20463a0:	10800a17 	ldw	r2,40(r2)
 20463a4:	10bfc00c 	andi	r2,r2,65280
 20463a8:	1004923a 	slli	r2,r2,8
 20463ac:	2088b03a 	or	r4,r4,r2
 20463b0:	00809934 	movhi	r2,612
 20463b4:	10b5c104 	addi	r2,r2,-10492
 20463b8:	10800017 	ldw	r2,0(r2)
 20463bc:	10800a17 	ldw	r2,40(r2)
 20463c0:	1004963a 	slli	r2,r2,24
 20463c4:	2084b03a 	or	r2,r4,r2
 20463c8:	1887883a 	add	r3,r3,r2
 20463cc:	e0bffe17 	ldw	r2,-8(fp)
 20463d0:	10800017 	ldw	r2,0(r2)
 20463d4:	1008d63a 	srli	r4,r2,24
 20463d8:	e0bffe17 	ldw	r2,-8(fp)
 20463dc:	10800017 	ldw	r2,0(r2)
 20463e0:	1004d23a 	srli	r2,r2,8
 20463e4:	10bfc00c 	andi	r2,r2,65280
 20463e8:	2088b03a 	or	r4,r4,r2
 20463ec:	e0bffe17 	ldw	r2,-8(fp)
 20463f0:	10800017 	ldw	r2,0(r2)
 20463f4:	10bfc00c 	andi	r2,r2,65280
 20463f8:	1004923a 	slli	r2,r2,8
 20463fc:	2088b03a 	or	r4,r4,r2
 2046400:	e0bffe17 	ldw	r2,-8(fp)
 2046404:	10800017 	ldw	r2,0(r2)
 2046408:	1004963a 	slli	r2,r2,24
 204640c:	2084b03a 	or	r2,r4,r2
 2046410:	1885883a 	add	r2,r3,r2
 2046414:	e0ffff0b 	ldhu	r3,-4(fp)
 2046418:	10c9203a 	divu	r4,r2,r3
 204641c:	20c7383a 	mul	r3,r4,r3
 2046420:	10c5c83a 	sub	r2,r2,r3
 2046424:	10c00044 	addi	r3,r2,1
 2046428:	e0bffe17 	ldw	r2,-8(fp)
 204642c:	10c00315 	stw	r3,12(r2)
   }

   return;
 2046430:	0001883a 	nop
}
 2046434:	e037883a 	mov	sp,fp
 2046438:	df000017 	ldw	fp,0(sp)
 204643c:	dec00104 	addi	sp,sp,4
 2046440:	f800283a 	ret

02046444 <igmpv2_chk4_rtr_alert_opt>:
 *         the IP Router Alert option in the received
 *         packet, and IGMP_FALSE otherwise.
 */

u_char igmpv2_chk4_rtr_alert_opt (struct ip * pip)
{
 2046444:	defffb04 	addi	sp,sp,-20
 2046448:	df000415 	stw	fp,16(sp)
 204644c:	df000404 	addi	fp,sp,16
 2046450:	e13fff15 	stw	r4,-4(fp)
   u_long * rtr_alert_optp;
   u_char total_optlen;
   u_char optlen;
   u_char optval;

   total_optlen = ip_hlen (pip) - sizeof (struct ip);
 2046454:	e0bfff17 	ldw	r2,-4(fp)
 2046458:	10800003 	ldbu	r2,0(r2)
 204645c:	108003cc 	andi	r2,r2,15
 2046460:	1085883a 	add	r2,r2,r2
 2046464:	1085883a 	add	r2,r2,r2
 2046468:	10bffb04 	addi	r2,r2,-20
 204646c:	e0bffd05 	stb	r2,-12(fp)

   if (total_optlen > 0)
 2046470:	e0bffd03 	ldbu	r2,-12(fp)
 2046474:	10003e26 	beq	r2,zero,2046570 <igmpv2_chk4_rtr_alert_opt+0x12c>
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
 2046478:	e0bfff17 	ldw	r2,-4(fp)
 204647c:	10800504 	addi	r2,r2,20
 2046480:	e0bffc15 	stw	r2,-16(fp)
  
      while (total_optlen > 0)
 2046484:	00003806 	br	2046568 <igmpv2_chk4_rtr_alert_opt+0x124>
      {
         /* only the lowermost 5 bits are significant */    
         optval = (*optp) & IPOPT_TYPE_MASK;
 2046488:	e0bffc17 	ldw	r2,-16(fp)
 204648c:	10800003 	ldbu	r2,0(r2)
 2046490:	108007cc 	andi	r2,r2,31
 2046494:	e0bffd85 	stb	r2,-10(fp)
         switch (optval)
 2046498:	e0bffd83 	ldbu	r2,-10(fp)
 204649c:	10c00060 	cmpeqi	r3,r2,1
 20464a0:	1800071e 	bne	r3,zero,20464c0 <igmpv2_chk4_rtr_alert_opt+0x7c>
 20464a4:	10c00520 	cmpeqi	r3,r2,20
 20464a8:	1800081e 	bne	r3,zero,20464cc <igmpv2_chk4_rtr_alert_opt+0x88>
 20464ac:	1000201e 	bne	r2,zero,2046530 <igmpv2_chk4_rtr_alert_opt+0xec>
         {
            case EOL_OPT:
               /* we've encountered the End of Option List option, 
                * and so setting optlen isn't necessary */
               optlen = 1;
 20464b0:	00800044 	movi	r2,1
 20464b4:	e0bffd45 	stb	r2,-11(fp)
               /* we're done - we couldn't locate the IP Router Alert 
                * option in this IP header */
               return IGMP_FALSE;
 20464b8:	0005883a 	mov	r2,zero
 20464bc:	00002d06 	br	2046574 <igmpv2_chk4_rtr_alert_opt+0x130>
         
            case NOOP_OPT:
               /* skip past the one byte of the No Operation option */
               optlen = 1;
 20464c0:	00800044 	movi	r2,1
 20464c4:	e0bffd45 	stb	r2,-11(fp)
               break;
 20464c8:	00001f06 	br	2046548 <igmpv2_chk4_rtr_alert_opt+0x104>
         
            case IP_RTR_ALERT_OPT:
               rtr_alert_optp = (u_long *) optp; 
 20464cc:	e0bffc17 	ldw	r2,-16(fp)
 20464d0:	e0bffe15 	stw	r2,-8(fp)
               if ((ntohl (*rtr_alert_optp)) == IP_RTR_ALERT_OPT_DATA)
 20464d4:	e0bffe17 	ldw	r2,-8(fp)
 20464d8:	10800017 	ldw	r2,0(r2)
 20464dc:	1006d63a 	srli	r3,r2,24
 20464e0:	e0bffe17 	ldw	r2,-8(fp)
 20464e4:	10800017 	ldw	r2,0(r2)
 20464e8:	1004d23a 	srli	r2,r2,8
 20464ec:	10bfc00c 	andi	r2,r2,65280
 20464f0:	1886b03a 	or	r3,r3,r2
 20464f4:	e0bffe17 	ldw	r2,-8(fp)
 20464f8:	10800017 	ldw	r2,0(r2)
 20464fc:	10bfc00c 	andi	r2,r2,65280
 2046500:	1004923a 	slli	r2,r2,8
 2046504:	1886b03a 	or	r3,r3,r2
 2046508:	e0bffe17 	ldw	r2,-8(fp)
 204650c:	10800017 	ldw	r2,0(r2)
 2046510:	1004963a 	slli	r2,r2,24
 2046514:	1886b03a 	or	r3,r3,r2
 2046518:	00a50134 	movhi	r2,37892
 204651c:	1880021e 	bne	r3,r2,2046528 <igmpv2_chk4_rtr_alert_opt+0xe4>
                  /* found the option, return success */
                  return IGMP_TRUE;
 2046520:	00800044 	movi	r2,1
 2046524:	00001306 	br	2046574 <igmpv2_chk4_rtr_alert_opt+0x130>
               else return IGMP_FALSE;
 2046528:	0005883a 	mov	r2,zero
 204652c:	00001106 	br	2046574 <igmpv2_chk4_rtr_alert_opt+0x130>
          
            default:
               /* extract the length of the current option, and compute
                * the total length of this option */
               optlen = (*(optp + 1)) + 2;
 2046530:	e0bffc17 	ldw	r2,-16(fp)
 2046534:	10800044 	addi	r2,r2,1
 2046538:	10800003 	ldbu	r2,0(r2)
 204653c:	10800084 	addi	r2,r2,2
 2046540:	e0bffd45 	stb	r2,-11(fp)
               break;
 2046544:	0001883a 	nop
         }
         
         /* skip past the bytes associated with the current option to 
          * point to the next option. */
         optp += optlen;
 2046548:	e0bffd43 	ldbu	r2,-11(fp)
 204654c:	e0fffc17 	ldw	r3,-16(fp)
 2046550:	1885883a 	add	r2,r3,r2
 2046554:	e0bffc15 	stw	r2,-16(fp)
         total_optlen -= optlen;
 2046558:	e0fffd03 	ldbu	r3,-12(fp)
 204655c:	e0bffd43 	ldbu	r2,-11(fp)
 2046560:	1885c83a 	sub	r2,r3,r2
 2046564:	e0bffd05 	stb	r2,-12(fp)
   if (total_optlen > 0)
   {
      /* point to just past the end of the IP header */
      optp = (u_char *) (pip + 1);
  
      while (total_optlen > 0)
 2046568:	e0bffd03 	ldbu	r2,-12(fp)
 204656c:	103fc61e 	bne	r2,zero,2046488 <igmpv2_chk4_rtr_alert_opt+0x44>
         total_optlen -= optlen;
      } /* end WHILE */
   }

   /* didn't find IP Alert option in IP header of rcvd packet */
   return IGMP_FALSE;
 2046570:	0005883a 	mov	r2,zero
}
 2046574:	e037883a 	mov	sp,fp
 2046578:	df000017 	ldw	fp,0(sp)
 204657c:	dec00104 	addi	sp,sp,4
 2046580:	f800283a 	ret

02046584 <IPADDR_TO_NETP>:
 * RETURNS: 
 */

void
IPADDR_TO_NETP(ip_addr addr, NET* netp)
{
 2046584:	defffc04 	addi	sp,sp,-16
 2046588:	df000315 	stw	fp,12(sp)
 204658c:	df000304 	addi	fp,sp,12
 2046590:	e13ffe15 	stw	r4,-8(fp)
 2046594:	e17fff15 	stw	r5,-4(fp)
   u_short  idx   =  0;
 2046598:	e03ffd0d 	sth	zero,-12(fp)
   *netp = nets[idx];
 204659c:	e0bffd0b 	ldhu	r2,-12(fp)
 20465a0:	00c09934 	movhi	r3,612
 20465a4:	18f5c104 	addi	r3,r3,-10492
 20465a8:	1085883a 	add	r2,r2,r2
 20465ac:	1085883a 	add	r2,r2,r2
 20465b0:	1885883a 	add	r2,r3,r2
 20465b4:	10c00017 	ldw	r3,0(r2)
 20465b8:	e0bfff17 	ldw	r2,-4(fp)
 20465bc:	10c00015 	stw	r3,0(r2)
/*
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
 20465c0:	e0bffe17 	ldw	r2,-8(fp)
 20465c4:	1000341e 	bne	r2,zero,2046698 <IPADDR_TO_NETP+0x114>
   {
      for (idx = 0; idx < ifNumber; idx++)
 20465c8:	e03ffd0d 	sth	zero,-12(fp)
 20465cc:	00001706 	br	204662c <IPADDR_TO_NETP+0xa8>
      {
         if (nets[idx]->n_mcastlist)
 20465d0:	e0bffd0b 	ldhu	r2,-12(fp)
 20465d4:	00c09934 	movhi	r3,612
 20465d8:	18f5c104 	addi	r3,r3,-10492
 20465dc:	1085883a 	add	r2,r2,r2
 20465e0:	1085883a 	add	r2,r2,r2
 20465e4:	1885883a 	add	r2,r3,r2
 20465e8:	10800017 	ldw	r2,0(r2)
 20465ec:	10802b17 	ldw	r2,172(r2)
 20465f0:	10000b26 	beq	r2,zero,2046620 <IPADDR_TO_NETP+0x9c>
         {
            *netp = nets[idx];
 20465f4:	e0bffd0b 	ldhu	r2,-12(fp)
 20465f8:	00c09934 	movhi	r3,612
 20465fc:	18f5c104 	addi	r3,r3,-10492
 2046600:	1085883a 	add	r2,r2,r2
 2046604:	1085883a 	add	r2,r2,r2
 2046608:	1885883a 	add	r2,r3,r2
 204660c:	10c00017 	ldw	r3,0(r2)
 2046610:	e0bfff17 	ldw	r2,-4(fp)
 2046614:	10c00015 	stw	r3,0(r2)
            break;
 2046618:	0001883a 	nop
 204661c:	00002706 	br	20466bc <IPADDR_TO_NETP+0x138>
 * If ip address is not specified, return the first intfc that supports
 * multicast
 */
   if (addr == AADDR) 
   {
      for (idx = 0; idx < ifNumber; idx++)
 2046620:	e0bffd0b 	ldhu	r2,-12(fp)
 2046624:	10800044 	addi	r2,r2,1
 2046628:	e0bffd0d 	sth	r2,-12(fp)
 204662c:	e0fffd0b 	ldhu	r3,-12(fp)
 2046630:	00808174 	movhi	r2,517
 2046634:	1090b304 	addi	r2,r2,17100
 2046638:	10800017 	ldw	r2,0(r2)
 204663c:	18bfe436 	bltu	r3,r2,20465d0 <IPADDR_TO_NETP+0x4c>
 2046640:	00001e06 	br	20466bc <IPADDR_TO_NETP+0x138>
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
      {
         idx++;
 2046644:	e0bffd0b 	ldhu	r2,-12(fp)
 2046648:	10800044 	addi	r2,r2,1
 204664c:	e0bffd0d 	sth	r2,-12(fp)
         if (idx >= ifNumber)
 2046650:	e0fffd0b 	ldhu	r3,-12(fp)
 2046654:	00808174 	movhi	r2,517
 2046658:	1090b304 	addi	r2,r2,17100
 204665c:	10800017 	ldw	r2,0(r2)
 2046660:	18800336 	bltu	r3,r2,2046670 <IPADDR_TO_NETP+0xec>
         {
            *netp = NULL;
 2046664:	e0bfff17 	ldw	r2,-4(fp)
 2046668:	10000015 	stw	zero,0(r2)
            break;
 204666c:	00001306 	br	20466bc <IPADDR_TO_NETP+0x138>
         }
         else
            *netp = nets[idx];
 2046670:	e0bffd0b 	ldhu	r2,-12(fp)
 2046674:	00c09934 	movhi	r3,612
 2046678:	18f5c104 	addi	r3,r3,-10492
 204667c:	1085883a 	add	r2,r2,r2
 2046680:	1085883a 	add	r2,r2,r2
 2046684:	1885883a 	add	r2,r3,r2
 2046688:	10c00017 	ldw	r3,0(r2)
 204668c:	e0bfff17 	ldw	r2,-4(fp)
 2046690:	10c00015 	stw	r3,0(r2)
 2046694:	00000106 	br	204669c <IPADDR_TO_NETP+0x118>
         }
      }
   }
   else  /* ip address specified- return the corresponding interface */
   {
      while ((*netp != NULL) && ((*netp)->n_ipaddr != addr))
 2046698:	0001883a 	nop
 204669c:	e0bfff17 	ldw	r2,-4(fp)
 20466a0:	10800017 	ldw	r2,0(r2)
 20466a4:	10000526 	beq	r2,zero,20466bc <IPADDR_TO_NETP+0x138>
 20466a8:	e0bfff17 	ldw	r2,-4(fp)
 20466ac:	10800017 	ldw	r2,0(r2)
 20466b0:	10c00a17 	ldw	r3,40(r2)
 20466b4:	e0bffe17 	ldw	r2,-8(fp)
 20466b8:	18bfe21e 	bne	r3,r2,2046644 <IPADDR_TO_NETP+0xc0>
         }
         else
            *netp = nets[idx];
      }
   }
}
 20466bc:	e037883a 	mov	sp,fp
 20466c0:	df000017 	ldw	fp,0(sp)
 20466c4:	dec00104 	addi	sp,sp,4
 20466c8:	f800283a 	ret

020466cc <ip_setmoptions>:
 * RETURNS: 
 */

int
ip_setmoptions(int optname, struct socket * so, void * val)
{
 20466cc:	defff304 	addi	sp,sp,-52
 20466d0:	dfc00c15 	stw	ra,48(sp)
 20466d4:	df000b15 	stw	fp,44(sp)
 20466d8:	dc000a15 	stw	r16,40(sp)
 20466dc:	df000a04 	addi	fp,sp,40
 20466e0:	e13ffd15 	stw	r4,-12(fp)
 20466e4:	e17ffe15 	stw	r5,-8(fp)
 20466e8:	e1bfff15 	stw	r6,-4(fp)
   int   error =  0;
 20466ec:	e03ff615 	stw	zero,-40(fp)
   u_short  i;
   struct ip_mreq *  mreq;
   struct net *   netp  =  NULL;
 20466f0:	e03ffc15 	stw	zero,-16(fp)
   struct ip_moptions * imo   =  so->inp_moptions;
 20466f4:	e0bffe17 	ldw	r2,-8(fp)
 20466f8:	10800317 	ldw	r2,12(r2)
 20466fc:	e0bff815 	stw	r2,-32(fp)
   struct ip_moptions **imop  =  &so->inp_moptions;
 2046700:	e0bffe17 	ldw	r2,-8(fp)
 2046704:	10800304 	addi	r2,r2,12
 2046708:	e0bff915 	stw	r2,-28(fp)
   ip_addr addr;


   if (imo == NULL) 
 204670c:	e0bff817 	ldw	r2,-32(fp)
 2046710:	1000141e 	bne	r2,zero,2046764 <ip_setmoptions+0x98>
   {
   /*
    * No multicast option buffer attached to the pcb;
    * allocate one and initialize to default values.
    */
      imo = (struct ip_moptions*)IM_ALLOC(sizeof(*imo));
 2046714:	01001604 	movi	r4,88
 2046718:	20290400 	call	2029040 <npalloc>
 204671c:	e0bff815 	stw	r2,-32(fp)

      if (imo == NULL)
 2046720:	e0bff817 	ldw	r2,-32(fp)
 2046724:	1000021e 	bne	r2,zero,2046730 <ip_setmoptions+0x64>
         return (ENOBUFS);
 2046728:	00801a44 	movi	r2,105
 204672c:	00015406 	br	2046c80 <ip_setmoptions+0x5b4>
      *imop = imo;
 2046730:	e0bff917 	ldw	r2,-28(fp)
 2046734:	e0fff817 	ldw	r3,-32(fp)
 2046738:	10c00015 	stw	r3,0(r2)
      imo->imo_multicast_netp = NULL;
 204673c:	e0bff817 	ldw	r2,-32(fp)
 2046740:	10000015 	stw	zero,0(r2)
      imo->imo_multicast_ttl = IP_DEFAULT_MULTICAST_TTL;
 2046744:	e0bff817 	ldw	r2,-32(fp)
 2046748:	00c00044 	movi	r3,1
 204674c:	10c00105 	stb	r3,4(r2)
      imo->imo_multicast_loop = IP_DEFAULT_MULTICAST_LOOP;
 2046750:	e0bff817 	ldw	r2,-32(fp)
 2046754:	00c00044 	movi	r3,1
 2046758:	10c00145 	stb	r3,5(r2)
      imo->imo_num_memberships = 0;
 204675c:	e0bff817 	ldw	r2,-32(fp)
 2046760:	1000018d 	sth	zero,6(r2)
   }

   switch (optname) 
 2046764:	e0bffd17 	ldw	r2,-12(fp)
 2046768:	10bffdc4 	addi	r2,r2,-9
 204676c:	10c00168 	cmpgeui	r3,r2,5
 2046770:	1801271e 	bne	r3,zero,2046c10 <ip_setmoptions+0x544>
 2046774:	1085883a 	add	r2,r2,r2
 2046778:	1087883a 	add	r3,r2,r2
 204677c:	00808134 	movhi	r2,516
 2046780:	1099e404 	addi	r2,r2,26512
 2046784:	1885883a 	add	r2,r3,r2
 2046788:	10800017 	ldw	r2,0(r2)
 204678c:	1000683a 	jmp	r2
 2046790:	020467a4 	muli	r8,zero,4510
 2046794:	0204680c 	andi	r8,zero,4512
 2046798:	02046820 	cmpeqi	r8,zero,4512
 204679c:	02046854 	movui	r8,4513
 20467a0:	02046a28 	cmpgeui	r8,zero,4520

   case IP_MULTICAST_IF:
      /*
       * Select the interface for outgoing multicast packets.
       */
      addr = *(ip_addr *)val;
 20467a4:	e0bfff17 	ldw	r2,-4(fp)
 20467a8:	10800017 	ldw	r2,0(r2)
 20467ac:	e0bffa15 	stw	r2,-24(fp)
         /*
          * AADDR is used to remove a previous selection.
          * When no interface is selected, a default one is
          * chosen every time a multicast packet is sent.
          */
      if (addr == AADDR) 
 20467b0:	e0bffa17 	ldw	r2,-24(fp)
 20467b4:	1000031e 	bne	r2,zero,20467c4 <ip_setmoptions+0xf8>
      {
         imo->imo_multicast_netp = NULL;
 20467b8:	e0bff817 	ldw	r2,-32(fp)
 20467bc:	10000015 	stw	zero,0(r2)
         break;
 20467c0:	00011706 	br	2046c20 <ip_setmoptions+0x554>
         /*
          * The selected interface is identified by its local
          * IP address.  Find the interface and confirm that
          * it supports multicasting.
          */
      IPADDR_TO_NETP(addr, &netp);
 20467c4:	e0bffc04 	addi	r2,fp,-16
 20467c8:	e13ffa17 	ldw	r4,-24(fp)
 20467cc:	100b883a 	mov	r5,r2
 20467d0:	20465840 	call	2046584 <IPADDR_TO_NETP>
      if ((netp == NULL) || (netp->n_mcastlist) == NULL) 
 20467d4:	e0bffc17 	ldw	r2,-16(fp)
 20467d8:	10000326 	beq	r2,zero,20467e8 <ip_setmoptions+0x11c>
 20467dc:	e0bffc17 	ldw	r2,-16(fp)
 20467e0:	10802b17 	ldw	r2,172(r2)
 20467e4:	1000031e 	bne	r2,zero,20467f4 <ip_setmoptions+0x128>
      {
         error = EADDRNOTAVAIL;
 20467e8:	00801f44 	movi	r2,125
 20467ec:	e0bff615 	stw	r2,-40(fp)
         break;
 20467f0:	00010b06 	br	2046c20 <ip_setmoptions+0x554>
      }
      if (addr != AADDR) 
 20467f4:	e0bffa17 	ldw	r2,-24(fp)
 20467f8:	10010826 	beq	r2,zero,2046c1c <ip_setmoptions+0x550>
         imo->imo_multicast_netp = netp;
 20467fc:	e0fffc17 	ldw	r3,-16(fp)
 2046800:	e0bff817 	ldw	r2,-32(fp)
 2046804:	10c00015 	stw	r3,0(r2)
      break;
 2046808:	00010406 	br	2046c1c <ip_setmoptions+0x550>

   case IP_MULTICAST_TTL:
      /*
       * Set the IP time-to-live for outgoing multicast packets.
       */
      imo->imo_multicast_ttl = *(u_char *)val;
 204680c:	e0bfff17 	ldw	r2,-4(fp)
 2046810:	10c00003 	ldbu	r3,0(r2)
 2046814:	e0bff817 	ldw	r2,-32(fp)
 2046818:	10c00105 	stb	r3,4(r2)
      break;
 204681c:	00010006 	br	2046c20 <ip_setmoptions+0x554>
   case IP_MULTICAST_LOOP:
      /*
       * Set the loopback flag for outgoing multicast packets.
       * Must be zero or one.
       */
      if (*(u_char *)val > 1) 
 2046820:	e0bfff17 	ldw	r2,-4(fp)
 2046824:	10800003 	ldbu	r2,0(r2)
 2046828:	10803fcc 	andi	r2,r2,255
 204682c:	108000b0 	cmpltui	r2,r2,2
 2046830:	1000031e 	bne	r2,zero,2046840 <ip_setmoptions+0x174>
      {
         error = EINVAL;
 2046834:	00800584 	movi	r2,22
 2046838:	e0bff615 	stw	r2,-40(fp)
         break;
 204683c:	0000f806 	br	2046c20 <ip_setmoptions+0x554>
      }
      imo->imo_multicast_loop = *(u_char *)(val);
 2046840:	e0bfff17 	ldw	r2,-4(fp)
 2046844:	10c00003 	ldbu	r3,0(r2)
 2046848:	e0bff817 	ldw	r2,-32(fp)
 204684c:	10c00145 	stb	r3,5(r2)
      break;
 2046850:	0000f306 	br	2046c20 <ip_setmoptions+0x554>
   case IP_ADD_MEMBERSHIP:
      /*
       * Add a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 2046854:	e0bfff17 	ldw	r2,-4(fp)
 2046858:	e0bffb15 	stw	r2,-20(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 204685c:	e0bffb17 	ldw	r2,-20(fp)
 2046860:	10800017 	ldw	r2,0(r2)
 2046864:	1006d63a 	srli	r3,r2,24
 2046868:	e0bffb17 	ldw	r2,-20(fp)
 204686c:	10800017 	ldw	r2,0(r2)
 2046870:	1004d23a 	srli	r2,r2,8
 2046874:	10bfc00c 	andi	r2,r2,65280
 2046878:	1886b03a 	or	r3,r3,r2
 204687c:	e0bffb17 	ldw	r2,-20(fp)
 2046880:	10800017 	ldw	r2,0(r2)
 2046884:	10bfc00c 	andi	r2,r2,65280
 2046888:	1004923a 	slli	r2,r2,8
 204688c:	1886b03a 	or	r3,r3,r2
 2046890:	e0bffb17 	ldw	r2,-20(fp)
 2046894:	10800017 	ldw	r2,0(r2)
 2046898:	1004963a 	slli	r2,r2,24
 204689c:	1884b03a 	or	r2,r3,r2
 20468a0:	10fc002c 	andhi	r3,r2,61440
 20468a4:	00b80034 	movhi	r2,57344
 20468a8:	18800326 	beq	r3,r2,20468b8 <ip_setmoptions+0x1ec>
      {
         error = EINVAL;
 20468ac:	00800584 	movi	r2,22
 20468b0:	e0bff615 	stw	r2,-40(fp)
         break;
 20468b4:	0000da06 	br	2046c20 <ip_setmoptions+0x554>
       * If no interface address was provided, use the interface of
       * the route to the given multicast address.
       * For the Iniche stack implementation, look for a default
       * interface that supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 20468b8:	e0bffb17 	ldw	r2,-20(fp)
 20468bc:	10c00117 	ldw	r3,4(r2)
 20468c0:	e0bffc04 	addi	r2,fp,-16
 20468c4:	1809883a 	mov	r4,r3
 20468c8:	100b883a 	mov	r5,r2
 20468cc:	20465840 	call	2046584 <IPADDR_TO_NETP>
      /*
       * See if we found an interface, and confirm that it
       * supports multicast.
       */
      if (netp == NULL || (netp->n_mcastlist) == NULL) 
 20468d0:	e0bffc17 	ldw	r2,-16(fp)
 20468d4:	10000326 	beq	r2,zero,20468e4 <ip_setmoptions+0x218>
 20468d8:	e0bffc17 	ldw	r2,-16(fp)
 20468dc:	10802b17 	ldw	r2,172(r2)
 20468e0:	1000031e 	bne	r2,zero,20468f0 <ip_setmoptions+0x224>
      {
         error = EADDRNOTAVAIL;
 20468e4:	00801f44 	movi	r2,125
 20468e8:	e0bff615 	stw	r2,-40(fp)
         break;
 20468ec:	0000cc06 	br	2046c20 <ip_setmoptions+0x554>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 20468f0:	e03ff70d 	sth	zero,-36(fp)
 20468f4:	00001806 	br	2046958 <ip_setmoptions+0x28c>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 20468f8:	e0bff70b 	ldhu	r2,-36(fp)
 20468fc:	e0fff817 	ldw	r3,-32(fp)
 2046900:	10800084 	addi	r2,r2,2
 2046904:	1085883a 	add	r2,r2,r2
 2046908:	1085883a 	add	r2,r2,r2
 204690c:	1885883a 	add	r2,r3,r2
 2046910:	10800017 	ldw	r2,0(r2)
 2046914:	10c00117 	ldw	r3,4(r2)
 2046918:	e0bffc17 	ldw	r2,-16(fp)
 204691c:	18800b1e 	bne	r3,r2,204694c <ip_setmoptions+0x280>
             imo->imo_membership[i]->inm_addr
 2046920:	e0bff70b 	ldhu	r2,-36(fp)
 2046924:	e0fff817 	ldw	r3,-32(fp)
 2046928:	10800084 	addi	r2,r2,2
 204692c:	1085883a 	add	r2,r2,r2
 2046930:	1085883a 	add	r2,r2,r2
 2046934:	1885883a 	add	r2,r3,r2
 2046938:	10800017 	ldw	r2,0(r2)
 204693c:	10c00017 	ldw	r3,0(r2)
             == mreq->imr_multiaddr)
 2046940:	e0bffb17 	ldw	r2,-20(fp)
 2046944:	10800017 	ldw	r2,0(r2)
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
 2046948:	18800926 	beq	r3,r2,2046970 <ip_setmoptions+0x2a4>
      }
      /*
       * See if the membership already exists or if all the
       * membership slots are full.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 204694c:	e0bff70b 	ldhu	r2,-36(fp)
 2046950:	10800044 	addi	r2,r2,1
 2046954:	e0bff70d 	sth	r2,-36(fp)
 2046958:	e0bff817 	ldw	r2,-32(fp)
 204695c:	1080018b 	ldhu	r2,6(r2)
 2046960:	10bfffcc 	andi	r2,r2,65535
 2046964:	e0fff70b 	ldhu	r3,-36(fp)
 2046968:	18bfe336 	bltu	r3,r2,20468f8 <ip_setmoptions+0x22c>
 204696c:	00000106 	br	2046974 <ip_setmoptions+0x2a8>
      {
         if (imo->imo_membership[i]->inm_netp == netp &&
             imo->imo_membership[i]->inm_addr
             == mreq->imr_multiaddr)
         {
            break;
 2046970:	0001883a 	nop
         }
      }
      if (i < imo->imo_num_memberships) 
 2046974:	e0bff817 	ldw	r2,-32(fp)
 2046978:	1080018b 	ldhu	r2,6(r2)
 204697c:	10bfffcc 	andi	r2,r2,65535
 2046980:	e0fff70b 	ldhu	r3,-36(fp)
 2046984:	1880032e 	bgeu	r3,r2,2046994 <ip_setmoptions+0x2c8>
      {
         error = EADDRINUSE;
 2046988:	00801c04 	movi	r2,112
 204698c:	e0bff615 	stw	r2,-40(fp)
         break;
 2046990:	0000a306 	br	2046c20 <ip_setmoptions+0x554>
      }
      if (i == IP_MAX_MEMBERSHIPS) 
 2046994:	e0bff70b 	ldhu	r2,-36(fp)
 2046998:	10800518 	cmpnei	r2,r2,20
 204699c:	1000031e 	bne	r2,zero,20469ac <ip_setmoptions+0x2e0>
      {
         error = ETOOMANYREFS;
 20469a0:	00802044 	movi	r2,129
 20469a4:	e0bff615 	stw	r2,-40(fp)
         break;
 20469a8:	00009d06 	br	2046c20 <ip_setmoptions+0x554>
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 20469ac:	e43ff70b 	ldhu	r16,-36(fp)
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
 20469b0:	e0fffb17 	ldw	r3,-20(fp)
 20469b4:	e0bffc17 	ldw	r2,-16(fp)
 20469b8:	1809883a 	mov	r4,r3
 20469bc:	100b883a 	mov	r5,r2
 20469c0:	01800104 	movi	r6,4
 20469c4:	2043e900 	call	2043e90 <in_addmulti>
 20469c8:	1007883a 	mov	r3,r2
      }
      /*
       * Everything looks good; add a new record to the multicast
       * address list for the given interface.
       */
      if ((imo->imo_membership[i] =
 20469cc:	e13ff817 	ldw	r4,-32(fp)
 20469d0:	80800084 	addi	r2,r16,2
 20469d4:	1085883a 	add	r2,r2,r2
 20469d8:	1085883a 	add	r2,r2,r2
 20469dc:	2085883a 	add	r2,r4,r2
 20469e0:	10c00015 	stw	r3,0(r2)
 20469e4:	e0fff817 	ldw	r3,-32(fp)
 20469e8:	80800084 	addi	r2,r16,2
 20469ec:	1085883a 	add	r2,r2,r2
 20469f0:	1085883a 	add	r2,r2,r2
 20469f4:	1885883a 	add	r2,r3,r2
 20469f8:	10800017 	ldw	r2,0(r2)
 20469fc:	1000031e 	bne	r2,zero,2046a0c <ip_setmoptions+0x340>
          in_addmulti(&mreq->imr_multiaddr, netp, 4)) == NULL) 
      {
         error = ENOBUFS;
 2046a00:	00801a44 	movi	r2,105
 2046a04:	e0bff615 	stw	r2,-40(fp)
         break;
 2046a08:	00008506 	br	2046c20 <ip_setmoptions+0x554>
      }
      ++imo->imo_num_memberships;
 2046a0c:	e0bff817 	ldw	r2,-32(fp)
 2046a10:	1080018b 	ldhu	r2,6(r2)
 2046a14:	10800044 	addi	r2,r2,1
 2046a18:	1007883a 	mov	r3,r2
 2046a1c:	e0bff817 	ldw	r2,-32(fp)
 2046a20:	10c0018d 	sth	r3,6(r2)
      break;
 2046a24:	00007e06 	br	2046c20 <ip_setmoptions+0x554>
   case IP_DROP_MEMBERSHIP:
      /*
       * Drop a multicast group membership.
       * Group must be a valid IP multicast address.
       */
      mreq = (struct ip_mreq *)val;
 2046a28:	e0bfff17 	ldw	r2,-4(fp)
 2046a2c:	e0bffb15 	stw	r2,-20(fp)
      if (!IN_MULTICAST(ntohl(mreq->imr_multiaddr))) 
 2046a30:	e0bffb17 	ldw	r2,-20(fp)
 2046a34:	10800017 	ldw	r2,0(r2)
 2046a38:	1006d63a 	srli	r3,r2,24
 2046a3c:	e0bffb17 	ldw	r2,-20(fp)
 2046a40:	10800017 	ldw	r2,0(r2)
 2046a44:	1004d23a 	srli	r2,r2,8
 2046a48:	10bfc00c 	andi	r2,r2,65280
 2046a4c:	1886b03a 	or	r3,r3,r2
 2046a50:	e0bffb17 	ldw	r2,-20(fp)
 2046a54:	10800017 	ldw	r2,0(r2)
 2046a58:	10bfc00c 	andi	r2,r2,65280
 2046a5c:	1004923a 	slli	r2,r2,8
 2046a60:	1886b03a 	or	r3,r3,r2
 2046a64:	e0bffb17 	ldw	r2,-20(fp)
 2046a68:	10800017 	ldw	r2,0(r2)
 2046a6c:	1004963a 	slli	r2,r2,24
 2046a70:	1884b03a 	or	r2,r3,r2
 2046a74:	10fc002c 	andhi	r3,r2,61440
 2046a78:	00b80034 	movhi	r2,57344
 2046a7c:	18800326 	beq	r3,r2,2046a8c <ip_setmoptions+0x3c0>
      {
         error = EINVAL;
 2046a80:	00800584 	movi	r2,22
 2046a84:	e0bff615 	stw	r2,-40(fp)
         break;
 2046a88:	00006506 	br	2046c20 <ip_setmoptions+0x554>
       * If an interface address was specified, get a pointer
       * to its ifnet structure. If an interface address was not
       * specified, get a pointer to the first interface that
       * supports multicast.
       */
      IPADDR_TO_NETP(mreq->imr_interface, &netp);
 2046a8c:	e0bffb17 	ldw	r2,-20(fp)
 2046a90:	10c00117 	ldw	r3,4(r2)
 2046a94:	e0bffc04 	addi	r2,fp,-16
 2046a98:	1809883a 	mov	r4,r3
 2046a9c:	100b883a 	mov	r5,r2
 2046aa0:	20465840 	call	2046584 <IPADDR_TO_NETP>
      if (netp == NULL) 
 2046aa4:	e0bffc17 	ldw	r2,-16(fp)
 2046aa8:	1000031e 	bne	r2,zero,2046ab8 <ip_setmoptions+0x3ec>
      {
         error = EADDRNOTAVAIL;
 2046aac:	00801f44 	movi	r2,125
 2046ab0:	e0bff615 	stw	r2,-40(fp)
         break;
 2046ab4:	00005a06 	br	2046c20 <ip_setmoptions+0x554>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 2046ab8:	e03ff70d 	sth	zero,-36(fp)
 2046abc:	00001a06 	br	2046b28 <ip_setmoptions+0x45c>
      {
         if ((netp == NULL ||
 2046ac0:	e0bffc17 	ldw	r2,-16(fp)
 2046ac4:	10000a26 	beq	r2,zero,2046af0 <ip_setmoptions+0x424>
             imo->imo_membership[i]->inm_netp == netp) &&
 2046ac8:	e0bff70b 	ldhu	r2,-36(fp)
 2046acc:	e0fff817 	ldw	r3,-32(fp)
 2046ad0:	10800084 	addi	r2,r2,2
 2046ad4:	1085883a 	add	r2,r2,r2
 2046ad8:	1085883a 	add	r2,r2,r2
 2046adc:	1885883a 	add	r2,r3,r2
 2046ae0:	10800017 	ldw	r2,0(r2)
 2046ae4:	10c00117 	ldw	r3,4(r2)
 2046ae8:	e0bffc17 	ldw	r2,-16(fp)
      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
 2046aec:	18800b1e 	bne	r3,r2,2046b1c <ip_setmoptions+0x450>
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
 2046af0:	e0bff70b 	ldhu	r2,-36(fp)
 2046af4:	e0fff817 	ldw	r3,-32(fp)
 2046af8:	10800084 	addi	r2,r2,2
 2046afc:	1085883a 	add	r2,r2,r2
 2046b00:	1085883a 	add	r2,r2,r2
 2046b04:	1885883a 	add	r2,r3,r2
 2046b08:	10800017 	ldw	r2,0(r2)
 2046b0c:	10c00017 	ldw	r3,0(r2)
             mreq->imr_multiaddr)
 2046b10:	e0bffb17 	ldw	r2,-20(fp)
 2046b14:	10800017 	ldw	r2,0(r2)
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
      {
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
 2046b18:	18800926 	beq	r3,r2,2046b40 <ip_setmoptions+0x474>
      }

      /*
       * Find the membership in the membership array.
       */
      for (i = 0; i < imo->imo_num_memberships; ++i) 
 2046b1c:	e0bff70b 	ldhu	r2,-36(fp)
 2046b20:	10800044 	addi	r2,r2,1
 2046b24:	e0bff70d 	sth	r2,-36(fp)
 2046b28:	e0bff817 	ldw	r2,-32(fp)
 2046b2c:	1080018b 	ldhu	r2,6(r2)
 2046b30:	10bfffcc 	andi	r2,r2,65535
 2046b34:	e0fff70b 	ldhu	r3,-36(fp)
 2046b38:	18bfe136 	bltu	r3,r2,2046ac0 <ip_setmoptions+0x3f4>
 2046b3c:	00000106 	br	2046b44 <ip_setmoptions+0x478>
         if ((netp == NULL ||
             imo->imo_membership[i]->inm_netp == netp) &&
             imo->imo_membership[i]->inm_addr ==
             mreq->imr_multiaddr)
         {
            break;
 2046b40:	0001883a 	nop
         }
      }
      if (i == imo->imo_num_memberships) 
 2046b44:	e0bff817 	ldw	r2,-32(fp)
 2046b48:	1080018b 	ldhu	r2,6(r2)
 2046b4c:	10ffffcc 	andi	r3,r2,65535
 2046b50:	e0bff70b 	ldhu	r2,-36(fp)
 2046b54:	1880031e 	bne	r3,r2,2046b64 <ip_setmoptions+0x498>
      {
         error = EADDRNOTAVAIL;
 2046b58:	00801f44 	movi	r2,125
 2046b5c:	e0bff615 	stw	r2,-40(fp)
         break;
 2046b60:	00002f06 	br	2046c20 <ip_setmoptions+0x554>
      }
      /*
       * Give up the multicast address record to which the
       * membership points.
       */
      in_delmulti(imo->imo_membership[i]);
 2046b64:	e0bff70b 	ldhu	r2,-36(fp)
 2046b68:	e0fff817 	ldw	r3,-32(fp)
 2046b6c:	10800084 	addi	r2,r2,2
 2046b70:	1085883a 	add	r2,r2,r2
 2046b74:	1085883a 	add	r2,r2,r2
 2046b78:	1885883a 	add	r2,r3,r2
 2046b7c:	10800017 	ldw	r2,0(r2)
 2046b80:	1009883a 	mov	r4,r2
 2046b84:	2043fdc0 	call	2043fdc <in_delmulti>
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 2046b88:	e0bff70b 	ldhu	r2,-36(fp)
 2046b8c:	10800044 	addi	r2,r2,1
 2046b90:	e0bff70d 	sth	r2,-36(fp)
 2046b94:	00001206 	br	2046be0 <ip_setmoptions+0x514>
         imo->imo_membership[i-1] = imo->imo_membership[i];
 2046b98:	e0bff70b 	ldhu	r2,-36(fp)
 2046b9c:	117fffc4 	addi	r5,r2,-1
 2046ba0:	e0bff70b 	ldhu	r2,-36(fp)
 2046ba4:	e0fff817 	ldw	r3,-32(fp)
 2046ba8:	10800084 	addi	r2,r2,2
 2046bac:	1085883a 	add	r2,r2,r2
 2046bb0:	1085883a 	add	r2,r2,r2
 2046bb4:	1885883a 	add	r2,r3,r2
 2046bb8:	10c00017 	ldw	r3,0(r2)
 2046bbc:	e13ff817 	ldw	r4,-32(fp)
 2046bc0:	28800084 	addi	r2,r5,2
 2046bc4:	1085883a 	add	r2,r2,r2
 2046bc8:	1085883a 	add	r2,r2,r2
 2046bcc:	2085883a 	add	r2,r4,r2
 2046bd0:	10c00015 	stw	r3,0(r2)
       */
      in_delmulti(imo->imo_membership[i]);
      /*
       * Remove the gap in the membership array.
       */
      for (++i; i < imo->imo_num_memberships; ++i)
 2046bd4:	e0bff70b 	ldhu	r2,-36(fp)
 2046bd8:	10800044 	addi	r2,r2,1
 2046bdc:	e0bff70d 	sth	r2,-36(fp)
 2046be0:	e0bff817 	ldw	r2,-32(fp)
 2046be4:	1080018b 	ldhu	r2,6(r2)
 2046be8:	10bfffcc 	andi	r2,r2,65535
 2046bec:	e0fff70b 	ldhu	r3,-36(fp)
 2046bf0:	18bfe936 	bltu	r3,r2,2046b98 <ip_setmoptions+0x4cc>
         imo->imo_membership[i-1] = imo->imo_membership[i];
      --imo->imo_num_memberships;
 2046bf4:	e0bff817 	ldw	r2,-32(fp)
 2046bf8:	1080018b 	ldhu	r2,6(r2)
 2046bfc:	10bfffc4 	addi	r2,r2,-1
 2046c00:	1007883a 	mov	r3,r2
 2046c04:	e0bff817 	ldw	r2,-32(fp)
 2046c08:	10c0018d 	sth	r3,6(r2)
      break;
 2046c0c:	00000406 	br	2046c20 <ip_setmoptions+0x554>

      default:
      error = EOPNOTSUPP;
 2046c10:	008017c4 	movi	r2,95
 2046c14:	e0bff615 	stw	r2,-40(fp)
      break;
 2046c18:	00000106 	br	2046c20 <ip_setmoptions+0x554>
         error = EADDRNOTAVAIL;
         break;
      }
      if (addr != AADDR) 
         imo->imo_multicast_netp = netp;
      break;
 2046c1c:	0001883a 	nop
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 2046c20:	e0bff817 	ldw	r2,-32(fp)
 2046c24:	10800017 	ldw	r2,0(r2)
 2046c28:	1000141e 	bne	r2,zero,2046c7c <ip_setmoptions+0x5b0>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 2046c2c:	e0bff817 	ldw	r2,-32(fp)
 2046c30:	10800103 	ldbu	r2,4(r2)
   }

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
 2046c34:	10803fcc 	andi	r2,r2,255
 2046c38:	10800058 	cmpnei	r2,r2,1
 2046c3c:	10000f1e 	bne	r2,zero,2046c7c <ip_setmoptions+0x5b0>
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 2046c40:	e0bff817 	ldw	r2,-32(fp)
 2046c44:	10800143 	ldbu	r2,5(r2)

      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
 2046c48:	10803fcc 	andi	r2,r2,255
 2046c4c:	10800058 	cmpnei	r2,r2,1
 2046c50:	10000a1e 	bne	r2,zero,2046c7c <ip_setmoptions+0x5b0>
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
       imo->imo_num_memberships == 0) 
 2046c54:	e0bff817 	ldw	r2,-32(fp)
 2046c58:	1080018b 	ldhu	r2,6(r2)
      /*
       * If all options have default values, no need to keep the mbuf.
       */
   if (imo->imo_multicast_netp == NULL &&
       imo->imo_multicast_ttl == IP_DEFAULT_MULTICAST_TTL &&
       imo->imo_multicast_loop == IP_DEFAULT_MULTICAST_LOOP &&
 2046c5c:	10bfffcc 	andi	r2,r2,65535
 2046c60:	1000061e 	bne	r2,zero,2046c7c <ip_setmoptions+0x5b0>
       imo->imo_num_memberships == 0) 
   {
      IM_FREE(*imop);
 2046c64:	e0bff917 	ldw	r2,-28(fp)
 2046c68:	10800017 	ldw	r2,0(r2)
 2046c6c:	1009883a 	mov	r4,r2
 2046c70:	202912c0 	call	202912c <npfree>
      *imop = NULL;
 2046c74:	e0bff917 	ldw	r2,-28(fp)
 2046c78:	10000015 	stw	zero,0(r2)
   }
   return (error);
 2046c7c:	e0bff617 	ldw	r2,-40(fp)
}
 2046c80:	e037883a 	mov	sp,fp
 2046c84:	dfc00217 	ldw	ra,8(sp)
 2046c88:	df000117 	ldw	fp,4(sp)
 2046c8c:	dc000017 	ldw	r16,0(sp)
 2046c90:	dec00304 	addi	sp,sp,12
 2046c94:	f800283a 	ret

02046c98 <ip_getmoptions>:
 * RETURNS: 
 */

int
ip_getmoptions(int optname, struct socket * so, void * val)
{
 2046c98:	defff804 	addi	sp,sp,-32
 2046c9c:	df000715 	stw	fp,28(sp)
 2046ca0:	df000704 	addi	fp,sp,28
 2046ca4:	e13ffd15 	stw	r4,-12(fp)
 2046ca8:	e17ffe15 	stw	r5,-8(fp)
 2046cac:	e1bfff15 	stw	r6,-4(fp)
   u_char * ttl;
   u_char * loop;
   ip_addr *addr;
   struct ip_moptions*  imo   =  so->inp_moptions;
 2046cb0:	e0bffe17 	ldw	r2,-8(fp)
 2046cb4:	10800317 	ldw	r2,12(r2)
 2046cb8:	e0bff915 	stw	r2,-28(fp)
   /* The following code will be commented out for Iniche stack.
    * Don't allocate a buffer here.
    *
    *        *mp = m_get(M_WAIT, MT_SOOPTS);
    */
   switch (optname) 
 2046cbc:	e0bffd17 	ldw	r2,-12(fp)
 2046cc0:	10c00260 	cmpeqi	r3,r2,9
 2046cc4:	1800071e 	bne	r3,zero,2046ce4 <ip_getmoptions+0x4c>
 2046cc8:	10c00250 	cmplti	r3,r2,9
 2046ccc:	1800321e 	bne	r3,zero,2046d98 <ip_getmoptions+0x100>
 2046cd0:	10c002a0 	cmpeqi	r3,r2,10
 2046cd4:	1800141e 	bne	r3,zero,2046d28 <ip_getmoptions+0x90>
 2046cd8:	108002e0 	cmpeqi	r2,r2,11
 2046cdc:	1000201e 	bne	r2,zero,2046d60 <ip_getmoptions+0xc8>
 2046ce0:	00002d06 	br	2046d98 <ip_getmoptions+0x100>
   {

   case IP_MULTICAST_IF:
      addr = (ip_addr *)(val);
 2046ce4:	e0bfff17 	ldw	r2,-4(fp)
 2046ce8:	e0bffa15 	stw	r2,-24(fp)
      if (imo == NULL || imo->imo_multicast_netp == NULL)
 2046cec:	e0bff917 	ldw	r2,-28(fp)
 2046cf0:	10000326 	beq	r2,zero,2046d00 <ip_getmoptions+0x68>
 2046cf4:	e0bff917 	ldw	r2,-28(fp)
 2046cf8:	10800017 	ldw	r2,0(r2)
 2046cfc:	1000031e 	bne	r2,zero,2046d0c <ip_getmoptions+0x74>
         *addr = AADDR;
 2046d00:	e0bffa17 	ldw	r2,-24(fp)
 2046d04:	10000015 	stw	zero,0(r2)
 2046d08:	00000506 	br	2046d20 <ip_getmoptions+0x88>
      else
         *addr = imo->imo_multicast_netp->n_ipaddr;
 2046d0c:	e0bff917 	ldw	r2,-28(fp)
 2046d10:	10800017 	ldw	r2,0(r2)
 2046d14:	10c00a17 	ldw	r3,40(r2)
 2046d18:	e0bffa17 	ldw	r2,-24(fp)
 2046d1c:	10c00015 	stw	r3,0(r2)
      return (0);
 2046d20:	0005883a 	mov	r2,zero
 2046d24:	00001d06 	br	2046d9c <ip_getmoptions+0x104>

   case IP_MULTICAST_TTL:
      ttl = (u_char *)val;
 2046d28:	e0bfff17 	ldw	r2,-4(fp)
 2046d2c:	e0bffb15 	stw	r2,-20(fp)
      if (imo == NULL)
 2046d30:	e0bff917 	ldw	r2,-28(fp)
 2046d34:	1000041e 	bne	r2,zero,2046d48 <ip_getmoptions+0xb0>
         *ttl = IP_DEFAULT_MULTICAST_TTL;
 2046d38:	e0bffb17 	ldw	r2,-20(fp)
 2046d3c:	00c00044 	movi	r3,1
 2046d40:	10c00005 	stb	r3,0(r2)
 2046d44:	00000406 	br	2046d58 <ip_getmoptions+0xc0>
      else
         *ttl = imo->imo_multicast_ttl;
 2046d48:	e0bff917 	ldw	r2,-28(fp)
 2046d4c:	10c00103 	ldbu	r3,4(r2)
 2046d50:	e0bffb17 	ldw	r2,-20(fp)
 2046d54:	10c00005 	stb	r3,0(r2)
      return (0);
 2046d58:	0005883a 	mov	r2,zero
 2046d5c:	00000f06 	br	2046d9c <ip_getmoptions+0x104>

   case IP_MULTICAST_LOOP:
      loop = (u_char *)val;
 2046d60:	e0bfff17 	ldw	r2,-4(fp)
 2046d64:	e0bffc15 	stw	r2,-16(fp)
      if (imo == NULL)
 2046d68:	e0bff917 	ldw	r2,-28(fp)
 2046d6c:	1000041e 	bne	r2,zero,2046d80 <ip_getmoptions+0xe8>
         *loop = IP_DEFAULT_MULTICAST_LOOP;
 2046d70:	e0bffc17 	ldw	r2,-16(fp)
 2046d74:	00c00044 	movi	r3,1
 2046d78:	10c00005 	stb	r3,0(r2)
 2046d7c:	00000406 	br	2046d90 <ip_getmoptions+0xf8>
      else
         *loop = imo->imo_multicast_loop;
 2046d80:	e0bff917 	ldw	r2,-28(fp)
 2046d84:	10c00143 	ldbu	r3,5(r2)
 2046d88:	e0bffc17 	ldw	r2,-16(fp)
 2046d8c:	10c00005 	stb	r3,0(r2)
      return (0);
 2046d90:	0005883a 	mov	r2,zero
 2046d94:	00000106 	br	2046d9c <ip_getmoptions+0x104>

      default:
      return (EOPNOTSUPP);
 2046d98:	008017c4 	movi	r2,95
   }
}
 2046d9c:	e037883a 	mov	sp,fp
 2046da0:	df000017 	ldw	fp,0(sp)
 2046da4:	dec00104 	addi	sp,sp,4
 2046da8:	f800283a 	ret

02046dac <ip_freemoptions>:
 * RETURNS: 
 */

void
ip_freemoptions(struct ip_moptions * imo)
{
 2046dac:	defffc04 	addi	sp,sp,-16
 2046db0:	dfc00315 	stw	ra,12(sp)
 2046db4:	df000215 	stw	fp,8(sp)
 2046db8:	df000204 	addi	fp,sp,8
 2046dbc:	e13fff15 	stw	r4,-4(fp)
   u_short  i;

   if (imo != NULL) 
 2046dc0:	e0bfff17 	ldw	r2,-4(fp)
 2046dc4:	10001526 	beq	r2,zero,2046e1c <ip_freemoptions+0x70>
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 2046dc8:	e03ffe0d 	sth	zero,-8(fp)
 2046dcc:	00000c06 	br	2046e00 <ip_freemoptions+0x54>
         in_delmulti(imo->imo_membership[i]);
 2046dd0:	e0bffe0b 	ldhu	r2,-8(fp)
 2046dd4:	e0ffff17 	ldw	r3,-4(fp)
 2046dd8:	10800084 	addi	r2,r2,2
 2046ddc:	1085883a 	add	r2,r2,r2
 2046de0:	1085883a 	add	r2,r2,r2
 2046de4:	1885883a 	add	r2,r3,r2
 2046de8:	10800017 	ldw	r2,0(r2)
 2046dec:	1009883a 	mov	r4,r2
 2046df0:	2043fdc0 	call	2043fdc <in_delmulti>
{
   u_short  i;

   if (imo != NULL) 
   {
      for (i = 0; i < imo->imo_num_memberships; ++i)
 2046df4:	e0bffe0b 	ldhu	r2,-8(fp)
 2046df8:	10800044 	addi	r2,r2,1
 2046dfc:	e0bffe0d 	sth	r2,-8(fp)
 2046e00:	e0bfff17 	ldw	r2,-4(fp)
 2046e04:	1080018b 	ldhu	r2,6(r2)
 2046e08:	10bfffcc 	andi	r2,r2,65535
 2046e0c:	e0fffe0b 	ldhu	r3,-8(fp)
 2046e10:	18bfef36 	bltu	r3,r2,2046dd0 <ip_freemoptions+0x24>
         in_delmulti(imo->imo_membership[i]);
      npfree(imo);
 2046e14:	e13fff17 	ldw	r4,-4(fp)
 2046e18:	202912c0 	call	202912c <npfree>
   }
}
 2046e1c:	e037883a 	mov	sp,fp
 2046e20:	dfc00117 	ldw	ra,4(sp)
 2046e24:	df000017 	ldw	fp,0(sp)
 2046e28:	dec00204 	addi	sp,sp,8
 2046e2c:	f800283a 	ret

02046e30 <u_mctest_init>:
 *
 * RETURNS: 
 */

void u_mctest_init()
{
 2046e30:	defffe04 	addi	sp,sp,-8
 2046e34:	dfc00115 	stw	ra,4(sp)
 2046e38:	df000015 	stw	fp,0(sp)
 2046e3c:	d839883a 	mov	fp,sp
   printf("mctest init called\n");
 2046e40:	01008174 	movhi	r4,517
 2046e44:	2106a504 	addi	r4,r4,6804
 2046e48:	2006cb40 	call	2006cb4 <puts>
// altera changes end (cadler@altera.com)
   install_menu(u_mctest_menu);
// altera changes begin (cadler@altera.com)
#endif //IN_MENUS
// altera changes end (cadler@altera.com)
}
 2046e4c:	e037883a 	mov	sp,fp
 2046e50:	dfc00117 	ldw	ra,4(sp)
 2046e54:	df000017 	ldw	fp,0(sp)
 2046e58:	dec00204 	addi	sp,sp,8
 2046e5c:	f800283a 	ret

02046e60 <u_mctest_run>:
 *
 * RETURNS: 
 */

int u_mctest_run(void * pio)
{
 2046e60:	defede04 	addi	sp,sp,-1160
 2046e64:	dfc12115 	stw	ra,1156(sp)
 2046e68:	df012015 	stw	fp,1152(sp)
 2046e6c:	df012004 	addi	fp,sp,1152
 2046e70:	e13fff15 	stw	r4,-4(fp)
    struct sockaddr_in   stLocal, stTo, stFrom;
    char  achIn[BUFSIZE];
    char  achOut[] = "Message number:              ";
 2046e74:	009cdcf4 	movhi	r2,29555
 2046e78:	10995344 	addi	r2,r2,25933
 2046e7c:	e0bff215 	stw	r2,-56(fp)
 2046e80:	00881974 	movhi	r2,8293
 2046e84:	1099d844 	addi	r2,r2,26465
 2046e88:	e0bff315 	stw	r2,-52(fp)
 2046e8c:	00989b74 	movhi	r2,25197
 2046e90:	109d5b84 	addi	r2,r2,30062
 2046e94:	e0bff415 	stw	r2,-48(fp)
 2046e98:	00880eb4 	movhi	r2,8250
 2046e9c:	109c9944 	addi	r2,r2,29285
 2046ea0:	e0bff515 	stw	r2,-44(fp)
 2046ea4:	00880834 	movhi	r2,8224
 2046ea8:	10880804 	addi	r2,r2,8224
 2046eac:	e0bff615 	stw	r2,-40(fp)
 2046eb0:	00880834 	movhi	r2,8224
 2046eb4:	10880804 	addi	r2,r2,8224
 2046eb8:	e0bff715 	stw	r2,-36(fp)
 2046ebc:	00880834 	movhi	r2,8224
 2046ec0:	10880804 	addi	r2,r2,8224
 2046ec4:	e0bff815 	stw	r2,-32(fp)
 2046ec8:	00800804 	movi	r2,32
 2046ecc:	e0bff90d 	sth	r2,-28(fp)
    struct ip_mreq stMreq;
    u_char cTmp;
    unsigned long endtime;

   /* get a datagram socket */
   s = t_socket(AF_INET,SOCK_DGRAM, 0);
 2046ed0:	01000084 	movi	r4,2
 2046ed4:	01400084 	movi	r5,2
 2046ed8:	000d883a 	mov	r6,zero
 2046edc:	202b4e00 	call	202b4e0 <t_socket>
 2046ee0:	e0bee315 	stw	r2,-1140(fp)

   if (s == INVALID_SOCKET) 
 2046ee4:	e0bee317 	ldw	r2,-1140(fp)
 2046ee8:	10bfffd8 	cmpnei	r2,r2,-1
 2046eec:	1000091e 	bne	r2,zero,2046f14 <u_mctest_run+0xb4>
   {
      ns_printf (pio,"t_socket() failed, Err: %d\n", t_errno(s));
 2046ef0:	e13ee317 	ldw	r4,-1140(fp)
 2046ef4:	202c9f40 	call	202c9f4 <t_errno>
 2046ef8:	e13fff17 	ldw	r4,-4(fp)
 2046efc:	01408174 	movhi	r5,517
 2046f00:	2946aa04 	addi	r5,r5,6824
 2046f04:	100d883a 	mov	r6,r2
 2046f08:	2026e100 	call	2026e10 <ns_printf>
      exit(1);
 2046f0c:	01000044 	movi	r4,1
 2046f10:	204bd0c0 	call	204bd0c <exit>
   }

   /* avoid EADDRINUSE error on bind() */ 
   iTmp = 1;
 2046f14:	00800044 	movi	r2,1
 2046f18:	e0bffa15 	stw	r2,-24(fp)
   iRet = t_setsockopt(s, SOL_SOCKET, SO_REUSEADDR, (char *)&iTmp, sizeof(iTmp));
 2046f1c:	e0bffa04 	addi	r2,fp,-24
 2046f20:	00c00104 	movi	r3,4
 2046f24:	d8c00015 	stw	r3,0(sp)
 2046f28:	e13ee317 	ldw	r4,-1140(fp)
 2046f2c:	017fffc4 	movi	r5,-1
 2046f30:	01800104 	movi	r6,4
 2046f34:	100f883a 	mov	r7,r2
 2046f38:	202be9c0 	call	202be9c <t_setsockopt>
 2046f3c:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 2046f40:	e0bee417 	ldw	r2,-1136(fp)
 2046f44:	10bfffd8 	cmpnei	r2,r2,-1
 2046f48:	1000071e 	bne	r2,zero,2046f68 <u_mctest_run+0x108>
   {
      ns_printf (pio,"t_setsockopt() SO_REUSEADDR failed, Err: %d\n",
 2046f4c:	e13ee317 	ldw	r4,-1140(fp)
 2046f50:	202c9f40 	call	202c9f4 <t_errno>
 2046f54:	e13fff17 	ldw	r4,-4(fp)
 2046f58:	01408174 	movhi	r5,517
 2046f5c:	2946b104 	addi	r5,r5,6852
 2046f60:	100d883a 	mov	r6,r2
 2046f64:	2026e100 	call	2026e10 <ns_printf>
       t_errno(s));
   }

   /* name the socket */
   stLocal.sin_family =   AF_INET;
 2046f68:	00800084 	movi	r2,2
 2046f6c:	e0bee60d 	sth	r2,-1128(fp)
   stLocal.sin_addr.s_addr = htonl(INADDR_ANY);
 2046f70:	e03ee715 	stw	zero,-1124(fp)
   stLocal.sin_port =   htons(TEST_PORT);
 2046f74:	00a00344 	movi	r2,-32755
 2046f78:	e0bee68d 	sth	r2,-1126(fp)
   iRet = t_bind(s, (struct sockaddr*) &stLocal, sizeof(struct sockaddr_in));
 2046f7c:	e0bee604 	addi	r2,fp,-1128
 2046f80:	e13ee317 	ldw	r4,-1140(fp)
 2046f84:	100b883a 	mov	r5,r2
 2046f88:	01800404 	movi	r6,16
 2046f8c:	202b5600 	call	202b560 <t_bind>
 2046f90:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 2046f94:	e0bee417 	ldw	r2,-1136(fp)
 2046f98:	10bfffd8 	cmpnei	r2,r2,-1
 2046f9c:	1000061e 	bne	r2,zero,2046fb8 <u_mctest_run+0x158>
   {
      printf ("t_bind() failed, Err: %d\n",
 2046fa0:	e13ee317 	ldw	r4,-1140(fp)
 2046fa4:	202c9f40 	call	202c9f4 <t_errno>
 2046fa8:	01008174 	movhi	r4,517
 2046fac:	2106bd04 	addi	r4,r4,6900
 2046fb0:	100b883a 	mov	r5,r2
 2046fb4:	2006a240 	call	2006a24 <printf>
       t_errno(s));
   }

   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
 2046fb8:	e13fff17 	ldw	r4,-4(fp)
 2046fbc:	01408174 	movhi	r5,517
 2046fc0:	2946c404 	addi	r5,r5,6928
 2046fc4:	01808174 	movhi	r6,517
 2046fc8:	3186cc04 	addi	r6,r6,6960
 2046fcc:	2026e100 	call	2026e10 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 2046fd0:	01008174 	movhi	r4,517
 2046fd4:	2106cc04 	addi	r4,r4,6960
 2046fd8:	2047c340 	call	2047c34 <inet_addr>
 2046fdc:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 2046fe0:	00809934 	movhi	r2,612
 2046fe4:	10b50104 	addi	r2,r2,-11260
 2046fe8:	10800a17 	ldw	r2,40(r2)
 2046fec:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                       (char *)&stMreq, sizeof(stMreq));
 2046ff0:	e0bffb04 	addi	r2,fp,-20
   /* join the multicast group. TEST_ADDR */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR);
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
   stMreq.imr_interface = netstatic[0].n_ipaddr;
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP,
 2046ff4:	00c00204 	movi	r3,8
 2046ff8:	d8c00015 	stw	r3,0(sp)
 2046ffc:	e13ee317 	ldw	r4,-1140(fp)
 2047000:	000b883a 	mov	r5,zero
 2047004:	01800304 	movi	r6,12
 2047008:	100f883a 	mov	r7,r2
 204700c:	202be9c0 	call	202be9c <t_setsockopt>
 2047010:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 2047014:	e0bee417 	ldw	r2,-1136(fp)
 2047018:	10bfffd8 	cmpnei	r2,r2,-1
 204701c:	1000071e 	bne	r2,zero,204703c <u_mctest_run+0x1dc>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 2047020:	e13ee317 	ldw	r4,-1140(fp)
 2047024:	202c9f40 	call	202c9f4 <t_errno>
 2047028:	e13fff17 	ldw	r4,-4(fp)
 204702c:	01408174 	movhi	r5,517
 2047030:	2946cf04 	addi	r5,r5,6972
 2047034:	100d883a 	mov	r6,r2
 2047038:	2026e100 	call	2026e10 <ns_printf>
                     t_errno(s));
   } 
   tk_yield();
 204703c:	20278080 	call	2027808 <tk_yield>

   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
 2047040:	e13fff17 	ldw	r4,-4(fp)
 2047044:	01408174 	movhi	r5,517
 2047048:	2946c404 	addi	r5,r5,6928
 204704c:	01808174 	movhi	r6,517
 2047050:	3186dc04 	addi	r6,r6,7024
 2047054:	2026e100 	call	2026e10 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
 2047058:	01008174 	movhi	r4,517
 204705c:	2106dc04 	addi	r4,r4,7024
 2047060:	2047c340 	call	2047c34 <inet_addr>
 2047064:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 2047068:	00809934 	movhi	r2,612
 204706c:	10b50104 	addi	r2,r2,-11260
 2047070:	10800a17 	ldw	r2,40(r2)
 2047074:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
                       (char *)&stMreq, sizeof(stMreq));
 2047078:	e0bffb04 	addi	r2,fp,-20
   /* join the multicast group. TEST_ADDR1 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR1);
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR1);
   stMreq.imr_interface = netstatic[0].n_ipaddr;
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 204707c:	00c00204 	movi	r3,8
 2047080:	d8c00015 	stw	r3,0(sp)
 2047084:	e13ee317 	ldw	r4,-1140(fp)
 2047088:	000b883a 	mov	r5,zero
 204708c:	01800304 	movi	r6,12
 2047090:	100f883a 	mov	r7,r2
 2047094:	202be9c0 	call	202be9c <t_setsockopt>
 2047098:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 204709c:	e0bee417 	ldw	r2,-1136(fp)
 20470a0:	10bfffd8 	cmpnei	r2,r2,-1
 20470a4:	1000071e 	bne	r2,zero,20470c4 <u_mctest_run+0x264>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 20470a8:	e13ee317 	ldw	r4,-1140(fp)
 20470ac:	202c9f40 	call	202c9f4 <t_errno>
 20470b0:	e13fff17 	ldw	r4,-4(fp)
 20470b4:	01408174 	movhi	r5,517
 20470b8:	2946cf04 	addi	r5,r5,6972
 20470bc:	100d883a 	mov	r6,r2
 20470c0:	2026e100 	call	2026e10 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 20470c4:	20278080 	call	2027808 <tk_yield>

   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
 20470c8:	e13fff17 	ldw	r4,-4(fp)
 20470cc:	01408174 	movhi	r5,517
 20470d0:	2946c404 	addi	r5,r5,6928
 20470d4:	01808174 	movhi	r6,517
 20470d8:	3186df04 	addi	r6,r6,7036
 20470dc:	2026e100 	call	2026e10 <ns_printf>
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
 20470e0:	01008174 	movhi	r4,517
 20470e4:	2106df04 	addi	r4,r4,7036
 20470e8:	2047c340 	call	2047c34 <inet_addr>
 20470ec:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 20470f0:	00809934 	movhi	r2,612
 20470f4:	10b50104 	addi	r2,r2,-11260
 20470f8:	10800a17 	ldw	r2,40(r2)
 20470fc:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
                       (char *)&stMreq, sizeof(stMreq));
 2047100:	e0bffb04 	addi	r2,fp,-20
   /* join the multicast group. TEST_ADDR2 */

   ns_printf (pio,"Joining multicast group: %s\n", TEST_ADDR2);
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR2);
   stMreq.imr_interface = netstatic[0].n_ipaddr;
   iRet = t_setsockopt(s, IPPROTO_IP, IP_ADD_MEMBERSHIP, 
 2047104:	00c00204 	movi	r3,8
 2047108:	d8c00015 	stw	r3,0(sp)
 204710c:	e13ee317 	ldw	r4,-1140(fp)
 2047110:	000b883a 	mov	r5,zero
 2047114:	01800304 	movi	r6,12
 2047118:	100f883a 	mov	r7,r2
 204711c:	202be9c0 	call	202be9c <t_setsockopt>
 2047120:	e0bee415 	stw	r2,-1136(fp)
                       (char *)&stMreq, sizeof(stMreq));
   if (iRet == SOCKET_ERROR) 
 2047124:	e0bee417 	ldw	r2,-1136(fp)
 2047128:	10bfffd8 	cmpnei	r2,r2,-1
 204712c:	1000071e 	bne	r2,zero,204714c <u_mctest_run+0x2ec>
   {
      ns_printf (pio,"t_setsockopt() IP_ADD_MEMBERSHIP failed, Err: %d\n",
 2047130:	e13ee317 	ldw	r4,-1140(fp)
 2047134:	202c9f40 	call	202c9f4 <t_errno>
 2047138:	e13fff17 	ldw	r4,-4(fp)
 204713c:	01408174 	movhi	r5,517
 2047140:	2946cf04 	addi	r5,r5,6972
 2047144:	100d883a 	mov	r6,r2
 2047148:	2026e100 	call	2026e10 <ns_printf>
                     t_errno(s));
   }
   tk_yield();
 204714c:	20278080 	call	2027808 <tk_yield>

   /* set TTL to traverse up to multiple routers */
   cTmp = TTL_VALUE;
 2047150:	00800084 	movi	r2,2
 2047154:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_TTL, (char *)&cTmp, sizeof(cTmp));
 2047158:	e0bffd04 	addi	r2,fp,-12
 204715c:	00c00044 	movi	r3,1
 2047160:	d8c00015 	stw	r3,0(sp)
 2047164:	e13ee317 	ldw	r4,-1140(fp)
 2047168:	000b883a 	mov	r5,zero
 204716c:	01800284 	movi	r6,10
 2047170:	100f883a 	mov	r7,r2
 2047174:	202be9c0 	call	202be9c <t_setsockopt>
 2047178:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 204717c:	e0bee417 	ldw	r2,-1136(fp)
 2047180:	10bfffd8 	cmpnei	r2,r2,-1
 2047184:	1000071e 	bne	r2,zero,20471a4 <u_mctest_run+0x344>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_TTL failed, Err: %d\n",
 2047188:	e13ee317 	ldw	r4,-1140(fp)
 204718c:	202c9f40 	call	202c9f4 <t_errno>
 2047190:	e13fff17 	ldw	r4,-4(fp)
 2047194:	01408174 	movhi	r5,517
 2047198:	2946e204 	addi	r5,r5,7048
 204719c:	100d883a 	mov	r6,r2
 20471a0:	2026e100 	call	2026e10 <ns_printf>
                     t_errno(s));
   }

   /* enable loopback */
   cTmp = 1;
 20471a4:	00800044 	movi	r2,1
 20471a8:	e0bffd05 	stb	r2,-12(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_MULTICAST_LOOP, (char *)&cTmp, sizeof(cTmp));
 20471ac:	e0bffd04 	addi	r2,fp,-12
 20471b0:	00c00044 	movi	r3,1
 20471b4:	d8c00015 	stw	r3,0(sp)
 20471b8:	e13ee317 	ldw	r4,-1140(fp)
 20471bc:	000b883a 	mov	r5,zero
 20471c0:	018002c4 	movi	r6,11
 20471c4:	100f883a 	mov	r7,r2
 20471c8:	202be9c0 	call	202be9c <t_setsockopt>
 20471cc:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 20471d0:	e0bee417 	ldw	r2,-1136(fp)
 20471d4:	10bfffd8 	cmpnei	r2,r2,-1
 20471d8:	1000071e 	bne	r2,zero,20471f8 <u_mctest_run+0x398>
   {
      ns_printf (pio,"t_setsockopt() IP_MULTICAST_LOOP failed, Err: %d\n",
 20471dc:	e13ee317 	ldw	r4,-1140(fp)
 20471e0:	202c9f40 	call	202c9f4 <t_errno>
 20471e4:	e13fff17 	ldw	r4,-4(fp)
 20471e8:	01408174 	movhi	r5,517
 20471ec:	2946ef04 	addi	r5,r5,7100
 20471f0:	100d883a 	mov	r6,r2
 20471f4:	2026e100 	call	2026e10 <ns_printf>
                     t_errno(s));
   }

   /* assign our destination address */
   stTo.sin_family =      AF_INET;
 20471f8:	00800084 	movi	r2,2
 20471fc:	e0beea0d 	sth	r2,-1112(fp)
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
 2047200:	01008174 	movhi	r4,517
 2047204:	2106dc04 	addi	r4,r4,7024
 2047208:	2047c340 	call	2047c34 <inet_addr>
 204720c:	e0beeb15 	stw	r2,-1108(fp)
   stTo.sin_port =        htons(TEST_PORT);
 2047210:	00a00344 	movi	r2,-32755
 2047214:	e0beea8d 	sth	r2,-1110(fp)
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
 2047218:	e13fff17 	ldw	r4,-4(fp)
 204721c:	01408174 	movhi	r5,517
 2047220:	2946fc04 	addi	r5,r5,7152
 2047224:	01808174 	movhi	r6,517
 2047228:	3186dc04 	addi	r6,r6,7024
 204722c:	2026e100 	call	2026e10 <ns_printf>
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 2047230:	e03ee215 	stw	zero,-1144(fp)
 2047234:	00009b06 	br	20474a4 <u_mctest_run+0x644>
   {
      static int iCounter = 1;

      /* send to the multicast address */
      sprintf(&achOut[16], "%d", iCounter++);
 2047238:	d0a05717 	ldw	r2,-32420(gp)
 204723c:	1007883a 	mov	r3,r2
 2047240:	10800044 	addi	r2,r2,1
 2047244:	d0a05715 	stw	r2,-32420(gp)
 2047248:	e0bff204 	addi	r2,fp,-56
 204724c:	10800404 	addi	r2,r2,16
 2047250:	1009883a 	mov	r4,r2
 2047254:	01408174 	movhi	r5,517
 2047258:	29470b04 	addi	r5,r5,7212
 204725c:	180d883a 	mov	r6,r3
 2047260:	2006fec0 	call	2006fec <sprintf>
      iRet = t_sendto(s, achOut, sizeof(achOut), 0, (struct sockaddr*)&stTo,
 2047264:	e0bff204 	addi	r2,fp,-56
 2047268:	e0feea04 	addi	r3,fp,-1112
 204726c:	d8c00015 	stw	r3,0(sp)
 2047270:	00c00404 	movi	r3,16
 2047274:	d8c00115 	stw	r3,4(sp)
 2047278:	e13ee317 	ldw	r4,-1140(fp)
 204727c:	100b883a 	mov	r5,r2
 2047280:	01800784 	movi	r6,30
 2047284:	000f883a 	mov	r7,zero
 2047288:	202c3ec0 	call	202c3ec <t_sendto>
 204728c:	e0bee415 	stw	r2,-1136(fp)
                      sizeof(struct sockaddr_in));
      if (iRet < 0) 
 2047290:	e0bee417 	ldw	r2,-1136(fp)
 2047294:	1000080e 	bge	r2,zero,20472b8 <u_mctest_run+0x458>
      {
         /*      perror("sendto() failed\n"); */
         ns_printf (pio,"t_sendto() failed, Error: %d\n", t_errno(s));
 2047298:	e13ee317 	ldw	r4,-1140(fp)
 204729c:	202c9f40 	call	202c9f4 <t_errno>
 20472a0:	e13fff17 	ldw	r4,-4(fp)
 20472a4:	01408174 	movhi	r5,517
 20472a8:	29470c04 	addi	r5,r5,7216
 20472ac:	100d883a 	mov	r6,r2
 20472b0:	2026e100 	call	2026e10 <ns_printf>
         /*     exit(1); */
         goto exitloop;
 20472b4:	00007e06 	br	20474b0 <u_mctest_run+0x650>
      }

      /* make the socket non-blocking */
      iTmp = 1;
 20472b8:	00800044 	movi	r2,1
 20472bc:	e0bffa15 	stw	r2,-24(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&iTmp, sizeof(iTmp));
 20472c0:	e0bffa04 	addi	r2,fp,-24
 20472c4:	00c00104 	movi	r3,4
 20472c8:	d8c00015 	stw	r3,0(sp)
 20472cc:	e13ee317 	ldw	r4,-1140(fp)
 20472d0:	017fffc4 	movi	r5,-1
 20472d4:	01840584 	movi	r6,4118
 20472d8:	100f883a 	mov	r7,r2
 20472dc:	202be9c0 	call	202be9c <t_setsockopt>
 20472e0:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 20472e4:	e0bee417 	ldw	r2,-1136(fp)
 20472e8:	10bfffd8 	cmpnei	r2,r2,-1
 20472ec:	1000071e 	bne	r2,zero,204730c <u_mctest_run+0x4ac>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (1) failed, Err: %d\n",
 20472f0:	e13ee317 	ldw	r4,-1140(fp)
 20472f4:	202c9f40 	call	202c9f4 <t_errno>
 20472f8:	e13fff17 	ldw	r4,-4(fp)
 20472fc:	01408174 	movhi	r5,517
 2047300:	29471404 	addi	r5,r5,7248
 2047304:	100d883a 	mov	r6,r2
 2047308:	2026e100 	call	2026e10 <ns_printf>
                        t_errno(s));
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);
 204730c:	00808174 	movhi	r2,517
 2047310:	1090c904 	addi	r2,r2,17188
 2047314:	10800017 	ldw	r2,0(r2)
 2047318:	1009883a 	mov	r4,r2
 204731c:	20145600 	call	2014560 <__floatunsidf>
 2047320:	100b883a 	mov	r5,r2
 2047324:	180d883a 	mov	r6,r3
 2047328:	2809883a 	mov	r4,r5
 204732c:	300b883a 	mov	r5,r6
 2047330:	000d883a 	mov	r6,zero
 2047334:	01d01ff4 	movhi	r7,16511
 2047338:	39d00004 	addi	r7,r7,16384
 204733c:	2013bd40 	call	2013bd4 <__adddf3>
 2047340:	1009883a 	mov	r4,r2
 2047344:	180b883a 	mov	r5,r3
 2047348:	2005883a 	mov	r2,r4
 204734c:	2807883a 	mov	r3,r5
 2047350:	1009883a 	mov	r4,r2
 2047354:	180b883a 	mov	r5,r3
 2047358:	2012ba40 	call	2012ba4 <__fixunsdfsi>
 204735c:	e0bee515 	stw	r2,-1132(fp)

      while (cticks < endtime)
 2047360:	00003406 	br	2047434 <u_mctest_run+0x5d4>
      {
         int sa_size = sizeof(struct sockaddr_in);
 2047364:	00800404 	movi	r2,16
 2047368:	e0bffe15 	stw	r2,-8(fp)
         tk_yield();
 204736c:	20278080 	call	2027808 <tk_yield>

         iRet = t_recvfrom(s, achIn, BUFSIZE, 0, (struct sockaddr*)&stFrom, &sa_size);
 2047370:	e0bef204 	addi	r2,fp,-1080
 2047374:	e0feee04 	addi	r3,fp,-1096
 2047378:	d8c00015 	stw	r3,0(sp)
 204737c:	e0fffe04 	addi	r3,fp,-8
 2047380:	d8c00115 	stw	r3,4(sp)
 2047384:	e13ee317 	ldw	r4,-1140(fp)
 2047388:	100b883a 	mov	r5,r2
 204738c:	01810004 	movi	r6,1024
 2047390:	000f883a 	mov	r7,zero
 2047394:	202c2b40 	call	202c2b4 <t_recvfrom>
 2047398:	e0bee415 	stw	r2,-1136(fp)
         if (iRet < 0) 
 204739c:	e0bee417 	ldw	r2,-1136(fp)
 20473a0:	10000c0e 	bge	r2,zero,20473d4 <u_mctest_run+0x574>
         {
            if (t_errno(s) != EWOULDBLOCK)
 20473a4:	e13ee317 	ldw	r4,-1140(fp)
 20473a8:	202c9f40 	call	202c9f4 <t_errno>
 20473ac:	108002e0 	cmpeqi	r2,r2,11
 20473b0:	1000081e 	bne	r2,zero,20473d4 <u_mctest_run+0x574>
            {
               /*      perror("recvfrom() failed\n"); */
               ns_printf (pio,"t_recvfrom() failed, Error: %d\n", t_errno(s));
 20473b4:	e13ee317 	ldw	r4,-1140(fp)
 20473b8:	202c9f40 	call	202c9f4 <t_errno>
 20473bc:	e13fff17 	ldw	r4,-4(fp)
 20473c0:	01408174 	movhi	r5,517
 20473c4:	29472004 	addi	r5,r5,7296
 20473c8:	100d883a 	mov	r6,r2
 20473cc:	2026e100 	call	2026e10 <ns_printf>
 20473d0:	00003706 	br	20474b0 <u_mctest_run+0x650>
               /*     exit(1); */
               goto exitloop;
            }
         }
         if (iRet > 0)
 20473d4:	e0bee417 	ldw	r2,-1136(fp)
 20473d8:	0080160e 	bge	zero,r2,2047434 <u_mctest_run+0x5d4>
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 20473dc:	e0beef17 	ldw	r2,-1092(fp)
 20473e0:	1009883a 	mov	r4,r2
 20473e4:	2026a400 	call	2026a40 <print_ipad>
 20473e8:	1007883a 	mov	r3,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 20473ec:	e0beee8b 	ldhu	r2,-1094(fp)
 20473f0:	10bfffcc 	andi	r2,r2,65535
 20473f4:	1004d23a 	srli	r2,r2,8
 20473f8:	10bfffcc 	andi	r2,r2,65535
 20473fc:	11003fcc 	andi	r4,r2,255
 2047400:	e0beee8b 	ldhu	r2,-1094(fp)
 2047404:	10bfffcc 	andi	r2,r2,65535
 2047408:	1004923a 	slli	r2,r2,8
 204740c:	10bfffcc 	andi	r2,r2,65535
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 2047410:	2084b03a 	or	r2,r4,r2
             print_ipad(stFrom.sin_addr.s_addr),
             ntohs(stFrom.sin_port), achIn);
 2047414:	e13ef204 	addi	r4,fp,-1080
               goto exitloop;
            }
         }
         if (iRet > 0)
         {
            ns_printf(pio,"From host:%s port:%d, %s\n",
 2047418:	d9000015 	stw	r4,0(sp)
 204741c:	e13fff17 	ldw	r4,-4(fp)
 2047420:	01408174 	movhi	r5,517
 2047424:	29472804 	addi	r5,r5,7328
 2047428:	180d883a 	mov	r6,r3
 204742c:	100f883a 	mov	r7,r2
 2047430:	2026e100 	call	2026e10 <ns_printf>
      }

      /* loop around for 5 seconds waiting to receive datagrams */
      endtime = cticks + (TPS * 5);

      while (cticks < endtime)
 2047434:	00808174 	movhi	r2,517
 2047438:	1090c904 	addi	r2,r2,17188
 204743c:	10c00017 	ldw	r3,0(r2)
 2047440:	e0bee517 	ldw	r2,-1132(fp)
 2047444:	18bfc736 	bltu	r3,r2,2047364 <u_mctest_run+0x504>
             ntohs(stFrom.sin_port), achIn);
         }
      }   /* end while (cticks...) */

      /* make the socket blocking */
      cTmp = 0;
 2047448:	e03ffd05 	stb	zero,-12(fp)
      iRet = t_setsockopt(s, SOL_SOCKET, SO_NONBLOCK, (char *)&cTmp, sizeof(cTmp));
 204744c:	e0bffd04 	addi	r2,fp,-12
 2047450:	00c00044 	movi	r3,1
 2047454:	d8c00015 	stw	r3,0(sp)
 2047458:	e13ee317 	ldw	r4,-1140(fp)
 204745c:	017fffc4 	movi	r5,-1
 2047460:	01840584 	movi	r6,4118
 2047464:	100f883a 	mov	r7,r2
 2047468:	202be9c0 	call	202be9c <t_setsockopt>
 204746c:	e0bee415 	stw	r2,-1136(fp)
      if (iRet == SOCKET_ERROR) 
 2047470:	e0bee417 	ldw	r2,-1136(fp)
 2047474:	10bfffd8 	cmpnei	r2,r2,-1
 2047478:	1000071e 	bne	r2,zero,2047498 <u_mctest_run+0x638>
      {
         ns_printf (pio,"t_setsockopt() SO_NONBLOCK (0) failed, Err: %d\n",
 204747c:	e13ee317 	ldw	r4,-1140(fp)
 2047480:	202c9f40 	call	202c9f4 <t_errno>
 2047484:	e13fff17 	ldw	r4,-4(fp)
 2047488:	01408174 	movhi	r5,517
 204748c:	29472f04 	addi	r5,r5,7356
 2047490:	100d883a 	mov	r6,r2
 2047494:	2026e100 	call	2026e10 <ns_printf>
   stTo.sin_addr.s_addr = inet_addr(TEST_ADDR1);
   stTo.sin_port =        htons(TEST_PORT);
   ns_printf (pio,"Now sending to (and receiving from) multicast group: %s\n",
                  TEST_ADDR1);

   for (i = 0; i < LOOPMAX; i++)
 2047498:	e0bee217 	ldw	r2,-1144(fp)
 204749c:	10800044 	addi	r2,r2,1
 20474a0:	e0bee215 	stw	r2,-1144(fp)
 20474a4:	e0bee217 	ldw	r2,-1144(fp)
 20474a8:	108000d0 	cmplti	r2,r2,3
 20474ac:	103f621e 	bne	r2,zero,2047238 <u_mctest_run+0x3d8>
      }
   }   /* end for(;;) */

exitloop:
   /* delete the multicast group. */
   stMreq.imr_multiaddr = inet_addr(TEST_ADDR);
 20474b0:	01008174 	movhi	r4,517
 20474b4:	2106cc04 	addi	r4,r4,6960
 20474b8:	2047c340 	call	2047c34 <inet_addr>
 20474bc:	e0bffb15 	stw	r2,-20(fp)
   stMreq.imr_interface = netstatic[0].n_ipaddr;
 20474c0:	00809934 	movhi	r2,612
 20474c4:	10b50104 	addi	r2,r2,-11260
 20474c8:	10800a17 	ldw	r2,40(r2)
 20474cc:	e0bffc15 	stw	r2,-16(fp)
   iRet = t_setsockopt(s, IPPROTO_IP, IP_DROP_MEMBERSHIP, (char *)&stMreq, sizeof(stMreq));
 20474d0:	e0bffb04 	addi	r2,fp,-20
 20474d4:	00c00204 	movi	r3,8
 20474d8:	d8c00015 	stw	r3,0(sp)
 20474dc:	e13ee317 	ldw	r4,-1140(fp)
 20474e0:	000b883a 	mov	r5,zero
 20474e4:	01800344 	movi	r6,13
 20474e8:	100f883a 	mov	r7,r2
 20474ec:	202be9c0 	call	202be9c <t_setsockopt>
 20474f0:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 20474f4:	e0bee417 	ldw	r2,-1136(fp)
 20474f8:	10bfffd8 	cmpnei	r2,r2,-1
 20474fc:	1000071e 	bne	r2,zero,204751c <u_mctest_run+0x6bc>
   {
      ns_printf (pio,"t_setsockopt() IP_DROP_MEMBERSHIP failed, Err: %d\n",
 2047500:	e13ee317 	ldw	r4,-1140(fp)
 2047504:	202c9f40 	call	202c9f4 <t_errno>
 2047508:	e13fff17 	ldw	r4,-4(fp)
 204750c:	01408174 	movhi	r5,517
 2047510:	29473b04 	addi	r5,r5,7404
 2047514:	100d883a 	mov	r6,r2
 2047518:	2026e100 	call	2026e10 <ns_printf>
   {
      ns_printf (pio,"t_shutdown failed.  Err: %d\n", t_errno(s));
   }
#endif

   iRet = t_socketclose(s);
 204751c:	e13ee317 	ldw	r4,-1140(fp)
 2047520:	202c8ac0 	call	202c8ac <t_socketclose>
 2047524:	e0bee415 	stw	r2,-1136(fp)
   if (iRet == SOCKET_ERROR) 
 2047528:	e0bee417 	ldw	r2,-1136(fp)
 204752c:	10bfffd8 	cmpnei	r2,r2,-1
 2047530:	1000071e 	bne	r2,zero,2047550 <u_mctest_run+0x6f0>
   {
      ns_printf (pio,"t_socketclose() failed.  Err: %d\n", t_errno(s));
 2047534:	e13ee317 	ldw	r4,-1140(fp)
 2047538:	202c9f40 	call	202c9f4 <t_errno>
 204753c:	e13fff17 	ldw	r4,-4(fp)
 2047540:	01408174 	movhi	r5,517
 2047544:	29474804 	addi	r5,r5,7456
 2047548:	100d883a 	mov	r6,r2
 204754c:	2026e100 	call	2026e10 <ns_printf>
   }

   return(0);
 2047550:	0005883a 	mov	r2,zero
}  /* end main() */  
 2047554:	e037883a 	mov	sp,fp
 2047558:	dfc00117 	ldw	ra,4(sp)
 204755c:	df000017 	ldw	fp,0(sp)
 2047560:	dec00204 	addi	sp,sp,8
 2047564:	f800283a 	ret

02047568 <init_memdev>:
 * RETURNS: 
 */

int
init_memdev(void)
{
 2047568:	deffff04 	addi	sp,sp,-4
 204756c:	df000015 	stw	fp,0(sp)
 2047570:	d839883a 	mov	fp,sp
   /* add our IO pointer to master list */
   mdio.next = vfsystems;
 2047574:	00808174 	movhi	r2,517
 2047578:	1090f504 	addi	r2,r2,17364
 204757c:	10c00017 	ldw	r3,0(r2)
 2047580:	00808174 	movhi	r2,517
 2047584:	108fcf04 	addi	r2,r2,16188
 2047588:	10c00015 	stw	r3,0(r2)
   vfsystems = &mdio;
 204758c:	00808174 	movhi	r2,517
 2047590:	1090f504 	addi	r2,r2,17364
 2047594:	00c08174 	movhi	r3,517
 2047598:	18cfcf04 	addi	r3,r3,16188
 204759c:	10c00015 	stw	r3,0(r2)

   /* add the memory device files to vfs list */
   mdlist[0].next = vfsfiles;
 20475a0:	00808174 	movhi	r2,517
 20475a4:	1090f704 	addi	r2,r2,17372
 20475a8:	10c00017 	ldw	r3,0(r2)
 20475ac:	00808174 	movhi	r2,517
 20475b0:	108fd804 	addi	r2,r2,16224
 20475b4:	10c00015 	stw	r3,0(r2)
   vfsfiles = &mdlist[3];
 20475b8:	00808174 	movhi	r2,517
 20475bc:	1090f704 	addi	r2,r2,17372
 20475c0:	00c08174 	movhi	r3,517
 20475c4:	18cff904 	addi	r3,r3,16356
 20475c8:	10c00015 	stw	r3,0(r2)

   return 0;
 20475cc:	0005883a 	mov	r2,zero
}
 20475d0:	e037883a 	mov	sp,fp
 20475d4:	df000017 	ldw	fp,0(sp)
 20475d8:	dec00104 	addi	sp,sp,4
 20475dc:	f800283a 	ret

020475e0 <md_fopen>:
 * RETURNS: 
 */

VFILE* 
md_fopen(char * name, char * mode)
{
 20475e0:	defffd04 	addi	sp,sp,-12
 20475e4:	df000215 	stw	fp,8(sp)
 20475e8:	df000204 	addi	fp,sp,8
 20475ec:	e13ffe15 	stw	r4,-8(fp)
 20475f0:	e17fff15 	stw	r5,-4(fp)
   USE_ARG(mode);
   USE_ARG(name);
   return NULL;
 20475f4:	0005883a 	mov	r2,zero
}
 20475f8:	e037883a 	mov	sp,fp
 20475fc:	df000017 	ldw	fp,0(sp)
 2047600:	dec00104 	addi	sp,sp,4
 2047604:	f800283a 	ret

02047608 <md_fclose>:
 * RETURNS: 
 */

void   
md_fclose(VFILE * vfd)
{
 2047608:	defffe04 	addi	sp,sp,-8
 204760c:	df000115 	stw	fp,4(sp)
 2047610:	df000104 	addi	fp,sp,4
 2047614:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);
}
 2047618:	e037883a 	mov	sp,fp
 204761c:	df000017 	ldw	fp,0(sp)
 2047620:	dec00104 	addi	sp,sp,4
 2047624:	f800283a 	ret

02047628 <md_fread>:
 * RETURNS: 
 */

int    
md_fread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 2047628:	defff704 	addi	sp,sp,-36
 204762c:	dfc00815 	stw	ra,32(sp)
 2047630:	df000715 	stw	fp,28(sp)
 2047634:	df000704 	addi	fp,sp,28
 2047638:	e13ffc15 	stw	r4,-16(fp)
 204763c:	e17ffd15 	stw	r5,-12(fp)
 2047640:	e1bffe15 	stw	r6,-8(fp)
 2047644:	e1ffff15 	stw	r7,-4(fp)
   u_long   bcount;     /* number of bytes put in caller's buffer */
   u_long   location;   /* current offset into file */
   unsigned long file_size = MEMDEV_SIZE;
 2047648:	00800834 	movhi	r2,32
 204764c:	e0bffa15 	stw	r2,-24(fp)
   if(vfd && vfd->file)
 2047650:	e0bfff17 	ldw	r2,-4(fp)
 2047654:	10000726 	beq	r2,zero,2047674 <md_fread+0x4c>
 2047658:	e0bfff17 	ldw	r2,-4(fp)
 204765c:	10800117 	ldw	r2,4(r2)
 2047660:	10000426 	beq	r2,zero,2047674 <md_fread+0x4c>
   {
      file_size = vfd->file->real_size; 
 2047664:	e0bfff17 	ldw	r2,-4(fp)
 2047668:	10800117 	ldw	r2,4(r2)
 204766c:	10800717 	ldw	r2,28(r2)
 2047670:	e0bffa15 	stw	r2,-24(fp)
#ifdef SEG16_16   /* 16-bit x86 must include segment. */
   if(vfd->cmploc == (u_char*)0xFFFFFFFF)   /* at EOF */
      return 0;
   location = (u_long)(((char huge *)vfd->cmploc) - ((char huge *)vfd->file->data));
#else
   location = (u_long)(vfd->cmploc - vfd->file->data);
 2047674:	e0bfff17 	ldw	r2,-4(fp)
 2047678:	10800217 	ldw	r2,8(r2)
 204767c:	1007883a 	mov	r3,r2
 2047680:	e0bfff17 	ldw	r2,-4(fp)
 2047684:	10800117 	ldw	r2,4(r2)
 2047688:	10800617 	ldw	r2,24(r2)
 204768c:	1885c83a 	sub	r2,r3,r2
 2047690:	e0bffb15 	stw	r2,-20(fp)
#endif   /* SEG16_16 */

   bcount = (items * (u_long)size);     /* number of bytes to transfer */
 2047694:	e0fffe17 	ldw	r3,-8(fp)
 2047698:	e0bffd17 	ldw	r2,-12(fp)
 204769c:	1885383a 	mul	r2,r3,r2
 20476a0:	e0bff915 	stw	r2,-28(fp)

   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
 20476a4:	e0fffb17 	ldw	r3,-20(fp)
 20476a8:	e0bff917 	ldw	r2,-28(fp)
 20476ac:	1885883a 	add	r2,r3,r2
 20476b0:	e0fffa17 	ldw	r3,-24(fp)
 20476b4:	1880042e 	bgeu	r3,r2,20476c8 <md_fread+0xa0>
      bcount = ((u_long)file_size - location);
 20476b8:	e0fffa17 	ldw	r3,-24(fp)
 20476bc:	e0bffb17 	ldw	r2,-20(fp)
 20476c0:	1885c83a 	sub	r2,r3,r2
 20476c4:	e0bff915 	stw	r2,-28(fp)

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 20476c8:	e0fffb17 	ldw	r3,-20(fp)
 20476cc:	e0bffa17 	ldw	r2,-24(fp)
 20476d0:	1880052e 	bgeu	r3,r2,20476e8 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 20476d4:	e0bff917 	ldw	r2,-28(fp)
 20476d8:	10bfffec 	andhi	r2,r2,65535
   /* if near end of memory, trim read count accordingly */
   if ((location + bcount) > file_size)
      bcount = ((u_long)file_size - location);

   /* trap bogus size items and end-of-x86 memory conditions */
   if((location >= file_size) ||
 20476dc:	1000021e 	bne	r2,zero,20476e8 <md_fread+0xc0>
      (bcount  & 0xFFFF0000) ||
 20476e0:	e0bff917 	ldw	r2,-28(fp)
 20476e4:	1000021e 	bne	r2,zero,20476f0 <md_fread+0xc8>
      (bcount == 0))
   {
      return 0;
 20476e8:	0005883a 	mov	r2,zero
 20476ec:	00002006 	br	2047770 <md_fread+0x148>
   /* Use VF_NODATA if memory devices have a size, but no
      data. This can be used to measure file read speed
      without introducing an undefined data copy. */
   /* VF_NODATA is defined in ../h/vfsfiles.h */
   
   if (!(vfd->file->flags & VF_NODATA))
 20476f0:	e0bfff17 	ldw	r2,-4(fp)
 20476f4:	10800117 	ldw	r2,4(r2)
 20476f8:	1080058b 	ldhu	r2,22(r2)
 20476fc:	10bfffcc 	andi	r2,r2,65535
 2047700:	10a0001c 	xori	r2,r2,32768
 2047704:	10a00004 	addi	r2,r2,-32768
 2047708:	10001016 	blt	r2,zero,204774c <md_fread+0x124>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 204770c:	e0bfff17 	ldw	r2,-4(fp)
 2047710:	10800117 	ldw	r2,4(r2)
 2047714:	10800103 	ldbu	r2,4(r2)
 2047718:	10803fcc 	andi	r2,r2,255
 204771c:	1080201c 	xori	r2,r2,128
 2047720:	10bfe004 	addi	r2,r2,-128
 2047724:	10801b58 	cmpnei	r2,r2,109
 2047728:	1000081e 	bne	r2,zero,204774c <md_fread+0x124>
         MEMCPY(buf, vfd->cmploc + MEMDEV_BASE, (unsigned)bcount);
 204772c:	e0bfff17 	ldw	r2,-4(fp)
 2047730:	10c00217 	ldw	r3,8(r2)
 2047734:	00800834 	movhi	r2,32
 2047738:	1885883a 	add	r2,r3,r2
 204773c:	e13ffc17 	ldw	r4,-16(fp)
 2047740:	100b883a 	mov	r5,r2
 2047744:	e1bff917 	ldw	r6,-28(fp)
 2047748:	200660c0 	call	200660c <memcpy>
         vfd->cmploc = (u_char *)cp;
      else     /* read wrapped memory, set pointer to EOF value */
         vfd->cmploc = (u_char*)(0xFFFFFFFF);  /* EOF */
   }
#else
   vfd->cmploc += bcount;  /* adjust location */
 204774c:	e0bfff17 	ldw	r2,-4(fp)
 2047750:	10c00217 	ldw	r3,8(r2)
 2047754:	e0bff917 	ldw	r2,-28(fp)
 2047758:	1887883a 	add	r3,r3,r2
 204775c:	e0bfff17 	ldw	r2,-4(fp)
 2047760:	10c00215 	stw	r3,8(r2)
#endif
   
   return ((int)bcount/size);
 2047764:	e0fff917 	ldw	r3,-28(fp)
 2047768:	e0bffd17 	ldw	r2,-12(fp)
 204776c:	1885203a 	divu	r2,r3,r2
}
 2047770:	e037883a 	mov	sp,fp
 2047774:	dfc00117 	ldw	ra,4(sp)
 2047778:	df000017 	ldw	fp,0(sp)
 204777c:	dec00204 	addi	sp,sp,8
 2047780:	f800283a 	ret

02047784 <md_fwrite>:
 * RETURNS: 
 */

int    
md_fwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 2047784:	defffb04 	addi	sp,sp,-20
 2047788:	df000415 	stw	fp,16(sp)
 204778c:	df000404 	addi	fp,sp,16
 2047790:	e13ffc15 	stw	r4,-16(fp)
 2047794:	e17ffd15 	stw	r5,-12(fp)
 2047798:	e1bffe15 	stw	r6,-8(fp)
 204779c:	e1ffff15 	stw	r7,-4(fp)
   if (vfd->file->name[0] == 'm')   /* memory device */
 20477a0:	e0bfff17 	ldw	r2,-4(fp)
 20477a4:	10800117 	ldw	r2,4(r2)
 20477a8:	10800103 	ldbu	r2,4(r2)
 20477ac:	10803fcc 	andi	r2,r2,255
 20477b0:	1080201c 	xori	r2,r2,128
 20477b4:	10bfe004 	addi	r2,r2,-128
 20477b8:	10801b58 	cmpnei	r2,r2,109
 20477bc:	1000021e 	bne	r2,zero,20477c8 <md_fwrite+0x44>
      return 0;   /* not writable device */
 20477c0:	0005883a 	mov	r2,zero
 20477c4:	00000906 	br	20477ec <md_fwrite+0x68>

   vfd->cmploc += (items * size);   /* adjust location */
 20477c8:	e0bfff17 	ldw	r2,-4(fp)
 20477cc:	10c00217 	ldw	r3,8(r2)
 20477d0:	e13ffe17 	ldw	r4,-8(fp)
 20477d4:	e0bffd17 	ldw	r2,-12(fp)
 20477d8:	2085383a 	mul	r2,r4,r2
 20477dc:	1887883a 	add	r3,r3,r2
 20477e0:	e0bfff17 	ldw	r2,-4(fp)
 20477e4:	10c00215 	stw	r3,8(r2)

   USE_ARG(buf);     /* supress compiler warnings */

   return (items);
 20477e8:	e0bffe17 	ldw	r2,-8(fp)
}
 20477ec:	e037883a 	mov	sp,fp
 20477f0:	df000017 	ldw	fp,0(sp)
 20477f4:	dec00104 	addi	sp,sp,4
 20477f8:	f800283a 	ret

020477fc <md_fseek>:
 * RETURNS: 
 */

int
md_fseek(VFILE * vfd, long offset, int mode)
{
 20477fc:	defffc04 	addi	sp,sp,-16
 2047800:	df000315 	stw	fp,12(sp)
 2047804:	df000304 	addi	fp,sp,12
 2047808:	e13ffd15 	stw	r4,-12(fp)
 204780c:	e17ffe15 	stw	r5,-8(fp)
 2047810:	e1bfff15 	stw	r6,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   USE_ARG(offset);
   USE_ARG(mode);
   return 0;
 2047814:	0005883a 	mov	r2,zero
}
 2047818:	e037883a 	mov	sp,fp
 204781c:	df000017 	ldw	fp,0(sp)
 2047820:	dec00104 	addi	sp,sp,4
 2047824:	f800283a 	ret

02047828 <md_ftell>:
 * RETURNS: 
 */

long   
md_ftell(VFILE * vfd)
{
 2047828:	defffe04 	addi	sp,sp,-8
 204782c:	df000115 	stw	fp,4(sp)
 2047830:	df000104 	addi	fp,sp,4
 2047834:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(vfd);     /* supress compiler warnings */
   return MEMDEV_SIZE;
 2047838:	00800834 	movhi	r2,32
}
 204783c:	e037883a 	mov	sp,fp
 2047840:	df000017 	ldw	fp,0(sp)
 2047844:	dec00104 	addi	sp,sp,4
 2047848:	f800283a 	ret

0204784c <md_fgetc>:
 * RETURNS: 
 */

int    
md_fgetc(VFILE * vfd)
{
 204784c:	defffc04 	addi	sp,sp,-16
 2047850:	df000315 	stw	fp,12(sp)
 2047854:	df000304 	addi	fp,sp,12
 2047858:	e13fff15 	stw	r4,-4(fp)
   unsigned location;   /* current offset infile */
   int   retval   =  0;
 204785c:	e03ffd15 	stw	zero,-12(fp)

   location = vfd->cmploc - vfd->file->data;
 2047860:	e0bfff17 	ldw	r2,-4(fp)
 2047864:	10800217 	ldw	r2,8(r2)
 2047868:	1007883a 	mov	r3,r2
 204786c:	e0bfff17 	ldw	r2,-4(fp)
 2047870:	10800117 	ldw	r2,4(r2)
 2047874:	10800617 	ldw	r2,24(r2)
 2047878:	1885c83a 	sub	r2,r3,r2
 204787c:	e0bffe15 	stw	r2,-8(fp)
   if (location >= vfd->file->real_size)     /* at end of file? */
 2047880:	e0bfff17 	ldw	r2,-4(fp)
 2047884:	10800117 	ldw	r2,4(r2)
 2047888:	10800717 	ldw	r2,28(r2)
 204788c:	e0fffe17 	ldw	r3,-8(fp)
 2047890:	18800236 	bltu	r3,r2,204789c <md_fgetc+0x50>
      return EOF;
 2047894:	00bfffc4 	movi	r2,-1
 2047898:	00001a06 	br	2047904 <md_fgetc+0xb8>

   if (!(vfd->file->flags & VF_NODATA))
 204789c:	e0bfff17 	ldw	r2,-4(fp)
 20478a0:	10800117 	ldw	r2,4(r2)
 20478a4:	1080058b 	ldhu	r2,22(r2)
 20478a8:	10bfffcc 	andi	r2,r2,65535
 20478ac:	10a0001c 	xori	r2,r2,32768
 20478b0:	10a00004 	addi	r2,r2,-32768
 20478b4:	10000d16 	blt	r2,zero,20478ec <md_fgetc+0xa0>
   {
      if (vfd->file->name[0] == 'm')   /* memory device */
 20478b8:	e0bfff17 	ldw	r2,-4(fp)
 20478bc:	10800117 	ldw	r2,4(r2)
 20478c0:	10800103 	ldbu	r2,4(r2)
 20478c4:	10803fcc 	andi	r2,r2,255
 20478c8:	1080201c 	xori	r2,r2,128
 20478cc:	10bfe004 	addi	r2,r2,-128
 20478d0:	10801b58 	cmpnei	r2,r2,109
 20478d4:	1000051e 	bne	r2,zero,20478ec <md_fgetc+0xa0>
         retval = (int)(*vfd->cmploc) & 0xFF ;
 20478d8:	e0bfff17 	ldw	r2,-4(fp)
 20478dc:	10800217 	ldw	r2,8(r2)
 20478e0:	10800003 	ldbu	r2,0(r2)
 20478e4:	10803fcc 	andi	r2,r2,255
 20478e8:	e0bffd15 	stw	r2,-12(fp)
   }

   /* else for null device or files without data, 
      use whatever is in retval */

   vfd->cmploc++;    /* adjust location */
 20478ec:	e0bfff17 	ldw	r2,-4(fp)
 20478f0:	10800217 	ldw	r2,8(r2)
 20478f4:	10c00044 	addi	r3,r2,1
 20478f8:	e0bfff17 	ldw	r2,-4(fp)
 20478fc:	10c00215 	stw	r3,8(r2)
   return retval;
 2047900:	e0bffd17 	ldw	r2,-12(fp)
}
 2047904:	e037883a 	mov	sp,fp
 2047908:	df000017 	ldw	fp,0(sp)
 204790c:	dec00104 	addi	sp,sp,4
 2047910:	f800283a 	ret

02047914 <md_unlink>:
 * RETURNS: 
 */

int    
md_unlink(char * filename)
{
 2047914:	defffe04 	addi	sp,sp,-8
 2047918:	df000115 	stw	fp,4(sp)
 204791c:	df000104 	addi	fp,sp,4
 2047920:	e13fff15 	stw	r4,-4(fp)
   USE_ARG(filename);     /* supress compiler warnings */
   return 0;
 2047924:	0005883a 	mov	r2,zero
}
 2047928:	e037883a 	mov	sp,fp
 204792c:	df000017 	ldw	fp,0(sp)
 2047930:	dec00104 	addi	sp,sp,4
 2047934:	f800283a 	ret

02047938 <parse_ipad>:

char *   
parse_ipad(ip_addr * ipout,   /* pointer to IP address to set */
   unsigned *  sbits,      /* default subnet bit number */
   char *   stringin)      /* buffer with ascii to parse */
{
 2047938:	defff604 	addi	sp,sp,-40
 204793c:	dfc00915 	stw	ra,36(sp)
 2047940:	df000815 	stw	fp,32(sp)
 2047944:	df000804 	addi	fp,sp,32
 2047948:	e13ffd15 	stw	r4,-12(fp)
 204794c:	e17ffe15 	stw	r5,-8(fp)
 2047950:	e1bfff15 	stw	r6,-4(fp)
   char *   cp;
   int   dots  =  0; /* periods imbedded in input string */
 2047954:	e03ff915 	stw	zero,-28(fp)
   union   
   {
      u_char   c[4];
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";
 2047958:	00808174 	movhi	r2,517
 204795c:	10875104 	addi	r2,r2,7492
 2047960:	e0bffa15 	stw	r2,-24(fp)

   cp = stringin;
 2047964:	e0bfff17 	ldw	r2,-4(fp)
 2047968:	e0bff815 	stw	r2,-32(fp)
   while (*cp)
 204796c:	00002506 	br	2047a04 <parse_ipad+0xcc>
   {
      if (*cp > '9' || *cp < '.' || *cp == '/')
 2047970:	e0bff817 	ldw	r2,-32(fp)
 2047974:	10800003 	ldbu	r2,0(r2)
 2047978:	10803fcc 	andi	r2,r2,255
 204797c:	1080201c 	xori	r2,r2,128
 2047980:	10bfe004 	addi	r2,r2,-128
 2047984:	10800e88 	cmpgei	r2,r2,58
 2047988:	10000e1e 	bne	r2,zero,20479c4 <parse_ipad+0x8c>
 204798c:	e0bff817 	ldw	r2,-32(fp)
 2047990:	10800003 	ldbu	r2,0(r2)
 2047994:	10803fcc 	andi	r2,r2,255
 2047998:	1080201c 	xori	r2,r2,128
 204799c:	10bfe004 	addi	r2,r2,-128
 20479a0:	10800b90 	cmplti	r2,r2,46
 20479a4:	1000071e 	bne	r2,zero,20479c4 <parse_ipad+0x8c>
 20479a8:	e0bff817 	ldw	r2,-32(fp)
 20479ac:	10800003 	ldbu	r2,0(r2)
 20479b0:	10803fcc 	andi	r2,r2,255
 20479b4:	1080201c 	xori	r2,r2,128
 20479b8:	10bfe004 	addi	r2,r2,-128
 20479bc:	10800bd8 	cmpnei	r2,r2,47
 20479c0:	1000031e 	bne	r2,zero,20479d0 <parse_ipad+0x98>
         return("all chars must be digits (0-9) or dots (.)");
 20479c4:	00808174 	movhi	r2,517
 20479c8:	10875a04 	addi	r2,r2,7528
 20479cc:	00009406 	br	2047c20 <parse_ipad+0x2e8>
      if (*cp == '.')dots++;
 20479d0:	e0bff817 	ldw	r2,-32(fp)
 20479d4:	10800003 	ldbu	r2,0(r2)
 20479d8:	10803fcc 	andi	r2,r2,255
 20479dc:	1080201c 	xori	r2,r2,128
 20479e0:	10bfe004 	addi	r2,r2,-128
 20479e4:	10800b98 	cmpnei	r2,r2,46
 20479e8:	1000031e 	bne	r2,zero,20479f8 <parse_ipad+0xc0>
 20479ec:	e0bff917 	ldw	r2,-28(fp)
 20479f0:	10800044 	addi	r2,r2,1
 20479f4:	e0bff915 	stw	r2,-28(fp)
         cp++;
 20479f8:	e0bff817 	ldw	r2,-32(fp)
 20479fc:	10800044 	addi	r2,r2,1
 2047a00:	e0bff815 	stw	r2,-32(fp)
      u_long   l;
   } retval;
   char *   toobig   = "each number must be less than 255";

   cp = stringin;
   while (*cp)
 2047a04:	e0bff817 	ldw	r2,-32(fp)
 2047a08:	10800003 	ldbu	r2,0(r2)
 2047a0c:	10803fcc 	andi	r2,r2,255
 2047a10:	1080201c 	xori	r2,r2,128
 2047a14:	10bfe004 	addi	r2,r2,-128
 2047a18:	103fd51e 	bne	r2,zero,2047970 <parse_ipad+0x38>
         return("all chars must be digits (0-9) or dots (.)");
      if (*cp == '.')dots++;
         cp++;
   }

   if ( dots < 1 || dots > 3 )
 2047a1c:	e0bff917 	ldw	r2,-28(fp)
 2047a20:	0080030e 	bge	zero,r2,2047a30 <parse_ipad+0xf8>
 2047a24:	e0bff917 	ldw	r2,-28(fp)
 2047a28:	10800110 	cmplti	r2,r2,4
 2047a2c:	1000031e 	bne	r2,zero,2047a3c <parse_ipad+0x104>
      return("string must contain 1 - 3 dots (.)");
 2047a30:	00808174 	movhi	r2,517
 2047a34:	10876504 	addi	r2,r2,7572
 2047a38:	00007906 	br	2047c20 <parse_ipad+0x2e8>

   cp = stringin;
 2047a3c:	e0bfff17 	ldw	r2,-4(fp)
 2047a40:	e0bff815 	stw	r2,-32(fp)
   if ((number = atoi(cp)) > 255)   /* set net number */
 2047a44:	e13ff817 	ldw	r4,-32(fp)
 2047a48:	20044d40 	call	20044d4 <atoi>
 2047a4c:	e0bffb15 	stw	r2,-20(fp)
 2047a50:	e0bffb17 	ldw	r2,-20(fp)
 2047a54:	10804010 	cmplti	r2,r2,256
 2047a58:	1000021e 	bne	r2,zero,2047a64 <parse_ipad+0x12c>
      return(toobig);
 2047a5c:	e0bffa17 	ldw	r2,-24(fp)
 2047a60:	00006f06 	br	2047c20 <parse_ipad+0x2e8>

   retval.c[0] = (u_char)number;
 2047a64:	e0bffb17 	ldw	r2,-20(fp)
 2047a68:	e0bffc05 	stb	r2,-16(fp)

   while (*cp != '.')cp++; /* find dot (end of number) */
 2047a6c:	00000306 	br	2047a7c <parse_ipad+0x144>
 2047a70:	e0bff817 	ldw	r2,-32(fp)
 2047a74:	10800044 	addi	r2,r2,1
 2047a78:	e0bff815 	stw	r2,-32(fp)
 2047a7c:	e0bff817 	ldw	r2,-32(fp)
 2047a80:	10800003 	ldbu	r2,0(r2)
 2047a84:	10803fcc 	andi	r2,r2,255
 2047a88:	1080201c 	xori	r2,r2,128
 2047a8c:	10bfe004 	addi	r2,r2,-128
 2047a90:	10800b98 	cmpnei	r2,r2,46
 2047a94:	103ff61e 	bne	r2,zero,2047a70 <parse_ipad+0x138>
      cp++;             /* point past dot */
 2047a98:	e0bff817 	ldw	r2,-32(fp)
 2047a9c:	10800044 	addi	r2,r2,1
 2047aa0:	e0bff815 	stw	r2,-32(fp)

   if (dots == 1 || dots == 2) retval.c[1] = 0;
 2047aa4:	e0bff917 	ldw	r2,-28(fp)
 2047aa8:	10800060 	cmpeqi	r2,r2,1
 2047aac:	1000031e 	bne	r2,zero,2047abc <parse_ipad+0x184>
 2047ab0:	e0bff917 	ldw	r2,-28(fp)
 2047ab4:	10800098 	cmpnei	r2,r2,2
 2047ab8:	1000021e 	bne	r2,zero,2047ac4 <parse_ipad+0x18c>
 2047abc:	e03ffc45 	stb	zero,-15(fp)
 2047ac0:	00001806 	br	2047b24 <parse_ipad+0x1ec>
      else
   {
      number = atoi(cp);
 2047ac4:	e13ff817 	ldw	r4,-32(fp)
 2047ac8:	20044d40 	call	20044d4 <atoi>
 2047acc:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 2047ad0:	00000306 	br	2047ae0 <parse_ipad+0x1a8>
 2047ad4:	e0bff817 	ldw	r2,-32(fp)
 2047ad8:	10800044 	addi	r2,r2,1
 2047adc:	e0bff815 	stw	r2,-32(fp)
 2047ae0:	e0bff817 	ldw	r2,-32(fp)
 2047ae4:	10800003 	ldbu	r2,0(r2)
 2047ae8:	10803fcc 	andi	r2,r2,255
 2047aec:	1080201c 	xori	r2,r2,128
 2047af0:	10bfe004 	addi	r2,r2,-128
 2047af4:	10800b98 	cmpnei	r2,r2,46
 2047af8:	103ff61e 	bne	r2,zero,2047ad4 <parse_ipad+0x19c>
         cp++;             /* point past dot */
 2047afc:	e0bff817 	ldw	r2,-32(fp)
 2047b00:	10800044 	addi	r2,r2,1
 2047b04:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 2047b08:	e0bffb17 	ldw	r2,-20(fp)
 2047b0c:	10804010 	cmplti	r2,r2,256
 2047b10:	1000021e 	bne	r2,zero,2047b1c <parse_ipad+0x1e4>
 2047b14:	e0bffa17 	ldw	r2,-24(fp)
 2047b18:	00004106 	br	2047c20 <parse_ipad+0x2e8>
         retval.c[1] = (u_char)number;
 2047b1c:	e0bffb17 	ldw	r2,-20(fp)
 2047b20:	e0bffc45 	stb	r2,-15(fp)
   }

   if (dots == 1) retval.c[2] = 0;
 2047b24:	e0bff917 	ldw	r2,-28(fp)
 2047b28:	10800058 	cmpnei	r2,r2,1
 2047b2c:	1000021e 	bne	r2,zero,2047b38 <parse_ipad+0x200>
 2047b30:	e03ffc85 	stb	zero,-14(fp)
 2047b34:	00001806 	br	2047b98 <parse_ipad+0x260>
      else
   {
      number = atoi(cp);
 2047b38:	e13ff817 	ldw	r4,-32(fp)
 2047b3c:	20044d40 	call	20044d4 <atoi>
 2047b40:	e0bffb15 	stw	r2,-20(fp)
      while (*cp != '.')cp++; /* find dot (end of number) */
 2047b44:	00000306 	br	2047b54 <parse_ipad+0x21c>
 2047b48:	e0bff817 	ldw	r2,-32(fp)
 2047b4c:	10800044 	addi	r2,r2,1
 2047b50:	e0bff815 	stw	r2,-32(fp)
 2047b54:	e0bff817 	ldw	r2,-32(fp)
 2047b58:	10800003 	ldbu	r2,0(r2)
 2047b5c:	10803fcc 	andi	r2,r2,255
 2047b60:	1080201c 	xori	r2,r2,128
 2047b64:	10bfe004 	addi	r2,r2,-128
 2047b68:	10800b98 	cmpnei	r2,r2,46
 2047b6c:	103ff61e 	bne	r2,zero,2047b48 <parse_ipad+0x210>
         cp++;             /* point past dot */
 2047b70:	e0bff817 	ldw	r2,-32(fp)
 2047b74:	10800044 	addi	r2,r2,1
 2047b78:	e0bff815 	stw	r2,-32(fp)
      if (number > 255) return(toobig);
 2047b7c:	e0bffb17 	ldw	r2,-20(fp)
 2047b80:	10804010 	cmplti	r2,r2,256
 2047b84:	1000021e 	bne	r2,zero,2047b90 <parse_ipad+0x258>
 2047b88:	e0bffa17 	ldw	r2,-24(fp)
 2047b8c:	00002406 	br	2047c20 <parse_ipad+0x2e8>
         retval.c[2] = (u_char)number;
 2047b90:	e0bffb17 	ldw	r2,-20(fp)
 2047b94:	e0bffc85 	stb	r2,-14(fp)
   }

   if ((number = atoi(cp)) > 255)
 2047b98:	e13ff817 	ldw	r4,-32(fp)
 2047b9c:	20044d40 	call	20044d4 <atoi>
 2047ba0:	e0bffb15 	stw	r2,-20(fp)
 2047ba4:	e0bffb17 	ldw	r2,-20(fp)
 2047ba8:	10804010 	cmplti	r2,r2,256
 2047bac:	1000021e 	bne	r2,zero,2047bb8 <parse_ipad+0x280>
      return(toobig);
 2047bb0:	e0bffa17 	ldw	r2,-24(fp)
 2047bb4:	00001a06 	br	2047c20 <parse_ipad+0x2e8>
   retval.c[3] = (u_char)number;
 2047bb8:	e0bffb17 	ldw	r2,-20(fp)
 2047bbc:	e0bffcc5 	stb	r2,-13(fp)

   if (retval.c[0] < 128) *sbits = 8;
 2047bc0:	e0bffc03 	ldbu	r2,-16(fp)
 2047bc4:	10803fcc 	andi	r2,r2,255
 2047bc8:	1080201c 	xori	r2,r2,128
 2047bcc:	10bfe004 	addi	r2,r2,-128
 2047bd0:	10000416 	blt	r2,zero,2047be4 <parse_ipad+0x2ac>
 2047bd4:	e0bffe17 	ldw	r2,-8(fp)
 2047bd8:	00c00204 	movi	r3,8
 2047bdc:	10c00015 	stw	r3,0(r2)
 2047be0:	00000b06 	br	2047c10 <parse_ipad+0x2d8>
      else if(retval.c[0] < 192) *sbits = 16;
 2047be4:	e0bffc03 	ldbu	r2,-16(fp)
 2047be8:	10803fcc 	andi	r2,r2,255
 2047bec:	10803028 	cmpgeui	r2,r2,192
 2047bf0:	1000041e 	bne	r2,zero,2047c04 <parse_ipad+0x2cc>
 2047bf4:	e0bffe17 	ldw	r2,-8(fp)
 2047bf8:	00c00404 	movi	r3,16
 2047bfc:	10c00015 	stw	r3,0(r2)
 2047c00:	00000306 	br	2047c10 <parse_ipad+0x2d8>
      else *sbits = 24;
 2047c04:	e0bffe17 	ldw	r2,-8(fp)
 2047c08:	00c00604 	movi	r3,24
 2047c0c:	10c00015 	stw	r3,0(r2)

      *ipout = retval.l;      /* everything went OK, return number */
 2047c10:	e0fffc17 	ldw	r3,-16(fp)
 2047c14:	e0bffd17 	ldw	r2,-12(fp)
 2047c18:	10c00015 	stw	r3,0(r2)
   return(NULL);        /* return OK code (no error string) */
 2047c1c:	0005883a 	mov	r2,zero
}
 2047c20:	e037883a 	mov	sp,fp
 2047c24:	dfc00117 	ldw	ra,4(sp)
 2047c28:	df000017 	ldw	fp,0(sp)
 2047c2c:	dec00204 	addi	sp,sp,8
 2047c30:	f800283a 	ret

02047c34 <inet_addr>:
 * RETURNS: u_long ipaddr
 */

u_long 
inet_addr(char FAR * str)
{
 2047c34:	defffb04 	addi	sp,sp,-20
 2047c38:	dfc00415 	stw	ra,16(sp)
 2047c3c:	df000315 	stw	fp,12(sp)
 2047c40:	df000304 	addi	fp,sp,12
 2047c44:	e13fff15 	stw	r4,-4(fp)
    * we need to make the conversion. Usually this function will be 
    * used for debugging, so I think we can bear the STRCPY overhead.
    */
   static char nearBuf[30];

   strcpy((char FAR *)nearBuf,str);
 2047c48:	010081b4 	movhi	r4,518
 2047c4c:	2103e104 	addi	r4,r4,3972
 2047c50:	e17fff17 	ldw	r5,-4(fp)
 2047c54:	200756c0 	call	200756c <strcpy>
   if ( parse_ipad(&ipaddr,&bits,nearBuf) == NULL )
 2047c58:	e0bffe04 	addi	r2,fp,-8
 2047c5c:	e13ffd04 	addi	r4,fp,-12
 2047c60:	100b883a 	mov	r5,r2
 2047c64:	018081b4 	movhi	r6,518
 2047c68:	3183e104 	addi	r6,r6,3972
 2047c6c:	20479380 	call	2047938 <parse_ipad>
 2047c70:	1000021e 	bne	r2,zero,2047c7c <inet_addr+0x48>
   {
      return ipaddr ;
 2047c74:	e0bffd17 	ldw	r2,-12(fp)
 2047c78:	00000106 	br	2047c80 <inet_addr+0x4c>
   }
   else
   {
      return (u_long)NULL ;
 2047c7c:	0005883a 	mov	r2,zero
   }
}
 2047c80:	e037883a 	mov	sp,fp
 2047c84:	dfc00117 	ldw	ra,4(sp)
 2047c88:	df000017 	ldw	fp,0(sp)
 2047c8c:	dec00204 	addi	sp,sp,8
 2047c90:	f800283a 	ret

02047c94 <hextoa>:
 * RETURNS: character 0-9 or A-F
 */

char
hextoa(int val)
{
 2047c94:	defffe04 	addi	sp,sp,-8
 2047c98:	df000115 	stw	fp,4(sp)
 2047c9c:	df000104 	addi	fp,sp,4
 2047ca0:	e13fff15 	stw	r4,-4(fp)
   val &= 0x0f;
 2047ca4:	e0bfff17 	ldw	r2,-4(fp)
 2047ca8:	108003cc 	andi	r2,r2,15
 2047cac:	e0bfff15 	stw	r2,-4(fp)
   if(val < 10)
 2047cb0:	e0bfff17 	ldw	r2,-4(fp)
 2047cb4:	10800288 	cmpgei	r2,r2,10
 2047cb8:	1000031e 	bne	r2,zero,2047cc8 <hextoa+0x34>
      return (char)(val + '0');
 2047cbc:	e0bfff17 	ldw	r2,-4(fp)
 2047cc0:	10800c04 	addi	r2,r2,48
 2047cc4:	00000206 	br	2047cd0 <hextoa+0x3c>
   else
      return (char)(val + 55);   /* converts 10-15 -> "A-F" */
 2047cc8:	e0bfff17 	ldw	r2,-4(fp)
 2047ccc:	10800dc4 	addi	r2,r2,55
}
 2047cd0:	e037883a 	mov	sp,fp
 2047cd4:	df000017 	ldw	fp,0(sp)
 2047cd8:	dec00104 	addi	sp,sp,4
 2047cdc:	f800283a 	ret

02047ce0 <inet_pton>:

char * pton_error = "";

int
inet_pton(int af, const char * src, void * dst)
{
 2047ce0:	defff804 	addi	sp,sp,-32
 2047ce4:	dfc00715 	stw	ra,28(sp)
 2047ce8:	df000615 	stw	fp,24(sp)
 2047cec:	df000604 	addi	fp,sp,24
 2047cf0:	e13ffd15 	stw	r4,-12(fp)
 2047cf4:	e17ffe15 	stw	r5,-8(fp)
 2047cf8:	e1bfff15 	stw	r6,-4(fp)
   int            words;   /* count of words written to dest */
#endif

#if defined(IP_V4) || defined(MINI_IP)
   /* RFC 2133 wants us to support both types of address */
   if(af == AF_INET)    /* wants a v4 address */
 2047cfc:	e0bffd17 	ldw	r2,-12(fp)
 2047d00:	10800098 	cmpnei	r2,r2,2
 2047d04:	1000151e 	bne	r2,zero,2047d5c <inet_pton+0x7c>
   {
      u_long ip4addr;
      unsigned sbits;
      char * err;
      
      err = parse_ipad(&ip4addr, &sbits, (char *) src);
 2047d08:	e0fffb04 	addi	r3,fp,-20
 2047d0c:	e0bffc04 	addi	r2,fp,-16
 2047d10:	1809883a 	mov	r4,r3
 2047d14:	100b883a 	mov	r5,r2
 2047d18:	e1bffe17 	ldw	r6,-8(fp)
 2047d1c:	20479380 	call	2047938 <parse_ipad>
 2047d20:	e0bffa15 	stw	r2,-24(fp)
      if(err == NULL)
 2047d24:	e0bffa17 	ldw	r2,-24(fp)
 2047d28:	1000071e 	bne	r2,zero,2047d48 <inet_pton+0x68>
      {
         /* copy the parsed address into caller's buffer, and 
          * return success
          */
         MEMCPY(dst, &ip4addr, sizeof (u_long));
 2047d2c:	e0bffb04 	addi	r2,fp,-20
 2047d30:	e13fff17 	ldw	r4,-4(fp)
 2047d34:	100b883a 	mov	r5,r2
 2047d38:	01800104 	movi	r6,4
 2047d3c:	200660c0 	call	200660c <memcpy>
         return 0;
 2047d40:	0005883a 	mov	r2,zero
 2047d44:	00000606 	br	2047d60 <inet_pton+0x80>
      }
      else
      {
         /* return failure */
         pton_error = "IPv4 address parse failure";
 2047d48:	00808174 	movhi	r2,517
 2047d4c:	10876f04 	addi	r2,r2,7612
 2047d50:	d0a05915 	stw	r2,-32412(gp)
         return 1;
 2047d54:	00800044 	movi	r2,1
 2047d58:	00000106 	br	2047d60 <inet_pton+0x80>
      pton_error = "too short - missing colon?";
      return 1;
   }
   
#endif /* IP_V6 */   
   return 0;
 2047d5c:	0005883a 	mov	r2,zero
}
 2047d60:	e037883a 	mov	sp,fp
 2047d64:	dfc00117 	ldw	ra,4(sp)
 2047d68:	df000017 	ldw	fp,0(sp)
 2047d6c:	dec00204 	addi	sp,sp,8
 2047d70:	f800283a 	ret

02047d74 <inet_ntop>:
 * address output (40 bytes).
 */

const char *
inet_ntop(int af, const void *addr, char *str, size_t size)
{
 2047d74:	defff804 	addi	sp,sp,-32
 2047d78:	dfc00715 	stw	ra,28(sp)
 2047d7c:	df000615 	stw	fp,24(sp)
 2047d80:	df000604 	addi	fp,sp,24
 2047d84:	e13ffc15 	stw	r4,-16(fp)
 2047d88:	e17ffd15 	stw	r5,-12(fp)
 2047d8c:	e1bffe15 	stw	r6,-8(fp)
 2047d90:	e1ffff15 	stw	r7,-4(fp)
   char *cp;

#if defined(IP_V4) || defined(MINI_IP)
   if (af == AF_INET)
 2047d94:	e0bffc17 	ldw	r2,-16(fp)
 2047d98:	10800098 	cmpnei	r2,r2,2
 2047d9c:	10000f1e 	bne	r2,zero,2047ddc <inet_ntop+0x68>
   {
      u_long   ip4addr;

      ip4addr = *(u_long*)addr;
 2047da0:	e0bffd17 	ldw	r2,-12(fp)
 2047da4:	10800017 	ldw	r2,0(r2)
 2047da8:	e0bffa15 	stw	r2,-24(fp)
      cp = print_ipad(ip4addr);
 2047dac:	e13ffa17 	ldw	r4,-24(fp)
 2047db0:	2026a400 	call	2026a40 <print_ipad>
 2047db4:	e0bffb15 	stw	r2,-20(fp)
      if (strlen(cp) < size)
 2047db8:	e13ffb17 	ldw	r4,-20(fp)
 2047dbc:	2007c640 	call	2007c64 <strlen>
 2047dc0:	e0ffff17 	ldw	r3,-4(fp)
 2047dc4:	10c0052e 	bgeu	r2,r3,2047ddc <inet_ntop+0x68>
      {
         strcpy(str, cp);
 2047dc8:	e13ffe17 	ldw	r4,-8(fp)
 2047dcc:	e17ffb17 	ldw	r5,-20(fp)
 2047dd0:	200756c0 	call	200756c <strcpy>
         return (str);
 2047dd4:	e0bffe17 	ldw	r2,-8(fp)
 2047dd8:	00000106 	br	2047de0 <inet_ntop+0x6c>
         return (str);
      }
   }
#endif

   return ((const char *)NULL);
 2047ddc:	0005883a 	mov	r2,zero
}
 2047de0:	e037883a 	mov	sp,fp
 2047de4:	dfc00117 	ldw	ra,4(sp)
 2047de8:	df000017 	ldw	fp,0(sp)
 2047dec:	dec00204 	addi	sp,sp,8
 2047df0:	f800283a 	ret

02047df4 <print46_addr>:
 *
 * RETURNS: Pointer to string with the address in readable format.
 */

char * print46_addr(struct sockaddr *ipaddr)
{
 2047df4:	defffc04 	addi	sp,sp,-16
 2047df8:	dfc00315 	stw	ra,12(sp)
 2047dfc:	df000215 	stw	fp,8(sp)
 2047e00:	df000204 	addi	fp,sp,8
 2047e04:	e13fff15 	stw	r4,-4(fp)
   if (ipaddr->sa_family == AF_INET)
 2047e08:	e0bfff17 	ldw	r2,-4(fp)
 2047e0c:	1080000b 	ldhu	r2,0(r2)
 2047e10:	10bfffcc 	andi	r2,r2,65535
 2047e14:	10800098 	cmpnei	r2,r2,2
 2047e18:	1000071e 	bne	r2,zero,2047e38 <print46_addr+0x44>
   {
      struct sockaddr_in * addr = (struct sockaddr_in *)ipaddr;
 2047e1c:	e0bfff17 	ldw	r2,-4(fp)
 2047e20:	e0bffe15 	stw	r2,-8(fp)
      return print_ipad(addr->sin_addr.s_addr);
 2047e24:	e0bffe17 	ldw	r2,-8(fp)
 2047e28:	10800117 	ldw	r2,4(r2)
 2047e2c:	1009883a 	mov	r4,r2
 2047e30:	2026a400 	call	2026a40 <print_ipad>
 2047e34:	00000106 	br	2047e3c <print46_addr+0x48>
      static char namebuf[46];  /* max len of IPv6 addr */
      return (char *)inet_ntop(AF_INET6,&addr->sin6_addr, namebuf, sizeof(namebuf));
   }
#endif

   return NULL;
 2047e38:	0005883a 	mov	r2,zero
}
 2047e3c:	e037883a 	mov	sp,fp
 2047e40:	dfc00117 	ldw	ra,4(sp)
 2047e44:	df000017 	ldw	fp,0(sp)
 2047e48:	dec00204 	addi	sp,sp,8
 2047e4c:	f800283a 	ret

02047e50 <inet46_addr>:
 *
 */

int 
inet46_addr(char * str, struct sockaddr *address)
{
 2047e50:	defffb04 	addi	sp,sp,-20
 2047e54:	dfc00415 	stw	ra,16(sp)
 2047e58:	df000315 	stw	fp,12(sp)
 2047e5c:	df000304 	addi	fp,sp,12
 2047e60:	e13ffe15 	stw	r4,-8(fp)
 2047e64:	e17fff15 	stw	r5,-4(fp)
   /* Read the IPv4/IPv6 address */
   address->sa_family = AF_INET; /* assume IPv4 address by default */
 2047e68:	e0bfff17 	ldw	r2,-4(fp)
 2047e6c:	00c00084 	movi	r3,2
 2047e70:	10c0000d 	sth	r3,0(r2)

   if ((str[1] == '.') || (str[2] == '.') || (str[3] == '.'))
 2047e74:	e0bffe17 	ldw	r2,-8(fp)
 2047e78:	10800044 	addi	r2,r2,1
 2047e7c:	10800003 	ldbu	r2,0(r2)
 2047e80:	10803fcc 	andi	r2,r2,255
 2047e84:	1080201c 	xori	r2,r2,128
 2047e88:	10bfe004 	addi	r2,r2,-128
 2047e8c:	10800ba0 	cmpeqi	r2,r2,46
 2047e90:	1000101e 	bne	r2,zero,2047ed4 <inet46_addr+0x84>
 2047e94:	e0bffe17 	ldw	r2,-8(fp)
 2047e98:	10800084 	addi	r2,r2,2
 2047e9c:	10800003 	ldbu	r2,0(r2)
 2047ea0:	10803fcc 	andi	r2,r2,255
 2047ea4:	1080201c 	xori	r2,r2,128
 2047ea8:	10bfe004 	addi	r2,r2,-128
 2047eac:	10800ba0 	cmpeqi	r2,r2,46
 2047eb0:	1000081e 	bne	r2,zero,2047ed4 <inet46_addr+0x84>
 2047eb4:	e0bffe17 	ldw	r2,-8(fp)
 2047eb8:	108000c4 	addi	r2,r2,3
 2047ebc:	10800003 	ldbu	r2,0(r2)
 2047ec0:	10803fcc 	andi	r2,r2,255
 2047ec4:	1080201c 	xori	r2,r2,128
 2047ec8:	10bfe004 	addi	r2,r2,-128
 2047ecc:	10800b98 	cmpnei	r2,r2,46
 2047ed0:	1000091e 	bne	r2,zero,2047ef8 <inet46_addr+0xa8>
   {
      struct sockaddr_in *addr = (struct sockaddr_in *)address;
 2047ed4:	e0bfff17 	ldw	r2,-4(fp)
 2047ed8:	e0bffd15 	stw	r2,-12(fp)
      addr->sin_addr.s_addr = inet_addr(str);
 2047edc:	e13ffe17 	ldw	r4,-8(fp)
 2047ee0:	2047c340 	call	2047c34 <inet_addr>
 2047ee4:	e0fffd17 	ldw	r3,-12(fp)
 2047ee8:	18800115 	stw	r2,4(r3)
      addr->sin_family = AF_INET;
 2047eec:	e0bffd17 	ldw	r2,-12(fp)
 2047ef0:	00c00084 	movi	r3,2
 2047ef4:	10c0000d 	sth	r3,0(r2)
      inet_pton(AF_INET6, str, &addr->sin6_addr);
      addr->sin6_family = AF_INET6;
   }
#endif

   return 0;
 2047ef8:	0005883a 	mov	r2,zero
}
 2047efc:	e037883a 	mov	sp,fp
 2047f00:	dfc00117 	ldw	ra,4(sp)
 2047f04:	df000017 	ldw	fp,0(sp)
 2047f08:	dec00204 	addi	sp,sp,8
 2047f0c:	f800283a 	ret

02047f10 <inet_setport>:
 *
 * RETURNS: -
 */

void inet_setport(struct sockaddr *addr,int port) 
{
 2047f10:	defffc04 	addi	sp,sp,-16
 2047f14:	df000315 	stw	fp,12(sp)
 2047f18:	df000304 	addi	fp,sp,12
 2047f1c:	e13ffe15 	stw	r4,-8(fp)
 2047f20:	e17fff15 	stw	r5,-4(fp)
   if (addr->sa_family == AF_INET)
 2047f24:	e0bffe17 	ldw	r2,-8(fp)
 2047f28:	1080000b 	ldhu	r2,0(r2)
 2047f2c:	10bfffcc 	andi	r2,r2,65535
 2047f30:	10800098 	cmpnei	r2,r2,2
 2047f34:	10000c1e 	bne	r2,zero,2047f68 <inet_setport+0x58>
   {
      struct sockaddr_in *si = (struct sockaddr_in *)addr;
 2047f38:	e0bffe17 	ldw	r2,-8(fp)
 2047f3c:	e0bffd15 	stw	r2,-12(fp)
      si->sin_port = htons(port);  
 2047f40:	e0bfff17 	ldw	r2,-4(fp)
 2047f44:	1005d23a 	srai	r2,r2,8
 2047f48:	10803fcc 	andi	r2,r2,255
 2047f4c:	1007883a 	mov	r3,r2
 2047f50:	e0bfff17 	ldw	r2,-4(fp)
 2047f54:	1004923a 	slli	r2,r2,8
 2047f58:	1884b03a 	or	r2,r3,r2
 2047f5c:	1007883a 	mov	r3,r2
 2047f60:	e0bffd17 	ldw	r2,-12(fp)
 2047f64:	10c0008d 	sth	r3,2(r2)
      struct sockaddr_in6 *si = (struct sockaddr_in6 *)addr;
      si->sin6_port = htons(port);
   }
#endif

}
 2047f68:	e037883a 	mov	sp,fp
 2047f6c:	df000017 	ldw	fp,0(sp)
 2047f70:	dec00104 	addi	sp,sp,4
 2047f74:	f800283a 	ret

02047f78 <convert_ip>:
 *Returns:
 *
 */

unsigned long convert_ip(const char *p)
{
 2047f78:	defff904 	addi	sp,sp,-28
 2047f7c:	df000615 	stw	fp,24(sp)
 2047f80:	df000604 	addi	fp,sp,24
 2047f84:	e13fff15 	stw	r4,-4(fp)
   const char *cp = p;
 2047f88:	e0bfff17 	ldw	r2,-4(fp)
 2047f8c:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
 2047f90:	e0bffe04 	addi	r2,fp,-8
 2047f94:	e0bffd15 	stw	r2,-12(fp)
   int n = 0;
 2047f98:	e03ffb15 	stw	zero,-20(fp)
   unsigned short v = 0;
 2047f9c:	e03ffc0d 	sth	zero,-16(fp)
   dw = 0;
 2047fa0:	e03ffe15 	stw	zero,-8(fp)
   while(*cp)
 2047fa4:	00003106 	br	204806c <convert_ip+0xf4>
   {
      if( *cp == '.')
 2047fa8:	e0bffa17 	ldw	r2,-24(fp)
 2047fac:	10800003 	ldbu	r2,0(r2)
 2047fb0:	10803fcc 	andi	r2,r2,255
 2047fb4:	1080201c 	xori	r2,r2,128
 2047fb8:	10bfe004 	addi	r2,r2,-128
 2047fbc:	10800b98 	cmpnei	r2,r2,46
 2047fc0:	10000e1e 	bne	r2,zero,2047ffc <convert_ip+0x84>
      {
         lpb[n] = (unsigned char) v;
 2047fc4:	e0bffb17 	ldw	r2,-20(fp)
 2047fc8:	e0fffd17 	ldw	r3,-12(fp)
 2047fcc:	1885883a 	add	r2,r3,r2
 2047fd0:	e0fffc0b 	ldhu	r3,-16(fp)
 2047fd4:	10c00005 	stb	r3,0(r2)
         v = 0;
 2047fd8:	e03ffc0d 	sth	zero,-16(fp)
         n++;
 2047fdc:	e0bffb17 	ldw	r2,-20(fp)
 2047fe0:	10800044 	addi	r2,r2,1
 2047fe4:	e0bffb15 	stw	r2,-20(fp)
         if(n > 3)
 2047fe8:	e0bffb17 	ldw	r2,-20(fp)
 2047fec:	10800110 	cmplti	r2,r2,4
 2047ff0:	10001b1e 	bne	r2,zero,2048060 <convert_ip+0xe8>
         {
            return dw;
 2047ff4:	e0bffe17 	ldw	r2,-8(fp)
 2047ff8:	00002806 	br	204809c <convert_ip+0x124>
         }
      }
      else if(((*cp >= '0') && (*cp <= '9')))
 2047ffc:	e0bffa17 	ldw	r2,-24(fp)
 2048000:	10800003 	ldbu	r2,0(r2)
 2048004:	10803fcc 	andi	r2,r2,255
 2048008:	1080201c 	xori	r2,r2,128
 204800c:	10bfe004 	addi	r2,r2,-128
 2048010:	10800c10 	cmplti	r2,r2,48
 2048014:	1000121e 	bne	r2,zero,2048060 <convert_ip+0xe8>
 2048018:	e0bffa17 	ldw	r2,-24(fp)
 204801c:	10800003 	ldbu	r2,0(r2)
 2048020:	10803fcc 	andi	r2,r2,255
 2048024:	1080201c 	xori	r2,r2,128
 2048028:	10bfe004 	addi	r2,r2,-128
 204802c:	10800e88 	cmpgei	r2,r2,58
 2048030:	10000b1e 	bne	r2,zero,2048060 <convert_ip+0xe8>
      {
         v = (v * 10) + (*cp - '0');
 2048034:	e0bffc0b 	ldhu	r2,-16(fp)
 2048038:	108002a4 	muli	r2,r2,10
 204803c:	1007883a 	mov	r3,r2
 2048040:	e0bffa17 	ldw	r2,-24(fp)
 2048044:	10800003 	ldbu	r2,0(r2)
 2048048:	10803fcc 	andi	r2,r2,255
 204804c:	1080201c 	xori	r2,r2,128
 2048050:	10bfe004 	addi	r2,r2,-128
 2048054:	1885883a 	add	r2,r3,r2
 2048058:	10bff404 	addi	r2,r2,-48
 204805c:	e0bffc0d 	sth	r2,-16(fp)
      }
      cp++;
 2048060:	e0bffa17 	ldw	r2,-24(fp)
 2048064:	10800044 	addi	r2,r2,1
 2048068:	e0bffa15 	stw	r2,-24(fp)
   unsigned long dw;
   unsigned char *lpb = (unsigned char *) &dw;
   int n = 0;
   unsigned short v = 0;
   dw = 0;
   while(*cp)
 204806c:	e0bffa17 	ldw	r2,-24(fp)
 2048070:	10800003 	ldbu	r2,0(r2)
 2048074:	10803fcc 	andi	r2,r2,255
 2048078:	1080201c 	xori	r2,r2,128
 204807c:	10bfe004 	addi	r2,r2,-128
 2048080:	103fc91e 	bne	r2,zero,2047fa8 <convert_ip+0x30>
      {
         v = (v * 10) + (*cp - '0');
      }
      cp++;
   }
   lpb[n] = (unsigned char) v;
 2048084:	e0bffb17 	ldw	r2,-20(fp)
 2048088:	e0fffd17 	ldw	r3,-12(fp)
 204808c:	1885883a 	add	r2,r3,r2
 2048090:	e0fffc0b 	ldhu	r3,-16(fp)
 2048094:	10c00005 	stb	r3,0(r2)
   return dw;
 2048098:	e0bffe17 	ldw	r2,-8(fp)
}  /* convert_ip() */
 204809c:	e037883a 	mov	sp,fp
 20480a0:	df000017 	ldw	fp,0(sp)
 20480a4:	dec00104 	addi	sp,sp,4
 20480a8:	f800283a 	ret

020480ac <tcp_cksum>:
 * RETURNS: 
 */

unshort
tcp_cksum(struct ip * pip)
{
 20480ac:	defff704 	addi	sp,sp,-36
 20480b0:	dfc00815 	stw	ra,32(sp)
 20480b4:	df000715 	stw	fp,28(sp)
 20480b8:	df000704 	addi	fp,sp,28
 20480bc:	e13fff15 	stw	r4,-4(fp)
   unshort  oldsum;
   unshort  newsum;
   struct tcphdr * tp;

#ifdef MUTE_WARNS    /* stifle compiler warnings */
   tcpdata = (char *)NULL;
 20480c0:	e03ffa15 	stw	zero,-24(fp)
#endif   /* MUTE_WARNS */

   IN_PROFILER(PF_TSUM, PF_ENTRY);

   oddchar = 0;
 20480c4:	e03ffb05 	stb	zero,-20(fp)

   iphlen = (unshort)ip_hlen(pip);
 20480c8:	e0bfff17 	ldw	r2,-4(fp)
 20480cc:	10800003 	ldbu	r2,0(r2)
 20480d0:	10803fcc 	andi	r2,r2,255
 20480d4:	108003cc 	andi	r2,r2,15
 20480d8:	1085883a 	add	r2,r2,r2
 20480dc:	1085883a 	add	r2,r2,r2
 20480e0:	e0bffc0d 	sth	r2,-16(fp)
   tcplen = htons(pip->ip_len) - iphlen;
 20480e4:	e0bfff17 	ldw	r2,-4(fp)
 20480e8:	1080008b 	ldhu	r2,2(r2)
 20480ec:	10bfffcc 	andi	r2,r2,65535
 20480f0:	1004d23a 	srli	r2,r2,8
 20480f4:	1007883a 	mov	r3,r2
 20480f8:	e0bfff17 	ldw	r2,-4(fp)
 20480fc:	1080008b 	ldhu	r2,2(r2)
 2048100:	10bfffcc 	andi	r2,r2,65535
 2048104:	1004923a 	slli	r2,r2,8
 2048108:	1884b03a 	or	r2,r3,r2
 204810c:	1007883a 	mov	r3,r2
 2048110:	e0bffc0b 	ldhu	r2,-16(fp)
 2048114:	1885c83a 	sub	r2,r3,r2
 2048118:	e0bff90d 	sth	r2,-28(fp)

   tp = (struct tcphdr*)ip_data(pip);     /* get TCP header */
 204811c:	e0bfff17 	ldw	r2,-4(fp)
 2048120:	10800003 	ldbu	r2,0(r2)
 2048124:	10803fcc 	andi	r2,r2,255
 2048128:	108003cc 	andi	r2,r2,15
 204812c:	1085883a 	add	r2,r2,r2
 2048130:	1085883a 	add	r2,r2,r2
 2048134:	e0ffff17 	ldw	r3,-4(fp)
 2048138:	1885883a 	add	r2,r3,r2
 204813c:	e0bffd15 	stw	r2,-12(fp)
   oldsum = tp->th_sum;       /* Save passed checksum */
 2048140:	e0bffd17 	ldw	r2,-12(fp)
 2048144:	1080040b 	ldhu	r2,16(r2)
 2048148:	e0bffe0d 	sth	r2,-8(fp)
    * cannot overflow a 16 bit field) and put them in the cksum field. 
    * We include the IP addresses by passing them to the lower level 
    * fast sum routine. This results in their values being factored into 
    * the sum and the cksum field contributes zero.
    */
   tp->th_sum = htons(tcplen + 6);
 204814c:	e0bff90b 	ldhu	r2,-28(fp)
 2048150:	10800184 	addi	r2,r2,6
 2048154:	1005d23a 	srai	r2,r2,8
 2048158:	10803fcc 	andi	r2,r2,255
 204815c:	1007883a 	mov	r3,r2
 2048160:	e0bff90b 	ldhu	r2,-28(fp)
 2048164:	10800184 	addi	r2,r2,6
 2048168:	1004923a 	slli	r2,r2,8
 204816c:	1884b03a 	or	r2,r3,r2
 2048170:	1007883a 	mov	r3,r2
 2048174:	e0bffd17 	ldw	r2,-12(fp)
 2048178:	10c0040d 	sth	r3,16(r2)

   /* zero pad odd sized packets for checksumming */
   if (tcplen & 1)   
 204817c:	e0bff90b 	ldhu	r2,-28(fp)
 2048180:	1080004c 	andi	r2,r2,1
 2048184:	10000e26 	beq	r2,zero,20481c0 <tcp_cksum+0x114>
   {
      tcpdata = ((char*)pip) + iphlen + tcplen;    /* end of packet */
 2048188:	e0fffc0b 	ldhu	r3,-16(fp)
 204818c:	e0bff90b 	ldhu	r2,-28(fp)
 2048190:	1885883a 	add	r2,r3,r2
 2048194:	e0ffff17 	ldw	r3,-4(fp)
 2048198:	1885883a 	add	r2,r3,r2
 204819c:	e0bffa15 	stw	r2,-24(fp)
      oddchar = *tcpdata;
 20481a0:	e0bffa17 	ldw	r2,-24(fp)
 20481a4:	10800003 	ldbu	r2,0(r2)
 20481a8:	e0bffb05 	stb	r2,-20(fp)
      *tcpdata = '\0';        /* zero out pad byte */
 20481ac:	e0bffa17 	ldw	r2,-24(fp)
 20481b0:	10000005 	stb	zero,0(r2)
      tcplen++;               /* bump length to pass to cksum() */
 20481b4:	e0bff90b 	ldhu	r2,-28(fp)
 20481b8:	10800044 	addi	r2,r2,1
 20481bc:	e0bff90d 	sth	r2,-28(fp)

   /* Pass a pointer to the beginning of the IP address area into the IP header
    * the the low level sum routine. Add the size of these two IP addresses to
    * the length, and convert the length to 16 bit words.
    */
   newsum = ~cksum(((char*)tp) - 8, (tcplen + 8) >> 1);
 20481c0:	e0bffd17 	ldw	r2,-12(fp)
 20481c4:	10fffe04 	addi	r3,r2,-8
 20481c8:	e0bff90b 	ldhu	r2,-28(fp)
 20481cc:	10800204 	addi	r2,r2,8
 20481d0:	1005d07a 	srai	r2,r2,1
 20481d4:	1809883a 	mov	r4,r3
 20481d8:	100b883a 	mov	r5,r2
 20481dc:	20268040 	call	2026804 <cksum>
 20481e0:	0084303a 	nor	r2,zero,r2
 20481e4:	e0bffb8d 	sth	r2,-18(fp)

   /* If the old checksum is 0xffff, but the actual checksum is 0x0000,
    * declare that to be a match.
    */
   if ((newsum != oldsum) && (oldsum == 0xffff) && (newsum == 0x0000))
 20481e8:	e0fffb8b 	ldhu	r3,-18(fp)
 20481ec:	e0bffe0b 	ldhu	r2,-8(fp)
 20481f0:	18800726 	beq	r3,r2,2048210 <tcp_cksum+0x164>
 20481f4:	e0fffe0b 	ldhu	r3,-8(fp)
 20481f8:	00bfffd4 	movui	r2,65535
 20481fc:	1880041e 	bne	r3,r2,2048210 <tcp_cksum+0x164>
 2048200:	e0bffb8b 	ldhu	r2,-18(fp)
 2048204:	1000021e 	bne	r2,zero,2048210 <tcp_cksum+0x164>
      newsum = 0xffff;
 2048208:	00bfffc4 	movi	r2,-1
 204820c:	e0bffb8d 	sth	r2,-18(fp)

   /* restore what we clobbered */
   tp->th_sum = oldsum;       /* put back passed checksum */
 2048210:	e0bffd17 	ldw	r2,-12(fp)
 2048214:	e0fffe0b 	ldhu	r3,-8(fp)
 2048218:	10c0040d 	sth	r3,16(r2)
   if (oddchar)
 204821c:	e0bffb07 	ldb	r2,-20(fp)
 2048220:	10000326 	beq	r2,zero,2048230 <tcp_cksum+0x184>
      *tcpdata = oddchar;     /* restore odd byte if we zeroed it */
 2048224:	e0bffa17 	ldw	r2,-24(fp)
 2048228:	e0fffb03 	ldbu	r3,-20(fp)
 204822c:	10c00005 	stb	r3,0(r2)

   IN_PROFILER(PF_TSUM, PF_EXIT);

   return newsum;
 2048230:	e0bffb8b 	ldhu	r2,-18(fp)
}
 2048234:	e037883a 	mov	sp,fp
 2048238:	dfc00117 	ldw	ra,4(sp)
 204823c:	df000017 	ldw	fp,0(sp)
 2048240:	dec00204 	addi	sp,sp,8
 2048244:	f800283a 	ret

02048248 <udp_open>:
   ip_addr  fhost,      /* foreign host, 0L for any */
   unshort  fsock,      /* foreign socket, 0 for any */
   unshort  lsock,      /* local socket */
   int (*handler)(PACKET, void*),   /* rcv upcall */
   void *   data)       /* random data, returned on upcalls to aid demuxing */
{
 2048248:	defff404 	addi	sp,sp,-48
 204824c:	dfc00b15 	stw	ra,44(sp)
 2048250:	df000a15 	stw	fp,40(sp)
 2048254:	df000a04 	addi	fp,sp,40
 2048258:	e13ffc15 	stw	r4,-16(fp)
 204825c:	2807883a 	mov	r3,r5
 2048260:	3005883a 	mov	r2,r6
 2048264:	e1ffff15 	stw	r7,-4(fp)
 2048268:	e0fffd0d 	sth	r3,-12(fp)
 204826c:	e0bffe0d 	sth	r2,-8(fp)
/*
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
 2048270:	00808174 	movhi	r2,517
 2048274:	1090b204 	addi	r2,r2,17096
 2048278:	10800017 	ldw	r2,0(r2)
 204827c:	1080010c 	andi	r2,r2,4
 2048280:	10001626 	beq	r2,zero,20482dc <udp_open+0x94>
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 2048284:	e0bffc17 	ldw	r2,-16(fp)
 2048288:	11403fcc 	andi	r5,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 204828c:	e0bffc17 	ldw	r2,-16(fp)
 2048290:	1004d23a 	srli	r2,r2,8
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 2048294:	10c03fcc 	andi	r3,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 2048298:	e0bffc17 	ldw	r2,-16(fp)
 204829c:	1004d43a 	srli	r2,r2,16
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 20482a0:	10803fcc 	andi	r2,r2,255
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
 20482a4:	e13ffc17 	ldw	r4,-16(fp)
 20482a8:	2010d63a 	srli	r8,r4,24
 * Altera Niche Stack Nios port modification:
 * cast 'data' to remove build warning
 */
#ifdef   NPDEBUG
   if (NDEBUG & INFOMSG)
      dprintf("udp_open: host %u.%u.%u.%u, lsock %u, fsock %u, foo %04x\n",
 20482ac:	e1fffe0b 	ldhu	r7,-8(fp)
 20482b0:	e1bffd0b 	ldhu	r6,-12(fp)
 20482b4:	e1000217 	ldw	r4,8(fp)
 20482b8:	da000015 	stw	r8,0(sp)
 20482bc:	d9c00115 	stw	r7,4(sp)
 20482c0:	d9800215 	stw	r6,8(sp)
 20482c4:	d9000315 	stw	r4,12(sp)
 20482c8:	01008174 	movhi	r4,517
 20482cc:	21077604 	addi	r4,r4,7640
 20482d0:	180d883a 	mov	r6,r3
 20482d4:	100f883a 	mov	r7,r2
 20482d8:	2006a240 	call	2006a24 <printf>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
 20482dc:	0009883a 	mov	r4,zero
 20482e0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   ocon = NULL;
 20482e4:	e03ffb15 	stw	zero,-20(fp)
   for (con = firstudp; con; con = con->u_next)
 20482e8:	d0a0c817 	ldw	r2,-31968(gp)
 20482ec:	e0bffa15 	stw	r2,-24(fp)
 20482f0:	00002206 	br	204837c <udp_open+0x134>
   {
      ocon = con;       /* remember last con in list */
 20482f4:	e0bffa17 	ldw	r2,-24(fp)
 20482f8:	e0bffb15 	stw	r2,-20(fp)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 20482fc:	e0bffa17 	ldw	r2,-24(fp)
 2048300:	1080018b 	ldhu	r2,6(r2)
 2048304:	10ffffcc 	andi	r3,r2,65535
 2048308:	e0bffe0b 	ldhu	r2,-8(fp)
 204830c:	1880181e 	bne	r3,r2,2048370 <udp_open+0x128>
 2048310:	e0bffa17 	ldw	r2,-24(fp)
 2048314:	1080020b 	ldhu	r2,8(r2)
 2048318:	10ffffcc 	andi	r3,r2,65535
 204831c:	e0bffd0b 	ldhu	r2,-12(fp)
 2048320:	1880131e 	bne	r3,r2,2048370 <udp_open+0x128>
          con->u_lhost == 0 && con->u_fhost == fhost)
 2048324:	e0bffa17 	ldw	r2,-24(fp)
 2048328:	10800317 	ldw	r2,12(r2)
      /* we only want to check UDP-over-IPv4 connections */
      if (!(con->u_flags & UDPCF_V4))
         continue;
#endif

      if (con->u_lport == lsock && con->u_fport == fsock &&
 204832c:	1000101e 	bne	r2,zero,2048370 <udp_open+0x128>
          con->u_lhost == 0 && con->u_fhost == fhost)
 2048330:	e0bffa17 	ldw	r2,-24(fp)
 2048334:	10c00417 	ldw	r3,16(r2)
 2048338:	e0bffc17 	ldw	r2,-16(fp)
 204833c:	18800c1e 	bne	r3,r2,2048370 <udp_open+0x128>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (INFOMSG|PROTERR))
 2048340:	00808174 	movhi	r2,517
 2048344:	1090b204 	addi	r2,r2,17096
 2048348:	10800017 	ldw	r2,0(r2)
 204834c:	1080050c 	andi	r2,r2,20
 2048350:	10000326 	beq	r2,zero,2048360 <udp_open+0x118>
            dprintf("UDP: Connection already exists.\n");
 2048354:	01008174 	movhi	r4,517
 2048358:	21078504 	addi	r4,r4,7700
 204835c:	2006cb40 	call	2006cb4 <puts>
#endif
         UNLOCK_NET_RESOURCE(NET_RESID);
 2048360:	0009883a 	mov	r4,zero
 2048364:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
         return(NULL);
 2048368:	0005883a 	mov	r2,zero
 204836c:	00003706 	br	204844c <udp_open+0x204>
    PUSH_IPADDR(fhost),lsock, fsock, (unsigned int)data);
#endif

   LOCK_NET_RESOURCE(NET_RESID);
   ocon = NULL;
   for (con = firstudp; con; con = con->u_next)
 2048370:	e0bffa17 	ldw	r2,-24(fp)
 2048374:	10800017 	ldw	r2,0(r2)
 2048378:	e0bffa15 	stw	r2,-24(fp)
 204837c:	e0bffa17 	ldw	r2,-24(fp)
 2048380:	103fdc1e 	bne	r2,zero,20482f4 <udp_open+0xac>
         UNLOCK_NET_RESOURCE(NET_RESID);
         return(NULL);
      }
   }

   con = (UDPCONN)UC_ALLOC(sizeof(struct udp_conn));
 2048384:	01000804 	movi	r4,32
 2048388:	20290400 	call	2029040 <npalloc>
 204838c:	e0bffa15 	stw	r2,-24(fp)
   if (con == 0)
 2048390:	e0bffa17 	ldw	r2,-24(fp)
 2048394:	10000c1e 	bne	r2,zero,20483c8 <udp_open+0x180>
   {
#ifdef   NPDEBUG
      if (NDEBUG & INFOMSG)
 2048398:	00808174 	movhi	r2,517
 204839c:	1090b204 	addi	r2,r2,17096
 20483a0:	10800017 	ldw	r2,0(r2)
 20483a4:	1080010c 	andi	r2,r2,4
 20483a8:	10000326 	beq	r2,zero,20483b8 <udp_open+0x170>
         dprintf("UDP: Couldn't allocate conn storage.\n");
 20483ac:	01008174 	movhi	r4,517
 20483b0:	21078d04 	addi	r4,r4,7732
 20483b4:	2006cb40 	call	2006cb4 <puts>
#endif
      UNLOCK_NET_RESOURCE(NET_RESID);
 20483b8:	0009883a 	mov	r4,zero
 20483bc:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return(NULL);
 20483c0:	0005883a 	mov	r2,zero
 20483c4:	00002106 	br	204844c <udp_open+0x204>
   }

   if (ocon)   /* ocon is end of list */
 20483c8:	e0bffb17 	ldw	r2,-20(fp)
 20483cc:	10000426 	beq	r2,zero,20483e0 <udp_open+0x198>
      ocon->u_next = con;  /* add new connection to end */
 20483d0:	e0bffb17 	ldw	r2,-20(fp)
 20483d4:	e0fffa17 	ldw	r3,-24(fp)
 20483d8:	10c00015 	stw	r3,0(r2)
 20483dc:	00000206 	br	20483e8 <udp_open+0x1a0>
   else  /* no list, start one */
      firstudp = con;
 20483e0:	e0bffa17 	ldw	r2,-24(fp)
 20483e4:	d0a0c815 	stw	r2,-31968(gp)

   con->u_next = 0;
 20483e8:	e0bffa17 	ldw	r2,-24(fp)
 20483ec:	10000015 	stw	zero,0(r2)

   con->u_lport = lsock;      /* fill in connection info */
 20483f0:	e0bffa17 	ldw	r2,-24(fp)
 20483f4:	e0fffe0b 	ldhu	r3,-8(fp)
 20483f8:	10c0018d 	sth	r3,6(r2)
   con->u_fport = fsock;
 20483fc:	e0bffa17 	ldw	r2,-24(fp)
 2048400:	e0fffd0b 	ldhu	r3,-12(fp)
 2048404:	10c0020d 	sth	r3,8(r2)
   con->u_lhost = 0;
 2048408:	e0bffa17 	ldw	r2,-24(fp)
 204840c:	10000315 	stw	zero,12(r2)
   con->u_fhost = fhost;
 2048410:	e0bffa17 	ldw	r2,-24(fp)
 2048414:	e0fffc17 	ldw	r3,-16(fp)
 2048418:	10c00415 	stw	r3,16(r2)
   con->u_rcv   = handler;
 204841c:	e0bffa17 	ldw	r2,-24(fp)
 2048420:	e0ffff17 	ldw	r3,-4(fp)
 2048424:	10c00515 	stw	r3,20(r2)
   con->u_data  = data;
 2048428:	e0bffa17 	ldw	r2,-24(fp)
 204842c:	e0c00217 	ldw	r3,8(fp)
 2048430:	10c00615 	stw	r3,24(r2)
   con->u_flags = UDPCF_V4;
 2048434:	e0bffa17 	ldw	r2,-24(fp)
 2048438:	00c00044 	movi	r3,1
 204843c:	10c0010d 	sth	r3,4(r2)

   UNLOCK_NET_RESOURCE(NET_RESID);
 2048440:	0009883a 	mov	r4,zero
 2048444:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
   return(con);
 2048448:	e0bffa17 	ldw	r2,-24(fp)
}
 204844c:	e037883a 	mov	sp,fp
 2048450:	dfc00117 	ldw	ra,4(sp)
 2048454:	df000017 	ldw	fp,0(sp)
 2048458:	dec00204 	addi	sp,sp,8
 204845c:	f800283a 	ret

02048460 <udp_close>:
 * RETURNS: void
 */

void
udp_close(UDPCONN con)
{
 2048460:	defffb04 	addi	sp,sp,-20
 2048464:	dfc00415 	stw	ra,16(sp)
 2048468:	df000315 	stw	fp,12(sp)
 204846c:	df000304 	addi	fp,sp,12
 2048470:	e13fff15 	stw	r4,-4(fp)
   UDPCONN pcon;
   UDPCONN lcon;

#ifdef NPDEBUG
   if ((con == NULL) || (firstudp == NULL))
 2048474:	e0bfff17 	ldw	r2,-4(fp)
 2048478:	10000226 	beq	r2,zero,2048484 <udp_close+0x24>
 204847c:	d0a0c817 	ldw	r2,-31968(gp)
 2048480:	1000021e 	bne	r2,zero,204848c <udp_close+0x2c>
   {
      dtrap(); /* bad programming! */
 2048484:	20285c80 	call	20285c8 <dtrap>
      return;
 2048488:	00002606 	br	2048524 <udp_close+0xc4>
   }
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
 204848c:	0009883a 	mov	r4,zero
 2048490:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
 2048494:	e03ffe15 	stw	zero,-8(fp)
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 2048498:	d0a0c817 	ldw	r2,-31968(gp)
 204849c:	e0bffd15 	stw	r2,-12(fp)
 20484a0:	00000806 	br	20484c4 <udp_close+0x64>
   {
      if (pcon == con)  /* found connection to delete */
 20484a4:	e0fffd17 	ldw	r3,-12(fp)
 20484a8:	e0bfff17 	ldw	r2,-4(fp)
 20484ac:	18800826 	beq	r3,r2,20484d0 <udp_close+0x70>
      break;
      lcon = pcon;   /* remember last connection */
 20484b0:	e0bffd17 	ldw	r2,-12(fp)
 20484b4:	e0bffe15 	stw	r2,-8(fp)
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(NET_RESID);
   /* find connection in list and unlink it */
   lcon = NULL;   /* clear ptr to last connection */
   for (pcon = firstudp; pcon; pcon = pcon->u_next)
 20484b8:	e0bffd17 	ldw	r2,-12(fp)
 20484bc:	10800017 	ldw	r2,0(r2)
 20484c0:	e0bffd15 	stw	r2,-12(fp)
 20484c4:	e0bffd17 	ldw	r2,-12(fp)
 20484c8:	103ff61e 	bne	r2,zero,20484a4 <udp_close+0x44>
 20484cc:	00000106 	br	20484d4 <udp_close+0x74>
   {
      if (pcon == con)  /* found connection to delete */
      break;
 20484d0:	0001883a 	nop
      lcon = pcon;   /* remember last connection */
   }

   if (!pcon)
 20484d4:	e0bffd17 	ldw	r2,-12(fp)
 20484d8:	1000041e 	bne	r2,zero,20484ec <udp_close+0x8c>
   {
      dtrap(); /* prog error - connenction not in list */
 20484dc:	20285c80 	call	20285c8 <dtrap>
      UNLOCK_NET_RESOURCE(NET_RESID);
 20484e0:	0009883a 	mov	r4,zero
 20484e4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return;
 20484e8:	00000e06 	br	2048524 <udp_close+0xc4>
   }

   if (lcon)   /* in con is not head of list */
 20484ec:	e0bffe17 	ldw	r2,-8(fp)
 20484f0:	10000526 	beq	r2,zero,2048508 <udp_close+0xa8>
      lcon->u_next = con->u_next;   /* unlink */
 20484f4:	e0bfff17 	ldw	r2,-4(fp)
 20484f8:	10c00017 	ldw	r3,0(r2)
 20484fc:	e0bffe17 	ldw	r2,-8(fp)
 2048500:	10c00015 	stw	r3,0(r2)
 2048504:	00000306 	br	2048514 <udp_close+0xb4>
   else
      firstudp = con->u_next; /* remove from head */
 2048508:	e0bfff17 	ldw	r2,-4(fp)
 204850c:	10800017 	ldw	r2,0(r2)
 2048510:	d0a0c815 	stw	r2,-31968(gp)

   UC_FREE(con);  /* free memory for structure */
 2048514:	e13fff17 	ldw	r4,-4(fp)
 2048518:	202912c0 	call	202912c <npfree>
   UNLOCK_NET_RESOURCE(NET_RESID);
 204851c:	0009883a 	mov	r4,zero
 2048520:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
}
 2048524:	e037883a 	mov	sp,fp
 2048528:	dfc00117 	ldw	ra,4(sp)
 204852c:	df000017 	ldw	fp,0(sp)
 2048530:	dec00204 	addi	sp,sp,8
 2048534:	f800283a 	ret

02048538 <in_pcballoc>:
 */

int
in_pcballoc(struct socket * so, 
   struct inpcb * head)
{
 2048538:	defffb04 	addi	sp,sp,-20
 204853c:	dfc00415 	stw	ra,16(sp)
 2048540:	df000315 	stw	fp,12(sp)
 2048544:	df000304 	addi	fp,sp,12
 2048548:	e13ffe15 	stw	r4,-8(fp)
 204854c:	e17fff15 	stw	r5,-4(fp)
   struct inpcb * inp;

   inp = INP_ALLOC (sizeof (*inp));
 2048550:	01000b04 	movi	r4,44
 2048554:	20290400 	call	2029040 <npalloc>
 2048558:	e0bffd15 	stw	r2,-12(fp)
   if (inp == 0)
 204855c:	e0bffd17 	ldw	r2,-12(fp)
 2048560:	1000021e 	bne	r2,zero,204856c <in_pcballoc+0x34>
      return ENOMEM;
 2048564:	00800304 	movi	r2,12
 2048568:	00001006 	br	20485ac <in_pcballoc+0x74>
   inp->inp_head = head;
 204856c:	e0bffd17 	ldw	r2,-12(fp)
 2048570:	e0ffff17 	ldw	r3,-4(fp)
 2048574:	10c00215 	stw	r3,8(r2)
   inp->inp_socket = so;
 2048578:	e0bffd17 	ldw	r2,-12(fp)
 204857c:	e0fffe17 	ldw	r3,-8(fp)
 2048580:	10c00815 	stw	r3,32(r2)

   /* Set Path MTU to a very small default. It should get expanded 
    * later by v4 or v6 specific SYN code. We don't want it zero 
    * in case it doesn't get expanded promptly.
    */
   inp->inp_pmtu = 512;
 2048584:	e0bffd17 	ldw	r2,-12(fp)
 2048588:	00c08004 	movi	r3,512
 204858c:	10c00615 	stw	r3,24(r2)
   insque(inp, head);
 2048590:	e13ffd17 	ldw	r4,-12(fp)
 2048594:	e17fff17 	ldw	r5,-4(fp)
 2048598:	2029cd80 	call	2029cd8 <insque>
   so->so_pcb = inp;
 204859c:	e0bffe17 	ldw	r2,-8(fp)
 20485a0:	e0fffd17 	ldw	r3,-12(fp)
 20485a4:	10c00115 	stw	r3,4(r2)
   return 0;
 20485a8:	0005883a 	mov	r2,zero
}
 20485ac:	e037883a 	mov	sp,fp
 20485b0:	dfc00117 	ldw	ra,4(sp)
 20485b4:	df000017 	ldw	fp,0(sp)
 20485b8:	dec00204 	addi	sp,sp,8
 20485bc:	f800283a 	ret

020485c0 <in_pcbdetach>:
 * RETURNS: 
 */

void
in_pcbdetach(struct inpcb * inp)
{
 20485c0:	defffc04 	addi	sp,sp,-16
 20485c4:	dfc00315 	stw	ra,12(sp)
 20485c8:	df000215 	stw	fp,8(sp)
 20485cc:	df000204 	addi	fp,sp,8
 20485d0:	e13fff15 	stw	r4,-4(fp)
   struct socket *   so =  inp->inp_socket;
 20485d4:	e0bfff17 	ldw	r2,-4(fp)
 20485d8:	10800817 	ldw	r2,32(r2)
 20485dc:	e0bffe15 	stw	r2,-8(fp)

   so->so_pcb = 0;
 20485e0:	e0bffe17 	ldw	r2,-8(fp)
 20485e4:	10000115 	stw	zero,4(r2)
   sofree(so);
 20485e8:	e13ffe17 	ldw	r4,-8(fp)
 20485ec:	202cd6c0 	call	202cd6c <sofree>
   remque(inp);
 20485f0:	e13fff17 	ldw	r4,-4(fp)
 20485f4:	2029c680 	call	2029c68 <remque>
   INP_FREE (inp);
 20485f8:	e13fff17 	ldw	r4,-4(fp)
 20485fc:	202912c0 	call	202912c <npfree>
}
 2048600:	e037883a 	mov	sp,fp
 2048604:	dfc00117 	ldw	ra,4(sp)
 2048608:	df000017 	ldw	fp,0(sp)
 204860c:	dec00204 	addi	sp,sp,8
 2048610:	f800283a 	ret

02048614 <in_pcbbind>:

int
in_pcbbind(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 2048614:	defff504 	addi	sp,sp,-44
 2048618:	dfc00a15 	stw	ra,40(sp)
 204861c:	df000915 	stw	fp,36(sp)
 2048620:	df000904 	addi	fp,sp,36
 2048624:	e13ffe15 	stw	r4,-8(fp)
 2048628:	e17fff15 	stw	r5,-4(fp)
   struct socket *   so =  inp->inp_socket;
 204862c:	e0bffe17 	ldw	r2,-8(fp)
 2048630:	10800817 	ldw	r2,32(r2)
 2048634:	e0bffb15 	stw	r2,-20(fp)
   struct inpcb * head  =  inp->inp_head;
 2048638:	e0bffe17 	ldw	r2,-8(fp)
 204863c:	10800217 	ldw	r2,8(r2)
 2048640:	e0bffc15 	stw	r2,-16(fp)
   struct sockaddr_in * sin;
   u_short  lport =  0;
 2048644:	e03ff90d 	sth	zero,-28(fp)


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
 2048648:	e0bffe17 	ldw	r2,-8(fp)
 204864c:	1080078b 	ldhu	r2,30(r2)
 2048650:	10bfffcc 	andi	r2,r2,65535
 2048654:	1000031e 	bne	r2,zero,2048664 <in_pcbbind+0x50>
 2048658:	e0bffe17 	ldw	r2,-8(fp)
 204865c:	10800417 	ldw	r2,16(r2)
 2048660:	10000226 	beq	r2,zero,204866c <in_pcbbind+0x58>
      return (EINVAL);
 2048664:	00800584 	movi	r2,22
 2048668:	00006906 	br	2048810 <in_pcbbind+0x1fc>
   if (nam == 0)
 204866c:	e0bfff17 	ldw	r2,-4(fp)
 2048670:	10003826 	beq	r2,zero,2048754 <in_pcbbind+0x140>
      goto noname;
   sin = mtod(nam, struct sockaddr_in *);
 2048674:	e0bfff17 	ldw	r2,-4(fp)
 2048678:	10800317 	ldw	r2,12(r2)
 204867c:	e0bffd15 	stw	r2,-12(fp)
   /*
    * removed test here for "if (nam->m_len != sizeof (*sin))"
    * since it really complicatges supporting dual IPv4/v6, and 
    * the 2.0 stack now checks this in t_bind(). -JB-
    */
   if (sin->sin_addr.s_addr != INADDR_ANY) 
 2048680:	e0bffd17 	ldw	r2,-12(fp)
 2048684:	10800117 	ldw	r2,4(r2)
 2048688:	10000926 	beq	r2,zero,20486b0 <in_pcbbind+0x9c>
   {
      if (ip_mymach(sin->sin_addr.s_addr) != sin->sin_addr.s_addr)
 204868c:	e0bffd17 	ldw	r2,-12(fp)
 2048690:	10800117 	ldw	r2,4(r2)
 2048694:	1009883a 	mov	r4,r2
 2048698:	2040d940 	call	2040d94 <ip_mymach>
 204869c:	e0fffd17 	ldw	r3,-12(fp)
 20486a0:	18c00117 	ldw	r3,4(r3)
 20486a4:	10c00226 	beq	r2,r3,20486b0 <in_pcbbind+0x9c>
      return (EADDRNOTAVAIL);
 20486a8:	00801f44 	movi	r2,125
 20486ac:	00005806 	br	2048810 <in_pcbbind+0x1fc>
   }
   lport = sin->sin_port;
 20486b0:	e0bffd17 	ldw	r2,-12(fp)
 20486b4:	1080008b 	ldhu	r2,2(r2)
 20486b8:	e0bff90d 	sth	r2,-28(fp)
   if (lport) 
 20486bc:	e0bff90b 	ldhu	r2,-28(fp)
 20486c0:	10001f26 	beq	r2,zero,2048740 <in_pcbbind+0x12c>
   {
      int   wild  =  0;
 20486c4:	e03ffa15 	stw	zero,-24(fp)

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 20486c8:	e0bffb17 	ldw	r2,-20(fp)
 20486cc:	10800417 	ldw	r2,16(r2)
 20486d0:	1080010c 	andi	r2,r2,4
 20486d4:	10000c1e 	bne	r2,zero,2048708 <in_pcbbind+0xf4>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 20486d8:	e0bffb17 	ldw	r2,-20(fp)
 20486dc:	10800217 	ldw	r2,8(r2)
 20486e0:	1080010b 	ldhu	r2,4(r2)
 20486e4:	10bfffcc 	andi	r2,r2,65535
 20486e8:	1080010c 	andi	r2,r2,4
   if (lport) 
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
 20486ec:	10000426 	beq	r2,zero,2048700 <in_pcbbind+0xec>
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
 20486f0:	e0bffb17 	ldw	r2,-20(fp)
 20486f4:	10800417 	ldw	r2,16(r2)
 20486f8:	1080008c 	andi	r2,r2,2
   {
      int   wild  =  0;

      /* even GROSSER, but this is the Internet */
      if ((so->so_options & SO_REUSEADDR) == 0 &&
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
 20486fc:	1000021e 	bne	r2,zero,2048708 <in_pcbbind+0xf4>
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
 2048700:	00800044 	movi	r2,1
 2048704:	e0bffa15 	stw	r2,-24(fp)
      }
      if (in_pcblookup(head,
          0L, 0, sin->sin_addr.s_addr, lport, wild))
 2048708:	e0bffd17 	ldw	r2,-12(fp)
          ((so->so_proto->pr_flags & PR_CONNREQUIRED) == 0 ||
          (so->so_options & SO_ACCEPTCONN) == 0))
      {
         wild = INPLOOKUP_WILDCARD;
      }
      if (in_pcblookup(head,
 204870c:	10800117 	ldw	r2,4(r2)
 2048710:	e0fff90b 	ldhu	r3,-28(fp)
 2048714:	d8c00015 	stw	r3,0(sp)
 2048718:	e0fffa17 	ldw	r3,-24(fp)
 204871c:	d8c00115 	stw	r3,4(sp)
 2048720:	e13ffc17 	ldw	r4,-16(fp)
 2048724:	000b883a 	mov	r5,zero
 2048728:	000d883a 	mov	r6,zero
 204872c:	100f883a 	mov	r7,r2
 2048730:	2048b580 	call	2048b58 <in_pcblookup>
 2048734:	10000226 	beq	r2,zero,2048740 <in_pcbbind+0x12c>
          0L, 0, sin->sin_addr.s_addr, lport, wild))
      {
         return (EADDRINUSE);
 2048738:	00801c04 	movi	r2,112
 204873c:	00003406 	br	2048810 <in_pcbbind+0x1fc>
      }
   }
   inp->inp_laddr = sin->sin_addr;
 2048740:	e0bffe17 	ldw	r2,-8(fp)
 2048744:	e0fffd17 	ldw	r3,-12(fp)
 2048748:	18c00117 	ldw	r3,4(r3)
 204874c:	10c00415 	stw	r3,16(r2)
 2048750:	00000106 	br	2048758 <in_pcbbind+0x144>


   if (inp->inp_lport || inp->inp_laddr.s_addr != INADDR_ANY)
      return (EINVAL);
   if (nam == 0)
      goto noname;
 2048754:	0001883a 	nop
         return (EADDRINUSE);
      }
   }
   inp->inp_laddr = sin->sin_addr;
noname:
   if (lport == 0)
 2048758:	e0bff90b 	ldhu	r2,-28(fp)
 204875c:	1000281e 	bne	r2,zero,2048800 <in_pcbbind+0x1ec>
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 2048760:	e0bffc17 	ldw	r2,-16(fp)
 2048764:	1080078b 	ldhu	r2,30(r2)
 2048768:	10ffffcc 	andi	r3,r2,65535
 204876c:	18c10030 	cmpltui	r3,r3,1024
 2048770:	10800044 	addi	r2,r2,1
 2048774:	1009883a 	mov	r4,r2
 2048778:	e0bffc17 	ldw	r2,-16(fp)
 204877c:	1100078d 	sth	r4,30(r2)
 2048780:	18803fcc 	andi	r2,r3,255
 2048784:	1000051e 	bne	r2,zero,204879c <in_pcbbind+0x188>
             head->inp_lport > IPPORT_USERRESERVED)
 2048788:	e0bffc17 	ldw	r2,-16(fp)
 204878c:	1080078b 	ldhu	r2,30(r2)
noname:
   if (lport == 0)
   {
      do 
      {
         if (head->inp_lport++ < IPPORT_RESERVED ||
 2048790:	10bfffcc 	andi	r2,r2,65535
 2048794:	1084e270 	cmpltui	r2,r2,5001
 2048798:	1000031e 	bne	r2,zero,20487a8 <in_pcbbind+0x194>
             head->inp_lport > IPPORT_USERRESERVED)
         {
            head->inp_lport = IPPORT_RESERVED;
 204879c:	e0bffc17 	ldw	r2,-16(fp)
 20487a0:	00c10004 	movi	r3,1024
 20487a4:	10c0078d 	sth	r3,30(r2)
         }
         lport = htons(head->inp_lport);
 20487a8:	e0bffc17 	ldw	r2,-16(fp)
 20487ac:	1080078b 	ldhu	r2,30(r2)
 20487b0:	10bfffcc 	andi	r2,r2,65535
 20487b4:	1004d23a 	srli	r2,r2,8
 20487b8:	1007883a 	mov	r3,r2
 20487bc:	e0bffc17 	ldw	r2,-16(fp)
 20487c0:	1080078b 	ldhu	r2,30(r2)
 20487c4:	10bfffcc 	andi	r2,r2,65535
 20487c8:	1004923a 	slli	r2,r2,8
 20487cc:	1884b03a 	or	r2,r3,r2
 20487d0:	e0bff90d 	sth	r2,-28(fp)
      } while(in_pcblookup(head, 0L, 0, inp->inp_laddr.s_addr, lport, 0));
 20487d4:	e0bffe17 	ldw	r2,-8(fp)
 20487d8:	10800417 	ldw	r2,16(r2)
 20487dc:	e0fff90b 	ldhu	r3,-28(fp)
 20487e0:	d8c00015 	stw	r3,0(sp)
 20487e4:	d8000115 	stw	zero,4(sp)
 20487e8:	e13ffc17 	ldw	r4,-16(fp)
 20487ec:	000b883a 	mov	r5,zero
 20487f0:	000d883a 	mov	r6,zero
 20487f4:	100f883a 	mov	r7,r2
 20487f8:	2048b580 	call	2048b58 <in_pcblookup>
 20487fc:	103fd81e 	bne	r2,zero,2048760 <in_pcbbind+0x14c>
   }
   inp->inp_lport = lport;
 2048800:	e0bffe17 	ldw	r2,-8(fp)
 2048804:	e0fff90b 	ldhu	r3,-28(fp)
 2048808:	10c0078d 	sth	r3,30(r2)
   return (0);
 204880c:	0005883a 	mov	r2,zero
}
 2048810:	e037883a 	mov	sp,fp
 2048814:	dfc00117 	ldw	ra,4(sp)
 2048818:	df000017 	ldw	fp,0(sp)
 204881c:	dec00204 	addi	sp,sp,8
 2048820:	f800283a 	ret

02048824 <in_pcbconnect>:
 */

int
in_pcbconnect(struct inpcb * inp, 
   struct mbuf *  nam)
{
 2048824:	defff604 	addi	sp,sp,-40
 2048828:	dfc00915 	stw	ra,36(sp)
 204882c:	df000815 	stw	fp,32(sp)
 2048830:	df000804 	addi	fp,sp,32
 2048834:	e13ffe15 	stw	r4,-8(fp)
 2048838:	e17fff15 	stw	r5,-4(fp)
   unsigned long ifaddr;
   struct sockaddr_in * sin   =  mtod(nam,   struct sockaddr_in *);
 204883c:	e0bfff17 	ldw	r2,-4(fp)
 2048840:	10800317 	ldw	r2,12(r2)
 2048844:	e0bffb15 	stw	r2,-20(fp)

   if (nam->m_len < sizeof (*sin))
 2048848:	e0bfff17 	ldw	r2,-4(fp)
 204884c:	10800217 	ldw	r2,8(r2)
 2048850:	10800428 	cmpgeui	r2,r2,16
 2048854:	1000021e 	bne	r2,zero,2048860 <in_pcbconnect+0x3c>
      return (EINVAL);
 2048858:	00800584 	movi	r2,22
 204885c:	00006306 	br	20489ec <in_pcbconnect+0x1c8>
   if (sin->sin_family != AF_INET)
 2048860:	e0bffb17 	ldw	r2,-20(fp)
 2048864:	1080000b 	ldhu	r2,0(r2)
 2048868:	10bfffcc 	andi	r2,r2,65535
 204886c:	10a0001c 	xori	r2,r2,32768
 2048870:	10a00004 	addi	r2,r2,-32768
 2048874:	108000a0 	cmpeqi	r2,r2,2
 2048878:	1000021e 	bne	r2,zero,2048884 <in_pcbconnect+0x60>
      return (EAFNOSUPPORT);
 204887c:	00801a84 	movi	r2,106
 2048880:	00005a06 	br	20489ec <in_pcbconnect+0x1c8>
   if (sin->sin_port == 0)
 2048884:	e0bffb17 	ldw	r2,-20(fp)
 2048888:	1080008b 	ldhu	r2,2(r2)
 204888c:	10bfffcc 	andi	r2,r2,65535
 2048890:	1000021e 	bne	r2,zero,204889c <in_pcbconnect+0x78>
      return (EADDRNOTAVAIL);
 2048894:	00801f44 	movi	r2,125
 2048898:	00005406 	br	20489ec <in_pcbconnect+0x1c8>
    * use the primary local address.
    * If the supplied address is INADDR_BROADCAST,
    * and the primary interface supports broadcast,
    * choose the broadcast address for that interface.
    */
   if (sin->sin_addr.s_addr == INADDR_ANY)
 204889c:	e0bffb17 	ldw	r2,-20(fp)
 20488a0:	10800117 	ldw	r2,4(r2)
 20488a4:	10000d1e 	bne	r2,zero,20488dc <in_pcbconnect+0xb8>
   {
      if (inp && inp->ifp)
 20488a8:	e0bffe17 	ldw	r2,-8(fp)
 20488ac:	10000926 	beq	r2,zero,20488d4 <in_pcbconnect+0xb0>
 20488b0:	e0bffe17 	ldw	r2,-8(fp)
 20488b4:	10800a17 	ldw	r2,40(r2)
 20488b8:	10000626 	beq	r2,zero,20488d4 <in_pcbconnect+0xb0>
         sin->sin_addr.s_addr = inp->ifp->n_ipaddr;
 20488bc:	e0bffe17 	ldw	r2,-8(fp)
 20488c0:	10800a17 	ldw	r2,40(r2)
 20488c4:	10c00a17 	ldw	r3,40(r2)
 20488c8:	e0bffb17 	ldw	r2,-20(fp)
 20488cc:	10c00115 	stw	r3,4(r2)
 20488d0:	00000806 	br	20488f4 <in_pcbconnect+0xd0>
      else
         return (EADDRNOTAVAIL);
 20488d4:	00801f44 	movi	r2,125
 20488d8:	00004406 	br	20489ec <in_pcbconnect+0x1c8>
   }
   else if (sin->sin_addr.s_addr == INADDR_BROADCAST)
 20488dc:	e0bffb17 	ldw	r2,-20(fp)
 20488e0:	10800117 	ldw	r2,4(r2)
 20488e4:	10bfffd8 	cmpnei	r2,r2,-1
 20488e8:	1000021e 	bne	r2,zero,20488f4 <in_pcbconnect+0xd0>
      return (EADDRNOTAVAIL);
 20488ec:	00801f44 	movi	r2,125
 20488f0:	00003e06 	br	20489ec <in_pcbconnect+0x1c8>


   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 20488f4:	e0bffe17 	ldw	r2,-8(fp)
 20488f8:	10800417 	ldw	r2,16(r2)
 20488fc:	10000f1e 	bne	r2,zero,204893c <in_pcbconnect+0x118>
   {
#ifdef MULTI_HOMED
      ip_addr hop1;     /* dummy for pass to iproute() */
      NET npnet;     /* the netport iface we can send on */
      /* call netport stack's IP routing */
      npnet = iproute(sin->sin_addr.s_addr, &hop1);
 2048900:	e0bffb17 	ldw	r2,-20(fp)
 2048904:	10c00117 	ldw	r3,4(r2)
 2048908:	e0bffd04 	addi	r2,fp,-12
 204890c:	1809883a 	mov	r4,r3
 2048910:	100b883a 	mov	r5,r2
 2048914:	20410e40 	call	20410e4 <iproute>
 2048918:	e0bffc15 	stw	r2,-16(fp)
      if (!npnet)
 204891c:	e0bffc17 	ldw	r2,-16(fp)
 2048920:	1000021e 	bne	r2,zero,204892c <in_pcbconnect+0x108>
         return EADDRNOTAVAIL;
 2048924:	00801f44 	movi	r2,125
 2048928:	00003006 	br	20489ec <in_pcbconnect+0x1c8>
      ifaddr = npnet->n_ipaddr;  /* local address for this host */
 204892c:	e0bffc17 	ldw	r2,-16(fp)
 2048930:	10800a17 	ldw	r2,40(r2)
 2048934:	e0bffa15 	stw	r2,-24(fp)
 2048938:	00000306 	br	2048948 <in_pcbconnect+0x124>
#else    /* not netport MULTI_HOMED, use 0th (only) iface */
      ifaddr = nets[0]->n_ipaddr;
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */
 204893c:	e0bffe17 	ldw	r2,-8(fp)
 2048940:	10800417 	ldw	r2,16(r2)
 2048944:	e0bffa15 	stw	r2,-24(fp)

   if (in_pcblookup(inp->inp_head,
 2048948:	e0bffe17 	ldw	r2,-8(fp)
 204894c:	11000217 	ldw	r4,8(r2)
       sin->sin_addr.s_addr,
 2048950:	e0bffb17 	ldw	r2,-20(fp)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 2048954:	10c00117 	ldw	r3,4(r2)
       sin->sin_addr.s_addr,
       sin->sin_port,
 2048958:	e0bffb17 	ldw	r2,-20(fp)
 204895c:	1080008b 	ldhu	r2,2(r2)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 2048960:	10bfffcc 	andi	r2,r2,65535
       sin->sin_addr.s_addr,
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
 2048964:	e17ffe17 	ldw	r5,-8(fp)
 2048968:	2940078b 	ldhu	r5,30(r5)
#endif   /* MULTI_HOMED */
   }
   else  /* inp->inp_laddr.s_addr != INADDR_ANY */
      ifaddr = inp->inp_laddr.s_addr;  /* use address passed */

   if (in_pcblookup(inp->inp_head,
 204896c:	297fffcc 	andi	r5,r5,65535
 2048970:	d9400015 	stw	r5,0(sp)
 2048974:	d8000115 	stw	zero,4(sp)
 2048978:	180b883a 	mov	r5,r3
 204897c:	100d883a 	mov	r6,r2
 2048980:	e1fffa17 	ldw	r7,-24(fp)
 2048984:	2048b580 	call	2048b58 <in_pcblookup>
 2048988:	10000226 	beq	r2,zero,2048994 <in_pcbconnect+0x170>
       sin->sin_port,
       ifaddr,
       inp->inp_lport,
       0))
   {
      return (EADDRINUSE);
 204898c:	00801c04 	movi	r2,112
 2048990:	00001606 	br	20489ec <in_pcbconnect+0x1c8>
   }
   if (inp->inp_laddr.s_addr == INADDR_ANY) 
 2048994:	e0bffe17 	ldw	r2,-8(fp)
 2048998:	10800417 	ldw	r2,16(r2)
 204899c:	10000a1e 	bne	r2,zero,20489c8 <in_pcbconnect+0x1a4>
   {
      if (inp->inp_lport == 0)
 20489a0:	e0bffe17 	ldw	r2,-8(fp)
 20489a4:	1080078b 	ldhu	r2,30(r2)
 20489a8:	10bfffcc 	andi	r2,r2,65535
 20489ac:	1000031e 	bne	r2,zero,20489bc <in_pcbconnect+0x198>
         (void)in_pcbbind(inp, (struct mbuf *)0);
 20489b0:	e13ffe17 	ldw	r4,-8(fp)
 20489b4:	000b883a 	mov	r5,zero
 20489b8:	20486140 	call	2048614 <in_pcbbind>
      inp->inp_laddr.s_addr = ifaddr;
 20489bc:	e0bffe17 	ldw	r2,-8(fp)
 20489c0:	e0fffa17 	ldw	r3,-24(fp)
 20489c4:	10c00415 	stw	r3,16(r2)
   }
   inp->inp_faddr = sin->sin_addr;
 20489c8:	e0bffe17 	ldw	r2,-8(fp)
 20489cc:	e0fffb17 	ldw	r3,-20(fp)
 20489d0:	18c00117 	ldw	r3,4(r3)
 20489d4:	10c00315 	stw	r3,12(r2)
   inp->inp_fport = sin->sin_port;
 20489d8:	e0bffb17 	ldw	r2,-20(fp)
 20489dc:	10c0008b 	ldhu	r3,2(r2)
 20489e0:	e0bffe17 	ldw	r2,-8(fp)
 20489e4:	10c0070d 	sth	r3,28(r2)
   return 0;
 20489e8:	0005883a 	mov	r2,zero
}
 20489ec:	e037883a 	mov	sp,fp
 20489f0:	dfc00117 	ldw	ra,4(sp)
 20489f4:	df000017 	ldw	fp,0(sp)
 20489f8:	dec00204 	addi	sp,sp,8
 20489fc:	f800283a 	ret

02048a00 <in_pcbdisconnect>:
 * RETURNS: 
 */

void
in_pcbdisconnect(struct inpcb * inp)
{
 2048a00:	defffd04 	addi	sp,sp,-12
 2048a04:	dfc00215 	stw	ra,8(sp)
 2048a08:	df000115 	stw	fp,4(sp)
 2048a0c:	df000104 	addi	fp,sp,4
 2048a10:	e13fff15 	stw	r4,-4(fp)

   inp->inp_faddr.s_addr = INADDR_ANY;
 2048a14:	e0bfff17 	ldw	r2,-4(fp)
 2048a18:	10000315 	stw	zero,12(r2)
   inp->inp_fport = 0;
 2048a1c:	e0bfff17 	ldw	r2,-4(fp)
 2048a20:	1000070d 	sth	zero,28(r2)
   if (inp->inp_socket->so_state & SS_NOFDREF)
 2048a24:	e0bfff17 	ldw	r2,-4(fp)
 2048a28:	10800817 	ldw	r2,32(r2)
 2048a2c:	1080088b 	ldhu	r2,34(r2)
 2048a30:	10bfffcc 	andi	r2,r2,65535
 2048a34:	1080004c 	andi	r2,r2,1
 2048a38:	10000226 	beq	r2,zero,2048a44 <in_pcbdisconnect+0x44>
      in_pcbdetach (inp);
 2048a3c:	e13fff17 	ldw	r4,-4(fp)
 2048a40:	20485c00 	call	20485c0 <in_pcbdetach>
}
 2048a44:	e037883a 	mov	sp,fp
 2048a48:	dfc00117 	ldw	ra,4(sp)
 2048a4c:	df000017 	ldw	fp,0(sp)
 2048a50:	dec00204 	addi	sp,sp,8
 2048a54:	f800283a 	ret

02048a58 <in_setsockaddr>:
 */

void
in_setsockaddr(struct inpcb * inp, 
   struct mbuf *  nam)
{
 2048a58:	defffb04 	addi	sp,sp,-20
 2048a5c:	dfc00415 	stw	ra,16(sp)
 2048a60:	df000315 	stw	fp,12(sp)
 2048a64:	df000304 	addi	fp,sp,12
 2048a68:	e13ffe15 	stw	r4,-8(fp)
 2048a6c:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 2048a70:	e0bfff17 	ldw	r2,-4(fp)
 2048a74:	00c00404 	movi	r3,16
 2048a78:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 2048a7c:	e0bfff17 	ldw	r2,-4(fp)
 2048a80:	10800317 	ldw	r2,12(r2)
 2048a84:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 2048a88:	e13ffd17 	ldw	r4,-12(fp)
 2048a8c:	000b883a 	mov	r5,zero
 2048a90:	01800404 	movi	r6,16
 2048a94:	200682c0 	call	200682c <memset>
   sin->sin_family = AF_INET;
 2048a98:	e0bffd17 	ldw	r2,-12(fp)
 2048a9c:	00c00084 	movi	r3,2
 2048aa0:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_lport;
 2048aa4:	e0bffe17 	ldw	r2,-8(fp)
 2048aa8:	10c0078b 	ldhu	r3,30(r2)
 2048aac:	e0bffd17 	ldw	r2,-12(fp)
 2048ab0:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_laddr;
 2048ab4:	e0bffd17 	ldw	r2,-12(fp)
 2048ab8:	e0fffe17 	ldw	r3,-8(fp)
 2048abc:	18c00417 	ldw	r3,16(r3)
 2048ac0:	10c00115 	stw	r3,4(r2)
}
 2048ac4:	e037883a 	mov	sp,fp
 2048ac8:	dfc00117 	ldw	ra,4(sp)
 2048acc:	df000017 	ldw	fp,0(sp)
 2048ad0:	dec00204 	addi	sp,sp,8
 2048ad4:	f800283a 	ret

02048ad8 <in_setpeeraddr>:

void
in_setpeeraddr(
   struct inpcb * inp,
   struct mbuf *  nam)
{
 2048ad8:	defffb04 	addi	sp,sp,-20
 2048adc:	dfc00415 	stw	ra,16(sp)
 2048ae0:	df000315 	stw	fp,12(sp)
 2048ae4:	df000304 	addi	fp,sp,12
 2048ae8:	e13ffe15 	stw	r4,-8(fp)
 2048aec:	e17fff15 	stw	r5,-4(fp)
   struct sockaddr_in * sin;

   nam->m_len = sizeof (*sin);
 2048af0:	e0bfff17 	ldw	r2,-4(fp)
 2048af4:	00c00404 	movi	r3,16
 2048af8:	10c00215 	stw	r3,8(r2)
   sin = mtod(nam, struct sockaddr_in *);
 2048afc:	e0bfff17 	ldw	r2,-4(fp)
 2048b00:	10800317 	ldw	r2,12(r2)
 2048b04:	e0bffd15 	stw	r2,-12(fp)
   MEMSET(sin, 0, sizeof (*sin));
 2048b08:	e13ffd17 	ldw	r4,-12(fp)
 2048b0c:	000b883a 	mov	r5,zero
 2048b10:	01800404 	movi	r6,16
 2048b14:	200682c0 	call	200682c <memset>
   sin->sin_family = AF_INET;
 2048b18:	e0bffd17 	ldw	r2,-12(fp)
 2048b1c:	00c00084 	movi	r3,2
 2048b20:	10c0000d 	sth	r3,0(r2)
   sin->sin_port = inp->inp_fport;
 2048b24:	e0bffe17 	ldw	r2,-8(fp)
 2048b28:	10c0070b 	ldhu	r3,28(r2)
 2048b2c:	e0bffd17 	ldw	r2,-12(fp)
 2048b30:	10c0008d 	sth	r3,2(r2)
   sin->sin_addr = inp->inp_faddr;
 2048b34:	e0bffd17 	ldw	r2,-12(fp)
 2048b38:	e0fffe17 	ldw	r3,-8(fp)
 2048b3c:	18c00317 	ldw	r3,12(r3)
 2048b40:	10c00115 	stw	r3,4(r2)
}
 2048b44:	e037883a 	mov	sp,fp
 2048b48:	dfc00117 	ldw	ra,4(sp)
 2048b4c:	df000017 	ldw	fp,0(sp)
 2048b50:	dec00204 	addi	sp,sp,8
 2048b54:	f800283a 	ret

02048b58 <in_pcblookup>:
   u_long   faddr, 
   unshort  xfport,
   u_long   laddr,
   unshort  xlport,
   int   flags)
{
 2048b58:	defff504 	addi	sp,sp,-44
 2048b5c:	df000a15 	stw	fp,40(sp)
 2048b60:	df000a04 	addi	fp,sp,40
 2048b64:	e13ffb15 	stw	r4,-20(fp)
 2048b68:	e17ffc15 	stw	r5,-16(fp)
 2048b6c:	3005883a 	mov	r2,r6
 2048b70:	e1fffe15 	stw	r7,-8(fp)
 2048b74:	e0c00117 	ldw	r3,4(fp)
 2048b78:	e0bffd0d 	sth	r2,-12(fp)
 2048b7c:	e0ffff0d 	sth	r3,-4(fp)
   struct inpcb * inp, *   match =  0;
 2048b80:	e03ff715 	stw	zero,-36(fp)
   unshort  fport =  xfport; 
 2048b84:	e0bffd0b 	ldhu	r2,-12(fp)
 2048b88:	e0bffa0d 	sth	r2,-24(fp)
   unshort  lport =  xlport;
 2048b8c:	e0bfff0b 	ldhu	r2,-4(fp)
 2048b90:	e0bffa8d 	sth	r2,-22(fp)
   int   matchwild   =  3;
 2048b94:	008000c4 	movi	r2,3
 2048b98:	e0bff815 	stw	r2,-32(fp)
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 2048b9c:	e0bffb17 	ldw	r2,-20(fp)
 2048ba0:	10800017 	ldw	r2,0(r2)
 2048ba4:	e0bff615 	stw	r2,-40(fp)
 2048ba8:	00004f06 	br	2048ce8 <in_pcblookup+0x190>
   {
      if (inp->inp_lport != lport)
 2048bac:	e0bff617 	ldw	r2,-40(fp)
 2048bb0:	1080078b 	ldhu	r2,30(r2)
 2048bb4:	10ffffcc 	andi	r3,r2,65535
 2048bb8:	e0bffa8b 	ldhu	r2,-22(fp)
 2048bbc:	1880401e 	bne	r3,r2,2048cc0 <in_pcblookup+0x168>
         continue;

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
 2048bc0:	e0bff617 	ldw	r2,-40(fp)
 2048bc4:	10800817 	ldw	r2,32(r2)
 2048bc8:	10800517 	ldw	r2,20(r2)
 2048bcc:	108000a0 	cmpeqi	r2,r2,2
 2048bd0:	10003d26 	beq	r2,zero,2048cc8 <in_pcblookup+0x170>
         continue;

      wildcard = 0;
 2048bd4:	e03ff915 	stw	zero,-28(fp)
      if (inp->inp_laddr.s_addr != INADDR_ANY) 
 2048bd8:	e0bff617 	ldw	r2,-40(fp)
 2048bdc:	10800417 	ldw	r2,16(r2)
 2048be0:	10000b26 	beq	r2,zero,2048c10 <in_pcblookup+0xb8>
      {
         if (laddr == INADDR_ANY)
 2048be4:	e0bffe17 	ldw	r2,-8(fp)
 2048be8:	1000041e 	bne	r2,zero,2048bfc <in_pcblookup+0xa4>
            wildcard++;
 2048bec:	e0bff917 	ldw	r2,-28(fp)
 2048bf0:	10800044 	addi	r2,r2,1
 2048bf4:	e0bff915 	stw	r2,-28(fp)
 2048bf8:	00000a06 	br	2048c24 <in_pcblookup+0xcc>
         else if (inp->inp_laddr.s_addr != laddr)
 2048bfc:	e0bff617 	ldw	r2,-40(fp)
 2048c00:	10c00417 	ldw	r3,16(r2)
 2048c04:	e0bffe17 	ldw	r2,-8(fp)
 2048c08:	18800626 	beq	r3,r2,2048c24 <in_pcblookup+0xcc>
            continue;
 2048c0c:	00003306 	br	2048cdc <in_pcblookup+0x184>
      }
      else 
      {
         if (laddr != INADDR_ANY)
 2048c10:	e0bffe17 	ldw	r2,-8(fp)
 2048c14:	10000326 	beq	r2,zero,2048c24 <in_pcblookup+0xcc>
            wildcard++;
 2048c18:	e0bff917 	ldw	r2,-28(fp)
 2048c1c:	10800044 	addi	r2,r2,1
 2048c20:	e0bff915 	stw	r2,-28(fp)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
 2048c24:	e0bff617 	ldw	r2,-40(fp)
 2048c28:	10800317 	ldw	r2,12(r2)
 2048c2c:	10001026 	beq	r2,zero,2048c70 <in_pcblookup+0x118>
      {
         if (faddr == INADDR_ANY)
 2048c30:	e0bffc17 	ldw	r2,-16(fp)
 2048c34:	1000041e 	bne	r2,zero,2048c48 <in_pcblookup+0xf0>
            wildcard++;
 2048c38:	e0bff917 	ldw	r2,-28(fp)
 2048c3c:	10800044 	addi	r2,r2,1
 2048c40:	e0bff915 	stw	r2,-28(fp)
 2048c44:	00000f06 	br	2048c84 <in_pcblookup+0x12c>
         else if (inp->inp_faddr.s_addr != faddr ||
 2048c48:	e0bff617 	ldw	r2,-40(fp)
 2048c4c:	10c00317 	ldw	r3,12(r2)
 2048c50:	e0bffc17 	ldw	r2,-16(fp)
 2048c54:	18801e1e 	bne	r3,r2,2048cd0 <in_pcblookup+0x178>
             inp->inp_fport != fport)
 2048c58:	e0bff617 	ldw	r2,-40(fp)
 2048c5c:	1080070b 	ldhu	r2,28(r2)
      }
      if (inp->inp_faddr.s_addr != INADDR_ANY) 
      {
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
 2048c60:	10ffffcc 	andi	r3,r2,65535
 2048c64:	e0bffa0b 	ldhu	r2,-24(fp)
 2048c68:	18800626 	beq	r3,r2,2048c84 <in_pcblookup+0x12c>
             inp->inp_fport != fport)
         {
            continue;
 2048c6c:	00001806 	br	2048cd0 <in_pcblookup+0x178>
         }
      } else 
      {
         if (faddr != INADDR_ANY)
 2048c70:	e0bffc17 	ldw	r2,-16(fp)
 2048c74:	10000326 	beq	r2,zero,2048c84 <in_pcblookup+0x12c>
            wildcard++;
 2048c78:	e0bff917 	ldw	r2,-28(fp)
 2048c7c:	10800044 	addi	r2,r2,1
 2048c80:	e0bff915 	stw	r2,-28(fp)
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
 2048c84:	e0bff917 	ldw	r2,-28(fp)
 2048c88:	10000326 	beq	r2,zero,2048c98 <in_pcblookup+0x140>
 2048c8c:	e0800217 	ldw	r2,8(fp)
 2048c90:	1080004c 	andi	r2,r2,1
 2048c94:	10001026 	beq	r2,zero,2048cd8 <in_pcblookup+0x180>
         continue;
      if (wildcard < matchwild) 
 2048c98:	e0fff917 	ldw	r3,-28(fp)
 2048c9c:	e0bff817 	ldw	r2,-32(fp)
 2048ca0:	18800e0e 	bge	r3,r2,2048cdc <in_pcblookup+0x184>
      {
         match = inp;
 2048ca4:	e0bff617 	ldw	r2,-40(fp)
 2048ca8:	e0bff715 	stw	r2,-36(fp)
         matchwild = wildcard;
 2048cac:	e0bff917 	ldw	r2,-28(fp)
 2048cb0:	e0bff815 	stw	r2,-32(fp)
         if (matchwild == 0)
 2048cb4:	e0bff817 	ldw	r2,-32(fp)
 2048cb8:	10000f26 	beq	r2,zero,2048cf8 <in_pcblookup+0x1a0>
 2048cbc:	00000706 	br	2048cdc <in_pcblookup+0x184>
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
   {
      if (inp->inp_lport != lport)
         continue;
 2048cc0:	0001883a 	nop
 2048cc4:	00000506 	br	2048cdc <in_pcblookup+0x184>

      /* Skip non IPv4 sockets */
      if(inp->inp_socket->so_domain != AF_INET)
         continue;
 2048cc8:	0001883a 	nop
 2048ccc:	00000306 	br	2048cdc <in_pcblookup+0x184>
         if (faddr == INADDR_ANY)
            wildcard++;
         else if (inp->inp_faddr.s_addr != faddr ||
             inp->inp_fport != fport)
         {
            continue;
 2048cd0:	0001883a 	nop
 2048cd4:	00000106 	br	2048cdc <in_pcblookup+0x184>
      {
         if (faddr != INADDR_ANY)
            wildcard++;
      }
      if (wildcard && (flags & INPLOOKUP_WILDCARD) == 0)
         continue;
 2048cd8:	0001883a 	nop
   unshort  fport =  xfport; 
   unshort  lport =  xlport;
   int   matchwild   =  3;
   int   wildcard;

   for (inp = head->inp_next; inp != head; inp = inp->inp_next) 
 2048cdc:	e0bff617 	ldw	r2,-40(fp)
 2048ce0:	10800017 	ldw	r2,0(r2)
 2048ce4:	e0bff615 	stw	r2,-40(fp)
 2048ce8:	e0fff617 	ldw	r3,-40(fp)
 2048cec:	e0bffb17 	ldw	r2,-20(fp)
 2048cf0:	18bfae1e 	bne	r3,r2,2048bac <in_pcblookup+0x54>
 2048cf4:	00000106 	br	2048cfc <in_pcblookup+0x1a4>
      if (wildcard < matchwild) 
      {
         match = inp;
         matchwild = wildcard;
         if (matchwild == 0)
            break;
 2048cf8:	0001883a 	nop
      }
   }
   if (match == NULL)
 2048cfc:	e0bff717 	ldw	r2,-36(fp)
 2048d00:	1000021e 	bne	r2,zero,2048d0c <in_pcblookup+0x1b4>
      return match;
 2048d04:	e0bff717 	ldw	r2,-36(fp)
 2048d08:	00002406 	br	2048d9c <in_pcblookup+0x244>

   if (head->inp_next == match)  /* got cache hit? */
 2048d0c:	e0bffb17 	ldw	r2,-20(fp)
 2048d10:	10c00017 	ldw	r3,0(r2)
 2048d14:	e0bff717 	ldw	r2,-36(fp)
 2048d18:	1880041e 	bne	r3,r2,2048d2c <in_pcblookup+0x1d4>
   {
      inpcb_cachehits++;
 2048d1c:	d0a0c917 	ldw	r2,-31964(gp)
 2048d20:	10800044 	addi	r2,r2,1
 2048d24:	d0a0c915 	stw	r2,-31964(gp)
 2048d28:	00001b06 	br	2048d98 <in_pcblookup+0x240>
   }
   else
   {
      inpcb_cachemiss++;
 2048d2c:	d0a0ca17 	ldw	r2,-31960(gp)
 2048d30:	10800044 	addi	r2,r2,1
 2048d34:	d0a0ca15 	stw	r2,-31960(gp)
      /* "cache" the match to be first checked next time. */
      match->inp_next->inp_prev = match->inp_prev; /*unlink match */
 2048d38:	e0bff717 	ldw	r2,-36(fp)
 2048d3c:	10800017 	ldw	r2,0(r2)
 2048d40:	e0fff717 	ldw	r3,-36(fp)
 2048d44:	18c00117 	ldw	r3,4(r3)
 2048d48:	10c00115 	stw	r3,4(r2)
      match->inp_prev->inp_next = match->inp_next;
 2048d4c:	e0bff717 	ldw	r2,-36(fp)
 2048d50:	10800117 	ldw	r2,4(r2)
 2048d54:	e0fff717 	ldw	r3,-36(fp)
 2048d58:	18c00017 	ldw	r3,0(r3)
 2048d5c:	10c00015 	stw	r3,0(r2)

      /* relink match as head->inp_next */
      match->inp_next = head->inp_next;
 2048d60:	e0bffb17 	ldw	r2,-20(fp)
 2048d64:	10c00017 	ldw	r3,0(r2)
 2048d68:	e0bff717 	ldw	r2,-36(fp)
 2048d6c:	10c00015 	stw	r3,0(r2)
      head->inp_next = match;
 2048d70:	e0bffb17 	ldw	r2,-20(fp)
 2048d74:	e0fff717 	ldw	r3,-36(fp)
 2048d78:	10c00015 	stw	r3,0(r2)
      match->inp_prev = head;
 2048d7c:	e0bff717 	ldw	r2,-36(fp)
 2048d80:	e0fffb17 	ldw	r3,-20(fp)
 2048d84:	10c00115 	stw	r3,4(r2)
      match->inp_next->inp_prev = match;
 2048d88:	e0bff717 	ldw	r2,-36(fp)
 2048d8c:	10800017 	ldw	r2,0(r2)
 2048d90:	e0fff717 	ldw	r3,-36(fp)
 2048d94:	10c00115 	stw	r3,4(r2)
   }
   return (match);
 2048d98:	e0bff717 	ldw	r2,-36(fp)
}
 2048d9c:	e037883a 	mov	sp,fp
 2048da0:	df000017 	ldw	fp,0(sp)
 2048da4:	dec00104 	addi	sp,sp,4
 2048da8:	f800283a 	ret

02048dac <set_vfopen_error>:
 *
 * RETURNS: 
 */

void set_vfopen_error(int error)
{
 2048dac:	defffe04 	addi	sp,sp,-8
 2048db0:	df000115 	stw	fp,4(sp)
 2048db4:	df000104 	addi	fp,sp,4
 2048db8:	e13fff15 	stw	r4,-4(fp)
   vfopen_error = error;
 2048dbc:	e0bfff17 	ldw	r2,-4(fp)
 2048dc0:	d0a0ce15 	stw	r2,-31944(gp)
}
 2048dc4:	e037883a 	mov	sp,fp
 2048dc8:	df000017 	ldw	fp,0(sp)
 2048dcc:	dec00104 	addi	sp,sp,4
 2048dd0:	f800283a 	ret

02048dd4 <get_vfopen_error>:
 *
 * RETURNS: 
 */

int get_vfopen_error()
{
 2048dd4:	deffff04 	addi	sp,sp,-4
 2048dd8:	df000015 	stw	fp,0(sp)
 2048ddc:	d839883a 	mov	fp,sp
   return vfopen_error;
 2048de0:	d0a0ce17 	ldw	r2,-31944(gp)
}
 2048de4:	e037883a 	mov	sp,fp
 2048de8:	df000017 	ldw	fp,0(sp)
 2048dec:	dec00104 	addi	sp,sp,4
 2048df0:	f800283a 	ret

02048df4 <vf_alloc_and_link_vop>:
 *
 * RETURNS: 
 */

VFILE * vf_alloc_and_link_vop()
{
 2048df4:	defffd04 	addi	sp,sp,-12
 2048df8:	dfc00215 	stw	ra,8(sp)
 2048dfc:	df000115 	stw	fp,4(sp)
 2048e00:	df000104 	addi	fp,sp,4
   struct vfs_open * vop;

   /* enforce maximum number of simultaneously open files */
   if (vfs_open_files >= VFS_MAX_OPEN_FILES)
 2048e04:	d0a0d017 	ldw	r2,-31936(gp)
 2048e08:	10803ff0 	cmpltui	r2,r2,255
 2048e0c:	1000021e 	bne	r2,zero,2048e18 <vf_alloc_and_link_vop+0x24>
   {
#ifdef VFS_VERBOSE
      dprintf("vfs_open_files too big (%ld) in vf_alloc_and_link_vop()\n",
       vfs_open_files);
#endif   /* VFS_VERBOSE */
      return NULL;
 2048e10:	0005883a 	mov	r2,zero
 2048e14:	00000e06 	br	2048e50 <vf_alloc_and_link_vop+0x5c>
   }

   /* allocate a structure to represent the open file */
   vop = VFS_VFS_OPEN_ALLOC();
 2048e18:	01000504 	movi	r4,20
 2048e1c:	20290400 	call	2029040 <npalloc>
 2048e20:	e0bfff15 	stw	r2,-4(fp)

   /* if the allocation succeeded */
   if (vop)
 2048e24:	e0bfff17 	ldw	r2,-4(fp)
 2048e28:	10000826 	beq	r2,zero,2048e4c <vf_alloc_and_link_vop+0x58>
   {
      /* add to the beginning of the list of open files */
      vop->next = vfiles;
 2048e2c:	d0e0cc17 	ldw	r3,-31952(gp)
 2048e30:	e0bfff17 	ldw	r2,-4(fp)
 2048e34:	10c00015 	stw	r3,0(r2)
      vfiles = vop;
 2048e38:	e0bfff17 	ldw	r2,-4(fp)
 2048e3c:	d0a0cc15 	stw	r2,-31952(gp)
      /* increment the count of open files */
      vfs_open_files++;
 2048e40:	d0a0d017 	ldw	r2,-31936(gp)
 2048e44:	10800044 	addi	r2,r2,1
 2048e48:	d0a0d015 	stw	r2,-31936(gp)
#ifdef VFS_VERBOSE
   else
      dprintf("VFS_VFS_OPEN_ALLOC() failed in vf_alloc_and_link_vop()\n");
#endif   /* VFS_VERBOSE */

   return vop;
 2048e4c:	e0bfff17 	ldw	r2,-4(fp)
}
 2048e50:	e037883a 	mov	sp,fp
 2048e54:	dfc00117 	ldw	ra,4(sp)
 2048e58:	df000017 	ldw	fp,0(sp)
 2048e5c:	dec00204 	addi	sp,sp,8
 2048e60:	f800283a 	ret

02048e64 <vf_alloc_buffer>:
 *
 * RETURNS: 
 */

unsigned char * vf_alloc_buffer(unsigned long size)
{
 2048e64:	defff904 	addi	sp,sp,-28
 2048e68:	dfc00615 	stw	ra,24(sp)
 2048e6c:	df000515 	stw	fp,20(sp)
 2048e70:	df000504 	addi	fp,sp,20
 2048e74:	e13fff15 	stw	r4,-4(fp)
   unsigned int long_size,int_size;
#endif   /* MUTE_WARNS */

   /* make sure the requested allocation does not exceed the total
      memory space reserved for file buffers */
   if ((vfs_total_rw_space + size) > VFS_MAX_TOTAL_RW_SPACE)
 2048e78:	d0e0d117 	ldw	r3,-31932(gp)
 2048e7c:	e0bfff17 	ldw	r2,-4(fp)
 2048e80:	1885883a 	add	r2,r3,r2
 2048e84:	00ffffd4 	movui	r3,65535
 2048e88:	1880022e 	bgeu	r3,r2,2048e94 <vf_alloc_buffer+0x30>
      return NULL;
 2048e8c:	0005883a 	mov	r2,zero
 2048e90:	00002106 	br	2048f18 <vf_alloc_buffer+0xb4>
    * any bigger than what will fit in an unsigned int 
    */
#ifdef MUTE_WARNS
   /* the idiotic hoops you got to jump through to suppress compiler
      warnings */
   long_size   =  sizeof(unsigned   long);
 2048e94:	00800104 	movi	r2,4
 2048e98:	e0bffb15 	stw	r2,-20(fp)
   int_size = sizeof(unsigned int);
 2048e9c:	00800104 	movi	r2,4
 2048ea0:	e0bffc15 	stw	r2,-16(fp)
   if (long_size > int_size)
 2048ea4:	e0bffb17 	ldw	r2,-20(fp)
 2048ea8:	e0fffc17 	ldw	r3,-16(fp)
 2048eac:	1880102e 	bgeu	r3,r2,2048ef0 <vf_alloc_buffer+0x8c>
       * most systems where this "if" expression will evaluate to 
       * true (2 byte ints, 4 byte longs). if any of those upper bits 
       * are on in your requested size, you otta luck.
       */
#ifdef MUTE_WARNS
      switch (int_size)
 2048eb0:	e0bffc17 	ldw	r2,-16(fp)
 2048eb4:	108000a0 	cmpeqi	r2,r2,2
 2048eb8:	10000826 	beq	r2,zero,2048edc <vf_alloc_buffer+0x78>
#else
      switch (sizeof(unsigned int))
#endif   /* MUTE_WARNS */
      {
      case 2 :
         mem_mask = 0xffff0000;
 2048ebc:	00bffff4 	movhi	r2,65535
 2048ec0:	e0bffd15 	stw	r2,-12(fp)
         break;
 2048ec4:	0001883a 	nop
         default :
            dtrap();    /* you have a weird compiler */
         return NULL;
      }

      if (size & mem_mask)
 2048ec8:	e0ffff17 	ldw	r3,-4(fp)
 2048ecc:	e0bffd17 	ldw	r2,-12(fp)
 2048ed0:	1884703a 	and	r2,r3,r2
 2048ed4:	10000626 	beq	r2,zero,2048ef0 <vf_alloc_buffer+0x8c>
 2048ed8:	00000306 	br	2048ee8 <vf_alloc_buffer+0x84>
      {
      case 2 :
         mem_mask = 0xffff0000;
         break;
         default :
            dtrap();    /* you have a weird compiler */
 2048edc:	20285c80 	call	20285c8 <dtrap>
         return NULL;
 2048ee0:	0005883a 	mov	r2,zero
 2048ee4:	00000c06 	br	2048f18 <vf_alloc_buffer+0xb4>
      }

      if (size & mem_mask)
         return NULL;
 2048ee8:	0005883a 	mov	r2,zero
 2048eec:	00000a06 	br	2048f18 <vf_alloc_buffer+0xb4>
   }

   /* try to allocate a buffer of the requested size */
   buffer = (unsigned char *) npalloc((unsigned int) size);
 2048ef0:	e13fff17 	ldw	r4,-4(fp)
 2048ef4:	20290400 	call	2029040 <npalloc>
 2048ef8:	e0bffe15 	stw	r2,-8(fp)

   /* if the allocation succeeded */
   if (buffer)
 2048efc:	e0bffe17 	ldw	r2,-8(fp)
 2048f00:	10000426 	beq	r2,zero,2048f14 <vf_alloc_buffer+0xb0>
   {
      /* add size to the count of total buffer space allocated */
      vfs_total_rw_space += size;
 2048f04:	d0e0d117 	ldw	r3,-31932(gp)
 2048f08:	e0bfff17 	ldw	r2,-4(fp)
 2048f0c:	1885883a 	add	r2,r3,r2
 2048f10:	d0a0d115 	stw	r2,-31932(gp)
   }

   return buffer;
 2048f14:	e0bffe17 	ldw	r2,-8(fp)
}
 2048f18:	e037883a 	mov	sp,fp
 2048f1c:	dfc00117 	ldw	ra,4(sp)
 2048f20:	df000017 	ldw	fp,0(sp)
 2048f24:	dec00204 	addi	sp,sp,8
 2048f28:	f800283a 	ret

02048f2c <vf_free_buffer>:
 *
 * RETURNS: 
 */

void vf_free_buffer(unsigned char * buffer, unsigned long size)
{
 2048f2c:	defffc04 	addi	sp,sp,-16
 2048f30:	dfc00315 	stw	ra,12(sp)
 2048f34:	df000215 	stw	fp,8(sp)
 2048f38:	df000204 	addi	fp,sp,8
 2048f3c:	e13ffe15 	stw	r4,-8(fp)
 2048f40:	e17fff15 	stw	r5,-4(fp)
   /* free the buffer */
   if (buffer)
 2048f44:	e0bffe17 	ldw	r2,-8(fp)
 2048f48:	10000226 	beq	r2,zero,2048f54 <vf_free_buffer+0x28>
      npfree(buffer);
 2048f4c:	e13ffe17 	ldw	r4,-8(fp)
 2048f50:	202912c0 	call	202912c <npfree>

   /* and subtract its size from the total buffer space count */
   vfs_total_rw_space -= size;
 2048f54:	d0e0d117 	ldw	r3,-31932(gp)
 2048f58:	e0bfff17 	ldw	r2,-4(fp)
 2048f5c:	1885c83a 	sub	r2,r3,r2
 2048f60:	d0a0d115 	stw	r2,-31932(gp)
}
 2048f64:	e037883a 	mov	sp,fp
 2048f68:	dfc00117 	ldw	ra,4(sp)
 2048f6c:	df000017 	ldw	fp,0(sp)
 2048f70:	dec00204 	addi	sp,sp,8
 2048f74:	f800283a 	ret

02048f78 <vfopen_locked>:
 * RETURNS: 
 */

VFILE *
vfopen_locked(char * name, char * mode)
{
 2048f78:	defff904 	addi	sp,sp,-28
 2048f7c:	dfc00615 	stw	ra,24(sp)
 2048f80:	df000515 	stw	fp,20(sp)
 2048f84:	df000504 	addi	fp,sp,20
 2048f88:	e13ffe15 	stw	r4,-8(fp)
 2048f8c:	e17fff15 	stw	r5,-4(fp)
   struct vfs_file * vfp;
   struct vfs_open * vop;

   /* clear any previous vfopen() error */
   set_vfopen_error(0);
 2048f90:	0009883a 	mov	r4,zero
 2048f94:	2048dac0 	call	2048dac <set_vfopen_error>

   /* the old code used to do special handling of '?' in files for 
    * the benefit of the web server. the web server should be doing 
    * this now. this is here to make sure that its doing it 
    */
   if (strchr(name,'?'))
 2048f98:	e13ffe17 	ldw	r4,-8(fp)
 2048f9c:	01400fc4 	movi	r5,63
 2048fa0:	20073e00 	call	20073e0 <strchr>
 2048fa4:	10000326 	beq	r2,zero,2048fb4 <vfopen_locked+0x3c>
   {
      dtrap();
 2048fa8:	20285c80 	call	20285c8 <dtrap>
      return NULL;
 2048fac:	0005883a 	mov	r2,zero
 2048fb0:	0000ba06 	br	204929c <vfopen_locked+0x324>
   }

   /* determine if the file exists */
   /* if the directory exists, vfp will point to its directory entry
      structure else vfp will be NULL */
   vfp = vfslookup_locked(name);
 2048fb4:	e13ffe17 	ldw	r4,-8(fp)
 2048fb8:	204a1f80 	call	204a1f8 <vfslookup_locked>
 2048fbc:	e0bffc15 	stw	r2,-16(fp)

   /* if the file exists */
   if (vfp)
 2048fc0:	e0bffc17 	ldw	r2,-16(fp)
 2048fc4:	10004a26 	beq	r2,zero,20490f0 <vfopen_locked+0x178>

#ifdef HT_RWVFS

      /* if mode begins with 'w' we will truncate to end of file */
      /* make sure the file is writable before proceeding */
      if ((*mode == 'w') && !(vfp->flags & VF_WRITE))
 2048fc8:	e0bfff17 	ldw	r2,-4(fp)
 2048fcc:	10800003 	ldbu	r2,0(r2)
 2048fd0:	10803fcc 	andi	r2,r2,255
 2048fd4:	1080201c 	xori	r2,r2,128
 2048fd8:	10bfe004 	addi	r2,r2,-128
 2048fdc:	10801dd8 	cmpnei	r2,r2,119
 2048fe0:	1000091e 	bne	r2,zero,2049008 <vfopen_locked+0x90>
 2048fe4:	e0bffc17 	ldw	r2,-16(fp)
 2048fe8:	1080058b 	ldhu	r2,22(r2)
 2048fec:	10bfffcc 	andi	r2,r2,65535
 2048ff0:	1080080c 	andi	r2,r2,32
 2048ff4:	1000041e 	bne	r2,zero,2049008 <vfopen_locked+0x90>
      {
         set_vfopen_error(ENP_FILEIO);
 2048ff8:	013ff984 	movi	r4,-26
 2048ffc:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("mode w with no VF_WRITE\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 2049000:	0005883a 	mov	r2,zero
 2049004:	0000a506 	br	204929c <vfopen_locked+0x324>
      }

#endif   /* HT_RWVFS */

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 2049008:	2048df40 	call	2048df4 <vf_alloc_and_link_vop>
 204900c:	e0bffd15 	stw	r2,-12(fp)

      /* check for failure */
      if (!vop)
 2049010:	e0bffd17 	ldw	r2,-12(fp)
 2049014:	1000041e 	bne	r2,zero,2049028 <vfopen_locked+0xb0>
      {
         set_vfopen_error(ENP_NOMEM);
 2049018:	013ffb04 	movi	r4,-20
 204901c:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 1\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 2049020:	0005883a 	mov	r2,zero
 2049024:	00009d06 	br	204929c <vfopen_locked+0x324>
      }

      /* link to the file's directory entry structure */
      vop->file = vfp;
 2049028:	e0bffd17 	ldw	r2,-12(fp)
 204902c:	e0fffc17 	ldw	r3,-16(fp)
 2049030:	10c00115 	stw	r3,4(r2)

      /* by default start at the beginning of the file */
      /* note that vfp->data could be NULL at this point since empty
         files might have no data buffer allocated to them */
      vop->cmploc = vfp->data;   /* start at beginning of file */
 2049034:	e0bffc17 	ldw	r2,-16(fp)
 2049038:	10c00617 	ldw	r3,24(r2)
 204903c:	e0bffd17 	ldw	r2,-12(fp)
 2049040:	10c00215 	stw	r3,8(r2)

#ifdef HT_RWVFS

      /* if mode begins with 'a', seek to end of file */
      if (*mode == 'a')
 2049044:	e0bfff17 	ldw	r2,-4(fp)
 2049048:	10800003 	ldbu	r2,0(r2)
 204904c:	10803fcc 	andi	r2,r2,255
 2049050:	1080201c 	xori	r2,r2,128
 2049054:	10bfe004 	addi	r2,r2,-128
 2049058:	10801858 	cmpnei	r2,r2,97
 204905c:	10000a1e 	bne	r2,zero,2049088 <vfopen_locked+0x110>
      {
         if (vfp->data)
 2049060:	e0bffc17 	ldw	r2,-16(fp)
 2049064:	10800617 	ldw	r2,24(r2)
 2049068:	10000726 	beq	r2,zero,2049088 <vfopen_locked+0x110>
         {
            vop->cmploc = vfp->data + vfp->comp_size;
 204906c:	e0bffc17 	ldw	r2,-16(fp)
 2049070:	10c00617 	ldw	r3,24(r2)
 2049074:	e0bffc17 	ldw	r2,-16(fp)
 2049078:	10800817 	ldw	r2,32(r2)
 204907c:	1887883a 	add	r3,r3,r2
 2049080:	e0bffd17 	ldw	r2,-12(fp)
 2049084:	10c00215 	stw	r3,8(r2)
         }
      }

      /* if mode begins with 'w', truncate to end of file */
      if (*mode == 'w')
 2049088:	e0bfff17 	ldw	r2,-4(fp)
 204908c:	10800003 	ldbu	r2,0(r2)
 2049090:	10803fcc 	andi	r2,r2,255
 2049094:	1080201c 	xori	r2,r2,128
 2049098:	10bfe004 	addi	r2,r2,-128
 204909c:	10801dd8 	cmpnei	r2,r2,119
 20490a0:	1000111e 	bne	r2,zero,20490e8 <vfopen_locked+0x170>
      {
         /* set the size of the file before compression to 0 */
         vfp->real_size = 0;
 20490a4:	e0bffc17 	ldw	r2,-16(fp)
 20490a8:	10000715 	stw	zero,28(r2)
         /* set the size of the compressed data to 0 */
         vfp->comp_size = 0;
 20490ac:	e0bffc17 	ldw	r2,-16(fp)
 20490b0:	10000815 	stw	zero,32(r2)
         /* note we leave the pointer to the file buffer and its length
            alone since first writes will go to it */
         /* flag that the file has been modified */
         vfp->flags |= VF_STALE;
 20490b4:	e0bffc17 	ldw	r2,-16(fp)
 20490b8:	1080058b 	ldhu	r2,22(r2)
 20490bc:	10808014 	ori	r2,r2,512
 20490c0:	1007883a 	mov	r3,r2
 20490c4:	e0bffc17 	ldw	r2,-16(fp)
 20490c8:	10c0058d 	sth	r3,22(r2)

         /* turn off the compression flag */
         vfp->flags &= ~VF_HTMLCOMPRESSED;
 20490cc:	e0bffc17 	ldw	r2,-16(fp)
 20490d0:	10c0058b 	ldhu	r3,22(r2)
 20490d4:	00bfff84 	movi	r2,-2
 20490d8:	1884703a 	and	r2,r3,r2
 20490dc:	1007883a 	mov	r3,r2
 20490e0:	e0bffc17 	ldw	r2,-16(fp)
 20490e4:	10c0058d 	sth	r3,22(r2)
      }

#endif   /* HT_RWVFS */

      return vop;
 20490e8:	e0bffd17 	ldw	r2,-12(fp)
 20490ec:	00006b06 	br	204929c <vfopen_locked+0x324>

#ifdef HT_EXTDEV

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 20490f0:	e0bfff17 	ldw	r2,-4(fp)
 20490f4:	10800003 	ldbu	r2,0(r2)
 20490f8:	10803fcc 	andi	r2,r2,255
 20490fc:	1080201c 	xori	r2,r2,128
 2049100:	10bfe004 	addi	r2,r2,-128
 2049104:	10801ca0 	cmpeqi	r2,r2,114
 2049108:	1000121e 	bne	r2,zero,2049154 <vfopen_locked+0x1dc>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 204910c:	d0a0cb17 	ldw	r2,-31956(gp)
 2049110:	e0bffb15 	stw	r2,-20(fp)
 2049114:	00000d06 	br	204914c <vfopen_locked+0x1d4>
      {
         if ((vop = vfs->r_fopen(name, mode)) != NULL)
 2049118:	e0bffb17 	ldw	r2,-20(fp)
 204911c:	10800117 	ldw	r2,4(r2)
 2049120:	e13ffe17 	ldw	r4,-8(fp)
 2049124:	e17fff17 	ldw	r5,-4(fp)
 2049128:	103ee83a 	callr	r2
 204912c:	e0bffd15 	stw	r2,-12(fp)
 2049130:	e0bffd17 	ldw	r2,-12(fp)
 2049134:	10000226 	beq	r2,zero,2049140 <vfopen_locked+0x1c8>
         {
            return vop;
 2049138:	e0bffd17 	ldw	r2,-12(fp)
 204913c:	00005706 	br	204929c <vfopen_locked+0x324>
   {
      /* see if one of the other systems wants to create this file */
      /* if none of the below devices can open the file, continue on */
      struct vfroutines *  vfs;

      for (vfs = vfsystems; vfs; vfs = vfs->next)
 2049140:	e0bffb17 	ldw	r2,-20(fp)
 2049144:	10800017 	ldw	r2,0(r2)
 2049148:	e0bffb15 	stw	r2,-20(fp)
 204914c:	e0bffb17 	ldw	r2,-20(fp)
 2049150:	103ff11e 	bne	r2,zero,2049118 <vfopen_locked+0x1a0>

#ifdef HT_RWVFS

   /* if the mode implies that the file should be created if it
      does not exist */
   if (*mode != 'r')
 2049154:	e0bfff17 	ldw	r2,-4(fp)
 2049158:	10800003 	ldbu	r2,0(r2)
 204915c:	10803fcc 	andi	r2,r2,255
 2049160:	1080201c 	xori	r2,r2,128
 2049164:	10bfe004 	addi	r2,r2,-128
 2049168:	10801ca0 	cmpeqi	r2,r2,114
 204916c:	1000481e 	bne	r2,zero,2049290 <vfopen_locked+0x318>
   {
      /* enforce maximum number of files */
      if (vfs_total_dyna_files >= VFS_MAX_DYNA_FILES)
 2049170:	d0a0d217 	ldw	r2,-31928(gp)
 2049174:	10803ff0 	cmpltui	r2,r2,255
 2049178:	1000041e 	bne	r2,zero,204918c <vfopen_locked+0x214>
      {
         set_vfopen_error(ENP_NOMEM);
 204917c:	013ffb04 	movi	r4,-20
 2049180:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_total_dyna_files too big in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 2049184:	0005883a 	mov	r2,zero
 2049188:	00004406 	br	204929c <vfopen_locked+0x324>
      }

      /* make sure the file name is not too long for the VFS */
      if (strlen(name) > FILENAMEMAX)
 204918c:	e13ffe17 	ldw	r4,-8(fp)
 2049190:	2007c640 	call	2007c64 <strlen>
 2049194:	10800470 	cmpltui	r2,r2,17
 2049198:	1000041e 	bne	r2,zero,20491ac <vfopen_locked+0x234>
      {
         set_vfopen_error(ENP_PARAM);
 204919c:	013ffd84 	movi	r4,-10
 20491a0:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("file name too long in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 20491a4:	0005883a 	mov	r2,zero
 20491a8:	00003c06 	br	204929c <vfopen_locked+0x324>
      }

      /* allocate a vfs_file structure to hold the new file entry in */
      vfp = VFS_VFS_FILE_ALLOC();
 20491ac:	01000b04 	movi	r4,44
 20491b0:	20290400 	call	2029040 <npalloc>
 20491b4:	e0bffc15 	stw	r2,-16(fp)

      /* check for memory allocation failure */
      if (!vfp)
 20491b8:	e0bffc17 	ldw	r2,-16(fp)
 20491bc:	1000041e 	bne	r2,zero,20491d0 <vfopen_locked+0x258>
      {
         set_vfopen_error(ENP_NOMEM);
 20491c0:	013ffb04 	movi	r4,-20
 20491c4:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("VFS_VFS_FILE_ALLOC() failed in vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 20491c8:	0005883a 	mov	r2,zero
 20491cc:	00003306 	br	204929c <vfopen_locked+0x324>
      }

      /* allocate a VFILE structure to represent the open file */
      vop = vf_alloc_and_link_vop();
 20491d0:	2048df40 	call	2048df4 <vf_alloc_and_link_vop>
 20491d4:	e0bffd15 	stw	r2,-12(fp)

      /* check for memory allocation failure */
      if (!vop)
 20491d8:	e0bffd17 	ldw	r2,-12(fp)
 20491dc:	1000061e 	bne	r2,zero,20491f8 <vfopen_locked+0x280>
      {
         VFS_VFS_FILE_FREE(vfp); /* free the allocated vfs_file entry */
 20491e0:	e13ffc17 	ldw	r4,-16(fp)
 20491e4:	202912c0 	call	202912c <npfree>
         set_vfopen_error(ENP_NOMEM);
 20491e8:	013ffb04 	movi	r4,-20
 20491ec:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
         dprintf("vf_alloc_and_link_vop() failed 2\n");
#endif   /* VFS_VERBOSE */
         return NULL;
 20491f0:	0005883a 	mov	r2,zero
 20491f4:	00002906 	br	204929c <vfopen_locked+0x324>
      }

      /* add the vfs_file structure to the head of the list */

      vfp->next = vfsfiles;
 20491f8:	d0e0cd17 	ldw	r3,-31948(gp)
 20491fc:	e0bffc17 	ldw	r2,-16(fp)
 2049200:	10c00015 	stw	r3,0(r2)
      vfsfiles = vfp;
 2049204:	e0bffc17 	ldw	r2,-16(fp)
 2049208:	d0a0cd15 	stw	r2,-31948(gp)

      /* increment count of total files */
      vfs_total_dyna_files++;
 204920c:	d0a0d217 	ldw	r2,-31928(gp)
 2049210:	10800044 	addi	r2,r2,1
 2049214:	d0a0d215 	stw	r2,-31928(gp)

      /* remove leading directory separator before storing name */
      if (*name == '/' || *name == '\\')
 2049218:	e0bffe17 	ldw	r2,-8(fp)
 204921c:	10800003 	ldbu	r2,0(r2)
 2049220:	10803fcc 	andi	r2,r2,255
 2049224:	1080201c 	xori	r2,r2,128
 2049228:	10bfe004 	addi	r2,r2,-128
 204922c:	10800be0 	cmpeqi	r2,r2,47
 2049230:	1000071e 	bne	r2,zero,2049250 <vfopen_locked+0x2d8>
 2049234:	e0bffe17 	ldw	r2,-8(fp)
 2049238:	10800003 	ldbu	r2,0(r2)
 204923c:	10803fcc 	andi	r2,r2,255
 2049240:	1080201c 	xori	r2,r2,128
 2049244:	10bfe004 	addi	r2,r2,-128
 2049248:	10801718 	cmpnei	r2,r2,92
 204924c:	1000031e 	bne	r2,zero,204925c <vfopen_locked+0x2e4>
         name++;
 2049250:	e0bffe17 	ldw	r2,-8(fp)
 2049254:	10800044 	addi	r2,r2,1
 2049258:	e0bffe15 	stw	r2,-8(fp)

      /* store the converted name in the directory entry structure */
      strcpy(vfp->name,name);
 204925c:	e0bffc17 	ldw	r2,-16(fp)
 2049260:	10800104 	addi	r2,r2,4
 2049264:	1009883a 	mov	r4,r2
 2049268:	e17ffe17 	ldw	r5,-8(fp)
 204926c:	200756c0 	call	200756c <strcpy>

      /* set the flags */
      vfp->flags = VF_DYNAMICINFO   /* the directory entry was allocated */
 2049270:	e0bffc17 	ldw	r2,-16(fp)
 2049274:	00c0d804 	movi	r3,864
 2049278:	10c0058d 	sth	r3,22(r2)
       * note that this means the data pointer contains a null 
       * because we don't allocate any buffer to hold the data 
       * in until the first write 
       */
      /* link to the file's directory entry structure */
      vop->file = vfp;
 204927c:	e0bffd17 	ldw	r2,-12(fp)
 2049280:	e0fffc17 	ldw	r3,-16(fp)
 2049284:	10c00115 	stw	r3,4(r2)
      /* the cmploc and tag fields of the vop retain their NULLs from 
       * npalloc(). cmploc contains NULL because there is no data 
       * buffer to point to yet. tag contains NULL because no 
       * decompression operation has started yet
       */
      return vop;
 2049288:	e0bffd17 	ldw	r2,-12(fp)
 204928c:	00000306 	br	204929c <vfopen_locked+0x324>
   /* pass the open to the local file system */
   return (VFILE *) fopen(name,mode);

#else

   set_vfopen_error(ENP_NOFILE);
 2049290:	013ff9c4 	movi	r4,-25
 2049294:	2048dac0 	call	2048dac <set_vfopen_error>
#ifdef VFS_VERBOSE
   dprintf("fell thru to end of vfopen_locked()\n");
#endif   /* VFS_VERBOSE */
   return NULL;
 2049298:	0005883a 	mov	r2,zero

#endif   /* HT_LOCALFS */
}
 204929c:	e037883a 	mov	sp,fp
 20492a0:	dfc00117 	ldw	ra,4(sp)
 20492a4:	df000017 	ldw	fp,0(sp)
 20492a8:	dec00204 	addi	sp,sp,8
 20492ac:	f800283a 	ret

020492b0 <vfopen>:
 * RETURNS: 
 */

VFILE *
vfopen(char * name, char * mode)
{
 20492b0:	defffb04 	addi	sp,sp,-20
 20492b4:	dfc00415 	stw	ra,16(sp)
 20492b8:	df000315 	stw	fp,12(sp)
 20492bc:	df000304 	addi	fp,sp,12
 20492c0:	e13ffe15 	stw	r4,-8(fp)
 20492c4:	e17fff15 	stw	r5,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfopen() passed >%s<,%s\n",name,mode);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 20492c8:	01000144 	movi	r4,5
 20492cc:	2028c100 	call	2028c10 <wait_app_sem>

   vfd = vfopen_locked(name,mode);
 20492d0:	e13ffe17 	ldw	r4,-8(fp)
 20492d4:	e17fff17 	ldw	r5,-4(fp)
 20492d8:	2048f780 	call	2048f78 <vfopen_locked>
 20492dc:	e0bffd15 	stw	r2,-12(fp)

   vfs_unlock();
 20492e0:	01000144 	movi	r4,5
 20492e4:	2028ccc0 	call	2028ccc <post_app_sem>

   return vfd;
 20492e8:	e0bffd17 	ldw	r2,-12(fp)
}
 20492ec:	e037883a 	mov	sp,fp
 20492f0:	dfc00117 	ldw	ra,4(sp)
 20492f4:	df000017 	ldw	fp,0(sp)
 20492f8:	dec00204 	addi	sp,sp,8
 20492fc:	f800283a 	ret

02049300 <vfclose_locked>:
 * RETURNS: 
 */

void 
vfclose_locked(VFILE * vfd)
{
 2049300:	defff804 	addi	sp,sp,-32
 2049304:	dfc00715 	stw	ra,28(sp)
 2049308:	df000615 	stw	fp,24(sp)
 204930c:	df000604 	addi	fp,sp,24
 2049310:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;
   VFILE * vlast;

   vlast = NULL;
 2049314:	e03ffb15 	stw	zero,-20(fp)

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
 2049318:	d0a0cc17 	ldw	r2,-31952(gp)
 204931c:	e0bffa15 	stw	r2,-24(fp)
   while (vtmp)
 2049320:	00000806 	br	2049344 <vfclose_locked+0x44>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
 2049324:	e0ffff17 	ldw	r3,-4(fp)
 2049328:	e0bffa17 	ldw	r2,-24(fp)
 204932c:	18800826 	beq	r3,r2,2049350 <vfclose_locked+0x50>
         break;

      /* bump the next and previous pointers along to try the next one */
      vlast = vtmp;
 2049330:	e0bffa17 	ldw	r2,-24(fp)
 2049334:	e0bffb15 	stw	r2,-20(fp)
      vtmp = vtmp->next;
 2049338:	e0bffa17 	ldw	r2,-24(fp)
 204933c:	10800017 	ldw	r2,0(r2)
 2049340:	e0bffa15 	stw	r2,-24(fp)
   vlast = NULL;

   /* see if vfd is in our list of open virtual files. We
      can't use isvfile() since we need a pointer to last. */
   vtmp = vfiles;
   while (vtmp)
 2049344:	e0bffa17 	ldw	r2,-24(fp)
 2049348:	103ff61e 	bne	r2,zero,2049324 <vfclose_locked+0x24>
 204934c:	00000106 	br	2049354 <vfclose_locked+0x54>
   {
      /* if this is the one we are looking for, exist search loop */
      if (vfd == vtmp)
         break;
 2049350:	0001883a 	nop
      vlast = vtmp;
      vtmp = vtmp->next;
   }

   /* if the passed in handle was not in the list we maintain */
   if (vfd != vtmp)
 2049354:	e0ffff17 	ldw	r3,-4(fp)
 2049358:	e0bffa17 	ldw	r2,-24(fp)
 204935c:	1880511e 	bne	r3,r2,20494a4 <vfclose_locked+0x1a4>

   /* this not really a forever loop. it exists so we can break easily
      and deal with all the ifdefs */
   while (1)
   {
      struct vfs_file * vfp   =  vfd->file;
 2049360:	e0bfff17 	ldw	r2,-4(fp)
 2049364:	10800117 	ldw	r2,4(r2)
 2049368:	e0bffc15 	stw	r2,-16(fp)
      /* vfd->file will be null if somebody unlinked the file after
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
 204936c:	e0bffc17 	ldw	r2,-16(fp)
 2049370:	10003826 	beq	r2,zero,2049454 <vfclose_locked+0x154>
         break;
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 2049374:	e0bffc17 	ldw	r2,-16(fp)
 2049378:	10800a17 	ldw	r2,40(r2)
 204937c:	10000826 	beq	r2,zero,20493a0 <vfclose_locked+0xa0>
      {
         /* call that file system's fclose() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)(vfp->method);
 2049380:	e0bffc17 	ldw	r2,-16(fp)
 2049384:	10800a17 	ldw	r2,40(r2)
 2049388:	e0bffd15 	stw	r2,-12(fp)

         vfs->r_fclose(vfd);
 204938c:	e0bffd17 	ldw	r2,-12(fp)
 2049390:	10800217 	ldw	r2,8(r2)
 2049394:	e13fff17 	ldw	r4,-4(fp)
 2049398:	103ee83a 	callr	r2
         break;   /* break to list deletion code after end of phoney loop */
 204939c:	00003006 	br	2049460 <vfclose_locked+0x160>

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 20493a0:	e0bffc17 	ldw	r2,-16(fp)
 20493a4:	1080058b 	ldhu	r2,22(r2)
 20493a8:	10bfffcc 	andi	r2,r2,65535
 20493ac:	1080200c 	andi	r2,r2,128
 20493b0:	10002a26 	beq	r2,zero,204945c <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 20493b4:	e0bffc17 	ldw	r2,-16(fp)
 20493b8:	10c00917 	ldw	r3,36(r2)
 20493bc:	e0bffc17 	ldw	r2,-16(fp)
 20493c0:	10800817 	ldw	r2,32(r2)
 20493c4:	1885c83a 	sub	r2,r3,r2

      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
 20493c8:	10804030 	cmpltui	r2,r2,256
 20493cc:	1000231e 	bne	r2,zero,204945c <vfclose_locked+0x15c>
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
          vfp->data) /* this last test is a sanity check */
 20493d0:	e0bffc17 	ldw	r2,-16(fp)
 20493d4:	10800617 	ldw	r2,24(r2)
      /* if the buffer containing the data was allocated dynamically, 
       * and there are VFS_CLOSE_FRAG_FLOOR bytes of unused data 
       * between the end of the file and the end of the buffer 
       */
      if ((vfp->flags & VF_DYNAMICDATA) &&
          ((vfp->buf_size - vfp->comp_size) > VFS_CLOSE_FRAG_FLOOR) &&
 20493d8:	10002026 	beq	r2,zero,204945c <vfclose_locked+0x15c>
          vfp->data) /* this last test is a sanity check */
      {
         /* try to reclaim the unused data */

         /* allocate a new buffer just big enough for the data */
         new_buffer = vf_alloc_buffer(vfp->comp_size);
 20493dc:	e0bffc17 	ldw	r2,-16(fp)
 20493e0:	10800817 	ldw	r2,32(r2)
 20493e4:	1009883a 	mov	r4,r2
 20493e8:	2048e640 	call	2048e64 <vf_alloc_buffer>
 20493ec:	e0bffe15 	stw	r2,-8(fp)

         /* if the allocation worked */
         if (new_buffer)
 20493f0:	e0bffe17 	ldw	r2,-8(fp)
 20493f4:	10001926 	beq	r2,zero,204945c <vfclose_locked+0x15c>
         {
            /* copy the old buffer to the new one */
            MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 20493f8:	e0bffc17 	ldw	r2,-16(fp)
 20493fc:	10c00617 	ldw	r3,24(r2)
 2049400:	e0bffc17 	ldw	r2,-16(fp)
 2049404:	10800817 	ldw	r2,32(r2)
 2049408:	e13ffe17 	ldw	r4,-8(fp)
 204940c:	180b883a 	mov	r5,r3
 2049410:	100d883a 	mov	r6,r2
 2049414:	200660c0 	call	200660c <memcpy>
            /* free the old buffer */
            vf_free_buffer(vfp->data,vfp->buf_size);
 2049418:	e0bffc17 	ldw	r2,-16(fp)
 204941c:	10c00617 	ldw	r3,24(r2)
 2049420:	e0bffc17 	ldw	r2,-16(fp)
 2049424:	10800917 	ldw	r2,36(r2)
 2049428:	1809883a 	mov	r4,r3
 204942c:	100b883a 	mov	r5,r2
 2049430:	2048f2c0 	call	2048f2c <vf_free_buffer>
            /* update the buffer pointer and size to reflect the
               just big enough buffer */
            vfp->data = new_buffer;
 2049434:	e0bffc17 	ldw	r2,-16(fp)
 2049438:	e0fffe17 	ldw	r3,-8(fp)
 204943c:	10c00615 	stw	r3,24(r2)
            vfp->buf_size = vfp->comp_size;
 2049440:	e0bffc17 	ldw	r2,-16(fp)
 2049444:	10c00817 	ldw	r3,32(r2)
 2049448:	e0bffc17 	ldw	r2,-16(fp)
 204944c:	10c00915 	stw	r3,36(r2)
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 2049450:	00000206 	br	204945c <vfclose_locked+0x15c>
       * this handle was created to point to it. if the file itself 
       * is gone there is nothing left to do, so break to list 
       * deletion code at bottom of loop
       */
      if (vfp == NULL)
         break;
 2049454:	0001883a 	nop
 2049458:	00000106 	br	2049460 <vfclose_locked+0x160>
#endif   /* VFS_AUTO_SYNC */

#endif   /* HT_RWVFS */

      /* break to list deletion code below */
      break;
 204945c:	0001883a 	nop

   }

   if (vlast)  /* unlink from list of open files */
 2049460:	e0bffb17 	ldw	r2,-20(fp)
 2049464:	10000526 	beq	r2,zero,204947c <vfclose_locked+0x17c>
      vlast->next = vtmp->next;
 2049468:	e0bffa17 	ldw	r2,-24(fp)
 204946c:	10c00017 	ldw	r3,0(r2)
 2049470:	e0bffb17 	ldw	r2,-20(fp)
 2049474:	10c00015 	stw	r3,0(r2)
 2049478:	00000306 	br	2049488 <vfclose_locked+0x188>
   else
      vfiles = vtmp->next;
 204947c:	e0bffa17 	ldw	r2,-24(fp)
 2049480:	10800017 	ldw	r2,0(r2)
 2049484:	d0a0cc15 	stw	r2,-31952(gp)

   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
 2049488:	e13ffa17 	ldw	r4,-24(fp)
 204948c:	202912c0 	call	202912c <npfree>
   /* decrement the number of open files */
   vfs_open_files--;
 2049490:	d0a0d017 	ldw	r2,-31936(gp)
 2049494:	10bfffc4 	addi	r2,r2,-1
 2049498:	d0a0d015 	stw	r2,-31936(gp)
   return;
 204949c:	0001883a 	nop
 20494a0:	00000106 	br	20494a8 <vfclose_locked+0x1a8>

#ifdef HT_LOCALFS
      /* default to call on local system */
      fclose((FILE*)vfd);
#endif   /* HT_LOCALFS */
      return;
 20494a4:	0001883a 	nop
   /* free structure addressed by open handle */
   VFS_VFS_OPEN_FREE(vtmp);
   /* decrement the number of open files */
   vfs_open_files--;
   return;
}
 20494a8:	e037883a 	mov	sp,fp
 20494ac:	dfc00117 	ldw	ra,4(sp)
 20494b0:	df000017 	ldw	fp,0(sp)
 20494b4:	dec00204 	addi	sp,sp,8
 20494b8:	f800283a 	ret

020494bc <vfclose>:
 *
 * RETURNS: 
 */

void vfclose(VFILE * vfd)
{
 20494bc:	defffd04 	addi	sp,sp,-12
 20494c0:	dfc00215 	stw	ra,8(sp)
 20494c4:	df000115 	stw	fp,4(sp)
 20494c8:	df000104 	addi	fp,sp,4
 20494cc:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 20494d0:	01000144 	movi	r4,5
 20494d4:	2028c100 	call	2028c10 <wait_app_sem>

   vfclose_locked(vfd);
 20494d8:	e13fff17 	ldw	r4,-4(fp)
 20494dc:	20493000 	call	2049300 <vfclose_locked>

   vfs_unlock();
 20494e0:	01000144 	movi	r4,5
 20494e4:	2028ccc0 	call	2028ccc <post_app_sem>
}
 20494e8:	e037883a 	mov	sp,fp
 20494ec:	dfc00117 	ldw	ra,4(sp)
 20494f0:	df000017 	ldw	fp,0(sp)
 20494f4:	dec00204 	addi	sp,sp,8
 20494f8:	f800283a 	ret

020494fc <vfflush>:
 *
 * RETURNS: 
 */

int vfflush(VFILE * vfd)
{
 20494fc:	defffd04 	addi	sp,sp,-12
 2049500:	dfc00215 	stw	ra,8(sp)
 2049504:	df000115 	stw	fp,4(sp)
 2049508:	df000104 	addi	fp,sp,4
 204950c:	e13fff15 	stw	r4,-4(fp)
   vfs_lock();
 2049510:	01000144 	movi	r4,5
 2049514:	2028c100 	call	2028c10 <wait_app_sem>

   printf("vfflush(): This function needs to be implemented\n");
 2049518:	01008174 	movhi	r4,517
 204951c:	21079704 	addi	r4,r4,7772
 2049520:	2006cb40 	call	2006cb4 <puts>

   vfs_unlock();
 2049524:	01000144 	movi	r4,5
 2049528:	2028ccc0 	call	2028ccc <post_app_sem>
   return(0);
 204952c:	0005883a 	mov	r2,zero
}
 2049530:	e037883a 	mov	sp,fp
 2049534:	dfc00117 	ldw	ra,4(sp)
 2049538:	df000017 	ldw	fp,0(sp)
 204953c:	dec00204 	addi	sp,sp,8
 2049540:	f800283a 	ret

02049544 <vfgets>:

char * vfgets(char * s, int lim, VFILE * fp) 
{
 2049544:	defff904 	addi	sp,sp,-28
 2049548:	dfc00615 	stw	ra,24(sp)
 204954c:	df000515 	stw	fp,20(sp)
 2049550:	df000504 	addi	fp,sp,20
 2049554:	e13ffd15 	stw	r4,-12(fp)
 2049558:	e17ffe15 	stw	r5,-8(fp)
 204955c:	e1bfff15 	stw	r6,-4(fp)
   int c;
   char * ret;

   ret = s;
 2049560:	e0bffd17 	ldw	r2,-12(fp)
 2049564:	e0bffc15 	stw	r2,-16(fp)
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 2049568:	00000f06 	br	20495a8 <vfgets+0x64>
      if (( *ret ++ = c) == '\n')
 204956c:	e0bffb17 	ldw	r2,-20(fp)
 2049570:	1007883a 	mov	r3,r2
 2049574:	e0bffc17 	ldw	r2,-16(fp)
 2049578:	10c00005 	stb	r3,0(r2)
 204957c:	e0bffc17 	ldw	r2,-16(fp)
 2049580:	10800003 	ldbu	r2,0(r2)
 2049584:	10803fcc 	andi	r2,r2,255
 2049588:	1080201c 	xori	r2,r2,128
 204958c:	10bfe004 	addi	r2,r2,-128
 2049590:	108002a0 	cmpeqi	r2,r2,10
 2049594:	e0fffc17 	ldw	r3,-16(fp)
 2049598:	18c00044 	addi	r3,r3,1
 204959c:	e0fffc15 	stw	r3,-16(fp)
 20495a0:	10803fcc 	andi	r2,r2,255
 20495a4:	10000c1e 	bne	r2,zero,20495d8 <vfgets+0x94>
{
   int c;
   char * ret;

   ret = s;
   while ( --lim > 0 && (c = vgetc(fp)) != EOF)
 20495a8:	e0bffe17 	ldw	r2,-8(fp)
 20495ac:	10bfffc4 	addi	r2,r2,-1
 20495b0:	e0bffe15 	stw	r2,-8(fp)
 20495b4:	e0bffe17 	ldw	r2,-8(fp)
 20495b8:	0080080e 	bge	zero,r2,20495dc <vfgets+0x98>
 20495bc:	e13fff17 	ldw	r4,-4(fp)
 20495c0:	204a1b00 	call	204a1b0 <vgetc>
 20495c4:	e0bffb15 	stw	r2,-20(fp)
 20495c8:	e0bffb17 	ldw	r2,-20(fp)
 20495cc:	10bfffd8 	cmpnei	r2,r2,-1
 20495d0:	103fe61e 	bne	r2,zero,204956c <vfgets+0x28>
 20495d4:	00000106 	br	20495dc <vfgets+0x98>
      if (( *ret ++ = c) == '\n')
         break;
 20495d8:	0001883a 	nop
   *ret = '\0';
 20495dc:	e0bffc17 	ldw	r2,-16(fp)
 20495e0:	10000005 	stb	zero,0(r2)
   return ( c == EOF && ret == s) ? NULL : s;
 20495e4:	e0bffb17 	ldw	r2,-20(fp)
 20495e8:	10bfffd8 	cmpnei	r2,r2,-1
 20495ec:	1000031e 	bne	r2,zero,20495fc <vfgets+0xb8>
 20495f0:	e0fffc17 	ldw	r3,-16(fp)
 20495f4:	e0bffd17 	ldw	r2,-12(fp)
 20495f8:	18800226 	beq	r3,r2,2049604 <vfgets+0xc0>
 20495fc:	e0bffd17 	ldw	r2,-12(fp)
 2049600:	00000106 	br	2049608 <vfgets+0xc4>
 2049604:	0005883a 	mov	r2,zero
}
 2049608:	e037883a 	mov	sp,fp
 204960c:	dfc00117 	ldw	ra,4(sp)
 2049610:	df000017 	ldw	fp,0(sp)
 2049614:	dec00204 	addi	sp,sp,8
 2049618:	f800283a 	ret

0204961c <vfeof>:
 *
 * RETURNS: 1 if the file pointer is at EOF, otherwise 0
 */
 
int vfeof(VFILE * vfd)
{
 204961c:	defffc04 	addi	sp,sp,-16
 2049620:	dfc00315 	stw	ra,12(sp)
 2049624:	df000215 	stw	fp,8(sp)
 2049628:	df000204 	addi	fp,sp,8
 204962c:	e13fff15 	stw	r4,-4(fp)
   int c = 0;
 2049630:	e03ffe15 	stw	zero,-8(fp)

#ifdef HT_LOCALFS
   return(feof((FILE*)vfd));
#endif
   if ((c = vgetc(vfd)) == EOF )
 2049634:	e13fff17 	ldw	r4,-4(fp)
 2049638:	204a1b00 	call	204a1b0 <vgetc>
 204963c:	e0bffe15 	stw	r2,-8(fp)
 2049640:	e0bffe17 	ldw	r2,-8(fp)
 2049644:	10bfffd8 	cmpnei	r2,r2,-1
 2049648:	1000021e 	bne	r2,zero,2049654 <vfeof+0x38>
   {
      return 1;
 204964c:	00800044 	movi	r2,1
 2049650:	00000106 	br	2049658 <vfeof+0x3c>
   }   
   return 0;
 2049654:	0005883a 	mov	r2,zero
}
 2049658:	e037883a 	mov	sp,fp
 204965c:	dfc00117 	ldw	ra,4(sp)
 2049660:	df000017 	ldw	fp,0(sp)
 2049664:	dec00204 	addi	sp,sp,8
 2049668:	f800283a 	ret

0204966c <vunlink_flag_open_files>:
 *
 * RETURNS: 
 */

void vunlink_flag_open_files(struct vfs_file * vfp)
{
 204966c:	defffd04 	addi	sp,sp,-12
 2049670:	df000215 	stw	fp,8(sp)
 2049674:	df000204 	addi	fp,sp,8
 2049678:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 204967c:	d0a0cc17 	ldw	r2,-31952(gp)
 2049680:	e0bffe15 	stw	r2,-8(fp)
 2049684:	00000906 	br	20496ac <vunlink_flag_open_files+0x40>
   {
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
 2049688:	e0bffe17 	ldw	r2,-8(fp)
 204968c:	10c00117 	ldw	r3,4(r2)
 2049690:	e0bfff17 	ldw	r2,-4(fp)
 2049694:	1880021e 	bne	r3,r2,20496a0 <vunlink_flag_open_files+0x34>
         vtmp->file = NULL;
 2049698:	e0bffe17 	ldw	r2,-8(fp)
 204969c:	10000115 	stw	zero,4(r2)
void vunlink_flag_open_files(struct vfs_file * vfp)
{
   VFILE * vtmp;

   /* for all open files */
   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 20496a0:	e0bffe17 	ldw	r2,-8(fp)
 20496a4:	10800017 	ldw	r2,0(r2)
 20496a8:	e0bffe15 	stw	r2,-8(fp)
 20496ac:	e0bffe17 	ldw	r2,-8(fp)
 20496b0:	103ff51e 	bne	r2,zero,2049688 <vunlink_flag_open_files+0x1c>
      /* if the open file handle is referencing the file we are
         deleting, set that reference to NULL */
      if (vtmp->file == vfp)
         vtmp->file = NULL;
   }
}
 20496b4:	e037883a 	mov	sp,fp
 20496b8:	df000017 	ldw	fp,0(sp)
 20496bc:	dec00104 	addi	sp,sp,4
 20496c0:	f800283a 	ret

020496c4 <vunlink>:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
int
vunlink(const char * const_name)
{
 20496c4:	defff604 	addi	sp,sp,-40
 20496c8:	dfc00915 	stw	ra,36(sp)
 20496cc:	df000815 	stw	fp,32(sp)
 20496d0:	df000804 	addi	fp,sp,32
 20496d4:	e13fff15 	stw	r4,-4(fp)
   struct vfs_file * vfp;
   int   rc =  0;
 20496d8:	e03ff815 	stw	zero,-32(fp)
/*
 * Altera Niche Stack Nios port modification:
 * Change prototype from char * name to const char to
 * follow C library standard.
 */
   char * name = malloc(strlen(const_name)+1);
 20496dc:	e13fff17 	ldw	r4,-4(fp)
 20496e0:	2007c640 	call	2007c64 <strlen>
 20496e4:	10800044 	addi	r2,r2,1
 20496e8:	1009883a 	mov	r4,r2
 20496ec:	204bd440 	call	204bd44 <malloc>
 20496f0:	e0bffb15 	stw	r2,-20(fp)
   strcpy(name, const_name);
 20496f4:	e13ffb17 	ldw	r4,-20(fp)
 20496f8:	e17fff17 	ldw	r5,-4(fp)
 20496fc:	200756c0 	call	200756c <strcpy>
   if (vfs_log_file_name)
      dprintf("vunlink() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 2049700:	01000144 	movi	r4,5
 2049704:	2028c100 	call	2028c10 <wait_app_sem>

   /* see if the converted name is one of the one's in our list */
   /* if it isn't */
   if ((vfp = vfslookup_locked(name)) == NULL)
 2049708:	e13ffb17 	ldw	r4,-20(fp)
 204970c:	204a1f80 	call	204a1f8 <vfslookup_locked>
 2049710:	e0bffc15 	stw	r2,-16(fp)
 2049714:	e0bffc17 	ldw	r2,-16(fp)
 2049718:	1000061e 	bne	r2,zero,2049734 <vunlink+0x70>
   {
      vfs_unlock();
 204971c:	01000144 	movi	r4,5
 2049720:	2028ccc0 	call	2028ccc <post_app_sem>
#ifdef HT_LOCALFS
      /* default to call on local system */
      return remove(name);
#else
      /* no local file system, so return error condition */
      free(name);
 2049724:	e13ffb17 	ldw	r4,-20(fp)
 2049728:	204bd580 	call	204bd58 <free>
      return -1;
 204972c:	00bfffc4 	movi	r2,-1
 2049730:	00005f06 	br	20498b0 <vunlink+0x1ec>
#ifdef   HT_RWVFS
   /* save the next link pointer since in one path through the code, 
    * the vfs_file structure gets freed before its unlinked from the 
    * list
    */
   vfnext = vfp->next;
 2049734:	e0bffc17 	ldw	r2,-16(fp)
 2049738:	10800017 	ldw	r2,0(r2)
 204973c:	e0bffd15 	stw	r2,-12(fp)

   /* search list of files to determine predecessor in list */
   vflast = NULL;
 2049740:	e03ffa15 	stw	zero,-24(fp)
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 2049744:	d0a0cd17 	ldw	r2,-31948(gp)
 2049748:	e0bff915 	stw	r2,-28(fp)
 204974c:	00000806 	br	2049770 <vunlink+0xac>
   {
      if (vtmp == vfp)
 2049750:	e0fff917 	ldw	r3,-28(fp)
 2049754:	e0bffc17 	ldw	r2,-16(fp)
 2049758:	18800826 	beq	r3,r2,204977c <vunlink+0xb8>
         break;
      vflast = vtmp;
 204975c:	e0bff917 	ldw	r2,-28(fp)
 2049760:	e0bffa15 	stw	r2,-24(fp)
    */
   vfnext = vfp->next;

   /* search list of files to determine predecessor in list */
   vflast = NULL;
   for (vtmp = vfsfiles; vtmp != NULL; vtmp = vtmp->next)
 2049764:	e0bff917 	ldw	r2,-28(fp)
 2049768:	10800017 	ldw	r2,0(r2)
 204976c:	e0bff915 	stw	r2,-28(fp)
 2049770:	e0bff917 	ldw	r2,-28(fp)
 2049774:	103ff61e 	bne	r2,zero,2049750 <vunlink+0x8c>
 2049778:	00000106 	br	2049780 <vunlink+0xbc>
   {
      if (vtmp == vfp)
         break;
 204977c:	0001883a 	nop
      vflast = vtmp;
   }

   /* this shouldn't happen since vfslookup_locked() already searched
      the list, but just in case */
   if (vtmp == NULL)
 2049780:	e0bff917 	ldw	r2,-28(fp)
 2049784:	1000071e 	bne	r2,zero,20497a4 <vunlink+0xe0>
   {
      dtrap();
 2049788:	20285c80 	call	20285c8 <dtrap>
      vfs_unlock();
 204978c:	01000144 	movi	r4,5
 2049790:	2028ccc0 	call	2028ccc <post_app_sem>
      free(name);
 2049794:	e13ffb17 	ldw	r4,-20(fp)
 2049798:	204bd580 	call	204bd58 <free>
      return -1;
 204979c:	00bfffc4 	movi	r2,-1
 20497a0:	00004306 	br	20498b0 <vunlink+0x1ec>
   while (1)
   {

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfp->method)
 20497a4:	e0bffc17 	ldw	r2,-16(fp)
 20497a8:	10800a17 	ldw	r2,40(r2)
 20497ac:	10000926 	beq	r2,zero,20497d4 <vunlink+0x110>
      {
         /* call that file system's unlink() */
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfp->method);
 20497b0:	e0bffc17 	ldw	r2,-16(fp)
 20497b4:	10800a17 	ldw	r2,40(r2)
 20497b8:	e0bffe15 	stw	r2,-8(fp)

         rc = vfs->r_unlink(name);
 20497bc:	e0bffe17 	ldw	r2,-8(fp)
 20497c0:	10800817 	ldw	r2,32(r2)
 20497c4:	e13ffb17 	ldw	r4,-20(fp)
 20497c8:	103ee83a 	callr	r2
 20497cc:	e0bff815 	stw	r2,-32(fp)
         break;   /* break to list deletion code after end of phoney loop */
 20497d0:	00002606 	br	204986c <vunlink+0x1a8>
      }
#endif   /* HT_EXTDEV */

      /* if the file is not write enabled, return error condition */
      if (!(vfp->flags & VF_WRITE))
 20497d4:	e0bffc17 	ldw	r2,-16(fp)
 20497d8:	1080058b 	ldhu	r2,22(r2)
 20497dc:	10bfffcc 	andi	r2,r2,65535
 20497e0:	1080080c 	andi	r2,r2,32
 20497e4:	1000061e 	bne	r2,zero,2049800 <vunlink+0x13c>
      {
         vfs_unlock();
 20497e8:	01000144 	movi	r4,5
 20497ec:	2028ccc0 	call	2028ccc <post_app_sem>
         free(name);
 20497f0:	e13ffb17 	ldw	r4,-20(fp)
 20497f4:	204bd580 	call	204bd58 <free>
         return -1;
 20497f8:	00bfffc4 	movi	r2,-1
 20497fc:	00002c06 	br	20498b0 <vunlink+0x1ec>
      }

      /* if the data buffer containing the file's data was dynamically
         allocated and is not null */
      if ((vfp->flags & VF_DYNAMICDATA) && (vfp->data))
 2049800:	e0bffc17 	ldw	r2,-16(fp)
 2049804:	1080058b 	ldhu	r2,22(r2)
 2049808:	10bfffcc 	andi	r2,r2,65535
 204980c:	1080200c 	andi	r2,r2,128
 2049810:	10000a26 	beq	r2,zero,204983c <vunlink+0x178>
 2049814:	e0bffc17 	ldw	r2,-16(fp)
 2049818:	10800617 	ldw	r2,24(r2)
 204981c:	10000726 	beq	r2,zero,204983c <vunlink+0x178>
      {
         /* free the buffer */
         vf_free_buffer(vfp->data,vfp->buf_size);
 2049820:	e0bffc17 	ldw	r2,-16(fp)
 2049824:	10c00617 	ldw	r3,24(r2)
 2049828:	e0bffc17 	ldw	r2,-16(fp)
 204982c:	10800917 	ldw	r2,36(r2)
 2049830:	1809883a 	mov	r4,r3
 2049834:	100b883a 	mov	r5,r2
 2049838:	2048f2c0 	call	2048f2c <vf_free_buffer>
      }

      /* if the vfs_file structure itself was allocated dynamically */
      if (vfp->flags & VF_DYNAMICINFO)
 204983c:	e0bffc17 	ldw	r2,-16(fp)
 2049840:	1080058b 	ldhu	r2,22(r2)
 2049844:	10bfffcc 	andi	r2,r2,65535
 2049848:	1080100c 	andi	r2,r2,64
 204984c:	10000526 	beq	r2,zero,2049864 <vunlink+0x1a0>
      {
         /* decrement count of total files */
         vfs_total_dyna_files--;
 2049850:	d0a0d217 	ldw	r2,-31928(gp)
 2049854:	10bfffc4 	addi	r2,r2,-1
 2049858:	d0a0d215 	stw	r2,-31928(gp)

         /* free the vfs_file structure */
         VFS_VFS_FILE_FREE(vfp);
 204985c:	e13ffc17 	ldw	r4,-16(fp)
 2049860:	202912c0 	call	202912c <npfree>
         the vfs_file has been deleted from the list */
#ifdef VFS_AUTO_SYNC
      do_sync = 1;
#endif
      /* we were successful at our unlink */
      rc = 0;
 2049864:	e03ff815 	stw	zero,-32(fp)

      break;
 2049868:	0001883a 	nop
   }

   /* delete the vfs_file structure from the list headed by vfsfiles */
   if (vflast)
 204986c:	e0bffa17 	ldw	r2,-24(fp)
 2049870:	10000426 	beq	r2,zero,2049884 <vunlink+0x1c0>
      vflast->next = vfnext;
 2049874:	e0bffa17 	ldw	r2,-24(fp)
 2049878:	e0fffd17 	ldw	r3,-12(fp)
 204987c:	10c00015 	stw	r3,0(r2)
 2049880:	00000206 	br	204988c <vunlink+0x1c8>
   else
      vfsfiles = vfnext;
 2049884:	e0bffd17 	ldw	r2,-12(fp)
 2049888:	d0a0cd15 	stw	r2,-31948(gp)

   /* fix up references to deleted file in list of currently open VFILEs */
   vunlink_flag_open_files(vfp);
 204988c:	e13ffc17 	ldw	r4,-16(fp)
 2049890:	204966c0 	call	204966c <vunlink_flag_open_files>

   /* flag that the directory is stale so vfs_sync() knows it has to do
      something */
   vfs_dir_stale = TRUE;
 2049894:	00800044 	movi	r2,1
 2049898:	d0a0cf15 	stw	r2,-31940(gp)

   /* unlinks not allowed on read-only VFS */
   rc = -1;

#endif   /* HT_RWVFS */
   vfs_unlock();
 204989c:	01000144 	movi	r4,5
 20498a0:	2028ccc0 	call	2028ccc <post_app_sem>
   free(name);
 20498a4:	e13ffb17 	ldw	r4,-20(fp)
 20498a8:	204bd580 	call	204bd58 <free>
   return rc;
 20498ac:	e0bff817 	ldw	r2,-32(fp)
}
 20498b0:	e037883a 	mov	sp,fp
 20498b4:	dfc00117 	ldw	ra,4(sp)
 20498b8:	df000017 	ldw	fp,0(sp)
 20498bc:	dec00204 	addi	sp,sp,8
 20498c0:	f800283a 	ret

020498c4 <vfread>:
 * RETURNS: 
 */

int 
vfread(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 20498c4:	defff604 	addi	sp,sp,-40
 20498c8:	dfc00915 	stw	ra,36(sp)
 20498cc:	df000815 	stw	fp,32(sp)
 20498d0:	df000804 	addi	fp,sp,32
 20498d4:	e13ffc15 	stw	r4,-16(fp)
 20498d8:	e17ffd15 	stw	r5,-12(fp)
 20498dc:	e1bffe15 	stw	r6,-8(fp)
 20498e0:	e1ffff15 	stw	r7,-4(fp)
   unsigned bcount;  /* number of bytes put in caller's buffer */

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 20498e4:	01000144 	movi	r4,5
 20498e8:	2028c100 	call	2028c10 <wait_app_sem>

   /* if the file is in our list of open files */
   if (isvfile_locked(vfd))
 20498ec:	e13fff17 	ldw	r4,-4(fp)
 20498f0:	204a5380 	call	204a538 <isvfile_locked>
 20498f4:	10004e26 	beq	r2,zero,2049a30 <vfread+0x16c>
   {

#ifdef HT_RWVFS
      /* the caller is trying to read a handle to a file that's been
         deleted, so he gets 0 data back */
      if (vfd->file == NULL)
 20498f8:	e0bfff17 	ldw	r2,-4(fp)
 20498fc:	10800117 	ldw	r2,4(r2)
 2049900:	1000041e 	bne	r2,zero,2049914 <vfread+0x50>
      {
         vfs_unlock();
 2049904:	01000144 	movi	r4,5
 2049908:	2028ccc0 	call	2028ccc <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 204990c:	0005883a 	mov	r2,zero
 2049910:	00004a06 	br	2049a3c <vfread+0x178>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      /* if the file was created by an external file system */
      if (vfd->file->method)
 2049914:	e0bfff17 	ldw	r2,-4(fp)
 2049918:	10800117 	ldw	r2,4(r2)
 204991c:	10800a17 	ldw	r2,40(r2)
 2049920:	10001026 	beq	r2,zero,2049964 <vfread+0xa0>
      {
         struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 2049924:	e0bfff17 	ldw	r2,-4(fp)
 2049928:	10800117 	ldw	r2,4(r2)
 204992c:	10800a17 	ldw	r2,40(r2)
 2049930:	e0bff915 	stw	r2,-28(fp)
         int   rc;

         /* call that system's fread() */
         rc = vfs->r_fread(buf,size,items,vfd);
 2049934:	e0bff917 	ldw	r2,-28(fp)
 2049938:	10800317 	ldw	r2,12(r2)
 204993c:	e13ffc17 	ldw	r4,-16(fp)
 2049940:	e17ffd17 	ldw	r5,-12(fp)
 2049944:	e1bffe17 	ldw	r6,-8(fp)
 2049948:	e1ffff17 	ldw	r7,-4(fp)
 204994c:	103ee83a 	callr	r2
 2049950:	e0bffa15 	stw	r2,-24(fp)
         vfs_unlock();
 2049954:	01000144 	movi	r4,5
 2049958:	2028ccc0 	call	2028ccc <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return rc;
 204995c:	e0bffa17 	ldw	r2,-24(fp)
 2049960:	00003606 	br	2049a3c <vfread+0x178>
#ifdef HT_RWVFS
      /* the data pointer can be NULL if somebody tries to read from 
       * a freshly created file, in which case there is no data in 
       * the file, so return 0
       */
      if (!(vfd->file->data))
 2049964:	e0bfff17 	ldw	r2,-4(fp)
 2049968:	10800117 	ldw	r2,4(r2)
 204996c:	10800617 	ldw	r2,24(r2)
 2049970:	1000041e 	bne	r2,zero,2049984 <vfread+0xc0>
      {
         vfs_unlock();
 2049974:	01000144 	movi	r4,5
 2049978:	2028ccc0 	call	2028ccc <post_app_sem>
         IN_PROFILER(PF_FS, PF_EXIT);
         return 0;
 204997c:	0005883a 	mov	r2,zero
 2049980:	00002e06 	br	2049a3c <vfread+0x178>
      }
#endif   /* HT_RWVFS */

      bcount = items * size;  /* number of bytes to transfer */
 2049984:	e0fffe17 	ldw	r3,-8(fp)
 2049988:	e0bffd17 	ldw	r2,-12(fp)
 204998c:	1885383a 	mul	r2,r3,r2
 2049990:	e0bff815 	stw	r2,-32(fp)
         return(items); /* filled user buffer, return # items copied */
      }
      else  /* else fall to faster non-compression code */
#endif   /* HTML_COMPRESSION */
      {  /* get here to do simple uncompressed data read */
         unsigned location = vfd->cmploc - vfd->file->data;
 2049994:	e0bfff17 	ldw	r2,-4(fp)
 2049998:	10800217 	ldw	r2,8(r2)
 204999c:	1007883a 	mov	r3,r2
 20499a0:	e0bfff17 	ldw	r2,-4(fp)
 20499a4:	10800117 	ldw	r2,4(r2)
 20499a8:	10800617 	ldw	r2,24(r2)
 20499ac:	1885c83a 	sub	r2,r3,r2
 20499b0:	e0bffb15 	stw	r2,-20(fp)

         if (((unsigned long)location + bcount) > vfd->file->comp_size)
 20499b4:	e0fffb17 	ldw	r3,-20(fp)
 20499b8:	e0bff817 	ldw	r2,-32(fp)
 20499bc:	1885883a 	add	r2,r3,r2
 20499c0:	e0ffff17 	ldw	r3,-4(fp)
 20499c4:	18c00117 	ldw	r3,4(r3)
 20499c8:	18c00817 	ldw	r3,32(r3)
 20499cc:	1880062e 	bgeu	r3,r2,20499e8 <vfread+0x124>
            bcount = (unsigned)(vfd->file->comp_size - location);
 20499d0:	e0bfff17 	ldw	r2,-4(fp)
 20499d4:	10800117 	ldw	r2,4(r2)
 20499d8:	10c00817 	ldw	r3,32(r2)
 20499dc:	e0bffb17 	ldw	r2,-20(fp)
 20499e0:	1885c83a 	sub	r2,r3,r2
 20499e4:	e0bff815 	stw	r2,-32(fp)
         MEMCPY(buf, vfd->cmploc, bcount);
 20499e8:	e0bfff17 	ldw	r2,-4(fp)
 20499ec:	10800217 	ldw	r2,8(r2)
 20499f0:	e13ffc17 	ldw	r4,-16(fp)
 20499f4:	100b883a 	mov	r5,r2
 20499f8:	e1bff817 	ldw	r6,-32(fp)
 20499fc:	200660c0 	call	200660c <memcpy>
         vfd->cmploc += bcount;
 2049a00:	e0bfff17 	ldw	r2,-4(fp)
 2049a04:	10c00217 	ldw	r3,8(r2)
 2049a08:	e0bff817 	ldw	r2,-32(fp)
 2049a0c:	1887883a 	add	r3,r3,r2
 2049a10:	e0bfff17 	ldw	r2,-4(fp)
 2049a14:	10c00215 	stw	r3,8(r2)
      }
      vfs_unlock();
 2049a18:	01000144 	movi	r4,5
 2049a1c:	2028ccc0 	call	2028ccc <post_app_sem>
      IN_PROFILER(PF_FS, PF_EXIT);
      return (bcount/size);
 2049a20:	e0fff817 	ldw	r3,-32(fp)
 2049a24:	e0bffd17 	ldw	r2,-12(fp)
 2049a28:	1885203a 	divu	r2,r3,r2
 2049a2c:	00000306 	br	2049a3c <vfread+0x178>
   }

   vfs_unlock();
 2049a30:	01000144 	movi	r4,5
 2049a34:	2028ccc0 	call	2028ccc <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fread(buf, size, items, (FILE*)vfd));
#else
   return 0;
 2049a38:	0005883a 	mov	r2,zero
#endif   /* HT_LOCALFS */
}
 2049a3c:	e037883a 	mov	sp,fp
 2049a40:	dfc00117 	ldw	ra,4(sp)
 2049a44:	df000017 	ldw	fp,0(sp)
 2049a48:	dec00204 	addi	sp,sp,8
 2049a4c:	f800283a 	ret

02049a50 <vfwrite_locked>:
 * RETURNS: 
 */

int 
vfwrite_locked(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 2049a50:	defff204 	addi	sp,sp,-56
 2049a54:	dfc00d15 	stw	ra,52(sp)
 2049a58:	df000c15 	stw	fp,48(sp)
 2049a5c:	df000c04 	addi	fp,sp,48
 2049a60:	e13ffc15 	stw	r4,-16(fp)
 2049a64:	e17ffd15 	stw	r5,-12(fp)
 2049a68:	e1bffe15 	stw	r6,-8(fp)
 2049a6c:	e1ffff15 	stw	r7,-4(fp)
   unsigned long current_offset;
   struct vfs_file * vfp;
#endif   /* HT_RWVFS */

   /* if the file is not in our list of files */
   if (!isvfile_locked(vfd))
 2049a70:	e13fff17 	ldw	r4,-4(fp)
 2049a74:	204a5380 	call	204a538 <isvfile_locked>
 2049a78:	1000021e 	bne	r2,zero,2049a84 <vfwrite_locked+0x34>
   {
#ifdef HT_LOCALFS
      /* default to call on local system */
      return(fwrite(buf, size, items, (FILE*)vfd));
#else
      return EBADF;
 2049a7c:	00800244 	movi	r2,9
 2049a80:	0000d906 	br	2049de8 <vfwrite_locked+0x398>
   }
   /* this file is in our list of files */

#ifdef HT_EXTDEV
   /* if the file was created by an external file system */
   if (vfd->file->method)
 2049a84:	e0bfff17 	ldw	r2,-4(fp)
 2049a88:	10800117 	ldw	r2,4(r2)
 2049a8c:	10800a17 	ldw	r2,40(r2)
 2049a90:	10000e26 	beq	r2,zero,2049acc <vfwrite_locked+0x7c>
   {
      struct vfroutines *  vfs   =  (struct  vfroutines*)   (vfd->file->method);
 2049a94:	e0bfff17 	ldw	r2,-4(fp)
 2049a98:	10800117 	ldw	r2,4(r2)
 2049a9c:	10800a17 	ldw	r2,40(r2)
 2049aa0:	e0bff415 	stw	r2,-48(fp)
      int   rc;

      /* call that system's fwrite() */
      rc = vfs->r_fwrite(buf,size,items,vfd);
 2049aa4:	e0bff417 	ldw	r2,-48(fp)
 2049aa8:	10800417 	ldw	r2,16(r2)
 2049aac:	e13ffc17 	ldw	r4,-16(fp)
 2049ab0:	e17ffd17 	ldw	r5,-12(fp)
 2049ab4:	e1bffe17 	ldw	r6,-8(fp)
 2049ab8:	e1ffff17 	ldw	r7,-4(fp)
 2049abc:	103ee83a 	callr	r2
 2049ac0:	e0bff515 	stw	r2,-44(fp)
      return rc;
 2049ac4:	e0bff517 	ldw	r2,-44(fp)
 2049ac8:	0000c706 	br	2049de8 <vfwrite_locked+0x398>

#else    /* HT_RWVFS */

   /* the caller is trying to write to a file that's been deleted,
      so he writes 0 data */
   if (vfd->file == NULL)
 2049acc:	e0bfff17 	ldw	r2,-4(fp)
 2049ad0:	10800117 	ldw	r2,4(r2)
 2049ad4:	1000021e 	bne	r2,zero,2049ae0 <vfwrite_locked+0x90>
   {
      return 0;
 2049ad8:	0005883a 	mov	r2,zero
 2049adc:	0000c206 	br	2049de8 <vfwrite_locked+0x398>
   }

   vfp = vfd->file;
 2049ae0:	e0bfff17 	ldw	r2,-4(fp)
 2049ae4:	10800117 	ldw	r2,4(r2)
 2049ae8:	e0bff615 	stw	r2,-40(fp)

   /* if the file is not writable, return error condition */
   if (!(vfp->flags & VF_WRITE))
 2049aec:	e0bff617 	ldw	r2,-40(fp)
 2049af0:	1080058b 	ldhu	r2,22(r2)
 2049af4:	10bfffcc 	andi	r2,r2,65535
 2049af8:	1080080c 	andi	r2,r2,32
 2049afc:	1000051e 	bne	r2,zero,2049b14 <vfwrite_locked+0xc4>
   {
      vfd->error = ENP_FILEIO;
 2049b00:	e0bfff17 	ldw	r2,-4(fp)
 2049b04:	00fff984 	movi	r3,-26
 2049b08:	10c00415 	stw	r3,16(r2)
      return 0;
 2049b0c:	0005883a 	mov	r2,zero
 2049b10:	0000b506 	br	2049de8 <vfwrite_locked+0x398>
   }

   /* compute number of bytes to write */
   bcount = size * items;
 2049b14:	e0fffd17 	ldw	r3,-12(fp)
 2049b18:	e0bffe17 	ldw	r2,-8(fp)
 2049b1c:	1885383a 	mul	r2,r3,r2
 2049b20:	e0bff715 	stw	r2,-36(fp)

   /* get rid of this degenerate case up front */
   if (bcount == 0)
 2049b24:	e0bff717 	ldw	r2,-36(fp)
 2049b28:	1000021e 	bne	r2,zero,2049b34 <vfwrite_locked+0xe4>
   {
      return 0;
 2049b2c:	0005883a 	mov	r2,zero
 2049b30:	0000ad06 	br	2049de8 <vfwrite_locked+0x398>
   }

   /* if the file currently has no data buffer */
   if (vfp->data == NULL)
 2049b34:	e0bff617 	ldw	r2,-40(fp)
 2049b38:	10800617 	ldw	r2,24(r2)
 2049b3c:	10003c1e 	bne	r2,zero,2049c30 <vfwrite_locked+0x1e0>
   {
      /* compute the size of the buffer to be created */
      /* we round up the size of the data to be written so we dont have
         the overhead of a memory allocation on every write */
      unsigned long buf_size = VFS_ROUND_UP((unsigned long)bcount);
 2049b40:	e0bff717 	ldw	r2,-36(fp)
 2049b44:	10bfffc4 	addi	r2,r2,-1
 2049b48:	1004d37a 	srli	r2,r2,13
 2049b4c:	10800044 	addi	r2,r2,1
 2049b50:	1004937a 	slli	r2,r2,13
 2049b54:	e0bff815 	stw	r2,-32(fp)

      /* allocate a buffer of that size */
      vfp->data = vf_alloc_buffer(buf_size);
 2049b58:	e13ff817 	ldw	r4,-32(fp)
 2049b5c:	2048e640 	call	2048e64 <vf_alloc_buffer>
 2049b60:	e0fff617 	ldw	r3,-40(fp)
 2049b64:	18800615 	stw	r2,24(r3)

      /* if the allocation failed */
      if (!(vfp->data))
 2049b68:	e0bff617 	ldw	r2,-40(fp)
 2049b6c:	10800617 	ldw	r2,24(r2)
 2049b70:	1000051e 	bne	r2,zero,2049b88 <vfwrite_locked+0x138>
      {
         vfd->error = ENP_NOMEM;
 2049b74:	e0bfff17 	ldw	r2,-4(fp)
 2049b78:	00fffb04 	movi	r3,-20
 2049b7c:	10c00415 	stw	r3,16(r2)
         return 0;
 2049b80:	0005883a 	mov	r2,zero
 2049b84:	00009806 	br	2049de8 <vfwrite_locked+0x398>
      }

      /* store the size of the allocated buffer */
      vfp->buf_size = buf_size;
 2049b88:	e0bff617 	ldw	r2,-40(fp)
 2049b8c:	e0fff817 	ldw	r3,-32(fp)
 2049b90:	10c00915 	stw	r3,36(r2)

      /* store the number of bytes written in the real and compressed
         file sizes */
      vfp->real_size = bcount;
 2049b94:	e0bff617 	ldw	r2,-40(fp)
 2049b98:	e0fff717 	ldw	r3,-36(fp)
 2049b9c:	10c00715 	stw	r3,28(r2)
      vfp->comp_size = bcount;
 2049ba0:	e0bff617 	ldw	r2,-40(fp)
 2049ba4:	e0fff717 	ldw	r3,-36(fp)
 2049ba8:	10c00815 	stw	r3,32(r2)

      /* set the file pointer to the first byte following the last
         byte written */
      vfd->cmploc = vfp->data + bcount;
 2049bac:	e0bff617 	ldw	r2,-40(fp)
 2049bb0:	10c00617 	ldw	r3,24(r2)
 2049bb4:	e0bff717 	ldw	r2,-36(fp)
 2049bb8:	1887883a 	add	r3,r3,r2
 2049bbc:	e0bfff17 	ldw	r2,-4(fp)
 2049bc0:	10c00215 	stw	r3,8(r2)

      /* turn off the compression flag */
      vfp->flags &= ~VF_HTMLCOMPRESSED;
 2049bc4:	e0bff617 	ldw	r2,-40(fp)
 2049bc8:	10c0058b 	ldhu	r3,22(r2)
 2049bcc:	00bfff84 	movi	r2,-2
 2049bd0:	1884703a 	and	r2,r3,r2
 2049bd4:	1007883a 	mov	r3,r2
 2049bd8:	e0bff617 	ldw	r2,-40(fp)
 2049bdc:	10c0058d 	sth	r3,22(r2)

      /* the data in the file is stale */
      vfp->flags |= VF_STALE;
 2049be0:	e0bff617 	ldw	r2,-40(fp)
 2049be4:	1080058b 	ldhu	r2,22(r2)
 2049be8:	10808014 	ori	r2,r2,512
 2049bec:	1007883a 	mov	r3,r2
 2049bf0:	e0bff617 	ldw	r2,-40(fp)
 2049bf4:	10c0058d 	sth	r3,22(r2)

      /* the buffer data was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 2049bf8:	e0bff617 	ldw	r2,-40(fp)
 2049bfc:	1080058b 	ldhu	r2,22(r2)
 2049c00:	10802014 	ori	r2,r2,128
 2049c04:	1007883a 	mov	r3,r2
 2049c08:	e0bff617 	ldw	r2,-40(fp)
 2049c0c:	10c0058d 	sth	r3,22(r2)

      /* copy the data to be written to the file buffer */
      MEMCPY(vfp->data,buf,bcount);
 2049c10:	e0bff617 	ldw	r2,-40(fp)
 2049c14:	10800617 	ldw	r2,24(r2)
 2049c18:	1009883a 	mov	r4,r2
 2049c1c:	e17ffc17 	ldw	r5,-16(fp)
 2049c20:	e1bff717 	ldw	r6,-36(fp)
 2049c24:	200660c0 	call	200660c <memcpy>

      /* return the number of "items" written */
      return items;
 2049c28:	e0bffe17 	ldw	r2,-8(fp)
 2049c2c:	00006e06 	br	2049de8 <vfwrite_locked+0x398>
   }

   /* compute the current offset into the file */
   current_offset = vfd->cmploc - vfp->data;
 2049c30:	e0bfff17 	ldw	r2,-4(fp)
 2049c34:	10800217 	ldw	r2,8(r2)
 2049c38:	1007883a 	mov	r3,r2
 2049c3c:	e0bff617 	ldw	r2,-40(fp)
 2049c40:	10800617 	ldw	r2,24(r2)
 2049c44:	1885c83a 	sub	r2,r3,r2
 2049c48:	e0bff915 	stw	r2,-28(fp)

   /* if the data to be written wont fit into the file buffer */
   if ((current_offset + bcount) > vfp->buf_size)
 2049c4c:	e0fff917 	ldw	r3,-28(fp)
 2049c50:	e0bff717 	ldw	r2,-36(fp)
 2049c54:	1885883a 	add	r2,r3,r2
 2049c58:	e0fff617 	ldw	r3,-40(fp)
 2049c5c:	18c00917 	ldw	r3,36(r3)
 2049c60:	1880382e 	bgeu	r3,r2,2049d44 <vfwrite_locked+0x2f4>
   {
      /* compute the size of a new buffer to hold the data */
      unsigned long new_buf_size = VFS_ROUND_UP(current_offset + bcount);
 2049c64:	e0fff917 	ldw	r3,-28(fp)
 2049c68:	e0bff717 	ldw	r2,-36(fp)
 2049c6c:	1885883a 	add	r2,r3,r2
 2049c70:	10bfffc4 	addi	r2,r2,-1
 2049c74:	1004d37a 	srli	r2,r2,13
 2049c78:	10800044 	addi	r2,r2,1
 2049c7c:	1004937a 	slli	r2,r2,13
 2049c80:	e0bffa15 	stw	r2,-24(fp)
      unsigned char *new_buffer;

      /* allocate a new buffer */
      new_buffer = vf_alloc_buffer(new_buf_size);
 2049c84:	e13ffa17 	ldw	r4,-24(fp)
 2049c88:	2048e640 	call	2048e64 <vf_alloc_buffer>
 2049c8c:	e0bffb15 	stw	r2,-20(fp)

      /* check for allocation failure */
      if (!new_buffer)
 2049c90:	e0bffb17 	ldw	r2,-20(fp)
 2049c94:	1000051e 	bne	r2,zero,2049cac <vfwrite_locked+0x25c>
      {
         vfd->error = ENP_NOMEM;
 2049c98:	e0bfff17 	ldw	r2,-4(fp)
 2049c9c:	00fffb04 	movi	r3,-20
 2049ca0:	10c00415 	stw	r3,16(r2)
         return 0;
 2049ca4:	0005883a 	mov	r2,zero
 2049ca8:	00004f06 	br	2049de8 <vfwrite_locked+0x398>
      }

      /* copy the old buffer contents to the new buffer */
      MEMCPY(new_buffer,vfp->data,(unsigned int) (vfp->comp_size));
 2049cac:	e0bff617 	ldw	r2,-40(fp)
 2049cb0:	10c00617 	ldw	r3,24(r2)
 2049cb4:	e0bff617 	ldw	r2,-40(fp)
 2049cb8:	10800817 	ldw	r2,32(r2)
 2049cbc:	e13ffb17 	ldw	r4,-20(fp)
 2049cc0:	180b883a 	mov	r5,r3
 2049cc4:	100d883a 	mov	r6,r2
 2049cc8:	200660c0 	call	200660c <memcpy>

      /* if the old buffer had been dynamically allocated */
      if (vfp->flags & VF_DYNAMICDATA)
 2049ccc:	e0bff617 	ldw	r2,-40(fp)
 2049cd0:	1080058b 	ldhu	r2,22(r2)
 2049cd4:	10bfffcc 	andi	r2,r2,65535
 2049cd8:	1080200c 	andi	r2,r2,128
 2049cdc:	10000726 	beq	r2,zero,2049cfc <vfwrite_locked+0x2ac>
      {
         /* free it */
         vf_free_buffer(vfp->data,vfp->buf_size);
 2049ce0:	e0bff617 	ldw	r2,-40(fp)
 2049ce4:	10c00617 	ldw	r3,24(r2)
 2049ce8:	e0bff617 	ldw	r2,-40(fp)
 2049cec:	10800917 	ldw	r2,36(r2)
 2049cf0:	1809883a 	mov	r4,r3
 2049cf4:	100b883a 	mov	r5,r2
 2049cf8:	2048f2c0 	call	2048f2c <vf_free_buffer>
      }

      /* store the new buffer in the file structure */
      vfp->data = new_buffer;
 2049cfc:	e0bff617 	ldw	r2,-40(fp)
 2049d00:	e0fffb17 	ldw	r3,-20(fp)
 2049d04:	10c00615 	stw	r3,24(r2)

      /* store the new buffer size in the file structure */
      vfp->buf_size = new_buf_size;
 2049d08:	e0bff617 	ldw	r2,-40(fp)
 2049d0c:	e0fffa17 	ldw	r3,-24(fp)
 2049d10:	10c00915 	stw	r3,36(r2)

      /* the new buffer was dynamically allocated */
      vfp->flags |= VF_DYNAMICDATA;
 2049d14:	e0bff617 	ldw	r2,-40(fp)
 2049d18:	1080058b 	ldhu	r2,22(r2)
 2049d1c:	10802014 	ori	r2,r2,128
 2049d20:	1007883a 	mov	r3,r2
 2049d24:	e0bff617 	ldw	r2,-40(fp)
 2049d28:	10c0058d 	sth	r3,22(r2)
       * buffer note that this means the VFS does not support 
       * simultaneous opens of the same file, since for that to work, 
       * all the other cmploc's that point to this file would 
       * have to be updated also 
       */
      vfd->cmploc = vfp->data + current_offset;
 2049d2c:	e0bff617 	ldw	r2,-40(fp)
 2049d30:	10c00617 	ldw	r3,24(r2)
 2049d34:	e0bff917 	ldw	r2,-28(fp)
 2049d38:	1887883a 	add	r3,r3,r2
 2049d3c:	e0bfff17 	ldw	r2,-4(fp)
 2049d40:	10c00215 	stw	r3,8(r2)
   }

   /* copy the data to the current file pointer */
   MEMCPY(vfd->cmploc,buf,bcount);
 2049d44:	e0bfff17 	ldw	r2,-4(fp)
 2049d48:	10800217 	ldw	r2,8(r2)
 2049d4c:	1009883a 	mov	r4,r2
 2049d50:	e17ffc17 	ldw	r5,-16(fp)
 2049d54:	e1bff717 	ldw	r6,-36(fp)
 2049d58:	200660c0 	call	200660c <memcpy>

   /* update the current file pointer */
   vfd->cmploc += bcount;
 2049d5c:	e0bfff17 	ldw	r2,-4(fp)
 2049d60:	10c00217 	ldw	r3,8(r2)
 2049d64:	e0bff717 	ldw	r2,-36(fp)
 2049d68:	1887883a 	add	r3,r3,r2
 2049d6c:	e0bfff17 	ldw	r2,-4(fp)
 2049d70:	10c00215 	stw	r3,8(r2)

   /* if the resulting current offset is greater than the file size */
   if (current_offset + bcount > vfp->comp_size)
 2049d74:	e0fff917 	ldw	r3,-28(fp)
 2049d78:	e0bff717 	ldw	r2,-36(fp)
 2049d7c:	1885883a 	add	r2,r3,r2
 2049d80:	e0fff617 	ldw	r3,-40(fp)
 2049d84:	18c00817 	ldw	r3,32(r3)
 2049d88:	1880052e 	bgeu	r3,r2,2049da0 <vfwrite_locked+0x350>
   {
      /* update the "compressed" file size */
      vfp->comp_size = current_offset + bcount;
 2049d8c:	e0fff917 	ldw	r3,-28(fp)
 2049d90:	e0bff717 	ldw	r2,-36(fp)
 2049d94:	1887883a 	add	r3,r3,r2
 2049d98:	e0bff617 	ldw	r2,-40(fp)
 2049d9c:	10c00815 	stw	r3,32(r2)
   }

   /* since we turn off the compression bit below, the "real" size and
      the compressed size must be the same */
   vfp->real_size = vfp->comp_size;
 2049da0:	e0bff617 	ldw	r2,-40(fp)
 2049da4:	10c00817 	ldw	r3,32(r2)
 2049da8:	e0bff617 	ldw	r2,-40(fp)
 2049dac:	10c00715 	stw	r3,28(r2)

   /* turn off the compression flag */
   vfp->flags &= ~VF_HTMLCOMPRESSED;
 2049db0:	e0bff617 	ldw	r2,-40(fp)
 2049db4:	10c0058b 	ldhu	r3,22(r2)
 2049db8:	00bfff84 	movi	r2,-2
 2049dbc:	1884703a 	and	r2,r3,r2
 2049dc0:	1007883a 	mov	r3,r2
 2049dc4:	e0bff617 	ldw	r2,-40(fp)
 2049dc8:	10c0058d 	sth	r3,22(r2)

   /* the data in the file is stale */
   vfp->flags |= VF_STALE;
 2049dcc:	e0bff617 	ldw	r2,-40(fp)
 2049dd0:	1080058b 	ldhu	r2,22(r2)
 2049dd4:	10808014 	ori	r2,r2,512
 2049dd8:	1007883a 	mov	r3,r2
 2049ddc:	e0bff617 	ldw	r2,-40(fp)
 2049de0:	10c0058d 	sth	r3,22(r2)

   /* return the number of "items" written */
   return items;
 2049de4:	e0bffe17 	ldw	r2,-8(fp)

#endif   /* HT_RWVFS */
}
 2049de8:	e037883a 	mov	sp,fp
 2049dec:	dfc00117 	ldw	ra,4(sp)
 2049df0:	df000017 	ldw	fp,0(sp)
 2049df4:	dec00204 	addi	sp,sp,8
 2049df8:	f800283a 	ret

02049dfc <vfwrite>:
 * RETURNS: 
 */

int
vfwrite(char * buf, unsigned size, unsigned items, VFILE * vfd)
{
 2049dfc:	defff904 	addi	sp,sp,-28
 2049e00:	dfc00615 	stw	ra,24(sp)
 2049e04:	df000515 	stw	fp,20(sp)
 2049e08:	df000504 	addi	fp,sp,20
 2049e0c:	e13ffc15 	stw	r4,-16(fp)
 2049e10:	e17ffd15 	stw	r5,-12(fp)
 2049e14:	e1bffe15 	stw	r6,-8(fp)
 2049e18:	e1ffff15 	stw	r7,-4(fp)
   int   rc;

   IN_PROFILER(PF_FS, PF_ENTRY);

   /* lock the VFS */
   vfs_lock();
 2049e1c:	01000144 	movi	r4,5
 2049e20:	2028c100 	call	2028c10 <wait_app_sem>

   /* do the write */
   rc = vfwrite_locked(buf, size, items, vfd);
 2049e24:	e13ffc17 	ldw	r4,-16(fp)
 2049e28:	e17ffd17 	ldw	r5,-12(fp)
 2049e2c:	e1bffe17 	ldw	r6,-8(fp)
 2049e30:	e1ffff17 	ldw	r7,-4(fp)
 2049e34:	2049a500 	call	2049a50 <vfwrite_locked>
 2049e38:	e0bffb15 	stw	r2,-20(fp)

   /* unlock the VFS */
   vfs_unlock();
 2049e3c:	01000144 	movi	r4,5
 2049e40:	2028ccc0 	call	2028ccc <post_app_sem>

   IN_PROFILER(PF_FS, PF_EXIT);

   return rc;
 2049e44:	e0bffb17 	ldw	r2,-20(fp)
}
 2049e48:	e037883a 	mov	sp,fp
 2049e4c:	dfc00117 	ldw	ra,4(sp)
 2049e50:	df000017 	ldw	fp,0(sp)
 2049e54:	dec00204 	addi	sp,sp,8
 2049e58:	f800283a 	ret

02049e5c <vfseek>:
 * RETURNS: 
 */

int 
vfseek(VFILE * vfd, long offset, int mode)
{
 2049e5c:	defff904 	addi	sp,sp,-28
 2049e60:	dfc00615 	stw	ra,24(sp)
 2049e64:	df000515 	stw	fp,20(sp)
 2049e68:	df000504 	addi	fp,sp,20
 2049e6c:	e13ffd15 	stw	r4,-12(fp)
 2049e70:	e17ffe15 	stw	r5,-8(fp)
 2049e74:	e1bfff15 	stw	r6,-4(fp)
   /* lock the VFS */
   vfs_lock();
 2049e78:	01000144 	movi	r4,5
 2049e7c:	2028c100 	call	2028c10 <wait_app_sem>

   if (isvfile_locked(vfd))
 2049e80:	e13ffd17 	ldw	r4,-12(fp)
 2049e84:	204a5380 	call	204a538 <isvfile_locked>
 2049e88:	10003f26 	beq	r2,zero,2049f88 <vfseek+0x12c>
   {
#ifdef HT_RWVFS
      /* the caller is trying to seek a file that's been deleted,
         so return an error indication */
      if (vfd->file == NULL)
 2049e8c:	e0bffd17 	ldw	r2,-12(fp)
 2049e90:	10800117 	ldw	r2,4(r2)
 2049e94:	1000041e 	bne	r2,zero,2049ea8 <vfseek+0x4c>
      {
         vfs_unlock();
 2049e98:	01000144 	movi	r4,5
 2049e9c:	2028ccc0 	call	2028ccc <post_app_sem>
         return -1;
 2049ea0:	00bfffc4 	movi	r2,-1
 2049ea4:	00003b06 	br	2049f94 <vfseek+0x138>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 2049ea8:	e0bffd17 	ldw	r2,-12(fp)
 2049eac:	10800117 	ldw	r2,4(r2)
 2049eb0:	10800a17 	ldw	r2,40(r2)
 2049eb4:	10000f26 	beq	r2,zero,2049ef4 <vfseek+0x98>
      {
         struct vfroutines *vfp = (struct vfroutines*)(vfd->file->method);
 2049eb8:	e0bffd17 	ldw	r2,-12(fp)
 2049ebc:	10800117 	ldw	r2,4(r2)
 2049ec0:	10800a17 	ldw	r2,40(r2)
 2049ec4:	e0bffb15 	stw	r2,-20(fp)
         int   rc;

         rc = vfp->r_fseek(vfd, offset, mode);
 2049ec8:	e0bffb17 	ldw	r2,-20(fp)
 2049ecc:	10800517 	ldw	r2,20(r2)
 2049ed0:	e13ffd17 	ldw	r4,-12(fp)
 2049ed4:	e17ffe17 	ldw	r5,-8(fp)
 2049ed8:	e1bfff17 	ldw	r6,-4(fp)
 2049edc:	103ee83a 	callr	r2
 2049ee0:	e0bffc15 	stw	r2,-16(fp)
         vfs_unlock();
 2049ee4:	01000144 	movi	r4,5
 2049ee8:	2028ccc0 	call	2028ccc <post_app_sem>
         return rc;
 2049eec:	e0bffc17 	ldw	r2,-16(fp)
 2049ef0:	00002806 	br	2049f94 <vfseek+0x138>
      }
#endif   /* HT_EXTDEV */
      /* this vfseek() currently only supports seek to exact
         end or begining of file */
      switch (mode)
 2049ef4:	e0bfff17 	ldw	r2,-4(fp)
 2049ef8:	10c00060 	cmpeqi	r3,r2,1
 2049efc:	18000b1e 	bne	r3,zero,2049f2c <vfseek+0xd0>
 2049f00:	10c000a0 	cmpeqi	r3,r2,2
 2049f04:	1800101e 	bne	r3,zero,2049f48 <vfseek+0xec>
 2049f08:	10001b1e 	bne	r2,zero,2049f78 <vfseek+0x11c>
      {
      case SEEK_SET:
         vfd->cmploc = vfd->file->data + offset;
 2049f0c:	e0bffd17 	ldw	r2,-12(fp)
 2049f10:	10800117 	ldw	r2,4(r2)
 2049f14:	10c00617 	ldw	r3,24(r2)
 2049f18:	e0bffe17 	ldw	r2,-8(fp)
 2049f1c:	1887883a 	add	r3,r3,r2
 2049f20:	e0bffd17 	ldw	r2,-12(fp)
 2049f24:	10c00215 	stw	r3,8(r2)
         break;
 2049f28:	00001306 	br	2049f78 <vfseek+0x11c>
      case SEEK_CUR:
         /* If the file is compressed, then the following
          * adjustment is inaccurate. Currently we don't have
          * any scenario where this happens. - handle later */
         vfd->cmploc += offset; 
 2049f2c:	e0bffd17 	ldw	r2,-12(fp)
 2049f30:	10c00217 	ldw	r3,8(r2)
 2049f34:	e0bffe17 	ldw	r2,-8(fp)
 2049f38:	1887883a 	add	r3,r3,r2
 2049f3c:	e0bffd17 	ldw	r2,-12(fp)
 2049f40:	10c00215 	stw	r3,8(r2)
         break;
 2049f44:	00000c06 	br	2049f78 <vfseek+0x11c>
      case SEEK_END:
         vfd->cmploc = vfd->file->data + vfd->file->comp_size + offset;
 2049f48:	e0bffd17 	ldw	r2,-12(fp)
 2049f4c:	10800117 	ldw	r2,4(r2)
 2049f50:	10c00617 	ldw	r3,24(r2)
 2049f54:	e0bffd17 	ldw	r2,-12(fp)
 2049f58:	10800117 	ldw	r2,4(r2)
 2049f5c:	11000817 	ldw	r4,32(r2)
 2049f60:	e0bffe17 	ldw	r2,-8(fp)
 2049f64:	2085883a 	add	r2,r4,r2
 2049f68:	1887883a 	add	r3,r3,r2
 2049f6c:	e0bffd17 	ldw	r2,-12(fp)
 2049f70:	10c00215 	stw	r3,8(r2)
         break;
 2049f74:	0001883a 	nop
      }
      vfs_unlock();
 2049f78:	01000144 	movi	r4,5
 2049f7c:	2028ccc0 	call	2028ccc <post_app_sem>
      return(0);
 2049f80:	0005883a 	mov	r2,zero
 2049f84:	00000306 	br	2049f94 <vfseek+0x138>
   }

   vfs_unlock();
 2049f88:	01000144 	movi	r4,5
 2049f8c:	2028ccc0 	call	2028ccc <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(fseek((FILE*)vfd, offset, mode));
#else
   return -1;
 2049f90:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 2049f94:	e037883a 	mov	sp,fp
 2049f98:	dfc00117 	ldw	ra,4(sp)
 2049f9c:	df000017 	ldw	fp,0(sp)
 2049fa0:	dec00204 	addi	sp,sp,8
 2049fa4:	f800283a 	ret

02049fa8 <vftell>:
 * RETURNS: 
 */

long
vftell(VFILE * vfd)
{
 2049fa8:	defffb04 	addi	sp,sp,-20
 2049fac:	dfc00415 	stw	ra,16(sp)
 2049fb0:	df000315 	stw	fp,12(sp)
 2049fb4:	df000304 	addi	fp,sp,12
 2049fb8:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 2049fbc:	01000144 	movi	r4,5
 2049fc0:	2028c100 	call	2028c10 <wait_app_sem>

   if (isvfile_locked(vfd))
 2049fc4:	e13fff17 	ldw	r4,-4(fp)
 2049fc8:	204a5380 	call	204a538 <isvfile_locked>
 2049fcc:	10003226 	beq	r2,zero,204a098 <vftell+0xf0>
   {
#ifdef HT_RWVFS
      /* the caller is trying to ftell a deleted file,
         so return an error condition */
      if (vfd->file == NULL)
 2049fd0:	e0bfff17 	ldw	r2,-4(fp)
 2049fd4:	10800117 	ldw	r2,4(r2)
 2049fd8:	1000041e 	bne	r2,zero,2049fec <vftell+0x44>
      {
         vfs_unlock();
 2049fdc:	01000144 	movi	r4,5
 2049fe0:	2028ccc0 	call	2028ccc <post_app_sem>
         return -1;
 2049fe4:	00bfffc4 	movi	r2,-1
 2049fe8:	00002e06 	br	204a0a4 <vftell+0xfc>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 2049fec:	e0bfff17 	ldw	r2,-4(fp)
 2049ff0:	10800117 	ldw	r2,4(r2)
 2049ff4:	10800a17 	ldw	r2,40(r2)
 2049ff8:	10000d26 	beq	r2,zero,204a030 <vftell+0x88>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 2049ffc:	e0bfff17 	ldw	r2,-4(fp)
 204a000:	10800117 	ldw	r2,4(r2)
 204a004:	10800a17 	ldw	r2,40(r2)
 204a008:	e0bffd15 	stw	r2,-12(fp)
         long  rc;

         rc = vfp->r_ftell(vfd);
 204a00c:	e0bffd17 	ldw	r2,-12(fp)
 204a010:	10800617 	ldw	r2,24(r2)
 204a014:	e13fff17 	ldw	r4,-4(fp)
 204a018:	103ee83a 	callr	r2
 204a01c:	e0bffe15 	stw	r2,-8(fp)
         vfs_unlock();
 204a020:	01000144 	movi	r4,5
 204a024:	2028ccc0 	call	2028ccc <post_app_sem>
         return rc;
 204a028:	e0bffe17 	ldw	r2,-8(fp)
 204a02c:	00001d06 	br	204a0a4 <vftell+0xfc>
      }
#endif   /* HT_EXTDEV */
      /* if file has been fseeked to end, return uncompressed size.
         else return current location in compression stream */
      if (vfd->cmploc == vfd->file->data + vfd->file->comp_size)
 204a030:	e0bfff17 	ldw	r2,-4(fp)
 204a034:	10c00217 	ldw	r3,8(r2)
 204a038:	e0bfff17 	ldw	r2,-4(fp)
 204a03c:	10800117 	ldw	r2,4(r2)
 204a040:	11000617 	ldw	r4,24(r2)
 204a044:	e0bfff17 	ldw	r2,-4(fp)
 204a048:	10800117 	ldw	r2,4(r2)
 204a04c:	10800817 	ldw	r2,32(r2)
 204a050:	2085883a 	add	r2,r4,r2
 204a054:	1880061e 	bne	r3,r2,204a070 <vftell+0xc8>
      {
         vfs_unlock();
 204a058:	01000144 	movi	r4,5
 204a05c:	2028ccc0 	call	2028ccc <post_app_sem>

         return vfd->file->comp_size;
 204a060:	e0bfff17 	ldw	r2,-4(fp)
 204a064:	10800117 	ldw	r2,4(r2)
 204a068:	10800817 	ldw	r2,32(r2)
 204a06c:	00000d06 	br	204a0a4 <vftell+0xfc>
      }
      else
      {
         vfs_unlock();
 204a070:	01000144 	movi	r4,5
 204a074:	2028ccc0 	call	2028ccc <post_app_sem>

         return (vfd->cmploc - vfd->file->data);
 204a078:	e0bfff17 	ldw	r2,-4(fp)
 204a07c:	10800217 	ldw	r2,8(r2)
 204a080:	1007883a 	mov	r3,r2
 204a084:	e0bfff17 	ldw	r2,-4(fp)
 204a088:	10800117 	ldw	r2,4(r2)
 204a08c:	10800617 	ldw	r2,24(r2)
 204a090:	1885c83a 	sub	r2,r3,r2
 204a094:	00000306 	br	204a0a4 <vftell+0xfc>
      }
   }

   vfs_unlock();
 204a098:	01000144 	movi	r4,5
 204a09c:	2028ccc0 	call	2028ccc <post_app_sem>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(ftell((FILE*)vfd));
#else
   return EBADF;
 204a0a0:	00800244 	movi	r2,9
#endif   /* HT_LOCALFS */
}
 204a0a4:	e037883a 	mov	sp,fp
 204a0a8:	dfc00117 	ldw	ra,4(sp)
 204a0ac:	df000017 	ldw	fp,0(sp)
 204a0b0:	dec00204 	addi	sp,sp,8
 204a0b4:	f800283a 	ret

0204a0b8 <vgetc_locked>:
 * RETURNS: 
 */

int
vgetc_locked(VFILE * vfd)
{
 204a0b8:	defffb04 	addi	sp,sp,-20
 204a0bc:	dfc00415 	stw	ra,16(sp)
 204a0c0:	df000315 	stw	fp,12(sp)
 204a0c4:	df000304 	addi	fp,sp,12
 204a0c8:	e13fff15 	stw	r4,-4(fp)
   int   chr;

   if (isvfile_locked(vfd))
 204a0cc:	e13fff17 	ldw	r4,-4(fp)
 204a0d0:	204a5380 	call	204a538 <isvfile_locked>
 204a0d4:	10002f26 	beq	r2,zero,204a194 <vgetc_locked+0xdc>
   {
#ifdef HT_RWVFS
      /* the caller is trying to read a file that's been deleted,
         so return an error condition */
      if (vfd->file == NULL)
 204a0d8:	e0bfff17 	ldw	r2,-4(fp)
 204a0dc:	10800117 	ldw	r2,4(r2)
 204a0e0:	1000021e 	bne	r2,zero,204a0ec <vgetc_locked+0x34>
      {
         return EOF;
 204a0e4:	00bfffc4 	movi	r2,-1
 204a0e8:	00002c06 	br	204a19c <vgetc_locked+0xe4>
      }
#endif   /* HT_RWVFS */

#ifdef HT_EXTDEV
      if (vfd->file->method)
 204a0ec:	e0bfff17 	ldw	r2,-4(fp)
 204a0f0:	10800117 	ldw	r2,4(r2)
 204a0f4:	10800a17 	ldw	r2,40(r2)
 204a0f8:	10000926 	beq	r2,zero,204a120 <vgetc_locked+0x68>
      {
         struct vfroutines *  vfp   =  (struct  vfroutines*)   (vfd->file->method);
 204a0fc:	e0bfff17 	ldw	r2,-4(fp)
 204a100:	10800117 	ldw	r2,4(r2)
 204a104:	10800a17 	ldw	r2,40(r2)
 204a108:	e0bffe15 	stw	r2,-8(fp)
         return (vfp->r_fgetc(vfd));
 204a10c:	e0bffe17 	ldw	r2,-8(fp)
 204a110:	10800717 	ldw	r2,28(r2)
 204a114:	e13fff17 	ldw	r4,-4(fp)
 204a118:	103ee83a 	callr	r2
 204a11c:	00001f06 	br	204a19c <vgetc_locked+0xe4>
#endif   /* HT_EXTDEV */

#ifdef HT_RWVFS
      /* a freshly created file might not have a data buffer associated
         with it yet */
      if (vfd->file->data == NULL)
 204a120:	e0bfff17 	ldw	r2,-4(fp)
 204a124:	10800117 	ldw	r2,4(r2)
 204a128:	10800617 	ldw	r2,24(r2)
 204a12c:	1000021e 	bne	r2,zero,204a138 <vgetc_locked+0x80>
         return EOF;
 204a130:	00bfffc4 	movi	r2,-1
 204a134:	00001906 	br	204a19c <vgetc_locked+0xe4>
      }
      else  /* HTML compression flag not set */
      {
#endif   /* HTML_COMPRESSION */
         /* Check to see if read has advanced to end of file */
         if (vfd->cmploc >= (vfd->file->data + vfd->file->comp_size))
 204a138:	e0bfff17 	ldw	r2,-4(fp)
 204a13c:	10c00217 	ldw	r3,8(r2)
 204a140:	e0bfff17 	ldw	r2,-4(fp)
 204a144:	10800117 	ldw	r2,4(r2)
 204a148:	11000617 	ldw	r4,24(r2)
 204a14c:	e0bfff17 	ldw	r2,-4(fp)
 204a150:	10800117 	ldw	r2,4(r2)
 204a154:	10800817 	ldw	r2,32(r2)
 204a158:	2085883a 	add	r2,r4,r2
 204a15c:	18800336 	bltu	r3,r2,204a16c <vgetc_locked+0xb4>
            chr = EOF;
 204a160:	00bfffc4 	movi	r2,-1
 204a164:	e0bffd15 	stw	r2,-12(fp)
 204a168:	00000806 	br	204a18c <vgetc_locked+0xd4>
         else  /* else just get next char to return */
            chr = *(vfd->cmploc++);
 204a16c:	e0bfff17 	ldw	r2,-4(fp)
 204a170:	10800217 	ldw	r2,8(r2)
 204a174:	10c00003 	ldbu	r3,0(r2)
 204a178:	18c03fcc 	andi	r3,r3,255
 204a17c:	e0fffd15 	stw	r3,-12(fp)
 204a180:	10c00044 	addi	r3,r2,1
 204a184:	e0bfff17 	ldw	r2,-4(fp)
 204a188:	10c00215 	stw	r3,8(r2)
#ifdef HTML_COMPRESSION
      }  /* need to close brace form if...else; */
#endif   /* HTML_COMPRESSION */

      return chr;
 204a18c:	e0bffd17 	ldw	r2,-12(fp)
 204a190:	00000206 	br	204a19c <vgetc_locked+0xe4>

#ifdef HT_LOCALFS
   /* default to call on local system */
   return(getc((FILE*)vfd));
#else
   dtrap(); /* can this happen? */
 204a194:	20285c80 	call	20285c8 <dtrap>
   return EOF;
 204a198:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 204a19c:	e037883a 	mov	sp,fp
 204a1a0:	dfc00117 	ldw	ra,4(sp)
 204a1a4:	df000017 	ldw	fp,0(sp)
 204a1a8:	dec00204 	addi	sp,sp,8
 204a1ac:	f800283a 	ret

0204a1b0 <vgetc>:
 * RETURNS: 
 */

int
vgetc(VFILE * vfd)
{
 204a1b0:	defffc04 	addi	sp,sp,-16
 204a1b4:	dfc00315 	stw	ra,12(sp)
 204a1b8:	df000215 	stw	fp,8(sp)
 204a1bc:	df000204 	addi	fp,sp,8
 204a1c0:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 204a1c4:	01000144 	movi	r4,5
 204a1c8:	2028c100 	call	2028c10 <wait_app_sem>

   /* get the character */
   rc = vgetc_locked(vfd);
 204a1cc:	e13fff17 	ldw	r4,-4(fp)
 204a1d0:	204a0b80 	call	204a0b8 <vgetc_locked>
 204a1d4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 204a1d8:	01000144 	movi	r4,5
 204a1dc:	2028ccc0 	call	2028ccc <post_app_sem>
   return rc;
 204a1e0:	e0bffe17 	ldw	r2,-8(fp)
}
 204a1e4:	e037883a 	mov	sp,fp
 204a1e8:	dfc00117 	ldw	ra,4(sp)
 204a1ec:	df000017 	ldw	fp,0(sp)
 204a1f0:	dec00204 	addi	sp,sp,8
 204a1f4:	f800283a 	ret

0204a1f8 <vfslookup_locked>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup_locked(char * name)
{
 204a1f8:	defffb04 	addi	sp,sp,-20
 204a1fc:	dfc00415 	stw	ra,16(sp)
 204a200:	df000315 	stw	fp,12(sp)
 204a204:	df000304 	addi	fp,sp,12
 204a208:	e13fff15 	stw	r4,-4(fp)

#ifdef VFS_STRIPPATH
   char *   cp;

   /* If root path is prepended to name, skip past it */
   if (*name == '/' || *name == '\\')
 204a20c:	e0bfff17 	ldw	r2,-4(fp)
 204a210:	10800003 	ldbu	r2,0(r2)
 204a214:	10803fcc 	andi	r2,r2,255
 204a218:	1080201c 	xori	r2,r2,128
 204a21c:	10bfe004 	addi	r2,r2,-128
 204a220:	10800be0 	cmpeqi	r2,r2,47
 204a224:	1000071e 	bne	r2,zero,204a244 <vfslookup_locked+0x4c>
 204a228:	e0bfff17 	ldw	r2,-4(fp)
 204a22c:	10800003 	ldbu	r2,0(r2)
 204a230:	10803fcc 	andi	r2,r2,255
 204a234:	1080201c 	xori	r2,r2,128
 204a238:	10bfe004 	addi	r2,r2,-128
 204a23c:	10801718 	cmpnei	r2,r2,92
 204a240:	1000191e 	bne	r2,zero,204a2a8 <vfslookup_locked+0xb0>
   {
      cp = strippath(name);
 204a244:	e13fff17 	ldw	r4,-4(fp)
 204a248:	204a3640 	call	204a364 <strippath>
 204a24c:	e0bffe15 	stw	r2,-8(fp)

      if (!cp) /* strippath coundn't match our path */
 204a250:	e0bffe17 	ldw	r2,-8(fp)
 204a254:	1000121e 	bne	r2,zero,204a2a0 <vfslookup_locked+0xa8>
      {
         /* Files like "/hub47.gif" need to be taken care of */
         if (*name == '/' || *name == '\\')
 204a258:	e0bfff17 	ldw	r2,-4(fp)
 204a25c:	10800003 	ldbu	r2,0(r2)
 204a260:	10803fcc 	andi	r2,r2,255
 204a264:	1080201c 	xori	r2,r2,128
 204a268:	10bfe004 	addi	r2,r2,-128
 204a26c:	10800be0 	cmpeqi	r2,r2,47
 204a270:	1000071e 	bne	r2,zero,204a290 <vfslookup_locked+0x98>
 204a274:	e0bfff17 	ldw	r2,-4(fp)
 204a278:	10800003 	ldbu	r2,0(r2)
 204a27c:	10803fcc 	andi	r2,r2,255
 204a280:	1080201c 	xori	r2,r2,128
 204a284:	10bfe004 	addi	r2,r2,-128
 204a288:	10801718 	cmpnei	r2,r2,92
 204a28c:	1000061e 	bne	r2,zero,204a2a8 <vfslookup_locked+0xb0>
            name++;
 204a290:	e0bfff17 	ldw	r2,-4(fp)
 204a294:	10800044 	addi	r2,r2,1
 204a298:	e0bfff15 	stw	r2,-4(fp)
 204a29c:	00000206 	br	204a2a8 <vfslookup_locked+0xb0>
      }
      else
         name = cp ;
 204a2a0:	e0bffe17 	ldw	r2,-8(fp)
 204a2a4:	e0bfff15 	stw	r2,-4(fp)
   }
#endif   /* VFS_STRIPPATH */

   /* see if there is a question mark in the file name */
   if (strchr(name,'?'))
 204a2a8:	e13fff17 	ldw	r4,-4(fp)
 204a2ac:	01400fc4 	movi	r5,63
 204a2b0:	20073e00 	call	20073e0 <strchr>
 204a2b4:	10000326 	beq	r2,zero,204a2c4 <vfslookup_locked+0xcc>
   {
      dtrap(); /* is this still allowed? */
 204a2b8:	20285c80 	call	20285c8 <dtrap>
      return NULL;
 204a2bc:	0005883a 	mov	r2,zero
 204a2c0:	00001106 	br	204a308 <vfslookup_locked+0x110>
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 204a2c4:	d0a0cd17 	ldw	r2,-31948(gp)
 204a2c8:	e0bffd15 	stw	r2,-12(fp)
 204a2cc:	00000b06 	br	204a2fc <vfslookup_locked+0x104>
   {
      if (strcmp(name, vp->name) == 0)
 204a2d0:	e0bffd17 	ldw	r2,-12(fp)
 204a2d4:	10800104 	addi	r2,r2,4
 204a2d8:	e13fff17 	ldw	r4,-4(fp)
 204a2dc:	100b883a 	mov	r5,r2
 204a2e0:	20074c80 	call	20074c8 <strcmp>
 204a2e4:	1000021e 	bne	r2,zero,204a2f0 <vfslookup_locked+0xf8>
         return vp;
 204a2e8:	e0bffd17 	ldw	r2,-12(fp)
 204a2ec:	00000606 	br	204a308 <vfslookup_locked+0x110>
   {
      dtrap(); /* is this still allowed? */
      return NULL;
   }

   for (vp = vfsfiles; vp; vp = vp->next)    /* search vfs list for name */
 204a2f0:	e0bffd17 	ldw	r2,-12(fp)
 204a2f4:	10800017 	ldw	r2,0(r2)
 204a2f8:	e0bffd15 	stw	r2,-12(fp)
 204a2fc:	e0bffd17 	ldw	r2,-12(fp)
 204a300:	103ff31e 	bne	r2,zero,204a2d0 <vfslookup_locked+0xd8>
   {
      if (strcmp(name, vp->name) == 0)
         return vp;
   }

   return NULL;   /* fall to here if not found in for loop */
 204a304:	0005883a 	mov	r2,zero
}
 204a308:	e037883a 	mov	sp,fp
 204a30c:	dfc00117 	ldw	ra,4(sp)
 204a310:	df000017 	ldw	fp,0(sp)
 204a314:	dec00204 	addi	sp,sp,8
 204a318:	f800283a 	ret

0204a31c <vfslookup>:
 * RETURNS: 
 */

struct vfs_file * 
vfslookup(char * name) 
{
 204a31c:	defffc04 	addi	sp,sp,-16
 204a320:	dfc00315 	stw	ra,12(sp)
 204a324:	df000215 	stw	fp,8(sp)
 204a328:	df000204 	addi	fp,sp,8
 204a32c:	e13fff15 	stw	r4,-4(fp)
   if (vfs_log_file_name)
      dprintf("vfslookup() passed >%s<\n",name);
#endif   /* VFS_UNIT_TEST */

   /* lock the VFS */
   vfs_lock();
 204a330:	01000144 	movi	r4,5
 204a334:	2028c100 	call	2028c10 <wait_app_sem>

   /* do the lookup */
   vp = vfslookup_locked(name);
 204a338:	e13fff17 	ldw	r4,-4(fp)
 204a33c:	204a1f80 	call	204a1f8 <vfslookup_locked>
 204a340:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 204a344:	01000144 	movi	r4,5
 204a348:	2028ccc0 	call	2028ccc <post_app_sem>
   return vp;
 204a34c:	e0bffe17 	ldw	r2,-8(fp)
}
 204a350:	e037883a 	mov	sp,fp
 204a354:	dfc00117 	ldw	ra,4(sp)
 204a358:	df000017 	ldw	fp,0(sp)
 204a35c:	dec00204 	addi	sp,sp,8
 204a360:	f800283a 	ret

0204a364 <strippath>:
 * have the http_root_path prepended; or on any error. 
 */

char * 
strippath(char * name)
{
 204a364:	defff904 	addi	sp,sp,-28
 204a368:	dfc00615 	stw	ra,24(sp)
 204a36c:	df000515 	stw	fp,20(sp)
 204a370:	df000504 	addi	fp,sp,20
 204a374:	e13fff15 	stw	r4,-4(fp)
   char *   path; /* pointer into system path */
   char *   ptmp; /* another pointer into path */
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
 204a378:	e13fff17 	ldw	r4,-4(fp)
 204a37c:	2026d940 	call	2026d94 <uslash>
 204a380:	e0bffc15 	stw	r2,-16(fp)
   path = http_root_path; /* The servers root path, at least one UNIX slash */
 204a384:	d0a05a17 	ldw	r2,-32408(gp)
 204a388:	e0bffb15 	stw	r2,-20(fp)
   while (*path && *ntmp)
 204a38c:	00003c06 	br	204a480 <strippath+0x11c>
   {
      while (*path == '/') path++;   /* strip leading slash */
 204a390:	e0bffb17 	ldw	r2,-20(fp)
 204a394:	10800044 	addi	r2,r2,1
 204a398:	e0bffb15 	stw	r2,-20(fp)
 204a39c:	00000106 	br	204a3a4 <strippath+0x40>
 204a3a0:	0001883a 	nop
 204a3a4:	e0bffb17 	ldw	r2,-20(fp)
 204a3a8:	10800003 	ldbu	r2,0(r2)
 204a3ac:	10803fcc 	andi	r2,r2,255
 204a3b0:	1080201c 	xori	r2,r2,128
 204a3b4:	10bfe004 	addi	r2,r2,-128
 204a3b8:	10800be0 	cmpeqi	r2,r2,47
 204a3bc:	103ff41e 	bne	r2,zero,204a390 <strippath+0x2c>
         if (*path == 0)
 204a3c0:	e0bffb17 	ldw	r2,-20(fp)
 204a3c4:	10800003 	ldbu	r2,0(r2)
 204a3c8:	10803fcc 	andi	r2,r2,255
 204a3cc:	1080201c 	xori	r2,r2,128
 204a3d0:	10bfe004 	addi	r2,r2,-128
 204a3d4:	10003726 	beq	r2,zero,204a4b4 <strippath+0x150>
         break;
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
 204a3d8:	e13ffb17 	ldw	r4,-20(fp)
 204a3dc:	01400bc4 	movi	r5,47
 204a3e0:	20073e00 	call	20073e0 <strchr>
 204a3e4:	e0bffe15 	stw	r2,-8(fp)
      if (ptmp)
 204a3e8:	e0bffe17 	ldw	r2,-8(fp)
 204a3ec:	10000526 	beq	r2,zero,204a404 <strippath+0xa0>
         dirlen = ptmp - path;
 204a3f0:	e0fffe17 	ldw	r3,-8(fp)
 204a3f4:	e0bffb17 	ldw	r2,-20(fp)
 204a3f8:	1885c83a 	sub	r2,r3,r2
 204a3fc:	e0bffd15 	stw	r2,-12(fp)
      else
         dirlen = strlen(path);

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 204a400:	00000706 	br	204a420 <strippath+0xbc>
      /* find number of chars in this directory layer's name */
      ptmp = strchr(path, '/');   /* location of next slash in path */
      if (ptmp)
         dirlen = ptmp - path;
      else
         dirlen = strlen(path);
 204a404:	e13ffb17 	ldw	r4,-20(fp)
 204a408:	2007c640 	call	2007c64 <strlen>
 204a40c:	e0bffd15 	stw	r2,-12(fp)

      while (*ntmp == '/') ntmp++;   /* strip leading slash */
 204a410:	00000306 	br	204a420 <strippath+0xbc>
 204a414:	e0bffc17 	ldw	r2,-16(fp)
 204a418:	10800044 	addi	r2,r2,1
 204a41c:	e0bffc15 	stw	r2,-16(fp)
 204a420:	e0bffc17 	ldw	r2,-16(fp)
 204a424:	10800003 	ldbu	r2,0(r2)
 204a428:	10803fcc 	andi	r2,r2,255
 204a42c:	1080201c 	xori	r2,r2,128
 204a430:	10bfe004 	addi	r2,r2,-128
 204a434:	10800be0 	cmpeqi	r2,r2,47
 204a438:	103ff61e 	bne	r2,zero,204a414 <strippath+0xb0>
         if (strncmp(ntmp, path, dirlen) == 0)
 204a43c:	e0bffd17 	ldw	r2,-12(fp)
 204a440:	e13ffc17 	ldw	r4,-16(fp)
 204a444:	e17ffb17 	ldw	r5,-20(fp)
 204a448:	100d883a 	mov	r6,r2
 204a44c:	2007cf00 	call	2007cf0 <strncmp>
 204a450:	1000091e 	bne	r2,zero,204a478 <strippath+0x114>
      {
         path += dirlen;
 204a454:	e0bffd17 	ldw	r2,-12(fp)
 204a458:	e0fffb17 	ldw	r3,-20(fp)
 204a45c:	1885883a 	add	r2,r3,r2
 204a460:	e0bffb15 	stw	r2,-20(fp)
         ntmp += dirlen;
 204a464:	e0bffd17 	ldw	r2,-12(fp)
 204a468:	e0fffc17 	ldw	r3,-16(fp)
 204a46c:	1885883a 	add	r2,r3,r2
 204a470:	e0bffc15 	stw	r2,-16(fp)
 204a474:	00000206 	br	204a480 <strippath+0x11c>
      }
      else
         return NULL;   /* didn't match */
 204a478:	0005883a 	mov	r2,zero
 204a47c:	00002906 	br	204a524 <strippath+0x1c0>
   char *   ntmp; /* pointer into name text */
   int   dirlen;

   ntmp = uslash(name);      /* uslash() is defined in misclib\in_utils.c */
   path = http_root_path; /* The servers root path, at least one UNIX slash */
   while (*path && *ntmp)
 204a480:	e0bffb17 	ldw	r2,-20(fp)
 204a484:	10800003 	ldbu	r2,0(r2)
 204a488:	10803fcc 	andi	r2,r2,255
 204a48c:	1080201c 	xori	r2,r2,128
 204a490:	10bfe004 	addi	r2,r2,-128
 204a494:	10000826 	beq	r2,zero,204a4b8 <strippath+0x154>
 204a498:	e0bffc17 	ldw	r2,-16(fp)
 204a49c:	10800003 	ldbu	r2,0(r2)
 204a4a0:	10803fcc 	andi	r2,r2,255
 204a4a4:	1080201c 	xori	r2,r2,128
 204a4a8:	10bfe004 	addi	r2,r2,-128
 204a4ac:	103fbc1e 	bne	r2,zero,204a3a0 <strippath+0x3c>
 204a4b0:	00000106 	br	204a4b8 <strippath+0x154>
   {
      while (*path == '/') path++;   /* strip leading slash */
         if (*path == 0)
         break;
 204a4b4:	0001883a 	nop
         ntmp += dirlen;
      }
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
 204a4b8:	e0bffb17 	ldw	r2,-20(fp)
 204a4bc:	10800003 	ldbu	r2,0(r2)
 204a4c0:	10803fcc 	andi	r2,r2,255
 204a4c4:	1080201c 	xori	r2,r2,128
 204a4c8:	10bfe004 	addi	r2,r2,-128
 204a4cc:	1000141e 	bne	r2,zero,204a520 <strippath+0x1bc>
   {
      while (*ntmp == '\\' || *ntmp == '/')
 204a4d0:	00000306 	br	204a4e0 <strippath+0x17c>
         ntmp++;
 204a4d4:	e0bffc17 	ldw	r2,-16(fp)
 204a4d8:	10800044 	addi	r2,r2,1
 204a4dc:	e0bffc15 	stw	r2,-16(fp)
      else
         return NULL;   /* didn't match */
   }
   if (*path == '\0')
   {
      while (*ntmp == '\\' || *ntmp == '/')
 204a4e0:	e0bffc17 	ldw	r2,-16(fp)
 204a4e4:	10800003 	ldbu	r2,0(r2)
 204a4e8:	10803fcc 	andi	r2,r2,255
 204a4ec:	1080201c 	xori	r2,r2,128
 204a4f0:	10bfe004 	addi	r2,r2,-128
 204a4f4:	10801720 	cmpeqi	r2,r2,92
 204a4f8:	103ff61e 	bne	r2,zero,204a4d4 <strippath+0x170>
 204a4fc:	e0bffc17 	ldw	r2,-16(fp)
 204a500:	10800003 	ldbu	r2,0(r2)
 204a504:	10803fcc 	andi	r2,r2,255
 204a508:	1080201c 	xori	r2,r2,128
 204a50c:	10bfe004 	addi	r2,r2,-128
 204a510:	10800be0 	cmpeqi	r2,r2,47
 204a514:	103fef1e 	bne	r2,zero,204a4d4 <strippath+0x170>
         ntmp++;
      return ntmp;
 204a518:	e0bffc17 	ldw	r2,-16(fp)
 204a51c:	00000106 	br	204a524 <strippath+0x1c0>
   }
   else
      return NULL;
 204a520:	0005883a 	mov	r2,zero
}
 204a524:	e037883a 	mov	sp,fp
 204a528:	dfc00117 	ldw	ra,4(sp)
 204a52c:	df000017 	ldw	fp,0(sp)
 204a530:	dec00204 	addi	sp,sp,8
 204a534:	f800283a 	ret

0204a538 <isvfile_locked>:
 * RETURNS: 
 */

int
isvfile_locked(VFILE * vfp)
{
 204a538:	defffd04 	addi	sp,sp,-12
 204a53c:	df000215 	stw	fp,8(sp)
 204a540:	df000204 	addi	fp,sp,8
 204a544:	e13fff15 	stw	r4,-4(fp)
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 204a548:	d0a0cc17 	ldw	r2,-31952(gp)
 204a54c:	e0bffe15 	stw	r2,-8(fp)
 204a550:	00000806 	br	204a574 <isvfile_locked+0x3c>
      if (vtmp == vfp)
 204a554:	e0fffe17 	ldw	r3,-8(fp)
 204a558:	e0bfff17 	ldw	r2,-4(fp)
 204a55c:	1880021e 	bne	r3,r2,204a568 <isvfile_locked+0x30>
      return TRUE;
 204a560:	00800044 	movi	r2,1
 204a564:	00000606 	br	204a580 <isvfile_locked+0x48>
int
isvfile_locked(VFILE * vfp)
{
   VFILE * vtmp;

   for (vtmp = vfiles; vtmp; vtmp = vtmp->next)
 204a568:	e0bffe17 	ldw	r2,-8(fp)
 204a56c:	10800017 	ldw	r2,0(r2)
 204a570:	e0bffe15 	stw	r2,-8(fp)
 204a574:	e0bffe17 	ldw	r2,-8(fp)
 204a578:	103ff61e 	bne	r2,zero,204a554 <isvfile_locked+0x1c>
      if (vtmp == vfp)
      return TRUE;

   return FALSE;  /* passed pointer not found in list */
 204a57c:	0005883a 	mov	r2,zero
}
 204a580:	e037883a 	mov	sp,fp
 204a584:	df000017 	ldw	fp,0(sp)
 204a588:	dec00104 	addi	sp,sp,4
 204a58c:	f800283a 	ret

0204a590 <isvfile>:
 * RETURNS: 
 */

int
isvfile(VFILE * vfp)
{
 204a590:	defffc04 	addi	sp,sp,-16
 204a594:	dfc00315 	stw	ra,12(sp)
 204a598:	df000215 	stw	fp,8(sp)
 204a59c:	df000204 	addi	fp,sp,8
 204a5a0:	e13fff15 	stw	r4,-4(fp)
   int   rc;

   /* lock the VFS */
   vfs_lock();
 204a5a4:	01000144 	movi	r4,5
 204a5a8:	2028c100 	call	2028c10 <wait_app_sem>

   /* do the lookup */
   rc = isvfile_locked(vfp);
 204a5ac:	e13fff17 	ldw	r4,-4(fp)
 204a5b0:	204a5380 	call	204a538 <isvfile_locked>
 204a5b4:	e0bffe15 	stw	r2,-8(fp)

   /* unlock the VFS */
   vfs_unlock();
 204a5b8:	01000144 	movi	r4,5
 204a5bc:	2028ccc0 	call	2028ccc <post_app_sem>
   return rc;
 204a5c0:	e0bffe17 	ldw	r2,-8(fp)
}
 204a5c4:	e037883a 	mov	sp,fp
 204a5c8:	dfc00117 	ldw	ra,4(sp)
 204a5cc:	df000017 	ldw	fp,0(sp)
 204a5d0:	dec00204 	addi	sp,sp,8
 204a5d4:	f800283a 	ret

0204a5d8 <vferror>:
 * RETURNS: 
 */

int
vferror(VFILE * vfd)
{
 204a5d8:	defffd04 	addi	sp,sp,-12
 204a5dc:	dfc00215 	stw	ra,8(sp)
 204a5e0:	df000115 	stw	fp,4(sp)
 204a5e4:	df000104 	addi	fp,sp,4
 204a5e8:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 204a5ec:	01000144 	movi	r4,5
 204a5f0:	2028c100 	call	2028c10 <wait_app_sem>

   if (isvfile_locked(vfd))
 204a5f4:	e13fff17 	ldw	r4,-4(fp)
 204a5f8:	204a5380 	call	204a538 <isvfile_locked>
 204a5fc:	10000526 	beq	r2,zero,204a614 <vferror+0x3c>
   {
      vfs_unlock();
 204a600:	01000144 	movi	r4,5
 204a604:	2028ccc0 	call	2028ccc <post_app_sem>

      return vfd->error;
 204a608:	e0bfff17 	ldw	r2,-4(fp)
 204a60c:	10800417 	ldw	r2,16(r2)
 204a610:	00000306 	br	204a620 <vferror+0x48>
   }

   vfs_unlock();
 204a614:	01000144 	movi	r4,5
 204a618:	2028ccc0 	call	2028ccc <post_app_sem>

#ifdef HT_LOCALFS
   return(ferror((FILE*)vfd));
#else /* not a VFILE, and no local FS */
   return -1;  /* should this be an error? */
 204a61c:	00bfffc4 	movi	r2,-1
#endif   /* HT_LOCALFS */
}
 204a620:	e037883a 	mov	sp,fp
 204a624:	dfc00117 	ldw	ra,4(sp)
 204a628:	df000017 	ldw	fp,0(sp)
 204a62c:	dec00204 	addi	sp,sp,8
 204a630:	f800283a 	ret

0204a634 <vclearerr>:
 *
 * RETURNS: 
 */

void vclearerr(VFILE * vfd)
{
 204a634:	defffd04 	addi	sp,sp,-12
 204a638:	dfc00215 	stw	ra,8(sp)
 204a63c:	df000115 	stw	fp,4(sp)
 204a640:	df000104 	addi	fp,sp,4
 204a644:	e13fff15 	stw	r4,-4(fp)
   /* lock the VFS */
   vfs_lock();
 204a648:	01000144 	movi	r4,5
 204a64c:	2028c100 	call	2028c10 <wait_app_sem>

   if (isvfile_locked(vfd))
 204a650:	e13fff17 	ldw	r4,-4(fp)
 204a654:	204a5380 	call	204a538 <isvfile_locked>
 204a658:	10000526 	beq	r2,zero,204a670 <vclearerr+0x3c>
   {
      vfs_unlock();
 204a65c:	01000144 	movi	r4,5
 204a660:	2028ccc0 	call	2028ccc <post_app_sem>

      vfd->error = 0;
 204a664:	e0bfff17 	ldw	r2,-4(fp)
 204a668:	10000415 	stw	zero,16(r2)
      return;
 204a66c:	00000206 	br	204a678 <vclearerr+0x44>
   }

   vfs_unlock();
 204a670:	01000144 	movi	r4,5
 204a674:	2028ccc0 	call	2028ccc <post_app_sem>

#ifdef HT_LOCALFS
   clearerr((FILE *) vfd);
#endif   /* HT_LOCALFS */
}
 204a678:	e037883a 	mov	sp,fp
 204a67c:	dfc00117 	ldw	ra,4(sp)
 204a680:	df000017 	ldw	fp,0(sp)
 204a684:	dec00204 	addi	sp,sp,8
 204a688:	f800283a 	ret

0204a68c <prep_vfs>:
 * PARAMS: NONE
 *
 * RETURNS: Error Code or 0 for OK
 */
int prep_vfs(void)
{
 204a68c:	defffe04 	addi	sp,sp,-8
 204a690:	df000115 	stw	fp,4(sp)
 204a694:	df000104 	addi	fp,sp,4
int e = 0;
 204a698:	e03fff15 	stw	zero,-4(fp)
   {
      dprintf("unable to install VFS NVPARMS, reconfigure nv_formats[]\n");
      dtrap();
   }
#endif   /* INCLUDE_NVPARMS */
   return e;
 204a69c:	e0bfff17 	ldw	r2,-4(fp)
}
 204a6a0:	e037883a 	mov	sp,fp
 204a6a4:	df000017 	ldw	fp,0(sp)
 204a6a8:	dec00104 	addi	sp,sp,4
 204a6ac:	f800283a 	ret

0204a6b0 <alt_get_errno>:
#undef errno

extern int errno;

static ALT_INLINE int* alt_get_errno(void)
{
 204a6b0:	defffe04 	addi	sp,sp,-8
 204a6b4:	dfc00115 	stw	ra,4(sp)
 204a6b8:	df000015 	stw	fp,0(sp)
 204a6bc:	d839883a 	mov	fp,sp
  return ((alt_errno) ? alt_errno() : &errno);
 204a6c0:	00808174 	movhi	r2,517
 204a6c4:	10907704 	addi	r2,r2,16860
 204a6c8:	10800017 	ldw	r2,0(r2)
 204a6cc:	10000526 	beq	r2,zero,204a6e4 <alt_get_errno+0x34>
 204a6d0:	00808174 	movhi	r2,517
 204a6d4:	10907704 	addi	r2,r2,16860
 204a6d8:	10800017 	ldw	r2,0(r2)
 204a6dc:	103ee83a 	callr	r2
 204a6e0:	00000206 	br	204a6ec <alt_get_errno+0x3c>
 204a6e4:	00808174 	movhi	r2,517
 204a6e8:	10908b04 	addi	r2,r2,16940
}
 204a6ec:	e037883a 	mov	sp,fp
 204a6f0:	dfc00117 	ldw	ra,4(sp)
 204a6f4:	df000017 	ldw	fp,0(sp)
 204a6f8:	dec00204 	addi	sp,sp,8
 204a6fc:	f800283a 	ret

0204a700 <alt_fcntl>:
 *
 * ALT_FCNTL is mapped onto the fcntl() system call in alt_syscall.h
 */
 
int ALT_FCNTL (int file, int cmd, ...)
{ 
 204a700:	defff704 	addi	sp,sp,-36
 204a704:	dfc00615 	stw	ra,24(sp)
 204a708:	df000515 	stw	fp,20(sp)
 204a70c:	df000504 	addi	fp,sp,20
 204a710:	e13ffe15 	stw	r4,-8(fp)
 204a714:	e1800215 	stw	r6,8(fp)
 204a718:	e1c00315 	stw	r7,12(fp)
 204a71c:	e17fff15 	stw	r5,-4(fp)
   * A common error case is that when the file descriptor was created, the call
   * to open() failed resulting in a negative file descriptor. This is trapped
   * below so that we don't try and process an invalid file descriptor.
   */

  fd = (file < 0) ? NULL : &alt_fd_list[file];
 204a720:	e0bffe17 	ldw	r2,-8(fp)
 204a724:	10000616 	blt	r2,zero,204a740 <alt_fcntl+0x40>
 204a728:	e0bffe17 	ldw	r2,-8(fp)
 204a72c:	10c00324 	muli	r3,r2,12
 204a730:	00808174 	movhi	r2,517
 204a734:	108f1e04 	addi	r2,r2,15480
 204a738:	1885883a 	add	r2,r3,r2
 204a73c:	00000106 	br	204a744 <alt_fcntl+0x44>
 204a740:	0005883a 	mov	r2,zero
 204a744:	e0bffb15 	stw	r2,-20(fp)
  
  if (fd)
 204a748:	e0bffb17 	ldw	r2,-20(fp)
 204a74c:	10002926 	beq	r2,zero,204a7f4 <alt_fcntl+0xf4>
  {
    switch (cmd)
 204a750:	e0bfff17 	ldw	r2,-4(fp)
 204a754:	10c000e0 	cmpeqi	r3,r2,3
 204a758:	1800031e 	bne	r3,zero,204a768 <alt_fcntl+0x68>
 204a75c:	10800120 	cmpeqi	r2,r2,4
 204a760:	1000071e 	bne	r2,zero,204a780 <alt_fcntl+0x80>
 204a764:	00001e06 	br	204a7e0 <alt_fcntl+0xe0>
    {
    case F_GETFL:
      return fd->fd_flags & ~((alt_u32) ALT_FD_FLAGS_MASK);
 204a768:	e0bffb17 	ldw	r2,-20(fp)
 204a76c:	10c00217 	ldw	r3,8(r2)
 204a770:	00900034 	movhi	r2,16384
 204a774:	10bfffc4 	addi	r2,r2,-1
 204a778:	1884703a 	and	r2,r3,r2
 204a77c:	00002106 	br	204a804 <alt_fcntl+0x104>
    case F_SETFL:
      va_start(argp, cmd);
 204a780:	e0800204 	addi	r2,fp,8
 204a784:	e0bffd15 	stw	r2,-12(fp)
      flags = va_arg(argp, long);
 204a788:	e0bffd17 	ldw	r2,-12(fp)
 204a78c:	10c00104 	addi	r3,r2,4
 204a790:	e0fffd15 	stw	r3,-12(fp)
 204a794:	10800017 	ldw	r2,0(r2)
 204a798:	e0bffc15 	stw	r2,-16(fp)
      fd->fd_flags &= ~ALT_FCNTL_FLAGS_MASK;
 204a79c:	e0bffb17 	ldw	r2,-20(fp)
 204a7a0:	10c00217 	ldw	r3,8(r2)
 204a7a4:	00affdc4 	movi	r2,-16393
 204a7a8:	1886703a 	and	r3,r3,r2
 204a7ac:	e0bffb17 	ldw	r2,-20(fp)
 204a7b0:	10c00215 	stw	r3,8(r2)
      fd->fd_flags |= (flags & ALT_FCNTL_FLAGS_MASK);
 204a7b4:	e0bffb17 	ldw	r2,-20(fp)
 204a7b8:	10800217 	ldw	r2,8(r2)
 204a7bc:	1007883a 	mov	r3,r2
 204a7c0:	e0bffc17 	ldw	r2,-16(fp)
 204a7c4:	1090020c 	andi	r2,r2,16392
 204a7c8:	1884b03a 	or	r2,r3,r2
 204a7cc:	1007883a 	mov	r3,r2
 204a7d0:	e0bffb17 	ldw	r2,-20(fp)
 204a7d4:	10c00215 	stw	r3,8(r2)
      va_end(argp);
      return 0;
 204a7d8:	0005883a 	mov	r2,zero
 204a7dc:	00000906 	br	204a804 <alt_fcntl+0x104>
    default:
      ALT_ERRNO = EINVAL;
 204a7e0:	204a6b00 	call	204a6b0 <alt_get_errno>
 204a7e4:	00c00584 	movi	r3,22
 204a7e8:	10c00015 	stw	r3,0(r2)
      return -1;
 204a7ec:	00bfffc4 	movi	r2,-1
 204a7f0:	00000406 	br	204a804 <alt_fcntl+0x104>
    }
  }

  ALT_ERRNO = EBADFD;
 204a7f4:	204a6b00 	call	204a6b0 <alt_get_errno>
 204a7f8:	00c01444 	movi	r3,81
 204a7fc:	10c00015 	stw	r3,0(r2)
  return -1;
 204a800:	00bfffc4 	movi	r2,-1
}
 204a804:	e037883a 	mov	sp,fp
 204a808:	dfc00117 	ldw	ra,4(sp)
 204a80c:	df000017 	ldw	fp,0(sp)
 204a810:	dec00404 	addi	sp,sp,16
 204a814:	f800283a 	ret

0204a818 <usleep>:
#if defined (__GNUC__) && __GNUC__ >= 4
int ALT_USLEEP (useconds_t us)
#else
unsigned int ALT_USLEEP (unsigned int us)
#endif
{
 204a818:	defffb04 	addi	sp,sp,-20
 204a81c:	dfc00415 	stw	ra,16(sp)
 204a820:	df000315 	stw	fp,12(sp)
 204a824:	df000304 	addi	fp,sp,12
 204a828:	e13fff15 	stw	r4,-4(fp)
   * If the O/S hasn't started yet, then we delay using a busy loop, rather than
   * OSTimeDly (since this would fail). The use of a busy loop is acceptable,
   * since the system is still running in a single-threaded mode.
   */ 

  if (OSRunning == OS_FALSE)
 204a82c:	00808174 	movhi	r2,517
 204a830:	10909b44 	addi	r2,r2,17005
 204a834:	10800003 	ldbu	r2,0(r2)
 204a838:	10803fcc 	andi	r2,r2,255
 204a83c:	1000031e 	bne	r2,zero,204a84c <usleep+0x34>
  {
    return alt_busy_sleep (us);
 204a840:	e13fff17 	ldw	r4,-4(fp)
 204a844:	204bbb40 	call	204bbb4 <alt_busy_sleep>
 204a848:	00003306 	br	204a918 <usleep+0x100>
 * Obtain the system clock rate in ticks/s. 
 */

static ALT_INLINE alt_u32 ALT_ALWAYS_INLINE alt_ticks_per_second (void)
{
  return _alt_tick_rate;
 204a84c:	00808174 	movhi	r2,517
 204a850:	10909504 	addi	r2,r2,16980
 204a854:	10800017 	ldw	r2,0(r2)

  /* 
   * Calculate the number of whole system clock ticks to delay.
   */

  tick_rate = alt_ticks_per_second ();
 204a858:	e0bffe15 	stw	r2,-8(fp)
  ticks     = (us/ALT_US)* tick_rate + ((us%ALT_US)*tick_rate)/ALT_US;
 204a85c:	e0ffff17 	ldw	r3,-4(fp)
 204a860:	008003f4 	movhi	r2,15
 204a864:	10909004 	addi	r2,r2,16960
 204a868:	1887203a 	divu	r3,r3,r2
 204a86c:	e0bffe17 	ldw	r2,-8(fp)
 204a870:	1887383a 	mul	r3,r3,r2
 204a874:	e0bfff17 	ldw	r2,-4(fp)
 204a878:	010003f4 	movhi	r4,15
 204a87c:	21109004 	addi	r4,r4,16960
 204a880:	110b203a 	divu	r5,r2,r4
 204a884:	010003f4 	movhi	r4,15
 204a888:	21109004 	addi	r4,r4,16960
 204a88c:	2909383a 	mul	r4,r5,r4
 204a890:	1109c83a 	sub	r4,r2,r4
 204a894:	e0bffe17 	ldw	r2,-8(fp)
 204a898:	2089383a 	mul	r4,r4,r2
 204a89c:	008003f4 	movhi	r2,15
 204a8a0:	10909004 	addi	r2,r2,16960
 204a8a4:	2085203a 	divu	r2,r4,r2
 204a8a8:	1885883a 	add	r2,r3,r2
 204a8ac:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 204a8b0:	00000706 	br	204a8d0 <usleep+0xb8>
  {
    OSTimeDly(0xffff);
 204a8b4:	013fffd4 	movui	r4,65535
 204a8b8:	201e00c0 	call	201e00c <OSTimeDly>
    ticks -= 0xffff;
 204a8bc:	e0fffd17 	ldw	r3,-12(fp)
 204a8c0:	00bffff4 	movhi	r2,65535
 204a8c4:	10800044 	addi	r2,r2,1
 204a8c8:	1885883a 	add	r2,r3,r2
 204a8cc:	e0bffd15 	stw	r2,-12(fp)
   * OSTimeDly can only delay for a maximum of 0xffff ticks, so if the requested
   * delay is greater than that, we need to break it down into a number of
   * seperate delays.
   */

  while (ticks > 0xffff)
 204a8d0:	e0bffd17 	ldw	r2,-12(fp)
 204a8d4:	00ffffd4 	movui	r3,65535
 204a8d8:	18bff636 	bltu	r3,r2,204a8b4 <usleep+0x9c>
  {
    OSTimeDly(0xffff);
    ticks -= 0xffff;
  }

  OSTimeDly ((INT16U) (ticks));
 204a8dc:	e0bffd17 	ldw	r2,-12(fp)
 204a8e0:	10bfffcc 	andi	r2,r2,65535
 204a8e4:	1009883a 	mov	r4,r2
 204a8e8:	201e00c0 	call	201e00c <OSTimeDly>
  /*
   * Now delay by the remainder using a busy loop. This is here in order to
   * provide very short delays of less than one clock tick.
   */

  alt_busy_sleep (us%(ALT_US/tick_rate));  
 204a8ec:	00c003f4 	movhi	r3,15
 204a8f0:	18d09004 	addi	r3,r3,16960
 204a8f4:	e0bffe17 	ldw	r2,-8(fp)
 204a8f8:	1887203a 	divu	r3,r3,r2
 204a8fc:	e0bfff17 	ldw	r2,-4(fp)
 204a900:	10c9203a 	divu	r4,r2,r3
 204a904:	20c7383a 	mul	r3,r4,r3
 204a908:	10c5c83a 	sub	r2,r2,r3
 204a90c:	1009883a 	mov	r4,r2
 204a910:	204bbb40 	call	204bbb4 <alt_busy_sleep>

  return 0;  
 204a914:	0005883a 	mov	r2,zero
}
 204a918:	e037883a 	mov	sp,fp
 204a91c:	dfc00117 	ldw	ra,4(sp)
 204a920:	df000017 	ldw	fp,0(sp)
 204a924:	dec00204 	addi	sp,sp,8
 204a928:	f800283a 	ret

0204a92c <icmprcv>:
};
#endif /* USER_PING_TSTAMP */

int
icmprcv(PACKET p)      /* the incoming packet */
{
 204a92c:	deffef04 	addi	sp,sp,-68
 204a930:	dfc01015 	stw	ra,64(sp)
 204a934:	df000f15 	stw	fp,60(sp)
 204a938:	dc400e15 	stw	r17,56(sp)
 204a93c:	dc000d15 	stw	r16,52(sp)
 204a940:	df000d04 	addi	fp,sp,52
 204a944:	e13fff15 	stw	r4,-4(fp)
   unsigned short xsum;
#ifdef FULL_ICMP
   struct redirect * rd;
   struct destun *   pdp;
#endif   /* FULL_ICMP */
   char sav_ch = 0;
 204a948:	e03ff505 	stb	zero,-44(fp)
   int i;

   icmp_mib.icmpInMsgs++;                 /* received one more icmp */
 204a94c:	00809934 	movhi	r2,612
 204a950:	10b7f104 	addi	r2,r2,-8252
 204a954:	10800017 	ldw	r2,0(r2)
 204a958:	10c00044 	addi	r3,r2,1
 204a95c:	00809934 	movhi	r2,612
 204a960:	10b7f104 	addi	r2,r2,-8252
 204a964:	10c00015 	stw	r3,0(r2)

   pip = ip_head(p);                      /* find IP header */
 204a968:	e0bfff17 	ldw	r2,-4(fp)
 204a96c:	10800317 	ldw	r2,12(r2)
 204a970:	e0bff615 	stw	r2,-40(fp)
   len = p->nb_plen - (ip_hlen(pip));     /* strip IP header length */
 204a974:	e0bfff17 	ldw	r2,-4(fp)
 204a978:	10c00417 	ldw	r3,16(r2)
 204a97c:	e0bff617 	ldw	r2,-40(fp)
 204a980:	10800003 	ldbu	r2,0(r2)
 204a984:	10803fcc 	andi	r2,r2,255
 204a988:	108003cc 	andi	r2,r2,15
 204a98c:	1085883a 	add	r2,r2,r2
 204a990:	1085883a 	add	r2,r2,r2
 204a994:	1885c83a 	sub	r2,r3,r2
 204a998:	e0bff715 	stw	r2,-36(fp)
   host = p->fhost;                       /* filled in by IP layer */
 204a99c:	e0bfff17 	ldw	r2,-4(fp)
 204a9a0:	10800717 	ldw	r2,28(r2)
 204a9a4:	e0bff815 	stw	r2,-32(fp)

#ifdef   NPDEBUG
   if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 204a9a8:	00808174 	movhi	r2,517
 204a9ac:	1090b204 	addi	r2,r2,17096
 204a9b0:	10800017 	ldw	r2,0(r2)
 204a9b4:	1081000c 	andi	r2,r2,1024
 204a9b8:	10001726 	beq	r2,zero,204aa18 <icmprcv+0xec>
 204a9bc:	00808174 	movhi	r2,517
 204a9c0:	1090b204 	addi	r2,r2,17096
 204a9c4:	10800017 	ldw	r2,0(r2)
 204a9c8:	1080800c 	andi	r2,r2,512
 204a9cc:	10001226 	beq	r2,zero,204aa18 <icmprcv+0xec>
      dprintf("ICMP: p[%u] from %u.%u.%u.%u\n", len, PUSH_IPADDR(host));
 204a9d0:	e0bff817 	ldw	r2,-32(fp)
 204a9d4:	10c03fcc 	andi	r3,r2,255
 204a9d8:	e0bff817 	ldw	r2,-32(fp)
 204a9dc:	1004d23a 	srli	r2,r2,8
 204a9e0:	10803fcc 	andi	r2,r2,255
 204a9e4:	e13ff817 	ldw	r4,-32(fp)
 204a9e8:	2008d43a 	srli	r4,r4,16
 204a9ec:	21403fcc 	andi	r5,r4,255
 204a9f0:	e13ff817 	ldw	r4,-32(fp)
 204a9f4:	2008d63a 	srli	r4,r4,24
 204a9f8:	d9400015 	stw	r5,0(sp)
 204a9fc:	d9000115 	stw	r4,4(sp)
 204aa00:	01008174 	movhi	r4,517
 204aa04:	2107a404 	addi	r4,r4,7824
 204aa08:	e17ff717 	ldw	r5,-36(fp)
 204aa0c:	180d883a 	mov	r6,r3
 204aa10:	100f883a 	mov	r7,r2
 204aa14:	2006a240 	call	2006a24 <printf>
#endif

   e = (struct ping *)ip_data(pip);       /* finally, extract ICMP header */
 204aa18:	e0bff617 	ldw	r2,-40(fp)
 204aa1c:	10800003 	ldbu	r2,0(r2)
 204aa20:	10803fcc 	andi	r2,r2,255
 204aa24:	108003cc 	andi	r2,r2,15
 204aa28:	1085883a 	add	r2,r2,r2
 204aa2c:	1085883a 	add	r2,r2,r2
 204aa30:	e0fff617 	ldw	r3,-40(fp)
 204aa34:	1885883a 	add	r2,r3,r2
 204aa38:	e0bff915 	stw	r2,-28(fp)

   osum = e->pchksum;
 204aa3c:	e0bff917 	ldw	r2,-28(fp)
 204aa40:	1080008b 	ldhu	r2,2(r2)
 204aa44:	e0bffa0d 	sth	r2,-24(fp)
   e->pchksum = 0;
 204aa48:	e0bff917 	ldw	r2,-28(fp)
 204aa4c:	1000008d 	sth	zero,2(r2)

   if (len&1)
 204aa50:	e0bff717 	ldw	r2,-36(fp)
 204aa54:	1080004c 	andi	r2,r2,1
 204aa58:	10000926 	beq	r2,zero,204aa80 <icmprcv+0x154>
   {
      sav_ch = *(((char *) e) + len);
 204aa5c:	e0fff917 	ldw	r3,-28(fp)
 204aa60:	e0bff717 	ldw	r2,-36(fp)
 204aa64:	1885883a 	add	r2,r3,r2
 204aa68:	10800003 	ldbu	r2,0(r2)
 204aa6c:	e0bff505 	stb	r2,-44(fp)
      ((char *)e)[len] = 0;
 204aa70:	e0fff917 	ldw	r3,-28(fp)
 204aa74:	e0bff717 	ldw	r2,-36(fp)
 204aa78:	1885883a 	add	r2,r3,r2
 204aa7c:	10000005 	stb	zero,0(r2)
   }

   xsum = ~cksum(e, (len+1)>>1);
 204aa80:	e0bff717 	ldw	r2,-36(fp)
 204aa84:	10800044 	addi	r2,r2,1
 204aa88:	1004d07a 	srli	r2,r2,1
 204aa8c:	e13ff917 	ldw	r4,-28(fp)
 204aa90:	100b883a 	mov	r5,r2
 204aa94:	20268040 	call	2026804 <cksum>
 204aa98:	0084303a 	nor	r2,zero,r2
 204aa9c:	e0bffa8d 	sth	r2,-22(fp)
   if (len&1) *(((char *) e) + len) = sav_ch;
 204aaa0:	e0bff717 	ldw	r2,-36(fp)
 204aaa4:	1080004c 	andi	r2,r2,1
 204aaa8:	10000526 	beq	r2,zero,204aac0 <icmprcv+0x194>
 204aaac:	e0fff917 	ldw	r3,-28(fp)
 204aab0:	e0bff717 	ldw	r2,-36(fp)
 204aab4:	1885883a 	add	r2,r3,r2
 204aab8:	e0fff503 	ldbu	r3,-44(fp)
 204aabc:	10c00005 	stb	r3,0(r2)
   if (xsum != osum)
 204aac0:	e0fffa8b 	ldhu	r3,-22(fp)
 204aac4:	e0bffa0b 	ldhu	r2,-24(fp)
 204aac8:	18802a26 	beq	r3,r2,204ab74 <icmprcv+0x248>
   {
      e->pchksum = osum;
 204aacc:	e0bff917 	ldw	r2,-28(fp)
 204aad0:	e0fffa0b 	ldhu	r3,-24(fp)
 204aad4:	10c0008d 	sth	r3,2(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 204aad8:	00808174 	movhi	r2,517
 204aadc:	1090b204 	addi	r2,r2,17096
 204aae0:	10800017 	ldw	r2,0(r2)
 204aae4:	1081000c 	andi	r2,r2,1024
 204aae8:	10001326 	beq	r2,zero,204ab38 <icmprcv+0x20c>
 204aaec:	00808174 	movhi	r2,517
 204aaf0:	1090b204 	addi	r2,r2,17096
 204aaf4:	10800017 	ldw	r2,0(r2)
 204aaf8:	1080800c 	andi	r2,r2,512
 204aafc:	10000e26 	beq	r2,zero,204ab38 <icmprcv+0x20c>
      {
         dprintf("ICMP: Bad xsum %04x should have been %04x\n",
 204ab00:	e0fffa0b 	ldhu	r3,-24(fp)
 204ab04:	e0bffa8b 	ldhu	r2,-22(fp)
 204ab08:	01008174 	movhi	r4,517
 204ab0c:	2107ac04 	addi	r4,r4,7856
 204ab10:	180b883a 	mov	r5,r3
 204ab14:	100d883a 	mov	r6,r2
 204ab18:	2006a240 	call	2006a24 <printf>
          osum, xsum);
         if (NDEBUG & DUMP) ip_dump(p);
 204ab1c:	00808174 	movhi	r2,517
 204ab20:	1090b204 	addi	r2,r2,17096
 204ab24:	10800017 	ldw	r2,0(r2)
 204ab28:	1080008c 	andi	r2,r2,2
 204ab2c:	10000226 	beq	r2,zero,204ab38 <icmprcv+0x20c>
 204ab30:	e13fff17 	ldw	r4,-4(fp)
 204ab34:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif
      icmp_mib.icmpInErrors++;
 204ab38:	00809934 	movhi	r2,612
 204ab3c:	10b7f104 	addi	r2,r2,-8252
 204ab40:	10800117 	ldw	r2,4(r2)
 204ab44:	10c00044 	addi	r3,r2,1
 204ab48:	00809934 	movhi	r2,612
 204ab4c:	10b7f104 	addi	r2,r2,-8252
 204ab50:	10c00115 	stw	r3,4(r2)
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204ab54:	01000084 	movi	r4,2
 204ab58:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204ab5c:	e13fff17 	ldw	r4,-4(fp)
 204ab60:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204ab64:	01000084 	movi	r4,2
 204ab68:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_BAD_HEADER;
 204ab6c:	00bff804 	movi	r2,-32
 204ab70:	00026106 	br	204b4f8 <icmprcv+0xbcc>
   }

   e->pchksum = osum;
 204ab74:	e0bff917 	ldw	r2,-28(fp)
 204ab78:	e0fffa0b 	ldhu	r3,-24(fp)
 204ab7c:	10c0008d 	sth	r3,2(r2)

   switch (e->ptype) 
 204ab80:	e0bff917 	ldw	r2,-28(fp)
 204ab84:	10800003 	ldbu	r2,0(r2)
 204ab88:	10803fcc 	andi	r2,r2,255
 204ab8c:	1080201c 	xori	r2,r2,128
 204ab90:	10bfe004 	addi	r2,r2,-128
 204ab94:	10c00428 	cmpgeui	r3,r2,16
 204ab98:	1802391e 	bne	r3,zero,204b480 <icmprcv+0xb54>
 204ab9c:	1085883a 	add	r2,r2,r2
 204aba0:	1087883a 	add	r3,r2,r2
 204aba4:	00808174 	movhi	r2,517
 204aba8:	10aaee04 	addi	r2,r2,-21576
 204abac:	1885883a 	add	r2,r3,r2
 204abb0:	10800017 	ldw	r2,0(r2)
 204abb4:	1000683a 	jmp	r2
 204abb8:	0204ae80 	call	204ae8 <__alt_mem_descriptor_memory+0x202ee8>
 204abbc:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abc0:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abc4:	0204aea8 	cmpgeui	r8,zero,4794
 204abc8:	0204afa4 	muli	r8,zero,4798
 204abcc:	0204b04c 	andi	r8,zero,4801
 204abd0:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abd4:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abd8:	0204abf8 	rdprs	r8,zero,4783
 204abdc:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abe0:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abe4:	0204b17c 	xorhi	r8,zero,4805
 204abe8:	0204b28c 	andi	r8,zero,4810
 204abec:	0204b300 	call	204b30 <__alt_mem_descriptor_memory+0x202f30>
 204abf0:	0204b480 	call	204b48 <__alt_mem_descriptor_memory+0x202f48>
 204abf4:	0204b444 	movi	r8,4817
   {
   case ECHOREQ:  /* got ping request, send reply */
      icmp_mib.icmpInEchos++;
 204abf8:	00809934 	movhi	r2,612
 204abfc:	10b7f104 	addi	r2,r2,-8252
 204ac00:	10800717 	ldw	r2,28(r2)
 204ac04:	10c00044 	addi	r3,r2,1
 204ac08:	00809934 	movhi	r2,612
 204ac0c:	10b7f104 	addi	r2,r2,-8252
 204ac10:	10c00715 	stw	r3,28(r2)
#ifdef   NPDEBUG
      if ((NDEBUG & UPCTRACE) && (NDEBUG & IPTRACE))
 204ac14:	00808174 	movhi	r2,517
 204ac18:	1090b204 	addi	r2,r2,17096
 204ac1c:	10800017 	ldw	r2,0(r2)
 204ac20:	1081000c 	andi	r2,r2,1024
 204ac24:	10001526 	beq	r2,zero,204ac7c <icmprcv+0x350>
 204ac28:	00808174 	movhi	r2,517
 204ac2c:	1090b204 	addi	r2,r2,17096
 204ac30:	10800017 	ldw	r2,0(r2)
 204ac34:	1080800c 	andi	r2,r2,512
 204ac38:	10001026 	beq	r2,zero,204ac7c <icmprcv+0x350>
         dprintf("ICMP: echo reply to %u.%u.%u.%u\n", PUSH_IPADDR(host));
 204ac3c:	e0bff817 	ldw	r2,-32(fp)
 204ac40:	11403fcc 	andi	r5,r2,255
 204ac44:	e0bff817 	ldw	r2,-32(fp)
 204ac48:	1004d23a 	srli	r2,r2,8
 204ac4c:	10c03fcc 	andi	r3,r2,255
 204ac50:	e0bff817 	ldw	r2,-32(fp)
 204ac54:	1004d43a 	srli	r2,r2,16
 204ac58:	10803fcc 	andi	r2,r2,255
 204ac5c:	e13ff817 	ldw	r4,-32(fp)
 204ac60:	2008d63a 	srli	r4,r4,24
 204ac64:	d9000015 	stw	r4,0(sp)
 204ac68:	01008174 	movhi	r4,517
 204ac6c:	2107b704 	addi	r4,r4,7900
 204ac70:	180d883a 	mov	r6,r3
 204ac74:	100f883a 	mov	r7,r2
 204ac78:	2006a240 	call	2006a24 <printf>
#endif
      e->ptype = ECHOREP;
 204ac7c:	e0bff917 	ldw	r2,-28(fp)
 204ac80:	10000005 	stb	zero,0(r2)
      e->pchksum = 0;
 204ac84:	e0bff917 	ldw	r2,-28(fp)
 204ac88:	1000008d 	sth	zero,2(r2)
      if (len&1)  /* pad odd length packets for checksum routine */
 204ac8c:	e0bff717 	ldw	r2,-36(fp)
 204ac90:	1080004c 	andi	r2,r2,1
 204ac94:	10000926 	beq	r2,zero,204acbc <icmprcv+0x390>
      {
         sav_ch = *(((char *) e) + len);
 204ac98:	e0fff917 	ldw	r3,-28(fp)
 204ac9c:	e0bff717 	ldw	r2,-36(fp)
 204aca0:	1885883a 	add	r2,r3,r2
 204aca4:	10800003 	ldbu	r2,0(r2)
 204aca8:	e0bff505 	stb	r2,-44(fp)
         ((char *)e)[len] = 0;
 204acac:	e0fff917 	ldw	r3,-28(fp)
 204acb0:	e0bff717 	ldw	r2,-36(fp)
 204acb4:	1885883a 	add	r2,r3,r2
 204acb8:	10000005 	stb	zero,0(r2)
      }

      e->pchksum = ~cksum(e, (len+1)>>1);
 204acbc:	e0bff717 	ldw	r2,-36(fp)
 204acc0:	10800044 	addi	r2,r2,1
 204acc4:	1004d07a 	srli	r2,r2,1
 204acc8:	e13ff917 	ldw	r4,-28(fp)
 204accc:	100b883a 	mov	r5,r2
 204acd0:	20268040 	call	2026804 <cksum>
 204acd4:	0084303a 	nor	r2,zero,r2
 204acd8:	1007883a 	mov	r3,r2
 204acdc:	e0bff917 	ldw	r2,-28(fp)
 204ace0:	10c0008d 	sth	r3,2(r2)
      if (len&1) *(((char *) e) + len) = sav_ch;
 204ace4:	e0bff717 	ldw	r2,-36(fp)
 204ace8:	1080004c 	andi	r2,r2,1
 204acec:	10000526 	beq	r2,zero,204ad04 <icmprcv+0x3d8>
 204acf0:	e0fff917 	ldw	r3,-28(fp)
 204acf4:	e0bff717 	ldw	r2,-36(fp)
 204acf8:	1885883a 	add	r2,r3,r2
 204acfc:	e0fff503 	ldbu	r3,-44(fp)
 204ad00:	10c00005 	stb	r3,0(r2)
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 204ad04:	e0bff617 	ldw	r2,-40(fp)
 204ad08:	10800417 	ldw	r2,16(r2)
 204ad0c:	10bfffe0 	cmpeqi	r2,r2,-1
 204ad10:	10001f1e 	bne	r2,zero,204ad90 <icmprcv+0x464>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 204ad14:	e0bff617 	ldw	r2,-40(fp)
 204ad18:	10800417 	ldw	r2,16(r2)
 204ad1c:	1006d63a 	srli	r3,r2,24
 204ad20:	e0bff617 	ldw	r2,-40(fp)
 204ad24:	10800417 	ldw	r2,16(r2)
 204ad28:	1004d23a 	srli	r2,r2,8
 204ad2c:	10bfc00c 	andi	r2,r2,65280
 204ad30:	1886b03a 	or	r3,r3,r2
 204ad34:	e0bff617 	ldw	r2,-40(fp)
 204ad38:	10800417 	ldw	r2,16(r2)
 204ad3c:	10bfc00c 	andi	r2,r2,65280
 204ad40:	1004923a 	slli	r2,r2,8
 204ad44:	1886b03a 	or	r3,r3,r2
 204ad48:	e0bff617 	ldw	r2,-40(fp)
 204ad4c:	10800417 	ldw	r2,16(r2)
 204ad50:	1004963a 	slli	r2,r2,24
 204ad54:	1884b03a 	or	r2,r3,r2
 204ad58:	10fc002c 	andhi	r3,r2,61440
      if (len&1) *(((char *) e) + len) = sav_ch;
      /* check to see if the destination is the IPv4 broadcast address,
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
 204ad5c:	00b80034 	movhi	r2,57344
 204ad60:	18800b26 	beq	r3,r2,204ad90 <icmprcv+0x464>
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
 204ad64:	e0bff617 	ldw	r2,-40(fp)
 204ad68:	10c00417 	ldw	r3,16(r2)
 204ad6c:	e0bfff17 	ldw	r2,-4(fp)
 204ad70:	10800617 	ldw	r2,24(r2)
 204ad74:	11000a17 	ldw	r4,40(r2)
 204ad78:	e0bfff17 	ldw	r2,-4(fp)
 204ad7c:	10800617 	ldw	r2,24(r2)
 204ad80:	10800c17 	ldw	r2,48(r2)
 204ad84:	0084303a 	nor	r2,zero,r2
 204ad88:	2084b03a 	or	r2,r4,r2
       * or if the destination is a multicast group address, or if the
       * destination address is the subnet-directed broadcast 
       */
      if ((pip->ip_dest == 0xffffffff) || 
#ifdef IP_MULTICAST
          (IN_MULTICAST(ntohl(pip->ip_dest))) ||
 204ad8c:	1880061e 	bne	r3,r2,204ada8 <icmprcv+0x47c>
#endif
          (pip->ip_dest == (p->net->n_ipaddr | (~(p->net->snmask)))))
      {
         pip->ip_src = p->net->n_ipaddr;
 204ad90:	e0bfff17 	ldw	r2,-4(fp)
 204ad94:	10800617 	ldw	r2,24(r2)
 204ad98:	10c00a17 	ldw	r3,40(r2)
 204ad9c:	e0bff617 	ldw	r2,-40(fp)
 204ada0:	10c00315 	stw	r3,12(r2)
 204ada4:	00000406 	br	204adb8 <icmprcv+0x48c>
      }
      else pip->ip_src = pip->ip_dest;
 204ada8:	e0bff617 	ldw	r2,-40(fp)
 204adac:	10c00417 	ldw	r3,16(r2)
 204adb0:	e0bff617 	ldw	r2,-40(fp)
 204adb4:	10c00315 	stw	r3,12(r2)

      pip->ip_dest = host;
 204adb8:	e0bff617 	ldw	r2,-40(fp)
 204adbc:	e0fff817 	ldw	r3,-32(fp)
 204adc0:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutEchoReps++;
 204adc4:	00809934 	movhi	r2,612
 204adc8:	10b7f104 	addi	r2,r2,-8252
 204adcc:	10801517 	ldw	r2,84(r2)
 204add0:	10c00044 	addi	r3,r2,1
 204add4:	00809934 	movhi	r2,612
 204add8:	10b7f104 	addi	r2,r2,-8252
 204addc:	10c01515 	stw	r3,84(r2)
      icmp_mib.icmpOutMsgs++;
 204ade0:	00809934 	movhi	r2,612
 204ade4:	10b7f104 	addi	r2,r2,-8252
 204ade8:	10800d17 	ldw	r2,52(r2)
 204adec:	10c00044 	addi	r3,r2,1
 204adf0:	00809934 	movhi	r2,612
 204adf4:	10b7f104 	addi	r2,r2,-8252
 204adf8:	10c00d15 	stw	r3,52(r2)
      p->fhost = host;
 204adfc:	e0bfff17 	ldw	r2,-4(fp)
 204ae00:	e0fff817 	ldw	r3,-32(fp)
 204ae04:	10c00715 	stw	r3,28(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 204ae08:	e0bfff17 	ldw	r2,-4(fp)
 204ae0c:	10c00317 	ldw	r3,12(r2)
 204ae10:	e0bff617 	ldw	r2,-40(fp)
 204ae14:	10800003 	ldbu	r2,0(r2)
 204ae18:	10803fcc 	andi	r2,r2,255
 204ae1c:	108003cc 	andi	r2,r2,15
 204ae20:	1085883a 	add	r2,r2,r2
 204ae24:	1085883a 	add	r2,r2,r2
 204ae28:	1887883a 	add	r3,r3,r2
 204ae2c:	e0bfff17 	ldw	r2,-4(fp)
 204ae30:	10c00315 	stw	r3,12(r2)
      p->nb_plen = len;
 204ae34:	e0bfff17 	ldw	r2,-4(fp)
 204ae38:	e0fff717 	ldw	r3,-36(fp)
 204ae3c:	10c00415 	stw	r3,16(r2)

      i = ip_write(ICMP_PROT, p);
 204ae40:	01000044 	movi	r4,1
 204ae44:	e17fff17 	ldw	r5,-4(fp)
 204ae48:	203fd780 	call	203fd78 <ip_write>
 204ae4c:	e0bffb15 	stw	r2,-20(fp)
      if (i < 0)
 204ae50:	e0bffb17 	ldw	r2,-20(fp)
 204ae54:	1000080e 	bge	r2,zero,204ae78 <icmprcv+0x54c>
      {
#ifdef   NPDEBUG
         if (NDEBUG & (UPCTRACE))
 204ae58:	00808174 	movhi	r2,517
 204ae5c:	1090b204 	addi	r2,r2,17096
 204ae60:	10800017 	ldw	r2,0(r2)
 204ae64:	1081000c 	andi	r2,r2,1024
 204ae68:	10000326 	beq	r2,zero,204ae78 <icmprcv+0x54c>
            dprintf("icmp: reply failed\n");
 204ae6c:	01008174 	movhi	r4,517
 204ae70:	2107c004 	addi	r4,r4,7936
 204ae74:	2006cb40 	call	2006cb4 <puts>
#endif
      }
      /* reused p will be freed by net->xxx_send() */
      return 0;
 204ae78:	0005883a 	mov	r2,zero
 204ae7c:	00019e06 	br	204b4f8 <icmprcv+0xbcc>
   case ECHOREP:
      icmp_mib.icmpInEchoReps++;
 204ae80:	00809934 	movhi	r2,612
 204ae84:	10b7f104 	addi	r2,r2,-8252
 204ae88:	10800817 	ldw	r2,32(r2)
 204ae8c:	10c00044 	addi	r3,r2,1
 204ae90:	00809934 	movhi	r2,612
 204ae94:	10b7f104 	addi	r2,r2,-8252
 204ae98:	10c00815 	stw	r3,32(r2)
      
/* 
 * Altera Niche Stack Nios port modification
 */
#if defined(ALT_INICHE) && !defined(PING_APP) && defined(IP_RAW)
      return(ip_raw_input(p));
 204ae9c:	e13fff17 	ldw	r4,-4(fp)
 204aea0:	20443bc0 	call	20443bc <ip_raw_input>
 204aea4:	00019406 	br	204b4f8 <icmprcv+0xbcc>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
      return(0);
#endif   /* PING_APP */
#ifdef FULL_ICMP
   case DESTIN:
      icmp_mib.icmpInDestUnreachs++;
 204aea8:	00809934 	movhi	r2,612
 204aeac:	10b7f104 	addi	r2,r2,-8252
 204aeb0:	10800217 	ldw	r2,8(r2)
 204aeb4:	10c00044 	addi	r3,r2,1
 204aeb8:	00809934 	movhi	r2,612
 204aebc:	10b7f104 	addi	r2,r2,-8252
 204aec0:	10c00215 	stw	r3,8(r2)
      pdp = (struct destun *)e;
 204aec4:	e0bff917 	ldw	r2,-28(fp)
 204aec8:	e0bffc15 	stw	r2,-16(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204aecc:	00808174 	movhi	r2,517
 204aed0:	1090b204 	addi	r2,r2,17096
 204aed4:	10800017 	ldw	r2,0(r2)
 204aed8:	1081000c 	andi	r2,r2,1024
 204aedc:	10002d26 	beq	r2,zero,204af94 <icmprcv+0x668>
      {
         dprintf("ICMP: got dest unreachable type ");
 204aee0:	01008174 	movhi	r4,517
 204aee4:	2107c504 	addi	r4,r4,7956
 204aee8:	2006a240 	call	2006a24 <printf>
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 204aeec:	e0bffc17 	ldw	r2,-16(fp)
 204aef0:	10800043 	ldbu	r2,1(r2)
 204aef4:	11403fcc 	andi	r5,r2,255
 204aef8:	2940201c 	xori	r5,r5,128
 204aefc:	297fe004 	addi	r5,r5,-128
          PUSH_IPADDR(pdp->dip.ip_dest));
 204af00:	e0bffc17 	ldw	r2,-16(fp)
 204af04:	10800617 	ldw	r2,24(r2)
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 204af08:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 204af0c:	e0bffc17 	ldw	r2,-16(fp)
 204af10:	10800617 	ldw	r2,24(r2)
 204af14:	1004d23a 	srli	r2,r2,8
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 204af18:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 204af1c:	e13ffc17 	ldw	r4,-16(fp)
 204af20:	21000617 	ldw	r4,24(r4)
 204af24:	2008d43a 	srli	r4,r4,16
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 204af28:	21803fcc 	andi	r6,r4,255
          PUSH_IPADDR(pdp->dip.ip_dest));
 204af2c:	e13ffc17 	ldw	r4,-16(fp)
 204af30:	21000617 	ldw	r4,24(r4)
 204af34:	2008d63a 	srli	r4,r4,24
      pdp = (struct destun *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: got dest unreachable type ");
         dprintf("%u on %u.%u.%u.%u ", pdp->dcode,
 204af38:	d9800015 	stw	r6,0(sp)
 204af3c:	d9000115 	stw	r4,4(sp)
 204af40:	01008174 	movhi	r4,517
 204af44:	2107ce04 	addi	r4,r4,7992
 204af48:	180d883a 	mov	r6,r3
 204af4c:	100f883a 	mov	r7,r2
 204af50:	2006a240 	call	2006a24 <printf>
          PUSH_IPADDR(pdp->dip.ip_dest));
         dprintf("from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 204af54:	e0bff817 	ldw	r2,-32(fp)
 204af58:	11403fcc 	andi	r5,r2,255
 204af5c:	e0bff817 	ldw	r2,-32(fp)
 204af60:	1004d23a 	srli	r2,r2,8
 204af64:	10c03fcc 	andi	r3,r2,255
 204af68:	e0bff817 	ldw	r2,-32(fp)
 204af6c:	1004d43a 	srli	r2,r2,16
 204af70:	10803fcc 	andi	r2,r2,255
 204af74:	e13ff817 	ldw	r4,-32(fp)
 204af78:	2008d63a 	srli	r4,r4,24
 204af7c:	d9000015 	stw	r4,0(sp)
 204af80:	01008174 	movhi	r4,517
 204af84:	2107d304 	addi	r4,r4,8012
 204af88:	180d883a 	mov	r6,r3
 204af8c:	100f883a 	mov	r7,r2
 204af90:	2006a240 	call	2006a24 <printf>
      }
#endif   /* NPDEBUG */
      icmp_du(p, pdp);
 204af94:	e13fff17 	ldw	r4,-4(fp)
 204af98:	e17ffc17 	ldw	r5,-16(fp)
 204af9c:	204bb640 	call	204bb64 <icmp_du>
      break;
 204afa0:	00015406 	br	204b4f4 <icmprcv+0xbc8>
   case SOURCEQ:
      icmp_mib.icmpInSrcQuenchs++;
 204afa4:	00809934 	movhi	r2,612
 204afa8:	10b7f104 	addi	r2,r2,-8252
 204afac:	10800517 	ldw	r2,20(r2)
 204afb0:	10c00044 	addi	r3,r2,1
 204afb4:	00809934 	movhi	r2,612
 204afb8:	10b7f104 	addi	r2,r2,-8252
 204afbc:	10c00515 	stw	r3,20(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204afc0:	00808174 	movhi	r2,517
 204afc4:	1090b204 	addi	r2,r2,17096
 204afc8:	10800017 	ldw	r2,0(r2)
 204afcc:	1081000c 	andi	r2,r2,1024
 204afd0:	10001726 	beq	r2,zero,204b030 <icmprcv+0x704>
      {
         dprintf("ICMP: source quench from %u.%u.%u.%u\n", PUSH_IPADDR(host));
 204afd4:	e0bff817 	ldw	r2,-32(fp)
 204afd8:	11403fcc 	andi	r5,r2,255
 204afdc:	e0bff817 	ldw	r2,-32(fp)
 204afe0:	1004d23a 	srli	r2,r2,8
 204afe4:	10c03fcc 	andi	r3,r2,255
 204afe8:	e0bff817 	ldw	r2,-32(fp)
 204afec:	1004d43a 	srli	r2,r2,16
 204aff0:	10803fcc 	andi	r2,r2,255
 204aff4:	e13ff817 	ldw	r4,-32(fp)
 204aff8:	2008d63a 	srli	r4,r4,24
 204affc:	d9000015 	stw	r4,0(sp)
 204b000:	01008174 	movhi	r4,517
 204b004:	2107d804 	addi	r4,r4,8032
 204b008:	180d883a 	mov	r6,r3
 204b00c:	100f883a 	mov	r7,r2
 204b010:	2006a240 	call	2006a24 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 204b014:	00808174 	movhi	r2,517
 204b018:	1090b204 	addi	r2,r2,17096
 204b01c:	10800017 	ldw	r2,0(r2)
 204b020:	1080008c 	andi	r2,r2,2
 204b024:	10000226 	beq	r2,zero,204b030 <icmprcv+0x704>
 204b028:	e13fff17 	ldw	r4,-4(fp)
 204b02c:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204b030:	01000084 	movi	r4,2
 204b034:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204b038:	e13fff17 	ldw	r4,-4(fp)
 204b03c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b040:	01000084 	movi	r4,2
 204b044:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      break;
 204b048:	00012a06 	br	204b4f4 <icmprcv+0xbc8>
   case REDIR:          /* got an icmp redirect */
      icmp_mib.icmpInRedirects++;
 204b04c:	00809934 	movhi	r2,612
 204b050:	10b7f104 	addi	r2,r2,-8252
 204b054:	10800617 	ldw	r2,24(r2)
 204b058:	10c00044 	addi	r3,r2,1
 204b05c:	00809934 	movhi	r2,612
 204b060:	10b7f104 	addi	r2,r2,-8252
 204b064:	10c00615 	stw	r3,24(r2)
      rd = (struct redirect *)e;
 204b068:	e0bff917 	ldw	r2,-28(fp)
 204b06c:	e0bffd15 	stw	r2,-12(fp)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204b070:	00808174 	movhi	r2,517
 204b074:	1090b204 	addi	r2,r2,17096
 204b078:	10800017 	ldw	r2,0(r2)
 204b07c:	1081000c 	andi	r2,r2,1024
 204b080:	10002826 	beq	r2,zero,204b124 <icmprcv+0x7f8>
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
          PUSH_IPADDR(rd->rdip.ip_dest));
 204b084:	e0bffd17 	ldw	r2,-12(fp)
 204b088:	10800617 	ldw	r2,24(r2)
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 204b08c:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 204b090:	e0bffd17 	ldw	r2,-12(fp)
 204b094:	10800617 	ldw	r2,24(r2)
 204b098:	1004d23a 	srli	r2,r2,8
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 204b09c:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 204b0a0:	e0bffd17 	ldw	r2,-12(fp)
 204b0a4:	10800617 	ldw	r2,24(r2)
 204b0a8:	1004d43a 	srli	r2,r2,16
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 204b0ac:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(rd->rdip.ip_dest));
 204b0b0:	e13ffd17 	ldw	r4,-12(fp)
 204b0b4:	21000617 	ldw	r4,24(r4)
 204b0b8:	2008d63a 	srli	r4,r4,24
      icmp_mib.icmpInRedirects++;
      rd = (struct redirect *)e;
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         dprintf("ICMP: rcvd redirect for %u.%u.%u.%u ",
 204b0bc:	d9000015 	stw	r4,0(sp)
 204b0c0:	01008174 	movhi	r4,517
 204b0c4:	2107e204 	addi	r4,r4,8072
 204b0c8:	180d883a 	mov	r6,r3
 204b0cc:	100f883a 	mov	r7,r2
 204b0d0:	2006a240 	call	2006a24 <printf>
          PUSH_IPADDR(rd->rdip.ip_dest));
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
 204b0d4:	e0bffd17 	ldw	r2,-12(fp)
 204b0d8:	10800117 	ldw	r2,4(r2)
 204b0dc:	11403fcc 	andi	r5,r2,255
 204b0e0:	e0bffd17 	ldw	r2,-12(fp)
 204b0e4:	10800117 	ldw	r2,4(r2)
 204b0e8:	1004d23a 	srli	r2,r2,8
 204b0ec:	10c03fcc 	andi	r3,r2,255
 204b0f0:	e0bffd17 	ldw	r2,-12(fp)
 204b0f4:	10800117 	ldw	r2,4(r2)
 204b0f8:	1004d43a 	srli	r2,r2,16
 204b0fc:	10803fcc 	andi	r2,r2,255
 204b100:	e13ffd17 	ldw	r4,-12(fp)
 204b104:	21000117 	ldw	r4,4(r4)
 204b108:	2008d63a 	srli	r4,r4,24
 204b10c:	d9000015 	stw	r4,0(sp)
 204b110:	01008174 	movhi	r4,517
 204b114:	2107ec04 	addi	r4,r4,8112
 204b118:	180d883a 	mov	r6,r3
 204b11c:	100f883a 	mov	r7,r2
 204b120:	2006a240 	call	2006a24 <printf>
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 204b124:	e0bffd17 	ldw	r2,-12(fp)
 204b128:	14400617 	ldw	r17,24(r2)
 204b12c:	e0bffd17 	ldw	r2,-12(fp)
 204b130:	14000117 	ldw	r16,4(r2)
       net_num(p->net), IPRP_ICMP);
 204b134:	e0bfff17 	ldw	r2,-4(fp)
         dprintf("to %u.%u.%u.%u\n", PUSH_IPADDR(rd->rdgw));
      }
#endif   /* NPDEBUG */
#ifdef IP_ROUTING
      /* try to add/update route table */
      add_route(rd->rdip.ip_dest, 0xFFFFFFFF, rd->rdgw, 
 204b138:	10800617 	ldw	r2,24(r2)
 204b13c:	1009883a 	mov	r4,r2
 204b140:	2024bac0 	call	2024bac <if_netnumber>
 204b144:	00c00104 	movi	r3,4
 204b148:	d8c00015 	stw	r3,0(sp)
 204b14c:	8809883a 	mov	r4,r17
 204b150:	017fffc4 	movi	r5,-1
 204b154:	800d883a 	mov	r6,r16
 204b158:	100f883a 	mov	r7,r2
 204b15c:	20448ac0 	call	20448ac <add_route>
       net_num(p->net), IPRP_ICMP);
#endif   /* IP_ROUTING */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204b160:	01000084 	movi	r4,2
 204b164:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204b168:	e13fff17 	ldw	r4,-4(fp)
 204b16c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b170:	01000084 	movi	r4,2
 204b174:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      break;
 204b178:	0000de06 	br	204b4f4 <icmprcv+0xbc8>
   case TIMEX:
      icmp_mib.icmpInTimeExcds++;
 204b17c:	00809934 	movhi	r2,612
 204b180:	10b7f104 	addi	r2,r2,-8252
 204b184:	10800317 	ldw	r2,12(r2)
 204b188:	10c00044 	addi	r3,r2,1
 204b18c:	00809934 	movhi	r2,612
 204b190:	10b7f104 	addi	r2,r2,-8252
 204b194:	10c00315 	stw	r3,12(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204b198:	00808174 	movhi	r2,517
 204b19c:	1090b204 	addi	r2,r2,17096
 204b1a0:	10800017 	ldw	r2,0(r2)
 204b1a4:	1081000c 	andi	r2,r2,1024
 204b1a8:	10003126 	beq	r2,zero,204b270 <icmprcv+0x944>
      {
         struct timex * pt =  (struct  timex *)e;
 204b1ac:	e0bff917 	ldw	r2,-28(fp)
 204b1b0:	e0bffe15 	stw	r2,-8(fp)

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
          PUSH_IPADDR(p->fhost));
 204b1b4:	e0bfff17 	ldw	r2,-4(fp)
 204b1b8:	10800717 	ldw	r2,28(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 204b1bc:	11403fcc 	andi	r5,r2,255
          PUSH_IPADDR(p->fhost));
 204b1c0:	e0bfff17 	ldw	r2,-4(fp)
 204b1c4:	10800717 	ldw	r2,28(r2)
 204b1c8:	1004d23a 	srli	r2,r2,8
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 204b1cc:	10c03fcc 	andi	r3,r2,255
          PUSH_IPADDR(p->fhost));
 204b1d0:	e0bfff17 	ldw	r2,-4(fp)
 204b1d4:	10800717 	ldw	r2,28(r2)
 204b1d8:	1004d43a 	srli	r2,r2,16
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 204b1dc:	10803fcc 	andi	r2,r2,255
          PUSH_IPADDR(p->fhost));
 204b1e0:	e13fff17 	ldw	r4,-4(fp)
 204b1e4:	21000717 	ldw	r4,28(r4)
 204b1e8:	2008d63a 	srli	r4,r4,24
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
      {
         struct timex * pt =  (struct  timex *)e;

         dprintf("ICMP: timex msg from %u.%u.%u.%u\n",
 204b1ec:	d9000015 	stw	r4,0(sp)
 204b1f0:	01008174 	movhi	r4,517
 204b1f4:	2107f004 	addi	r4,r4,8128
 204b1f8:	180d883a 	mov	r6,r3
 204b1fc:	100f883a 	mov	r7,r2
 204b200:	2006a240 	call	2006a24 <printf>
          PUSH_IPADDR(p->fhost));
         dprintf(" about %u.%u.%u.%u\n", PUSH_IPADDR(pt->tip.ip_dest));
 204b204:	e0bffe17 	ldw	r2,-8(fp)
 204b208:	10800617 	ldw	r2,24(r2)
 204b20c:	11403fcc 	andi	r5,r2,255
 204b210:	e0bffe17 	ldw	r2,-8(fp)
 204b214:	10800617 	ldw	r2,24(r2)
 204b218:	1004d23a 	srli	r2,r2,8
 204b21c:	10c03fcc 	andi	r3,r2,255
 204b220:	e0bffe17 	ldw	r2,-8(fp)
 204b224:	10800617 	ldw	r2,24(r2)
 204b228:	1004d43a 	srli	r2,r2,16
 204b22c:	10803fcc 	andi	r2,r2,255
 204b230:	e13ffe17 	ldw	r4,-8(fp)
 204b234:	21000617 	ldw	r4,24(r4)
 204b238:	2008d63a 	srli	r4,r4,24
 204b23c:	d9000015 	stw	r4,0(sp)
 204b240:	01008174 	movhi	r4,517
 204b244:	2107f904 	addi	r4,r4,8164
 204b248:	180d883a 	mov	r6,r3
 204b24c:	100f883a 	mov	r7,r2
 204b250:	2006a240 	call	2006a24 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 204b254:	00808174 	movhi	r2,517
 204b258:	1090b204 	addi	r2,r2,17096
 204b25c:	10800017 	ldw	r2,0(r2)
 204b260:	1080008c 	andi	r2,r2,2
 204b264:	10000226 	beq	r2,zero,204b270 <icmprcv+0x944>
 204b268:	e13fff17 	ldw	r4,-4(fp)
 204b26c:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204b270:	01000084 	movi	r4,2
 204b274:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204b278:	e13fff17 	ldw	r4,-4(fp)
 204b27c:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b280:	01000084 	movi	r4,2
 204b284:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      break;
 204b288:	00009a06 	br	204b4f4 <icmprcv+0xbc8>
   case PARAM:
      icmp_mib.icmpInParmProbs++;
 204b28c:	00809934 	movhi	r2,612
 204b290:	10b7f104 	addi	r2,r2,-8252
 204b294:	10800417 	ldw	r2,16(r2)
 204b298:	10c00044 	addi	r3,r2,1
 204b29c:	00809934 	movhi	r2,612
 204b2a0:	10b7f104 	addi	r2,r2,-8252
 204b2a4:	10c00415 	stw	r3,16(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204b2a8:	00808174 	movhi	r2,517
 204b2ac:	1090b204 	addi	r2,r2,17096
 204b2b0:	10800017 	ldw	r2,0(r2)
 204b2b4:	1081000c 	andi	r2,r2,1024
 204b2b8:	10000326 	beq	r2,zero,204b2c8 <icmprcv+0x99c>
         dprintf("ICMP: got param problem message\n");
 204b2bc:	01008174 	movhi	r4,517
 204b2c0:	2107fe04 	addi	r4,r4,8184
 204b2c4:	2006cb40 	call	2006cb4 <puts>
      if (NDEBUG & DUMP)
 204b2c8:	00808174 	movhi	r2,517
 204b2cc:	1090b204 	addi	r2,r2,17096
 204b2d0:	10800017 	ldw	r2,0(r2)
 204b2d4:	1080008c 	andi	r2,r2,2
 204b2d8:	10000226 	beq	r2,zero,204b2e4 <icmprcv+0x9b8>
      {
         ip_dump(p);
 204b2dc:	e13fff17 	ldw	r4,-4(fp)
 204b2e0:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204b2e4:	01000084 	movi	r4,2
 204b2e8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204b2ec:	e13fff17 	ldw	r4,-4(fp)
 204b2f0:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b2f4:	01000084 	movi	r4,2
 204b2f8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      break;
 204b2fc:	00007d06 	br	204b4f4 <icmprcv+0xbc8>
   case TIMEREQ:
      icmp_mib.icmpInTimestamps++;
 204b300:	00809934 	movhi	r2,612
 204b304:	10b7f104 	addi	r2,r2,-8252
 204b308:	10800917 	ldw	r2,36(r2)
 204b30c:	10c00044 	addi	r3,r2,1
 204b310:	00809934 	movhi	r2,612
 204b314:	10b7f104 	addi	r2,r2,-8252
 204b318:	10c00915 	stw	r3,36(r2)
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204b31c:	00808174 	movhi	r2,517
 204b320:	1090b204 	addi	r2,r2,17096
 204b324:	10800017 	ldw	r2,0(r2)
 204b328:	1081000c 	andi	r2,r2,1024
 204b32c:	10000326 	beq	r2,zero,204b33c <icmprcv+0xa10>
         dprintf("ICMP: got timestamp request\n");
 204b330:	01008174 	movhi	r4,517
 204b334:	21080604 	addi	r4,r4,8216
 204b338:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG */
      e->ptype = TIMEREP;
 204b33c:	e0bff917 	ldw	r2,-28(fp)
 204b340:	00c00384 	movi	r3,14
 204b344:	10c00005 	stb	r3,0(r2)
      e->pchksum = 0;
 204b348:	e0bff917 	ldw	r2,-28(fp)
 204b34c:	1000008d 	sth	zero,2(r2)
		   */
		  sstmp->dtstamp[1] = sstmp->dtstamp[2] = user_UTCtime();
	  }
#endif /* USER_PING_TSTAMP */

      e->pchksum = ~cksum(e, sizeof(struct tstamp)>>1);
 204b350:	e13ff917 	ldw	r4,-28(fp)
 204b354:	01400284 	movi	r5,10
 204b358:	20268040 	call	2026804 <cksum>
 204b35c:	0084303a 	nor	r2,zero,r2
 204b360:	1007883a 	mov	r3,r2
 204b364:	e0bff917 	ldw	r2,-28(fp)
 204b368:	10c0008d 	sth	r3,2(r2)
      pip->ip_src = pip->ip_dest;
 204b36c:	e0bff617 	ldw	r2,-40(fp)
 204b370:	10c00417 	ldw	r3,16(r2)
 204b374:	e0bff617 	ldw	r2,-40(fp)
 204b378:	10c00315 	stw	r3,12(r2)
      pip->ip_dest = host;
 204b37c:	e0bff617 	ldw	r2,-40(fp)
 204b380:	e0fff817 	ldw	r3,-32(fp)
 204b384:	10c00415 	stw	r3,16(r2)
      icmp_mib.icmpOutMsgs++;
 204b388:	00809934 	movhi	r2,612
 204b38c:	10b7f104 	addi	r2,r2,-8252
 204b390:	10800d17 	ldw	r2,52(r2)
 204b394:	10c00044 	addi	r3,r2,1
 204b398:	00809934 	movhi	r2,612
 204b39c:	10b7f104 	addi	r2,r2,-8252
 204b3a0:	10c00d15 	stw	r3,52(r2)
      icmp_mib.icmpOutTimestampReps++;
 204b3a4:	00809934 	movhi	r2,612
 204b3a8:	10b7f104 	addi	r2,r2,-8252
 204b3ac:	10801717 	ldw	r2,92(r2)
 204b3b0:	10c00044 	addi	r3,r2,1
 204b3b4:	00809934 	movhi	r2,612
 204b3b8:	10b7f104 	addi	r2,r2,-8252
 204b3bc:	10c01715 	stw	r3,92(r2)
      p->nb_prot += ip_hlen(pip);      /* move pointer past IP to ICMP */
 204b3c0:	e0bfff17 	ldw	r2,-4(fp)
 204b3c4:	10c00317 	ldw	r3,12(r2)
 204b3c8:	e0bff617 	ldw	r2,-40(fp)
 204b3cc:	10800003 	ldbu	r2,0(r2)
 204b3d0:	10803fcc 	andi	r2,r2,255
 204b3d4:	108003cc 	andi	r2,r2,15
 204b3d8:	1085883a 	add	r2,r2,r2
 204b3dc:	1085883a 	add	r2,r2,r2
 204b3e0:	1887883a 	add	r3,r3,r2
 204b3e4:	e0bfff17 	ldw	r2,-4(fp)
 204b3e8:	10c00315 	stw	r3,12(r2)
      p->nb_plen = sizeof(struct tstamp);
 204b3ec:	e0bfff17 	ldw	r2,-4(fp)
 204b3f0:	00c00504 	movi	r3,20
 204b3f4:	10c00415 	stw	r3,16(r2)
      p->fhost = host;
 204b3f8:	e0bfff17 	ldw	r2,-4(fp)
 204b3fc:	e0fff817 	ldw	r3,-32(fp)
 204b400:	10c00715 	stw	r3,28(r2)
      i = ip_write(ICMP_PROT, p);
 204b404:	01000044 	movi	r4,1
 204b408:	e17fff17 	ldw	r5,-4(fp)
 204b40c:	203fd780 	call	203fd78 <ip_write>
 204b410:	e0bffb15 	stw	r2,-20(fp)
      if (i < 0)
 204b414:	e0bffb17 	ldw	r2,-20(fp)
 204b418:	1000080e 	bge	r2,zero,204b43c <icmprcv+0xb10>
      {
#ifdef   NPDEBUG
         if (NDEBUG & UPCTRACE)
 204b41c:	00808174 	movhi	r2,517
 204b420:	1090b204 	addi	r2,r2,17096
 204b424:	10800017 	ldw	r2,0(r2)
 204b428:	1081000c 	andi	r2,r2,1024
 204b42c:	10000326 	beq	r2,zero,204b43c <icmprcv+0xb10>
            dprintf("icmp: can't send timestamp reply\n");
 204b430:	01008174 	movhi	r4,517
 204b434:	21080d04 	addi	r4,r4,8244
 204b438:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG */
      }
      /* re-used packet was pk_free()d by net->send() */
      return (0);
 204b43c:	0005883a 	mov	r2,zero
 204b440:	00002d06 	br	204b4f8 <icmprcv+0xbcc>
   case INFO:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204b444:	00808174 	movhi	r2,517
 204b448:	1090b204 	addi	r2,r2,17096
 204b44c:	10800017 	ldw	r2,0(r2)
 204b450:	1081000c 	andi	r2,r2,1024
 204b454:	10000326 	beq	r2,zero,204b464 <icmprcv+0xb38>
         dprintf("icmp: got info request\n");
 204b458:	01008174 	movhi	r4,517
 204b45c:	21081604 	addi	r4,r4,8280
 204b460:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204b464:	01000084 	movi	r4,2
 204b468:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204b46c:	e13fff17 	ldw	r4,-4(fp)
 204b470:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b474:	01000084 	movi	r4,2
 204b478:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      break;
 204b47c:	00001d06 	br	204b4f4 <icmprcv+0xbc8>
#endif   /* FULL_ICMP */
   default:
#ifdef   NPDEBUG
      if (NDEBUG & UPCTRACE)
 204b480:	00808174 	movhi	r2,517
 204b484:	1090b204 	addi	r2,r2,17096
 204b488:	10800017 	ldw	r2,0(r2)
 204b48c:	1081000c 	andi	r2,r2,1024
 204b490:	10001026 	beq	r2,zero,204b4d4 <icmprcv+0xba8>
      {
         dprintf("icmp: unhandled type %u\n", e->ptype);
 204b494:	e0bff917 	ldw	r2,-28(fp)
 204b498:	10800003 	ldbu	r2,0(r2)
 204b49c:	10803fcc 	andi	r2,r2,255
 204b4a0:	1080201c 	xori	r2,r2,128
 204b4a4:	10bfe004 	addi	r2,r2,-128
 204b4a8:	01008174 	movhi	r4,517
 204b4ac:	21081c04 	addi	r4,r4,8304
 204b4b0:	100b883a 	mov	r5,r2
 204b4b4:	2006a240 	call	2006a24 <printf>
         if (NDEBUG & DUMP) ip_dump(p);
 204b4b8:	00808174 	movhi	r2,517
 204b4bc:	1090b204 	addi	r2,r2,17096
 204b4c0:	10800017 	ldw	r2,0(r2)
 204b4c4:	1080008c 	andi	r2,r2,2
 204b4c8:	10000226 	beq	r2,zero,204b4d4 <icmprcv+0xba8>
 204b4cc:	e13fff17 	ldw	r4,-4(fp)
 204b4d0:	2040e3c0 	call	2040e3c <ip_dump>
      }
#endif   /* NPDEBUG */
      LOCK_NET_RESOURCE(FREEQ_RESID);
 204b4d4:	01000084 	movi	r4,2
 204b4d8:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
      pk_free(p);
 204b4dc:	e13fff17 	ldw	r4,-4(fp)
 204b4e0:	20280440 	call	2028044 <pk_free>
      UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b4e4:	01000084 	movi	r4,2
 204b4e8:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>
      return ENP_NOT_MINE;
 204b4ec:	00800084 	movi	r2,2
 204b4f0:	00000106 	br	204b4f8 <icmprcv+0xbcc>
   }
#ifdef FULL_ICMP
   return ENP_NOT_MINE;
 204b4f4:	00800084 	movi	r2,2
#endif   /* FULL_ICMP */
}
 204b4f8:	e037883a 	mov	sp,fp
 204b4fc:	dfc00317 	ldw	ra,12(sp)
 204b500:	df000217 	ldw	fp,8(sp)
 204b504:	dc400117 	ldw	r17,4(sp)
 204b508:	dc000017 	ldw	r16,0(sp)
 204b50c:	dec00404 	addi	sp,sp,16
 204b510:	f800283a 	ret

0204b514 <icmp_destun>:
icmp_destun(ip_addr host,  /* host to complain to */
   ip_addr src_addr, /* source address for outgoing ICMP/IP packet header */
   struct ip * ip,   /* IP header of offending packet */
   unsigned typecode,    /* type & code of DU to send (PROT, PORT, HOST) */
   NET   net)        /* interface that this packet came in on */
{
 204b514:	defff404 	addi	sp,sp,-48
 204b518:	dfc00b15 	stw	ra,44(sp)
 204b51c:	df000a15 	stw	fp,40(sp)
 204b520:	df000a04 	addi	fp,sp,40
 204b524:	e13ffc15 	stw	r4,-16(fp)
 204b528:	e17ffd15 	stw	r5,-12(fp)
 204b52c:	e1bffe15 	stw	r6,-8(fp)
 204b530:	e1ffff15 	stw	r7,-4(fp)
   struct destun *   d;
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 204b534:	00808174 	movhi	r2,517
 204b538:	1090b204 	addi	r2,r2,17096
 204b53c:	10800017 	ldw	r2,0(r2)
 204b540:	1080040c 	andi	r2,r2,16
 204b544:	10001926 	beq	r2,zero,204b5ac <icmp_destun+0x98>
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 204b548:	e0bfff17 	ldw	r2,-4(fp)
 204b54c:	10803fcc 	andi	r2,r2,255
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 204b550:	00c08174 	movhi	r3,517
 204b554:	18d02404 	addi	r3,r3,16528
 204b558:	1085883a 	add	r2,r2,r2
 204b55c:	1085883a 	add	r2,r2,r2
 204b560:	1885883a 	add	r2,r3,r2
 204b564:	11400017 	ldw	r5,0(r2)
 204b568:	e0bffc17 	ldw	r2,-16(fp)
 204b56c:	10c03fcc 	andi	r3,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 204b570:	e0bffc17 	ldw	r2,-16(fp)
 204b574:	1004d23a 	srli	r2,r2,8
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 204b578:	10803fcc 	andi	r2,r2,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 204b57c:	e13ffc17 	ldw	r4,-16(fp)
 204b580:	2008d43a 	srli	r4,r4,16
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 204b584:	21803fcc 	andi	r6,r4,255
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
 204b588:	e13ffc17 	ldw	r4,-16(fp)
 204b58c:	2008d63a 	srli	r4,r4,24
   struct ip * pip;
   int   i;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending %s dest unreachable to %u.%u.%u.%u\n",
 204b590:	d9800015 	stw	r6,0(sp)
 204b594:	d9000115 	stw	r4,4(sp)
 204b598:	01008174 	movhi	r4,517
 204b59c:	21083604 	addi	r4,r4,8408
 204b5a0:	180d883a 	mov	r6,r3
 204b5a4:	100f883a 	mov	r7,r2
 204b5a8:	2006a240 	call	2006a24 <printf>
      dsts[typecode & 0xFF], PUSH_IPADDR(host));
#endif   /* NPDEBUG */

   LOCK_NET_RESOURCE(FREEQ_RESID);
 204b5ac:	01000084 	movi	r4,2
 204b5b0:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
   p = pk_alloc(512 + IPHSIZ);   /* get packet to send icmp dest unreachable */
 204b5b4:	01008504 	movi	r4,532
 204b5b8:	2027cec0 	call	2027cec <pk_alloc>
 204b5bc:	e0bff815 	stw	r2,-32(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b5c0:	01000084 	movi	r4,2
 204b5c4:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 204b5c8:	e0bff817 	ldw	r2,-32(fp)
 204b5cc:	1000101e 	bne	r2,zero,204b610 <icmp_destun+0xfc>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 204b5d0:	00808174 	movhi	r2,517
 204b5d4:	1090b204 	addi	r2,r2,17096
 204b5d8:	10800017 	ldw	r2,0(r2)
 204b5dc:	1080800c 	andi	r2,r2,512
 204b5e0:	10000326 	beq	r2,zero,204b5f0 <icmp_destun+0xdc>
         dprintf("icmp: can't alloc pkt\n");
 204b5e4:	01008174 	movhi	r4,517
 204b5e8:	21084304 	addi	r4,r4,8460
 204b5ec:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 204b5f0:	00809934 	movhi	r2,612
 204b5f4:	10b7f104 	addi	r2,r2,-8252
 204b5f8:	10800e17 	ldw	r2,56(r2)
 204b5fc:	10c00044 	addi	r3,r2,1
 204b600:	00809934 	movhi	r2,612
 204b604:	10b7f104 	addi	r2,r2,-8252
 204b608:	10c00e15 	stw	r3,56(r2)
      return;
 204b60c:	00008106 	br	204b814 <icmp_destun+0x300>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 204b610:	e0bff817 	ldw	r2,-32(fp)
 204b614:	10800317 	ldw	r2,12(r2)
 204b618:	e0bff915 	stw	r2,-28(fp)
   pip->ip_src = src_addr;
 204b61c:	e0bff917 	ldw	r2,-28(fp)
 204b620:	e0fffd17 	ldw	r3,-12(fp)
 204b624:	10c00315 	stw	r3,12(r2)
   pip->ip_dest = host;
 204b628:	e0bff917 	ldw	r2,-28(fp)
 204b62c:	e0fffc17 	ldw	r3,-16(fp)
 204b630:	10c00415 	stw	r3,16(r2)

   /* allow space for icmp header */
   p->nb_prot += sizeof(struct ip);
 204b634:	e0bff817 	ldw	r2,-32(fp)
 204b638:	10800317 	ldw	r2,12(r2)
 204b63c:	10c00504 	addi	r3,r2,20
 204b640:	e0bff817 	ldw	r2,-32(fp)
 204b644:	10c00315 	stw	r3,12(r2)
   p->nb_plen -= sizeof(struct ip);
 204b648:	e0bff817 	ldw	r2,-32(fp)
 204b64c:	10800417 	ldw	r2,16(r2)
 204b650:	10fffb04 	addi	r3,r2,-20
 204b654:	e0bff817 	ldw	r2,-32(fp)
 204b658:	10c00415 	stw	r3,16(r2)
   p->net = net;     /* Put in the interface that this packet came in on */
 204b65c:	e0bff817 	ldw	r2,-32(fp)
 204b660:	e0c00217 	ldw	r3,8(fp)
 204b664:	10c00615 	stw	r3,24(r2)

   d = (struct destun *)p->nb_prot;
 204b668:	e0bff817 	ldw	r2,-32(fp)
 204b66c:	10800317 	ldw	r2,12(r2)
 204b670:	e0bffa15 	stw	r2,-24(fp)

   if (typecode & 0xFF00)               /* if the type was sent */
 204b674:	e0bfff17 	ldw	r2,-4(fp)
 204b678:	10bfc00c 	andi	r2,r2,65280
 204b67c:	10000626 	beq	r2,zero,204b698 <icmp_destun+0x184>
      d->dtype = (char)(typecode >>8);  /* then use it */
 204b680:	e0bfff17 	ldw	r2,-4(fp)
 204b684:	1004d23a 	srli	r2,r2,8
 204b688:	1007883a 	mov	r3,r2
 204b68c:	e0bffa17 	ldw	r2,-24(fp)
 204b690:	10c00005 	stb	r3,0(r2)
 204b694:	00000306 	br	204b6a4 <icmp_destun+0x190>
   else                                 /* else use default */
      d->dtype = DESTIN;
 204b698:	e0bffa17 	ldw	r2,-24(fp)
 204b69c:	00c000c4 	movi	r3,3
 204b6a0:	10c00005 	stb	r3,0(r2)
   d->dcode = (char)(typecode & 0xFF);
 204b6a4:	e0bfff17 	ldw	r2,-4(fp)
 204b6a8:	1007883a 	mov	r3,r2
 204b6ac:	e0bffa17 	ldw	r2,-24(fp)
 204b6b0:	10c00045 	stb	r3,1(r2)
   d->dno1 = d->dno2 = 0;
 204b6b4:	e0bffa17 	ldw	r2,-24(fp)
 204b6b8:	1000018d 	sth	zero,6(r2)
 204b6bc:	e0bffa17 	ldw	r2,-24(fp)
 204b6c0:	10c0018b 	ldhu	r3,6(r2)
 204b6c4:	e0bffa17 	ldw	r2,-24(fp)
 204b6c8:	10c0010d 	sth	r3,4(r2)
#ifndef ICMP_SUPPRESS_PMTU
   if ((typecode & 0xFF) == DSTFRAG)
 204b6cc:	e0bfff17 	ldw	r2,-4(fp)
 204b6d0:	10803fcc 	andi	r2,r2,255
 204b6d4:	10800118 	cmpnei	r2,r2,4
 204b6d8:	1000121e 	bne	r2,zero,204b724 <icmp_destun+0x210>
      d->dno2 = htons(net->n_mtu - net->n_lnh);
 204b6dc:	e0800217 	ldw	r2,8(fp)
 204b6e0:	10c00917 	ldw	r3,36(r2)
 204b6e4:	e0800217 	ldw	r2,8(fp)
 204b6e8:	10800817 	ldw	r2,32(r2)
 204b6ec:	1885c83a 	sub	r2,r3,r2
 204b6f0:	1005d23a 	srai	r2,r2,8
 204b6f4:	10803fcc 	andi	r2,r2,255
 204b6f8:	1007883a 	mov	r3,r2
 204b6fc:	e0800217 	ldw	r2,8(fp)
 204b700:	11000917 	ldw	r4,36(r2)
 204b704:	e0800217 	ldw	r2,8(fp)
 204b708:	10800817 	ldw	r2,32(r2)
 204b70c:	2085c83a 	sub	r2,r4,r2
 204b710:	1004923a 	slli	r2,r2,8
 204b714:	1884b03a 	or	r2,r3,r2
 204b718:	1007883a 	mov	r3,r2
 204b71c:	e0bffa17 	ldw	r2,-24(fp)
 204b720:	10c0018d 	sth	r3,6(r2)
#endif    /* ICMP_SUPPRESS_PMTU */
   MEMCPY(&d->dip, ip, (sizeof(struct ip) + ICMPDUDATA));
 204b724:	e0bffa17 	ldw	r2,-24(fp)
 204b728:	10800204 	addi	r2,r2,8
 204b72c:	1009883a 	mov	r4,r2
 204b730:	e17ffe17 	ldw	r5,-8(fp)
 204b734:	01800704 	movi	r6,28
 204b738:	200660c0 	call	200660c <memcpy>

   d->dchksum = 0;
 204b73c:	e0bffa17 	ldw	r2,-24(fp)
 204b740:	1000008d 	sth	zero,2(r2)
   d->dchksum = ~cksum(d, sizeof(struct destun)>>1);
 204b744:	e13ffa17 	ldw	r4,-24(fp)
 204b748:	01400484 	movi	r5,18
 204b74c:	20268040 	call	2026804 <cksum>
 204b750:	0084303a 	nor	r2,zero,r2
 204b754:	1007883a 	mov	r3,r2
 204b758:	e0bffa17 	ldw	r2,-24(fp)
 204b75c:	10c0008d 	sth	r3,2(r2)

   p->nb_plen =  sizeof(struct destun);
 204b760:	e0bff817 	ldw	r2,-32(fp)
 204b764:	00c00904 	movi	r3,36
 204b768:	10c00415 	stw	r3,16(r2)
   p->fhost = host;
 204b76c:	e0bff817 	ldw	r2,-32(fp)
 204b770:	e0fffc17 	ldw	r3,-16(fp)
 204b774:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 204b778:	01000044 	movi	r4,1
 204b77c:	e17ff817 	ldw	r5,-32(fp)
 204b780:	203fd780 	call	203fd78 <ip_write>
 204b784:	e0bffb15 	stw	r2,-20(fp)
   if (i < 0)
 204b788:	e0bffb17 	ldw	r2,-20(fp)
 204b78c:	1000100e 	bge	r2,zero,204b7d0 <icmp_destun+0x2bc>
   {
      icmp_mib.icmpOutErrors++;
 204b790:	00809934 	movhi	r2,612
 204b794:	10b7f104 	addi	r2,r2,-8252
 204b798:	10800e17 	ldw	r2,56(r2)
 204b79c:	10c00044 	addi	r3,r2,1
 204b7a0:	00809934 	movhi	r2,612
 204b7a4:	10b7f104 	addi	r2,r2,-8252
 204b7a8:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 204b7ac:	00808174 	movhi	r2,517
 204b7b0:	1090b204 	addi	r2,r2,17096
 204b7b4:	10800017 	ldw	r2,0(r2)
 204b7b8:	1080860c 	andi	r2,r2,536
 204b7bc:	10001426 	beq	r2,zero,204b810 <icmp_destun+0x2fc>
         dprintf("ICMP: Can't send dest unreachable\n");
 204b7c0:	01008174 	movhi	r4,517
 204b7c4:	21084904 	addi	r4,r4,8484
 204b7c8:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG  */
      return;
 204b7cc:	00001006 	br	204b810 <icmp_destun+0x2fc>
   }
   icmp_mib.icmpOutMsgs++;
 204b7d0:	00809934 	movhi	r2,612
 204b7d4:	10b7f104 	addi	r2,r2,-8252
 204b7d8:	10800d17 	ldw	r2,52(r2)
 204b7dc:	10c00044 	addi	r3,r2,1
 204b7e0:	00809934 	movhi	r2,612
 204b7e4:	10b7f104 	addi	r2,r2,-8252
 204b7e8:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutDestUnreachs++;
 204b7ec:	00809934 	movhi	r2,612
 204b7f0:	10b7f104 	addi	r2,r2,-8252
 204b7f4:	10800f17 	ldw	r2,60(r2)
 204b7f8:	10c00044 	addi	r3,r2,1
 204b7fc:	00809934 	movhi	r2,612
 204b800:	10b7f104 	addi	r2,r2,-8252
 204b804:	10c00f15 	stw	r3,60(r2)
   return;
 204b808:	0001883a 	nop
 204b80c:	00000106 	br	204b814 <icmp_destun+0x300>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send dest unreachable\n");
#endif   /* NPDEBUG  */
      return;
 204b810:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutDestUnreachs++;
   return;
}
 204b814:	e037883a 	mov	sp,fp
 204b818:	dfc00117 	ldw	ra,4(sp)
 204b81c:	df000017 	ldw	fp,0(sp)
 204b820:	dec00204 	addi	sp,sp,8
 204b824:	f800283a 	ret

0204b828 <icmp_timex>:
 *
 * RETURNS: void
 */

void icmp_timex (struct ip * ip, char code) 
{
 204b828:	defff504 	addi	sp,sp,-44
 204b82c:	dfc00a15 	stw	ra,40(sp)
 204b830:	df000915 	stw	fp,36(sp)
 204b834:	df000904 	addi	fp,sp,36
 204b838:	e13ffe15 	stw	r4,-8(fp)
 204b83c:	2805883a 	mov	r2,r5
 204b840:	e0bfff05 	stb	r2,-4(fp)
   struct ip * pip;
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
 204b844:	00808174 	movhi	r2,517
 204b848:	1090b204 	addi	r2,r2,17096
 204b84c:	10800017 	ldw	r2,0(r2)
 204b850:	1080040c 	andi	r2,r2,16
 204b854:	10003226 	beq	r2,zero,204b920 <icmp_timex+0xf8>
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 204b858:	e17fff07 	ldb	r5,-4(fp)
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 204b85c:	e0bffe17 	ldw	r2,-8(fp)
 204b860:	10800317 	ldw	r2,12(r2)
 204b864:	1004d23a 	srli	r2,r2,8
 204b868:	10c03fcc 	andi	r3,r2,255
 204b86c:	e0bffe17 	ldw	r2,-8(fp)
 204b870:	10800317 	ldw	r2,12(r2)
 204b874:	1004923a 	slli	r2,r2,8
 204b878:	10bfffcc 	andi	r2,r2,65535
 204b87c:	1884b03a 	or	r2,r3,r2
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 204b880:	10c03fcc 	andi	r3,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 204b884:	e0bffe17 	ldw	r2,-8(fp)
 204b888:	10800317 	ldw	r2,12(r2)
 204b88c:	1004d23a 	srli	r2,r2,8
 204b890:	11003fcc 	andi	r4,r2,255
 204b894:	e0bffe17 	ldw	r2,-8(fp)
 204b898:	10800317 	ldw	r2,12(r2)
 204b89c:	1004923a 	slli	r2,r2,8
 204b8a0:	10bfffcc 	andi	r2,r2,65535
 204b8a4:	2084b03a 	or	r2,r4,r2
 204b8a8:	1004d23a 	srli	r2,r2,8
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 204b8ac:	10803fcc 	andi	r2,r2,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 204b8b0:	e13ffe17 	ldw	r4,-8(fp)
 204b8b4:	21000317 	ldw	r4,12(r4)
 204b8b8:	2008d23a 	srli	r4,r4,8
 204b8bc:	21803fcc 	andi	r6,r4,255
 204b8c0:	e13ffe17 	ldw	r4,-8(fp)
 204b8c4:	21000317 	ldw	r4,12(r4)
 204b8c8:	2008923a 	slli	r4,r4,8
 204b8cc:	213fffcc 	andi	r4,r4,65535
 204b8d0:	3108b03a 	or	r4,r6,r4
 204b8d4:	2008d43a 	srli	r4,r4,16
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 204b8d8:	21803fcc 	andi	r6,r4,255
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
 204b8dc:	e13ffe17 	ldw	r4,-8(fp)
 204b8e0:	21000317 	ldw	r4,12(r4)
 204b8e4:	2008d23a 	srli	r4,r4,8
 204b8e8:	21c03fcc 	andi	r7,r4,255
 204b8ec:	e13ffe17 	ldw	r4,-8(fp)
 204b8f0:	21000317 	ldw	r4,12(r4)
 204b8f4:	2008923a 	slli	r4,r4,8
 204b8f8:	213fffcc 	andi	r4,r4,65535
 204b8fc:	3908b03a 	or	r4,r7,r4
 204b900:	2008d63a 	srli	r4,r4,24
   int i;
   u_char icmp_pkt_len;

#ifdef NPDEBUG
   if (NDEBUG & PROTERR)
      dprintf("icmp: sending ICMP Time Exceeded with code %u to %u.%u.%u.%u\n",
 204b904:	d9800015 	stw	r6,0(sp)
 204b908:	d9000115 	stw	r4,4(sp)
 204b90c:	01008174 	movhi	r4,517
 204b910:	21085204 	addi	r4,r4,8520
 204b914:	180d883a 	mov	r6,r3
 204b918:	100f883a 	mov	r7,r2
 204b91c:	2006a240 	call	2006a24 <printf>
       code, PUSH_IPADDR((ntohs(ip->ip_src))));
#endif   /* NPDEBUG */

   icmp_pkt_len = ICMPTIMEX_HDR_LEN + ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN;
 204b920:	e0bffe17 	ldw	r2,-8(fp)
 204b924:	10800003 	ldbu	r2,0(r2)
 204b928:	108003cc 	andi	r2,r2,15
 204b92c:	1085883a 	add	r2,r2,r2
 204b930:	1085883a 	add	r2,r2,r2
 204b934:	10800404 	addi	r2,r2,16
 204b938:	e0bff905 	stb	r2,-28(fp)
   LOCK_NET_RESOURCE(FREEQ_RESID);
 204b93c:	01000084 	movi	r4,2
 204b940:	20288980 	call	2028898 <LOCK_NET_RESOURCE>
    * length of the "outer" IP header, length of the ICMP header (ICMPTIMEX_HDR_LEN,
    * 8 bytes), length of the "inner" IP header, and length of "user" data 
    * (ICMPTIMEX_PAYLOAD_DATA_LEN, 8 bytes) (just past the "inner" IP header).  The 
    * latter two items are from the packet that the ICMP Time Exceeded message is 
    * being sent in response to. */
   p = pk_alloc(MaxLnh + IPHSIZ + icmp_pkt_len);
 204b944:	e0fff903 	ldbu	r3,-28(fp)
 204b948:	00808174 	movhi	r2,517
 204b94c:	1090b004 	addi	r2,r2,17088
 204b950:	10800017 	ldw	r2,0(r2)
 204b954:	1885883a 	add	r2,r3,r2
 204b958:	10800504 	addi	r2,r2,20
 204b95c:	1009883a 	mov	r4,r2
 204b960:	2027cec0 	call	2027cec <pk_alloc>
 204b964:	e0bffa15 	stw	r2,-24(fp)
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
 204b968:	01000084 	movi	r4,2
 204b96c:	202895c0 	call	202895c <UNLOCK_NET_RESOURCE>

   if (p == NULL)
 204b970:	e0bffa17 	ldw	r2,-24(fp)
 204b974:	1000101e 	bne	r2,zero,204b9b8 <icmp_timex+0x190>
   {
#ifdef NPDEBUG
      if (NDEBUG & IPTRACE)
 204b978:	00808174 	movhi	r2,517
 204b97c:	1090b204 	addi	r2,r2,17096
 204b980:	10800017 	ldw	r2,0(r2)
 204b984:	1080800c 	andi	r2,r2,512
 204b988:	10000326 	beq	r2,zero,204b998 <icmp_timex+0x170>
         dprintf("icmp: can't alloc pkt\n");
 204b98c:	01008174 	movhi	r4,517
 204b990:	21084304 	addi	r4,r4,8460
 204b994:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG */
      icmp_mib.icmpOutErrors++;
 204b998:	00809934 	movhi	r2,612
 204b99c:	10b7f104 	addi	r2,r2,-8252
 204b9a0:	10800e17 	ldw	r2,56(r2)
 204b9a4:	10c00044 	addi	r3,r2,1
 204b9a8:	00809934 	movhi	r2,612
 204b9ac:	10b7f104 	addi	r2,r2,-8252
 204b9b0:	10c00e15 	stw	r3,56(r2)
      return;
 204b9b4:	00006606 	br	204bb50 <icmp_timex+0x328>
   }

   /* build the addresses in the IP header */
   pip = (struct ip *)p->nb_prot;
 204b9b8:	e0bffa17 	ldw	r2,-24(fp)
 204b9bc:	10800317 	ldw	r2,12(r2)
 204b9c0:	e0bffb15 	stw	r2,-20(fp)
   /* source IP address of packet is our address (i.e., destination IP address 
    * in the datagram whose reassembly timed out) */
   pip->ip_src = ip->ip_dest;
 204b9c4:	e0bffe17 	ldw	r2,-8(fp)
 204b9c8:	10c00417 	ldw	r3,16(r2)
 204b9cc:	e0bffb17 	ldw	r2,-20(fp)
 204b9d0:	10c00315 	stw	r3,12(r2)
   /* the destination address is the same as the source IP address of the 
    * datagram whose reassembly timed out */
   pip->ip_dest = ip->ip_src;
 204b9d4:	e0bffe17 	ldw	r2,-8(fp)
 204b9d8:	10c00317 	ldw	r3,12(r2)
 204b9dc:	e0bffb17 	ldw	r2,-20(fp)
 204b9e0:	10c00415 	stw	r3,16(r2)

   /* move past space for IP header to get to start of ICMP header */
   p->nb_prot += sizeof(struct ip);
 204b9e4:	e0bffa17 	ldw	r2,-24(fp)
 204b9e8:	10800317 	ldw	r2,12(r2)
 204b9ec:	10c00504 	addi	r3,r2,20
 204b9f0:	e0bffa17 	ldw	r2,-24(fp)
 204b9f4:	10c00315 	stw	r3,12(r2)

   tx = (struct timex *) p->nb_prot;
 204b9f8:	e0bffa17 	ldw	r2,-24(fp)
 204b9fc:	10800317 	ldw	r2,12(r2)
 204ba00:	e0bffc15 	stw	r2,-16(fp)

   tx->ttype = TIMEX;
 204ba04:	e0bffc17 	ldw	r2,-16(fp)
 204ba08:	00c002c4 	movi	r3,11
 204ba0c:	10c00005 	stb	r3,0(r2)
   tx->tcode = code;
 204ba10:	e0bffc17 	ldw	r2,-16(fp)
 204ba14:	e0ffff03 	ldbu	r3,-4(fp)
 204ba18:	10c00045 	stb	r3,1(r2)
   tx->tno1 = tx->tno2 = 0;
 204ba1c:	e0bffc17 	ldw	r2,-16(fp)
 204ba20:	1000018d 	sth	zero,6(r2)
 204ba24:	e0bffc17 	ldw	r2,-16(fp)
 204ba28:	10c0018b 	ldhu	r3,6(r2)
 204ba2c:	e0bffc17 	ldw	r2,-16(fp)
 204ba30:	10c0010d 	sth	r3,4(r2)
   MEMCPY(&tx->tip, ip, (ip_hlen(ip) + ICMPTIMEX_PAYLOAD_DATA_LEN));
 204ba34:	e0bffc17 	ldw	r2,-16(fp)
 204ba38:	10c00204 	addi	r3,r2,8
 204ba3c:	e0bffe17 	ldw	r2,-8(fp)
 204ba40:	10800003 	ldbu	r2,0(r2)
 204ba44:	10803fcc 	andi	r2,r2,255
 204ba48:	108003cc 	andi	r2,r2,15
 204ba4c:	1085883a 	add	r2,r2,r2
 204ba50:	1085883a 	add	r2,r2,r2
 204ba54:	10800204 	addi	r2,r2,8
 204ba58:	1809883a 	mov	r4,r3
 204ba5c:	e17ffe17 	ldw	r5,-8(fp)
 204ba60:	100d883a 	mov	r6,r2
 204ba64:	200660c0 	call	200660c <memcpy>

   tx->tchksum = 0;
 204ba68:	e0bffc17 	ldw	r2,-16(fp)
 204ba6c:	1000008d 	sth	zero,2(r2)
   tx->tchksum = ~cksum(tx, (icmp_pkt_len>>1));
 204ba70:	e0bff903 	ldbu	r2,-28(fp)
 204ba74:	1004d07a 	srli	r2,r2,1
 204ba78:	10803fcc 	andi	r2,r2,255
 204ba7c:	e13ffc17 	ldw	r4,-16(fp)
 204ba80:	100b883a 	mov	r5,r2
 204ba84:	20268040 	call	2026804 <cksum>
 204ba88:	0084303a 	nor	r2,zero,r2
 204ba8c:	1007883a 	mov	r3,r2
 204ba90:	e0bffc17 	ldw	r2,-16(fp)
 204ba94:	10c0008d 	sth	r3,2(r2)

   p->nb_plen = icmp_pkt_len;
 204ba98:	e0fff903 	ldbu	r3,-28(fp)
 204ba9c:	e0bffa17 	ldw	r2,-24(fp)
 204baa0:	10c00415 	stw	r3,16(r2)
   /* p->fhost is expected to be in network byte order */
   p->fhost = pip->ip_dest;
 204baa4:	e0bffb17 	ldw	r2,-20(fp)
 204baa8:	10c00417 	ldw	r3,16(r2)
 204baac:	e0bffa17 	ldw	r2,-24(fp)
 204bab0:	10c00715 	stw	r3,28(r2)
   i = ip_write(ICMP_PROT, p);
 204bab4:	01000044 	movi	r4,1
 204bab8:	e17ffa17 	ldw	r5,-24(fp)
 204babc:	203fd780 	call	203fd78 <ip_write>
 204bac0:	e0bffd15 	stw	r2,-12(fp)
   if (i < 0)
 204bac4:	e0bffd17 	ldw	r2,-12(fp)
 204bac8:	1000100e 	bge	r2,zero,204bb0c <icmp_timex+0x2e4>
   {
      icmp_mib.icmpOutErrors++;
 204bacc:	00809934 	movhi	r2,612
 204bad0:	10b7f104 	addi	r2,r2,-8252
 204bad4:	10800e17 	ldw	r2,56(r2)
 204bad8:	10c00044 	addi	r3,r2,1
 204badc:	00809934 	movhi	r2,612
 204bae0:	10b7f104 	addi	r2,r2,-8252
 204bae4:	10c00e15 	stw	r3,56(r2)
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
 204bae8:	00808174 	movhi	r2,517
 204baec:	1090b204 	addi	r2,r2,17096
 204baf0:	10800017 	ldw	r2,0(r2)
 204baf4:	1080860c 	andi	r2,r2,536
 204baf8:	10001426 	beq	r2,zero,204bb4c <icmp_timex+0x324>
         dprintf("ICMP: Can't send Time Exceeded\n");
 204bafc:	01008174 	movhi	r4,517
 204bb00:	21086204 	addi	r4,r4,8584
 204bb04:	2006cb40 	call	2006cb4 <puts>
#endif   /* NPDEBUG  */
      return;
 204bb08:	00001006 	br	204bb4c <icmp_timex+0x324>
   }
   icmp_mib.icmpOutMsgs++;
 204bb0c:	00809934 	movhi	r2,612
 204bb10:	10b7f104 	addi	r2,r2,-8252
 204bb14:	10800d17 	ldw	r2,52(r2)
 204bb18:	10c00044 	addi	r3,r2,1
 204bb1c:	00809934 	movhi	r2,612
 204bb20:	10b7f104 	addi	r2,r2,-8252
 204bb24:	10c00d15 	stw	r3,52(r2)
   icmp_mib.icmpOutTimeExcds++;
 204bb28:	00809934 	movhi	r2,612
 204bb2c:	10b7f104 	addi	r2,r2,-8252
 204bb30:	10801017 	ldw	r2,64(r2)
 204bb34:	10c00044 	addi	r3,r2,1
 204bb38:	00809934 	movhi	r2,612
 204bb3c:	10b7f104 	addi	r2,r2,-8252
 204bb40:	10c01015 	stw	r3,64(r2)
   return;
 204bb44:	0001883a 	nop
 204bb48:	00000106 	br	204bb50 <icmp_timex+0x328>
      icmp_mib.icmpOutErrors++;
#ifdef   NPDEBUG
      if (NDEBUG & (IPTRACE|NETERR|PROTERR))
         dprintf("ICMP: Can't send Time Exceeded\n");
#endif   /* NPDEBUG  */
      return;
 204bb4c:	0001883a 	nop
   }
   icmp_mib.icmpOutMsgs++;
   icmp_mib.icmpOutTimeExcds++;
   return;
}
 204bb50:	e037883a 	mov	sp,fp
 204bb54:	dfc00117 	ldw	ra,4(sp)
 204bb58:	df000017 	ldw	fp,0(sp)
 204bb5c:	dec00204 	addi	sp,sp,8
 204bb60:	f800283a 	ret

0204bb64 <icmp_du>:
 * RETURNS: void
 */

void  
icmp_du(PACKET p, struct destun * pdp)
{
 204bb64:	defffc04 	addi	sp,sp,-16
 204bb68:	dfc00315 	stw	ra,12(sp)
 204bb6c:	df000215 	stw	fp,8(sp)
 204bb70:	df000204 	addi	fp,sp,8
 204bb74:	e13ffe15 	stw	r4,-8(fp)
 204bb78:	e17fff15 	stw	r5,-4(fp)
   /* see if user app wants notification first */
   if (icmpdu_hook)
 204bb7c:	d0a0d317 	ldw	r2,-31924(gp)
 204bb80:	10000426 	beq	r2,zero,204bb94 <icmp_du+0x30>
      icmpdu_hook(p, pdp);
 204bb84:	d0a0d317 	ldw	r2,-31924(gp)
 204bb88:	e13ffe17 	ldw	r4,-8(fp)
 204bb8c:	e17fff17 	ldw	r5,-4(fp)
 204bb90:	103ee83a 	callr	r2

#ifdef INCLUDE_TCP
   /* Tell the sockets layer so it can correct the problem. */
   so_icmpdu(p, pdp);   /* this call should free packet p */
 204bb94:	e13ffe17 	ldw	r4,-8(fp)
 204bb98:	e17fff17 	ldw	r5,-4(fp)
 204bb9c:	202a70c0 	call	202a70c <so_icmpdu>
done:
   LOCK_NET_RESOURCE(FREEQ_RESID);
   pk_free(p); /* else just free packet */
   UNLOCK_NET_RESOURCE(FREEQ_RESID);
#endif   /* INCLUDE_TCP */
}
 204bba0:	e037883a 	mov	sp,fp
 204bba4:	dfc00117 	ldw	ra,4(sp)
 204bba8:	df000017 	ldw	fp,0(sp)
 204bbac:	dec00204 	addi	sp,sp,8
 204bbb0:	f800283a 	ret

0204bbb4 <alt_busy_sleep>:
#include "alt_types.h"

#include "priv/alt_busy_sleep.h"

unsigned int alt_busy_sleep (unsigned int us)
{
 204bbb4:	defffb04 	addi	sp,sp,-20
 204bbb8:	df000415 	stw	fp,16(sp)
 204bbbc:	df000404 	addi	fp,sp,16
 204bbc0:	e13fff15 	stw	r4,-4(fp)
  {
    cycles_per_loop = 9;
  }
  else  
  {
    cycles_per_loop = 3;
 204bbc4:	008000c4 	movi	r2,3
 204bbc8:	e0bffd15 	stw	r2,-12(fp)
  }
  

  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));
 204bbcc:	e0fffd17 	ldw	r3,-12(fp)
 204bbd0:	008003f4 	movhi	r2,15
 204bbd4:	10909004 	addi	r2,r2,16960
 204bbd8:	1885383a 	mul	r2,r3,r2
 204bbdc:	00c17db4 	movhi	r3,1526
 204bbe0:	18f84004 	addi	r3,r3,-7936
 204bbe4:	1885203a 	divu	r2,r3,r2
  {
    cycles_per_loop = 3;
  }
  

  big_loops = us / (INT_MAX/
 204bbe8:	00e00034 	movhi	r3,32768
 204bbec:	18ffffc4 	addi	r3,r3,-1
 204bbf0:	1885203a 	divu	r2,r3,r2
 204bbf4:	e0ffff17 	ldw	r3,-4(fp)
 204bbf8:	1885203a 	divu	r2,r3,r2
 204bbfc:	e0bffe15 	stw	r2,-8(fp)
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
 204bc00:	e0bffe17 	ldw	r2,-8(fp)
 204bc04:	10002526 	beq	r2,zero,204bc9c <alt_busy_sleep+0xe8>
  {
    for(i=0;i<big_loops;i++)
 204bc08:	e03ffc15 	stw	zero,-16(fp)
 204bc0c:	00001406 	br	204bc60 <alt_busy_sleep+0xac>
      /*
      * Do NOT Try to single step the asm statement below 
      * (single step will never return)
      * Step out of this function or set a breakpoint after the asm statements
      */
      __asm__ volatile (
 204bc10:	00a00034 	movhi	r2,32768
 204bc14:	10bfffc4 	addi	r2,r2,-1
 204bc18:	10bfffc4 	addi	r2,r2,-1
 204bc1c:	103ffe1e 	bne	r2,zero,204bc18 <alt_busy_sleep+0x64>
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
      (cycles_per_loop * 1000000)));
 204bc20:	e0fffd17 	ldw	r3,-12(fp)
 204bc24:	008003f4 	movhi	r2,15
 204bc28:	10909004 	addi	r2,r2,16960
 204bc2c:	1885383a 	mul	r2,r3,r2
        "\n1:"
        "\n\t.pushsection .debug_alt_sim_info"
        "\n\t.int 4, 0, 0b, 1b"
        "\n\t.popsection"
        :: "r" (INT_MAX));
      us -= (INT_MAX/(ALT_CPU_FREQ/
 204bc30:	00c17db4 	movhi	r3,1526
 204bc34:	18f84004 	addi	r3,r3,-7936
 204bc38:	1885203a 	divu	r2,r3,r2
 204bc3c:	00e00034 	movhi	r3,32768
 204bc40:	18ffffc4 	addi	r3,r3,-1
 204bc44:	1885203a 	divu	r2,r3,r2
 204bc48:	e0ffff17 	ldw	r3,-4(fp)
 204bc4c:	1885c83a 	sub	r2,r3,r2
 204bc50:	e0bfff15 	stw	r2,-4(fp)
  big_loops = us / (INT_MAX/
  (ALT_CPU_FREQ/(cycles_per_loop * 1000000)));

  if (big_loops)
  {
    for(i=0;i<big_loops;i++)
 204bc54:	e0bffc17 	ldw	r2,-16(fp)
 204bc58:	10800044 	addi	r2,r2,1
 204bc5c:	e0bffc15 	stw	r2,-16(fp)
 204bc60:	e0fffc17 	ldw	r3,-16(fp)
 204bc64:	e0bffe17 	ldw	r2,-8(fp)
 204bc68:	18bfe916 	blt	r3,r2,204bc10 <alt_busy_sleep+0x5c>
      "\n\tbne %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 204bc6c:	e0fffd17 	ldw	r3,-12(fp)
 204bc70:	008003f4 	movhi	r2,15
 204bc74:	10909004 	addi	r2,r2,16960
 204bc78:	1885383a 	mul	r2,r3,r2
 204bc7c:	00c17db4 	movhi	r3,1526
 204bc80:	18f84004 	addi	r3,r3,-7936
 204bc84:	1887203a 	divu	r3,r3,r2
 204bc88:	e0bfff17 	ldw	r2,-4(fp)
 204bc8c:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 204bc90:	10bfffc4 	addi	r2,r2,-1
 204bc94:	103ffe1e 	bne	r2,zero,204bc90 <alt_busy_sleep+0xdc>
 204bc98:	00000b06 	br	204bcc8 <alt_busy_sleep+0x114>
      "\n\tbgt %0,zero,0b"
      "\n1:"
      "\n\t.pushsection .debug_alt_sim_info"
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
 204bc9c:	e0fffd17 	ldw	r3,-12(fp)
 204bca0:	008003f4 	movhi	r2,15
 204bca4:	10909004 	addi	r2,r2,16960
 204bca8:	1885383a 	mul	r2,r3,r2
 204bcac:	00c17db4 	movhi	r3,1526
 204bcb0:	18f84004 	addi	r3,r3,-7936
 204bcb4:	1887203a 	divu	r3,r3,r2
 204bcb8:	e0bfff17 	ldw	r2,-4(fp)
 204bcbc:	1885383a 	mul	r2,r3,r2
    /*
    * Do NOT Try to single step the asm statement below 
    * (single step will never return)
    * Step out of this function or set a breakpoint after the asm statements
    */
    __asm__ volatile (
 204bcc0:	10bfffc4 	addi	r2,r2,-1
 204bcc4:	00bffe16 	blt	zero,r2,204bcc0 <alt_busy_sleep+0x10c>
      "\n\t.int 4, 0, 0b, 1b"
      "\n\t.popsection"
      :: "r" (us*(ALT_CPU_FREQ/(cycles_per_loop * 1000000))));
  }
#endif /* #ifndef ALT_SIM_OPTIMIZE */
  return 0;
 204bcc8:	0005883a 	mov	r2,zero
}
 204bccc:	e037883a 	mov	sp,fp
 204bcd0:	df000017 	ldw	fp,0(sp)
 204bcd4:	dec00104 	addi	sp,sp,4
 204bcd8:	f800283a 	ret

0204bcdc <atexit>:
 204bcdc:	200b883a 	mov	r5,r4
 204bce0:	000d883a 	mov	r6,zero
 204bce4:	0009883a 	mov	r4,zero
 204bce8:	000f883a 	mov	r7,zero
 204bcec:	204be141 	jmpi	204be14 <__register_exitproc>

0204bcf0 <calloc>:
 204bcf0:	00c08174 	movhi	r3,517
 204bcf4:	18d03604 	addi	r3,r3,16600
 204bcf8:	2005883a 	mov	r2,r4
 204bcfc:	19000017 	ldw	r4,0(r3)
 204bd00:	280d883a 	mov	r6,r5
 204bd04:	100b883a 	mov	r5,r2
 204bd08:	2011f1c1 	jmpi	2011f1c <_calloc_r>

0204bd0c <exit>:
 204bd0c:	defffe04 	addi	sp,sp,-8
 204bd10:	000b883a 	mov	r5,zero
 204bd14:	dc000015 	stw	r16,0(sp)
 204bd18:	dfc00115 	stw	ra,4(sp)
 204bd1c:	2021883a 	mov	r16,r4
 204bd20:	204bf440 	call	204bf44 <__call_exitprocs>
 204bd24:	00808174 	movhi	r2,517
 204bd28:	10903504 	addi	r2,r2,16596
 204bd2c:	11000017 	ldw	r4,0(r2)
 204bd30:	20800f17 	ldw	r2,60(r4)
 204bd34:	10000126 	beq	r2,zero,204bd3c <exit+0x30>
 204bd38:	103ee83a 	callr	r2
 204bd3c:	8009883a 	mov	r4,r16
 204bd40:	204c0e40 	call	204c0e4 <_exit>

0204bd44 <malloc>:
 204bd44:	00808174 	movhi	r2,517
 204bd48:	10903604 	addi	r2,r2,16600
 204bd4c:	200b883a 	mov	r5,r4
 204bd50:	11000017 	ldw	r4,0(r2)
 204bd54:	2005e881 	jmpi	2005e88 <_malloc_r>

0204bd58 <free>:
 204bd58:	00808174 	movhi	r2,517
 204bd5c:	10903604 	addi	r2,r2,16600
 204bd60:	200b883a 	mov	r5,r4
 204bd64:	11000017 	ldw	r4,0(r2)
 204bd68:	20050b41 	jmpi	20050b4 <_free_r>

0204bd6c <vprintf>:
 204bd6c:	00808174 	movhi	r2,517
 204bd70:	10903604 	addi	r2,r2,16600
 204bd74:	10800017 	ldw	r2,0(r2)
 204bd78:	280f883a 	mov	r7,r5
 204bd7c:	200d883a 	mov	r6,r4
 204bd80:	11400217 	ldw	r5,8(r2)
 204bd84:	1009883a 	mov	r4,r2
 204bd88:	2008a301 	jmpi	2008a30 <___vfprintf_internal_r>

0204bd8c <_vprintf_r>:
 204bd8c:	2805883a 	mov	r2,r5
 204bd90:	21400217 	ldw	r5,8(r4)
 204bd94:	300f883a 	mov	r7,r6
 204bd98:	100d883a 	mov	r6,r2
 204bd9c:	2008a301 	jmpi	2008a30 <___vfprintf_internal_r>

0204bda0 <_vsprintf_r>:
 204bda0:	deffe804 	addi	sp,sp,-96
 204bda4:	00a00034 	movhi	r2,32768
 204bda8:	10bfffc4 	addi	r2,r2,-1
 204bdac:	2807883a 	mov	r3,r5
 204bdb0:	02008204 	movi	r8,520
 204bdb4:	d8800215 	stw	r2,8(sp)
 204bdb8:	d8800515 	stw	r2,20(sp)
 204bdbc:	d80b883a 	mov	r5,sp
 204bdc0:	00bfffc4 	movi	r2,-1
 204bdc4:	d8c00015 	stw	r3,0(sp)
 204bdc8:	d8c00415 	stw	r3,16(sp)
 204bdcc:	dfc01715 	stw	ra,92(sp)
 204bdd0:	da00030d 	sth	r8,12(sp)
 204bdd4:	d880038d 	sth	r2,14(sp)
 204bdd8:	2008a300 	call	2008a30 <___vfprintf_internal_r>
 204bddc:	d8c00017 	ldw	r3,0(sp)
 204bde0:	18000005 	stb	zero,0(r3)
 204bde4:	dfc01717 	ldw	ra,92(sp)
 204bde8:	dec01804 	addi	sp,sp,96
 204bdec:	f800283a 	ret

0204bdf0 <vsprintf>:
 204bdf0:	00808174 	movhi	r2,517
 204bdf4:	10903604 	addi	r2,r2,16600
 204bdf8:	2007883a 	mov	r3,r4
 204bdfc:	11000017 	ldw	r4,0(r2)
 204be00:	2805883a 	mov	r2,r5
 204be04:	300f883a 	mov	r7,r6
 204be08:	180b883a 	mov	r5,r3
 204be0c:	100d883a 	mov	r6,r2
 204be10:	204bda01 	jmpi	204bda0 <_vsprintf_r>

0204be14 <__register_exitproc>:
 204be14:	defffa04 	addi	sp,sp,-24
 204be18:	00808174 	movhi	r2,517
 204be1c:	10903504 	addi	r2,r2,16596
 204be20:	dc000315 	stw	r16,12(sp)
 204be24:	14000017 	ldw	r16,0(r2)
 204be28:	dc400415 	stw	r17,16(sp)
 204be2c:	dfc00515 	stw	ra,20(sp)
 204be30:	80805217 	ldw	r2,328(r16)
 204be34:	2023883a 	mov	r17,r4
 204be38:	10003e26 	beq	r2,zero,204bf34 <__register_exitproc+0x120>
 204be3c:	10c00117 	ldw	r3,4(r2)
 204be40:	020007c4 	movi	r8,31
 204be44:	40c0180e 	bge	r8,r3,204bea8 <__register_exitproc+0x94>
 204be48:	00808174 	movhi	r2,517
 204be4c:	10af5104 	addi	r2,r2,-17084
 204be50:	1000061e 	bne	r2,zero,204be6c <__register_exitproc+0x58>
 204be54:	00bfffc4 	movi	r2,-1
 204be58:	dfc00517 	ldw	ra,20(sp)
 204be5c:	dc400417 	ldw	r17,16(sp)
 204be60:	dc000317 	ldw	r16,12(sp)
 204be64:	dec00604 	addi	sp,sp,24
 204be68:	f800283a 	ret
 204be6c:	01006404 	movi	r4,400
 204be70:	d9400015 	stw	r5,0(sp)
 204be74:	d9800115 	stw	r6,4(sp)
 204be78:	d9c00215 	stw	r7,8(sp)
 204be7c:	204bd440 	call	204bd44 <malloc>
 204be80:	d9400017 	ldw	r5,0(sp)
 204be84:	d9800117 	ldw	r6,4(sp)
 204be88:	d9c00217 	ldw	r7,8(sp)
 204be8c:	103ff126 	beq	r2,zero,204be54 <__register_exitproc+0x40>
 204be90:	80c05217 	ldw	r3,328(r16)
 204be94:	10000115 	stw	zero,4(r2)
 204be98:	10c00015 	stw	r3,0(r2)
 204be9c:	80805215 	stw	r2,328(r16)
 204bea0:	10006215 	stw	zero,392(r2)
 204bea4:	10006315 	stw	zero,396(r2)
 204bea8:	10c00117 	ldw	r3,4(r2)
 204beac:	88000d1e 	bne	r17,zero,204bee4 <__register_exitproc+0xd0>
 204beb0:	19000084 	addi	r4,r3,2
 204beb4:	2109883a 	add	r4,r4,r4
 204beb8:	18c00044 	addi	r3,r3,1
 204bebc:	2109883a 	add	r4,r4,r4
 204bec0:	1109883a 	add	r4,r2,r4
 204bec4:	10c00115 	stw	r3,4(r2)
 204bec8:	0005883a 	mov	r2,zero
 204becc:	21400015 	stw	r5,0(r4)
 204bed0:	dfc00517 	ldw	ra,20(sp)
 204bed4:	dc400417 	ldw	r17,16(sp)
 204bed8:	dc000317 	ldw	r16,12(sp)
 204bedc:	dec00604 	addi	sp,sp,24
 204bee0:	f800283a 	ret
 204bee4:	02400044 	movi	r9,1
 204bee8:	12806217 	ldw	r10,392(r2)
 204beec:	48d2983a 	sll	r9,r9,r3
 204bef0:	19000804 	addi	r4,r3,32
 204bef4:	18d1883a 	add	r8,r3,r3
 204bef8:	2109883a 	add	r4,r4,r4
 204befc:	4211883a 	add	r8,r8,r8
 204bf00:	2109883a 	add	r4,r4,r4
 204bf04:	1109883a 	add	r4,r2,r4
 204bf08:	1211883a 	add	r8,r2,r8
 204bf0c:	5254b03a 	or	r10,r10,r9
 204bf10:	21c02215 	stw	r7,136(r4)
 204bf14:	41802215 	stw	r6,136(r8)
 204bf18:	12806215 	stw	r10,392(r2)
 204bf1c:	01000084 	movi	r4,2
 204bf20:	893fe31e 	bne	r17,r4,204beb0 <__register_exitproc+0x9c>
 204bf24:	11006317 	ldw	r4,396(r2)
 204bf28:	2252b03a 	or	r9,r4,r9
 204bf2c:	12406315 	stw	r9,396(r2)
 204bf30:	003fdf06 	br	204beb0 <__register_exitproc+0x9c>
 204bf34:	00809934 	movhi	r2,612
 204bf38:	10b80b04 	addi	r2,r2,-8148
 204bf3c:	80805215 	stw	r2,328(r16)
 204bf40:	003fbe06 	br	204be3c <__register_exitproc+0x28>

0204bf44 <__call_exitprocs>:
 204bf44:	00808174 	movhi	r2,517
 204bf48:	10903504 	addi	r2,r2,16596
 204bf4c:	10800017 	ldw	r2,0(r2)
 204bf50:	defff304 	addi	sp,sp,-52
 204bf54:	df000b15 	stw	fp,44(sp)
 204bf58:	d8800015 	stw	r2,0(sp)
 204bf5c:	10805204 	addi	r2,r2,328
 204bf60:	dd400815 	stw	r21,32(sp)
 204bf64:	dfc00c15 	stw	ra,48(sp)
 204bf68:	ddc00a15 	stw	r23,40(sp)
 204bf6c:	dd800915 	stw	r22,36(sp)
 204bf70:	dd000715 	stw	r20,28(sp)
 204bf74:	dcc00615 	stw	r19,24(sp)
 204bf78:	dc800515 	stw	r18,20(sp)
 204bf7c:	dc400415 	stw	r17,16(sp)
 204bf80:	dc000315 	stw	r16,12(sp)
 204bf84:	d9000115 	stw	r4,4(sp)
 204bf88:	2839883a 	mov	fp,r5
 204bf8c:	d8800215 	stw	r2,8(sp)
 204bf90:	057fffc4 	movi	r21,-1
 204bf94:	d8800017 	ldw	r2,0(sp)
 204bf98:	ddc00217 	ldw	r23,8(sp)
 204bf9c:	14805217 	ldw	r18,328(r2)
 204bfa0:	90001726 	beq	r18,zero,204c000 <__call_exitprocs+0xbc>
 204bfa4:	94400117 	ldw	r17,4(r18)
 204bfa8:	8c3fffc4 	addi	r16,r17,-1
 204bfac:	80001116 	blt	r16,zero,204bff4 <__call_exitprocs+0xb0>
 204bfb0:	8c400044 	addi	r17,r17,1
 204bfb4:	8427883a 	add	r19,r16,r16
 204bfb8:	8c63883a 	add	r17,r17,r17
 204bfbc:	95802204 	addi	r22,r18,136
 204bfc0:	9ce7883a 	add	r19,r19,r19
 204bfc4:	8c63883a 	add	r17,r17,r17
 204bfc8:	b4e7883a 	add	r19,r22,r19
 204bfcc:	9463883a 	add	r17,r18,r17
 204bfd0:	e0001726 	beq	fp,zero,204c030 <__call_exitprocs+0xec>
 204bfd4:	8c87c83a 	sub	r3,r17,r18
 204bfd8:	b0c7883a 	add	r3,r22,r3
 204bfdc:	18c01e17 	ldw	r3,120(r3)
 204bfe0:	1f001326 	beq	r3,fp,204c030 <__call_exitprocs+0xec>
 204bfe4:	843fffc4 	addi	r16,r16,-1
 204bfe8:	9cffff04 	addi	r19,r19,-4
 204bfec:	8c7fff04 	addi	r17,r17,-4
 204bff0:	857ff71e 	bne	r16,r21,204bfd0 <__call_exitprocs+0x8c>
 204bff4:	00808174 	movhi	r2,517
 204bff8:	10af5604 	addi	r2,r2,-17064
 204bffc:	10002a1e 	bne	r2,zero,204c0a8 <__call_exitprocs+0x164>
 204c000:	dfc00c17 	ldw	ra,48(sp)
 204c004:	df000b17 	ldw	fp,44(sp)
 204c008:	ddc00a17 	ldw	r23,40(sp)
 204c00c:	dd800917 	ldw	r22,36(sp)
 204c010:	dd400817 	ldw	r21,32(sp)
 204c014:	dd000717 	ldw	r20,28(sp)
 204c018:	dcc00617 	ldw	r19,24(sp)
 204c01c:	dc800517 	ldw	r18,20(sp)
 204c020:	dc400417 	ldw	r17,16(sp)
 204c024:	dc000317 	ldw	r16,12(sp)
 204c028:	dec00d04 	addi	sp,sp,52
 204c02c:	f800283a 	ret
 204c030:	91000117 	ldw	r4,4(r18)
 204c034:	88c00017 	ldw	r3,0(r17)
 204c038:	213fffc4 	addi	r4,r4,-1
 204c03c:	24001526 	beq	r4,r16,204c094 <__call_exitprocs+0x150>
 204c040:	88000015 	stw	zero,0(r17)
 204c044:	183fe726 	beq	r3,zero,204bfe4 <__call_exitprocs+0xa0>
 204c048:	00800044 	movi	r2,1
 204c04c:	1408983a 	sll	r4,r2,r16
 204c050:	91406217 	ldw	r5,392(r18)
 204c054:	95000117 	ldw	r20,4(r18)
 204c058:	214a703a 	and	r5,r4,r5
 204c05c:	28000b26 	beq	r5,zero,204c08c <__call_exitprocs+0x148>
 204c060:	91406317 	ldw	r5,396(r18)
 204c064:	2148703a 	and	r4,r4,r5
 204c068:	20000c1e 	bne	r4,zero,204c09c <__call_exitprocs+0x158>
 204c06c:	99400017 	ldw	r5,0(r19)
 204c070:	d9000117 	ldw	r4,4(sp)
 204c074:	183ee83a 	callr	r3
 204c078:	90c00117 	ldw	r3,4(r18)
 204c07c:	1d3fc51e 	bne	r3,r20,204bf94 <__call_exitprocs+0x50>
 204c080:	b8c00017 	ldw	r3,0(r23)
 204c084:	1cbfd726 	beq	r3,r18,204bfe4 <__call_exitprocs+0xa0>
 204c088:	003fc206 	br	204bf94 <__call_exitprocs+0x50>
 204c08c:	183ee83a 	callr	r3
 204c090:	003ff906 	br	204c078 <__call_exitprocs+0x134>
 204c094:	94000115 	stw	r16,4(r18)
 204c098:	003fea06 	br	204c044 <__call_exitprocs+0x100>
 204c09c:	99000017 	ldw	r4,0(r19)
 204c0a0:	183ee83a 	callr	r3
 204c0a4:	003ff406 	br	204c078 <__call_exitprocs+0x134>
 204c0a8:	90c00117 	ldw	r3,4(r18)
 204c0ac:	1800071e 	bne	r3,zero,204c0cc <__call_exitprocs+0x188>
 204c0b0:	90c00017 	ldw	r3,0(r18)
 204c0b4:	18000926 	beq	r3,zero,204c0dc <__call_exitprocs+0x198>
 204c0b8:	9009883a 	mov	r4,r18
 204c0bc:	b8c00015 	stw	r3,0(r23)
 204c0c0:	204bd580 	call	204bd58 <free>
 204c0c4:	bc800017 	ldw	r18,0(r23)
 204c0c8:	003fb506 	br	204bfa0 <__call_exitprocs+0x5c>
 204c0cc:	90c00017 	ldw	r3,0(r18)
 204c0d0:	902f883a 	mov	r23,r18
 204c0d4:	1825883a 	mov	r18,r3
 204c0d8:	003fb106 	br	204bfa0 <__call_exitprocs+0x5c>
 204c0dc:	0007883a 	mov	r3,zero
 204c0e0:	003ffb06 	br	204c0d0 <__call_exitprocs+0x18c>

0204c0e4 <_exit>:
 *
 * ALT_EXIT is mapped onto the _exit() system call in alt_syscall.h
 */

void ALT_EXIT (int exit_code)
{
 204c0e4:	defffc04 	addi	sp,sp,-16
 204c0e8:	df000315 	stw	fp,12(sp)
 204c0ec:	df000304 	addi	fp,sp,12
 204c0f0:	e13fff15 	stw	r4,-4(fp)
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Entering _exit() function.\r\n");
  ALT_LOG_PRINT_BOOT("[alt_exit.c] Exit code from main was %d.\r\n",exit_code);
  /* Stop all other threads */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Calling ALT_OS_STOP().\r\n");
  ALT_OS_STOP();
 204c0f4:	00808174 	movhi	r2,517
 204c0f8:	10909b44 	addi	r2,r2,17005
 204c0fc:	10000005 	stb	zero,0(r2)
 204c100:	e0bfff17 	ldw	r2,-4(fp)
 204c104:	e0bffd15 	stw	r2,-12(fp)
/*
 * Routine called on exit.
 */
static ALT_INLINE ALT_ALWAYS_INLINE void alt_sim_halt(int exit_code)
{
  int r2 = exit_code;
 204c108:	e0bffd17 	ldw	r2,-12(fp)
 204c10c:	e0bffe15 	stw	r2,-8(fp)
  __asm__ volatile ("\n0:\n\taddi %0,%0, -1\n\tbgt %0,zero,0b" : : "r" (ALT_CPU_FREQ/100) ); /* Delay for >30ms */

  __asm__ volatile ("break 2" : : "D02"(r2), "D03"(r3) ALT_GMON_DATA );

#else /* !DEBUG_STUB */
  if (r2) {
 204c110:	e0bffe17 	ldw	r2,-8(fp)
 204c114:	10000226 	beq	r2,zero,204c120 <_exit+0x3c>
    ALT_SIM_FAIL();
 204c118:	002af070 	cmpltui	zero,zero,43969
 204c11c:	00000106 	br	204c124 <_exit+0x40>
  } else {
    ALT_SIM_PASS();
 204c120:	002af0b0 	cmpltui	zero,zero,43970
  ALT_SIM_HALT(exit_code);

  /* spin forever, since there's no where to go back to */

  ALT_LOG_PRINT_BOOT("[alt_exit.c] Spinning forever.\r\n");
  while (1);
 204c124:	003fff06 	br	204c124 <_exit+0x40>
